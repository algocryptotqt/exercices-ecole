<thinking>
## Analyse du Concept
- Concept : Saga Orchestrator Pattern
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les Sagas sont essentielles pour les transactions distribuees.
</thinking>

# Exercice 5.6.17-a : saga_orchestrator

**Module :**
5.6.17 — Distributed Transactions - Saga Orchestrator

**Concept :**
a — Saga Orchestrator (transactions distribuees, compensation)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
2 — Concepts composes

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.7 — Outbox Pattern
- 5.6.15 — Idempotency Handler

**Domaines :**
DistributedSystems, Transactions, StateMachine

**Duree estimee :**
150 min

**XP Base :**
200

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `serde` / `serde_json` (serialization)
- `uuid` (identifiants)
- `async-trait` (traits async)

### 1.2 Consigne

**CONTEXTE : "The Transaction Conductor"**

*"Dans un orchestre, le chef coordonne tous les musiciens. Dans un systeme distribue, le Saga Orchestrator coordonne tous les services."* — Le Chef d'Orchestre

Le pattern Saga permet de gerer des transactions distribuees sans 2PC (Two-Phase Commit). L'Orchestrator centralise la logique et coordonne les steps de la saga.

**Ta mission :**

Implementer un `SagaOrchestrator` qui :
1. Execute une sequence de steps transactionnels
2. Compense les steps en cas d'echec (rollback distribue)
3. Persiste l'etat de la saga pour recovery
4. Supporte la reprise apres crash

### 1.3 Prototype

```rust
use uuid::Uuid;
use std::time::Duration;
use async_trait::async_trait;

#[derive(Debug, Clone, PartialEq)]
pub enum SagaState {
    Created,
    Running,
    Completed,
    Compensating,
    Compensated,
    Failed,
}

#[derive(Debug, Clone)]
pub struct SagaDefinition<C: Clone> {
    pub name: String,
    pub steps: Vec<SagaStepDef>,
    pub timeout: Duration,
    _phantom: std::marker::PhantomData<C>,
}

#[derive(Debug, Clone)]
pub struct SagaStepDef {
    pub name: String,
    pub compensatable: bool,
}

#[async_trait]
pub trait SagaStep: Send + Sync {
    type Context: Clone + Send + Sync;
    type Error: std::error::Error + Send + Sync;

    fn name(&self) -> &str;

    async fn execute(&self, ctx: &mut Self::Context) -> Result<(), Self::Error>;
    async fn compensate(&self, ctx: &mut Self::Context) -> Result<(), Self::Error>;
}

#[derive(Debug, Clone)]
pub struct SagaInstance<C: Clone> {
    pub id: Uuid,
    pub definition_name: String,
    pub state: SagaState,
    pub current_step: usize,
    pub context: C,
    pub step_results: Vec<StepResult>,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub enum StepResult {
    Pending,
    Completed,
    Failed(String),
    Compensated,
    CompensationFailed(String),
}

#[async_trait]
pub trait SagaStore<C: Clone + Send + Sync>: Send + Sync {
    async fn save(&self, instance: &SagaInstance<C>) -> Result<(), SagaStoreError>;
    async fn load(&self, id: Uuid) -> Result<Option<SagaInstance<C>>, SagaStoreError>;
    async fn list_incomplete(&self) -> Result<Vec<Uuid>, SagaStoreError>;
}

#[derive(Debug)]
pub enum SagaError {
    StepFailed { step: String, error: String },
    CompensationFailed { step: String, error: String },
    StoreError(String),
    Timeout,
    AlreadyCompleted,
}

pub struct SagaOrchestrator<C: Clone + Send + Sync + 'static> {
    steps: Vec<Box<dyn SagaStep<Context = C, Error = Box<dyn std::error::Error + Send + Sync>>>>,
    store: Box<dyn SagaStore<C>>,
    timeout: Duration,
}

impl<C: Clone + Send + Sync + 'static> SagaOrchestrator<C> {
    pub fn builder(name: &str) -> SagaOrchestratorBuilder<C>;

    /// Demarre une nouvelle saga
    pub async fn start(&self, context: C) -> Result<Uuid, SagaError>;

    /// Reprend une saga interrompue
    pub async fn resume(&self, saga_id: Uuid) -> Result<SagaState, SagaError>;

    /// Execute la saga jusqu'a completion ou echec
    async fn execute_saga(&self, instance: &mut SagaInstance<C>) -> Result<SagaState, SagaError>;

    /// Compense les steps executes
    async fn compensate(&self, instance: &mut SagaInstance<C>) -> Result<(), SagaError>;

    /// Recupere l'etat d'une saga
    pub async fn get_state(&self, saga_id: Uuid) -> Option<SagaInstance<C>>;
}

pub struct SagaOrchestratorBuilder<C: Clone + Send + Sync + 'static> {
    name: String,
    steps: Vec<Box<dyn SagaStep<Context = C, Error = Box<dyn std::error::Error + Send + Sync>>>>,
    store: Option<Box<dyn SagaStore<C>>>,
    timeout: Duration,
}

impl<C: Clone + Send + Sync + 'static> SagaOrchestratorBuilder<C> {
    pub fn step<S: SagaStep<Context = C> + 'static>(self, step: S) -> Self;
    pub fn store<S: SagaStore<C> + 'static>(self, store: S) -> Self;
    pub fn timeout(self, timeout: Duration) -> Self;
    pub fn build(self) -> SagaOrchestrator<C>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Saga vs 2PC

- **2PC (Two-Phase Commit)** : Lock global, bloque tout jusqu'a commit/abort
- **Saga** : Sequence de transactions locales avec compensations

Les Sagas sacrifient l'isolation ACID pour la disponibilite (BASE vs ACID).

### 2.2 Orchestration vs Choreography

- **Orchestration** : Un coordinateur central (le chef d'orchestre)
  - Avantages : Logique centralisee, facile a debugger
  - Inconvenients : Point de failure, couplage

- **Choreography** : Chaque service reagit aux events
  - Avantages : Decouplage, pas de SPOF
  - Inconvenients : Logique distribuee, difficile a suivre

### 2.3 Exemple : Commande E-commerce

```
Saga: CreateOrder
1. CreateOrder -> OrderService
2. ReserveInventory -> InventoryService
3. ProcessPayment -> PaymentService
4. ShipOrder -> ShippingService

Compensation (si etape 3 echoue):
- ReleaseInventory (compensate step 2)
- CancelOrder (compensate step 1)
```

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Clone, Debug)]
    struct OrderContext {
        order_id: String,
        amount: u64,
        inventory_reserved: bool,
        payment_processed: bool,
    }

    struct CreateOrderStep;
    struct ReserveInventoryStep { should_fail: bool }
    struct ProcessPaymentStep { should_fail: bool }

    #[async_trait]
    impl SagaStep for CreateOrderStep {
        type Context = OrderContext;
        type Error = Box<dyn std::error::Error + Send + Sync>;

        fn name(&self) -> &str { "CreateOrder" }

        async fn execute(&self, ctx: &mut Self::Context) -> Result<(), Self::Error> {
            ctx.order_id = Uuid::new_v4().to_string();
            Ok(())
        }

        async fn compensate(&self, ctx: &mut Self::Context) -> Result<(), Self::Error> {
            ctx.order_id.clear();
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_saga_success() {
        let store = InMemorySagaStore::new();
        let orchestrator = SagaOrchestrator::builder("OrderSaga")
            .step(CreateOrderStep)
            .step(ReserveInventoryStep { should_fail: false })
            .step(ProcessPaymentStep { should_fail: false })
            .store(store)
            .build();

        let ctx = OrderContext {
            order_id: String::new(),
            amount: 100,
            inventory_reserved: false,
            payment_processed: false,
        };

        let saga_id = orchestrator.start(ctx).await.unwrap();
        let instance = orchestrator.get_state(saga_id).await.unwrap();

        assert_eq!(instance.state, SagaState::Completed);
    }

    #[tokio::test]
    async fn test_saga_compensation() {
        let store = InMemorySagaStore::new();
        let orchestrator = SagaOrchestrator::builder("OrderSaga")
            .step(CreateOrderStep)
            .step(ReserveInventoryStep { should_fail: false })
            .step(ProcessPaymentStep { should_fail: true }) // Will fail
            .store(store)
            .build();

        let ctx = OrderContext {
            order_id: String::new(),
            amount: 100,
            inventory_reserved: false,
            payment_processed: false,
        };

        let saga_id = orchestrator.start(ctx).await.unwrap();
        let instance = orchestrator.get_state(saga_id).await.unwrap();

        assert_eq!(instance.state, SagaState::Compensated);
        assert!(!instance.context.inventory_reserved); // Compensated
    }

    #[tokio::test]
    async fn test_saga_resume() {
        let store = Arc::new(InMemorySagaStore::new());
        // Simulate crash and resume...
    }
}
```

### 4.3 Solution de reference

```rust
use std::sync::Arc;
use std::time::Duration;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use async_trait::async_trait;
use tokio::sync::RwLock;
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum SagaState {
    Created,
    Running,
    Completed,
    Compensating,
    Compensated,
    Failed,
}

#[derive(Debug, Clone)]
pub enum StepResult {
    Pending,
    Completed,
    Failed(String),
    Compensated,
    CompensationFailed(String),
}

#[derive(Debug, Clone)]
pub struct SagaInstance<C: Clone> {
    pub id: Uuid,
    pub definition_name: String,
    pub state: SagaState,
    pub current_step: usize,
    pub context: C,
    pub step_results: Vec<StepResult>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug)]
pub enum SagaError {
    StepFailed { step: String, error: String },
    CompensationFailed { step: String, error: String },
    StoreError(String),
    Timeout,
    AlreadyCompleted,
}

impl std::fmt::Display for SagaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::StepFailed { step, error } => write!(f, "Step '{}' failed: {}", step, error),
            Self::CompensationFailed { step, error } => {
                write!(f, "Compensation of '{}' failed: {}", step, error)
            }
            Self::StoreError(e) => write!(f, "Store error: {}", e),
            Self::Timeout => write!(f, "Saga timeout"),
            Self::AlreadyCompleted => write!(f, "Saga already completed"),
        }
    }
}

impl std::error::Error for SagaError {}

#[derive(Debug)]
pub struct SagaStoreError(pub String);

#[async_trait]
pub trait SagaStep: Send + Sync {
    type Context: Clone + Send + Sync;
    type Error: std::error::Error + Send + Sync;

    fn name(&self) -> &str;
    async fn execute(&self, ctx: &mut Self::Context) -> Result<(), Self::Error>;
    async fn compensate(&self, ctx: &mut Self::Context) -> Result<(), Self::Error>;
}

#[async_trait]
pub trait SagaStore<C: Clone + Send + Sync>: Send + Sync {
    async fn save(&self, instance: &SagaInstance<C>) -> Result<(), SagaStoreError>;
    async fn load(&self, id: Uuid) -> Result<Option<SagaInstance<C>>, SagaStoreError>;
    async fn list_incomplete(&self) -> Result<Vec<Uuid>, SagaStoreError>;
}

pub struct InMemorySagaStore<C: Clone + Send + Sync> {
    instances: RwLock<HashMap<Uuid, SagaInstance<C>>>,
}

impl<C: Clone + Send + Sync> InMemorySagaStore<C> {
    pub fn new() -> Self {
        Self {
            instances: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl<C: Clone + Send + Sync + 'static> SagaStore<C> for InMemorySagaStore<C> {
    async fn save(&self, instance: &SagaInstance<C>) -> Result<(), SagaStoreError> {
        let mut instances = self.instances.write().await;
        instances.insert(instance.id, instance.clone());
        Ok(())
    }

    async fn load(&self, id: Uuid) -> Result<Option<SagaInstance<C>>, SagaStoreError> {
        let instances = self.instances.read().await;
        Ok(instances.get(&id).cloned())
    }

    async fn list_incomplete(&self) -> Result<Vec<Uuid>, SagaStoreError> {
        let instances = self.instances.read().await;
        Ok(instances.iter()
            .filter(|(_, i)| !matches!(i.state, SagaState::Completed | SagaState::Compensated | SagaState::Failed))
            .map(|(id, _)| *id)
            .collect())
    }
}

type BoxedSagaStep<C> = Box<dyn SagaStep<Context = C, Error = Box<dyn std::error::Error + Send + Sync>>>;

pub struct SagaOrchestrator<C: Clone + Send + Sync + 'static> {
    name: String,
    steps: Vec<BoxedSagaStep<C>>,
    store: Box<dyn SagaStore<C>>,
    timeout: Duration,
}

impl<C: Clone + Send + Sync + 'static> SagaOrchestrator<C> {
    pub fn builder(name: &str) -> SagaOrchestratorBuilder<C> {
        SagaOrchestratorBuilder {
            name: name.to_string(),
            steps: Vec::new(),
            store: None,
            timeout: Duration::from_secs(300),
        }
    }

    pub async fn start(&self, context: C) -> Result<Uuid, SagaError> {
        let id = Uuid::new_v4();
        let mut instance = SagaInstance {
            id,
            definition_name: self.name.clone(),
            state: SagaState::Created,
            current_step: 0,
            context,
            step_results: vec![StepResult::Pending; self.steps.len()],
            created_at: Utc::now(),
        };

        self.store.save(&instance).await.map_err(|e| SagaError::StoreError(e.0))?;

        let final_state = self.execute_saga(&mut instance).await?;
        instance.state = final_state;
        self.store.save(&instance).await.map_err(|e| SagaError::StoreError(e.0))?;

        Ok(id)
    }

    async fn execute_saga(&self, instance: &mut SagaInstance<C>) -> Result<SagaState, SagaError> {
        instance.state = SagaState::Running;
        self.store.save(instance).await.map_err(|e| SagaError::StoreError(e.0))?;

        for (i, step) in self.steps.iter().enumerate() {
            instance.current_step = i;

            match step.execute(&mut instance.context).await {
                Ok(()) => {
                    instance.step_results[i] = StepResult::Completed;
                    self.store.save(instance).await.map_err(|e| SagaError::StoreError(e.0))?;
                }
                Err(e) => {
                    instance.step_results[i] = StepResult::Failed(e.to_string());
                    instance.state = SagaState::Compensating;
                    self.store.save(instance).await.map_err(|e| SagaError::StoreError(e.0))?;

                    // Compensate all completed steps in reverse order
                    self.compensate(instance).await?;

                    return Ok(SagaState::Compensated);
                }
            }
        }

        Ok(SagaState::Completed)
    }

    async fn compensate(&self, instance: &mut SagaInstance<C>) -> Result<(), SagaError> {
        // Compensate in reverse order
        for i in (0..=instance.current_step).rev() {
            if matches!(instance.step_results[i], StepResult::Completed) {
                let step = &self.steps[i];
                match step.compensate(&mut instance.context).await {
                    Ok(()) => {
                        instance.step_results[i] = StepResult::Compensated;
                    }
                    Err(e) => {
                        instance.step_results[i] = StepResult::CompensationFailed(e.to_string());
                        instance.state = SagaState::Failed;
                        self.store.save(instance).await.map_err(|e| SagaError::StoreError(e.0))?;
                        return Err(SagaError::CompensationFailed {
                            step: step.name().to_string(),
                            error: e.to_string(),
                        });
                    }
                }
                self.store.save(instance).await.map_err(|e| SagaError::StoreError(e.0))?;
            }
        }
        Ok(())
    }

    pub async fn get_state(&self, saga_id: Uuid) -> Option<SagaInstance<C>> {
        self.store.load(saga_id).await.ok().flatten()
    }
}

pub struct SagaOrchestratorBuilder<C: Clone + Send + Sync + 'static> {
    name: String,
    steps: Vec<BoxedSagaStep<C>>,
    store: Option<Box<dyn SagaStore<C>>>,
    timeout: Duration,
}

impl<C: Clone + Send + Sync + 'static> SagaOrchestratorBuilder<C> {
    pub fn step<S>(mut self, step: S) -> Self
    where
        S: SagaStep<Context = C, Error = Box<dyn std::error::Error + Send + Sync>> + 'static,
    {
        self.steps.push(Box::new(step));
        self
    }

    pub fn store<S: SagaStore<C> + 'static>(mut self, store: S) -> Self {
        self.store = Some(Box::new(store));
        self
    }

    pub fn timeout(mut self, timeout: Duration) -> Self {
        self.timeout = timeout;
        self
    }

    pub fn build(self) -> SagaOrchestrator<C> {
        SagaOrchestrator {
            name: self.name,
            steps: self.steps,
            store: self.store.expect("Store is required"),
            timeout: self.timeout,
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Compensation dans le mauvais ordre */
async fn compensate(&self, instance: &mut SagaInstance<C>) {
    // MUTANT: Ordre croissant au lieu de decroissant
    for i in 0..=instance.current_step {
        self.steps[i].compensate(&mut instance.context).await?;
    }
}
// Pourquoi c'est faux : La compensation doit defaire dans l'ordre inverse

/* Mutant B (Safety) : Pas de persistance apres chaque step */
async fn execute_saga(&self, instance: &mut SagaInstance<C>) {
    for step in &self.steps {
        step.execute(&mut instance.context).await?;
        // MUTANT: Pas de self.store.save()
    }
}
// Pourquoi c'est faux : En cas de crash, on ne sait pas ou reprendre

/* Mutant C (Logic) : Compensation des steps non-completes */
async fn compensate(&self, instance: &mut SagaInstance<C>) {
    for i in (0..=instance.current_step).rev() {
        // MUTANT: Pas de check StepResult::Completed
        self.steps[i].compensate(&mut instance.context).await?;
    }
}
// Pourquoi c'est faux : On compense des steps qui n'ont pas ete executes

/* Mutant D (Edge) : Erreur de compensation ignoree */
async fn compensate(&self, instance: &mut SagaInstance<C>) {
    for step in &self.steps {
        let _ = step.compensate(&mut instance.context).await;
        // MUTANT: Ignore l'erreur
    }
}
// Pourquoi c'est faux : Saga apparait comme Compensated alors qu'elle a echoue

/* Mutant E (Return) : Etat final incorrect */
async fn execute_saga(&self, instance: &mut SagaInstance<C>) -> Result<SagaState, SagaError> {
    for step in &self.steps {
        if step.execute(&mut instance.context).await.is_err() {
            self.compensate(instance).await?;
            return Ok(SagaState::Completed); // MUTANT: Devrait etre Compensated
        }
    }
    Ok(SagaState::Completed)
}
// Pourquoi c'est faux : L'appelant pense que la saga a reussi
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    SAGA ORCHESTRATOR FLOW

    ┌─────────────────────────────────────────────────────┐
    │                  SAGA ORCHESTRATOR                  │
    │                                                     │
    │    Step 1        Step 2        Step 3        Step 4 │
    │   ┌──────┐      ┌──────┐      ┌──────┐      ┌──────┐
    │   │Create│ ───► │Reserve│ ───►│ Pay  │ ───► │ Ship │
    │   │Order │      │ Stock │      │      │      │      │
    │   └──────┘      └──────┘      └──┬───┘      └──────┘
    │                                  │ FAIL!
    │                                  ▼
    │   ┌──────┐      ┌──────┐      ┌──────┐
    │   │Cancel│ ◄─── │Release│ ◄─── │Refund│  COMPENSATE
    │   │Order │      │ Stock │      │      │
    │   └──────┘      └──────┘      └──────┘
    │                                                     │
    └─────────────────────────────────────────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Ordre compensation | Inconsistance | Reverse order |
| 2 | Pas de persistance | Perte etat | Save apres chaque step |
| 3 | Compense non-done | Erreur | Check StepResult |
| 4 | Ignore comp error | Faux succes | Propagate error |
| 5 | Etat final faux | Bug appelant | Return correct state |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | saga_orchestrator |
| **Module** | 5.6.17 — Saga Orchestrator |
| **Difficulte** | 8/10 |
| **Temps estime** | 150 min |
| **XP** | 200 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.17-a-saga-orchestrator",
    "metadata": {
      "exercise_id": "5.6.17-a",
      "exercise_name": "saga_orchestrator",
      "difficulty": 8,
      "xp_base": 200
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 96/100*
