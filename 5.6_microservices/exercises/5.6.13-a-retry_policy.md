<thinking>
## Analyse du Concept
- Concept : Retry Policy avec Exponential Backoff
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le retry est essentiel pour la resilience face aux erreurs transitoires.
</thinking>

# Exercice 5.6.13-a : retry_policy

**Module :**
5.6.13 — Resilience Patterns - Retry

**Concept :**
a — Retry Policy (exponential backoff, jitter, conditions)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.11 — Circuit Breaker

**Domaines :**
Resilience, Async, ErrorHandling

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `rand` (jitter)

### 1.2 Consigne

**CONTEXTE : "The Persistent Caller"**

*"Si tu n'as pas reussi du premier coup, attends un peu et reessaie. Mais pas trop vite, et pas indefiniment."* — Le Philosophe du Retry

Le Retry Pattern permet de reessayer automatiquement une operation echouee, avec un delai croissant entre les tentatives (exponential backoff) et un peu d'aleatoire (jitter) pour eviter le thundering herd.

**Ta mission :**

Implementer un `RetryPolicy` qui :
1. Reessaie avec exponential backoff
2. Ajoute du jitter pour desynchroniser les retries
3. Permet de configurer quelles erreurs sont retryables
4. Limite le nombre de tentatives et le delai maximum

### 1.3 Prototype

```rust
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct RetryConfig {
    pub max_attempts: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub multiplier: f64,
    pub jitter_factor: f64, // 0.0 to 1.0
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(30),
            multiplier: 2.0,
            jitter_factor: 0.3,
        }
    }
}

#[derive(Debug)]
pub struct RetryError<E> {
    pub last_error: E,
    pub attempts: u32,
    pub total_duration: Duration,
}

pub struct RetryPolicy<E> {
    config: RetryConfig,
    should_retry: Box<dyn Fn(&E) -> bool + Send + Sync>,
}

impl<E: Send + 'static> RetryPolicy<E> {
    pub fn new(config: RetryConfig) -> Self;

    /// Configure quelles erreurs sont retryables
    pub fn with_condition<F>(self, condition: F) -> Self
    where
        F: Fn(&E) -> bool + Send + Sync + 'static;

    /// Execute avec retry
    pub async fn execute<F, T, Fut>(&self, operation: F) -> Result<T, RetryError<E>>
    where
        F: Fn() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>;

    /// Calcule le delai pour la tentative N
    pub fn calculate_delay(&self, attempt: u32) -> Duration;

    /// Ajoute du jitter au delai
    pub fn apply_jitter(&self, delay: Duration) -> Duration;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Exponential Backoff

Le delai double a chaque tentative : 100ms, 200ms, 400ms, 800ms...

Formula: `delay = min(initial_delay * multiplier^attempt, max_delay)`

### 2.2 Le Jitter contre le Thundering Herd

Sans jitter, 1000 clients qui retry en meme temps vont tous retenter au meme moment. Avec 30% de jitter, ils sont espaces aleatoirement :
- Client A : 200ms +/- 60ms = 140-260ms
- Client B : 200ms +/- 60ms = different de A

### 2.3 Erreurs Retryables

Toutes les erreurs ne doivent pas etre retryees :
- **Retryable** : Timeout, 503 Service Unavailable, rate limit (429)
- **Non-retryable** : 400 Bad Request, 401 Unauthorized, 404 Not Found

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::atomic::{AtomicU32, Ordering};

    #[tokio::test]
    async fn test_success_no_retry() {
        let policy = RetryPolicy::<&str>::new(RetryConfig::default());
        let result = policy.execute(|| async { Ok::<_, &str>(42) }).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);
    }

    #[tokio::test]
    async fn test_retry_then_success() {
        let attempts = Arc::new(AtomicU32::new(0));
        let attempts_clone = attempts.clone();

        let policy = RetryPolicy::<&str>::new(RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(10),
            ..Default::default()
        });

        let result = policy.execute(|| {
            let attempts = attempts_clone.clone();
            async move {
                let n = attempts.fetch_add(1, Ordering::SeqCst);
                if n < 2 {
                    Err("transient error")
                } else {
                    Ok(42)
                }
            }
        }).await;

        assert!(result.is_ok());
        assert_eq!(attempts.load(Ordering::SeqCst), 3);
    }

    #[tokio::test]
    async fn test_max_attempts_exceeded() {
        let policy = RetryPolicy::<&str>::new(RetryConfig {
            max_attempts: 2,
            initial_delay: Duration::from_millis(10),
            ..Default::default()
        });

        let result = policy.execute(|| async { Err::<i32, _>("permanent error") }).await;

        assert!(result.is_err());
        let err = result.unwrap_err();
        assert_eq!(err.attempts, 2);
    }

    #[test]
    fn test_calculate_delay() {
        let config = RetryConfig {
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(10),
            multiplier: 2.0,
            jitter_factor: 0.0, // No jitter for testing
            ..Default::default()
        };
        let policy = RetryPolicy::<&str>::new(config);

        assert_eq!(policy.calculate_delay(0), Duration::from_millis(100));
        assert_eq!(policy.calculate_delay(1), Duration::from_millis(200));
        assert_eq!(policy.calculate_delay(2), Duration::from_millis(400));
    }

    #[test]
    fn test_max_delay_cap() {
        let config = RetryConfig {
            initial_delay: Duration::from_secs(1),
            max_delay: Duration::from_secs(5),
            multiplier: 10.0,
            jitter_factor: 0.0,
            ..Default::default()
        };
        let policy = RetryPolicy::<&str>::new(config);

        // 1s * 10^3 = 1000s, but capped at 5s
        assert_eq!(policy.calculate_delay(3), Duration::from_secs(5));
    }

    #[tokio::test]
    async fn test_condition_not_retryable() {
        let policy = RetryPolicy::<&str>::new(RetryConfig::default())
            .with_condition(|e| *e != "fatal");

        let result = policy.execute(|| async { Err::<i32, _>("fatal") }).await;

        assert!(result.is_err());
        // Should only attempt once since error is not retryable
        assert_eq!(result.unwrap_err().attempts, 1);
    }
}
```

### 4.3 Solution de reference

```rust
use std::time::{Duration, Instant};
use rand::Rng;

#[derive(Debug, Clone)]
pub struct RetryConfig {
    pub max_attempts: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub multiplier: f64,
    pub jitter_factor: f64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(30),
            multiplier: 2.0,
            jitter_factor: 0.3,
        }
    }
}

#[derive(Debug)]
pub struct RetryError<E> {
    pub last_error: E,
    pub attempts: u32,
    pub total_duration: Duration,
}

impl<E: std::fmt::Display> std::fmt::Display for RetryError<E> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Retry exhausted after {} attempts: {}", self.attempts, self.last_error)
    }
}

pub struct RetryPolicy<E> {
    config: RetryConfig,
    should_retry: Box<dyn Fn(&E) -> bool + Send + Sync>,
}

impl<E: Send + 'static> RetryPolicy<E> {
    pub fn new(config: RetryConfig) -> Self {
        Self {
            config,
            should_retry: Box::new(|_| true), // Retry all errors by default
        }
    }

    pub fn with_condition<F>(mut self, condition: F) -> Self
    where
        F: Fn(&E) -> bool + Send + Sync + 'static,
    {
        self.should_retry = Box::new(condition);
        self
    }

    pub async fn execute<F, T, Fut>(&self, operation: F) -> Result<T, RetryError<E>>
    where
        F: Fn() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
    {
        let start = Instant::now();
        let mut attempts = 0;
        let mut last_error = None;

        while attempts < self.config.max_attempts {
            attempts += 1;

            match operation().await {
                Ok(result) => return Ok(result),
                Err(e) => {
                    // Check if we should retry this error
                    if !(self.should_retry)(&e) {
                        return Err(RetryError {
                            last_error: e,
                            attempts,
                            total_duration: start.elapsed(),
                        });
                    }

                    last_error = Some(e);

                    // Don't sleep after the last attempt
                    if attempts < self.config.max_attempts {
                        let delay = self.calculate_delay(attempts - 1);
                        let delay = self.apply_jitter(delay);
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }

        Err(RetryError {
            last_error: last_error.unwrap(),
            attempts,
            total_duration: start.elapsed(),
        })
    }

    pub fn calculate_delay(&self, attempt: u32) -> Duration {
        let delay_ms = self.config.initial_delay.as_millis() as f64
            * self.config.multiplier.powi(attempt as i32);

        let capped_ms = delay_ms.min(self.config.max_delay.as_millis() as f64);

        Duration::from_millis(capped_ms as u64)
    }

    pub fn apply_jitter(&self, delay: Duration) -> Duration {
        if self.config.jitter_factor <= 0.0 {
            return delay;
        }

        let mut rng = rand::thread_rng();
        let jitter_range = delay.as_millis() as f64 * self.config.jitter_factor;
        let jitter = rng.gen_range(-jitter_range..=jitter_range);

        let new_ms = (delay.as_millis() as f64 + jitter).max(0.0);
        Duration::from_millis(new_ms as u64)
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Pas de max_delay */
pub fn calculate_delay(&self, attempt: u32) -> Duration {
    // MUTANT: Pas de cap
    let delay_ms = self.config.initial_delay.as_millis() as f64
        * self.config.multiplier.powi(attempt as i32);
    Duration::from_millis(delay_ms as u64)
}
// Pourquoi c'est faux : Delay peut devenir astronomique (2^30 = 1 milliard)

/* Mutant B (Safety) : Jitter qui peut etre negatif */
pub fn apply_jitter(&self, delay: Duration) -> Duration {
    let jitter = rand::random::<f64>() * self.config.jitter_factor * 2.0 - self.config.jitter_factor;
    // MUTANT: Pas de .max(0.0)
    Duration::from_millis((delay.as_millis() as f64 * (1.0 + jitter)) as u64)
}
// Pourquoi c'est faux : Peut donner un delai negatif qui panic

/* Mutant C (Logic) : Retry meme les erreurs non-retryables */
pub async fn execute<F, T, Fut>(&self, operation: F) -> Result<T, RetryError<E>> {
    // MUTANT: Ignore should_retry
    loop {
        match operation().await {
            Ok(r) => return Ok(r),
            Err(e) => {
                attempts += 1;
                if attempts >= self.config.max_attempts {
                    return Err(RetryError { .. });
                }
            }
        }
    }
}
// Pourquoi c'est faux : Gaspille des retries sur des erreurs permanentes

/* Mutant D (Edge) : Sleep apres la derniere tentative */
pub async fn execute(&self, operation: F) -> Result<T, RetryError<E>> {
    while attempts < self.config.max_attempts {
        match operation().await {
            Err(e) => {
                let delay = self.calculate_delay(attempts);
                tokio::time::sleep(delay).await; // MUTANT: Sleep meme a la fin
                attempts += 1;
            }
        }
    }
}
// Pourquoi c'est faux : Ajoute un delai inutile avant de retourner l'erreur

/* Mutant E (Return) : Perd l'erreur originale */
pub async fn execute(&self, operation: F) -> Result<T, RetryError<E>> {
    let mut attempts = 0;
    while attempts < self.config.max_attempts {
        match operation().await {
            Err(_) => {
                attempts += 1;
            }
        }
    }
    // MUTANT: Pas de last_error stockee
    Err(RetryError { last_error: ???, .. })
}
// Pourquoi c'est faux : Impossible de savoir quelle erreur a cause l'echec
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    EXPONENTIAL BACKOFF WITH JITTER

    Attempt 1    Attempt 2        Attempt 3            Attempt 4
        │            │                │                    │
        ▼            ▼                ▼                    ▼
    ┌───┐        ┌───┐            ┌───┐                ┌───┐
    │ X │        │ X │            │ X │                │ X │
    └───┘        └───┘            └───┘                └───┘
        │            │                │                    │
        ▼            ▼                ▼                    ▼
     100ms        200ms            400ms               800ms
    +jitter      +jitter          +jitter             +jitter
        │            │                │                    │
        └────────────┴────────────────┴────────────────────┘
                    Total time with delays
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Pas de max_delay | Delay infini | Cap avec max_delay |
| 2 | Jitter negatif | Panic | .max(0.0) |
| 3 | Retry tout | Gaspillage | Condition should_retry |
| 4 | Sleep a la fin | Latence inutile | Check avant sleep |
| 5 | Erreur perdue | Debug impossible | Stocker last_error |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | retry_policy |
| **Module** | 5.6.13 — Retry Policy |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP** | 150 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.13-a-retry-policy",
    "metadata": {
      "exercise_id": "5.6.13-a",
      "exercise_name": "retry_policy",
      "difficulty": 6,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
