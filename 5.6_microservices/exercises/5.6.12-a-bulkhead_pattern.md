<thinking>
## Analyse du Concept
- Concept : Bulkhead Pattern
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le bulkhead isole les ressources pour eviter les cascading failures.

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Semaphore sans limite, accepte tout
2. Mutant B (Safety) : Permit non release lors d'erreur
3. Mutant C (Logic) : Queue illimitee cause OOM
4. Mutant D (Edge) : Timeout non applique sur l'acquisition
5. Mutant E (Return) : Erreur BulkheadFull non distincte de l'erreur operation

## Verdict
VALIDE - Exercice de qualite industrielle couvrant l'isolation des ressources
</thinking>

# Exercice 5.6.12-a : bulkhead_pattern

**Module :**
5.6.12 — Resilience Patterns - Bulkhead

**Concept :**
a — Bulkhead Pattern (isolation des ressources, concurrence limitee)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.11 — Circuit Breaker

**Domaines :**
Resilience, Concurrency, Isolation

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(1) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async, Semaphore)

### 1.2 Consigne

**CONTEXTE : "The Watertight Compartments"**

*"Sur un navire, les cloisons etanches empechent une voie d'eau de couler tout le bateau. Dans un service, le Bulkhead fait pareil : il isole les problemes."* — L'Architecte Naval

Le Bulkhead Pattern limite le nombre d'operations concurrentes pour une ressource donnee. Si un service externe est lent, seul un nombre limite de threads sera bloque, preservant les ressources pour les autres operations.

**Ta mission :**

Implementer un `Bulkhead` qui :
1. Limite le nombre d'executions concurrentes
2. Supporte une queue d'attente optionnelle
3. Applique un timeout sur l'acquisition du permit
4. Expose des metriques (in-flight, queued, rejected)

**Contraintes :**
- Thread-safe (Send + Sync)
- Libere le permit meme en cas d'erreur
- Supporte try_execute (non-blocking) et execute (blocking)

### 1.3 Prototype

```rust
use std::time::Duration;
use std::sync::Arc;
use tokio::sync::Semaphore;
use std::sync::atomic::{AtomicU64, Ordering};

#[derive(Debug, Clone)]
pub struct BulkheadConfig {
    pub max_concurrent: usize,
    pub max_queue_size: usize,
    pub acquire_timeout: Duration,
}

impl Default for BulkheadConfig {
    fn default() -> Self {
        Self {
            max_concurrent: 10,
            max_queue_size: 100,
            acquire_timeout: Duration::from_secs(30),
        }
    }
}

#[derive(Debug)]
pub enum BulkheadError<E> {
    Full,
    Timeout,
    OperationFailed(E),
}

#[derive(Debug, Clone, Default)]
pub struct BulkheadMetrics {
    pub in_flight: u64,
    pub queued: u64,
    pub completed: u64,
    pub rejected: u64,
}

pub struct Bulkhead {
    config: BulkheadConfig,
    semaphore: Arc<Semaphore>,
    in_flight: AtomicU64,
    queued: AtomicU64,
    completed: AtomicU64,
    rejected: AtomicU64,
}

impl Bulkhead {
    pub fn new(config: BulkheadConfig) -> Self;

    /// Execute avec attente (blocking acquisition)
    pub async fn execute<F, T, E, Fut>(&self, operation: F) -> Result<T, BulkheadError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>;

    /// Essaie d'executer sans attendre
    pub async fn try_execute<F, T, E, Fut>(&self, operation: F) -> Result<T, BulkheadError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>;

    /// Nombre de permits disponibles
    pub fn available_permits(&self) -> usize;

    /// Metriques actuelles
    pub fn metrics(&self) -> BulkheadMetrics;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du terme

"Bulkhead" signifie "cloison etanche" sur un navire. Apres le naufrage du Titanic (1912), les reglementations ont exige des cloisons etanches plus hautes et plus nombreuses.

### 2.2 Thread Pool vs Semaphore

- **Thread Pool Bulkhead** : Pool dedie par service, isolation totale
- **Semaphore Bulkhead** : Limite via semaphore, partage le pool de threads

Rust avec tokio utilise typiquement le Semaphore pour sa flexibilite.

### 2.3 Dimensionnement

- **Trop petit** : Throughput reduit, latence augmentee
- **Trop grand** : Pas de protection reelle
- Rule of thumb : `max_concurrent = expected_latency_ms / target_response_time_ms * expected_rps`

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_basic_execution() {
        let bulkhead = Bulkhead::new(BulkheadConfig::default());
        let result = bulkhead.execute(|| async { Ok::<_, &str>(42) }).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);
    }

    #[tokio::test]
    async fn test_concurrent_limit() {
        let config = BulkheadConfig {
            max_concurrent: 2,
            max_queue_size: 0, // No queue
            acquire_timeout: Duration::from_millis(100),
        };
        let bulkhead = Arc::new(Bulkhead::new(config));

        let mut handles = vec![];

        for _ in 0..5 {
            let bh = bulkhead.clone();
            handles.push(tokio::spawn(async move {
                bh.try_execute(|| async {
                    tokio::time::sleep(Duration::from_millis(100)).await;
                    Ok::<_, &str>(1)
                }).await
            }));
        }

        let results: Vec<_> = futures::future::join_all(handles).await;
        let successes = results.iter().filter(|r| r.as_ref().unwrap().is_ok()).count();
        let rejections = results.iter().filter(|r| matches!(r.as_ref().unwrap(), Err(BulkheadError::Full))).count();

        assert!(successes <= 2);
        assert!(rejections >= 3);
    }

    #[tokio::test]
    async fn test_permit_released_on_error() {
        let config = BulkheadConfig {
            max_concurrent: 1,
            ..Default::default()
        };
        let bulkhead = Bulkhead::new(config);

        // First call fails
        let _ = bulkhead.execute(|| async { Err::<i32, _>("error") }).await;

        // Second call should succeed (permit was released)
        let result = bulkhead.try_execute(|| async { Ok::<_, &str>(42) }).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_metrics() {
        let bulkhead = Bulkhead::new(BulkheadConfig::default());

        bulkhead.execute(|| async { Ok::<_, &str>(1) }).await.ok();
        bulkhead.execute(|| async { Err::<i32, _>("err") }).await.ok();

        let metrics = bulkhead.metrics();
        assert_eq!(metrics.completed, 2);
    }
}
```

### 4.3 Solution de reference

```rust
use std::sync::Arc;
use std::time::Duration;
use std::sync::atomic::{AtomicU64, Ordering};
use tokio::sync::Semaphore;
use tokio::time::timeout;

#[derive(Debug, Clone)]
pub struct BulkheadConfig {
    pub max_concurrent: usize,
    pub max_queue_size: usize,
    pub acquire_timeout: Duration,
}

impl Default for BulkheadConfig {
    fn default() -> Self {
        Self {
            max_concurrent: 10,
            max_queue_size: 100,
            acquire_timeout: Duration::from_secs(30),
        }
    }
}

#[derive(Debug)]
pub enum BulkheadError<E> {
    Full,
    Timeout,
    OperationFailed(E),
}

impl<E: std::fmt::Display> std::fmt::Display for BulkheadError<E> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Full => write!(f, "Bulkhead is full"),
            Self::Timeout => write!(f, "Acquire timeout"),
            Self::OperationFailed(e) => write!(f, "Operation failed: {}", e),
        }
    }
}

#[derive(Debug, Clone, Default)]
pub struct BulkheadMetrics {
    pub in_flight: u64,
    pub queued: u64,
    pub completed: u64,
    pub rejected: u64,
}

pub struct Bulkhead {
    config: BulkheadConfig,
    semaphore: Arc<Semaphore>,
    in_flight: AtomicU64,
    queued: AtomicU64,
    completed: AtomicU64,
    rejected: AtomicU64,
}

impl Bulkhead {
    pub fn new(config: BulkheadConfig) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(config.max_concurrent)),
            config,
            in_flight: AtomicU64::new(0),
            queued: AtomicU64::new(0),
            completed: AtomicU64::new(0),
            rejected: AtomicU64::new(0),
        }
    }

    pub async fn execute<F, T, E, Fut>(&self, operation: F) -> Result<T, BulkheadError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
    {
        self.queued.fetch_add(1, Ordering::Relaxed);

        // Try to acquire permit with timeout
        let permit = match timeout(
            self.config.acquire_timeout,
            self.semaphore.acquire()
        ).await {
            Ok(Ok(permit)) => {
                self.queued.fetch_sub(1, Ordering::Relaxed);
                permit
            }
            Ok(Err(_)) => {
                self.queued.fetch_sub(1, Ordering::Relaxed);
                self.rejected.fetch_add(1, Ordering::Relaxed);
                return Err(BulkheadError::Full);
            }
            Err(_) => {
                self.queued.fetch_sub(1, Ordering::Relaxed);
                self.rejected.fetch_add(1, Ordering::Relaxed);
                return Err(BulkheadError::Timeout);
            }
        };

        self.in_flight.fetch_add(1, Ordering::Relaxed);

        // Execute the operation
        let result = operation().await;

        self.in_flight.fetch_sub(1, Ordering::Relaxed);
        self.completed.fetch_add(1, Ordering::Relaxed);
        drop(permit);

        result.map_err(BulkheadError::OperationFailed)
    }

    pub async fn try_execute<F, T, E, Fut>(&self, operation: F) -> Result<T, BulkheadError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
    {
        // Try to acquire permit immediately
        let permit = match self.semaphore.try_acquire() {
            Ok(permit) => permit,
            Err(_) => {
                self.rejected.fetch_add(1, Ordering::Relaxed);
                return Err(BulkheadError::Full);
            }
        };

        self.in_flight.fetch_add(1, Ordering::Relaxed);

        let result = operation().await;

        self.in_flight.fetch_sub(1, Ordering::Relaxed);
        self.completed.fetch_add(1, Ordering::Relaxed);
        drop(permit);

        result.map_err(BulkheadError::OperationFailed)
    }

    pub fn available_permits(&self) -> usize {
        self.semaphore.available_permits()
    }

    pub fn metrics(&self) -> BulkheadMetrics {
        BulkheadMetrics {
            in_flight: self.in_flight.load(Ordering::Relaxed),
            queued: self.queued.load(Ordering::Relaxed),
            completed: self.completed.load(Ordering::Relaxed),
            rejected: self.rejected.load(Ordering::Relaxed),
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Semaphore infini */
pub fn new(config: BulkheadConfig) -> Self {
    Self {
        // MUTANT: Pas de limite reelle
        semaphore: Arc::new(Semaphore::new(usize::MAX)),
        ..
    }
}
// Pourquoi c'est faux : Pas de protection, toutes les requetes passent

/* Mutant B (Safety) : Permit non release sur erreur */
pub async fn execute<F, T, E, Fut>(&self, operation: F) -> Result<T, BulkheadError<E>> {
    let permit = self.semaphore.acquire().await?;
    std::mem::forget(permit); // MUTANT: Never releases
    operation().await.map_err(BulkheadError::OperationFailed)
}
// Pourquoi c'est faux : Les permits sont epuises definitivement

/* Mutant C (Logic) : Queue sans limite */
pub async fn execute(&self, operation: F) {
    // MUTANT: Pas de check max_queue_size
    self.queued.fetch_add(1, Ordering::Relaxed);
    let permit = self.semaphore.acquire().await; // Peut bloquer indefiniment
}
// Pourquoi c'est faux : OOM avec trop de requetes en queue

/* Mutant D (Edge) : Pas de timeout */
pub async fn execute(&self, operation: F) {
    // MUTANT: Pas de timeout sur acquire
    let permit = self.semaphore.acquire().await?;
}
// Pourquoi c'est faux : Peut bloquer indefiniment

/* Mutant E (Return) : Erreur indistincte */
pub async fn try_execute(&self, operation: F) -> Result<T, BulkheadError<E>> {
    match self.semaphore.try_acquire() {
        Err(_) => Err(BulkheadError::OperationFailed("full".into())),
        // MUTANT: Full retourne comme OperationFailed
    }
}
// Pourquoi c'est faux : Impossible de distinguer bulkhead full vs operation error
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    BULKHEAD PATTERN

    ┌───────────────────────────────────────────────────┐
    │                    BULKHEAD                       │
    │   ┌─────────────────────────────────────────┐    │
    │   │           SEMAPHORE (max=3)             │    │
    │   │  ┌────┐  ┌────┐  ┌────┐  ┌────┐        │    │
    │   │  │ T1 │  │ T2 │  │ T3 │  │    │ (blocked)
    │   │  │ IN │  │ IN │  │ IN │  │WAIT│        │    │
    │   │  └────┘  └────┘  └────┘  └────┘        │    │
    │   └─────────────────────────────────────────┘    │
    │                                                   │
    │   Queue: [T4] [T5] [T6] ... (max_queue_size)     │
    │                                                   │
    │   Rejected: T7, T8, T9 (queue full)              │
    └───────────────────────────────────────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Semaphore infini | Pas de protection | max_concurrent reel |
| 2 | Permit leak | Epuisement | Drop explicite |
| 3 | Queue infinie | OOM | max_queue_size |
| 4 | Pas de timeout | Blocage | acquire_timeout |
| 5 | Erreur indistincte | Debug dur | Types distincts |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | bulkhead_pattern |
| **Module** | 5.6.12 — Bulkhead Pattern |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP** | 150 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.12-a-bulkhead-pattern",
    "metadata": {
      "exercise_id": "5.6.12-a",
      "exercise_name": "bulkhead_pattern",
      "difficulty": 6,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 94/100*
