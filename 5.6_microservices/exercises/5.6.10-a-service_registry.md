<thinking>
## Analyse du Concept
- Concept : Service Registry Implementation
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le Service Registry est fondamental pour les architectures microservices. L'exercice combine patterns de conception, concurrence async et gestion d'etat distribue.

## Combo Base + Bonus
- Exercice de base : Implementation d'un Service Registry avec enregistrement, decouverte et health checks
- Bonus : Implementation d'un consensus distribue avec heartbeats et leader election
- Palier bonus : Avance (complexite algorithmique + contraintes de concurrence)
- Progression logique ? OUI - Base = registre local, Bonus = distribution et consensus

## Prerequis & Difficulte
- Prerequis reels : Async Rust, HashMap concurrent, Traits, Arc/RwLock
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "Neuromancer" - Le cyberspace comme reseau de services
- MEME mnémotechnique : "The Registry Knows All" (parodie de Big Brother)
- Pourquoi c'est fun : Les registres sont les "annuaires" du cyberspace microservices

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : TTL de 0 accepte sans erreur
2. Mutant B (Safety) : Pas de verrou lors de l'acces concurrent
3. Mutant C (Logic) : Health check ne supprime pas les services morts
4. Mutant D (Edge) : Service avec meme ID ecrase sans verification de version
5. Mutant E (Return) : get_service retourne un service unhealthy

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les fondamentaux du Service Registry
</thinking>

# Exercice 5.6.10-a : service_registry

**Module :**
5.6.10 — Service Discovery & Registry

**Concept :**
a — Service Registry Implementation (enregistrement, decouverte, health checks)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 — Composant integre

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.5 — Async/await et tokio
- 3.2 — Collections (HashMap, Vec)
- 5.6.1 — Microservices fundamentals

**Domaines :**
Microservices, Distributed Systems, Concurrency

**Duree estimee :**
120 min

**XP Base :**
200

**Complexite :**
T2 O(1) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async, sync primitives)
- `uuid` (generation d'identifiants)
- `chrono` (timestamps)
- `serde` (serialization)
- `thiserror` (gestion d'erreurs)

**Fonctions/methodes interdites :**
- Crates externes de service discovery (consul, etcd clients)
- `unsafe` blocks
- `std::thread` (utiliser tokio)

### 1.2 Consigne

**CONTEXTE : "The Neuromancer Registry"**

*"Case jacked into the matrix, feeling the familiar rush as his consciousness expanded into the sprawling network. Every service was a node, every registry a beacon in the digital wilderness. Without the registry, you were blind in cyberspace."* — Adapte de Neuromancer

Dans une architecture microservices, le Service Registry est le composant central qui permet aux services de s'enregistrer et de se decouvrir mutuellement. C'est l'annuaire du cyberspace distribue.

**Ta mission :**

Implementer un Service Registry complet qui permet de :
1. Enregistrer des services avec leurs metadonnees
2. Decouvrir des services par nom ou tags
3. Gerer les health checks et TTL
4. Supporter plusieurs instances du meme service
5. Notifier les changements via callbacks

**Entree :**
- `ServiceRegistration` — Informations d'enregistrement
- `ServiceQuery` — Criteres de recherche

**Sortie :**
- `ServiceInstance` — Instance de service decouverte
- `RegistryError` — En cas d'erreur

**Contraintes :**
- Thread-safe : tous les types doivent etre `Send + Sync`
- TTL par defaut de 30 secondes
- Health check toutes les 10 secondes
- Support de load balancing round-robin

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `registry.register(service).await` | `Ok(service_id)` | Enregistrement reussi |
| `registry.discover("api-gateway").await` | `Ok(vec![instance])` | Service trouve |
| `registry.discover("unknown").await` | `Ok(vec![])` | Aucun service |
| `registry.heartbeat(id).await` | `Ok(())` | TTL renouvele |

### 1.2.2 Consigne Academique

Implementer un Service Registry thread-safe avec support d'enregistrement, decouverte, health checks et notifications de changements. Le registry doit gerer le TTL des services et supprimer automatiquement les instances mortes.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{RwLock, broadcast};
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Identifiant unique de service
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ServiceId(pub Uuid);

impl ServiceId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Statut de sante d'un service
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

/// Instance de service enregistree
#[derive(Debug, Clone)]
pub struct ServiceInstance {
    pub id: ServiceId,
    pub name: String,
    pub host: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub health_status: HealthStatus,
    pub registered_at: DateTime<Utc>,
    pub last_heartbeat: Instant,
    pub version: u64,
}

/// Configuration du registry
#[derive(Debug, Clone)]
pub struct RegistryConfig {
    pub default_ttl: Duration,
    pub health_check_interval: Duration,
    pub max_instances_per_service: usize,
}

impl Default for RegistryConfig {
    fn default() -> Self {
        Self {
            default_ttl: Duration::from_secs(30),
            health_check_interval: Duration::from_secs(10),
            max_instances_per_service: 100,
        }
    }
}

/// Demande d'enregistrement
#[derive(Debug, Clone)]
pub struct ServiceRegistration {
    pub name: String,
    pub host: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub ttl: Option<Duration>,
}

/// Evenement du registry
#[derive(Debug, Clone)]
pub enum RegistryEvent {
    ServiceRegistered(ServiceId, String),
    ServiceDeregistered(ServiceId, String),
    ServiceHealthChanged(ServiceId, HealthStatus),
}

/// Erreurs du registry
#[derive(Debug, Clone, PartialEq, thiserror::Error)]
pub enum RegistryError {
    #[error("Service not found: {0}")]
    NotFound(String),
    #[error("Service already exists: {0}")]
    AlreadyExists(String),
    #[error("Max instances reached for service: {0}")]
    MaxInstancesReached(String),
    #[error("Invalid registration: {0}")]
    InvalidRegistration(String),
    #[error("Internal error: {0}")]
    Internal(String),
}

/// Service Registry principal
pub struct ServiceRegistry {
    config: RegistryConfig,
    services: Arc<RwLock<HashMap<ServiceId, ServiceInstance>>>,
    by_name: Arc<RwLock<HashMap<String, Vec<ServiceId>>>>,
    event_tx: broadcast::Sender<RegistryEvent>,
}

impl ServiceRegistry {
    /// Cree un nouveau registry
    pub fn new(config: RegistryConfig) -> Self;

    /// Enregistre un nouveau service
    pub async fn register(&self, registration: ServiceRegistration) -> Result<ServiceId, RegistryError>;

    /// Desenregistre un service
    pub async fn deregister(&self, id: ServiceId) -> Result<(), RegistryError>;

    /// Decouvre les services par nom
    pub async fn discover(&self, name: &str) -> Result<Vec<ServiceInstance>, RegistryError>;

    /// Decouvre les services par tag
    pub async fn discover_by_tag(&self, tag: &str) -> Result<Vec<ServiceInstance>, RegistryError>;

    /// Met a jour le heartbeat d'un service
    pub async fn heartbeat(&self, id: ServiceId) -> Result<(), RegistryError>;

    /// Obtient une instance specifique
    pub async fn get_instance(&self, id: ServiceId) -> Result<ServiceInstance, RegistryError>;

    /// Liste tous les services
    pub async fn list_all(&self) -> Vec<ServiceInstance>;

    /// Obtient le nombre de services enregistres
    pub async fn service_count(&self) -> usize;

    /// S'abonne aux evenements
    pub fn subscribe(&self) -> broadcast::Receiver<RegistryEvent>;

    /// Demarre le health checker en arriere-plan
    pub fn start_health_checker(&self) -> tokio::task::JoinHandle<()>;
}

/// Load balancer round-robin
pub struct RoundRobinBalancer {
    counters: Arc<RwLock<HashMap<String, usize>>>,
}

impl RoundRobinBalancer {
    pub fn new() -> Self;

    /// Selectionne la prochaine instance
    pub async fn next(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Service Discovery

Le concept de Service Discovery remonte aux premiers systemes distribues comme DNS (1983) et CORBA Naming Service (1991). Les implementations modernes comme Consul (2014), Eureka (2012) et etcd (2013) ont popularise le pattern dans les architectures microservices.

### 2.2 Le Pattern Registry

Le Service Registry est un pattern essentiel qui resout le probleme de la localisation dynamique des services. Contrairement aux configurations statiques, il permet :
- L'elasticite (ajout/suppression de services)
- La resilience (detection des pannes)
- Le load balancing (distribution de charge)

```
┌─────────────────┐
│ Service A       │──register──►┌─────────────────┐
└─────────────────┘             │                 │
                                │  Service        │
┌─────────────────┐◄──discover──│  Registry       │
│ Service B       │             │                 │
└─────────────────┘             └─────────────────┘
                                        ▲
┌─────────────────┐──heartbeat──────────┘
│ Service C       │
└─────────────────┘
```

### 2.3 TTL et Health Checks

Le TTL (Time To Live) est crucial pour eviter les "zombie services" :
- Un service doit envoyer un heartbeat avant expiration du TTL
- Sans heartbeat, le service est considere mort
- Le health checker nettoie periodiquement les services expires

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation du Service Registry |
|--------|--------------------------------|
| **Platform Engineer** | Configuration et maintenance des registries (Consul, etcd) |
| **Backend Developer** | Integration du service discovery dans les applications |
| **SRE** | Monitoring de la sante des services, alerting |
| **DevOps** | Automatisation des deployments avec discovery |

### Cas d'usage concrets

1. **Kubernetes Service Discovery** : CoreDNS + kube-proxy pour la resolution de services
2. **Consul Cluster** : Service mesh avec health checks et KV store
3. **Netflix Eureka** : Discovery pour applications Spring Cloud
4. **HashiCorp Nomad** : Orchestration avec service registration automatique

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling service_registry v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 15 tests
test tests::test_register_service ... ok
test tests::test_deregister_service ... ok
test tests::test_discover_by_name ... ok
test tests::test_discover_by_tag ... ok
test tests::test_heartbeat_renews_ttl ... ok
test tests::test_expired_service_removed ... ok
test tests::test_round_robin_balancer ... ok
test tests::test_max_instances_limit ... ok
test tests::test_duplicate_prevention ... ok
test tests::test_event_notification ... ok
test tests::test_concurrent_registration ... ok
test tests::test_health_status_update ... ok
test tests::test_metadata_storage ... ok
test tests::test_version_increment ... ok
test tests::test_empty_discovery ... ok

test result: ok. 15 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) pour consensus, O(1) pour operations locales

**Space Complexity attendue :**
O(n) ou n = nombre de noeuds

**Domaines Bonus :**
`Distributed Systems, Consensus`

#### 3.1.1 Consigne Bonus

**"The Distributed Mind"**

*"Dans le cyberspace, un seul registre est un point de defaillance. Les vrais cowboys du net savent que la redondance est la cle de la survie."*

**Ta mission bonus :**

Implementer un **Distributed Service Registry** avec :
- Replication des donnees entre noeuds
- Leader election avec heartbeats
- Consistency garantie (eventual ou strong)
- Partition tolerance

**Entree :**
- `ClusterConfig` — Configuration du cluster
- `NodeId` — Identifiant du noeud local

**Sortie :**
- `DistributedRegistry` — Registry distribue
- `ConsensusError` — Erreurs de consensus

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone)]
pub struct ClusterConfig {
    pub nodes: Vec<NodeAddress>,
    pub replication_factor: usize,
    pub election_timeout: Duration,
    pub heartbeat_interval: Duration,
}

#[derive(Debug, Clone)]
pub struct NodeAddress {
    pub id: NodeId,
    pub host: String,
    pub port: u16,
}

pub struct DistributedRegistry {
    local: ServiceRegistry,
    cluster: ClusterConfig,
    role: Arc<RwLock<NodeRole>>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum NodeRole {
    Leader,
    Follower,
    Candidate,
}

impl DistributedRegistry {
    pub fn new(local_id: NodeId, config: ClusterConfig) -> Self;
    pub async fn join_cluster(&self) -> Result<(), ConsensusError>;
    pub async fn replicate(&self, event: RegistryEvent) -> Result<(), ConsensusError>;
    pub async fn current_role(&self) -> NodeRole;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `register_service` | Valid registration | `Ok(ServiceId)` | 10 | Basic |
| `register_invalid` | Empty name | `Err(InvalidRegistration)` | 5 | Edge |
| `deregister_existing` | Valid id | `Ok(())` | 5 | Basic |
| `deregister_unknown` | Unknown id | `Err(NotFound)` | 5 | Edge |
| `discover_existing` | Known name | `Ok(vec![...])` | 10 | Core |
| `discover_unknown` | Unknown name | `Ok(vec![])` | 5 | Core |
| `discover_by_tag` | Valid tag | `Ok(vec![...])` | 5 | Core |
| `heartbeat_valid` | Registered id | `Ok(())` | 5 | Core |
| `heartbeat_unknown` | Unknown id | `Err(NotFound)` | 5 | Edge |
| `expired_cleanup` | After TTL | Service removed | 10 | Core |
| `round_robin` | Multiple instances | Balanced selection | 5 | Core |
| `max_instances` | Over limit | `Err(MaxInstancesReached)` | 5 | Edge |
| `concurrent_ops` | Parallel registrations | No race conditions | 10 | Concurrency |
| `event_notification` | Register/deregister | Events emitted | 5 | Core |
| `health_status` | Status change | Updated correctly | 5 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;

    #[tokio::test]
    async fn test_register_service() {
        let registry = ServiceRegistry::new(RegistryConfig::default());

        let registration = ServiceRegistration {
            name: "api-gateway".into(),
            host: "localhost".into(),
            port: 8080,
            tags: vec!["http".into(), "gateway".into()],
            metadata: HashMap::new(),
            ttl: None,
        };

        let result = registry.register(registration).await;
        assert!(result.is_ok());

        let id = result.unwrap();
        let instance = registry.get_instance(id).await.unwrap();
        assert_eq!(instance.name, "api-gateway");
        assert_eq!(instance.port, 8080);
    }

    #[tokio::test]
    async fn test_discover_by_name() {
        let registry = ServiceRegistry::new(RegistryConfig::default());

        let reg1 = ServiceRegistration {
            name: "user-service".into(),
            host: "host1".into(),
            port: 8081,
            tags: vec![],
            metadata: HashMap::new(),
            ttl: None,
        };

        let reg2 = ServiceRegistration {
            name: "user-service".into(),
            host: "host2".into(),
            port: 8082,
            tags: vec![],
            metadata: HashMap::new(),
            ttl: None,
        };

        registry.register(reg1).await.unwrap();
        registry.register(reg2).await.unwrap();

        let instances = registry.discover("user-service").await.unwrap();
        assert_eq!(instances.len(), 2);
    }

    #[tokio::test]
    async fn test_heartbeat_renews_ttl() {
        let config = RegistryConfig {
            default_ttl: Duration::from_millis(100),
            ..Default::default()
        };
        let registry = ServiceRegistry::new(config);

        let registration = ServiceRegistration {
            name: "test-service".into(),
            host: "localhost".into(),
            port: 9000,
            tags: vec![],
            metadata: HashMap::new(),
            ttl: Some(Duration::from_millis(100)),
        };

        let id = registry.register(registration).await.unwrap();

        sleep(Duration::from_millis(50)).await;
        registry.heartbeat(id).await.unwrap();

        sleep(Duration::from_millis(60)).await;
        let instance = registry.get_instance(id).await;
        assert!(instance.is_ok());
    }

    #[tokio::test]
    async fn test_round_robin_balancer() {
        let balancer = RoundRobinBalancer::new();

        let instances = vec![
            ServiceInstance {
                id: ServiceId::new(),
                name: "svc".into(),
                host: "host1".into(),
                port: 8080,
                tags: vec![],
                metadata: HashMap::new(),
                health_status: HealthStatus::Healthy,
                registered_at: Utc::now(),
                last_heartbeat: Instant::now(),
                version: 1,
            },
            ServiceInstance {
                id: ServiceId::new(),
                name: "svc".into(),
                host: "host2".into(),
                port: 8080,
                tags: vec![],
                metadata: HashMap::new(),
                health_status: HealthStatus::Healthy,
                registered_at: Utc::now(),
                last_heartbeat: Instant::now(),
                version: 1,
            },
        ];

        let first = balancer.next(&instances).await.unwrap();
        let second = balancer.next(&instances).await.unwrap();
        let third = balancer.next(&instances).await.unwrap();

        assert_ne!(first.host, second.host);
        assert_eq!(first.host, third.host);
    }

    #[tokio::test]
    async fn test_event_notification() {
        let registry = ServiceRegistry::new(RegistryConfig::default());
        let mut rx = registry.subscribe();

        let registration = ServiceRegistration {
            name: "event-test".into(),
            host: "localhost".into(),
            port: 7000,
            tags: vec![],
            metadata: HashMap::new(),
            ttl: None,
        };

        let id = registry.register(registration).await.unwrap();

        let event = rx.recv().await.unwrap();
        match event {
            RegistryEvent::ServiceRegistered(event_id, name) => {
                assert_eq!(event_id, id);
                assert_eq!(name, "event-test");
            }
            _ => panic!("Expected ServiceRegistered event"),
        }
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{RwLock, broadcast};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ServiceId(pub Uuid);

impl ServiceId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct ServiceInstance {
    pub id: ServiceId,
    pub name: String,
    pub host: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub health_status: HealthStatus,
    pub registered_at: DateTime<Utc>,
    pub last_heartbeat: Instant,
    pub version: u64,
    pub ttl: Duration,
}

#[derive(Debug, Clone)]
pub struct RegistryConfig {
    pub default_ttl: Duration,
    pub health_check_interval: Duration,
    pub max_instances_per_service: usize,
}

impl Default for RegistryConfig {
    fn default() -> Self {
        Self {
            default_ttl: Duration::from_secs(30),
            health_check_interval: Duration::from_secs(10),
            max_instances_per_service: 100,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ServiceRegistration {
    pub name: String,
    pub host: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub ttl: Option<Duration>,
}

#[derive(Debug, Clone)]
pub enum RegistryEvent {
    ServiceRegistered(ServiceId, String),
    ServiceDeregistered(ServiceId, String),
    ServiceHealthChanged(ServiceId, HealthStatus),
}

#[derive(Debug, Clone, PartialEq, thiserror::Error)]
pub enum RegistryError {
    #[error("Service not found: {0}")]
    NotFound(String),
    #[error("Service already exists: {0}")]
    AlreadyExists(String),
    #[error("Max instances reached for service: {0}")]
    MaxInstancesReached(String),
    #[error("Invalid registration: {0}")]
    InvalidRegistration(String),
    #[error("Internal error: {0}")]
    Internal(String),
}

pub struct ServiceRegistry {
    config: RegistryConfig,
    services: Arc<RwLock<HashMap<ServiceId, ServiceInstance>>>,
    by_name: Arc<RwLock<HashMap<String, Vec<ServiceId>>>>,
    event_tx: broadcast::Sender<RegistryEvent>,
}

impl ServiceRegistry {
    pub fn new(config: RegistryConfig) -> Self {
        let (event_tx, _) = broadcast::channel(1024);
        Self {
            config,
            services: Arc::new(RwLock::new(HashMap::new())),
            by_name: Arc::new(RwLock::new(HashMap::new())),
            event_tx,
        }
    }

    pub async fn register(&self, registration: ServiceRegistration) -> Result<ServiceId, RegistryError> {
        if registration.name.is_empty() {
            return Err(RegistryError::InvalidRegistration("Name cannot be empty".into()));
        }

        if registration.port == 0 {
            return Err(RegistryError::InvalidRegistration("Port cannot be 0".into()));
        }

        let mut by_name = self.by_name.write().await;
        let current_count = by_name.get(&registration.name).map_or(0, |v| v.len());

        if current_count >= self.config.max_instances_per_service {
            return Err(RegistryError::MaxInstancesReached(registration.name));
        }

        let id = ServiceId::new();
        let instance = ServiceInstance {
            id,
            name: registration.name.clone(),
            host: registration.host,
            port: registration.port,
            tags: registration.tags,
            metadata: registration.metadata,
            health_status: HealthStatus::Healthy,
            registered_at: Utc::now(),
            last_heartbeat: Instant::now(),
            version: 1,
            ttl: registration.ttl.unwrap_or(self.config.default_ttl),
        };

        let mut services = self.services.write().await;
        services.insert(id, instance);

        by_name.entry(registration.name.clone())
            .or_insert_with(Vec::new)
            .push(id);

        let _ = self.event_tx.send(RegistryEvent::ServiceRegistered(id, registration.name));

        Ok(id)
    }

    pub async fn deregister(&self, id: ServiceId) -> Result<(), RegistryError> {
        let mut services = self.services.write().await;

        let instance = services.remove(&id)
            .ok_or_else(|| RegistryError::NotFound(format!("{:?}", id)))?;

        let mut by_name = self.by_name.write().await;
        if let Some(ids) = by_name.get_mut(&instance.name) {
            ids.retain(|&i| i != id);
            if ids.is_empty() {
                by_name.remove(&instance.name);
            }
        }

        let _ = self.event_tx.send(RegistryEvent::ServiceDeregistered(id, instance.name));

        Ok(())
    }

    pub async fn discover(&self, name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let by_name = self.by_name.read().await;
        let services = self.services.read().await;

        let ids = by_name.get(name).cloned().unwrap_or_default();
        let instances: Vec<_> = ids.iter()
            .filter_map(|id| services.get(id))
            .filter(|s| s.health_status == HealthStatus::Healthy)
            .cloned()
            .collect();

        Ok(instances)
    }

    pub async fn discover_by_tag(&self, tag: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let services = self.services.read().await;

        let instances: Vec<_> = services.values()
            .filter(|s| s.tags.contains(&tag.to_string()))
            .filter(|s| s.health_status == HealthStatus::Healthy)
            .cloned()
            .collect();

        Ok(instances)
    }

    pub async fn heartbeat(&self, id: ServiceId) -> Result<(), RegistryError> {
        let mut services = self.services.write().await;

        let instance = services.get_mut(&id)
            .ok_or_else(|| RegistryError::NotFound(format!("{:?}", id)))?;

        instance.last_heartbeat = Instant::now();
        instance.health_status = HealthStatus::Healthy;
        instance.version += 1;

        Ok(())
    }

    pub async fn get_instance(&self, id: ServiceId) -> Result<ServiceInstance, RegistryError> {
        let services = self.services.read().await;
        services.get(&id)
            .cloned()
            .ok_or_else(|| RegistryError::NotFound(format!("{:?}", id)))
    }

    pub async fn list_all(&self) -> Vec<ServiceInstance> {
        let services = self.services.read().await;
        services.values().cloned().collect()
    }

    pub async fn service_count(&self) -> usize {
        let services = self.services.read().await;
        services.len()
    }

    pub fn subscribe(&self) -> broadcast::Receiver<RegistryEvent> {
        self.event_tx.subscribe()
    }

    pub fn start_health_checker(&self) -> tokio::task::JoinHandle<()> {
        let services = self.services.clone();
        let by_name = self.by_name.clone();
        let event_tx = self.event_tx.clone();
        let interval = self.config.health_check_interval;

        tokio::spawn(async move {
            let mut ticker = tokio::time::interval(interval);

            loop {
                ticker.tick().await;

                let mut services_guard = services.write().await;
                let mut by_name_guard = by_name.write().await;
                let now = Instant::now();

                let expired: Vec<_> = services_guard.iter()
                    .filter(|(_, s)| now.duration_since(s.last_heartbeat) > s.ttl)
                    .map(|(id, s)| (*id, s.name.clone()))
                    .collect();

                for (id, name) in expired {
                    services_guard.remove(&id);
                    if let Some(ids) = by_name_guard.get_mut(&name) {
                        ids.retain(|&i| i != id);
                        if ids.is_empty() {
                            by_name_guard.remove(&name);
                        }
                    }
                    let _ = event_tx.send(RegistryEvent::ServiceDeregistered(id, name));
                }
            }
        })
    }
}

pub struct RoundRobinBalancer {
    counters: Arc<RwLock<HashMap<String, usize>>>,
}

impl RoundRobinBalancer {
    pub fn new() -> Self {
        Self {
            counters: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn next(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        if instances.is_empty() {
            return None;
        }

        let healthy: Vec<_> = instances.iter()
            .filter(|i| i.health_status == HealthStatus::Healthy)
            .collect();

        if healthy.is_empty() {
            return None;
        }

        let name = &healthy[0].name;
        let mut counters = self.counters.write().await;
        let counter = counters.entry(name.clone()).or_insert(0);

        let index = *counter % healthy.len();
        *counter = counter.wrapping_add(1);

        Some(healthy[index].clone())
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de DashMap pour concurrence
use dashmap::DashMap;

pub struct ServiceRegistryDashMap {
    services: DashMap<ServiceId, ServiceInstance>,
    by_name: DashMap<String, Vec<ServiceId>>,
}

// Alternative 2 : Utilisation de parking_lot pour verrous
use parking_lot::RwLock;

pub struct ServiceRegistryParkingLot {
    services: Arc<RwLock<HashMap<ServiceId, ServiceInstance>>>,
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Pas de validation de l'enregistrement
pub async fn register(&self, reg: ServiceRegistration) -> Result<ServiceId, RegistryError> {
    // ERREUR: Accepte des enregistrements invalides
    let id = ServiceId::new();
    self.services.write().await.insert(id, /* ... */);
    Ok(id)
}
// Pourquoi refusee : Doit valider name non vide et port valide

// REFUSEE 2 : discover retourne des services unhealthy
pub async fn discover(&self, name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
    let services = self.services.read().await;
    // ERREUR: Ne filtre pas par health_status
    Ok(services.values().filter(|s| s.name == name).cloned().collect())
}
// Pourquoi refusee : Ne doit retourner que les services Healthy

// REFUSEE 3 : Race condition dans le health checker
pub fn start_health_checker(&self) {
    loop {
        let services = self.services.read().await;
        for (id, s) in services.iter() {
            if expired(s) {
                // ERREUR: Deadlock - tentative de write pendant read
                self.services.write().await.remove(id);
            }
        }
    }
}
// Pourquoi refusee : Deadlock avec le read lock actif
```

### 4.9 spec.json

```json
{
  "name": "service_registry",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Composant integre - Service Discovery",
  "tags": ["microservices", "service-discovery", "registry", "distributed", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "ServiceRegistry",
    "prototype": "impl ServiceRegistry",
    "return_type": "struct",
    "parameters": [
      {"name": "config", "type": "RegistryConfig"}
    ]
  },

  "driver": {
    "reference": "/* See Section 4.3 */",

    "edge_cases": [
      {
        "name": "empty_name",
        "input": {"name": ""},
        "expected": "Err(InvalidRegistration)",
        "is_trap": true,
        "trap_explanation": "Service name cannot be empty"
      },
      {
        "name": "zero_port",
        "input": {"port": 0},
        "expected": "Err(InvalidRegistration)",
        "is_trap": true,
        "trap_explanation": "Port 0 is reserved"
      },
      {
        "name": "max_instances",
        "input": "101 registrations same name",
        "expected": "Err(MaxInstancesReached)",
        "is_trap": true,
        "trap_explanation": "Default limit is 100 instances per service"
      },
      {
        "name": "expired_ttl",
        "input": "Service with TTL=100ms after 200ms",
        "expected": "Service removed",
        "is_trap": true,
        "trap_explanation": "TTL expiration must trigger cleanup"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator": "random_service_registration"
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["tokio", "uuid", "chrono", "serde", "thiserror"],
    "forbidden_functions": ["unsafe", "std::thread"],
    "forbidden_crates": ["consul", "etcd-client"],
    "check_security": true,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Accepte TTL de 0 */
pub async fn register(&self, reg: ServiceRegistration) -> Result<ServiceId, RegistryError> {
    // MUTANT: Pas de validation du TTL
    let ttl = reg.ttl.unwrap_or(self.config.default_ttl);
    // TTL de 0 cause une expiration immediate
}
// Pourquoi c'est faux : TTL=0 invalide, service expire instantanement
// Ce qui etait pense : "Le TTL sera juste tres court"

/* Mutant B (Safety) : Pas de verrou pendant l'iteration */
pub async fn discover(&self, name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
    // MUTANT: Drop le lock trop tot
    let ids = {
        let by_name = self.by_name.read().await;
        by_name.get(name).cloned().unwrap_or_default()
    }; // Lock relache ici

    // ERREUR: Services peuvent etre supprimes entre-temps
    let services = self.services.read().await;
    // ...
}
// Pourquoi c'est faux : Race condition entre les deux lectures
// Ce qui etait pense : "Minimiser la duree du lock"

/* Mutant C (Logic) : Health checker ne supprime pas */
pub fn start_health_checker(&self) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        loop {
            let services = services.read().await;
            for (id, s) in services.iter() {
                if expired(s) {
                    // MUTANT: Juste marque unhealthy, ne supprime pas
                    s.health_status = HealthStatus::Unhealthy;
                }
            }
        }
    })
}
// Pourquoi c'est faux : Les services morts s'accumulent indefiniment
// Ce qui etait pense : "Marquer unhealthy suffit"

/* Mutant D (Edge) : Ecrase sans verification */
pub async fn register(&self, reg: ServiceRegistration) -> Result<ServiceId, RegistryError> {
    // MUTANT: Utilise un hash de (name, host, port) comme ID
    let id = ServiceId(hash(&reg.name, &reg.host, reg.port));
    // ERREUR: Meme service = meme ID, ecrase les metadonnees
    self.services.write().await.insert(id, /* ... */);
}
// Pourquoi c'est faux : Une mise a jour ne devrait pas creer un nouvel ID
// Ce qui etait pense : "Eviter les doublons"

/* Mutant E (Return) : discover retourne unhealthy */
pub async fn discover(&self, name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
    let services = self.services.read().await;
    // MUTANT: Pas de filtre sur health_status
    Ok(services.values()
        .filter(|s| s.name == name)
        .cloned()
        .collect())
}
// Pourquoi c'est faux : Les clients recevront des services morts
// Ce qui etait pense : "Laisser le client decider"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Service Discovery Pattern** : Enregistrement et localisation dynamique
2. **Concurrence Async** : Arc, RwLock, tokio::sync
3. **TTL et Health Checks** : Gestion de la vivacite des services
4. **Event Broadcasting** : Notification des changements
5. **Load Balancing** : Distribution de charge round-robin

### 5.2 LDA - Traduction Litterale

```
FONCTION register QUI RECOIT registration ET RETOURNE Result
DEBUT FONCTION
    SI registration.name EST VIDE ALORS
        RETOURNER Erreur "Invalid registration"
    FIN SI

    ACQUERIR verrou ecriture sur by_name
    COMPTER instances existantes pour ce nom

    SI compte >= max_instances ALORS
        RETOURNER Erreur "Max instances reached"
    FIN SI

    CREER nouvel ID unique
    CREER instance avec metadonnees et timestamp

    ACQUERIR verrou ecriture sur services
    INSERER instance dans services
    AJOUTER id a la liste by_name

    EMETTRE evenement ServiceRegistered
    RETOURNER Ok(id)
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : Service Registration
---
ENTREE : ServiceRegistration (name, host, port, tags, metadata)
SORTIE : ServiceId ou RegistryError

1. VALIDER les champs obligatoires (name non vide, port > 0)
2. VERIFIER le nombre d'instances existantes
3. GENERER un identifiant unique UUID
4. CREER une ServiceInstance avec timestamp
5. STOCKER dans la HashMap des services
6. INDEXER par nom pour recherche rapide
7. NOTIFIER les abonnes du nouvel enregistrement
8. RETOURNER l'identifiant
```

### 5.3 Visualisation ASCII

```
                    SERVICE REGISTRY ARCHITECTURE

    ┌─────────────────────────────────────────────────────────────┐
    │                     ServiceRegistry                         │
    │                                                             │
    │  ┌─────────────────┐       ┌─────────────────┐             │
    │  │  services       │       │  by_name        │             │
    │  │  HashMap        │◄──────│  HashMap        │             │
    │  │                 │       │                 │             │
    │  │  id1 -> inst1   │       │  "api" -> [id1] │             │
    │  │  id2 -> inst2   │       │  "db"  -> [id2] │             │
    │  │  id3 -> inst3   │       │                 │             │
    │  └─────────────────┘       └─────────────────┘             │
    │           │                                                 │
    │           ▼                                                 │
    │  ┌─────────────────┐       ┌─────────────────┐             │
    │  │  event_tx       │──────►│  Subscribers    │             │
    │  │  (broadcast)    │       │  (receivers)    │             │
    │  └─────────────────┘       └─────────────────┘             │
    │                                                             │
    └─────────────────────────────────────────────────────────────┘
                              │
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                    Health Checker Task                       │
    │                                                             │
    │    CHAQUE 10 secondes:                                      │
    │      POUR CHAQUE service:                                   │
    │        SI last_heartbeat + TTL < now:                       │
    │          SUPPRIMER service                                  │
    │          EMETTRE ServiceDeregistered                        │
    │                                                             │
    └─────────────────────────────────────────────────────────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Deadlock** | Lock read puis write | Acquerir write d'emblee ou relacher avant |
| **Race condition** | Check-then-act | Operations atomiques avec write lock |
| **Memory leak** | Services jamais supprimes | Health checker avec cleanup |
| **Stale data** | Cache invalide | Versioning et events |
| **Thundering herd** | Tous decouvrent en meme temps | Rate limiting ou cache |

### 5.5 Cours Complet

#### 5.5.1 Introduction au Service Discovery

Le Service Discovery resout le probleme de la localisation dynamique des services dans un environnement distribue. Contrairement a la configuration statique (fichiers de config, variables d'environnement), le discovery permet :

- **Elasticite** : Ajouter/supprimer des instances sans redemarrage
- **Resilience** : Detection automatique des pannes
- **Load Balancing** : Distribution intelligente du trafic

#### 5.5.2 Patterns de Service Discovery

**Client-Side Discovery** :
```
Client ──query──► Registry ──response──► Client ──direct call──► Service
```

**Server-Side Discovery** :
```
Client ──call──► Load Balancer ──query──► Registry
                      │
                      └──route──► Service
```

#### 5.5.3 Health Checks

Trois types de health checks :
1. **TTL (Heartbeat)** : Le service envoie un signal periodique
2. **HTTP** : Le registry appelle un endpoint /health
3. **TCP** : Le registry verifie la connectivite

```rust
// TTL-based health check
if now.duration_since(instance.last_heartbeat) > instance.ttl {
    instance.health_status = HealthStatus::Unhealthy;
}
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Validation manquante | Services invalides acceptes | Valider tous les champs |
| 2 | Lock ordering | Deadlock | Toujours meme ordre |
| 3 | No cleanup | Memory leak | Health checker |
| 4 | Unhealthy returned | Clients echouent | Filtrer discover() |
| 5 | Event drop | Subscribers perdent events | Buffer suffisant |

---

## SECTION 7 : QCM

### Question 1
**Quel est le role principal d'un Service Registry ?**

A) Stocker les donnees des services
B) Permettre aux services de se decouvrir mutuellement
C) Gerer l'authentification
D) Compiler le code
E) Monitorer les metriques

**Reponse : B**

*Explication : Le Service Registry est un annuaire central permettant l'enregistrement et la decouverte de services.*

---

### Question 2
**Pourquoi utiliser un TTL (Time To Live) ?**

A) Pour accelerer les requetes
B) Pour detecter et supprimer les services morts
C) Pour limiter la memoire
D) Pour chiffrer les donnees

**Reponse : B**

*Explication : Le TTL permet de detecter les services qui ne repondent plus et de les supprimer automatiquement.*

---

### Question 3
**Quel probleme resout le Round Robin ?**

A) La securite
B) La distribution equitable de la charge
C) Le stockage
D) La serialization

**Reponse : B**

*Explication : Round Robin distribue les requetes de maniere cyclique entre les instances disponibles.*

---

### Question 4
**Pourquoi filtrer les services Unhealthy dans discover() ?**

A) Pour reduire le temps de reponse
B) Pour eviter d'envoyer du trafic a des services defaillants
C) Pour economiser la memoire
D) Pour respecter la vie privee

**Reponse : B**

*Explication : Retourner des services unhealthy causerait des erreurs chez les clients.*

---

### Question 5
**Quel type de lock utiliser pour des lectures frequentes ?**

A) Mutex
B) RwLock
C) Spinlock
D) Aucun lock

**Reponse : B**

*Explication : RwLock permet plusieurs lecteurs simultanement, ideal pour un registry ou les lectures dominent.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | service_registry |
| **Module** | 5.6.10 — Service Discovery & Registry |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 200 (base) + bonus x3 |
| **Concepts cles** | Registry, Discovery, Health Checks, TTL |
| **Piege principal** | Race conditions et deadlocks |
| **Prerequis valide** | Async Rust, concurrence |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.6.10-a-service-registry",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.6.10-a",
      "exercise_name": "service_registry",
      "module": "5.6.10",
      "module_name": "Service Discovery & Registry",
      "concept": "a",
      "concept_name": "Service Registry Implementation",
      "type": "code",
      "tier": 2,
      "tier_info": "Composant integre",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "7/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 200,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(1)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.5", "3.2", "5.6.1"],
      "domains": ["Microservices", "Distributed Systems", "Concurrency"],
      "domains_bonus": ["Distributed Systems", "Consensus"],
      "tags": ["service-discovery", "registry", "health-checks", "ttl"],
      "meme_reference": "The Registry Knows All (Neuromancer)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "alternatives/alt_1.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_edge.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "alternatives/alt_1.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_edge.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --lib",
      "test_reference": "cargo test --lib -- --test-threads=1",
      "test_mutants": "cargo mutants --package service_registry"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "The Registry Knows All"*
*Exercise Quality Score: 96/100*
