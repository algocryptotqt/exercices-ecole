<thinking>
## Analyse du Concept
- Concept : Circuit Breaker Pattern
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le circuit breaker est fondamental pour la resilience des microservices.

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Transition Half-Open vers Closed trop rapide
2. Mutant B (Safety) : Race condition sur les compteurs d'echecs
3. Mutant C (Logic) : Pas de reset du compteur de succes en Closed
4. Mutant D (Edge) : Timer pas demarre lors de l'ouverture
5. Mutant E (Return) : Erreur non propagee correctement

## Verdict
VALIDE - Exercice de qualite industrielle couvrant la resilience
</thinking>

# Exercice 5.6.11-a : circuit_breaker

**Module :**
5.6.11 — Resilience Patterns - Circuit Breaker

**Concept :**
a — Circuit Breaker Pattern (Closed, Open, Half-Open states)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.4 — Gestion d'erreurs (Result, Option)
- 3.5 — Programmation async avec tokio
- 5.6.9 — Health patterns

**Domaines :**
Resilience, Async, StateMachine

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(1) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `std::sync` (synchronisation)
- `std::time` (durations)

**Fonctions/methodes interdites :**
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Electric Guardian"**

*"Quand le courant devient trop fort, je coupe. Quand les choses se calment, je laisse passer un peu. Si ca marche, je retablis. C'est aussi simple que ca."* — Le Circuit Breaker

Le Circuit Breaker est un pattern de resilience qui empeche les appels repetitifs a un service defaillant. Comme un disjoncteur electrique, il "ouvre" le circuit quand trop d'erreurs se produisent.

**Ta mission :**

Implementer un `CircuitBreaker` avec trois etats :
1. **Closed** : Fonctionnement normal, les requetes passent
2. **Open** : Circuit ouvert, les requetes sont rejetees immediatement
3. **Half-Open** : Test de recuperation, quelques requetes passent

**Entree :**
- `operation: F` — Fonction async a proteger

**Sortie :**
- `Result<T, CircuitError<E>>` — Resultat ou erreur de circuit

**Contraintes :**
- Thread-safe (Send + Sync)
- Transitions d'etat atomiques
- Metriques observables
- Configuration flexible (thresholds, timeouts)

### 1.3 Prototype

```rust
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
use tokio::sync::RwLock;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: u32,
    pub success_threshold: u32,
    pub open_timeout: Duration,
    pub half_open_max_calls: u32,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            success_threshold: 3,
            open_timeout: Duration::from_secs(30),
            half_open_max_calls: 3,
        }
    }
}

#[derive(Debug)]
pub enum CircuitError<E> {
    Open,
    HalfOpenRejected,
    OperationFailed(E),
}

#[derive(Debug, Clone, Default)]
pub struct CircuitMetrics {
    pub total_calls: u64,
    pub successful_calls: u64,
    pub failed_calls: u64,
    pub rejected_calls: u64,
    pub state_transitions: u64,
}

pub struct CircuitBreaker {
    config: CircuitBreakerConfig,
    state: Arc<RwLock<InnerState>>,
    metrics: Arc<Metrics>,
}

struct InnerState {
    state: CircuitState,
    failure_count: u32,
    success_count: u32,
    opened_at: Option<Instant>,
    half_open_calls: u32,
}

struct Metrics {
    total_calls: AtomicU64,
    successful_calls: AtomicU64,
    failed_calls: AtomicU64,
    rejected_calls: AtomicU64,
    state_transitions: AtomicU64,
}

impl CircuitBreaker {
    pub fn new(config: CircuitBreakerConfig) -> Self;

    /// Execute une operation avec protection du circuit
    pub async fn call<F, T, E, Fut>(&self, operation: F) -> Result<T, CircuitError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>;

    /// Retourne l'etat actuel du circuit
    pub async fn state(&self) -> CircuitState;

    /// Force le circuit a se fermer
    pub async fn reset(&self);

    /// Force le circuit a s'ouvrir
    pub async fn trip(&self);

    /// Retourne les metriques actuelles
    pub fn metrics(&self) -> CircuitMetrics;

    /// Verifie si une operation peut etre executee
    pub async fn can_execute(&self) -> bool;
}

impl std::fmt::Display for CircuitState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Pattern

Le pattern Circuit Breaker a ete popularise par Michael Nygard dans son livre "Release It!" (2007). Il est inspire des disjoncteurs electriques qui coupent le courant pour proteger les circuits.

### 2.2 Les Trois Etats

```
    ┌─────────┐
    │  CLOSED │ ◄─── Fonctionnement normal
    └────┬────┘
         │ failures >= threshold
         ▼
    ┌─────────┐
    │   OPEN  │ ◄─── Toutes requetes rejetees
    └────┬────┘
         │ timeout expired
         ▼
    ┌───────────┐
    │ HALF-OPEN │ ◄─── Test de recuperation
    └─────┬─────┘
          │
    ┌─────┴─────┐
    ▼           ▼
 [Success]   [Failure]
    │           │
    ▼           ▼
  CLOSED      OPEN
```

### 2.3 Fallback Strategies

Le circuit breaker peut etre combine avec des fallbacks :
- **Cache** : Retourner une valeur cachee
- **Default** : Retourner une valeur par defaut
- **Alternative** : Appeler un service backup

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling circuit_breaker v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 12 tests
test tests::test_closed_state_success ... ok
test tests::test_closed_state_failure ... ok
test tests::test_transition_to_open ... ok
test tests::test_open_rejects ... ok
test tests::test_transition_to_half_open ... ok
test tests::test_half_open_success ... ok
test tests::test_half_open_failure ... ok
test tests::test_reset ... ok
test tests::test_trip ... ok
test tests::test_metrics ... ok
test tests::test_concurrent_calls ... ok
test tests::test_can_execute ... ok

test result: ok. 12 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `closed_success` | 5 successful calls | Remains Closed | 10 | Core |
| `closed_failure` | 5 failed calls | Opens | 10 | Core |
| `open_rejects` | Call when Open | CircuitError::Open | 10 | Core |
| `timeout_half_open` | Wait after Open | Transitions to HalfOpen | 10 | Core |
| `half_open_success` | success_threshold calls | Closes | 10 | Core |
| `half_open_failure` | 1 failure | Reopens | 10 | Edge |
| `half_open_limit` | >half_open_max_calls | Rejects excess | 10 | Edge |
| `reset` | Manual reset | Returns to Closed | 5 | Core |
| `metrics` | Various operations | Correct counts | 10 | Core |
| `concurrent_calls` | Parallel calls | Thread-safe | 15 | Edge |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_closed_state_success() {
        let cb = CircuitBreaker::new(CircuitBreakerConfig::default());

        for _ in 0..5 {
            let result = cb.call(|| async { Ok::<_, &str>(42) }).await;
            assert!(result.is_ok());
        }

        assert_eq!(cb.state().await, CircuitState::Closed);
    }

    #[tokio::test]
    async fn test_transition_to_open() {
        let config = CircuitBreakerConfig {
            failure_threshold: 3,
            ..Default::default()
        };
        let cb = CircuitBreaker::new(config);

        // Cause 3 failures
        for _ in 0..3 {
            let _ = cb.call(|| async { Err::<i32, _>("error") }).await;
        }

        assert_eq!(cb.state().await, CircuitState::Open);
    }

    #[tokio::test]
    async fn test_open_rejects() {
        let config = CircuitBreakerConfig {
            failure_threshold: 1,
            ..Default::default()
        };
        let cb = CircuitBreaker::new(config);

        // Trigger open
        let _ = cb.call(|| async { Err::<i32, _>("error") }).await;

        // Should be rejected
        let result = cb.call(|| async { Ok::<_, &str>(42) }).await;
        assert!(matches!(result, Err(CircuitError::Open)));
    }

    #[tokio::test]
    async fn test_half_open_success() {
        let config = CircuitBreakerConfig {
            failure_threshold: 1,
            success_threshold: 2,
            open_timeout: Duration::from_millis(50),
            half_open_max_calls: 3,
        };
        let cb = CircuitBreaker::new(config);

        // Trigger open
        let _ = cb.call(|| async { Err::<i32, _>("error") }).await;
        assert_eq!(cb.state().await, CircuitState::Open);

        // Wait for timeout
        tokio::time::sleep(Duration::from_millis(60)).await;

        // Should be half-open now
        assert_eq!(cb.state().await, CircuitState::HalfOpen);

        // 2 successes should close
        for _ in 0..2 {
            let result = cb.call(|| async { Ok::<_, &str>(42) }).await;
            assert!(result.is_ok());
        }

        assert_eq!(cb.state().await, CircuitState::Closed);
    }

    #[tokio::test]
    async fn test_metrics() {
        let cb = CircuitBreaker::new(CircuitBreakerConfig::default());

        cb.call(|| async { Ok::<_, &str>(1) }).await.ok();
        cb.call(|| async { Err::<i32, _>("err") }).await.ok();

        let metrics = cb.metrics();
        assert_eq!(metrics.total_calls, 2);
        assert_eq!(metrics.successful_calls, 1);
        assert_eq!(metrics.failed_calls, 1);
    }
}
```

### 4.3 Solution de reference

```rust
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::sync::atomic::{AtomicU64, Ordering};
use tokio::sync::RwLock;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

impl std::fmt::Display for CircuitState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Closed => write!(f, "Closed"),
            Self::Open => write!(f, "Open"),
            Self::HalfOpen => write!(f, "HalfOpen"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: u32,
    pub success_threshold: u32,
    pub open_timeout: Duration,
    pub half_open_max_calls: u32,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            success_threshold: 3,
            open_timeout: Duration::from_secs(30),
            half_open_max_calls: 3,
        }
    }
}

#[derive(Debug)]
pub enum CircuitError<E> {
    Open,
    HalfOpenRejected,
    OperationFailed(E),
}

impl<E: std::fmt::Display> std::fmt::Display for CircuitError<E> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Open => write!(f, "Circuit is open"),
            Self::HalfOpenRejected => write!(f, "Circuit is half-open and at capacity"),
            Self::OperationFailed(e) => write!(f, "Operation failed: {}", e),
        }
    }
}

struct InnerState {
    state: CircuitState,
    failure_count: u32,
    success_count: u32,
    opened_at: Option<Instant>,
    half_open_calls: u32,
}

struct Metrics {
    total_calls: AtomicU64,
    successful_calls: AtomicU64,
    failed_calls: AtomicU64,
    rejected_calls: AtomicU64,
    state_transitions: AtomicU64,
}

impl Default for Metrics {
    fn default() -> Self {
        Self {
            total_calls: AtomicU64::new(0),
            successful_calls: AtomicU64::new(0),
            failed_calls: AtomicU64::new(0),
            rejected_calls: AtomicU64::new(0),
            state_transitions: AtomicU64::new(0),
        }
    }
}

#[derive(Debug, Clone, Default)]
pub struct CircuitMetrics {
    pub total_calls: u64,
    pub successful_calls: u64,
    pub failed_calls: u64,
    pub rejected_calls: u64,
    pub state_transitions: u64,
}

pub struct CircuitBreaker {
    config: CircuitBreakerConfig,
    state: Arc<RwLock<InnerState>>,
    metrics: Arc<Metrics>,
}

impl CircuitBreaker {
    pub fn new(config: CircuitBreakerConfig) -> Self {
        Self {
            config,
            state: Arc::new(RwLock::new(InnerState {
                state: CircuitState::Closed,
                failure_count: 0,
                success_count: 0,
                opened_at: None,
                half_open_calls: 0,
            })),
            metrics: Arc::new(Metrics::default()),
        }
    }

    pub async fn call<F, T, E, Fut>(&self, operation: F) -> Result<T, CircuitError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
    {
        self.metrics.total_calls.fetch_add(1, Ordering::Relaxed);

        // Check if we can execute
        if !self.try_acquire().await {
            self.metrics.rejected_calls.fetch_add(1, Ordering::Relaxed);
            let state = self.state.read().await;
            return match state.state {
                CircuitState::Open => Err(CircuitError::Open),
                CircuitState::HalfOpen => Err(CircuitError::HalfOpenRejected),
                _ => Err(CircuitError::Open),
            };
        }

        // Execute the operation
        match operation().await {
            Ok(result) => {
                self.record_success().await;
                self.metrics.successful_calls.fetch_add(1, Ordering::Relaxed);
                Ok(result)
            }
            Err(e) => {
                self.record_failure().await;
                self.metrics.failed_calls.fetch_add(1, Ordering::Relaxed);
                Err(CircuitError::OperationFailed(e))
            }
        }
    }

    async fn try_acquire(&self) -> bool {
        let mut state = self.state.write().await;

        match state.state {
            CircuitState::Closed => true,
            CircuitState::Open => {
                // Check if timeout has elapsed
                if let Some(opened_at) = state.opened_at {
                    if opened_at.elapsed() >= self.config.open_timeout {
                        // Transition to HalfOpen
                        state.state = CircuitState::HalfOpen;
                        state.half_open_calls = 1;
                        state.success_count = 0;
                        self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
                        return true;
                    }
                }
                false
            }
            CircuitState::HalfOpen => {
                if state.half_open_calls < self.config.half_open_max_calls {
                    state.half_open_calls += 1;
                    true
                } else {
                    false
                }
            }
        }
    }

    async fn record_success(&self) {
        let mut state = self.state.write().await;

        match state.state {
            CircuitState::Closed => {
                state.failure_count = 0;
            }
            CircuitState::HalfOpen => {
                state.success_count += 1;
                if state.success_count >= self.config.success_threshold {
                    // Transition to Closed
                    state.state = CircuitState::Closed;
                    state.failure_count = 0;
                    state.success_count = 0;
                    state.opened_at = None;
                    self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
                }
            }
            _ => {}
        }
    }

    async fn record_failure(&self) {
        let mut state = self.state.write().await;

        match state.state {
            CircuitState::Closed => {
                state.failure_count += 1;
                if state.failure_count >= self.config.failure_threshold {
                    // Transition to Open
                    state.state = CircuitState::Open;
                    state.opened_at = Some(Instant::now());
                    self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
                }
            }
            CircuitState::HalfOpen => {
                // Any failure in HalfOpen reopens the circuit
                state.state = CircuitState::Open;
                state.opened_at = Some(Instant::now());
                state.half_open_calls = 0;
                state.success_count = 0;
                self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
            }
            _ => {}
        }
    }

    pub async fn state(&self) -> CircuitState {
        let mut state = self.state.write().await;

        // Check for automatic transition from Open to HalfOpen
        if state.state == CircuitState::Open {
            if let Some(opened_at) = state.opened_at {
                if opened_at.elapsed() >= self.config.open_timeout {
                    state.state = CircuitState::HalfOpen;
                    state.half_open_calls = 0;
                    state.success_count = 0;
                    self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
                }
            }
        }

        state.state
    }

    pub async fn reset(&self) {
        let mut state = self.state.write().await;
        state.state = CircuitState::Closed;
        state.failure_count = 0;
        state.success_count = 0;
        state.opened_at = None;
        state.half_open_calls = 0;
        self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
    }

    pub async fn trip(&self) {
        let mut state = self.state.write().await;
        state.state = CircuitState::Open;
        state.opened_at = Some(Instant::now());
        self.metrics.state_transitions.fetch_add(1, Ordering::Relaxed);
    }

    pub fn metrics(&self) -> CircuitMetrics {
        CircuitMetrics {
            total_calls: self.metrics.total_calls.load(Ordering::Relaxed),
            successful_calls: self.metrics.successful_calls.load(Ordering::Relaxed),
            failed_calls: self.metrics.failed_calls.load(Ordering::Relaxed),
            rejected_calls: self.metrics.rejected_calls.load(Ordering::Relaxed),
            state_transitions: self.metrics.state_transitions.load(Ordering::Relaxed),
        }
    }

    pub async fn can_execute(&self) -> bool {
        let state = self.state.read().await;
        match state.state {
            CircuitState::Closed => true,
            CircuitState::Open => {
                if let Some(opened_at) = state.opened_at {
                    opened_at.elapsed() >= self.config.open_timeout
                } else {
                    false
                }
            }
            CircuitState::HalfOpen => {
                state.half_open_calls < self.config.half_open_max_calls
            }
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Transition trop rapide */
async fn record_success(&self) {
    let mut state = self.state.write().await;
    if state.state == CircuitState::HalfOpen {
        // MUTANT: Ferme immediatement au premier succes
        state.state = CircuitState::Closed;
    }
}
// Pourquoi c'est faux : Un seul succes ne prouve pas la stabilite

/* Mutant B (Safety) : Race condition */
async fn record_failure(&self) {
    let state = self.state.read().await;
    let new_count = state.failure_count + 1;
    drop(state);
    // MUTANT: Gap entre lecture et ecriture
    let mut state = self.state.write().await;
    state.failure_count = new_count;
}
// Pourquoi c'est faux : Autre thread peut modifier entre-temps

/* Mutant C (Logic) : Pas de reset en Closed */
async fn record_success(&self) {
    let mut state = self.state.write().await;
    if state.state == CircuitState::Closed {
        // MUTANT: Ne reset pas failure_count
        // state.failure_count = 0;
    }
}
// Pourquoi c'est faux : Les echecs s'accumulent meme avec des succes

/* Mutant D (Edge) : Timer non demarre */
async fn record_failure(&self) {
    let mut state = self.state.write().await;
    if state.failure_count >= self.config.failure_threshold {
        state.state = CircuitState::Open;
        // MUTANT: Pas de opened_at = Some(Instant::now())
    }
}
// Pourquoi c'est faux : Sans timer, jamais de transition vers HalfOpen

/* Mutant E (Return) : Erreur non propagee */
pub async fn call<F, T, E, Fut>(&self, operation: F) -> Result<T, CircuitError<E>> {
    match operation().await {
        Ok(result) => Ok(result),
        Err(_) => {
            // MUTANT: Retourne Open au lieu de OperationFailed
            Err(CircuitError::Open)
        }
    }
}
// Pourquoi c'est faux : L'erreur originale est perdue
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **State Machine** : Gestion des transitions d'etat
2. **Resilience** : Protection contre les cascading failures
3. **Concurrency** : Thread-safety avec RwLock et Atomics
4. **Observability** : Metriques pour monitoring
5. **Configuration** : Thresholds et timeouts

### 5.3 Visualisation ASCII

```
                    CIRCUIT BREAKER STATE MACHINE

    ┌──────────────────────────────────────────────────────┐
    │                        CLOSED                         │
    │   (Normal operation, requests pass through)          │
    └────────────────────────┬─────────────────────────────┘
                             │
               failures >= threshold
                             │
                             ▼
    ┌──────────────────────────────────────────────────────┐
    │                         OPEN                          │
    │   (All requests rejected, timer running)             │
    └────────────────────────┬─────────────────────────────┘
                             │
                   timeout elapsed
                             │
                             ▼
    ┌──────────────────────────────────────────────────────┐
    │                      HALF-OPEN                        │
    │   (Limited requests allowed for testing)             │
    └───────────────┬────────────────────┬─────────────────┘
                    │                    │
       success >= threshold         any failure
                    │                    │
                    ▼                    ▼
               [CLOSED]              [OPEN]
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Transition rapide | Instabilite | success_threshold >= 3 |
| 2 | Race condition | Compteurs faux | RwLock atomique |
| 3 | Pas de reset | Accumulation | Reset failure_count en Closed |
| 4 | Timer absent | Stuck en Open | opened_at = Some(Instant::now()) |
| 5 | Erreur perdue | Debug impossible | OperationFailed(E) |

---

## SECTION 7 : QCM

### Question 1
**Quel etat permet de tester si un service est retabli ?**

A) Closed
B) Open
C) HalfOpen
D) Testing

**Reponse : C**

*Explication : HalfOpen permet un nombre limite de requetes pour tester si le service fonctionne a nouveau.*

---

### Question 2
**Que se passe-t-il si une requete echoue en HalfOpen ?**

A) Le circuit reste en HalfOpen
B) Le circuit passe en Closed
C) Le circuit repasse en Open
D) L'erreur est ignoree

**Reponse : C**

*Explication : Une seule erreur en HalfOpen suffit a reopvrir le circuit.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | circuit_breaker |
| **Module** | 5.6.11 — Circuit Breaker |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 |
| **Concepts cles** | States, thresholds, timeouts, metrics |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.11-a-circuit-breaker",
    "metadata": {
      "exercise_id": "5.6.11-a",
      "exercise_name": "circuit_breaker",
      "difficulty": 7,
      "xp_base": 175
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 96/100*
