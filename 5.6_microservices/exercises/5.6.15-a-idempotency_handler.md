<thinking>
## Analyse du Concept
- Concept : Idempotency Handler
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - L'idempotence est critique pour la fiabilite des systemes distribues.
</thinking>

# Exercice 5.6.15-a : idempotency_handler

**Module :**
5.6.15 — Microservices Patterns - Idempotency

**Concept :**
a — Idempotency Handler (deduplication, at-least-once safety)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.7 — Outbox Pattern

**Domaines :**
Messaging, Reliability, Deduplication

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(1) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `uuid` (identifiants)
- `chrono` (timestamps)

### 1.2 Consigne

**CONTEXTE : "The Duplicate Detector"**

*"Peu importe combien de fois tu m'envoies la meme requete, le resultat sera identique. C'est ma promesse."* — Le Gardien de l'Idempotence

Une operation est idempotente si l'executer plusieurs fois produit le meme resultat qu'une seule execution. C'est crucial dans les systemes distribues ou les messages peuvent etre delivres plusieurs fois.

**Ta mission :**

Implementer un `IdempotencyHandler` qui :
1. Detecte les requetes dupliquees via une cle d'idempotence
2. Retourne le resultat cache pour les duplicatas
3. Gere les requetes in-flight (meme cle en cours de traitement)
4. Expire les anciennes entrees pour eviter l'OOM

### 1.3 Prototype

```rust
use std::time::Duration;
use std::collections::HashMap;
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdempotencyKey(String);

impl IdempotencyKey {
    pub fn new(key: impl Into<String>) -> Self;
    pub fn from_request(method: &str, path: &str, body_hash: &str) -> Self;
}

#[derive(Debug, Clone)]
pub enum IdempotencyResult<T> {
    New,                    // Premiere requete, executer l'operation
    Duplicate(T),           // Requete dupliquee, retourner le resultat cache
    InFlight,               // Meme requete en cours de traitement
}

#[derive(Debug)]
pub enum IdempotencyError {
    Conflict,               // Requete en cours pour cette cle
    StorageError(String),
    Expired,
}

#[derive(Debug, Clone)]
pub struct IdempotencyRecord<T> {
    pub key: IdempotencyKey,
    pub result: Option<T>,
    pub status: RecordStatus,
    pub created_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum RecordStatus {
    InProgress,
    Completed,
    Failed,
}

pub struct IdempotencyHandler<T: Clone> {
    records: tokio::sync::RwLock<HashMap<IdempotencyKey, IdempotencyRecord<T>>>,
    ttl: Duration,
}

impl<T: Clone + Send + Sync + 'static> IdempotencyHandler<T> {
    pub fn new(ttl: Duration) -> Self;

    /// Verifie si une requete est un duplicata
    pub async fn check(&self, key: &IdempotencyKey) -> IdempotencyResult<T>;

    /// Enregistre le debut d'une operation
    pub async fn start(&self, key: IdempotencyKey) -> Result<(), IdempotencyError>;

    /// Enregistre la fin d'une operation avec son resultat
    pub async fn complete(&self, key: &IdempotencyKey, result: T) -> Result<(), IdempotencyError>;

    /// Marque une operation comme echouee (permet retry)
    pub async fn fail(&self, key: &IdempotencyKey) -> Result<(), IdempotencyError>;

    /// Nettoie les entrees expirees
    pub async fn cleanup(&self) -> usize;

    /// Execute une operation de maniere idempotente
    pub async fn execute<F, Fut>(
        &self,
        key: IdempotencyKey,
        operation: F,
    ) -> Result<T, IdempotencyError>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, String>>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Idempotence HTTP

Les methodes HTTP ont une semantique d'idempotence :
- **Idempotent** : GET, PUT, DELETE, HEAD, OPTIONS
- **Non-idempotent** : POST

Mais en pratique, meme POST peut etre rendu idempotent avec une cle.

### 2.2 Cle d'Idempotence

La cle doit etre unique par intention utilisateur :
- `X-Idempotency-Key: pay_12345` (generee par le client)
- `hash(method + path + body)` (generee par le serveur)
- `user_id + action + timestamp` (business-driven)

### 2.3 Stripe's Approach

Stripe utilise des cles d'idempotence avec :
- TTL de 24 heures
- Cle fournie par le client dans le header
- Resultat cache retourne pour les duplicatas

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_new_request() {
        let handler = IdempotencyHandler::<i32>::new(Duration::from_secs(300));
        let key = IdempotencyKey::new("test-key-1");

        let result = handler.check(&key).await;
        assert!(matches!(result, IdempotencyResult::New));
    }

    #[tokio::test]
    async fn test_duplicate_detection() {
        let handler = IdempotencyHandler::<i32>::new(Duration::from_secs(300));
        let key = IdempotencyKey::new("test-key-2");

        handler.start(key.clone()).await.unwrap();
        handler.complete(&key, 42).await.unwrap();

        let result = handler.check(&key).await;
        assert!(matches!(result, IdempotencyResult::Duplicate(42)));
    }

    #[tokio::test]
    async fn test_in_flight_detection() {
        let handler = IdempotencyHandler::<i32>::new(Duration::from_secs(300));
        let key = IdempotencyKey::new("test-key-3");

        handler.start(key.clone()).await.unwrap();

        let result = handler.check(&key).await;
        assert!(matches!(result, IdempotencyResult::InFlight));
    }

    #[tokio::test]
    async fn test_failed_allows_retry() {
        let handler = IdempotencyHandler::<i32>::new(Duration::from_secs(300));
        let key = IdempotencyKey::new("test-key-4");

        handler.start(key.clone()).await.unwrap();
        handler.fail(&key).await.unwrap();

        // Should allow new attempt after failure
        let result = handler.check(&key).await;
        assert!(matches!(result, IdempotencyResult::New));
    }

    #[tokio::test]
    async fn test_execute_idempotent() {
        let handler = IdempotencyHandler::<i32>::new(Duration::from_secs(300));
        let key = IdempotencyKey::new("test-key-5");

        let result1 = handler.execute(key.clone(), || async { Ok(42) }).await;
        let result2 = handler.execute(key.clone(), || async { Ok(100) }).await;

        assert_eq!(result1.unwrap(), 42);
        assert_eq!(result2.unwrap(), 42); // Returns cached result
    }

    #[tokio::test]
    async fn test_cleanup_expired() {
        let handler = IdempotencyHandler::<i32>::new(Duration::from_millis(50));
        let key = IdempotencyKey::new("test-key-6");

        handler.start(key.clone()).await.unwrap();
        handler.complete(&key, 42).await.unwrap();

        tokio::time::sleep(Duration::from_millis(100)).await;

        let cleaned = handler.cleanup().await;
        assert_eq!(cleaned, 1);

        // Should be new after cleanup
        let result = handler.check(&key).await;
        assert!(matches!(result, IdempotencyResult::New));
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::RwLock;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdempotencyKey(String);

impl IdempotencyKey {
    pub fn new(key: impl Into<String>) -> Self {
        Self(key.into())
    }

    pub fn from_request(method: &str, path: &str, body_hash: &str) -> Self {
        Self(format!("{}:{}:{}", method, path, body_hash))
    }
}

#[derive(Debug, Clone)]
pub enum IdempotencyResult<T> {
    New,
    Duplicate(T),
    InFlight,
}

#[derive(Debug)]
pub enum IdempotencyError {
    Conflict,
    StorageError(String),
    Expired,
}

impl std::fmt::Display for IdempotencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Conflict => write!(f, "Operation already in progress"),
            Self::StorageError(s) => write!(f, "Storage error: {}", s),
            Self::Expired => write!(f, "Record expired"),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum RecordStatus {
    InProgress,
    Completed,
    Failed,
}

#[derive(Debug, Clone)]
pub struct IdempotencyRecord<T> {
    pub key: IdempotencyKey,
    pub result: Option<T>,
    pub status: RecordStatus,
    pub created_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
}

pub struct IdempotencyHandler<T: Clone> {
    records: RwLock<HashMap<IdempotencyKey, IdempotencyRecord<T>>>,
    ttl: Duration,
}

impl<T: Clone + Send + Sync + 'static> IdempotencyHandler<T> {
    pub fn new(ttl: Duration) -> Self {
        Self {
            records: RwLock::new(HashMap::new()),
            ttl,
        }
    }

    pub async fn check(&self, key: &IdempotencyKey) -> IdempotencyResult<T> {
        let records = self.records.read().await;

        match records.get(key) {
            Some(record) => {
                // Check if expired
                let age = Utc::now().signed_duration_since(record.created_at);
                if age.to_std().unwrap_or(Duration::MAX) > self.ttl {
                    return IdempotencyResult::New;
                }

                match record.status {
                    RecordStatus::Completed => {
                        IdempotencyResult::Duplicate(record.result.clone().unwrap())
                    }
                    RecordStatus::InProgress => IdempotencyResult::InFlight,
                    RecordStatus::Failed => IdempotencyResult::New,
                }
            }
            None => IdempotencyResult::New,
        }
    }

    pub async fn start(&self, key: IdempotencyKey) -> Result<(), IdempotencyError> {
        let mut records = self.records.write().await;

        if let Some(record) = records.get(&key) {
            if record.status == RecordStatus::InProgress {
                return Err(IdempotencyError::Conflict);
            }
        }

        records.insert(key.clone(), IdempotencyRecord {
            key,
            result: None,
            status: RecordStatus::InProgress,
            created_at: Utc::now(),
            completed_at: None,
        });

        Ok(())
    }

    pub async fn complete(&self, key: &IdempotencyKey, result: T) -> Result<(), IdempotencyError> {
        let mut records = self.records.write().await;

        match records.get_mut(key) {
            Some(record) => {
                record.result = Some(result);
                record.status = RecordStatus::Completed;
                record.completed_at = Some(Utc::now());
                Ok(())
            }
            None => Err(IdempotencyError::StorageError("Record not found".to_string())),
        }
    }

    pub async fn fail(&self, key: &IdempotencyKey) -> Result<(), IdempotencyError> {
        let mut records = self.records.write().await;

        match records.get_mut(key) {
            Some(record) => {
                record.status = RecordStatus::Failed;
                record.completed_at = Some(Utc::now());
                Ok(())
            }
            None => Err(IdempotencyError::StorageError("Record not found".to_string())),
        }
    }

    pub async fn cleanup(&self) -> usize {
        let mut records = self.records.write().await;
        let now = Utc::now();
        let initial_len = records.len();

        records.retain(|_, record| {
            let age = now.signed_duration_since(record.created_at);
            age.to_std().unwrap_or(Duration::MAX) <= self.ttl
        });

        initial_len - records.len()
    }

    pub async fn execute<F, Fut>(
        &self,
        key: IdempotencyKey,
        operation: F,
    ) -> Result<T, IdempotencyError>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, String>>,
    {
        // Check for existing result
        match self.check(&key).await {
            IdempotencyResult::Duplicate(result) => return Ok(result),
            IdempotencyResult::InFlight => return Err(IdempotencyError::Conflict),
            IdempotencyResult::New => {}
        }

        // Start new operation
        self.start(key.clone()).await?;

        // Execute
        match operation().await {
            Ok(result) => {
                self.complete(&key, result.clone()).await?;
                Ok(result)
            }
            Err(e) => {
                self.fail(&key).await?;
                Err(IdempotencyError::StorageError(e))
            }
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Pas de check TTL */
pub async fn check(&self, key: &IdempotencyKey) -> IdempotencyResult<T> {
    let records = self.records.read().await;
    match records.get(key) {
        // MUTANT: Pas de check expiration
        Some(record) if record.status == RecordStatus::Completed => {
            IdempotencyResult::Duplicate(record.result.clone().unwrap())
        }
    }
}
// Pourquoi c'est faux : Les records restent indefiniment, OOM

/* Mutant B (Safety) : Race condition sur start */
pub async fn start(&self, key: IdempotencyKey) -> Result<(), IdempotencyError> {
    let records = self.records.read().await;
    if records.contains_key(&key) {
        return Err(IdempotencyError::Conflict);
    }
    drop(records);
    // MUTANT: Gap entre check et insert
    let mut records = self.records.write().await;
    records.insert(key, ...);
}
// Pourquoi c'est faux : Deux threads peuvent passer le check

/* Mutant C (Logic) : Failed ne permet pas retry */
pub async fn check(&self, key: &IdempotencyKey) -> IdempotencyResult<T> {
    match records.get(key) {
        Some(record) => match record.status {
            RecordStatus::Failed => IdempotencyResult::InFlight, // MUTANT
            ...
        }
    }
}
// Pourquoi c'est faux : Les echecs bloquent les retries

/* Mutant D (Edge) : complete() sans start() */
pub async fn execute(&self, key: IdempotencyKey, operation: F) {
    match operation().await {
        Ok(result) => {
            // MUTANT: Pas de start() avant
            self.complete(&key, result).await?;
        }
    }
}
// Pourquoi c'est faux : Record not found error

/* Mutant E (Return) : Resultat non cache */
pub async fn complete(&self, key: &IdempotencyKey, result: T) -> Result<(), IdempotencyError> {
    let mut records = self.records.write().await;
    if let Some(record) = records.get_mut(key) {
        // MUTANT: record.result = None au lieu de Some(result)
        record.status = RecordStatus::Completed;
    }
}
// Pourquoi c'est faux : Duplicate retourne None.unwrap() = panic
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    IDEMPOTENCY FLOW

    Request 1 (key=abc123)           Request 2 (key=abc123)
           │                                  │
           ▼                                  ▼
    ┌──────────────┐                  ┌──────────────┐
    │    CHECK     │                  │    CHECK     │
    │   key=abc    │                  │   key=abc    │
    └──────┬───────┘                  └──────┬───────┘
           │                                  │
           ▼ NEW                              ▼ DUPLICATE
    ┌──────────────┐                  ┌──────────────┐
    │    START     │                  │   RETURN     │
    │  InProgress  │                  │   cached     │
    └──────┬───────┘                  │   result     │
           │                          └──────────────┘
           ▼
    ┌──────────────┐
    │   EXECUTE    │
    │  operation   │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │   COMPLETE   │
    │ store result │
    └──────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Pas de TTL check | OOM | Expiration dans check() |
| 2 | Race condition | Duplicates | Lock atomique |
| 3 | Failed bloque | Pas de retry | Failed = New |
| 4 | Complete sans start | Error | start() obligatoire |
| 5 | Result non cache | Panic | Some(result) |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | idempotency_handler |
| **Module** | 5.6.15 — Idempotency Handler |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.15-a-idempotency-handler",
    "metadata": {
      "exercise_id": "5.6.15-a",
      "exercise_name": "idempotency_handler",
      "difficulty": 7,
      "xp_base": 175
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
