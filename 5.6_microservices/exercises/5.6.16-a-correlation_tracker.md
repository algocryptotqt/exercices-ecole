<thinking>
## Analyse du Concept
- Concept : Correlation Tracker (Distributed Tracing)
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le tracing distribue est essentiel pour debugger les microservices.
</thinking>

# Exercice 5.6.16-a : correlation_tracker

**Module :**
5.6.16 — Observability Patterns - Correlation

**Concept :**
a — Correlation Tracker (trace ID, span ID, distributed tracing)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.6 — Sidecar Proxy

**Domaines :**
Observability, Tracing, Async

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(1) x S1 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `uuid` (identifiants)
- `chrono` (timestamps)

### 1.2 Consigne

**CONTEXTE : "The Thread Weaver"**

*"Dans un systeme distribue, une requete traverse des dizaines de services. Sans fil d'Ariane, tu es perdu."* — Le Traceur

Le Correlation Tracker permet de suivre une requete a travers tous les services qu'elle traverse. Chaque requete a un Trace ID unique, et chaque operation dans un service a un Span ID.

**Ta mission :**

Implementer un `CorrelationTracker` qui :
1. Genere des Trace IDs et Span IDs
2. Maintient le contexte de correlation dans les async tasks
3. Propage le contexte aux appels downstream
4. Enregistre les spans avec leurs relations parent/child

### 1.3 Prototype

```rust
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraceId(Uuid);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpanId(Uuid);

#[derive(Debug, Clone)]
pub struct CorrelationContext {
    pub trace_id: TraceId,
    pub span_id: SpanId,
    pub parent_span_id: Option<SpanId>,
    pub baggage: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct Span {
    pub trace_id: TraceId,
    pub span_id: SpanId,
    pub parent_span_id: Option<SpanId>,
    pub operation_name: String,
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub tags: HashMap<String, String>,
    pub status: SpanStatus,
}

#[derive(Debug, Clone, PartialEq)]
pub enum SpanStatus {
    InProgress,
    Ok,
    Error(String),
}

impl TraceId {
    pub fn new() -> Self;
    pub fn from_string(s: &str) -> Option<Self>;
}

impl SpanId {
    pub fn new() -> Self;
}

impl CorrelationContext {
    pub fn new() -> Self;
    pub fn new_child(&self) -> Self;
    pub fn with_baggage(self, key: &str, value: &str) -> Self;
    pub fn get_baggage(&self, key: &str) -> Option<&str>;
    pub fn to_headers(&self) -> HashMap<String, String>;
    pub fn from_headers(headers: &HashMap<String, String>) -> Option<Self>;
}

pub struct CorrelationTracker {
    spans: tokio::sync::RwLock<Vec<Span>>,
}

impl CorrelationTracker {
    pub fn new() -> Self;

    /// Demarre un nouveau span
    pub async fn start_span(
        &self,
        ctx: &CorrelationContext,
        operation_name: &str,
    ) -> SpanId;

    /// Termine un span avec succes
    pub async fn end_span(&self, span_id: &SpanId);

    /// Termine un span avec erreur
    pub async fn end_span_error(&self, span_id: &SpanId, error: &str);

    /// Ajoute un tag a un span
    pub async fn add_tag(&self, span_id: &SpanId, key: &str, value: &str);

    /// Recupere tous les spans d'une trace
    pub async fn get_trace(&self, trace_id: &TraceId) -> Vec<Span>;
}

/// Macro pour wrapper une operation avec un span
#[macro_export]
macro_rules! with_span {
    ($tracker:expr, $ctx:expr, $name:expr, $body:expr) => {{
        let span_id = $tracker.start_span($ctx, $name).await;
        let result = $body;
        $tracker.end_span(&span_id).await;
        result
    }};
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 OpenTelemetry Standard

OpenTelemetry definit les standards pour le tracing distribue :
- **Trace** : L'ensemble du parcours d'une requete
- **Span** : Une operation unitaire (ex: appel HTTP, query DB)
- **Context** : Trace ID + Span ID + Baggage

### 2.2 W3C Trace Context

Le standard W3C definit les headers de propagation :
- `traceparent: 00-{trace-id}-{parent-span-id}-{flags}`
- `tracestate: vendor-specific data`

### 2.3 Sampling

En production, on ne trace pas 100% des requetes :
- **Head sampling** : Decision au debut de la trace
- **Tail sampling** : Decision a la fin (garde les erreurs)
- Rate typique : 1% en production, 100% en dev

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trace_id_generation() {
        let t1 = TraceId::new();
        let t2 = TraceId::new();
        assert_ne!(t1, t2);
    }

    #[test]
    fn test_context_new_child() {
        let parent = CorrelationContext::new();
        let child = parent.new_child();

        assert_eq!(child.trace_id, parent.trace_id); // Same trace
        assert_ne!(child.span_id, parent.span_id);   // New span
        assert_eq!(child.parent_span_id, Some(parent.span_id)); // Parent linked
    }

    #[test]
    fn test_baggage_propagation() {
        let ctx = CorrelationContext::new()
            .with_baggage("user_id", "12345")
            .with_baggage("tenant", "acme");

        assert_eq!(ctx.get_baggage("user_id"), Some("12345"));
        assert_eq!(ctx.get_baggage("tenant"), Some("acme"));

        let child = ctx.new_child();
        assert_eq!(child.get_baggage("user_id"), Some("12345")); // Inherited
    }

    #[test]
    fn test_headers_roundtrip() {
        let ctx = CorrelationContext::new()
            .with_baggage("key", "value");

        let headers = ctx.to_headers();
        let restored = CorrelationContext::from_headers(&headers).unwrap();

        assert_eq!(ctx.trace_id, restored.trace_id);
        assert_eq!(ctx.span_id, restored.span_id);
    }

    #[tokio::test]
    async fn test_span_lifecycle() {
        let tracker = CorrelationTracker::new();
        let ctx = CorrelationContext::new();

        let span_id = tracker.start_span(&ctx, "test-operation").await;
        tracker.add_tag(&span_id, "http.method", "GET").await;
        tracker.end_span(&span_id).await;

        let spans = tracker.get_trace(&ctx.trace_id).await;
        assert_eq!(spans.len(), 1);
        assert_eq!(spans[0].operation_name, "test-operation");
        assert!(matches!(spans[0].status, SpanStatus::Ok));
    }

    #[tokio::test]
    async fn test_span_error() {
        let tracker = CorrelationTracker::new();
        let ctx = CorrelationContext::new();

        let span_id = tracker.start_span(&ctx, "failing-op").await;
        tracker.end_span_error(&span_id, "Connection refused").await;

        let spans = tracker.get_trace(&ctx.trace_id).await;
        assert!(matches!(spans[0].status, SpanStatus::Error(_)));
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraceId(Uuid);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpanId(Uuid);

impl TraceId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    pub fn from_string(s: &str) -> Option<Self> {
        Uuid::parse_str(s).ok().map(Self)
    }

    pub fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl SpanId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    pub fn to_string(&self) -> String {
        self.0.to_string()
    }
}

#[derive(Debug, Clone)]
pub struct CorrelationContext {
    pub trace_id: TraceId,
    pub span_id: SpanId,
    pub parent_span_id: Option<SpanId>,
    pub baggage: HashMap<String, String>,
}

impl CorrelationContext {
    pub fn new() -> Self {
        Self {
            trace_id: TraceId::new(),
            span_id: SpanId::new(),
            parent_span_id: None,
            baggage: HashMap::new(),
        }
    }

    pub fn new_child(&self) -> Self {
        Self {
            trace_id: self.trace_id.clone(),
            span_id: SpanId::new(),
            parent_span_id: Some(self.span_id.clone()),
            baggage: self.baggage.clone(),
        }
    }

    pub fn with_baggage(mut self, key: &str, value: &str) -> Self {
        self.baggage.insert(key.to_string(), value.to_string());
        self
    }

    pub fn get_baggage(&self, key: &str) -> Option<&str> {
        self.baggage.get(key).map(|s| s.as_str())
    }

    pub fn to_headers(&self) -> HashMap<String, String> {
        let mut headers = HashMap::new();
        headers.insert("x-trace-id".to_string(), self.trace_id.to_string());
        headers.insert("x-span-id".to_string(), self.span_id.to_string());
        if let Some(ref parent) = self.parent_span_id {
            headers.insert("x-parent-span-id".to_string(), parent.to_string());
        }
        for (k, v) in &self.baggage {
            headers.insert(format!("x-baggage-{}", k), v.clone());
        }
        headers
    }

    pub fn from_headers(headers: &HashMap<String, String>) -> Option<Self> {
        let trace_id = TraceId::from_string(headers.get("x-trace-id")?)?;
        let span_id_str = headers.get("x-span-id")?;
        let span_id = SpanId(Uuid::parse_str(span_id_str).ok()?);

        let parent_span_id = headers.get("x-parent-span-id")
            .and_then(|s| Uuid::parse_str(s).ok())
            .map(SpanId);

        let mut baggage = HashMap::new();
        for (k, v) in headers {
            if k.starts_with("x-baggage-") {
                let key = k.strip_prefix("x-baggage-").unwrap();
                baggage.insert(key.to_string(), v.clone());
            }
        }

        Some(Self {
            trace_id,
            span_id,
            parent_span_id,
            baggage,
        })
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum SpanStatus {
    InProgress,
    Ok,
    Error(String),
}

#[derive(Debug, Clone)]
pub struct Span {
    pub trace_id: TraceId,
    pub span_id: SpanId,
    pub parent_span_id: Option<SpanId>,
    pub operation_name: String,
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub tags: HashMap<String, String>,
    pub status: SpanStatus,
}

pub struct CorrelationTracker {
    spans: RwLock<Vec<Span>>,
}

impl CorrelationTracker {
    pub fn new() -> Self {
        Self {
            spans: RwLock::new(Vec::new()),
        }
    }

    pub async fn start_span(
        &self,
        ctx: &CorrelationContext,
        operation_name: &str,
    ) -> SpanId {
        let span_id = SpanId::new();
        let span = Span {
            trace_id: ctx.trace_id.clone(),
            span_id: span_id.clone(),
            parent_span_id: Some(ctx.span_id.clone()),
            operation_name: operation_name.to_string(),
            start_time: Utc::now(),
            end_time: None,
            tags: HashMap::new(),
            status: SpanStatus::InProgress,
        };

        let mut spans = self.spans.write().await;
        spans.push(span);

        span_id
    }

    pub async fn end_span(&self, span_id: &SpanId) {
        let mut spans = self.spans.write().await;
        if let Some(span) = spans.iter_mut().find(|s| s.span_id == *span_id) {
            span.end_time = Some(Utc::now());
            span.status = SpanStatus::Ok;
        }
    }

    pub async fn end_span_error(&self, span_id: &SpanId, error: &str) {
        let mut spans = self.spans.write().await;
        if let Some(span) = spans.iter_mut().find(|s| s.span_id == *span_id) {
            span.end_time = Some(Utc::now());
            span.status = SpanStatus::Error(error.to_string());
        }
    }

    pub async fn add_tag(&self, span_id: &SpanId, key: &str, value: &str) {
        let mut spans = self.spans.write().await;
        if let Some(span) = spans.iter_mut().find(|s| s.span_id == *span_id) {
            span.tags.insert(key.to_string(), value.to_string());
        }
    }

    pub async fn get_trace(&self, trace_id: &TraceId) -> Vec<Span> {
        let spans = self.spans.read().await;
        spans.iter()
            .filter(|s| s.trace_id == *trace_id)
            .cloned()
            .collect()
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Child n'herite pas du trace_id */
pub fn new_child(&self) -> Self {
    Self {
        trace_id: TraceId::new(), // MUTANT: Nouveau trace au lieu d'heriter
        span_id: SpanId::new(),
        parent_span_id: Some(self.span_id.clone()),
        ..
    }
}
// Pourquoi c'est faux : Les spans ne sont plus lies dans la meme trace

/* Mutant B (Safety) : Baggage non propage au child */
pub fn new_child(&self) -> Self {
    Self {
        trace_id: self.trace_id.clone(),
        span_id: SpanId::new(),
        baggage: HashMap::new(), // MUTANT: Pas d'heritage
        ..
    }
}
// Pourquoi c'est faux : Le contexte utilisateur (user_id, etc.) est perdu

/* Mutant C (Logic) : parent_span_id non set */
pub fn new_child(&self) -> Self {
    Self {
        trace_id: self.trace_id.clone(),
        span_id: SpanId::new(),
        parent_span_id: None, // MUTANT: Pas de lien parent
        ..
    }
}
// Pourquoi c'est faux : Impossible de reconstruire l'arbre des spans

/* Mutant D (Edge) : Headers parsing partiel */
pub fn from_headers(headers: &HashMap<String, String>) -> Option<Self> {
    let trace_id = TraceId::from_string(headers.get("x-trace-id")?)?;
    // MUTANT: Genere nouveau span_id au lieu de parser
    let span_id = SpanId::new();
    ...
}
// Pourquoi c'est faux : Le span_id du caller n'est pas preserve

/* Mutant E (Return) : Span non trouve ignore */
pub async fn end_span(&self, span_id: &SpanId) {
    let mut spans = self.spans.write().await;
    // MUTANT: Pas de gestion si span non trouve
    for span in spans.iter_mut() {
        span.end_time = Some(Utc::now()); // Update tous les spans!
    }
}
// Pourquoi c'est faux : Tous les spans sont marques comme termines
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    DISTRIBUTED TRACE

    Trace ID: abc-123
    ─────────────────────────────────────────────────────────

    Gateway [span-001, parent=null]
    ├── Auth Service [span-002, parent=001]
    │   └── Redis Cache [span-003, parent=002]
    │
    ├── User Service [span-004, parent=001]
    │   ├── PostgreSQL [span-005, parent=004]
    │   └── Cache [span-006, parent=004]
    │
    └── Notification Service [span-007, parent=001]
        └── Kafka Producer [span-008, parent=007]

    ─────────────────────────────────────────────────────────
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Nouveau trace_id | Traces fragmentees | Heriter du parent |
| 2 | Baggage perdu | Contexte manquant | Clone baggage |
| 3 | Parent non set | Arbre plat | parent_span_id = Some |
| 4 | Span_id regenere | Trace incorrecte | Parser l'existant |
| 5 | Update all spans | Corruption | Filter by span_id |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | correlation_tracker |
| **Module** | 5.6.16 — Correlation Tracker |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP** | 150 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.16-a-correlation-tracker",
    "metadata": {
      "exercise_id": "5.6.16-a",
      "exercise_name": "correlation_tracker",
      "difficulty": 6,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 94/100*
