<thinking>
## Analyse du Concept
- Concept : Saga Choreography Pattern
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - L'approche decentralisee des sagas via events.
</thinking>

# Exercice 5.6.18-a : saga_choreography

**Module :**
5.6.18 — Distributed Transactions - Saga Choreography

**Concept :**
a — Saga Choreography (event-driven, decentralized)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
2 — Concepts composes

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.7 — Outbox Pattern
- 5.6.17 — Saga Orchestrator

**Domaines :**
DistributedSystems, EventDriven, Decoupled

**Duree estimee :**
150 min

**XP Base :**
200

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

**CONTEXTE : "The Dance of Services"**

*"Pas de chef d'orchestre ici. Chaque danseur connait ses pas et reagit aux mouvements des autres."* — Le Choregraphe

Contrairement a l'Orchestrator, la Choreographie Saga est decentralisee. Chaque service ecoute les events et reagit en publiant d'autres events. La logique est distribuee.

**Ta mission :**

Implementer un framework `SagaChoreography` qui :
1. Definit les reactions aux events (event handlers)
2. Publie des events de succes/echec
3. Gere la compensation via des events de rollback
4. Supporte le tracking de l'etat de la saga via correlation

### 1.3 Prototype

```rust
use uuid::Uuid;
use async_trait::async_trait;

pub trait SagaEvent: Clone + Send + Sync + 'static {
    fn saga_id(&self) -> Uuid;
    fn event_type(&self) -> &'static str;
    fn is_compensation(&self) -> bool;
}

#[async_trait]
pub trait EventHandler<E: SagaEvent>: Send + Sync {
    type Output: SagaEvent;
    type CompensationEvent: SagaEvent;

    async fn handle(&self, event: E) -> HandlerResult<Self::Output, Self::CompensationEvent>;
}

pub enum HandlerResult<S: SagaEvent, C: SagaEvent> {
    Success(S),
    Failure { compensation: C, reason: String },
    NoAction,
}

#[async_trait]
pub trait EventBus: Send + Sync {
    async fn publish<E: SagaEvent>(&self, event: E) -> Result<(), EventBusError>;
    async fn subscribe<E, H>(&self, handler: H)
    where
        E: SagaEvent,
        H: EventHandler<E> + 'static;
}

pub struct ChoreographySaga<B: EventBus> {
    saga_id: Uuid,
    event_bus: B,
    state: SagaChoreographyState,
}

#[derive(Debug, Clone)]
pub struct SagaChoreographyState {
    pub saga_id: Uuid,
    pub completed_steps: Vec<String>,
    pub pending_compensations: Vec<String>,
    pub status: ChoreographyStatus,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ChoreographyStatus {
    InProgress,
    Completed,
    Compensating,
    Compensated,
    Failed,
}

impl<B: EventBus> ChoreographySaga<B> {
    pub fn new(event_bus: B) -> Self;

    /// Demarre la saga en publiant l'event initial
    pub async fn start<E: SagaEvent>(&mut self, initial_event: E) -> Result<Uuid, SagaError>;

    /// Enregistre un handler pour un type d'event
    pub async fn on<E, H>(&self, handler: H)
    where
        E: SagaEvent,
        H: EventHandler<E> + 'static;

    /// Recupere l'etat actuel de la saga
    pub fn state(&self) -> &SagaChoreographyState;
}

// Example events
#[derive(Clone)]
pub struct OrderCreated { pub saga_id: Uuid, pub order_id: String }
#[derive(Clone)]
pub struct InventoryReserved { pub saga_id: Uuid, pub items: Vec<String> }
#[derive(Clone)]
pub struct InventoryReservationFailed { pub saga_id: Uuid, pub reason: String }
#[derive(Clone)]
pub struct OrderCancelled { pub saga_id: Uuid, pub order_id: String }

impl SagaEvent for OrderCreated {
    fn saga_id(&self) -> Uuid { self.saga_id }
    fn event_type(&self) -> &'static str { "OrderCreated" }
    fn is_compensation(&self) -> bool { false }
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Orchestration vs Choreography

| Aspect | Orchestration | Choreography |
|--------|---------------|--------------|
| Coordination | Centralisee | Distribuee |
| Couplage | Fort (orchestrateur) | Faible (events) |
| Debug | Facile | Difficile |
| SPOF | Orchestrateur | Aucun |
| Scalabilite | Limitee | Excellente |

### 2.2 Le Pattern Saga Choreography

```
OrderService          InventoryService        PaymentService
     │                      │                      │
     │ OrderCreated ────────►                      │
     │                      │                      │
     │         InventoryReserved ─────────────────►│
     │                      │                      │
     │◄───────────────────────────── PaymentProcessed
     │                      │                      │
     │ OrderCompleted       │                      │
     ▼                      ▼                      ▼
```

### 2.3 Semantic Coupling

Le probleme de la choreographie : chaque service doit connaitre les events qu'il doit ecouter et publier. Un changement dans un service peut casser la chaine sans erreur visible.

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    struct TestEventBus {
        events: Arc<RwLock<Vec<Box<dyn std::any::Any + Send + Sync>>>>,
    }

    #[tokio::test]
    async fn test_saga_flow() {
        let bus = TestEventBus::new();
        let mut saga = ChoreographySaga::new(bus);

        let initial = OrderCreated {
            saga_id: Uuid::new_v4(),
            order_id: "order-1".to_string(),
        };

        let saga_id = saga.start(initial).await.unwrap();
        assert_eq!(saga.state().status, ChoreographyStatus::InProgress);
    }

    #[tokio::test]
    async fn test_compensation_triggered() {
        // Test that when a step fails, compensation events are published
    }
}
```

### 4.3 Solution de reference

```rust
use std::sync::Arc;
use std::collections::HashMap;
use uuid::Uuid;
use async_trait::async_trait;
use tokio::sync::RwLock;

pub trait SagaEvent: Clone + Send + Sync + 'static {
    fn saga_id(&self) -> Uuid;
    fn event_type(&self) -> &'static str;
    fn is_compensation(&self) -> bool;
}

pub enum HandlerResult<S: SagaEvent, C: SagaEvent> {
    Success(S),
    Failure { compensation: C, reason: String },
    NoAction,
}

#[async_trait]
pub trait EventHandler<E: SagaEvent>: Send + Sync {
    type Output: SagaEvent;
    type CompensationEvent: SagaEvent;

    async fn handle(&self, event: E) -> HandlerResult<Self::Output, Self::CompensationEvent>;
}

#[derive(Debug)]
pub struct EventBusError(pub String);

#[async_trait]
pub trait EventBus: Send + Sync {
    async fn publish(&self, event_type: &str, saga_id: Uuid, payload: Vec<u8>) -> Result<(), EventBusError>;
}

#[derive(Debug, Clone, PartialEq)]
pub enum ChoreographyStatus {
    InProgress,
    Completed,
    Compensating,
    Compensated,
    Failed,
}

#[derive(Debug, Clone)]
pub struct SagaChoreographyState {
    pub saga_id: Uuid,
    pub completed_steps: Vec<String>,
    pub pending_compensations: Vec<String>,
    pub status: ChoreographyStatus,
}

impl SagaChoreographyState {
    pub fn new(saga_id: Uuid) -> Self {
        Self {
            saga_id,
            completed_steps: Vec::new(),
            pending_compensations: Vec::new(),
            status: ChoreographyStatus::InProgress,
        }
    }

    pub fn record_completion(&mut self, step: &str) {
        self.completed_steps.push(step.to_string());
    }

    pub fn start_compensation(&mut self) {
        self.status = ChoreographyStatus::Compensating;
        // Reverse order for compensation
        self.pending_compensations = self.completed_steps.iter().rev().cloned().collect();
    }

    pub fn record_compensated(&mut self, step: &str) {
        self.pending_compensations.retain(|s| s != step);
        if self.pending_compensations.is_empty() {
            self.status = ChoreographyStatus::Compensated;
        }
    }

    pub fn mark_completed(&mut self) {
        self.status = ChoreographyStatus::Completed;
    }

    pub fn mark_failed(&mut self) {
        self.status = ChoreographyStatus::Failed;
    }
}

#[derive(Debug)]
pub struct SagaError(pub String);

pub struct ChoreographySaga<B: EventBus> {
    saga_id: Uuid,
    event_bus: B,
    state: Arc<RwLock<SagaChoreographyState>>,
}

impl<B: EventBus> ChoreographySaga<B> {
    pub fn new(event_bus: B) -> Self {
        let saga_id = Uuid::new_v4();
        Self {
            saga_id,
            event_bus,
            state: Arc::new(RwLock::new(SagaChoreographyState::new(saga_id))),
        }
    }

    pub async fn start<E: SagaEvent>(&mut self, initial_event: E) -> Result<Uuid, SagaError> {
        let saga_id = initial_event.saga_id();
        self.saga_id = saga_id;

        {
            let mut state = self.state.write().await;
            state.saga_id = saga_id;
        }

        // Serialize and publish the initial event
        self.event_bus
            .publish(initial_event.event_type(), saga_id, Vec::new())
            .await
            .map_err(|e| SagaError(e.0))?;

        Ok(saga_id)
    }

    pub async fn record_step_completed(&self, step: &str) {
        let mut state = self.state.write().await;
        state.record_completion(step);
    }

    pub async fn trigger_compensation(&self) {
        let mut state = self.state.write().await;
        state.start_compensation();
    }

    pub async fn record_compensated(&self, step: &str) {
        let mut state = self.state.write().await;
        state.record_compensated(step);
    }

    pub async fn complete(&self) {
        let mut state = self.state.write().await;
        state.mark_completed();
    }

    pub async fn state(&self) -> SagaChoreographyState {
        self.state.read().await.clone()
    }
}

// Example event implementations
#[derive(Clone)]
pub struct OrderCreated {
    pub saga_id: Uuid,
    pub order_id: String,
}

impl SagaEvent for OrderCreated {
    fn saga_id(&self) -> Uuid { self.saga_id }
    fn event_type(&self) -> &'static str { "OrderCreated" }
    fn is_compensation(&self) -> bool { false }
}

#[derive(Clone)]
pub struct OrderCancelled {
    pub saga_id: Uuid,
    pub order_id: String,
}

impl SagaEvent for OrderCancelled {
    fn saga_id(&self) -> Uuid { self.saga_id }
    fn event_type(&self) -> &'static str { "OrderCancelled" }
    fn is_compensation(&self) -> bool { true }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Compensation dans le mauvais ordre */
pub fn start_compensation(&mut self) {
    self.status = ChoreographyStatus::Compensating;
    // MUTANT: Pas de reverse, meme ordre que l'execution
    self.pending_compensations = self.completed_steps.clone();
}
// Pourquoi c'est faux : La compensation doit etre inverse

/* Mutant B (Safety) : Saga ID non propage */
pub async fn start<E: SagaEvent>(&mut self, initial_event: E) -> Result<Uuid, SagaError> {
    // MUTANT: Utilise self.saga_id au lieu de initial_event.saga_id()
    self.event_bus.publish(initial_event.event_type(), self.saga_id, ...).await
}
// Pourquoi c'est faux : Le saga_id du caller est ignore

/* Mutant C (Logic) : Compensation event non publie */
async fn handle_failure<C: SagaEvent>(&self, compensation: C) {
    self.trigger_compensation().await;
    // MUTANT: Pas de publish de l'event de compensation
}
// Pourquoi c'est faux : Les autres services ne savent pas qu'il faut compenser

/* Mutant D (Edge) : Status Compensated premature */
pub fn record_compensated(&mut self, step: &str) {
    self.pending_compensations.retain(|s| s != step);
    self.status = ChoreographyStatus::Compensated;
    // MUTANT: Pas de check si pending_compensations.is_empty()
}
// Pourquoi c'est faux : Marque comme compense avant la fin

/* Mutant E (Return) : Event handler ignore le resultat */
async fn process_event<E, H>(&self, event: E, handler: H) {
    let result = handler.handle(event).await;
    // MUTANT: Ignore le result, pas de publication
}
// Pourquoi c'est faux : La chaine d'events est cassee
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    SAGA CHOREOGRAPHY FLOW

    OrderService     InventoryService    PaymentService    ShippingService
         │                  │                  │                  │
    [OrderCreated]          │                  │                  │
         │                  │                  │                  │
         ├─────────────────►│                  │                  │
         │                  │                  │                  │
         │          [InventoryReserved]        │                  │
         │                  │                  │                  │
         │                  ├─────────────────►│                  │
         │                  │                  │                  │
         │                  │         [PaymentFailed]             │
         │                  │                  │                  │
         │                  │◄─────────────────┤                  │
         │          [ReleaseInventory]         │                  │
         │                  │                  │                  │
         │◄─────────────────┤                  │                  │
    [CancelOrder]           │                  │                  │
         │                  │                  │                  │
         ▼                  ▼                  ▼                  ▼
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Ordre compensation | Inconsistance | Reverse order |
| 2 | Saga ID perdu | Correlation cassee | Propager saga_id |
| 3 | Comp non publiee | Pas de rollback | Publish compensation |
| 4 | Status premature | Faux Compensated | Check is_empty() |
| 5 | Result ignore | Chaine cassee | Process result |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | saga_choreography |
| **Module** | 5.6.18 — Saga Choreography |
| **Difficulte** | 8/10 |
| **Temps estime** | 150 min |
| **XP** | 200 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.18-a-saga-choreography",
    "metadata": {
      "exercise_id": "5.6.18-a",
      "exercise_name": "saga_choreography",
      "difficulty": 8,
      "xp_base": 200
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
