# HACKBRAIN MUSIC - Module 5.6 Microservices
## EX00 : DomainForge - Tactical DDD Modeling

```
================================================================================
  _    _          _____ _  ______  _____            _____ _   _
 | |  | |   /\   / ____| |/ /  _ \|  __ \     /\   |_   _| \ | |
 | |__| |  /  \ | |    | ' /| |_) | |__) |   /  \    | | |  \| |
 |  __  | / /\ \| |    |  < |  _ <|  _  /   / /\ \   | | | . ` |
 | |  | |/ ____ \ |____| . \| |_) | | \ \  / ____ \ _| |_| |\  |
 |_|  |_/_/    \_\_____|_|\_\____/|_|  \_\/_/    \_\_____|_| \_|

  MUSIC ENGINE v5.5.2 - Microservices & Event-Driven Architecture
================================================================================
  TRACK: DomainForge           LEVEL: Advanced            BPM: 128
  GENRE: Domain-Driven Design  KEY: Rust Minor            DURATION: 4h
================================================================================
```

---

## METADATA

| Champ | Valeur |
|-------|--------|
| **ID** | `5.6.0-a` |
| **Titre** | DomainForge - Tactical DDD Modeling |
| **Module** | 5.6 - Microservices & Event-Driven |
| **Difficulte** | Avance (4/5) |
| **Duree estimee** | 4 heures |
| **Prerequis** | Rust avance, Traits, Async/Await, Error Handling |
| **Langage** | Rust Edition 2024 |
| **Version HACKBRAIN** | 5.5.2 |

---

## <thinking> MUSIC ENGINE - ANALYSE PEDAGOGIQUE

### Decomposition cognitive de l'exercice

**Niveau taxonomique de Bloom**: Synthese (niveau 5)
- L'etudiant doit combiner plusieurs patterns DDD pour creer un modele de domaine coherent
- Necessite une comprehension profonde des invariants metier et leur expression via le systeme de types

**Charge cognitive estimee**: Elevee
- 6 concepts nouveaux a integrer: Entity, Value Object, Aggregate, Aggregate Root, Domain Events, Repository
- Complexite syntaxique Rust: traits generiques, async/await, derive macros, lifetime elision
- Complexite semantique: mapping concepts DDD vers idiomes Rust

**Prerequis implicites identifies**:
1. Maitrise du pattern Newtype pour l'encapsulation
2. Comprehension de `Result<T, E>` et propagation d'erreurs
3. Familiarite avec `serde` pour la serialisation
4. Connaissance de `async-trait` pour les traits async
5. Experience avec `thiserror` pour la definition d'erreurs

**Points de friction anticipes**:
1. **Confusion Entity vs Value Object**: L'etudiant pourrait vouloir donner une identite aux Value Objects
2. **Aggregate boundaries**: Difficulte a determiner ce qui appartient a l'Aggregate
3. **Event sourcing implicite**: Tendance a oublier l'emission d'events a chaque mutation
4. **Validation a la construction**: Oubli de valider dans `new()` vs validation tardive
5. **Version pour optimistic locking**: Incomprehension du role du champ `version`

**Strategie de scaffolding**:
- Phase 1: Value Objects isoles (plus simple, patterns clairs)
- Phase 2: Entity avec identite (introduction du concept d'identite)
- Phase 3: Aggregate (composition des concepts precedents)
- Phase 4: Domain Events (effet de bord controle)
- Phase 5: Repository (abstraction de persistance)

**Metriques de succes**:
- Tous les Value Objects rejettent les valeurs invalides
- L'Aggregate ne peut jamais etre dans un etat invalide
- Chaque mutation produit exactement un Domain Event
- Les tests couvrent tous les chemins d'erreur

</thinking>

---

## SECTION 1 : OBJECTIFS PEDAGOGIQUES

### 1.1 Objectif Principal

> Maitriser les patterns tactiques du Domain-Driven Design en Rust en implementant un modele de domaine complet pour un systeme bancaire, garantissant les invariants metier via le systeme de types.

### 1.2 Competences Cibles

| Code | Competence | Niveau Vise |
|------|------------|-------------|
| `DDD-VO-01` | Concevoir des Value Objects immutables avec validation a la construction | Maitrise |
| `DDD-ENT-01` | Implementer des Entities avec identite unique via Newtype pattern | Maitrise |
| `DDD-AGG-01` | Definir des Aggregates protegeant les invariants metier | Maitrise |
| `DDD-EVT-01` | Modeliser des Domain Events pour capturer les changements d'etat | Application |
| `DDD-REP-01` | Abstraire la persistance via le Repository pattern async | Application |
| `RUST-TYPE-01` | Exploiter le systeme de types pour rendre les etats invalides impossibles | Maitrise |

### 1.3 Mapping Concepts DDD vers Rust

```
+-------------------+------------------------+----------------------------------+
| Concept DDD       | Pattern Rust           | Caracteristique                  |
+-------------------+------------------------+----------------------------------+
| Value Object      | struct + validation    | Immutable, egalite par valeur    |
| Entity            | struct + Id newtype    | Identite unique, mutable interne |
| Aggregate Root    | struct englobant       | Point d'entree, protege enfants  |
| Domain Event      | enum ou struct + trait | Immutable, serialisable          |
| Repository        | async trait            | Abstraction I/O, unit of work    |
+-------------------+------------------------+----------------------------------+
```

---

## SECTION 2 : ENONCE DU PROBLEME

### 2.1 Contexte Narratif

```
================================================================================
                    DOMAINFORGE BANKING SYSTEM
                    --------------------------
    "Where invariants are forged in the fires of the type system"
================================================================================

    Vous rejoignez l'equipe DDD de DomainForge Bank, une fintech qui
    construit son core banking system from scratch en Rust.

    Votre mission: implementer le Bounded Context "Account Management"
    en respectant scrupuleusement les patterns tactiques DDD.

    Le Product Owner vous a fourni les regles metier suivantes:
    - Un compte a toujours un proprietaire identifie par email
    - Un IBAN identifie uniquement un compte dans le systeme bancaire
    - Le solde d'un compte ne peut JAMAIS etre negatif
    - Un compte gele ne peut effectuer aucune transaction
    - Un compte ferme est en etat terminal (aucune operation possible)
    - Chaque changement d'etat doit etre trace via un evenement

================================================================================
```

### 2.2 Specification Fonctionnelle

#### Partie 1 : Value Objects (20 points)

Implementez trois Value Objects representant des concepts metier:

```rust
/// Represente une somme d'argent en centimes (precision: 2 decimales)
/// Invariant: la valeur ne peut etre negative
pub struct Money {
    cents: u64,  // Stockage en centimes pour eviter les erreurs de floating point
}

/// Represente une adresse email valide
/// Invariant: doit contenir exactement un '@' avec des parties non-vides
pub struct Email {
    value: String,
}

/// Represente un IBAN valide (format simplifie)
/// Invariant: 2 lettres majuscules + 2 chiffres + 4-30 caracteres alphanumeriques
pub struct Iban {
    value: String,
}
```

**Exigences pour tous les Value Objects**:
- Immutabilite: `#[derive(Clone, PartialEq, Eq, Hash)]`
- Validation: constructeur retournant `Result<Self, DomainError>`
- Affichage: implementation de `Display`
- Serialisation: `#[derive(Serialize, Deserialize)]`
- Pas d'accesseur mutable

#### Partie 2 : Entity et Aggregate Root (30 points)

```rust
/// Identifiant unique d'un compte bancaire (Newtype pattern)
#[derive(Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct AccountId(Uuid);

/// Etats possibles d'un compte bancaire
#[derive(Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum AccountStatus {
    Active,
    Frozen,
    Closed,
}

/// Aggregate Root representant un compte bancaire
/// Encapsule toutes les regles metier du domaine Account
pub struct BankAccount {
    id: AccountId,
    owner_email: Email,
    iban: Iban,
    balance: Money,
    status: AccountStatus,
    created_at: DateTime<Utc>,
    version: u64,  // Pour optimistic locking
}
```

**Methodes a implementer sur `BankAccount`**:

| Methode | Description | Event Emis |
|---------|-------------|------------|
| `new(email, iban) -> Self` | Cree un nouveau compte actif avec solde zero | `AccountCreated` |
| `deposit(amount) -> Result<Event, Err>` | Credite le compte | `AccountDeposited` |
| `withdraw(amount) -> Result<Event, Err>` | Debite le compte si solde suffisant | `AccountWithdrawn` |
| `freeze(reason) -> Result<Event, Err>` | Gele le compte | `AccountFrozen` |
| `close() -> Result<Event, Err>` | Ferme definitivement le compte | `AccountClosed` |

**Regles metier strictes**:

```
REGLE 1: SOLDE NON-NEGATIF
--------------------------
withdraw(amount) DOIT echouer si balance < amount

REGLE 2: COMPTE GELE
--------------------
deposit() sur compte Frozen -> Err(AccountFrozen)
withdraw() sur compte Frozen -> Err(AccountFrozen)

REGLE 3: COMPTE FERME
---------------------
deposit() sur compte Closed -> Err(AccountClosed)
withdraw() sur compte Closed -> Err(AccountClosed)
freeze() sur compte Closed -> Err(AccountClosed)

REGLE 4: TRANSITIONS VALIDES
----------------------------
Active -> Frozen   : OK (via freeze)
Active -> Closed   : OK (via close)
Frozen -> Active   : INTERDIT (pas de methode unfreeze)
Frozen -> Closed   : OK (via close)
Closed -> *        : INTERDIT (etat terminal)
```

#### Partie 3 : Domain Events (25 points)

```rust
/// Trait commun a tous les Domain Events du Bounded Context
pub trait DomainEvent: Clone + Serialize + DeserializeOwned + Send + Sync {
    /// Retourne le type d'evenement (ex: "AccountCreated")
    fn event_type(&self) -> &'static str;

    /// Retourne l'ID de l'aggregate concerne
    fn aggregate_id(&self) -> AccountId;

    /// Retourne le timestamp de l'evenement
    fn occurred_at(&self) -> DateTime<Utc>;

    /// Retourne la version de l'aggregate au moment de l'event
    fn version(&self) -> u64;
}

// Events a implementer:
pub struct AccountCreated { /* ... */ }
pub struct AccountDeposited { /* amount, new_balance */ }
pub struct AccountWithdrawn { /* amount, new_balance */ }
pub struct AccountFrozen { /* reason: String */ }
pub struct AccountClosed { /* final_balance */ }
```

#### Partie 4 : Repository Pattern (15 points)

```rust
/// Abstraction de la persistence pour les BankAccount
#[async_trait]
pub trait AccountRepository: Send + Sync {
    /// Trouve un compte par son ID
    async fn find_by_id(&self, id: &AccountId) -> Result<Option<BankAccount>, RepositoryError>;

    /// Trouve un compte par son IBAN
    async fn find_by_iban(&self, iban: &Iban) -> Result<Option<BankAccount>, RepositoryError>;

    /// Sauvegarde un compte avec ses events (Unit of Work)
    async fn save(
        &self,
        account: &BankAccount,
        events: Vec<Box<dyn DomainEvent>>
    ) -> Result<(), RepositoryError>;

    /// Genere un nouvel ID unique
    async fn next_id(&self) -> AccountId;
}
```

#### Partie 5 : Tests de Validation (10 points)

Fournissez des tests unitaires demontrant:
- La validation des Value Objects (cas valides et invalides)
- Les transitions d'etat valides et invalides de l'Aggregate
- L'emission correcte des Domain Events

---

## SECTION 3 : SPECIFICATIONS TECHNIQUES

### 3.1 Structure du Projet

```
ex00_domain_forge/
+-- Cargo.toml
+-- src/
    +-- lib.rs              # Re-exports publics
    +-- domain/
    |   +-- mod.rs
    |   +-- value_objects/
    |   |   +-- mod.rs
    |   |   +-- money.rs
    |   |   +-- email.rs
    |   |   +-- iban.rs
    |   +-- entities/
    |   |   +-- mod.rs
    |   |   +-- account_id.rs
    |   +-- aggregates/
    |   |   +-- mod.rs
    |   |   +-- bank_account.rs
    |   +-- events/
    |   |   +-- mod.rs
    |   |   +-- account_events.rs
    |   +-- errors.rs
    +-- repository/
        +-- mod.rs
        +-- account_repository.rs
```

### 3.2 Cargo.toml

```toml
[package]
name = "ex00_domain_forge"
version = "0.1.0"
edition = "2024"
description = "Tactical DDD implementation for banking domain"
license = "MIT"

[dependencies]
uuid = { version = "1.11", features = ["v4", "serde"] }
chrono = { version = "0.4", default-features = false, features = ["serde", "std", "clock"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "2.0"
async-trait = "0.1"
tokio = { version = "1.42", features = ["full"] }
regex = "1.11"

[dev-dependencies]
tokio-test = "0.4"
```

### 3.3 Contraintes de Code

| Contrainte | Justification |
|------------|---------------|
| Pas de `unwrap()` / `expect()` en production | Robustesse, gestion explicite des erreurs |
| `thiserror` obligatoire pour les erreurs | Erreurs idiomatiques et composables |
| Documentation `///` sur tous types publics | Maintenabilite, generation de docs |
| Encapsulation stricte (pas de champs `pub`) | Protection des invariants |
| `#[must_use]` sur les Result | Prevenir l'ignorance des erreurs |
| `#[non_exhaustive]` sur les enums | Compatibilite future |

### 3.4 Types d'Erreurs

```rust
use thiserror::Error;

#[derive(Error, Debug, Clone, PartialEq)]
#[non_exhaustive]
pub enum DomainError {
    #[error("Invalid money amount: {0}")]
    InvalidMoney(String),

    #[error("Invalid email format: {0}")]
    InvalidEmail(String),

    #[error("Invalid IBAN format: {0}")]
    InvalidIban(String),

    #[error("Insufficient funds: available {available} cents, requested {requested} cents")]
    InsufficientFunds { available: u64, requested: u64 },

    #[error("Account is frozen: {reason}")]
    AccountFrozen { reason: String },

    #[error("Account is closed, no operations allowed")]
    AccountClosed,

    #[error("Invalid state transition from {from:?} to {to:?}")]
    InvalidStateTransition { from: AccountStatus, to: AccountStatus },
}

#[derive(Error, Debug)]
#[non_exhaustive]
pub enum RepositoryError {
    #[error("Account not found: {0}")]
    NotFound(AccountId),

    #[error("Optimistic locking conflict: expected version {expected}, found {actual}")]
    OptimisticLockConflict { expected: u64, actual: u64 },

    #[error("Persistence error: {0}")]
    PersistenceError(String),
}
```

---

## SECTION 4 : SQUELETTE DE CODE

### 4.1 Value Object - Money

```rust
// src/domain/value_objects/money.rs

use serde::{Deserialize, Serialize};
use std::fmt;
use crate::domain::errors::DomainError;

/// Represente un montant monetaire en centimes.
///
/// # Invariants
/// - Le montant est toujours non-negatif (garanti par le type u64)
/// - La precision est de 2 decimales (centimes)
///
/// # Examples
/// ```
/// use ex00_domain_forge::domain::Money;
///
/// let amount = Money::from_cents(1050).unwrap(); // 10.50
/// assert_eq!(amount.cents(), 1050);
/// assert_eq!(format!("{}", amount), "10.50");
/// ```
#[derive(Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Money {
    // TODO: Implementer le champ
}

impl Money {
    /// Cree un Money a partir d'un montant en centimes.
    ///
    /// # Arguments
    /// * `cents` - Le montant en centimes
    ///
    /// # Returns
    /// * `Ok(Money)` - Si le montant est valide
    /// * `Err(DomainError::InvalidMoney)` - Si invalide (cas impossible avec u64)
    pub fn from_cents(cents: u64) -> Result<Self, DomainError> {
        // TODO: Implementer
        todo!()
    }

    /// Cree un Money a partir d'un montant en euros (partie entiere et centimes).
    ///
    /// # Arguments
    /// * `euros` - Partie entiere
    /// * `cents` - Partie decimale (0-99)
    ///
    /// # Returns
    /// * `Ok(Money)` si cents < 100
    /// * `Err(DomainError::InvalidMoney)` si cents >= 100
    pub fn from_euros(euros: u64, cents: u8) -> Result<Self, DomainError> {
        // TODO: Implementer
        todo!()
    }

    /// Retourne la valeur en centimes.
    #[must_use]
    pub fn cents(&self) -> u64 {
        // TODO: Implementer
        todo!()
    }

    /// Additionne deux montants.
    ///
    /// # Panics
    /// Ne panique pas (u64::MAX est suffisamment grand)
    #[must_use]
    pub fn add(&self, other: &Money) -> Money {
        // TODO: Implementer
        todo!()
    }

    /// Soustrait un montant si suffisant.
    ///
    /// # Returns
    /// * `Ok(Money)` si self >= other
    /// * `Err(DomainError::InsufficientFunds)` sinon
    pub fn subtract(&self, other: &Money) -> Result<Money, DomainError> {
        // TODO: Implementer
        todo!()
    }

    /// Cree un montant nul.
    #[must_use]
    pub fn zero() -> Self {
        // TODO: Implementer
        todo!()
    }

    /// Verifie si le montant est nul.
    #[must_use]
    pub fn is_zero(&self) -> bool {
        // TODO: Implementer
        todo!()
    }
}

impl fmt::Display for Money {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Format: "XX.YY" (euros.centimes)
        // TODO: Implementer
        todo!()
    }
}

impl fmt::Debug for Money {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Money({})", self)
    }
}
```

### 4.2 Value Object - Email

```rust
// src/domain/value_objects/email.rs

use serde::{Deserialize, Serialize};
use std::fmt;
use crate::domain::errors::DomainError;

/// Represente une adresse email validee.
///
/// # Invariants
/// - Contient exactement un caractere '@'
/// - La partie locale (avant @) n'est pas vide
/// - La partie domaine (apres @) n'est pas vide et contient au moins un '.'
///
/// # Examples
/// ```
/// use ex00_domain_forge::domain::Email;
///
/// let email = Email::new("user@example.com").unwrap();
/// assert_eq!(email.as_str(), "user@example.com");
///
/// assert!(Email::new("invalid-email").is_err());
/// ```
#[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Email {
    // TODO: Implementer le champ
}

impl Email {
    /// Cree un Email a partir d'une chaine.
    ///
    /// # Validation
    /// - Format: `local@domain.tld`
    /// - Local part: non-vide, caracteres alphanumeriques + `._%+-`
    /// - Domain: non-vide, contient au moins un `.`, caracteres alphanumeriques + `.-`
    ///
    /// # Returns
    /// * `Ok(Email)` si format valide
    /// * `Err(DomainError::InvalidEmail)` sinon
    pub fn new(value: impl Into<String>) -> Result<Self, DomainError> {
        // TODO: Implementer la validation
        // Hint: Utiliser regex ou validation manuelle
        todo!()
    }

    /// Retourne l'email sous forme de &str.
    #[must_use]
    pub fn as_str(&self) -> &str {
        // TODO: Implementer
        todo!()
    }

    /// Retourne la partie locale (avant @).
    #[must_use]
    pub fn local_part(&self) -> &str {
        // TODO: Implementer
        todo!()
    }

    /// Retourne le domaine (apres @).
    #[must_use]
    pub fn domain(&self) -> &str {
        // TODO: Implementer
        todo!()
    }
}

impl fmt::Display for Email {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // TODO: Implementer
        todo!()
    }
}

impl fmt::Debug for Email {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Email({})", self)
    }
}
```

### 4.3 Value Object - Iban

```rust
// src/domain/value_objects/iban.rs

use serde::{Deserialize, Serialize};
use std::fmt;
use crate::domain::errors::DomainError;

/// Represente un IBAN (International Bank Account Number) valide.
///
/// # Format simplifie
/// - 2 lettres majuscules (code pays)
/// - 2 chiffres (cle de controle)
/// - 4 a 30 caracteres alphanumeriques (BBAN)
///
/// # Examples
/// ```
/// use ex00_domain_forge::domain::Iban;
///
/// let iban = Iban::new("FR7630006000011234567890189").unwrap();
/// assert_eq!(iban.country_code(), "FR");
///
/// assert!(Iban::new("INVALID").is_err());
/// ```
#[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Iban {
    // TODO: Implementer le champ
}

impl Iban {
    /// Cree un IBAN a partir d'une chaine.
    ///
    /// # Validation
    /// - Longueur: 8 a 34 caracteres
    /// - Positions 0-1: lettres majuscules (code pays)
    /// - Positions 2-3: chiffres (cle de controle)
    /// - Positions 4+: alphanumerique majuscule
    ///
    /// # Returns
    /// * `Ok(Iban)` si format valide
    /// * `Err(DomainError::InvalidIban)` sinon
    pub fn new(value: impl Into<String>) -> Result<Self, DomainError> {
        // TODO: Implementer la validation
        todo!()
    }

    /// Retourne l'IBAN sous forme de &str.
    #[must_use]
    pub fn as_str(&self) -> &str {
        // TODO: Implementer
        todo!()
    }

    /// Retourne le code pays (2 premieres lettres).
    #[must_use]
    pub fn country_code(&self) -> &str {
        // TODO: Implementer
        todo!()
    }

    /// Retourne la cle de controle (2 chiffres apres le code pays).
    #[must_use]
    pub fn check_digits(&self) -> &str {
        // TODO: Implementer
        todo!()
    }

    /// Retourne le BBAN (partie apres la cle de controle).
    #[must_use]
    pub fn bban(&self) -> &str {
        // TODO: Implementer
        todo!()
    }

    /// Retourne l'IBAN formate avec espaces tous les 4 caracteres.
    #[must_use]
    pub fn formatted(&self) -> String {
        // TODO: Implementer
        // Ex: "FR76 3000 6000 0112 3456 7890 189"
        todo!()
    }
}

impl fmt::Display for Iban {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Affichage formate avec espaces
        // TODO: Implementer
        todo!()
    }
}

impl fmt::Debug for Iban {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Iban({})", self.as_str())
    }
}
```

### 4.4 Entity - AccountId

```rust
// src/domain/entities/account_id.rs

use serde::{Deserialize, Serialize};
use std::fmt;
use uuid::Uuid;

/// Identifiant unique d'un compte bancaire.
///
/// Utilise le pattern Newtype pour encapsuler un UUID et fournir
/// une semantique metier forte.
///
/// # Examples
/// ```
/// use ex00_domain_forge::domain::AccountId;
///
/// let id = AccountId::new();
/// println!("Account ID: {}", id);
/// ```
#[derive(Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct AccountId(Uuid);

impl AccountId {
    /// Genere un nouvel identifiant unique.
    #[must_use]
    pub fn new() -> Self {
        // TODO: Implementer avec Uuid::new_v4()
        todo!()
    }

    /// Cree un AccountId a partir d'un UUID existant.
    #[must_use]
    pub fn from_uuid(uuid: Uuid) -> Self {
        // TODO: Implementer
        todo!()
    }

    /// Retourne l'UUID sous-jacent.
    #[must_use]
    pub fn as_uuid(&self) -> &Uuid {
        // TODO: Implementer
        todo!()
    }
}

impl Default for AccountId {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // TODO: Implementer
        todo!()
    }
}

impl fmt::Debug for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "AccountId({})", self.0)
    }
}
```

### 4.5 Aggregate Root - BankAccount

```rust
// src/domain/aggregates/bank_account.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use crate::domain::{
    AccountId, Email, Iban, Money,
    errors::DomainError,
    events::*,
};

/// Etats possibles d'un compte bancaire.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum AccountStatus {
    /// Le compte est actif et peut effectuer des transactions.
    Active,
    /// Le compte est gele, aucune transaction n'est autorisee.
    Frozen,
    /// Le compte est ferme definitivement.
    Closed,
}

/// Aggregate Root representant un compte bancaire.
///
/// Encapsule toutes les regles metier et garantit que l'etat
/// interne est toujours valide.
///
/// # Invariants
/// - Le solde ne peut jamais etre negatif
/// - Un compte gele ne peut effectuer aucune transaction
/// - Un compte ferme ne peut effectuer aucune operation
/// - Chaque mutation incremente la version
///
/// # Examples
/// ```
/// use ex00_domain_forge::domain::{BankAccount, Email, Iban, Money};
///
/// let email = Email::new("user@example.com").unwrap();
/// let iban = Iban::new("FR7630006000011234567890189").unwrap();
///
/// let (mut account, created_event) = BankAccount::new(email, iban);
///
/// let deposit = Money::from_cents(10000).unwrap();
/// let deposited_event = account.deposit(deposit).unwrap();
/// ```
#[derive(Clone, Serialize, Deserialize)]
pub struct BankAccount {
    id: AccountId,
    owner_email: Email,
    iban: Iban,
    balance: Money,
    status: AccountStatus,
    created_at: DateTime<Utc>,
    version: u64,
}

impl BankAccount {
    /// Cree un nouveau compte bancaire actif avec un solde de zero.
    ///
    /// # Arguments
    /// * `owner_email` - Email du proprietaire
    /// * `iban` - IBAN du compte
    ///
    /// # Returns
    /// Un tuple (compte, evenement de creation)
    #[must_use]
    pub fn new(owner_email: Email, iban: Iban) -> (Self, AccountCreated) {
        // TODO: Implementer
        // - Generer un nouvel AccountId
        // - Initialiser balance a Money::zero()
        // - Status = Active
        // - version = 1
        // - Creer l'event AccountCreated
        todo!()
    }

    /// Reconstitue un compte a partir de donnees persistees.
    ///
    /// # Warning
    /// Cette methode bypass la validation et ne doit etre utilisee
    /// que par le Repository pour la rehydratation.
    #[doc(hidden)]
    pub fn reconstitute(
        id: AccountId,
        owner_email: Email,
        iban: Iban,
        balance: Money,
        status: AccountStatus,
        created_at: DateTime<Utc>,
        version: u64,
    ) -> Self {
        // TODO: Implementer
        todo!()
    }

    // ===== GETTERS =====

    #[must_use]
    pub fn id(&self) -> AccountId {
        self.id
    }

    #[must_use]
    pub fn owner_email(&self) -> &Email {
        &self.owner_email
    }

    #[must_use]
    pub fn iban(&self) -> &Iban {
        &self.iban
    }

    #[must_use]
    pub fn balance(&self) -> &Money {
        &self.balance
    }

    #[must_use]
    pub fn status(&self) -> AccountStatus {
        self.status
    }

    #[must_use]
    pub fn created_at(&self) -> DateTime<Utc> {
        self.created_at
    }

    #[must_use]
    pub fn version(&self) -> u64 {
        self.version
    }

    // ===== COMMANDS (mutations with events) =====

    /// Depose de l'argent sur le compte.
    ///
    /// # Errors
    /// - `DomainError::AccountFrozen` si le compte est gele
    /// - `DomainError::AccountClosed` si le compte est ferme
    pub fn deposit(&mut self, amount: Money) -> Result<AccountDeposited, DomainError> {
        // TODO: Implementer
        // 1. Verifier le status (Active requis)
        // 2. Ajouter au solde
        // 3. Incrementer la version
        // 4. Retourner l'event
        todo!()
    }

    /// Retire de l'argent du compte.
    ///
    /// # Errors
    /// - `DomainError::AccountFrozen` si le compte est gele
    /// - `DomainError::AccountClosed` si le compte est ferme
    /// - `DomainError::InsufficientFunds` si solde insuffisant
    pub fn withdraw(&mut self, amount: Money) -> Result<AccountWithdrawn, DomainError> {
        // TODO: Implementer
        // 1. Verifier le status (Active requis)
        // 2. Verifier le solde suffisant
        // 3. Soustraire du solde
        // 4. Incrementer la version
        // 5. Retourner l'event
        todo!()
    }

    /// Gele le compte.
    ///
    /// # Arguments
    /// * `reason` - Raison du gel
    ///
    /// # Errors
    /// - `DomainError::AccountClosed` si le compte est deja ferme
    /// - `DomainError::InvalidStateTransition` si deja gele
    pub fn freeze(&mut self, reason: impl Into<String>) -> Result<AccountFrozen, DomainError> {
        // TODO: Implementer
        // 1. Verifier que le compte n'est pas ferme
        // 2. Verifier que le compte n'est pas deja gele
        // 3. Changer le status en Frozen
        // 4. Incrementer la version
        // 5. Retourner l'event
        todo!()
    }

    /// Ferme definitivement le compte.
    ///
    /// # Errors
    /// - `DomainError::AccountClosed` si deja ferme
    pub fn close(&mut self) -> Result<AccountClosed, DomainError> {
        // TODO: Implementer
        // 1. Verifier que le compte n'est pas deja ferme
        // 2. Changer le status en Closed
        // 3. Incrementer la version
        // 4. Retourner l'event avec le solde final
        todo!()
    }

    // ===== PRIVATE HELPERS =====

    /// Verifie que le compte est actif pour les transactions.
    fn ensure_active(&self) -> Result<(), DomainError> {
        match self.status {
            AccountStatus::Active => Ok(()),
            AccountStatus::Frozen => Err(DomainError::AccountFrozen {
                reason: "Account is frozen".to_string()
            }),
            AccountStatus::Closed => Err(DomainError::AccountClosed),
        }
    }

    /// Verifie que le compte n'est pas ferme.
    fn ensure_not_closed(&self) -> Result<(), DomainError> {
        if self.status == AccountStatus::Closed {
            Err(DomainError::AccountClosed)
        } else {
            Ok(())
        }
    }
}
```

### 4.6 Domain Events

```rust
// src/domain/events/account_events.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use crate::domain::{AccountId, Money};

/// Trait commun a tous les Domain Events.
pub trait DomainEvent: Clone + Send + Sync {
    /// Type de l'evenement (ex: "AccountCreated").
    fn event_type(&self) -> &'static str;

    /// ID de l'aggregate source.
    fn aggregate_id(&self) -> AccountId;

    /// Timestamp de l'evenement.
    fn occurred_at(&self) -> DateTime<Utc>;

    /// Version de l'aggregate au moment de l'event.
    fn version(&self) -> u64;
}

/// Event emis lors de la creation d'un compte.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AccountCreated {
    // TODO: Definir les champs
    // - account_id, owner_email, iban, occurred_at, version
}

impl AccountCreated {
    pub fn new(
        account_id: AccountId,
        owner_email: String,
        iban: String,
        version: u64,
    ) -> Self {
        // TODO: Implementer
        todo!()
    }
}

impl DomainEvent for AccountCreated {
    fn event_type(&self) -> &'static str {
        "AccountCreated"
    }

    fn aggregate_id(&self) -> AccountId {
        // TODO: Implementer
        todo!()
    }

    fn occurred_at(&self) -> DateTime<Utc> {
        // TODO: Implementer
        todo!()
    }

    fn version(&self) -> u64 {
        // TODO: Implementer
        todo!()
    }
}

/// Event emis lors d'un depot.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AccountDeposited {
    // TODO: Definir les champs
    // - account_id, amount, new_balance, occurred_at, version
}

impl AccountDeposited {
    pub fn new(
        account_id: AccountId,
        amount: Money,
        new_balance: Money,
        version: u64,
    ) -> Self {
        // TODO: Implementer
        todo!()
    }

    pub fn amount(&self) -> Money {
        // TODO: Implementer
        todo!()
    }

    pub fn new_balance(&self) -> Money {
        // TODO: Implementer
        todo!()
    }
}

impl DomainEvent for AccountDeposited {
    // TODO: Implementer les methodes du trait
    fn event_type(&self) -> &'static str {
        "AccountDeposited"
    }

    fn aggregate_id(&self) -> AccountId {
        todo!()
    }

    fn occurred_at(&self) -> DateTime<Utc> {
        todo!()
    }

    fn version(&self) -> u64 {
        todo!()
    }
}

/// Event emis lors d'un retrait.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AccountWithdrawn {
    // TODO: Definir les champs
}

impl AccountWithdrawn {
    pub fn new(
        account_id: AccountId,
        amount: Money,
        new_balance: Money,
        version: u64,
    ) -> Self {
        // TODO: Implementer
        todo!()
    }

    pub fn amount(&self) -> Money {
        todo!()
    }

    pub fn new_balance(&self) -> Money {
        todo!()
    }
}

impl DomainEvent for AccountWithdrawn {
    fn event_type(&self) -> &'static str {
        "AccountWithdrawn"
    }

    fn aggregate_id(&self) -> AccountId {
        todo!()
    }

    fn occurred_at(&self) -> DateTime<Utc> {
        todo!()
    }

    fn version(&self) -> u64 {
        todo!()
    }
}

/// Event emis lors du gel d'un compte.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AccountFrozen {
    // TODO: Definir les champs
    // - account_id, reason, occurred_at, version
}

impl AccountFrozen {
    pub fn new(
        account_id: AccountId,
        reason: String,
        version: u64,
    ) -> Self {
        // TODO: Implementer
        todo!()
    }

    pub fn reason(&self) -> &str {
        todo!()
    }
}

impl DomainEvent for AccountFrozen {
    fn event_type(&self) -> &'static str {
        "AccountFrozen"
    }

    fn aggregate_id(&self) -> AccountId {
        todo!()
    }

    fn occurred_at(&self) -> DateTime<Utc> {
        todo!()
    }

    fn version(&self) -> u64 {
        todo!()
    }
}

/// Event emis lors de la fermeture d'un compte.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AccountClosed {
    // TODO: Definir les champs
    // - account_id, final_balance, occurred_at, version
}

impl AccountClosed {
    pub fn new(
        account_id: AccountId,
        final_balance: Money,
        version: u64,
    ) -> Self {
        // TODO: Implementer
        todo!()
    }

    pub fn final_balance(&self) -> Money {
        todo!()
    }
}

impl DomainEvent for AccountClosed {
    fn event_type(&self) -> &'static str {
        "AccountClosed"
    }

    fn aggregate_id(&self) -> AccountId {
        todo!()
    }

    fn occurred_at(&self) -> DateTime<Utc> {
        todo!()
    }

    fn version(&self) -> u64 {
        todo!()
    }
}
```

### 4.7 Repository Trait

```rust
// src/repository/account_repository.rs

use async_trait::async_trait;
use crate::domain::{AccountId, BankAccount, Iban};
use crate::domain::errors::RepositoryError;
use crate::domain::events::DomainEvent;

/// Abstraction du pattern Repository pour la persistance des BankAccount.
///
/// # Design Decisions
/// - Utilisation de `async_trait` pour les methodes async dans un trait
/// - `Send + Sync` pour la compatibilite avec les runtimes async
/// - Pattern Unit of Work: save() accepte les events a publier
///
/// # Examples
/// ```ignore
/// async fn transfer(repo: &impl AccountRepository, from: AccountId, to: AccountId, amount: Money) {
///     let mut from_account = repo.find_by_id(&from).await?.expect("Account not found");
///     let mut to_account = repo.find_by_id(&to).await?.expect("Account not found");
///
///     let withdrawn = from_account.withdraw(amount)?;
///     let deposited = to_account.deposit(amount)?;
///
///     repo.save(&from_account, vec![Box::new(withdrawn)]).await?;
///     repo.save(&to_account, vec![Box::new(deposited)]).await?;
/// }
/// ```
#[async_trait]
pub trait AccountRepository: Send + Sync {
    /// Trouve un compte par son identifiant.
    ///
    /// # Returns
    /// - `Ok(Some(account))` si trouve
    /// - `Ok(None)` si non trouve
    /// - `Err(RepositoryError)` en cas d'erreur I/O
    async fn find_by_id(&self, id: &AccountId) -> Result<Option<BankAccount>, RepositoryError>;

    /// Trouve un compte par son IBAN.
    ///
    /// # Returns
    /// - `Ok(Some(account))` si trouve
    /// - `Ok(None)` si non trouve
    /// - `Err(RepositoryError)` en cas d'erreur I/O
    async fn find_by_iban(&self, iban: &Iban) -> Result<Option<BankAccount>, RepositoryError>;

    /// Sauvegarde un compte et publie les events associes.
    ///
    /// Cette methode implemente le pattern Unit of Work:
    /// - Sauvegarde l'etat du compte
    /// - Publie les domain events de maniere atomique
    ///
    /// # Optimistic Locking
    /// L'implementation DOIT verifier que la version en base correspond
    /// a la version attendue et retourner `OptimisticLockConflict` sinon.
    ///
    /// # Arguments
    /// * `account` - Le compte a sauvegarder
    /// * `events` - Les events a publier (transactionnellement avec la sauvegarde)
    async fn save(
        &self,
        account: &BankAccount,
        events: Vec<Box<dyn DomainEvent + Send>>,
    ) -> Result<(), RepositoryError>;

    /// Genere un nouvel identifiant unique.
    ///
    /// # Design Note
    /// La generation d'ID est dans le repository pour permettre
    /// des strategies comme les ID sequentiels en base.
    async fn next_id(&self) -> AccountId;
}
```

---

## SECTION 5 : SOLUTION DE REFERENCE

### 5.1 Money - Implementation Complete

```rust
use serde::{Deserialize, Serialize};
use std::fmt;
use crate::domain::errors::DomainError;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Money {
    cents: u64,
}

impl Money {
    pub fn from_cents(cents: u64) -> Result<Self, DomainError> {
        Ok(Self { cents })
    }

    pub fn from_euros(euros: u64, cents: u8) -> Result<Self, DomainError> {
        if cents >= 100 {
            return Err(DomainError::InvalidMoney(
                format!("Cents must be less than 100, got {}", cents)
            ));
        }
        Ok(Self {
            cents: euros * 100 + u64::from(cents),
        })
    }

    #[must_use]
    pub fn cents(&self) -> u64 {
        self.cents
    }

    #[must_use]
    pub fn add(&self, other: &Money) -> Money {
        Money {
            cents: self.cents.saturating_add(other.cents),
        }
    }

    pub fn subtract(&self, other: &Money) -> Result<Money, DomainError> {
        if self.cents < other.cents {
            return Err(DomainError::InsufficientFunds {
                available: self.cents,
                requested: other.cents,
            });
        }
        Ok(Money {
            cents: self.cents - other.cents,
        })
    }

    #[must_use]
    pub fn zero() -> Self {
        Self { cents: 0 }
    }

    #[must_use]
    pub fn is_zero(&self) -> bool {
        self.cents == 0
    }
}

impl fmt::Display for Money {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let euros = self.cents / 100;
        let cents = self.cents % 100;
        write!(f, "{}.{:02}", euros, cents)
    }
}

impl fmt::Debug for Money {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Money({})", self)
    }
}
```

### 5.2 Email - Implementation Complete

```rust
use serde::{Deserialize, Serialize};
use std::fmt;
use regex::Regex;
use once_cell::sync::Lazy;
use crate::domain::errors::DomainError;

static EMAIL_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").unwrap()
});

#[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Email {
    value: String,
}

impl Email {
    pub fn new(value: impl Into<String>) -> Result<Self, DomainError> {
        let value = value.into();

        if !EMAIL_REGEX.is_match(&value) {
            return Err(DomainError::InvalidEmail(
                format!("'{}' is not a valid email format", value)
            ));
        }

        Ok(Self { value })
    }

    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.value
    }

    #[must_use]
    pub fn local_part(&self) -> &str {
        self.value.split('@').next().unwrap_or("")
    }

    #[must_use]
    pub fn domain(&self) -> &str {
        self.value.split('@').nth(1).unwrap_or("")
    }
}

impl fmt::Display for Email {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.value)
    }
}

impl fmt::Debug for Email {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Email({})", self.value)
    }
}
```

### 5.3 BankAccount - Implementation Complete (Extraits Cles)

```rust
impl BankAccount {
    #[must_use]
    pub fn new(owner_email: Email, iban: Iban) -> (Self, AccountCreated) {
        let id = AccountId::new();
        let now = Utc::now();
        let version = 1;

        let account = Self {
            id,
            owner_email: owner_email.clone(),
            iban: iban.clone(),
            balance: Money::zero(),
            status: AccountStatus::Active,
            created_at: now,
            version,
        };

        let event = AccountCreated::new(
            id,
            owner_email.as_str().to_string(),
            iban.as_str().to_string(),
            version,
        );

        (account, event)
    }

    pub fn deposit(&mut self, amount: Money) -> Result<AccountDeposited, DomainError> {
        self.ensure_active()?;

        self.balance = self.balance.add(&amount);
        self.version += 1;

        Ok(AccountDeposited::new(
            self.id,
            amount,
            self.balance,
            self.version,
        ))
    }

    pub fn withdraw(&mut self, amount: Money) -> Result<AccountWithdrawn, DomainError> {
        self.ensure_active()?;

        self.balance = self.balance.subtract(&amount)?;
        self.version += 1;

        Ok(AccountWithdrawn::new(
            self.id,
            amount,
            self.balance,
            self.version,
        ))
    }

    pub fn freeze(&mut self, reason: impl Into<String>) -> Result<AccountFrozen, DomainError> {
        self.ensure_not_closed()?;

        if self.status == AccountStatus::Frozen {
            return Err(DomainError::InvalidStateTransition {
                from: AccountStatus::Frozen,
                to: AccountStatus::Frozen,
            });
        }

        self.status = AccountStatus::Frozen;
        self.version += 1;

        Ok(AccountFrozen::new(
            self.id,
            reason.into(),
            self.version,
        ))
    }

    pub fn close(&mut self) -> Result<AccountClosed, DomainError> {
        self.ensure_not_closed()?;

        let final_balance = self.balance;
        self.status = AccountStatus::Closed;
        self.version += 1;

        Ok(AccountClosed::new(
            self.id,
            final_balance,
            self.version,
        ))
    }
}
```

---

## SECTION 6 : TESTS ACADEMIQUES

### 6.1 Sorties Standards Attendues

```
================================================================================
                    DOMAINFORGE TEST SUITE - ACADEMIC OUTPUT
================================================================================

test domain::value_objects::money::tests::test_from_cents_valid ... ok
test domain::value_objects::money::tests::test_from_euros_valid ... ok
test domain::value_objects::money::tests::test_from_euros_invalid_cents ... ok
test domain::value_objects::money::tests::test_add ... ok
test domain::value_objects::money::tests::test_subtract_sufficient ... ok
test domain::value_objects::money::tests::test_subtract_insufficient ... ok
test domain::value_objects::money::tests::test_display ... ok

test domain::value_objects::email::tests::test_valid_email ... ok
test domain::value_objects::email::tests::test_invalid_no_at ... ok
test domain::value_objects::email::tests::test_invalid_no_domain ... ok
test domain::value_objects::email::tests::test_local_and_domain_parts ... ok

test domain::value_objects::iban::tests::test_valid_iban ... ok
test domain::value_objects::iban::tests::test_invalid_too_short ... ok
test domain::value_objects::iban::tests::test_invalid_bad_country_code ... ok
test domain::value_objects::iban::tests::test_formatted ... ok

test domain::aggregates::bank_account::tests::test_new_account ... ok
test domain::aggregates::bank_account::tests::test_deposit_active_account ... ok
test domain::aggregates::bank_account::tests::test_deposit_frozen_account ... FAILED
    expected: Err(AccountFrozen { reason: _ })
    actual:   Ok(AccountDeposited { ... })
test domain::aggregates::bank_account::tests::test_withdraw_sufficient_funds ... ok
test domain::aggregates::bank_account::tests::test_withdraw_insufficient_funds ... ok
test domain::aggregates::bank_account::tests::test_freeze_active_account ... ok
test domain::aggregates::bank_account::tests::test_close_account ... ok
test domain::aggregates::bank_account::tests::test_operations_on_closed_account ... ok
test domain::aggregates::bank_account::tests::test_version_increment ... ok

test domain::events::tests::test_event_serialization ... ok

================================================================================
TEST RESULT: 23 passed, 1 failed
TIME: 0.15s
================================================================================

FAILURE DETAILS:
----------------
test domain::aggregates::bank_account::tests::test_deposit_frozen_account

thread 'domain::aggregates::bank_account::tests::test_deposit_frozen_account' panicked at
    'assertion failed: matches!(result, Err(DomainError::AccountFrozen { .. }))'

HINT: Verifiez que deposit() verifie le status du compte AVANT d'effectuer l'operation.
      Un compte gele ne doit JAMAIS accepter de depot.
================================================================================
```

### 6.2 Tests de Reference

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // ===== MONEY TESTS =====

    mod money_tests {
        use super::*;

        #[test]
        fn test_from_cents_valid() {
            let money = Money::from_cents(1050).unwrap();
            assert_eq!(money.cents(), 1050);
        }

        #[test]
        fn test_from_euros_valid() {
            let money = Money::from_euros(10, 50).unwrap();
            assert_eq!(money.cents(), 1050);
        }

        #[test]
        fn test_from_euros_invalid_cents() {
            let result = Money::from_euros(10, 100);
            assert!(matches!(result, Err(DomainError::InvalidMoney(_))));
        }

        #[test]
        fn test_add() {
            let a = Money::from_cents(100).unwrap();
            let b = Money::from_cents(50).unwrap();
            let result = a.add(&b);
            assert_eq!(result.cents(), 150);
        }

        #[test]
        fn test_subtract_sufficient() {
            let a = Money::from_cents(100).unwrap();
            let b = Money::from_cents(50).unwrap();
            let result = a.subtract(&b).unwrap();
            assert_eq!(result.cents(), 50);
        }

        #[test]
        fn test_subtract_insufficient() {
            let a = Money::from_cents(50).unwrap();
            let b = Money::from_cents(100).unwrap();
            let result = a.subtract(&b);
            assert!(matches!(
                result,
                Err(DomainError::InsufficientFunds { available: 50, requested: 100 })
            ));
        }

        #[test]
        fn test_display() {
            let money = Money::from_cents(1050).unwrap();
            assert_eq!(format!("{}", money), "10.50");

            let money_zero = Money::from_cents(5).unwrap();
            assert_eq!(format!("{}", money_zero), "0.05");
        }

        #[test]
        fn test_zero() {
            let zero = Money::zero();
            assert!(zero.is_zero());
            assert_eq!(zero.cents(), 0);
        }
    }

    // ===== EMAIL TESTS =====

    mod email_tests {
        use super::*;

        #[test]
        fn test_valid_email() {
            let email = Email::new("user@example.com");
            assert!(email.is_ok());
            assert_eq!(email.unwrap().as_str(), "user@example.com");
        }

        #[test]
        fn test_invalid_no_at() {
            let result = Email::new("invalid-email");
            assert!(matches!(result, Err(DomainError::InvalidEmail(_))));
        }

        #[test]
        fn test_invalid_empty_local() {
            let result = Email::new("@example.com");
            assert!(matches!(result, Err(DomainError::InvalidEmail(_))));
        }

        #[test]
        fn test_invalid_no_tld() {
            let result = Email::new("user@example");
            assert!(matches!(result, Err(DomainError::InvalidEmail(_))));
        }

        #[test]
        fn test_local_and_domain_parts() {
            let email = Email::new("user@example.com").unwrap();
            assert_eq!(email.local_part(), "user");
            assert_eq!(email.domain(), "example.com");
        }
    }

    // ===== IBAN TESTS =====

    mod iban_tests {
        use super::*;

        #[test]
        fn test_valid_iban() {
            let iban = Iban::new("FR7630006000011234567890189");
            assert!(iban.is_ok());
        }

        #[test]
        fn test_country_code() {
            let iban = Iban::new("FR7630006000011234567890189").unwrap();
            assert_eq!(iban.country_code(), "FR");
        }

        #[test]
        fn test_check_digits() {
            let iban = Iban::new("FR7630006000011234567890189").unwrap();
            assert_eq!(iban.check_digits(), "76");
        }

        #[test]
        fn test_invalid_too_short() {
            let result = Iban::new("FR76");
            assert!(matches!(result, Err(DomainError::InvalidIban(_))));
        }

        #[test]
        fn test_invalid_lowercase_country() {
            let result = Iban::new("fr7630006000011234567890189");
            assert!(matches!(result, Err(DomainError::InvalidIban(_))));
        }

        #[test]
        fn test_formatted() {
            let iban = Iban::new("FR7630006000011234567890189").unwrap();
            assert_eq!(iban.formatted(), "FR76 3000 6000 0112 3456 7890 189");
        }
    }

    // ===== BANK ACCOUNT TESTS =====

    mod bank_account_tests {
        use super::*;

        fn create_test_account() -> (BankAccount, AccountCreated) {
            let email = Email::new("test@example.com").unwrap();
            let iban = Iban::new("FR7630006000011234567890189").unwrap();
            BankAccount::new(email, iban)
        }

        #[test]
        fn test_new_account() {
            let (account, event) = create_test_account();

            assert_eq!(account.status(), AccountStatus::Active);
            assert!(account.balance().is_zero());
            assert_eq!(account.version(), 1);
            assert_eq!(event.event_type(), "AccountCreated");
        }

        #[test]
        fn test_deposit_active_account() {
            let (mut account, _) = create_test_account();
            let amount = Money::from_cents(10000).unwrap();

            let result = account.deposit(amount);
            assert!(result.is_ok());

            let event = result.unwrap();
            assert_eq!(event.event_type(), "AccountDeposited");
            assert_eq!(event.amount().cents(), 10000);
            assert_eq!(account.balance().cents(), 10000);
            assert_eq!(account.version(), 2);
        }

        #[test]
        fn test_deposit_frozen_account() {
            let (mut account, _) = create_test_account();
            account.freeze("Test freeze").unwrap();

            let amount = Money::from_cents(10000).unwrap();
            let result = account.deposit(amount);

            assert!(matches!(result, Err(DomainError::AccountFrozen { .. })));
        }

        #[test]
        fn test_withdraw_sufficient_funds() {
            let (mut account, _) = create_test_account();
            account.deposit(Money::from_cents(10000).unwrap()).unwrap();

            let result = account.withdraw(Money::from_cents(3000).unwrap());
            assert!(result.is_ok());

            assert_eq!(account.balance().cents(), 7000);
        }

        #[test]
        fn test_withdraw_insufficient_funds() {
            let (mut account, _) = create_test_account();
            account.deposit(Money::from_cents(5000).unwrap()).unwrap();

            let result = account.withdraw(Money::from_cents(10000).unwrap());

            assert!(matches!(
                result,
                Err(DomainError::InsufficientFunds { available: 5000, requested: 10000 })
            ));
        }

        #[test]
        fn test_freeze_active_account() {
            let (mut account, _) = create_test_account();

            let result = account.freeze("Suspicious activity");
            assert!(result.is_ok());

            let event = result.unwrap();
            assert_eq!(event.event_type(), "AccountFrozen");
            assert_eq!(event.reason(), "Suspicious activity");
            assert_eq!(account.status(), AccountStatus::Frozen);
        }

        #[test]
        fn test_freeze_already_frozen() {
            let (mut account, _) = create_test_account();
            account.freeze("First freeze").unwrap();

            let result = account.freeze("Second freeze");

            assert!(matches!(
                result,
                Err(DomainError::InvalidStateTransition {
                    from: AccountStatus::Frozen,
                    to: AccountStatus::Frozen
                })
            ));
        }

        #[test]
        fn test_close_account() {
            let (mut account, _) = create_test_account();
            account.deposit(Money::from_cents(5000).unwrap()).unwrap();

            let result = account.close();
            assert!(result.is_ok());

            let event = result.unwrap();
            assert_eq!(event.event_type(), "AccountClosed");
            assert_eq!(event.final_balance().cents(), 5000);
            assert_eq!(account.status(), AccountStatus::Closed);
        }

        #[test]
        fn test_operations_on_closed_account() {
            let (mut account, _) = create_test_account();
            account.close().unwrap();

            let deposit_result = account.deposit(Money::from_cents(1000).unwrap());
            assert!(matches!(deposit_result, Err(DomainError::AccountClosed)));

            let withdraw_result = account.withdraw(Money::from_cents(1000).unwrap());
            assert!(matches!(withdraw_result, Err(DomainError::AccountClosed)));

            let freeze_result = account.freeze("Cannot freeze");
            assert!(matches!(freeze_result, Err(DomainError::AccountClosed)));

            let close_result = account.close();
            assert!(matches!(close_result, Err(DomainError::AccountClosed)));
        }

        #[test]
        fn test_version_increment() {
            let (mut account, _) = create_test_account();
            assert_eq!(account.version(), 1);

            account.deposit(Money::from_cents(1000).unwrap()).unwrap();
            assert_eq!(account.version(), 2);

            account.withdraw(Money::from_cents(500).unwrap()).unwrap();
            assert_eq!(account.version(), 3);

            account.freeze("Test").unwrap();
            assert_eq!(account.version(), 4);
        }
    }

    // ===== EVENT SERIALIZATION TESTS =====

    mod event_tests {
        use super::*;

        #[test]
        fn test_account_created_serialization() {
            let id = AccountId::new();
            let event = AccountCreated::new(
                id,
                "test@example.com".to_string(),
                "FR7630006000011234567890189".to_string(),
                1,
            );

            let json = serde_json::to_string(&event).unwrap();
            let deserialized: AccountCreated = serde_json::from_str(&json).unwrap();

            assert_eq!(deserialized.aggregate_id(), id);
            assert_eq!(deserialized.version(), 1);
        }

        #[test]
        fn test_account_deposited_serialization() {
            let id = AccountId::new();
            let amount = Money::from_cents(5000).unwrap();
            let new_balance = Money::from_cents(10000).unwrap();

            let event = AccountDeposited::new(id, amount, new_balance, 2);

            let json = serde_json::to_string(&event).unwrap();
            let deserialized: AccountDeposited = serde_json::from_str(&json).unwrap();

            assert_eq!(deserialized.amount().cents(), 5000);
            assert_eq!(deserialized.new_balance().cents(), 10000);
        }
    }
}
```

---

## SECTION 7 : MUTATION TESTING

### 7.1 Mutants a Detecter

| ID | Localisation | Mutation | Detection Attendue |
|----|--------------|----------|-------------------|
| `MUT-01` | `Money::subtract` | Changer `<` en `<=` dans la comparaison | Test `test_subtract_equal_amounts` |
| `MUT-02` | `BankAccount::deposit` | Supprimer `self.ensure_active()?` | Test `test_deposit_frozen_account` |
| `MUT-03` | `BankAccount::withdraw` | Supprimer verification de solde | Test `test_withdraw_insufficient_funds` |
| `MUT-04` | `BankAccount::freeze` | Ne pas changer `self.status` | Test `test_freeze_active_account` |
| `MUT-05` | `BankAccount::version` | Ne pas incrementer la version | Test `test_version_increment` |

### 7.2 Details des Mutants

#### MUT-01: Money::subtract - Operateur Relationnel

```rust
// ORIGINAL
pub fn subtract(&self, other: &Money) -> Result<Money, DomainError> {
    if self.cents < other.cents {
        return Err(DomainError::InsufficientFunds { ... });
    }
    Ok(Money { cents: self.cents - other.cents })
}

// MUTANT (< devient <=)
pub fn subtract(&self, other: &Money) -> Result<Money, DomainError> {
    if self.cents <= other.cents {  // MUTATION
        return Err(DomainError::InsufficientFunds { ... });
    }
    Ok(Money { cents: self.cents - other.cents })
}
```

**Test de detection:**
```rust
#[test]
fn test_subtract_equal_amounts() {
    let a = Money::from_cents(100).unwrap();
    let b = Money::from_cents(100).unwrap();
    let result = a.subtract(&b);

    // Doit reussir avec exactement 0 centimes
    assert!(result.is_ok());
    assert!(result.unwrap().is_zero());
}
```

#### MUT-02: BankAccount::deposit - Suppression de Verification

```rust
// ORIGINAL
pub fn deposit(&mut self, amount: Money) -> Result<AccountDeposited, DomainError> {
    self.ensure_active()?;
    self.balance = self.balance.add(&amount);
    self.version += 1;
    Ok(AccountDeposited::new(...))
}

// MUTANT (suppression de ensure_active)
pub fn deposit(&mut self, amount: Money) -> Result<AccountDeposited, DomainError> {
    // self.ensure_active()?;  // SUPPRIME
    self.balance = self.balance.add(&amount);
    self.version += 1;
    Ok(AccountDeposited::new(...))
}
```

**Test de detection:**
```rust
#[test]
fn test_deposit_frozen_account() {
    let (mut account, _) = create_test_account();
    account.freeze("Test").unwrap();

    let result = account.deposit(Money::from_cents(1000).unwrap());

    // DOIT echouer car le compte est gele
    assert!(matches!(result, Err(DomainError::AccountFrozen { .. })));
}
```

#### MUT-03: BankAccount::withdraw - Suppression Verification Solde

```rust
// ORIGINAL
pub fn withdraw(&mut self, amount: Money) -> Result<AccountWithdrawn, DomainError> {
    self.ensure_active()?;
    self.balance = self.balance.subtract(&amount)?;  // Peut echouer
    self.version += 1;
    Ok(AccountWithdrawn::new(...))
}

// MUTANT (ignore l'erreur de subtract)
pub fn withdraw(&mut self, amount: Money) -> Result<AccountWithdrawn, DomainError> {
    self.ensure_active()?;
    // Force le retrait meme si insuffisant
    self.balance = Money::from_cents(
        self.balance.cents().saturating_sub(amount.cents())
    ).unwrap();
    self.version += 1;
    Ok(AccountWithdrawn::new(...))
}
```

**Test de detection:**
```rust
#[test]
fn test_withdraw_insufficient_funds() {
    let (mut account, _) = create_test_account();
    account.deposit(Money::from_cents(500).unwrap()).unwrap();

    let result = account.withdraw(Money::from_cents(1000).unwrap());

    // DOIT echouer avec InsufficientFunds
    assert!(matches!(
        result,
        Err(DomainError::InsufficientFunds { available: 500, requested: 1000 })
    ));

    // Le solde ne doit PAS avoir change
    assert_eq!(account.balance().cents(), 500);
}
```

#### MUT-04: BankAccount::freeze - Status Non Modifie

```rust
// ORIGINAL
pub fn freeze(&mut self, reason: impl Into<String>) -> Result<AccountFrozen, DomainError> {
    self.ensure_not_closed()?;
    if self.status == AccountStatus::Frozen { ... }
    self.status = AccountStatus::Frozen;  // Changement d'etat
    self.version += 1;
    Ok(AccountFrozen::new(...))
}

// MUTANT (status non modifie)
pub fn freeze(&mut self, reason: impl Into<String>) -> Result<AccountFrozen, DomainError> {
    self.ensure_not_closed()?;
    if self.status == AccountStatus::Frozen { ... }
    // self.status = AccountStatus::Frozen;  // SUPPRIME
    self.version += 1;
    Ok(AccountFrozen::new(...))
}
```

**Test de detection:**
```rust
#[test]
fn test_freeze_changes_status() {
    let (mut account, _) = create_test_account();
    assert_eq!(account.status(), AccountStatus::Active);

    account.freeze("Test").unwrap();

    // Le status DOIT avoir change
    assert_eq!(account.status(), AccountStatus::Frozen);
}
```

#### MUT-05: Version Non Incrementee

```rust
// ORIGINAL
pub fn deposit(&mut self, amount: Money) -> Result<AccountDeposited, DomainError> {
    self.ensure_active()?;
    self.balance = self.balance.add(&amount);
    self.version += 1;  // Increment
    Ok(AccountDeposited::new(...))
}

// MUTANT (version non incrementee)
pub fn deposit(&mut self, amount: Money) -> Result<AccountDeposited, DomainError> {
    self.ensure_active()?;
    self.balance = self.balance.add(&amount);
    // self.version += 1;  // SUPPRIME
    Ok(AccountDeposited::new(...))
}
```

**Test de detection:**
```rust
#[test]
fn test_version_increment_on_deposit() {
    let (mut account, _) = create_test_account();
    let initial_version = account.version();

    account.deposit(Money::from_cents(1000).unwrap()).unwrap();

    // La version DOIT avoir ete incrementee
    assert_eq!(account.version(), initial_version + 1);
}
```

### 7.3 Commande de Mutation Testing

```bash
# Installation de cargo-mutants
cargo install cargo-mutants

# Execution sur le projet
cargo mutants --jobs 4 --timeout 60

# Rapport attendu
================================================================================
MUTATION TESTING REPORT
================================================================================
Total mutants: 47
Killed: 45
Survived: 2  <-- ATTENTION: Tests insuffisants
Timeout: 0
================================================================================

SURVIVED MUTANTS (need additional tests):
- src/domain/aggregates/bank_account.rs:128: replaced += with -=
- src/domain/value_objects/email.rs:45: replaced is_match with true

RECOMMENDATION: Ajouter des tests pour:
1. Verifier que la version augmente (pas diminue) apres mutation
2. Verifier qu'un email invalide est bien rejete
================================================================================
```

---

## SECTION 8 : CRITERES D'EVALUATION

### 8.1 Grille de Notation

| Critere | Points | Description |
|---------|--------|-------------|
| **Value Objects** | 20 | |
| - Money implementation | 8 | from_cents, from_euros, add, subtract, display |
| - Email validation | 6 | Regex ou validation manuelle correcte |
| - Iban validation | 6 | Format correct, methodes d'extraction |
| **Aggregate** | 30 | |
| - Structure correcte | 10 | Encapsulation, getters, version |
| - Regles metier deposit/withdraw | 10 | Verification status, solde |
| - Transitions freeze/close | 10 | Machine a etats correcte |
| **Domain Events** | 25 | |
| - Trait DomainEvent | 5 | Interface complete |
| - 5 events implementes | 15 | Structure et serialisation |
| - Emission correcte | 5 | Chaque mutation produit son event |
| **Repository** | 15 | |
| - Trait async correct | 10 | Methodes avec bons types |
| - Documentation | 5 | Contrats clairs |
| **Qualite** | 10 | |
| - Tests unitaires | 5 | Couverture des cas limites |
| - Code idiomatique | 5 | Rust best practices |
| **TOTAL** | **100** | |

### 8.2 Niveaux de Reussite

```
================================================================================
                         NIVEAUX DE REUSSITE
================================================================================

 90-100 points  |  GOLD RECORD       |  Maitrise exceptionnelle du DDD en Rust
                |  ****************  |  Pret pour architecture microservices
                |                    |
 75-89 points   |  PLATINUM          |  Bonne comprehension des patterns
                |  **************    |  Quelques ajustements mineurs
                |                    |
 60-74 points   |  SILVER            |  Concepts de base acquis
                |  ************      |  Revoir invariants et events
                |                    |
 40-59 points   |  BRONZE            |  Comprehension partielle
                |  **********        |  Retravailler Value Objects
                |                    |
 < 40 points    |  NEEDS PRACTICE    |  Fondamentaux a consolider
                |  ********          |  Revoir theorie DDD
                |                    |
================================================================================
```

### 8.3 Erreurs Courantes et Penalites

| Erreur | Penalite | Explication |
|--------|----------|-------------|
| `unwrap()` en production | -5 | Manque de robustesse |
| Champs publics sur Aggregate | -10 | Violation encapsulation |
| Event non emis sur mutation | -5/event | Perte de tracabilite |
| Validation tardive (pas dans new) | -5 | Etat invalide possible |
| Version non incrementee | -5 | Optimistic locking casse |
| Tests sans assertions | -2/test | Tests inutiles |
| Clone derive sur Aggregate Root | -3 | Identite violee |

---

## SECTION 9 : RESSOURCES COMPLEMENTAIRES

### 9.1 Lectures Recommandees

1. **Domain-Driven Design** - Eric Evans (2003)
   - Chapitres 5-6: Entities, Value Objects, Aggregates

2. **Implementing Domain-Driven Design** - Vaughn Vernon (2013)
   - Chapitre 10: Aggregates
   - Chapitre 8: Domain Events

3. **Rust API Guidelines**
   - https://rust-lang.github.io/api-guidelines/

### 9.2 Patterns Connexes

```
+------------------------+----------------------------------+
| Pattern                | Relation avec cet exercice       |
+------------------------+----------------------------------+
| Factory Pattern        | Creation des Aggregates          |
| Specification Pattern  | Validation complexe des VO       |
| Event Sourcing         | Extension naturelle des Events   |
| CQRS                   | Separation commandes/queries     |
| Saga Pattern           | Coordination multi-aggregates    |
+------------------------+----------------------------------+
```

### 9.3 Exercices Suivants

- **EX01**: ResilienceShield - Patterns de Resilience (Circuit Breaker, Retry)
- **EX02**: EventHorizon - Event Sourcing complet
- **EX03**: SagaMaster - Transactions distribuees

---

```
================================================================================
                    FIN DE L'EXERCICE DOMAINFORGE
================================================================================
  "In DDD we trust, in types we verify"

  Bon courage, futur Domain Expert!
================================================================================
  HACKBRAIN MUSIC v5.5.2 - Tactical DDD Modeling
  Generated: 2024-01-16 | Module: 5.6 Microservices
================================================================================
```
