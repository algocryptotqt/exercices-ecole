<thinking>
## Analyse du Concept
- Concept : Timeout Manager
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La gestion des timeouts est critique pour eviter les blocages.
</thinking>

# Exercice 5.6.14-a : timeout_manager

**Module :**
5.6.14 — Resilience Patterns - Timeout

**Concept :**
a — Timeout Manager (deadline propagation, cascading timeouts)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.5 — Programmation async avec tokio
- 5.6.11 — Circuit Breaker

**Domaines :**
Resilience, Async, Deadlines

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(1) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async, timeout)

### 1.2 Consigne

**CONTEXTE : "The Time Keeper"**

*"Le temps est precieux dans un systeme distribue. Si tu n'as pas de reponse dans 5 secondes, considere que tu n'en auras jamais."* — Le Gardien du Temps

Les timeouts evitent que les requetes restent bloquees indefiniment. Un bon systeme de timeout :
- Applique des limites a chaque operation
- Propage les deadlines aux appels downstream
- Mesure le temps restant pour eviter les cascading timeouts

**Ta mission :**

Implementer un `TimeoutManager` qui :
1. Wrap n'importe quelle operation async avec un timeout
2. Propage le budget de temps restant
3. Supporte des timeouts hierarchiques (parent/child)
4. Collecte des metriques sur les timeouts

### 1.3 Prototype

```rust
use std::time::{Duration, Instant};
use std::sync::Arc;

#[derive(Debug, Clone)]
pub struct TimeoutConfig {
    pub default_timeout: Duration,
    pub propagate_deadline: bool,
}

#[derive(Debug)]
pub enum TimeoutError<E> {
    Elapsed,
    DeadlineExceeded,
    OperationFailed(E),
}

#[derive(Debug, Clone)]
pub struct Deadline {
    expires_at: Instant,
}

impl Deadline {
    pub fn new(timeout: Duration) -> Self;
    pub fn remaining(&self) -> Option<Duration>;
    pub fn is_expired(&self) -> bool;
    pub fn child(&self, max_duration: Duration) -> Self;
}

pub struct TimeoutManager {
    config: TimeoutConfig,
    current_deadline: Option<Deadline>,
}

impl TimeoutManager {
    pub fn new(config: TimeoutConfig) -> Self;

    /// Execute avec timeout simple
    pub async fn execute<F, T, E, Fut>(
        &self,
        timeout: Duration,
        operation: F,
    ) -> Result<T, TimeoutError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>;

    /// Execute avec deadline propagee
    pub async fn execute_with_deadline<F, T, E, Fut>(
        &self,
        deadline: Deadline,
        operation: F,
    ) -> Result<T, TimeoutError<E>>
    where
        F: FnOnce(Deadline) -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>;

    /// Cree un child timeout avec le temps restant
    pub fn child_deadline(&self, max_duration: Duration) -> Option<Deadline>;
}

#[derive(Debug, Clone, Default)]
pub struct TimeoutMetrics {
    pub total_operations: u64,
    pub timed_out: u64,
    pub completed: u64,
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Deadline Propagation

Quand une requete traverse plusieurs services, le timeout doit etre reparti :
- Requete initiale : 10s de budget
- Service A : 3s (reste 7s pour downstream)
- Service B : 2s (reste 5s)
- Service C : doit finir en 5s max

### 2.2 Le Piege du Timeout Fixe

```
Client ---10s---> Gateway ---10s---> Service A ---10s---> Service B
                                                              |
                     Reponse apres 25s (3x10s de timeouts!)   v
```

Avec propagation :
```
Client ---10s---> Gateway ---7s---> Service A ---4s---> Service B
                                                              |
                        Timeout a 10s total comme attendu    v
```

### 2.3 gRPC Deadlines

gRPC propage automatiquement les deadlines via le header `grpc-timeout`. Chaque hop soustrait le temps ecoule avant de forwarder.

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_success_within_timeout() {
        let tm = TimeoutManager::new(TimeoutConfig::default());
        let result = tm.execute(
            Duration::from_secs(5),
            || async { Ok::<_, &str>(42) }
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);
    }

    #[tokio::test]
    async fn test_timeout_elapsed() {
        let tm = TimeoutManager::new(TimeoutConfig::default());
        let result = tm.execute(
            Duration::from_millis(10),
            || async {
                tokio::time::sleep(Duration::from_millis(100)).await;
                Ok::<_, &str>(42)
            }
        ).await;

        assert!(matches!(result, Err(TimeoutError::Elapsed)));
    }

    #[test]
    fn test_deadline_remaining() {
        let deadline = Deadline::new(Duration::from_secs(10));
        let remaining = deadline.remaining().unwrap();
        assert!(remaining <= Duration::from_secs(10));
        assert!(remaining > Duration::from_secs(9));
    }

    #[test]
    fn test_deadline_expired() {
        let deadline = Deadline::new(Duration::from_millis(1));
        std::thread::sleep(Duration::from_millis(10));
        assert!(deadline.is_expired());
        assert!(deadline.remaining().is_none());
    }

    #[test]
    fn test_child_deadline() {
        let parent = Deadline::new(Duration::from_secs(10));
        let child = parent.child(Duration::from_secs(5));

        // Child should be min(parent_remaining, max_duration)
        let child_remaining = child.remaining().unwrap();
        assert!(child_remaining <= Duration::from_secs(5));
    }

    #[test]
    fn test_child_inherits_shorter_parent() {
        let parent = Deadline::new(Duration::from_secs(2));
        let child = parent.child(Duration::from_secs(10));

        // Child can't exceed parent
        let child_remaining = child.remaining().unwrap();
        assert!(child_remaining <= Duration::from_secs(2));
    }
}
```

### 4.3 Solution de reference

```rust
use std::time::{Duration, Instant};
use tokio::time::timeout;

#[derive(Debug, Clone)]
pub struct TimeoutConfig {
    pub default_timeout: Duration,
    pub propagate_deadline: bool,
}

impl Default for TimeoutConfig {
    fn default() -> Self {
        Self {
            default_timeout: Duration::from_secs(30),
            propagate_deadline: true,
        }
    }
}

#[derive(Debug)]
pub enum TimeoutError<E> {
    Elapsed,
    DeadlineExceeded,
    OperationFailed(E),
}

impl<E: std::fmt::Display> std::fmt::Display for TimeoutError<E> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Elapsed => write!(f, "Operation timed out"),
            Self::DeadlineExceeded => write!(f, "Deadline exceeded before operation started"),
            Self::OperationFailed(e) => write!(f, "Operation failed: {}", e),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Deadline {
    expires_at: Instant,
}

impl Deadline {
    pub fn new(timeout_duration: Duration) -> Self {
        Self {
            expires_at: Instant::now() + timeout_duration,
        }
    }

    pub fn remaining(&self) -> Option<Duration> {
        let now = Instant::now();
        if now >= self.expires_at {
            None
        } else {
            Some(self.expires_at - now)
        }
    }

    pub fn is_expired(&self) -> bool {
        Instant::now() >= self.expires_at
    }

    pub fn child(&self, max_duration: Duration) -> Self {
        let remaining = self.remaining().unwrap_or(Duration::ZERO);
        let child_duration = remaining.min(max_duration);

        Self {
            expires_at: Instant::now() + child_duration,
        }
    }

    pub fn expires_at(&self) -> Instant {
        self.expires_at
    }
}

pub struct TimeoutManager {
    config: TimeoutConfig,
}

impl TimeoutManager {
    pub fn new(config: TimeoutConfig) -> Self {
        Self { config }
    }

    pub async fn execute<F, T, E, Fut>(
        &self,
        timeout_duration: Duration,
        operation: F,
    ) -> Result<T, TimeoutError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
    {
        match timeout(timeout_duration, operation()).await {
            Ok(Ok(result)) => Ok(result),
            Ok(Err(e)) => Err(TimeoutError::OperationFailed(e)),
            Err(_) => Err(TimeoutError::Elapsed),
        }
    }

    pub async fn execute_with_deadline<F, T, E, Fut>(
        &self,
        deadline: Deadline,
        operation: F,
    ) -> Result<T, TimeoutError<E>>
    where
        F: FnOnce(Deadline) -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
    {
        // Check if deadline already passed
        let remaining = match deadline.remaining() {
            Some(r) => r,
            None => return Err(TimeoutError::DeadlineExceeded),
        };

        match timeout(remaining, operation(deadline.clone())).await {
            Ok(Ok(result)) => Ok(result),
            Ok(Err(e)) => Err(TimeoutError::OperationFailed(e)),
            Err(_) => Err(TimeoutError::Elapsed),
        }
    }

    pub fn child_deadline(&self, parent: &Deadline, max_duration: Duration) -> Option<Deadline> {
        if parent.is_expired() {
            return None;
        }
        Some(parent.child(max_duration))
    }
}

#[derive(Debug, Clone, Default)]
pub struct TimeoutMetrics {
    pub total_operations: u64,
    pub timed_out: u64,
    pub completed: u64,
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Deadline.remaining() ne check pas l'expiration */
pub fn remaining(&self) -> Option<Duration> {
    // MUTANT: Pas de check si expire
    Some(self.expires_at - Instant::now()) // Peut underflow!
}
// Pourquoi c'est faux : Panic si le deadline est passe

/* Mutant B (Safety) : child() peut depasser le parent */
pub fn child(&self, max_duration: Duration) -> Self {
    // MUTANT: Ne prend pas le min avec remaining
    Self { expires_at: Instant::now() + max_duration }
}
// Pourquoi c'est faux : Le child peut expirer apres le parent

/* Mutant C (Logic) : Pas de check avant execute_with_deadline */
pub async fn execute_with_deadline(&self, deadline: Deadline, operation: F) {
    // MUTANT: Pas de check is_expired
    let remaining = deadline.remaining().unwrap();
    timeout(remaining, operation(deadline)).await
}
// Pourquoi c'est faux : Peut panic sur unwrap si deadline expiree

/* Mutant D (Edge) : Timeout zero autorise */
pub fn new(timeout_duration: Duration) -> Self {
    // MUTANT: Pas de validation
    Self { expires_at: Instant::now() + timeout_duration }
}
// Pourquoi c'est faux : Duration::ZERO cause timeout immediat

/* Mutant E (Return) : Erreur de timeout masquee */
pub async fn execute(&self, timeout: Duration, operation: F) -> Result<T, TimeoutError<E>> {
    match timeout(timeout, operation()).await {
        Err(_) => Err(TimeoutError::OperationFailed("timeout".into())),
        // MUTANT: Timeout retourne comme OperationFailed
    }
}
// Pourquoi c'est faux : Impossible de distinguer timeout vs erreur operation
```

---

## SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                    DEADLINE PROPAGATION

    Request with 10s budget
           │
           ▼
    ┌──────────────┐
    │   Gateway    │ consumes 1s
    │   9s left    │
    └──────┬───────┘
           │ propagates 9s deadline
           ▼
    ┌──────────────┐
    │  Service A   │ consumes 2s
    │   7s left    │
    └──────┬───────┘
           │ propagates 7s deadline
           ▼
    ┌──────────────┐
    │  Service B   │ consumes 3s
    │   4s left    │
    └──────┬───────┘
           │ propagates 4s deadline
           ▼
    ┌──────────────┐
    │  Service C   │ must complete in 4s
    └──────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Underflow remaining | Panic | Check is_expired first |
| 2 | Child > parent | Cascade incorrecte | .min(remaining) |
| 3 | Expired unchecked | Panic/zero timeout | Check before execute |
| 4 | Zero timeout | Immediate fail | Validate config |
| 5 | Timeout masque | Debug impossible | Types distincts |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | timeout_manager |
| **Module** | 5.6.14 — Timeout Manager |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP** | 150 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.14-a-timeout-manager",
    "metadata": {
      "exercise_id": "5.6.14-a",
      "exercise_name": "timeout_manager",
      "difficulty": 6,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 94/100*
