<thinking>
## Analyse du Concept
- Concept : Outbox Pattern
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - L'outbox pattern est essentiel pour garantir la coherence entre ecriture en base et publication d'evenements en systeme distribue.

## Combo Base + Bonus
- Exercice de base : Implementer le pattern outbox avec table dediee, polling et publication garantie
- Bonus : Implementation avec CDC (Change Data Capture) et exactly-once delivery
- Palier bonus : Avance (garanties de livraison distribuees)
- Progression logique ? OUI - Base = polling simple, Bonus = CDC avance

## Prerequis & Difficulte
- Prerequis reels : Async Rust, SQL, patterns messaging
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Postal Service" - Garantir la livraison
- MEME mnemonique : "Neither snow nor rain..." (USPS motto)
- Pourquoi c'est fun : L'outbox est comme une boite aux lettres garantissant la livraison

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Transaction non atomique (save + publish separes)
2. Mutant B (Safety) : Race condition sur le marking des messages comme publies
3. Mutant C (Logic) : Messages publies mais non marques (republication infinie)
4. Mutant D (Edge) : Ordre des messages non preserve
5. Mutant E (Return) : Pas de retry sur echec de publication

## Verdict
VALIDE - Exercice de qualite industrielle couvrant la coherence transactionnelle
</thinking>

# Exercice 5.6.7-a : outbox_pattern

**Module :**
5.6.7 — Microservices Patterns - Transactional Outbox

**Concept :**
a — Outbox Pattern (coherence transactionnelle, publication garantie)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.4 — Gestion d'erreurs (Result, Option)
- 3.5 — Programmation async avec tokio
- 5.2 — Bases de donnees et SQL

**Domaines :**
DB, Async, Messaging

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `sqlx` (database async)
- `serde` / `serde_json` (serialization)
- `uuid` (identifiants)

**Fonctions/methodes interdites :**
- Crates de messaging complets (`kafka`, `rabbitmq`)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Guaranteed Delivery"**

*"Chaque message doit arriver. Pas de perte, pas de duplication. C'est le contrat."* — Le Facteur Distribue

Le probleme du "dual write" : comment garantir qu'une ecriture en base ET la publication d'un evenement se font toutes les deux ou aucune ? Le pattern Outbox resout ce probleme en ecrivant l'evenement dans une table de la meme base, puis un processus separe le publie.

**Ta mission :**

Implementer un systeme `Outbox` qui :
1. Stocke les evenements dans une table outbox au sein de la meme transaction que les donnees metier
2. Expose un publisher qui poll la table et publie les evenements
3. Garantit at-least-once delivery avec idempotence
4. Supporte le retry avec backoff exponentiel
5. Nettoie les anciens messages publies

**Entree :**
- `event: OutboxEvent` — Evenement a publier
- `connection: &mut Transaction` — Transaction SQL active

**Sortie :**
- `Result<(), OutboxError>` — Succes ou erreur

**Contraintes :**
- Les evenements doivent etre persistes avant commit de la transaction metier
- Le publisher ne doit pas bloquer les ecritures
- L'ordre des evenements par aggregate doit etre preserve
- Les evenements doivent avoir un TTL configurable

**Exemples :**

| Scenario | Action | Resultat |
|----------|--------|----------|
| Transaction reussie | save_with_event | Event en outbox |
| Transaction rollback | save_with_event | Pas d'event |
| Publisher poll | poll_and_publish | Events publies et marques |

### 1.2.2 Consigne Academique

Implementer le pattern Outbox Transactionnel garantissant la coherence entre ecritures en base de donnees et publication d'evenements. Le systeme doit supporter at-least-once delivery avec detection des duplicatas.

### 1.3 Prototype

```rust
use std::time::Duration;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutboxEvent {
    pub id: Uuid,
    pub aggregate_type: String,
    pub aggregate_id: String,
    pub event_type: String,
    pub payload: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub published_at: Option<DateTime<Utc>>,
    pub retry_count: u32,
}

#[derive(Debug, Clone)]
pub struct OutboxConfig {
    pub poll_interval: Duration,
    pub batch_size: usize,
    pub max_retries: u32,
    pub retention_period: Duration,
}

#[derive(Debug)]
pub enum OutboxError {
    DatabaseError(String),
    SerializationError(String),
    PublishError(String),
    MaxRetriesExceeded(Uuid),
}

#[async_trait::async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, event: &OutboxEvent) -> Result<(), String>;
}

pub struct Outbox<P: EventPublisher> {
    config: OutboxConfig,
    publisher: P,
}

impl<P: EventPublisher> Outbox<P> {
    pub fn new(config: OutboxConfig, publisher: P) -> Self;

    /// Ajoute un evenement a l'outbox dans la transaction courante
    pub async fn add_event<'e, E>(
        &self,
        executor: E,
        aggregate_type: &str,
        aggregate_id: &str,
        event_type: &str,
        payload: serde_json::Value,
    ) -> Result<Uuid, OutboxError>
    where
        E: sqlx::Executor<'e, Database = sqlx::Postgres>;

    /// Poll et publie les evenements en attente
    pub async fn poll_and_publish<'e, E>(
        &self,
        executor: E,
    ) -> Result<PublishResult, OutboxError>
    where
        E: sqlx::Executor<'e, Database = sqlx::Postgres>;

    /// Marque un evenement comme publie
    pub async fn mark_published<'e, E>(
        &self,
        executor: E,
        event_id: Uuid,
    ) -> Result<(), OutboxError>
    where
        E: sqlx::Executor<'e, Database = sqlx::Postgres>;

    /// Incremente le retry count
    pub async fn increment_retry<'e, E>(
        &self,
        executor: E,
        event_id: Uuid,
    ) -> Result<(), OutboxError>
    where
        E: sqlx::Executor<'e, Database = sqlx::Postgres>;

    /// Nettoie les anciens evenements publies
    pub async fn cleanup<'e, E>(
        &self,
        executor: E,
    ) -> Result<u64, OutboxError>
    where
        E: sqlx::Executor<'e, Database = sqlx::Postgres>;
}

#[derive(Debug, Default)]
pub struct PublishResult {
    pub published: usize,
    pub failed: usize,
    pub skipped: usize,
}

/// SQL pour creer la table outbox
pub fn create_outbox_table_sql() -> &'static str;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Le Probleme du Dual Write

Le dual write est un anti-pattern ou on ecrit dans deux systemes (ex: DB + Kafka) sans coordination :
1. Si on ecrit DB puis Kafka : si Kafka echoue, la DB est mise a jour mais l'event est perdu
2. Si on ecrit Kafka puis DB : si DB echoue, l'event est publie mais les donnees ne sont pas persistees

Le pattern Outbox resout ce probleme en utilisant la transaction de la DB comme source de verite.

### 2.2 Outbox vs CDC

- **Outbox polling** : Simple, universel, mais ajoute de la latence
- **CDC (Change Data Capture)** : Lit le WAL de la DB, temps reel, mais plus complexe
- Debezium est l'outil CDC le plus populaire pour transformer l'outbox en events Kafka

### 2.3 Idempotence Consumer

L'outbox garantit at-least-once delivery (chaque event sera livre au moins une fois). Les consumers doivent donc gerer les duplicatas via :
- Un store d'event IDs deja traites
- Des operations idempotentes (ex: `INSERT ... ON CONFLICT DO NOTHING`)

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de l'outbox |
|--------|-------------------------|
| **Backend Developer** | Integration transactionnelle event-driven |
| **Data Engineer** | Synchronisation DB vers data lake |
| **Platform Engineer** | Infrastructure CDC avec Debezium |
| **Architect** | Design de systemes eventually consistent |

### Cas d'usage concrets

1. **E-commerce** : Apres creation commande, publier OrderCreated vers shipping
2. **Banking** : Transaction DB + event pour audit trail
3. **Microservices** : Synchroniser les read models entre services

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling outbox_pattern v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 12 tests
test tests::test_outbox_event_creation ... ok
test tests::test_add_event_to_outbox ... ok
test tests::test_poll_pending_events ... ok
test tests::test_mark_as_published ... ok
test tests::test_retry_increment ... ok
test tests::test_max_retries_exceeded ... ok
test tests::test_ordering_preserved ... ok
test tests::test_cleanup_old_events ... ok
test tests::test_concurrent_publishers ... ok
test tests::test_publish_result_aggregation ... ok
test tests::test_transaction_rollback ... ok
test tests::test_idempotent_publish ... ok

test result: ok. 12 passed; 0 failed
```

### 3.1 Bonus Avance (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

#### 3.1.1 Consigne Bonus

Implementer un outbox avec :
- CDC via LISTEN/NOTIFY PostgreSQL pour temps reel
- Exactly-once delivery avec consumer acknowledgment store
- Partitioning par aggregate pour parallelisme

#### 3.1.2 Prototype Bonus

```rust
pub struct CdcOutbox {
    notify_channel: String,
    consumer_store: Arc<dyn ConsumerAckStore>,
}

#[async_trait::async_trait]
pub trait ConsumerAckStore: Send + Sync {
    async fn has_processed(&self, consumer_id: &str, event_id: Uuid) -> bool;
    async fn mark_processed(&self, consumer_id: &str, event_id: Uuid);
}

impl CdcOutbox {
    pub async fn listen_and_publish(&self) -> Result<(), OutboxError>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `event_creation` | `OutboxEvent::new(...)` | Valid event | 5 | Basic |
| `add_event` | Event + transaction | Event in DB | 10 | Core |
| `poll_pending` | 5 pending events | 5 events returned | 10 | Core |
| `mark_published` | Published event | published_at set | 10 | Core |
| `retry_increment` | Failed event | retry_count++ | 10 | Core |
| `max_retries` | retry_count >= max | Error returned | 10 | Edge |
| `order_preserved` | 3 events same aggregate | Correct order | 10 | Core |
| `cleanup` | Events older than TTL | Deleted | 10 | Core |
| `concurrent_poll` | 2 publishers | No duplicates | 10 | Edge |
| `transaction_rollback` | Failed transaction | No event | 10 | Edge |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_outbox_event_creation() {
        let event = OutboxEvent {
            id: Uuid::new_v4(),
            aggregate_type: "Order".to_string(),
            aggregate_id: "order-123".to_string(),
            event_type: "OrderCreated".to_string(),
            payload: serde_json::json!({"amount": 100}),
            created_at: Utc::now(),
            published_at: None,
            retry_count: 0,
        };

        assert_eq!(event.aggregate_type, "Order");
        assert!(event.published_at.is_none());
    }

    #[test]
    fn test_config_defaults() {
        let config = OutboxConfig {
            poll_interval: Duration::from_secs(5),
            batch_size: 100,
            max_retries: 3,
            retention_period: Duration::from_secs(86400),
        };

        assert_eq!(config.max_retries, 3);
    }

    #[test]
    fn test_publish_result_aggregation() {
        let mut result = PublishResult::default();
        result.published = 5;
        result.failed = 2;
        result.skipped = 1;

        assert_eq!(result.published + result.failed + result.skipped, 8);
    }

    #[test]
    fn test_create_table_sql() {
        let sql = create_outbox_table_sql();
        assert!(sql.contains("CREATE TABLE"));
        assert!(sql.contains("outbox"));
        assert!(sql.contains("aggregate_id"));
    }
}
```

### 4.3 Solution de reference

```rust
use std::time::Duration;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use async_trait::async_trait;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutboxEvent {
    pub id: Uuid,
    pub aggregate_type: String,
    pub aggregate_id: String,
    pub event_type: String,
    pub payload: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub published_at: Option<DateTime<Utc>>,
    pub retry_count: u32,
}

impl OutboxEvent {
    pub fn new(
        aggregate_type: &str,
        aggregate_id: &str,
        event_type: &str,
        payload: serde_json::Value,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            aggregate_type: aggregate_type.to_string(),
            aggregate_id: aggregate_id.to_string(),
            event_type: event_type.to_string(),
            payload,
            created_at: Utc::now(),
            published_at: None,
            retry_count: 0,
        }
    }

    pub fn is_published(&self) -> bool {
        self.published_at.is_some()
    }

    pub fn can_retry(&self, max_retries: u32) -> bool {
        self.retry_count < max_retries
    }
}

#[derive(Debug, Clone)]
pub struct OutboxConfig {
    pub poll_interval: Duration,
    pub batch_size: usize,
    pub max_retries: u32,
    pub retention_period: Duration,
}

impl Default for OutboxConfig {
    fn default() -> Self {
        Self {
            poll_interval: Duration::from_secs(5),
            batch_size: 100,
            max_retries: 3,
            retention_period: Duration::from_secs(7 * 24 * 3600), // 7 days
        }
    }
}

#[derive(Debug)]
pub enum OutboxError {
    DatabaseError(String),
    SerializationError(String),
    PublishError(String),
    MaxRetriesExceeded(Uuid),
}

impl std::fmt::Display for OutboxError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DatabaseError(e) => write!(f, "Database error: {}", e),
            Self::SerializationError(e) => write!(f, "Serialization error: {}", e),
            Self::PublishError(e) => write!(f, "Publish error: {}", e),
            Self::MaxRetriesExceeded(id) => write!(f, "Max retries exceeded for event: {}", id),
        }
    }
}

impl std::error::Error for OutboxError {}

#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, event: &OutboxEvent) -> Result<(), String>;
}

#[derive(Debug, Default)]
pub struct PublishResult {
    pub published: usize,
    pub failed: usize,
    pub skipped: usize,
}

pub fn create_outbox_table_sql() -> &'static str {
    r#"
    CREATE TABLE IF NOT EXISTS outbox (
        id UUID PRIMARY KEY,
        aggregate_type VARCHAR(255) NOT NULL,
        aggregate_id VARCHAR(255) NOT NULL,
        event_type VARCHAR(255) NOT NULL,
        payload JSONB NOT NULL,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        published_at TIMESTAMPTZ,
        retry_count INTEGER NOT NULL DEFAULT 0,

        -- Index for polling unpublished events
        INDEX idx_outbox_pending (published_at) WHERE published_at IS NULL,
        -- Index for ordering by aggregate
        INDEX idx_outbox_aggregate (aggregate_id, created_at)
    )
    "#
}

// Mock implementation for testing
pub struct MockPublisher {
    should_fail: bool,
}

impl MockPublisher {
    pub fn new(should_fail: bool) -> Self {
        Self { should_fail }
    }
}

#[async_trait]
impl EventPublisher for MockPublisher {
    async fn publish(&self, event: &OutboxEvent) -> Result<(), String> {
        if self.should_fail {
            Err("Mock publish failure".to_string())
        } else {
            Ok(())
        }
    }
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Publish avant commit de transaction
async fn save_with_event(&self, data: Data, event: Event) {
    self.publisher.publish(&event).await?; // ERREUR: Publie avant commit
    self.db.save(data).await?;
}
// Pourquoi refusee : Si le save echoue, l'event est deja publie

// REFUSEE 2 : Pas de lock sur le polling
async fn poll_and_publish(&self) -> Result<PublishResult> {
    let events = self.get_pending().await?;
    for event in events {
        // ERREUR: Un autre worker peut traiter le meme event
        self.publish(event).await?;
        self.mark_published(event.id).await?;
    }
}
// Pourquoi refusee : Race condition entre workers

// REFUSEE 3 : Mark avant publish
async fn process_event(&self, event: OutboxEvent) {
    self.mark_published(event.id).await?; // ERREUR: Mark avant publish
    self.publisher.publish(&event).await?;
}
// Pourquoi refusee : Si publish echoue, l'event est marque comme publie
```

### 4.9 spec.json

```json
{
  "name": "outbox_pattern",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isole - Transactional Outbox",
  "tags": ["microservices", "outbox", "messaging", "transactions", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "Outbox",
    "prototype": "impl Outbox<P: EventPublisher>",
    "return_type": "struct"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "transaction_rollback",
        "input": "Failed save with event",
        "expected": "No event in outbox",
        "is_trap": true,
        "trap_explanation": "Event must be in same transaction as data"
      },
      {
        "name": "max_retries",
        "input": "Event with retry_count >= max_retries",
        "expected": "MaxRetriesExceeded error",
        "is_trap": true
      },
      {
        "name": "ordering",
        "input": "3 events for same aggregate",
        "expected": "Events in creation order",
        "is_trap": true
      }
    ]
  },

  "norm": {
    "forbidden_functions": ["unsafe"],
    "check_security": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Transaction non atomique */
async fn save_with_event(&self, data: Data, event: Event) {
    self.db.save(data).await?;
    // MUTANT: Separate transaction pour l'event
    self.db.insert_outbox(event).await?;
}
// Pourquoi c'est faux : Si insert_outbox echoue, data est sauvegardee sans event

/* Mutant B (Safety) : Race condition polling */
async fn poll_and_publish(&self) -> Result<PublishResult> {
    let events = self.get_pending().await?;
    // MUTANT: Pas de SELECT FOR UPDATE
    for event in events {
        self.publish(event).await?;
    }
}
// Pourquoi c'est faux : Deux workers peuvent traiter le meme event

/* Mutant C (Logic) : Mark avant publish */
async fn process_event(&self, event: OutboxEvent) {
    self.mark_published(event.id).await?;
    // MUTANT: Mark avant publish
    self.publisher.publish(&event).await?;
}
// Pourquoi c'est faux : Event marque comme publie meme si publish echoue

/* Mutant D (Edge) : Pas de tri par created_at */
async fn get_pending(&self) -> Vec<OutboxEvent> {
    // MUTANT: Pas de ORDER BY created_at
    sqlx::query_as("SELECT * FROM outbox WHERE published_at IS NULL LIMIT $1")
        .fetch_all(&self.pool).await
}
// Pourquoi c'est faux : Ordre des events non garanti

/* Mutant E (Return) : Pas de retry handling */
async fn process_event(&self, event: OutboxEvent) {
    if self.publisher.publish(&event).await.is_err() {
        // MUTANT: Pas d'increment du retry_count
        return;
    }
    self.mark_published(event.id).await?;
}
// Pourquoi c'est faux : Event jamais marque en echec permanent
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Transactional Outbox** : Garantir la coherence DB + events
2. **At-Least-Once Delivery** : Chaque event sera livre au moins une fois
3. **Idempotence** : Gerer les duplicatas cote consumer
4. **Polling patterns** : Batch processing efficace
5. **Error handling distribue** : Retry, dead letter, cleanup

### 5.2 Pseudocode Academique

```
ALGORITHME : Transactional Outbox
---
ENTREE : Donnees metier, Evenement a publier
SORTIE : Succes ou Erreur

DANS UNE TRANSACTION:
  1. SAUVEGARDER donnees metier
  2. INSERER evenement dans table outbox
  3. COMMIT transaction

SEPAREMENT (worker de publication):
  BOUCLE:
    1. SELECT evenements non publies WITH LOCK
    2. POUR CHAQUE evenement:
       a. PUBLIER vers message broker
       b. SI succes: MARQUER comme publie
       c. SI echec: INCREMENTER retry_count
       d. SI retry_count >= max: DEPLACER vers dead letter
    3. ATTENDRE poll_interval
```

### 5.3 Visualisation ASCII

```
                    OUTBOX PATTERN FLOW

    ┌──────────────────────────────────────────────────┐
    │                   TRANSACTION                     │
    │  ┌────────────┐         ┌─────────────────┐      │
    │  │   Save     │────────►│  Insert Outbox  │      │
    │  │   Order    │         │     Event       │      │
    │  └────────────┘         └─────────────────┘      │
    │                    COMMIT                         │
    └──────────────────────────────────────────────────┘
                              │
                              ▼
    ┌──────────────────────────────────────────────────┐
    │              OUTBOX PUBLISHER (async)            │
    │                                                  │
    │   POLL ──► PUBLISH ──► MARK ──► CLEANUP          │
    │     │         │          │                       │
    │     └─────────┼──────────┘                       │
    │         RETRY if failed                          │
    └──────────────────────────────────────────────────┘
                              │
                              ▼
                     ┌─────────────┐
                     │   Message   │
                     │   Broker    │
                     └─────────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Dual write** | Publish hors transaction | Toujours dans la meme TX |
| **Race condition** | Double traitement | SELECT FOR UPDATE |
| **Event loss** | Mark avant publish | Toujours publish d'abord |
| **Disorder** | Events non ordonnes | ORDER BY created_at |
| **Infinite retry** | Pas de max retries | Implementer dead letter |

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Dual write | Events perdus ou orphelins | Transaction atomique |
| 2 | Race condition | Events dupliques | SELECT FOR UPDATE |
| 3 | Mark avant publish | Events marques non publies | Publish puis mark |
| 4 | Desordre | Events hors sequence | ORDER BY + aggregate_id |
| 5 | Infinite retry | Queue bloquee | Max retries + dead letter |

---

## SECTION 7 : QCM

### Question 1
**Quel probleme le pattern Outbox resout-il ?**

A) Performance des requetes SQL
B) Le probleme du dual write
C) La mise en cache
D) Le load balancing
E) L'authentification
F) Le rate limiting
G) La pagination
H) Le full-text search
I) Les indexes
J) Les foreign keys

**Reponse : B**

*Explication : L'outbox resout le dual write problem en ecrivant l'evenement dans la meme transaction que les donnees metier.*

---

### Question 2
**Pourquoi doit-on utiliser SELECT FOR UPDATE lors du polling ?**

A) Pour ameliorer les performances
B) Pour eviter que deux workers traitent le meme event
C) Pour trier les resultats
D) Pour paginer
E) Pour joindre des tables
F) Pour aggreager des donnees
G) Pour filtrer par date
H) Pour compter les lignes
I) Pour grouper les resultats
J) Pour limiter les resultats

**Reponse : B**

*Explication : SELECT FOR UPDATE verrouille les lignes selectionnees, empechant d'autres workers de les traiter en parallele.*

---

### Question 3
**Quelle garantie de livraison l'outbox pattern fournit-il ?**

A) At-most-once
B) At-least-once
C) Exactly-once
D) Best-effort
E) Fire-and-forget
F) Guaranteed order
G) No guarantee
H) Conditional delivery
I) Delayed delivery
J) Priority delivery

**Reponse : B**

*Explication : L'outbox garantit at-least-once delivery. Les consumers doivent gerer les duplicatas (idempotence).*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | outbox_pattern |
| **Module** | 5.6.7 — Transactional Outbox |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x3 |
| **Concepts cles** | Outbox, transactions, at-least-once |
| **Piege principal** | Dual write problem |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.6.7-a-outbox-pattern",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.6.7-a",
      "exercise_name": "outbox_pattern",
      "module": "5.6.7",
      "module_name": "Transactional Outbox",
      "concept": "a",
      "concept_name": "Outbox Pattern",
      "type": "code",
      "tier": 1,
      "phase": 5,
      "difficulty": 7,
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
