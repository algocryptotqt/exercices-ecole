# Exercice 5.6.19-a : service_mesh

**Module :**
5.6.19 — Infrastructure Patterns - Service Mesh

**Concept :**
a — Service Mesh (data plane, control plane, sidecar injection)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
2 — Concepts composes

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.6.6 — Sidecar Proxy
- 5.6.11 — Circuit Breaker
- 5.6.16 — Correlation Tracker

**Domaines :**
Infrastructure, Networking, Observability

**Duree estimee :**
180 min

**XP Base :**
225

**Complexite :**
T4 O(n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

**CONTEXTE : "The Invisible Network"**

*"Tu ne vois pas le mesh, mais il est partout. Chaque requete passe par lui, chaque service est surveille par lui."* — L'Architecte du Mesh

Un Service Mesh est une couche d'infrastructure dediee qui gere la communication service-to-service. Elle fournit : discovery, load balancing, encryption, observability, et resilience.

**Ta mission :**

Implementer un mini `ServiceMesh` qui :
1. Fournit un registre de services (service discovery)
2. Implemente le load balancing (round-robin, least-connections)
3. Injecte automatiquement les sidecars
4. Centralise les metriques et le tracing

### 1.3 Prototype

```rust
use std::time::Duration;
use std::collections::HashMap;
use std::sync::Arc;

#[derive(Debug, Clone)]
pub struct ServiceEndpoint {
    pub service_name: String,
    pub instance_id: String,
    pub address: String,
    pub port: u16,
    pub metadata: HashMap<String, String>,
    pub health_status: HealthStatus,
}

#[derive(Debug, Clone, PartialEq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

#[async_trait::async_trait]
pub trait ServiceRegistry: Send + Sync {
    async fn register(&self, endpoint: ServiceEndpoint) -> Result<(), RegistryError>;
    async fn deregister(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError>;
    async fn discover(&self, service_name: &str) -> Vec<ServiceEndpoint>;
    async fn watch(&self, service_name: &str) -> tokio::sync::watch::Receiver<Vec<ServiceEndpoint>>;
}

pub trait LoadBalancer: Send + Sync {
    fn select(&self, endpoints: &[ServiceEndpoint]) -> Option<&ServiceEndpoint>;
    fn record_success(&self, endpoint: &ServiceEndpoint);
    fn record_failure(&self, endpoint: &ServiceEndpoint);
}

pub struct RoundRobinBalancer {
    index: std::sync::atomic::AtomicUsize,
}

pub struct LeastConnectionsBalancer {
    connections: tokio::sync::RwLock<HashMap<String, u32>>,
}

pub struct ServiceMesh {
    registry: Box<dyn ServiceRegistry>,
    load_balancer: Box<dyn LoadBalancer>,
    sidecars: tokio::sync::RwLock<HashMap<String, SidecarProxy>>,
    config: MeshConfig,
}

#[derive(Debug, Clone)]
pub struct MeshConfig {
    pub retry_policy: RetryConfig,
    pub circuit_breaker: CircuitBreakerConfig,
    pub timeout: Duration,
    pub mtls_enabled: bool,
}

impl ServiceMesh {
    pub fn new(
        registry: impl ServiceRegistry + 'static,
        load_balancer: impl LoadBalancer + 'static,
        config: MeshConfig,
    ) -> Self;

    /// Envoie une requete a un service via le mesh
    pub async fn call(
        &self,
        service_name: &str,
        request: Request,
    ) -> Result<Response, MeshError>;

    /// Configure le sidecar pour un service
    pub async fn inject_sidecar(&self, service_name: &str, sidecar: SidecarProxy);

    /// Health check de tous les endpoints
    pub async fn health_check_all(&self) -> HealthReport;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Data Plane vs Control Plane

- **Data Plane** : Les sidecars qui traitent les requetes (Envoy)
- **Control Plane** : La gestion centralisee (Istio, Linkerd)

### 2.2 Service Meshes Populaires

| Mesh | Data Plane | Langage | Particularite |
|------|------------|---------|---------------|
| Istio | Envoy | C++ | Feature-rich, complexe |
| Linkerd | linkerd2-proxy | Rust | Leger, simple |
| Consul Connect | Envoy/builtin | Go | Multi-cloud |

### 2.3 Le Cout du Mesh

Chaque requete ajoute :
- 2 hops reseau supplementaires (in/out sidecar)
- Latence : +1-5ms par hop
- Memory : 30-100MB par sidecar
- CPU : 1-5% overhead

---

## SECTION 4 : ZONE CORRECTION

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct InMemoryRegistry {
        endpoints: tokio::sync::RwLock<HashMap<String, Vec<ServiceEndpoint>>>,
    }

    #[tokio::test]
    async fn test_service_registration() {
        let registry = InMemoryRegistry::new();
        let endpoint = ServiceEndpoint {
            service_name: "user-service".to_string(),
            instance_id: "user-1".to_string(),
            address: "10.0.0.1".to_string(),
            port: 8080,
            metadata: HashMap::new(),
            health_status: HealthStatus::Healthy,
        };

        registry.register(endpoint).await.unwrap();
        let discovered = registry.discover("user-service").await;
        assert_eq!(discovered.len(), 1);
    }

    #[test]
    fn test_round_robin_balancer() {
        let balancer = RoundRobinBalancer::new();
        let endpoints = vec![
            create_endpoint("a"),
            create_endpoint("b"),
            create_endpoint("c"),
        ];

        assert_eq!(balancer.select(&endpoints).unwrap().instance_id, "a");
        assert_eq!(balancer.select(&endpoints).unwrap().instance_id, "b");
        assert_eq!(balancer.select(&endpoints).unwrap().instance_id, "c");
        assert_eq!(balancer.select(&endpoints).unwrap().instance_id, "a"); // Wrap around
    }

    #[tokio::test]
    async fn test_mesh_call_with_retry() {
        let mesh = create_test_mesh();
        // Simulate one failure, then success
        let result = mesh.call("user-service", Request::new()).await;
        assert!(result.is_ok());
    }
}
```

### 4.3 Solution de reference

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::collections::HashMap;
use std::time::Duration;
use tokio::sync::RwLock;
use async_trait::async_trait;

#[derive(Debug, Clone)]
pub struct ServiceEndpoint {
    pub service_name: String,
    pub instance_id: String,
    pub address: String,
    pub port: u16,
    pub metadata: HashMap<String, String>,
    pub health_status: HealthStatus,
}

impl ServiceEndpoint {
    pub fn url(&self) -> String {
        format!("http://{}:{}", self.address, self.port)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

#[derive(Debug)]
pub struct RegistryError(pub String);

#[async_trait]
pub trait ServiceRegistry: Send + Sync {
    async fn register(&self, endpoint: ServiceEndpoint) -> Result<(), RegistryError>;
    async fn deregister(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError>;
    async fn discover(&self, service_name: &str) -> Vec<ServiceEndpoint>;
}

pub trait LoadBalancer: Send + Sync {
    fn select<'a>(&self, endpoints: &'a [ServiceEndpoint]) -> Option<&'a ServiceEndpoint>;
    fn record_success(&self, endpoint: &ServiceEndpoint);
    fn record_failure(&self, endpoint: &ServiceEndpoint);
}

pub struct RoundRobinBalancer {
    index: AtomicUsize,
}

impl RoundRobinBalancer {
    pub fn new() -> Self {
        Self {
            index: AtomicUsize::new(0),
        }
    }
}

impl LoadBalancer for RoundRobinBalancer {
    fn select<'a>(&self, endpoints: &'a [ServiceEndpoint]) -> Option<&'a ServiceEndpoint> {
        if endpoints.is_empty() {
            return None;
        }

        let healthy: Vec<_> = endpoints.iter()
            .filter(|e| e.health_status == HealthStatus::Healthy)
            .collect();

        if healthy.is_empty() {
            return None;
        }

        let idx = self.index.fetch_add(1, Ordering::Relaxed) % healthy.len();
        Some(healthy[idx])
    }

    fn record_success(&self, _endpoint: &ServiceEndpoint) {}
    fn record_failure(&self, _endpoint: &ServiceEndpoint) {}
}

pub struct LeastConnectionsBalancer {
    connections: RwLock<HashMap<String, u32>>,
}

impl LeastConnectionsBalancer {
    pub fn new() -> Self {
        Self {
            connections: RwLock::new(HashMap::new()),
        }
    }
}

impl LoadBalancer for LeastConnectionsBalancer {
    fn select<'a>(&self, endpoints: &'a [ServiceEndpoint]) -> Option<&'a ServiceEndpoint> {
        let connections = futures::executor::block_on(self.connections.read());

        endpoints.iter()
            .filter(|e| e.health_status == HealthStatus::Healthy)
            .min_by_key(|e| connections.get(&e.instance_id).unwrap_or(&0))
    }

    fn record_success(&self, endpoint: &ServiceEndpoint) {
        let mut connections = futures::executor::block_on(self.connections.write());
        if let Some(count) = connections.get_mut(&endpoint.instance_id) {
            *count = count.saturating_sub(1);
        }
    }

    fn record_failure(&self, endpoint: &ServiceEndpoint) {
        let mut connections = futures::executor::block_on(self.connections.write());
        if let Some(count) = connections.get_mut(&endpoint.instance_id) {
            *count = count.saturating_sub(1);
        }
    }
}

pub struct InMemoryRegistry {
    endpoints: RwLock<HashMap<String, Vec<ServiceEndpoint>>>,
}

impl InMemoryRegistry {
    pub fn new() -> Self {
        Self {
            endpoints: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl ServiceRegistry for InMemoryRegistry {
    async fn register(&self, endpoint: ServiceEndpoint) -> Result<(), RegistryError> {
        let mut endpoints = self.endpoints.write().await;
        endpoints.entry(endpoint.service_name.clone())
            .or_insert_with(Vec::new)
            .push(endpoint);
        Ok(())
    }

    async fn deregister(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError> {
        let mut endpoints = self.endpoints.write().await;
        if let Some(list) = endpoints.get_mut(service_name) {
            list.retain(|e| e.instance_id != instance_id);
        }
        Ok(())
    }

    async fn discover(&self, service_name: &str) -> Vec<ServiceEndpoint> {
        let endpoints = self.endpoints.read().await;
        endpoints.get(service_name).cloned().unwrap_or_default()
    }
}

#[derive(Debug, Clone)]
pub struct MeshConfig {
    pub timeout: Duration,
    pub max_retries: u32,
}

impl Default for MeshConfig {
    fn default() -> Self {
        Self {
            timeout: Duration::from_secs(30),
            max_retries: 3,
        }
    }
}

#[derive(Debug)]
pub struct MeshError(pub String);

pub struct ServiceMesh {
    registry: Box<dyn ServiceRegistry>,
    load_balancer: Box<dyn LoadBalancer>,
    config: MeshConfig,
}

impl ServiceMesh {
    pub fn new(
        registry: impl ServiceRegistry + 'static,
        load_balancer: impl LoadBalancer + 'static,
        config: MeshConfig,
    ) -> Self {
        Self {
            registry: Box::new(registry),
            load_balancer: Box::new(load_balancer),
            config,
        }
    }

    pub async fn call(&self, service_name: &str) -> Result<String, MeshError> {
        let endpoints = self.registry.discover(service_name).await;

        if endpoints.is_empty() {
            return Err(MeshError(format!("No endpoints found for {}", service_name)));
        }

        let endpoint = self.load_balancer.select(&endpoints)
            .ok_or_else(|| MeshError("No healthy endpoints".to_string()))?;

        // In real implementation, make HTTP call here
        self.load_balancer.record_success(endpoint);

        Ok(format!("Response from {}", endpoint.url()))
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Load balancer ignore unhealthy */
fn select<'a>(&self, endpoints: &'a [ServiceEndpoint]) -> Option<&'a ServiceEndpoint> {
    // MUTANT: Pas de filtre sur health_status
    let idx = self.index.fetch_add(1, Ordering::Relaxed) % endpoints.len();
    Some(&endpoints[idx])
}
// Pourquoi c'est faux : Envoie des requetes a des endpoints morts

/* Mutant B (Safety) : Index overflow */
fn select(&self, endpoints: &[ServiceEndpoint]) -> Option<&ServiceEndpoint> {
    // MUTANT: Pas de modulo, index peut depasser
    let idx = self.index.fetch_add(1, Ordering::Relaxed);
    endpoints.get(idx)
}
// Pourquoi c'est faux : Index out of bounds apres quelques iterations

/* Mutant C (Logic) : Deregister ne filtre pas */
async fn deregister(&self, service_name: &str, _: &str) {
    let mut endpoints = self.endpoints.write().await;
    // MUTANT: Supprime tous les endpoints du service
    endpoints.remove(service_name);
}
// Pourquoi c'est faux : Une instance down supprime tout le service

/* Mutant D (Edge) : Discover retourne les unhealthy */
async fn discover(&self, service_name: &str) -> Vec<ServiceEndpoint> {
    let endpoints = self.endpoints.read().await;
    // MUTANT: Pas de filtre sur health, ou le faire ailleurs
    endpoints.get(service_name).cloned().unwrap_or_default()
}
// Pourquoi c'est faux : Caller doit filtrer lui-meme

/* Mutant E (Return) : Pas de record sur failure */
async fn call(&self, service_name: &str) -> Result<String, MeshError> {
    let endpoint = self.load_balancer.select(&endpoints)?;
    match make_request(endpoint).await {
        Err(e) => {
            // MUTANT: Pas de record_failure
            Err(MeshError(e))
        }
    }
}
// Pourquoi c'est faux : Le load balancer ne sait pas quels endpoints ont echoue
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Select unhealthy | Timeouts | Filter par health |
| 2 | Index overflow | Panic | Modulo |
| 3 | Deregister tout | Service down | Filter par instance |
| 4 | Unhealthy visible | Routing faux | Filter a la source |
| 5 | Failure non record | Bad balancing | record_failure |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | service_mesh |
| **Module** | 5.6.19 — Service Mesh |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 225 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.6.19-a-service-mesh",
    "metadata": {
      "exercise_id": "5.6.19-a",
      "exercise_name": "service_mesh",
      "difficulty": 8,
      "xp_base": 225
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
