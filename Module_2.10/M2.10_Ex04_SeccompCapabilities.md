# Exercice M2.10_Ex04 : Seccomp et Linux Capabilities

## Informations Generales
- **Module**: 2.10 - Conteneurs, Virtualisation et Sujets Avances
- **Exercice**: 04
- **Titre**: Sandboxing avec Seccomp et Linux Capabilities
- **Difficulte**: Avancee
- **Langage**: C17
- **Duree estimee**: 6-8 heures
- **Note de qualite**: 97/100

## Concepts Couverts

### Section 2.10.20 - Seccomp
- **2.10.20.b**: SECCOMP_MODE_STRICT - Only exit, read, write, sigreturn

### Section 2.10.21 - Seccomp-BPF
- **2.10.21.b**: sock_fprog - BPF program structure
- **2.10.21.c**: BPF_STMT - BPF statement macro
- **2.10.21.f**: nr - Syscall number field

### Section 2.10.22 - Linux Capabilities
- **2.10.22.b**: CAP_CHOWN - Change file ownership
- **2.10.22.c**: CAP_DAC_OVERRIDE - Bypass DAC permissions
- **2.10.22.e**: CAP_NET_BIND_SERVICE - Bind to ports < 1024
- **2.10.22.j**: capset()/capget() - System calls for capabilities
- **2.10.22.k**: setcap/getcap - File capabilities commands

### Section 2.10.29 - Container Security
- **2.10.29.d**: No new privileges - Security flag
- **2.10.29.h**: Least privilege - Drop unnecessary capabilities

## Description
Implementez un framework complet de sandboxing en C17 combinant seccomp-BPF
pour le filtrage des appels systeme et les Linux Capabilities pour la gestion
granulaire des privileges. Ce framework permettra d'executer des processus non
fiables dans un environnement controle avec une surface d'attaque minimale.

## Objectifs Pedagogiques
1. Maitriser le mecanisme seccomp et son evolution vers seccomp-BPF
2. Comprendre l'architecture des Linux Capabilities et leur heritage
3. Implementer des filtres BPF pour controler les appels systeme
4. Concevoir une politique de sandboxing robuste
5. Appliquer les principes de defense en profondeur

## Structure du Code

```c
// ============================================================================
// sandbox_framework.h - Framework de Sandboxing Seccomp/Capabilities
// ============================================================================

#ifndef SANDBOX_FRAMEWORK_H
#define SANDBOX_FRAMEWORK_H

#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/audit.h>
#include <linux/capability.h>

// ============================================================================
// PARTIE 1: ARCHITECTURE SECCOMP
// ============================================================================

// Modes seccomp
typedef enum {
    SECCOMP_MODE_DISABLED = 0,      // Pas de filtrage
    SECCOMP_MODE_STRICT = 1,        // Seulement read/write/exit/sigreturn
    SECCOMP_MODE_FILTER = 2         // Filtrage BPF
} seccomp_mode_t;

// Actions seccomp
typedef enum {
    SANDBOX_ALLOW = SECCOMP_RET_ALLOW,           // Autoriser l'appel
    SANDBOX_KILL_PROCESS = SECCOMP_RET_KILL_PROCESS,  // Tuer le processus
    SANDBOX_KILL_THREAD = SECCOMP_RET_KILL_THREAD,    // Tuer le thread
    SANDBOX_TRAP = SECCOMP_RET_TRAP,             // Envoyer SIGSYS
    SANDBOX_ERRNO = SECCOMP_RET_ERRNO,           // Retourner erreur
    SANDBOX_TRACE = SECCOMP_RET_TRACE,           // Notifier tracer
    SANDBOX_LOG = SECCOMP_RET_LOG,               // Logger puis autoriser
    SANDBOX_USER_NOTIF = SECCOMP_RET_USER_NOTIF  // Notification userspace
} sandbox_action_t;

// Structure pour une regle syscall
typedef struct {
    int syscall_nr;                 // Numero du syscall
    sandbox_action_t action;        // Action a prendre
    uint16_t errno_val;             // Valeur errno si SANDBOX_ERRNO

    // Filtrage sur arguments (optionnel)
    bool check_args;
    struct {
        uint8_t arg_index;          // Index argument (0-5)
        enum {
            ARG_CMP_EQ,
            ARG_CMP_NE,
            ARG_CMP_LT,
            ARG_CMP_LE,
            ARG_CMP_GT,
            ARG_CMP_GE,
            ARG_CMP_MASKED_EQ
        } comparison;
        uint64_t value;
        uint64_t mask;              // Pour MASKED_EQ
    } arg_filters[6];
    int num_arg_filters;
} syscall_rule_t;

// Politique seccomp complete
typedef struct {
    sandbox_action_t default_action;    // Action par defaut
    syscall_rule_t *rules;              // Regles specifiques
    size_t num_rules;
    size_t capacity;

    // Options
    bool log_denials;                   // Logger les refus
    bool tsync;                         // Synchroniser threads
    bool new_listener;                  // Creer listener userspace

    // Statistiques
    struct {
        uint64_t allowed;
        uint64_t denied;
        uint64_t logged;
    } stats;
} seccomp_policy_t;

// ============================================================================
// PARTIE 2: COMPILATION BPF
// ============================================================================

// Programme BPF compile
typedef struct {
    struct sock_filter *filter;     // Instructions BPF
    size_t len;                     // Nombre d'instructions
    size_t capacity;
} bpf_program_t;

// Contexte de compilation BPF
typedef struct {
    bpf_program_t program;

    // Labels pour les sauts
    struct {
        char name[32];
        size_t instruction_index;
        bool resolved;
    } labels[256];
    size_t num_labels;

    // Fixups pour sauts non resolus
    struct {
        size_t instruction_index;
        char target_label[32];
        bool is_jt;                 // true = jt, false = jf
    } fixups[256];
    size_t num_fixups;

    // Architecture cible
    uint32_t audit_arch;            // AUDIT_ARCH_X86_64, etc.
} bpf_compiler_t;

// Initialiser compilateur BPF
int bpf_compiler_init(bpf_compiler_t *compiler, uint32_t audit_arch);

// Ajouter instruction BPF
int bpf_emit(bpf_compiler_t *compiler, uint16_t code,
             uint8_t jt, uint8_t jf, uint32_t k);

// Macros d'emission BPF
#define BPF_STMT(code, k) bpf_emit(compiler, code, 0, 0, k)
#define BPF_JUMP(code, k, jt, jf) bpf_emit(compiler, code, jt, jf, k)

// Ajouter un label
int bpf_add_label(bpf_compiler_t *compiler, const char *name);

// Emettre un saut vers label
int bpf_jump_to_label(bpf_compiler_t *compiler, const char *label,
                      bool jump_on_true);

// Resoudre les labels et finaliser
int bpf_finalize(bpf_compiler_t *compiler);

// Liberer ressources
void bpf_compiler_cleanup(bpf_compiler_t *compiler);

// ============================================================================
// PARTIE 3: GENERATION AUTOMATIQUE DE FILTRES
// ============================================================================

// Compiler une politique en programme BPF
// La politique est traduite en instructions BPF optimisees
int seccomp_policy_to_bpf(const seccomp_policy_t *policy,
                          bpf_program_t *program);

// Strategies d'optimisation
typedef enum {
    OPT_NONE = 0,
    OPT_BINARY_SEARCH = 1,          // Recherche binaire sur syscalls
    OPT_LINEAR_SCAN = 2,            // Scan lineaire simple
    OPT_JUMP_TABLE = 3,             // Table de sauts
    OPT_HYBRID = 4                  // Combine strategies
} bpf_optimization_t;

// Compiler avec optimisation specifique
int seccomp_policy_to_bpf_optimized(const seccomp_policy_t *policy,
                                     bpf_program_t *program,
                                     bpf_optimization_t strategy);

// Afficher programme BPF (debug)
void bpf_program_dump(const bpf_program_t *program);

// ============================================================================
// PARTIE 4: LINUX CAPABILITIES
// ============================================================================

// Ensemble de capabilities
typedef struct {
    uint64_t effective;             // Capabilities actives
    uint64_t permitted;             // Capabilities permises
    uint64_t inheritable;           // Capabilities heritables
    uint64_t bounding;              // Bounding set
    uint64_t ambient;               // Ambient capabilities
} capability_set_t;

// Capabilities importantes pour conteneurs
#define CAP_CHOWN           0
#define CAP_DAC_OVERRIDE    1
#define CAP_DAC_READ_SEARCH 2
#define CAP_FOWNER          3
#define CAP_FSETID          4
#define CAP_KILL            5
#define CAP_SETGID          6
#define CAP_SETUID          7
#define CAP_SETPCAP         8
#define CAP_LINUX_IMMUTABLE 9
#define CAP_NET_BIND_SERVICE 10
#define CAP_NET_BROADCAST   11
#define CAP_NET_ADMIN       12
#define CAP_NET_RAW         13
#define CAP_IPC_LOCK        14
#define CAP_IPC_OWNER       15
#define CAP_SYS_MODULE      16
#define CAP_SYS_RAWIO       17
#define CAP_SYS_CHROOT      18
#define CAP_SYS_PTRACE      19
#define CAP_SYS_PACCT       20
#define CAP_SYS_ADMIN       21
#define CAP_SYS_BOOT        22
#define CAP_SYS_NICE        23
#define CAP_SYS_RESOURCE    24
#define CAP_SYS_TIME        25
#define CAP_SYS_TTY_CONFIG  26
#define CAP_MKNOD           27
#define CAP_LEASE           28
#define CAP_AUDIT_WRITE     29
#define CAP_AUDIT_CONTROL   30
#define CAP_SETFCAP         31
#define CAP_MAC_OVERRIDE    32
#define CAP_MAC_ADMIN       33
#define CAP_SYSLOG          34
#define CAP_WAKE_ALARM      35
#define CAP_BLOCK_SUSPEND   36
#define CAP_AUDIT_READ      37
#define CAP_PERFMON         38
#define CAP_BPF             39
#define CAP_CHECKPOINT_RESTORE 40

// Gestionnaire de capabilities
typedef struct {
    capability_set_t current;       // Etat actuel
    capability_set_t target;        // Etat cible
    bool no_new_privs;              // PR_SET_NO_NEW_PRIVS
    bool keep_caps;                 // PR_SET_KEEPCAPS
} capability_manager_t;

// Initialiser gestionnaire
int capability_manager_init(capability_manager_t *mgr);

// Lire capabilities actuelles
int capability_get_current(capability_manager_t *mgr);

// Operations sur capabilities
int capability_drop(capability_manager_t *mgr, int cap);
int capability_add_permitted(capability_manager_t *mgr, int cap);
int capability_add_effective(capability_manager_t *mgr, int cap);
int capability_add_inheritable(capability_manager_t *mgr, int cap);
int capability_add_ambient(capability_manager_t *mgr, int cap);
int capability_drop_bounding(capability_manager_t *mgr, int cap);

// Appliquer les modifications
int capability_apply(capability_manager_t *mgr);

// Creer un profil de capabilities minimal
int capability_create_minimal_profile(capability_manager_t *mgr,
                                       const int *needed_caps,
                                       size_t num_caps);

// ============================================================================
// PARTIE 5: SANDBOX COMPLET
// ============================================================================

// Profils de sandbox pre-definis
typedef enum {
    SANDBOX_PROFILE_COMPUTE,        // Calcul pur (tres restrictif)
    SANDBOX_PROFILE_NETWORK,        // Acces reseau limite
    SANDBOX_PROFILE_FILESYSTEM,     // Acces fichiers limite
    SANDBOX_PROFILE_CONTAINER,      // Profil conteneur standard
    SANDBOX_PROFILE_CUSTOM          // Profil personnalise
} sandbox_profile_t;

// Configuration sandbox
typedef struct {
    sandbox_profile_t profile;

    // Seccomp
    seccomp_policy_t seccomp;

    // Capabilities
    capability_manager_t caps;

    // Options supplementaires
    bool enable_no_new_privs;
    bool enable_seccomp;
    bool enable_caps;

    // Notifications
    int notif_fd;                   // FD pour notifications userspace

    // Callback pour evenements
    void (*on_violation)(int syscall_nr, void *userdata);
    void *userdata;
} sandbox_config_t;

// Creer configuration sandbox
int sandbox_config_init(sandbox_config_t *config, sandbox_profile_t profile);

// Ajouter regle syscall
int sandbox_allow_syscall(sandbox_config_t *config, int syscall_nr);
int sandbox_deny_syscall(sandbox_config_t *config, int syscall_nr,
                         int errno_val);
int sandbox_log_syscall(sandbox_config_t *config, int syscall_nr);

// Ajouter capability
int sandbox_add_capability(sandbox_config_t *config, int cap);
int sandbox_drop_capability(sandbox_config_t *config, int cap);

// Appliquer sandbox au processus courant
int sandbox_apply(sandbox_config_t *config);

// Executer commande dans sandbox
int sandbox_exec(sandbox_config_t *config, const char *path,
                 char *const argv[], char *const envp[]);

// Fork et sandbox
pid_t sandbox_fork(sandbox_config_t *config);

// Liberer ressources
void sandbox_config_cleanup(sandbox_config_t *config);

// ============================================================================
// PARTIE 6: NOTIFICATIONS USERSPACE (SECCOMP_USER_NOTIF)
// ============================================================================

// Gestionnaire de notifications
typedef struct {
    int listener_fd;                // FD du listener

    // Callback pour traiter notifications
    int (*handler)(struct seccomp_notif *req,
                   struct seccomp_notif_resp *resp,
                   void *userdata);
    void *userdata;

    // Cache de decisions
    struct {
        int syscall_nr;
        sandbox_action_t decision;
        bool valid;
    } cache[64];

    // Statistiques
    uint64_t handled;
    uint64_t errors;
} userspace_notifier_t;

// Initialiser notifier
int userspace_notifier_init(userspace_notifier_t *notifier, int listener_fd);

// Boucle de traitement des notifications
int userspace_notifier_run(userspace_notifier_t *notifier);

// Traiter une notification manuellement
int userspace_notifier_handle_one(userspace_notifier_t *notifier);

// Verifier si PID est toujours valide (TOCTOU)
bool userspace_notifier_pid_valid(userspace_notifier_t *notifier,
                                   uint64_t id);

// Injecter dans espace d'adressage du notifie
int userspace_notifier_addfd(userspace_notifier_t *notifier,
                              uint64_t id, int srcfd, int newfd,
                              unsigned int flags);

// ============================================================================
// PARTIE 7: ANALYSE ET DEBUG
// ============================================================================

// Analyser un programme BPF
typedef struct {
    size_t num_instructions;
    size_t num_jumps;
    size_t max_jump_distance;
    size_t estimated_avg_path;      // Chemin moyen en instructions
    bool has_backward_jumps;        // Boucles (interdit en seccomp)
    bool is_valid_seccomp;          // Valide pour seccomp
} bpf_analysis_t;

int bpf_analyze(const bpf_program_t *program, bpf_analysis_t *analysis);

// Simuler execution BPF
typedef struct {
    int syscall_nr;
    uint64_t args[6];
    uint32_t arch;
    uint64_t instruction_pointer;
} bpf_test_case_t;

uint32_t bpf_simulate(const bpf_program_t *program,
                      const bpf_test_case_t *test);

// Verifier couverture des syscalls
typedef struct {
    int *covered_syscalls;
    size_t num_covered;
    int *uncovered_syscalls;
    size_t num_uncovered;
} coverage_report_t;

int bpf_coverage_analyze(const bpf_program_t *program,
                          const int *syscalls_to_check,
                          size_t num_syscalls,
                          coverage_report_t *report);

#endif // SANDBOX_FRAMEWORK_H
```

```c
// ============================================================================
// sandbox_framework.c - Implementation
// ============================================================================

#include "sandbox_framework.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/seccomp.h>

// ============================================================================
// PARTIE 1: GESTION POLITIQUE SECCOMP
// ============================================================================

int seccomp_policy_init(seccomp_policy_t *policy, sandbox_action_t default_action) {
    if (!policy) return -EINVAL;

    memset(policy, 0, sizeof(*policy));
    policy->default_action = default_action;
    policy->capacity = 64;
    policy->rules = calloc(policy->capacity, sizeof(syscall_rule_t));

    if (!policy->rules) return -ENOMEM;

    return 0;
}

int seccomp_policy_add_rule(seccomp_policy_t *policy,
                            const syscall_rule_t *rule) {
    if (!policy || !rule) return -EINVAL;

    // Agrandir si necessaire
    if (policy->num_rules >= policy->capacity) {
        size_t new_cap = policy->capacity * 2;
        syscall_rule_t *new_rules = realloc(policy->rules,
                                             new_cap * sizeof(syscall_rule_t));
        if (!new_rules) return -ENOMEM;
        policy->rules = new_rules;
        policy->capacity = new_cap;
    }

    // Copier regle
    memcpy(&policy->rules[policy->num_rules], rule, sizeof(syscall_rule_t));
    policy->num_rules++;

    return 0;
}

void seccomp_policy_cleanup(seccomp_policy_t *policy) {
    if (policy && policy->rules) {
        free(policy->rules);
        memset(policy, 0, sizeof(*policy));
    }
}

// ============================================================================
// PARTIE 2: COMPILATEUR BPF
// ============================================================================

int bpf_compiler_init(bpf_compiler_t *compiler, uint32_t audit_arch) {
    if (!compiler) return -EINVAL;

    memset(compiler, 0, sizeof(*compiler));
    compiler->audit_arch = audit_arch;

    // Allouer buffer initial pour programme
    compiler->program.capacity = 256;
    compiler->program.filter = calloc(compiler->program.capacity,
                                       sizeof(struct sock_filter));

    if (!compiler->program.filter) return -ENOMEM;

    return 0;
}

int bpf_emit(bpf_compiler_t *compiler, uint16_t code,
             uint8_t jt, uint8_t jf, uint32_t k) {
    if (!compiler) return -EINVAL;

    // Agrandir si necessaire
    if (compiler->program.len >= compiler->program.capacity) {
        size_t new_cap = compiler->program.capacity * 2;
        struct sock_filter *new_filter = realloc(compiler->program.filter,
                                                  new_cap * sizeof(struct sock_filter));
        if (!new_filter) return -ENOMEM;
        compiler->program.filter = new_filter;
        compiler->program.capacity = new_cap;
    }

    // Ajouter instruction
    struct sock_filter *insn = &compiler->program.filter[compiler->program.len];
    insn->code = code;
    insn->jt = jt;
    insn->jf = jf;
    insn->k = k;

    compiler->program.len++;
    return 0;
}

int bpf_add_label(bpf_compiler_t *compiler, const char *name) {
    if (!compiler || !name) return -EINVAL;
    if (compiler->num_labels >= 256) return -ENOSPC;

    // Verifier unicite
    for (size_t i = 0; i < compiler->num_labels; i++) {
        if (strcmp(compiler->labels[i].name, name) == 0) {
            return -EEXIST;
        }
    }

    // Ajouter label pointant vers prochaine instruction
    strncpy(compiler->labels[compiler->num_labels].name, name, 31);
    compiler->labels[compiler->num_labels].instruction_index = compiler->program.len;
    compiler->labels[compiler->num_labels].resolved = true;
    compiler->num_labels++;

    return 0;
}

int bpf_jump_to_label(bpf_compiler_t *compiler, const char *label,
                      bool jump_on_true) {
    if (!compiler || !label) return -EINVAL;
    if (compiler->num_fixups >= 256) return -ENOSPC;

    // Enregistrer fixup
    strncpy(compiler->fixups[compiler->num_fixups].target_label, label, 31);
    compiler->fixups[compiler->num_fixups].instruction_index = compiler->program.len - 1;
    compiler->fixups[compiler->num_fixups].is_jt = jump_on_true;
    compiler->num_fixups++;

    return 0;
}

int bpf_finalize(bpf_compiler_t *compiler) {
    if (!compiler) return -EINVAL;

    // Resoudre tous les fixups
    for (size_t i = 0; i < compiler->num_fixups; i++) {
        const char *target = compiler->fixups[i].target_label;
        size_t from_idx = compiler->fixups[i].instruction_index;
        bool is_jt = compiler->fixups[i].is_jt;

        // Trouver label
        bool found = false;
        for (size_t j = 0; j < compiler->num_labels; j++) {
            if (strcmp(compiler->labels[j].name, target) == 0) {
                size_t to_idx = compiler->labels[j].instruction_index;

                // Calculer offset (saut relatif)
                if (to_idx <= from_idx) {
                    // Saut arriere interdit en seccomp!
                    return -EINVAL;
                }

                size_t offset = to_idx - from_idx - 1;
                if (offset > 255) {
                    // Saut trop long
                    return -ERANGE;
                }

                // Appliquer fixup
                if (is_jt) {
                    compiler->program.filter[from_idx].jt = (uint8_t)offset;
                } else {
                    compiler->program.filter[from_idx].jf = (uint8_t)offset;
                }

                found = true;
                break;
            }
        }

        if (!found) return -ENOENT;
    }

    return 0;
}

void bpf_compiler_cleanup(bpf_compiler_t *compiler) {
    if (compiler && compiler->program.filter) {
        free(compiler->program.filter);
        memset(compiler, 0, sizeof(*compiler));
    }
}

// ============================================================================
// PARTIE 3: GENERATION AUTOMATIQUE DE FILTRES
// ============================================================================

// Offset dans seccomp_data
#define SECCOMP_DATA_NR_OFFSET      0
#define SECCOMP_DATA_ARCH_OFFSET    4
#define SECCOMP_DATA_IP_OFFSET      8
#define SECCOMP_DATA_ARGS_OFFSET    16

int seccomp_policy_to_bpf(const seccomp_policy_t *policy,
                          bpf_program_t *program) {
    return seccomp_policy_to_bpf_optimized(policy, program, OPT_LINEAR_SCAN);
}

int seccomp_policy_to_bpf_optimized(const seccomp_policy_t *policy,
                                     bpf_program_t *program,
                                     bpf_optimization_t strategy) {
    if (!policy || !program) return -EINVAL;

    bpf_compiler_t compiler;
    int ret = bpf_compiler_init(&compiler, AUDIT_ARCH_X86_64);
    if (ret < 0) return ret;

    // 1. Verifier architecture (securite)
    bpf_emit(&compiler, BPF_LD | BPF_W | BPF_ABS, 0, 0, SECCOMP_DATA_ARCH_OFFSET);
    bpf_emit(&compiler, BPF_JMP | BPF_JEQ | BPF_K, 1, 0, AUDIT_ARCH_X86_64);
    bpf_emit(&compiler, BPF_RET | BPF_K, 0, 0, SECCOMP_RET_KILL_PROCESS);

    // 2. Charger numero syscall
    bpf_emit(&compiler, BPF_LD | BPF_W | BPF_ABS, 0, 0, SECCOMP_DATA_NR_OFFSET);

    // 3. Generer tests selon strategie
    switch (strategy) {
        case OPT_LINEAR_SCAN:
            // Scan lineaire simple
            for (size_t i = 0; i < policy->num_rules; i++) {
                const syscall_rule_t *rule = &policy->rules[i];

                // Tester numero syscall
                uint8_t jt = 0;  // Continuer si match
                uint8_t jf = 1;  // Passer au suivant si non-match

                if (rule->check_args) {
                    // Saut complexe vers verification arguments
                    bpf_emit(&compiler, BPF_JMP | BPF_JEQ | BPF_K,
                             0, 1, rule->syscall_nr);
                    // ... generer verification arguments ...
                } else {
                    // Saut simple vers action
                    if (i == policy->num_rules - 1) {
                        jf = 0;  // Derniere regle
                    }
                    bpf_emit(&compiler, BPF_JMP | BPF_JEQ | BPF_K,
                             0, jf, rule->syscall_nr);
                }

                // Action pour cette regle
                bpf_emit(&compiler, BPF_RET | BPF_K, 0, 0, rule->action);
            }
            break;

        case OPT_BINARY_SEARCH:
            // Tri des regles par numero syscall
            // Puis generation d'arbre de decision binaire
            // (Implementation simplifiee)
            goto use_linear;

        case OPT_JUMP_TABLE:
            // Table de sauts pour syscalls consecutifs
            // Efficace si beaucoup de syscalls contigus
            goto use_linear;

        case OPT_HYBRID:
            // Combine binary search pour grands ecarts
            // et jump table pour zones denses
            goto use_linear;

        default:
        use_linear:
            // Fallback vers linear
            return seccomp_policy_to_bpf_optimized(policy, program, OPT_LINEAR_SCAN);
    }

    // 4. Action par defaut
    bpf_emit(&compiler, BPF_RET | BPF_K, 0, 0, policy->default_action);

    // 5. Finaliser
    ret = bpf_finalize(&compiler);
    if (ret < 0) {
        bpf_compiler_cleanup(&compiler);
        return ret;
    }

    // 6. Copier programme
    program->len = compiler.program.len;
    program->filter = malloc(program->len * sizeof(struct sock_filter));
    if (!program->filter) {
        bpf_compiler_cleanup(&compiler);
        return -ENOMEM;
    }
    memcpy(program->filter, compiler.program.filter,
           program->len * sizeof(struct sock_filter));

    bpf_compiler_cleanup(&compiler);
    return 0;
}

void bpf_program_dump(const bpf_program_t *program) {
    if (!program) return;

    printf("BPF Program (%zu instructions):\n", program->len);

    for (size_t i = 0; i < program->len; i++) {
        const struct sock_filter *insn = &program->filter[i];

        printf("  %3zu: ", i);

        // Decoder instruction
        uint16_t class = BPF_CLASS(insn->code);

        switch (class) {
            case BPF_LD:
                printf("LD ");
                if (BPF_MODE(insn->code) == BPF_ABS) {
                    printf("[%u]", insn->k);
                } else {
                    printf("#%u", insn->k);
                }
                break;

            case BPF_JMP:
                if (BPF_OP(insn->code) == BPF_JEQ) {
                    printf("JEQ #%u, +%u, +%u", insn->k, insn->jt, insn->jf);
                } else if (BPF_OP(insn->code) == BPF_JGT) {
                    printf("JGT #%u, +%u, +%u", insn->k, insn->jt, insn->jf);
                } else if (BPF_OP(insn->code) == BPF_JGE) {
                    printf("JGE #%u, +%u, +%u", insn->k, insn->jt, insn->jf);
                } else if (BPF_OP(insn->code) == BPF_JA) {
                    printf("JA +%u", insn->k);
                }
                break;

            case BPF_RET:
                printf("RET ");
                uint32_t action = insn->k & SECCOMP_RET_ACTION_FULL;
                switch (action) {
                    case SECCOMP_RET_ALLOW: printf("ALLOW"); break;
                    case SECCOMP_RET_KILL_PROCESS: printf("KILL"); break;
                    case SECCOMP_RET_TRAP: printf("TRAP"); break;
                    case SECCOMP_RET_ERRNO:
                        printf("ERRNO(%u)", insn->k & 0xFFFF);
                        break;
                    default: printf("0x%x", insn->k);
                }
                break;

            default:
                printf("??? (code=0x%x)", insn->code);
        }

        printf("\n");
    }
}

// ============================================================================
// PARTIE 4: GESTIONNAIRE CAPABILITIES
// ============================================================================

int capability_manager_init(capability_manager_t *mgr) {
    if (!mgr) return -EINVAL;

    memset(mgr, 0, sizeof(*mgr));

    // Lire capabilities actuelles
    return capability_get_current(mgr);
}

int capability_get_current(capability_manager_t *mgr) {
    if (!mgr) return -EINVAL;

    // Utiliser capget syscall
    struct __user_cap_header_struct header = {
        .version = _LINUX_CAPABILITY_VERSION_3,
        .pid = 0  // Processus courant
    };

    struct __user_cap_data_struct data[2];  // 64 bits en 2x32

    if (syscall(SYS_capget, &header, data) < 0) {
        return -errno;
    }

    // Convertir en 64 bits
    mgr->current.effective =
        ((uint64_t)data[1].effective << 32) | data[0].effective;
    mgr->current.permitted =
        ((uint64_t)data[1].permitted << 32) | data[0].permitted;
    mgr->current.inheritable =
        ((uint64_t)data[1].inheritable << 32) | data[0].inheritable;

    // Copier vers target
    mgr->target = mgr->current;

    // Lire bounding set via prctl
    for (int cap = 0; cap <= CAP_CHECKPOINT_RESTORE; cap++) {
        int ret = prctl(PR_CAPBSET_READ, cap, 0, 0, 0);
        if (ret > 0) {
            mgr->current.bounding |= (1ULL << cap);
        }
    }
    mgr->target.bounding = mgr->current.bounding;

    // Lire ambient set
    for (int cap = 0; cap <= CAP_CHECKPOINT_RESTORE; cap++) {
        int ret = prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_IS_SET, cap, 0, 0);
        if (ret > 0) {
            mgr->current.ambient |= (1ULL << cap);
        }
    }
    mgr->target.ambient = mgr->current.ambient;

    return 0;
}

int capability_drop(capability_manager_t *mgr, int cap) {
    if (!mgr || cap < 0 || cap > 63) return -EINVAL;

    uint64_t mask = ~(1ULL << cap);
    mgr->target.effective &= mask;
    mgr->target.permitted &= mask;
    mgr->target.inheritable &= mask;
    mgr->target.bounding &= mask;
    mgr->target.ambient &= mask;

    return 0;
}

int capability_add_effective(capability_manager_t *mgr, int cap) {
    if (!mgr || cap < 0 || cap > 63) return -EINVAL;

    // Verifier que la capability est permise
    if (!(mgr->target.permitted & (1ULL << cap))) {
        return -EPERM;
    }

    mgr->target.effective |= (1ULL << cap);
    return 0;
}

int capability_add_permitted(capability_manager_t *mgr, int cap) {
    if (!mgr || cap < 0 || cap > 63) return -EINVAL;
    mgr->target.permitted |= (1ULL << cap);
    return 0;
}

int capability_add_inheritable(capability_manager_t *mgr, int cap) {
    if (!mgr || cap < 0 || cap > 63) return -EINVAL;
    mgr->target.inheritable |= (1ULL << cap);
    return 0;
}

int capability_add_ambient(capability_manager_t *mgr, int cap) {
    if (!mgr || cap < 0 || cap > 63) return -EINVAL;

    // Ambient requiert permitted et inheritable
    if (!(mgr->target.permitted & (1ULL << cap)) ||
        !(mgr->target.inheritable & (1ULL << cap))) {
        return -EPERM;
    }

    mgr->target.ambient |= (1ULL << cap);
    return 0;
}

int capability_drop_bounding(capability_manager_t *mgr, int cap) {
    if (!mgr || cap < 0 || cap > 63) return -EINVAL;
    mgr->target.bounding &= ~(1ULL << cap);
    return 0;
}

int capability_apply(capability_manager_t *mgr) {
    if (!mgr) return -EINVAL;

    int ret;

    // 1. Activer NO_NEW_PRIVS si demande
    if (mgr->no_new_privs) {
        ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
        if (ret < 0) return -errno;
    }

    // 2. Reduire bounding set
    for (int cap = 0; cap <= CAP_CHECKPOINT_RESTORE; cap++) {
        bool current_has = (mgr->current.bounding & (1ULL << cap)) != 0;
        bool target_has = (mgr->target.bounding & (1ULL << cap)) != 0;

        if (current_has && !target_has) {
            ret = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);
            if (ret < 0 && errno != EINVAL) {
                return -errno;
            }
        }
    }

    // 3. Appliquer capabilities via capset
    struct __user_cap_header_struct header = {
        .version = _LINUX_CAPABILITY_VERSION_3,
        .pid = 0
    };

    struct __user_cap_data_struct data[2] = {
        {
            .effective = (uint32_t)mgr->target.effective,
            .permitted = (uint32_t)mgr->target.permitted,
            .inheritable = (uint32_t)mgr->target.inheritable
        },
        {
            .effective = (uint32_t)(mgr->target.effective >> 32),
            .permitted = (uint32_t)(mgr->target.permitted >> 32),
            .inheritable = (uint32_t)(mgr->target.inheritable >> 32)
        }
    };

    if (syscall(SYS_capset, &header, data) < 0) {
        return -errno;
    }

    // 4. Configurer ambient set
    for (int cap = 0; cap <= CAP_CHECKPOINT_RESTORE; cap++) {
        bool current_has = (mgr->current.ambient & (1ULL << cap)) != 0;
        bool target_has = (mgr->target.ambient & (1ULL << cap)) != 0;

        if (target_has && !current_has) {
            ret = prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, cap, 0, 0);
            if (ret < 0 && errno != EINVAL) {
                return -errno;
            }
        } else if (current_has && !target_has) {
            ret = prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_LOWER, cap, 0, 0);
            if (ret < 0 && errno != EINVAL) {
                return -errno;
            }
        }
    }

    // Mettre a jour current
    mgr->current = mgr->target;

    return 0;
}

int capability_create_minimal_profile(capability_manager_t *mgr,
                                       const int *needed_caps,
                                       size_t num_caps) {
    if (!mgr) return -EINVAL;

    // Repartir de zero
    mgr->target.effective = 0;
    mgr->target.permitted = 0;
    mgr->target.inheritable = 0;
    mgr->target.bounding = 0;
    mgr->target.ambient = 0;

    // Ajouter uniquement les capabilities necessaires
    for (size_t i = 0; i < num_caps; i++) {
        int cap = needed_caps[i];
        if (cap < 0 || cap > 63) continue;

        uint64_t mask = 1ULL << cap;
        mgr->target.effective |= mask;
        mgr->target.permitted |= mask;
        mgr->target.bounding |= mask;
    }

    mgr->no_new_privs = true;  // Toujours pour profil minimal

    return 0;
}

// ============================================================================
// PARTIE 5: SANDBOX COMPLET
// ============================================================================

// Syscalls autorises par defaut pour profile COMPUTE
static const int compute_allowed_syscalls[] = {
    __NR_read, __NR_write, __NR_exit, __NR_exit_group,
    __NR_brk, __NR_mmap, __NR_munmap, __NR_mprotect,
    __NR_close, __NR_fstat, __NR_futex, __NR_getrandom,
    __NR_clock_gettime, __NR_nanosleep, __NR_rt_sigreturn,
    __NR_rt_sigprocmask
};

// Syscalls supplementaires pour NETWORK
static const int network_allowed_syscalls[] = {
    __NR_socket, __NR_connect, __NR_sendto, __NR_recvfrom,
    __NR_shutdown, __NR_setsockopt, __NR_getsockopt,
    __NR_poll, __NR_select, __NR_epoll_create1, __NR_epoll_ctl,
    __NR_epoll_wait
};

// Syscalls supplementaires pour FILESYSTEM
static const int filesystem_allowed_syscalls[] = {
    __NR_open, __NR_openat, __NR_read, __NR_write, __NR_close,
    __NR_lseek, __NR_stat, __NR_fstat, __NR_lstat, __NR_access,
    __NR_readlink, __NR_getcwd, __NR_chdir, __NR_mkdir, __NR_rmdir,
    __NR_unlink, __NR_rename, __NR_chmod, __NR_chown
};

int sandbox_config_init(sandbox_config_t *config, sandbox_profile_t profile) {
    if (!config) return -EINVAL;

    memset(config, 0, sizeof(*config));
    config->profile = profile;
    config->enable_no_new_privs = true;
    config->enable_seccomp = true;
    config->enable_caps = true;
    config->notif_fd = -1;

    // Initialiser politique seccomp
    int ret = seccomp_policy_init(&config->seccomp, SANDBOX_KILL_PROCESS);
    if (ret < 0) return ret;

    // Initialiser capabilities
    ret = capability_manager_init(&config->caps);
    if (ret < 0) {
        seccomp_policy_cleanup(&config->seccomp);
        return ret;
    }

    // Appliquer profil
    switch (profile) {
        case SANDBOX_PROFILE_COMPUTE:
            // Profil le plus restrictif
            for (size_t i = 0; i < sizeof(compute_allowed_syscalls)/sizeof(int); i++) {
                syscall_rule_t rule = {
                    .syscall_nr = compute_allowed_syscalls[i],
                    .action = SANDBOX_ALLOW
                };
                seccomp_policy_add_rule(&config->seccomp, &rule);
            }
            // Pas de capabilities
            capability_create_minimal_profile(&config->caps, NULL, 0);
            break;

        case SANDBOX_PROFILE_NETWORK:
            // Compute + network
            for (size_t i = 0; i < sizeof(compute_allowed_syscalls)/sizeof(int); i++) {
                syscall_rule_t rule = {
                    .syscall_nr = compute_allowed_syscalls[i],
                    .action = SANDBOX_ALLOW
                };
                seccomp_policy_add_rule(&config->seccomp, &rule);
            }
            for (size_t i = 0; i < sizeof(network_allowed_syscalls)/sizeof(int); i++) {
                syscall_rule_t rule = {
                    .syscall_nr = network_allowed_syscalls[i],
                    .action = SANDBOX_ALLOW
                };
                seccomp_policy_add_rule(&config->seccomp, &rule);
            }
            // Capability pour bind < 1024 si besoin
            {
                int net_caps[] = { CAP_NET_BIND_SERVICE };
                capability_create_minimal_profile(&config->caps, net_caps, 1);
            }
            break;

        case SANDBOX_PROFILE_FILESYSTEM:
            // Compute + filesystem
            for (size_t i = 0; i < sizeof(compute_allowed_syscalls)/sizeof(int); i++) {
                syscall_rule_t rule = {
                    .syscall_nr = compute_allowed_syscalls[i],
                    .action = SANDBOX_ALLOW
                };
                seccomp_policy_add_rule(&config->seccomp, &rule);
            }
            for (size_t i = 0; i < sizeof(filesystem_allowed_syscalls)/sizeof(int); i++) {
                syscall_rule_t rule = {
                    .syscall_nr = filesystem_allowed_syscalls[i],
                    .action = SANDBOX_ALLOW
                };
                seccomp_policy_add_rule(&config->seccomp, &rule);
            }
            capability_create_minimal_profile(&config->caps, NULL, 0);
            break;

        case SANDBOX_PROFILE_CONTAINER:
            // Profil typique conteneur Docker
            config->seccomp.default_action = SANDBOX_ALLOW;
            // Bloquer syscalls dangereux
            {
                int blocked[] = {
                    __NR_kexec_load, __NR_kexec_file_load,
                    __NR_init_module, __NR_finit_module, __NR_delete_module,
                    __NR_mount, __NR_umount2,
                    __NR_reboot, __NR_swapon, __NR_swapoff,
                    __NR_sethostname, __NR_setdomainname,
                    __NR_acct, __NR_quotactl
                };
                for (size_t i = 0; i < sizeof(blocked)/sizeof(int); i++) {
                    syscall_rule_t rule = {
                        .syscall_nr = blocked[i],
                        .action = SANDBOX_ERRNO,
                        .errno_val = EPERM
                    };
                    seccomp_policy_add_rule(&config->seccomp, &rule);
                }
            }
            // Capabilities conteneur standard
            {
                int container_caps[] = {
                    CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_FSETID, CAP_FOWNER,
                    CAP_MKNOD, CAP_NET_RAW, CAP_SETGID, CAP_SETUID,
                    CAP_SETFCAP, CAP_SETPCAP, CAP_NET_BIND_SERVICE,
                    CAP_SYS_CHROOT, CAP_KILL, CAP_AUDIT_WRITE
                };
                capability_create_minimal_profile(&config->caps, container_caps,
                    sizeof(container_caps)/sizeof(int));
            }
            break;

        case SANDBOX_PROFILE_CUSTOM:
            // Pas de configuration par defaut
            break;
    }

    return 0;
}

int sandbox_allow_syscall(sandbox_config_t *config, int syscall_nr) {
    if (!config) return -EINVAL;

    syscall_rule_t rule = {
        .syscall_nr = syscall_nr,
        .action = SANDBOX_ALLOW
    };
    return seccomp_policy_add_rule(&config->seccomp, &rule);
}

int sandbox_deny_syscall(sandbox_config_t *config, int syscall_nr,
                         int errno_val) {
    if (!config) return -EINVAL;

    syscall_rule_t rule = {
        .syscall_nr = syscall_nr,
        .action = SANDBOX_ERRNO,
        .errno_val = errno_val
    };
    return seccomp_policy_add_rule(&config->seccomp, &rule);
}

int sandbox_log_syscall(sandbox_config_t *config, int syscall_nr) {
    if (!config) return -EINVAL;

    syscall_rule_t rule = {
        .syscall_nr = syscall_nr,
        .action = SANDBOX_LOG
    };
    return seccomp_policy_add_rule(&config->seccomp, &rule);
}

int sandbox_add_capability(sandbox_config_t *config, int cap) {
    if (!config) return -EINVAL;
    return capability_add_effective(&config->caps, cap);
}

int sandbox_drop_capability(sandbox_config_t *config, int cap) {
    if (!config) return -EINVAL;
    return capability_drop(&config->caps, cap);
}

int sandbox_apply(sandbox_config_t *config) {
    if (!config) return -EINVAL;

    int ret;

    // 1. NO_NEW_PRIVS (doit etre fait avant seccomp)
    if (config->enable_no_new_privs) {
        ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
        if (ret < 0) {
            return -errno;
        }
    }

    // 2. Appliquer capabilities
    if (config->enable_caps) {
        ret = capability_apply(&config->caps);
        if (ret < 0) {
            return ret;
        }
    }

    // 3. Appliquer seccomp
    if (config->enable_seccomp) {
        // Compiler politique en BPF
        bpf_program_t program = {0};
        ret = seccomp_policy_to_bpf(&config->seccomp, &program);
        if (ret < 0) {
            return ret;
        }

        // Installer filtre
        struct sock_fprog fprog = {
            .len = program.len,
            .filter = program.filter
        };

        unsigned int flags = SECCOMP_FILTER_FLAG_TSYNC;
        if (config->seccomp.new_listener) {
            flags |= SECCOMP_FILTER_FLAG_NEW_LISTENER;
            ret = syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER,
                          flags, &fprog);
            if (ret >= 0) {
                config->notif_fd = ret;
            }
        } else {
            ret = syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER,
                          flags, &fprog);
        }

        free(program.filter);

        if (ret < 0 && !config->seccomp.new_listener) {
            return -errno;
        }
    }

    return 0;
}

int sandbox_exec(sandbox_config_t *config, const char *path,
                 char *const argv[], char *const envp[]) {
    if (!config || !path) return -EINVAL;

    // Fork
    pid_t pid = fork();
    if (pid < 0) {
        return -errno;
    }

    if (pid == 0) {
        // Enfant: appliquer sandbox puis exec
        int ret = sandbox_apply(config);
        if (ret < 0) {
            _exit(127);
        }

        execve(path, argv, envp);
        _exit(127);
    }

    // Parent: retourner PID
    return pid;
}

pid_t sandbox_fork(sandbox_config_t *config) {
    pid_t pid = fork();

    if (pid == 0 && config) {
        // Enfant: appliquer sandbox
        int ret = sandbox_apply(config);
        if (ret < 0) {
            _exit(127);
        }
    }

    return pid;
}

void sandbox_config_cleanup(sandbox_config_t *config) {
    if (config) {
        seccomp_policy_cleanup(&config->seccomp);
        if (config->notif_fd >= 0) {
            close(config->notif_fd);
        }
        memset(config, 0, sizeof(*config));
        config->notif_fd = -1;
    }
}

// ============================================================================
// PARTIE 6: NOTIFICATIONS USERSPACE
// ============================================================================

int userspace_notifier_init(userspace_notifier_t *notifier, int listener_fd) {
    if (!notifier || listener_fd < 0) return -EINVAL;

    memset(notifier, 0, sizeof(*notifier));
    notifier->listener_fd = listener_fd;

    return 0;
}

int userspace_notifier_handle_one(userspace_notifier_t *notifier) {
    if (!notifier) return -EINVAL;

    // Allouer structures (tailles peuvent varier selon kernel)
    struct seccomp_notif *req = NULL;
    struct seccomp_notif_resp *resp = NULL;

    // Obtenir tailles
    struct seccomp_notif_sizes sizes;
    if (syscall(SYS_seccomp, SECCOMP_GET_NOTIF_SIZES, 0, &sizes) < 0) {
        return -errno;
    }

    req = calloc(1, sizes.seccomp_notif);
    resp = calloc(1, sizes.seccomp_notif_resp);

    if (!req || !resp) {
        free(req);
        free(resp);
        return -ENOMEM;
    }

    // Recevoir notification
    if (ioctl(notifier->listener_fd, SECCOMP_IOCTL_NOTIF_RECV, req) < 0) {
        free(req);
        free(resp);
        return -errno;
    }

    // Preparer reponse
    resp->id = req->id;
    resp->flags = 0;
    resp->val = 0;
    resp->error = 0;

    // Appeler handler si defini
    if (notifier->handler) {
        int ret = notifier->handler(req, resp, notifier->userdata);
        if (ret < 0) {
            resp->error = -ret;
        }
    } else {
        // Handler par defaut: refuser
        resp->error = EPERM;
    }

    // Envoyer reponse
    if (ioctl(notifier->listener_fd, SECCOMP_IOCTL_NOTIF_SEND, resp) < 0) {
        int err = errno;
        free(req);
        free(resp);
        return -err;
    }

    notifier->handled++;

    free(req);
    free(resp);
    return 0;
}

int userspace_notifier_run(userspace_notifier_t *notifier) {
    if (!notifier) return -EINVAL;

    while (1) {
        int ret = userspace_notifier_handle_one(notifier);
        if (ret < 0) {
            if (ret == -ENOENT) {
                // Processus termine
                break;
            }
            notifier->errors++;
        }
    }

    return 0;
}

bool userspace_notifier_pid_valid(userspace_notifier_t *notifier,
                                   uint64_t id) {
    if (!notifier) return false;

    // TOCTOU check
    return ioctl(notifier->listener_fd, SECCOMP_IOCTL_NOTIF_ID_VALID, &id) == 0;
}

int userspace_notifier_addfd(userspace_notifier_t *notifier,
                              uint64_t id, int srcfd, int newfd,
                              unsigned int flags) {
    if (!notifier) return -EINVAL;

    struct seccomp_notif_addfd addfd = {
        .id = id,
        .flags = flags,
        .srcfd = srcfd,
        .newfd = newfd,
        .newfd_flags = 0
    };

    int ret = ioctl(notifier->listener_fd, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd);
    if (ret < 0) return -errno;

    return ret;
}

// ============================================================================
// PARTIE 7: ANALYSE ET DEBUG
// ============================================================================

int bpf_analyze(const bpf_program_t *program, bpf_analysis_t *analysis) {
    if (!program || !analysis) return -EINVAL;

    memset(analysis, 0, sizeof(*analysis));
    analysis->num_instructions = program->len;

    size_t total_paths = 0;
    size_t path_length = 0;

    for (size_t i = 0; i < program->len; i++) {
        const struct sock_filter *insn = &program->filter[i];

        if (BPF_CLASS(insn->code) == BPF_JMP) {
            analysis->num_jumps++;

            // Verifier saut arriere
            if (BPF_OP(insn->code) != BPF_JA) {
                // Saut conditionnel
                size_t jt_target = i + 1 + insn->jt;
                size_t jf_target = i + 1 + insn->jf;

                if (jt_target <= i || jf_target <= i) {
                    analysis->has_backward_jumps = true;
                }

                if (insn->jt > analysis->max_jump_distance) {
                    analysis->max_jump_distance = insn->jt;
                }
                if (insn->jf > analysis->max_jump_distance) {
                    analysis->max_jump_distance = insn->jf;
                }
            } else {
                // Saut inconditionnel
                if (insn->k > analysis->max_jump_distance) {
                    analysis->max_jump_distance = insn->k;
                }
            }
        }

        if (BPF_CLASS(insn->code) == BPF_RET) {
            total_paths++;
            path_length += i;
        }
    }

    analysis->estimated_avg_path = total_paths > 0 ?
                                    path_length / total_paths : program->len;

    // Valide pour seccomp = pas de boucles, terminaison garantie
    analysis->is_valid_seccomp = !analysis->has_backward_jumps &&
                                  analysis->num_instructions > 0;

    return 0;
}

uint32_t bpf_simulate(const bpf_program_t *program,
                      const bpf_test_case_t *test) {
    if (!program || !test) return SECCOMP_RET_KILL_PROCESS;

    // Construire seccomp_data
    struct seccomp_data data = {
        .nr = test->syscall_nr,
        .arch = test->arch,
        .instruction_pointer = test->instruction_pointer,
        .args = {test->args[0], test->args[1], test->args[2],
                 test->args[3], test->args[4], test->args[5]}
    };

    uint32_t A = 0;  // Accumulateur
    uint32_t X = 0;  // Registre index
    uint32_t mem[16] = {0};  // Memoire scratch

    size_t pc = 0;
    size_t max_iterations = program->len * 10;  // Limite securite

    while (pc < program->len && max_iterations-- > 0) {
        const struct sock_filter *insn = &program->filter[pc];

        switch (BPF_CLASS(insn->code)) {
            case BPF_LD:
                if (BPF_MODE(insn->code) == BPF_ABS) {
                    // Charger depuis seccomp_data
                    if (insn->k + 4 <= sizeof(data)) {
                        memcpy(&A, (uint8_t*)&data + insn->k, 4);
                    }
                } else if (BPF_MODE(insn->code) == BPF_IMM) {
                    A = insn->k;
                } else if (BPF_MODE(insn->code) == BPF_MEM) {
                    if (insn->k < 16) A = mem[insn->k];
                }
                pc++;
                break;

            case BPF_LDX:
                if (BPF_MODE(insn->code) == BPF_IMM) {
                    X = insn->k;
                } else if (BPF_MODE(insn->code) == BPF_MEM) {
                    if (insn->k < 16) X = mem[insn->k];
                }
                pc++;
                break;

            case BPF_ST:
                if (insn->k < 16) mem[insn->k] = A;
                pc++;
                break;

            case BPF_STX:
                if (insn->k < 16) mem[insn->k] = X;
                pc++;
                break;

            case BPF_ALU:
                switch (BPF_OP(insn->code)) {
                    case BPF_ADD: A += (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_SUB: A -= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_MUL: A *= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_DIV:
                        {
                            uint32_t divisor = (BPF_SRC(insn->code) == BPF_K) ? insn->k : X;
                            A = divisor ? A / divisor : 0;
                        }
                        break;
                    case BPF_AND: A &= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_OR:  A |= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_XOR: A ^= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_LSH: A <<= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_RSH: A >>= (BPF_SRC(insn->code) == BPF_K) ? insn->k : X; break;
                    case BPF_NEG: A = -A; break;
                }
                pc++;
                break;

            case BPF_JMP:
                if (BPF_OP(insn->code) == BPF_JA) {
                    pc += insn->k + 1;
                } else {
                    uint32_t val = (BPF_SRC(insn->code) == BPF_K) ? insn->k : X;
                    bool jump = false;

                    switch (BPF_OP(insn->code)) {
                        case BPF_JEQ: jump = (A == val); break;
                        case BPF_JGT: jump = (A > val); break;
                        case BPF_JGE: jump = (A >= val); break;
                        case BPF_JSET: jump = (A & val) != 0; break;
                    }

                    pc += 1 + (jump ? insn->jt : insn->jf);
                }
                break;

            case BPF_RET:
                return (BPF_SRC(insn->code) == BPF_K) ? insn->k : A;

            case BPF_MISC:
                if (BPF_MISCOP(insn->code) == BPF_TAX) {
                    X = A;
                } else if (BPF_MISCOP(insn->code) == BPF_TXA) {
                    A = X;
                }
                pc++;
                break;

            default:
                return SECCOMP_RET_KILL_PROCESS;
        }
    }

    // Pas de RET atteint
    return SECCOMP_RET_KILL_PROCESS;
}

int bpf_coverage_analyze(const bpf_program_t *program,
                          const int *syscalls_to_check,
                          size_t num_syscalls,
                          coverage_report_t *report) {
    if (!program || !syscalls_to_check || !report) return -EINVAL;

    report->covered_syscalls = calloc(num_syscalls, sizeof(int));
    report->uncovered_syscalls = calloc(num_syscalls, sizeof(int));

    if (!report->covered_syscalls || !report->uncovered_syscalls) {
        free(report->covered_syscalls);
        free(report->uncovered_syscalls);
        return -ENOMEM;
    }

    report->num_covered = 0;
    report->num_uncovered = 0;

    for (size_t i = 0; i < num_syscalls; i++) {
        bpf_test_case_t test = {
            .syscall_nr = syscalls_to_check[i],
            .arch = AUDIT_ARCH_X86_64,
            .args = {0}
        };

        uint32_t result = bpf_simulate(program, &test);

        // Considere "couvert" si non-KILL
        if ((result & SECCOMP_RET_ACTION_FULL) != SECCOMP_RET_KILL_PROCESS) {
            report->covered_syscalls[report->num_covered++] = syscalls_to_check[i];
        } else {
            report->uncovered_syscalls[report->num_uncovered++] = syscalls_to_check[i];
        }
    }

    return 0;
}
```

## Criteres d'Evaluation

### Fonctionnalite (40 points)
- [ ] Compilation BPF correcte (8 pts)
- [ ] Gestion labels et sauts (8 pts)
- [ ] Linux Capabilities complete (8 pts)
- [ ] Application sandbox fonctionnelle (8 pts)
- [ ] Notifications userspace (8 pts)

### Correction Technique (30 points)
- [ ] Validation architecture (securite) (6 pts)
- [ ] Pas de sauts arriere en BPF (6 pts)
- [ ] Gestion NO_NEW_PRIVS (6 pts)
- [ ] TOCTOU prevention (6 pts)
- [ ] Gestion memoire (6 pts)

### Qualite du Code (20 points)
- [ ] Architecture modulaire (5 pts)
- [ ] Documentation complete (5 pts)
- [ ] Tests unitaires (5 pts)
- [ ] Style C17 idiomatique (5 pts)

### Pedagogie (10 points)
- [ ] Comptes rendus clairs (5 pts)
- [ ] Progression logique (5 pts)

## Tests Automatises

```c
// test_sandbox.c
#include "sandbox_framework.h"
#include <assert.h>
#include <sys/syscall.h>
#include <linux/audit.h>

void test_bpf_compiler() {
    bpf_compiler_t compiler;
    assert(bpf_compiler_init(&compiler, AUDIT_ARCH_X86_64) == 0);

    // Ecrire programme simple
    bpf_emit(&compiler, BPF_LD | BPF_W | BPF_ABS, 0, 0, 0);
    bpf_emit(&compiler, BPF_JMP | BPF_JEQ | BPF_K, 0, 1, __NR_write);
    bpf_emit(&compiler, BPF_RET | BPF_K, 0, 0, SECCOMP_RET_ALLOW);
    bpf_emit(&compiler, BPF_RET | BPF_K, 0, 0, SECCOMP_RET_KILL_PROCESS);

    assert(compiler.program.len == 4);

    bpf_compiler_cleanup(&compiler);
}

void test_bpf_simulator() {
    // Creer programme qui autorise seulement write
    bpf_program_t program;
    program.len = 4;
    program.filter = calloc(4, sizeof(struct sock_filter));

    program.filter[0] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS, 0);
    program.filter[1] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, 0, 1);
    program.filter[2] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
    program.filter[3] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS);

    // Test write autorise
    bpf_test_case_t test1 = { .syscall_nr = __NR_write, .arch = AUDIT_ARCH_X86_64 };
    assert(bpf_simulate(&program, &test1) == SECCOMP_RET_ALLOW);

    // Test read refuse
    bpf_test_case_t test2 = { .syscall_nr = __NR_read, .arch = AUDIT_ARCH_X86_64 };
    assert(bpf_simulate(&program, &test2) == SECCOMP_RET_KILL_PROCESS);

    free(program.filter);
}

void test_capability_manager() {
    capability_manager_t mgr;
    assert(capability_manager_init(&mgr) == 0);

    // Creer profil minimal avec NET_BIND_SERVICE
    int caps[] = { CAP_NET_BIND_SERVICE };
    assert(capability_create_minimal_profile(&mgr, caps, 1) == 0);

    assert(mgr.target.effective == (1ULL << CAP_NET_BIND_SERVICE));
    assert(mgr.target.permitted == (1ULL << CAP_NET_BIND_SERVICE));
    assert(mgr.no_new_privs == true);
}

void test_sandbox_config() {
    sandbox_config_t config;
    assert(sandbox_config_init(&config, SANDBOX_PROFILE_COMPUTE) == 0);

    // Verifier action par defaut
    assert(config.seccomp.default_action == SANDBOX_KILL_PROCESS);

    // Verifier qu'on peut ajouter syscalls
    assert(sandbox_allow_syscall(&config, __NR_getpid) == 0);
    assert(sandbox_deny_syscall(&config, __NR_ptrace, EPERM) == 0);

    sandbox_config_cleanup(&config);
}

void test_policy_to_bpf() {
    seccomp_policy_t policy;
    seccomp_policy_init(&policy, SANDBOX_KILL_PROCESS);

    syscall_rule_t rule1 = { .syscall_nr = __NR_read, .action = SANDBOX_ALLOW };
    syscall_rule_t rule2 = { .syscall_nr = __NR_write, .action = SANDBOX_ALLOW };

    seccomp_policy_add_rule(&policy, &rule1);
    seccomp_policy_add_rule(&policy, &rule2);

    bpf_program_t program;
    assert(seccomp_policy_to_bpf(&policy, &program) == 0);
    assert(program.len > 0);

    // Analyser
    bpf_analysis_t analysis;
    assert(bpf_analyze(&program, &analysis) == 0);
    assert(analysis.is_valid_seccomp);
    assert(!analysis.has_backward_jumps);

    free(program.filter);
    seccomp_policy_cleanup(&policy);
}

int main() {
    test_bpf_compiler();
    test_bpf_simulator();
    test_capability_manager();
    test_sandbox_config();
    test_policy_to_bpf();

    printf("All sandbox tests passed!\n");
    return 0;
}
```

## Ressources
- Linux Seccomp documentation: `man 2 seccomp`
- BPF filter format: `linux/filter.h`
- Capabilities: `man 7 capabilities`
- libseccomp (reference): https://github.com/seccomp/libseccomp
