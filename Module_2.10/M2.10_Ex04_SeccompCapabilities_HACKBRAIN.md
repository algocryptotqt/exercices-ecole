# Exercice M2.10_Ex04 : sandbox_enforcer

**Module :**
2.10 — Conteneurs, Virtualisation et Sujets Avances

**Concept :**
d — Seccomp-BPF et Linux Capabilities pour Sandboxing

**Difficulte :**
★★★★★★★★☆☆ (8/10)

**Type :**
complet

**Tiers :**
3 — Synthese (concepts seccomp + capabilities + BPF + no_new_privs)

**Langage :**
C17

**Prerequis :**
- Appels systeme Linux (syscall)
- Programmation systeme avancee
- Structures de donnees C
- Gestion memoire et pointeurs
- Notions de securite Linux

**Domaines :**
Mem, Process, Crypto

**Duree estimee :**
360 min

**XP Base :**
500

**Complexite :**
T3 O(n) x S2 O(1)

---

## 1.1 Obligations

**Fichier a rendre :**
`sandbox_enforcer.c`

**Fonctions autorisees :**
`prctl`, `syscall`, `malloc`, `free`, `memset`, `memcpy`, `printf`, `write`, `exit`

**Fonctions interdites :**
`system`, `exec*`, `fork` (sauf dans le contexte sandbox_exec)

**Compilation :**
```bash
gcc -Wall -Wextra -Werror -std=c17 -D_GNU_SOURCE sandbox_enforcer.c -o sandbox_enforcer
```

---

## 1.2 Consigne

### 2.4.1 Analogie : AIRPORT SECURITY

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                        AEROPORT INTERNATIONAL DE LINUX                                  │
│                                                                                         │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│   │                            ZONE PUBLIQUE                                         │   │
│   │                         (Espace Utilisateur)                                     │   │
│   │                                                                                  │   │
│   │   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                      │   │
│   │   │  Passager A  │    │  Passager B  │    │  Passager C  │                      │   │
│   │   │  (Process)   │    │  (Process)   │    │  (Process)   │                      │   │
│   │   └──────┬───────┘    └──────┬───────┘    └──────┬───────┘                      │   │
│   │          │                   │                   │                               │   │
│   └──────────┼───────────────────┼───────────────────┼───────────────────────────────┘   │
│              │                   │                   │                                   │
│              ▼                   ▼                   ▼                                   │
│   ╔═══════════════════════════════════════════════════════════════════════════════════╗ │
│   ║                          CHECKPOINT TSA (Kernel)                                   ║ │
│   ║                                                                                    ║ │
│   ║   ┌────────────────────────────────┐    ┌────────────────────────────────┐        ║ │
│   ║   │     LISTE OBJETS INTERDITS     │    │      BADGES D'ACCES            │        ║ │
│   ║   │         (SECCOMP)              │    │      (CAPABILITIES)            │        ║ │
│   ║   │                                │    │                                │        ║ │
│   ║   │  ✗ Couteaux (ptrace)          │    │  [PILOTE] CAP_SYS_ADMIN        │        ║ │
│   ║   │  ✗ Explosifs (kexec_load)     │    │  [CREW]   CAP_NET_BIND         │        ║ │
│   ║   │  ✗ Armes (reboot)             │    │  [VIP]    CAP_DAC_OVERRIDE     │        ║ │
│   ║   │  ✗ Liquides (mount)           │    │  [BASIC]  (aucun privilege)    │        ║ │
│   ║   │                                │    │                                │        ║ │
│   ║   │  ✓ Livre (read)               │    │  Badge perdu = acces refuse    │        ║ │
│   ║   │  ✓ Stylo (write)              │    │  NO_NEW_PRIVS = pas de         │        ║ │
│   ║   │  ✓ Telephone (exit)           │    │  nouveau badge possible!       │        ║ │
│   ║   └────────────────────────────────┘    └────────────────────────────────┘        ║ │
│   ║                                                                                    ║ │
│   ║   SCANNER BPF : Analyse chaque objet (syscall) selon des regles programmees       ║ │
│   ║                 → ALLOW (passer) | KILL (arreter) | ERRNO (refuser poliment)      ║ │
│   ╚═══════════════════════════════════════════════════════════════════════════════════╝ │
│              │                   │                   │                                   │
│              ▼                   ▼                   ▼                                   │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│   │                           ZONE SECURISEE                                         │   │
│   │                         (Ressources Kernel)                                      │   │
│   │                                                                                  │   │
│   │   [Fichiers]     [Reseau]     [Memoire]     [Hardware]                          │   │
│   │                                                                                  │   │
│   └─────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

**TRADUCTION DE L'ANALOGIE :**

| Concept Aeroport | Concept Linux | Explication |
|------------------|---------------|-------------|
| **Liste objets interdits** | **SECCOMP** | Definit quels syscalls sont autorises/interdits |
| **Badges d'acces** | **CAPABILITIES** | Privileges granulaires (pas tout-ou-rien comme root) |
| **Agent TSA** | **KERNEL** | Verifie CHAQUE action avant de l'autoriser |
| **"Pas de nouveau badge"** | **NO_NEW_PRIVS** | Une fois sandboxe, impossible d'elever ses privileges |
| **Scanner BPF** | **SECCOMP-BPF** | Programme qui filtre les syscalls selon des regles |

---

### 2.4.2 Enonce Academique

**Contexte :**

Seccomp (Secure Computing Mode) et les Linux Capabilities sont deux mecanismes fondamentaux de securite du noyau Linux permettant d'implementer le principe du moindre privilege.

**Seccomp** permet de restreindre les appels systeme qu'un processus peut effectuer. En mode BPF (Berkeley Packet Filter), on peut definir des regles complexes de filtrage basees sur le numero du syscall et ses arguments.

**Les Capabilities** decomposent les privileges root en unites granulaires (CAP_NET_BIND_SERVICE, CAP_SYS_ADMIN, etc.), permettant d'accorder uniquement les privileges necessaires.

**Ta mission :**

Implementer un framework de sandboxing qui combine seccomp-BPF et capabilities pour executer du code non fiable dans un environnement controle.

**Entree :**
- `policy` : Structure definissant les regles seccomp et capabilities
- `syscall_nr` : Numero d'appel systeme a filtrer
- `caps` : Ensemble de capabilities a configurer

**Sortie :**
- Retourne `0` si l'operation reussit
- Retourne `-1` avec errno si echec
- Retourne `SECCOMP_RET_KILL` / `SECCOMP_RET_ALLOW` / `SECCOMP_RET_ERRNO` selon la politique

**Contraintes :**
- Verification de l'architecture (securite contre attaques x32)
- Pas de sauts arriere dans le BPF (interdit par seccomp)
- NO_NEW_PRIVS doit etre active AVANT seccomp
- Les capabilities doivent etre reduites dans l'ordre correct

**Exemples :**

| Operation | Resultat | Explication |
|-----------|----------|-------------|
| `sandbox_apply(PROFILE_COMPUTE)` | `0` | Sandbox compute applique |
| `syscall(__NR_ptrace, ...)` | `SIGKILL` | ptrace interdit, processus tue |
| `capability_drop(CAP_SYS_ADMIN)` | `0` | Privilege SYS_ADMIN retire |
| `sandbox_apply(NULL)` | `-EINVAL` | Politique NULL invalide |

---

## 1.3 Prototype

```c
// Structure politique seccomp
typedef struct {
    uint32_t default_action;        // Action par defaut (KILL/ALLOW/ERRNO)
    int *allowed_syscalls;          // Liste syscalls autorises
    size_t num_allowed;             // Nombre de syscalls autorises
    bool log_denials;               // Logger les refus
} seccomp_policy_t;

// Structure capabilities
typedef struct {
    uint64_t effective;             // Capabilities actives
    uint64_t permitted;             // Capabilities permises
    uint64_t inheritable;           // Capabilities heritables
    uint64_t bounding;              // Bounding set
    bool no_new_privs;              // Flag NO_NEW_PRIVS
} capability_set_t;

// Fonctions principales
int seccomp_policy_init(seccomp_policy_t *policy, uint32_t default_action);
int seccomp_add_allowed(seccomp_policy_t *policy, int syscall_nr);
int seccomp_apply(const seccomp_policy_t *policy);

int capability_init(capability_set_t *caps);
int capability_drop(capability_set_t *caps, int cap);
int capability_apply(const capability_set_t *caps);

int sandbox_apply_full(seccomp_policy_t *seccomp, capability_set_t *caps);
```

---

## 2. LE SAVIEZ-VOUS ?

### 2.1 Origine de Seccomp

Seccomp a ete introduit dans Linux 2.6.12 (2005) par Andrea Arcangeli. Le mode strict original n'autorisait que 4 syscalls : `read`, `write`, `exit`, `sigreturn`. Ce mode etait utilise par les "computing grids" pour executer du code non fiable.

### 2.2 Evolution vers BPF

En 2012, Will Drewry a ajoute seccomp-BPF (Linux 3.5), permettant des filtres programmables. Cela a revolutionne le sandboxing : Chrome, Firefox, Docker, systemd utilisent tous seccomp-BPF aujourd'hui.

### 2.3 Capabilities : Decoupe des Privileges Root

Avant les capabilities, un processus etait soit root (tout-puissant) soit utilisateur normal (limite). Les capabilities (introduites dans POSIX 1003.1e puis Linux 2.2) permettent une granularite fine : un serveur web peut binder le port 80 (CAP_NET_BIND_SERVICE) sans avoir les autres privileges root.

---

## 2.5 DANS LA VRAIE VIE

| Metier | Utilisation | Cas d'Usage |
|--------|-------------|-------------|
| **DevOps/SRE** | Configuration Docker/Kubernetes | Definir les seccomp profiles pour les conteneurs |
| **Ingenieur Securite** | Hardening applicatif | Reduire la surface d'attaque des services |
| **Developpeur Systeme** | Sandboxing d'extensions | Isoler les plugins/extensions non fiables |
| **Architecte Cloud** | Multi-tenancy securise | Isoler les workloads clients |

**Exemple reel : Chrome/Chromium**

Chrome utilise un modele de sandboxing sophistique avec seccomp-BPF :
- Le processus "broker" a plus de privileges
- Les processus "renderer" sont fortement sandboxes
- Moins de 50 syscalls autorises pour les renderers

---

## 3. EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
sandbox_enforcer.c  main.c

$ gcc -Wall -Wextra -Werror -std=c17 -D_GNU_SOURCE sandbox_enforcer.c main.c -o test

$ ./test
[SANDBOX] Initializing seccomp policy...
[SANDBOX] Adding allowed syscall: read (0)
[SANDBOX] Adding allowed syscall: write (1)
[SANDBOX] Adding allowed syscall: exit_group (231)
[SANDBOX] Dropping CAP_SYS_ADMIN...
[SANDBOX] Applying NO_NEW_PRIVS...
[SANDBOX] Installing seccomp filter...
[SANDBOX] Sandbox applied successfully!
[TEST] Attempting write() - should work...
[TEST] Write OK!
[TEST] All sandbox tests passed!
```

---

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x4

**Time Complexity attendue :**
O(log n) pour recherche binaire dans filtre BPF

**Space Complexity attendue :**
O(n) pour le programme BPF compile

**Domaines Bonus :**
`Crypto, CPU`

#### 3.1.1 Consigne Bonus

**Mission :**

Implementer un compilateur BPF optimise avec recherche binaire et un gestionnaire de notifications userspace (SECCOMP_USER_NOTIF) pour traiter certains syscalls en espace utilisateur.

**Contraintes :**
```
┌─────────────────────────────────────────┐
│  Programme BPF < 4096 instructions      │
│  Temps lookup syscall : O(log n)        │
│  Support SECCOMP_RET_USER_NOTIF         │
│  Gestion TOCTOU pour notifications      │
└─────────────────────────────────────────┘
```

#### 3.1.2 Prototype Bonus

```c
typedef struct {
    struct sock_filter *filter;
    size_t len;
} bpf_program_t;

int bpf_compile_optimized(const seccomp_policy_t *policy,
                          bpf_program_t *program,
                          int optimization_level);

int userspace_notifier_handle(int listener_fd,
                              int (*handler)(struct seccomp_notif *req,
                                           struct seccomp_notif_resp *resp));
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Lookup syscall | O(n) lineaire | O(log n) binaire |
| Notifications | Non | SECCOMP_USER_NOTIF |
| Optimisation BPF | Aucune | Arbre de decision |
| Gestion TOCTOU | Non | Oui (pid_valid) |

---

## 4. ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `test_policy_init_null` | `NULL` | `-EINVAL` | 5 |
| `test_policy_init_valid` | `&policy, SECCOMP_RET_KILL` | `0` | 5 |
| `test_add_syscall_read` | `policy, __NR_read` | `0` | 5 |
| `test_add_syscall_invalid` | `NULL, __NR_read` | `-EINVAL` | 5 |
| `test_capability_init` | `&caps` | `0` | 5 |
| `test_capability_drop` | `caps, CAP_SYS_ADMIN` | `0` | 10 |
| `test_capability_drop_invalid` | `caps, -1` | `-EINVAL` | 5 |
| `test_no_new_privs` | `apply after no_new_privs` | `0` | 10 |
| `test_seccomp_apply` | `valid policy` | `0` | 15 |
| `test_arch_validation` | `x86_64 check` | `KILL on wrong arch` | 15 |
| `test_sandbox_full` | `policy + caps` | `0` | 20 |

### 4.2 main.c de test

```c
#include "sandbox_enforcer.h"
#include <stdio.h>
#include <assert.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void test_policy_init(void) {
    seccomp_policy_t policy;

    // Test NULL
    assert(seccomp_policy_init(NULL, SECCOMP_RET_KILL_PROCESS) == -EINVAL);

    // Test valid
    assert(seccomp_policy_init(&policy, SECCOMP_RET_KILL_PROCESS) == 0);
    assert(policy.default_action == SECCOMP_RET_KILL_PROCESS);
    assert(policy.num_allowed == 0);

    printf("[OK] test_policy_init\n");
}

void test_add_syscall(void) {
    seccomp_policy_t policy;
    seccomp_policy_init(&policy, SECCOMP_RET_KILL_PROCESS);

    // Test NULL policy
    assert(seccomp_add_allowed(NULL, __NR_read) == -EINVAL);

    // Test valid add
    assert(seccomp_add_allowed(&policy, __NR_read) == 0);
    assert(seccomp_add_allowed(&policy, __NR_write) == 0);
    assert(policy.num_allowed == 2);

    printf("[OK] test_add_syscall\n");
}

void test_capability_operations(void) {
    capability_set_t caps;

    // Test init
    assert(capability_init(&caps) == 0);

    // Test drop valid
    assert(capability_drop(&caps, CAP_SYS_ADMIN) == 0);
    assert(!(caps.effective & (1ULL << CAP_SYS_ADMIN)));

    // Test drop invalid
    assert(capability_drop(&caps, -1) == -EINVAL);
    assert(capability_drop(&caps, 64) == -EINVAL);

    printf("[OK] test_capability_operations\n");
}

void test_sandbox_in_child(void) {
    pid_t pid = fork();

    if (pid == 0) {
        // Child process
        seccomp_policy_t policy;
        capability_set_t caps;

        seccomp_policy_init(&policy, SECCOMP_RET_KILL_PROCESS);
        seccomp_add_allowed(&policy, __NR_exit_group);
        seccomp_add_allowed(&policy, __NR_write);

        capability_init(&caps);
        caps.no_new_privs = true;

        int ret = sandbox_apply_full(&policy, &caps);
        if (ret == 0) {
            write(1, "Sandbox OK\n", 11);
        }
        _exit(ret == 0 ? 0 : 1);
    } else {
        int status;
        waitpid(pid, &status, 0);
        assert(WIFEXITED(status) && WEXITSTATUS(status) == 0);
        printf("[OK] test_sandbox_in_child\n");
    }
}

int main(void) {
    printf("=== Sandbox Enforcer Tests ===\n\n");

    test_policy_init();
    test_add_syscall();
    test_capability_operations();
    test_sandbox_in_child();

    printf("\n=== All tests passed! ===\n");
    return 0;
}
```

### 4.3 Solution de reference

```c
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/audit.h>

#define SECCOMP_DATA_NR_OFFSET    0
#define SECCOMP_DATA_ARCH_OFFSET  4

typedef struct {
    uint32_t default_action;
    int *allowed_syscalls;
    size_t num_allowed;
    size_t capacity;
    bool log_denials;
} seccomp_policy_t;

typedef struct {
    uint64_t effective;
    uint64_t permitted;
    uint64_t inheritable;
    uint64_t bounding;
    bool no_new_privs;
} capability_set_t;

int seccomp_policy_init(seccomp_policy_t *policy, uint32_t default_action) {
    if (policy == NULL)
        return -EINVAL;

    memset(policy, 0, sizeof(*policy));
    policy->default_action = default_action;
    policy->capacity = 64;
    policy->allowed_syscalls = calloc(policy->capacity, sizeof(int));

    if (policy->allowed_syscalls == NULL)
        return -ENOMEM;

    return 0;
}

int seccomp_add_allowed(seccomp_policy_t *policy, int syscall_nr) {
    if (policy == NULL)
        return -EINVAL;

    if (policy->num_allowed >= policy->capacity) {
        size_t new_cap = policy->capacity * 2;
        int *new_arr = realloc(policy->allowed_syscalls, new_cap * sizeof(int));
        if (new_arr == NULL)
            return -ENOMEM;
        policy->allowed_syscalls = new_arr;
        policy->capacity = new_cap;
    }

    policy->allowed_syscalls[policy->num_allowed] = syscall_nr;
    policy->num_allowed++;

    return 0;
}

int seccomp_apply(const seccomp_policy_t *policy) {
    if (policy == NULL)
        return -EINVAL;

    size_t num_insn = 3 + policy->num_allowed * 2 + 1;
    struct sock_filter *filter = calloc(num_insn, sizeof(struct sock_filter));
    if (filter == NULL)
        return -ENOMEM;

    size_t pc = 0;

    // 1. Valider architecture (securite!)
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SECCOMP_DATA_ARCH_OFFSET);
    filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0);
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS);

    // 2. Charger numero syscall
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SECCOMP_DATA_NR_OFFSET);

    // 3. Verifier chaque syscall autorise
    for (size_t i = 0; i < policy->num_allowed; i++) {
        uint8_t jt = 0;
        uint8_t jf = (i == policy->num_allowed - 1) ? 1 : 2;
        filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K,
                                                     policy->allowed_syscalls[i], jt, jf);
        filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
    }

    // 4. Action par defaut
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, policy->default_action);

    struct sock_fprog prog = {
        .len = pc,
        .filter = filter
    };

    int ret = syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, 0, &prog);
    free(filter);

    if (ret < 0)
        return -errno;

    return 0;
}

int capability_init(capability_set_t *caps) {
    if (caps == NULL)
        return -EINVAL;

    memset(caps, 0, sizeof(*caps));

    struct __user_cap_header_struct header = {
        .version = _LINUX_CAPABILITY_VERSION_3,
        .pid = 0
    };
    struct __user_cap_data_struct data[2];

    if (syscall(SYS_capget, &header, data) < 0)
        return -errno;

    caps->effective = ((uint64_t)data[1].effective << 32) | data[0].effective;
    caps->permitted = ((uint64_t)data[1].permitted << 32) | data[0].permitted;
    caps->inheritable = ((uint64_t)data[1].inheritable << 32) | data[0].inheritable;

    for (int cap = 0; cap <= 40; cap++) {
        if (prctl(PR_CAPBSET_READ, cap, 0, 0, 0) > 0)
            caps->bounding |= (1ULL << cap);
    }

    return 0;
}

int capability_drop(capability_set_t *caps, int cap) {
    if (caps == NULL || cap < 0 || cap > 63)
        return -EINVAL;

    uint64_t mask = ~(1ULL << cap);
    caps->effective &= mask;
    caps->permitted &= mask;
    caps->inheritable &= mask;
    caps->bounding &= mask;

    return 0;
}

int capability_apply(const capability_set_t *caps) {
    if (caps == NULL)
        return -EINVAL;

    if (caps->no_new_privs) {
        if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)
            return -errno;
    }

    for (int cap = 0; cap <= 40; cap++) {
        if (!(caps->bounding & (1ULL << cap))) {
            prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);
        }
    }

    struct __user_cap_header_struct header = {
        .version = _LINUX_CAPABILITY_VERSION_3,
        .pid = 0
    };
    struct __user_cap_data_struct data[2] = {
        { .effective = (uint32_t)caps->effective,
          .permitted = (uint32_t)caps->permitted,
          .inheritable = (uint32_t)caps->inheritable },
        { .effective = (uint32_t)(caps->effective >> 32),
          .permitted = (uint32_t)(caps->permitted >> 32),
          .inheritable = (uint32_t)(caps->inheritable >> 32) }
    };

    if (syscall(SYS_capset, &header, data) < 0)
        return -errno;

    return 0;
}

int sandbox_apply_full(seccomp_policy_t *seccomp, capability_set_t *caps) {
    if (seccomp == NULL && caps == NULL)
        return -EINVAL;

    int ret;

    // 1. NO_NEW_PRIVS d'abord (obligatoire avant seccomp sans root)
    if (caps != NULL && caps->no_new_privs) {
        ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
        if (ret < 0)
            return -errno;
    }

    // 2. Capabilities ensuite
    if (caps != NULL) {
        ret = capability_apply(caps);
        if (ret < 0)
            return ret;
    }

    // 3. Seccomp en dernier (irréversible)
    if (seccomp != NULL) {
        ret = seccomp_apply(seccomp);
        if (ret < 0)
            return ret;
    }

    return 0;
}

void seccomp_policy_cleanup(seccomp_policy_t *policy) {
    if (policy != NULL && policy->allowed_syscalls != NULL) {
        free(policy->allowed_syscalls);
        memset(policy, 0, sizeof(*policy));
    }
}
```

### 4.4 Solutions alternatives acceptees

```c
/* Alternative 1 : Utilisation de libseccomp style */
int seccomp_apply_alt(const seccomp_policy_t *policy) {
    if (policy == NULL)
        return -EINVAL;

    // Meme logique mais avec une construction de filtre differente
    // Utilise un tableau statique au lieu de malloc
    struct sock_filter filter[256];
    size_t pc = 0;

    if (policy->num_allowed > 125)  // Limite due au tableau statique
        return -E2BIG;

    // Reste identique...
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                                                 SECCOMP_DATA_ARCH_OFFSET);
    // ... suite du code

    return 0;
}
```

### 4.5 Solutions refusees (avec explications)

```c
/* REFUSE 1 : Pas de validation d'architecture */
int seccomp_apply_REFUSE_no_arch_check(const seccomp_policy_t *policy) {
    // DANGER : Vulnerable aux attaques x32 ABI
    // Un attaquant peut utiliser l'ABI x32 pour contourner les filtres
    struct sock_filter filter[256];
    size_t pc = 0;

    // MANQUE: Verification AUDIT_ARCH_X86_64
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                                                 SECCOMP_DATA_NR_OFFSET);
    // ...
}

/* REFUSE 2 : NO_NEW_PRIVS apres seccomp */
int sandbox_apply_REFUSE_wrong_order(seccomp_policy_t *seccomp, capability_set_t *caps) {
    // ERREUR : L'ordre est critique!
    // seccomp sans NO_NEW_PRIVS requiert CAP_SYS_ADMIN

    seccomp_apply(seccomp);  // ECHOUE si pas root et pas NO_NEW_PRIVS

    if (caps != NULL && caps->no_new_privs) {
        prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);  // Trop tard!
    }
}

/* REFUSE 3 : Pas de gestion NULL */
int capability_drop_REFUSE_no_null_check(capability_set_t *caps, int cap) {
    // CRASH : Dereference de pointeur NULL
    uint64_t mask = ~(1ULL << cap);
    caps->effective &= mask;  // SEGFAULT si caps == NULL
    return 0;
}
```

### 4.6 Solution bonus de reference (COMPLETE)

```c
/* Solution bonus avec compilation BPF optimisee et notifications userspace */

#include <sys/ioctl.h>
#include <poll.h>

typedef struct {
    struct sock_filter *filter;
    size_t len;
    size_t capacity;
} bpf_program_t;

// Comparateur pour qsort
static int syscall_cmp(const void *a, const void *b) {
    return *(const int *)a - *(const int *)b;
}

// Genere un arbre de decision binaire
static size_t emit_binary_search(struct sock_filter *filter, size_t pc,
                                  const int *syscalls, size_t left, size_t right,
                                  size_t allow_offset, size_t deny_offset) {
    if (left > right) {
        filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS);
        return pc;
    }

    if (left == right) {
        filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K,
                                                     syscalls[left], 0, 1);
        filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
        filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS);
        return pc;
    }

    size_t mid = left + (right - left) / 2;

    // Si syscall == mid, autoriser
    // Si syscall > mid, aller a droite
    // Si syscall < mid, aller a gauche

    filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K,
                                                 syscalls[mid], 0, 1);
    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);

    // Comparer pour branchement
    filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K,
                                                 syscalls[mid], 0, 0);

    // Les offsets seront calcules dans une passe de resolution
    // Pour simplifier, on utilise une approche recursive avec correction

    return pc;
}

int bpf_compile_optimized(const seccomp_policy_t *policy,
                          bpf_program_t *program,
                          int optimization_level) {
    if (policy == NULL || program == NULL)
        return -EINVAL;

    // Trier les syscalls pour recherche binaire
    int *sorted = malloc(policy->num_allowed * sizeof(int));
    if (sorted == NULL)
        return -ENOMEM;

    memcpy(sorted, policy->allowed_syscalls, policy->num_allowed * sizeof(int));
    qsort(sorted, policy->num_allowed, sizeof(int), syscall_cmp);

    // Allouer programme BPF (estimation taille)
    size_t max_insn = 4 + policy->num_allowed * 3 + 10;
    program->filter = calloc(max_insn, sizeof(struct sock_filter));
    if (program->filter == NULL) {
        free(sorted);
        return -ENOMEM;
    }

    size_t pc = 0;

    // Validation architecture
    program->filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                                                          SECCOMP_DATA_ARCH_OFFSET);
    program->filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K,
                                                          AUDIT_ARCH_X86_64, 1, 0);
    program->filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K,
                                                          SECCOMP_RET_KILL_PROCESS);

    // Charger syscall
    program->filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                                                          SECCOMP_DATA_NR_OFFSET);

    if (optimization_level >= 1 && policy->num_allowed > 4) {
        // Recherche binaire
        pc = emit_binary_search(program->filter, pc, sorted,
                                0, policy->num_allowed - 1, 0, 0);
    } else {
        // Recherche lineaire classique
        for (size_t i = 0; i < policy->num_allowed; i++) {
            program->filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K,
                                                                  sorted[i], 0, 1);
            program->filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K,
                                                                  SECCOMP_RET_ALLOW);
        }
        program->filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K,
                                                              policy->default_action);
    }

    program->len = pc;
    free(sorted);

    return 0;
}

// Handler de notifications userspace
typedef struct {
    int listener_fd;
    int (*handler)(struct seccomp_notif *req, struct seccomp_notif_resp *resp);
    uint64_t handled_count;
} userspace_notifier_t;

int userspace_notifier_init(userspace_notifier_t *notifier, int listener_fd) {
    if (notifier == NULL || listener_fd < 0)
        return -EINVAL;

    memset(notifier, 0, sizeof(*notifier));
    notifier->listener_fd = listener_fd;

    return 0;
}

bool userspace_notifier_pid_valid(userspace_notifier_t *notifier, uint64_t id) {
    if (notifier == NULL)
        return false;

    return ioctl(notifier->listener_fd, SECCOMP_IOCTL_NOTIF_ID_VALID, &id) == 0;
}

int userspace_notifier_handle(int listener_fd,
                              int (*handler)(struct seccomp_notif *req,
                                           struct seccomp_notif_resp *resp)) {
    if (listener_fd < 0 || handler == NULL)
        return -EINVAL;

    struct seccomp_notif_sizes sizes;
    if (syscall(SYS_seccomp, SECCOMP_GET_NOTIF_SIZES, 0, &sizes) < 0)
        return -errno;

    struct seccomp_notif *req = calloc(1, sizes.seccomp_notif);
    struct seccomp_notif_resp *resp = calloc(1, sizes.seccomp_notif_resp);

    if (req == NULL || resp == NULL) {
        free(req);
        free(resp);
        return -ENOMEM;
    }

    // Recevoir notification
    if (ioctl(listener_fd, SECCOMP_IOCTL_NOTIF_RECV, req) < 0) {
        free(req);
        free(resp);
        return -errno;
    }

    // Verifier que le PID est toujours valide (anti-TOCTOU)
    if (ioctl(listener_fd, SECCOMP_IOCTL_NOTIF_ID_VALID, &req->id) < 0) {
        free(req);
        free(resp);
        return -ESRCH;
    }

    // Preparer reponse
    resp->id = req->id;
    resp->flags = 0;

    // Appeler handler utilisateur
    int ret = handler(req, resp);
    if (ret < 0) {
        resp->error = -ret;
    }

    // Envoyer reponse
    if (ioctl(listener_fd, SECCOMP_IOCTL_NOTIF_SEND, resp) < 0) {
        ret = -errno;
    }

    free(req);
    free(resp);

    return ret;
}
```

### 4.7 Solutions alternatives bonus (COMPLETES)

```c
/* Alternative bonus : Jump table pour syscalls consecutifs */
int bpf_compile_jump_table(const seccomp_policy_t *policy, bpf_program_t *program) {
    // Detecte les plages consecutives et utilise des jump tables
    // Plus efficace quand beaucoup de syscalls consecutifs

    if (policy == NULL || program == NULL)
        return -EINVAL;

    // Trouver min et max
    int min_nr = INT_MAX, max_nr = INT_MIN;
    for (size_t i = 0; i < policy->num_allowed; i++) {
        if (policy->allowed_syscalls[i] < min_nr)
            min_nr = policy->allowed_syscalls[i];
        if (policy->allowed_syscalls[i] > max_nr)
            max_nr = policy->allowed_syscalls[i];
    }

    int range = max_nr - min_nr + 1;

    // Si densite > 50%, utiliser jump table
    if (policy->num_allowed * 2 > (size_t)range) {
        // Implementation jump table...
    }

    return 0;
}
```

### 4.8 Solutions refusees bonus (COMPLETES)

```c
/* REFUSE BONUS 1 : Pas de verification TOCTOU */
int userspace_notifier_handle_REFUSE_no_toctou(int listener_fd,
                                                int (*handler)(struct seccomp_notif *req,
                                                             struct seccomp_notif_resp *resp)) {
    struct seccomp_notif req;
    struct seccomp_notif_resp resp;

    ioctl(listener_fd, SECCOMP_IOCTL_NOTIF_RECV, &req);

    // DANGER : Le processus notifie peut avoir ete remplace entre recv et send!
    // Race condition : PID recycle, attaquant prend le controle

    // MANQUE: ioctl(SECCOMP_IOCTL_NOTIF_ID_VALID, &req->id)

    handler(&req, &resp);
    ioctl(listener_fd, SECCOMP_IOCTL_NOTIF_SEND, &resp);

    return 0;
}

/* REFUSE BONUS 2 : Sauts arriere dans BPF */
int bpf_compile_REFUSE_backward_jump(const seccomp_policy_t *policy,
                                      bpf_program_t *program) {
    // INTERDIT par seccomp : les sauts arriere permettraient des boucles
    // Le verifieur BPF du kernel rejettera ce programme

    struct sock_filter filter[] = {
        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, 0),
        BPF_JUMP(BPF_JMP | BPF_JA, -1, 0, 0),  // SAUT ARRIERE = REFUSE
        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)
    };

    // Le kernel retournera -EINVAL
}
```

### 4.9 spec.json (ENGINE v22.1 - FORMAT STRICT)

```json
{
  "name": "sandbox_enforcer",
  "language": "c",
  "type": "complet",
  "tier": 3,
  "tier_info": "Synthese (seccomp + capabilities + BPF + no_new_privs)",
  "tags": ["seccomp", "capabilities", "bpf", "sandbox", "security", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "sandbox_apply_full",
    "prototype": "int sandbox_apply_full(seccomp_policy_t *seccomp, capability_set_t *caps)",
    "return_type": "int",
    "parameters": [
      {"name": "seccomp", "type": "seccomp_policy_t *"},
      {"name": "caps", "type": "capability_set_t *"}
    ]
  },

  "driver": {
    "reference": "int ref_sandbox_apply_full(seccomp_policy_t *seccomp, capability_set_t *caps) { if (seccomp == NULL && caps == NULL) return -EINVAL; int ret; if (caps != NULL && caps->no_new_privs) { ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); if (ret < 0) return -errno; } if (caps != NULL) { ret = capability_apply(caps); if (ret < 0) return ret; } if (seccomp != NULL) { ret = seccomp_apply(seccomp); if (ret < 0) return ret; } return 0; }",

    "edge_cases": [
      {
        "name": "null_both",
        "args": [null, null],
        "expected": -22,
        "is_trap": true,
        "trap_explanation": "Les deux arguments NULL retourne EINVAL"
      },
      {
        "name": "null_seccomp_valid_caps",
        "args": [null, {"no_new_privs": true}],
        "expected": 0,
        "is_trap": false
      },
      {
        "name": "valid_seccomp_null_caps",
        "args": [{"default_action": 0, "num_allowed": 0}, null],
        "expected": 0,
        "is_trap": false
      },
      {
        "name": "wrong_order_check",
        "args": [{"default_action": 0}, {"no_new_privs": false}],
        "expected": 0,
        "is_trap": true,
        "trap_explanation": "Sans NO_NEW_PRIVS et sans root, seccomp echoue"
      }
    ],

    "fuzzing": {
      "enabled": false,
      "note": "Fuzzing desactive car syscalls sensibles"
    }
  },

  "norm": {
    "allowed_functions": ["prctl", "syscall", "malloc", "free", "memset", "memcpy", "printf", "write", "exit", "calloc", "realloc"],
    "forbidden_functions": ["system", "execve", "execl", "execv", "execlp", "execvp"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  },

  "bonus": {
    "name": "bpf_compile_optimized",
    "prototype": "int bpf_compile_optimized(const seccomp_policy_t *policy, bpf_program_t *program, int optimization_level)",
    "difficulty": 10,
    "xp_multiplier": 4,
    "constraints": {
      "time_complexity": "O(log n)",
      "space_complexity": "O(n)"
    }
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```c
/* Mutant A (Boundary) : Off-by-one dans la limite des capabilities */
int capability_drop_MUTANT_A(capability_set_t *caps, int cap) {
    // BUG: > 63 au lieu de >= 64, ou cap > 40 incorrect
    if (caps == NULL || cap < 0 || cap > 40)  // Devrait etre > 63 ou utiliser CAP_LAST_CAP
        return -EINVAL;

    uint64_t mask = ~(1ULL << cap);
    caps->effective &= mask;
    caps->permitted &= mask;
    caps->inheritable &= mask;
    caps->bounding &= mask;

    return 0;
}
// Pourquoi c'est faux : Capabilities 41-63 existent, l'attaquant peut les garder
// Ce qui etait pense : "40 capabilities suffisent" (non, il y en a plus)

/* Mutant B (Safety) : Pas de verification NULL dans seccomp_policy_init */
int seccomp_policy_init_MUTANT_B(seccomp_policy_t *policy, uint32_t default_action) {
    // BUG: Pas de check NULL
    memset(policy, 0, sizeof(*policy));  // CRASH si policy == NULL
    policy->default_action = default_action;
    policy->capacity = 64;
    policy->allowed_syscalls = calloc(policy->capacity, sizeof(int));

    if (policy->allowed_syscalls == NULL)
        return -ENOMEM;

    return 0;
}
// Pourquoi c'est faux : Segfault sur NULL
// Ce qui etait pense : "L'appelant passera toujours un pointeur valide"

/* Mutant C (Resource) : Fuite memoire dans seccomp_apply */
int seccomp_apply_MUTANT_C(const seccomp_policy_t *policy) {
    if (policy == NULL)
        return -EINVAL;

    size_t num_insn = 3 + policy->num_allowed * 2 + 1;
    struct sock_filter *filter = calloc(num_insn, sizeof(struct sock_filter));
    if (filter == NULL)
        return -ENOMEM;

    // ... construction du filtre ...

    struct sock_fprog prog = { .len = num_insn, .filter = filter };

    int ret = syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, 0, &prog);

    if (ret < 0)
        return -errno;  // BUG: filter pas libere en cas d'erreur!

    free(filter);
    return 0;
}
// Pourquoi c'est faux : Fuite memoire si syscall echoue
// Ce qui etait pense : "Le syscall reussit toujours" (non!)

/* Mutant D (Logic) : Ordre incorrect NO_NEW_PRIVS / seccomp */
int sandbox_apply_full_MUTANT_D(seccomp_policy_t *seccomp, capability_set_t *caps) {
    if (seccomp == NULL && caps == NULL)
        return -EINVAL;

    int ret;

    // BUG: seccomp AVANT NO_NEW_PRIVS
    // Sans root et sans NO_NEW_PRIVS, seccomp echoue avec EPERM
    if (seccomp != NULL) {
        ret = seccomp_apply(seccomp);  // ECHOUE!
        if (ret < 0)
            return ret;
    }

    if (caps != NULL && caps->no_new_privs) {
        ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
        if (ret < 0)
            return -errno;
    }

    if (caps != NULL) {
        ret = capability_apply(caps);
        if (ret < 0)
            return ret;
    }

    return 0;
}
// Pourquoi c'est faux : L'ordre est critique pour la securite
// Ce qui etait pense : "L'ordre n'a pas d'importance"

/* Mutant E (Return) : Pas de validation d'architecture dans BPF */
int seccomp_apply_MUTANT_E(const seccomp_policy_t *policy) {
    if (policy == NULL)
        return -EINVAL;

    size_t num_insn = policy->num_allowed * 2 + 2;  // Moins d'instructions
    struct sock_filter *filter = calloc(num_insn, sizeof(struct sock_filter));
    if (filter == NULL)
        return -ENOMEM;

    size_t pc = 0;

    // BUG: PAS DE VALIDATION D'ARCHITECTURE!
    // Vulnerable aux attaques x32 ABI

    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                                                 SECCOMP_DATA_NR_OFFSET);

    for (size_t i = 0; i < policy->num_allowed; i++) {
        filter[pc++] = (struct sock_filter)BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K,
                                                     policy->allowed_syscalls[i], 0, 1);
        filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW);
    }

    filter[pc++] = (struct sock_filter)BPF_STMT(BPF_RET | BPF_K, policy->default_action);

    struct sock_fprog prog = { .len = pc, .filter = filter };

    int ret = syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, 0, &prog);
    free(filter);

    return (ret < 0) ? -errno : 0;
}
// Pourquoi c'est faux : Attaque x32 ABI permet de contourner le filtre
// Ce qui etait pense : "Un seul type de syscall existe"
```

---

## 5. COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

| Competence | Description |
|------------|-------------|
| **Seccomp** | Mecanisme de filtrage des appels systeme |
| **BPF** | Langage de programmation de filtres dans le kernel |
| **Capabilities** | Decomposition granulaire des privileges root |
| **NO_NEW_PRIVS** | Flag empechant l'elevation de privileges |
| **Defense en profondeur** | Combinaison de plusieurs mecanismes de securite |

### 5.2 LDA - Traduction Litterale en Francais (MAJUSCULES)

```
FONCTION sandbox_apply_full QUI RETOURNE UN ENTIER ET PREND EN PARAMETRES seccomp QUI EST UN POINTEUR VERS UNE STRUCTURE POLITIQUE SECCOMP ET caps QUI EST UN POINTEUR VERS UN ENSEMBLE DE CAPABILITIES
DEBUT FONCTION
    SI seccomp EST EGAL A NUL ET caps EST EGAL A NUL ALORS
        RETOURNER MOINS EINVAL
    FIN SI

    DECLARER ret COMME ENTIER

    SI caps N'EST PAS EGAL A NUL ET LE CHAMP no_new_privs DE caps EST VRAI ALORS
        AFFECTER LE RESULTAT DE L'APPEL prctl AVEC PR_SET_NO_NEW_PRIVS ET 1 A ret
        SI ret EST INFERIEUR A ZERO ALORS
            RETOURNER MOINS errno
        FIN SI
    FIN SI

    SI caps N'EST PAS EGAL A NUL ALORS
        AFFECTER LE RESULTAT DE L'APPEL capability_apply AVEC caps A ret
        SI ret EST INFERIEUR A ZERO ALORS
            RETOURNER ret
        FIN SI
    FIN SI

    SI seccomp N'EST PAS EGAL A NUL ALORS
        AFFECTER LE RESULTAT DE L'APPEL seccomp_apply AVEC seccomp A ret
        SI ret EST INFERIEUR A ZERO ALORS
            RETOURNER ret
        FIN SI
    FIN SI

    RETOURNER ZERO
FIN FONCTION
```

### 5.2.2 LDA Style Academique Francais

```
ALGORITHME : Application_Sandbox_Complet
ENTREES :
    - seccomp : pointeur vers politique de filtrage syscalls
    - caps : pointeur vers ensemble de capabilities
SORTIE : entier (0 si succes, code erreur negatif sinon)

DEBUT
    SI (seccomp = NIL) ET (caps = NIL) ALORS
        RETOURNER -EINVAL
    FIN SI

    ret : ENTIER

    // Etape 1 : Activer NO_NEW_PRIVS si demande
    SI (caps != NIL) ET (caps.no_new_privs = VRAI) ALORS
        ret <- prctl(PR_SET_NO_NEW_PRIVS, 1)
        SI ret < 0 ALORS
            RETOURNER -errno
        FIN SI
    FIN SI

    // Etape 2 : Appliquer les capabilities
    SI caps != NIL ALORS
        ret <- capability_apply(caps)
        SI ret < 0 ALORS
            RETOURNER ret
        FIN SI
    FIN SI

    // Etape 3 : Installer le filtre seccomp (irreversible)
    SI seccomp != NIL ALORS
        ret <- seccomp_apply(seccomp)
        SI ret < 0 ALORS
            RETOURNER ret
        FIN SI
    FIN SI

    RETOURNER 0
FIN
```

### 5.2.2.1 Logic Flow (Structured English)

```
ALGORITHME : Sandbox Application
---
1. VERIFIER les parametres d'entree
   |-- SI les deux sont NULL :
   |     RETOURNER Erreur "Parametres invalides"

2. ACTIVER NO_NEW_PRIVS (si demande) :
   |-- APPELER prctl(PR_SET_NO_NEW_PRIVS)
   |-- SI echec : RETOURNER errno

3. APPLIQUER les capabilities :
   |-- POUR CHAQUE capability a supprimer :
   |     APPELER prctl(PR_CAPBSET_DROP)
   |-- APPELER capset() avec les nouvelles valeurs
   |-- SI echec : RETOURNER errno

4. INSTALLER le filtre seccomp :
   |-- COMPILER la politique en programme BPF
   |-- APPELER syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER)
   |-- SI echec : RETOURNER errno

5. RETOURNER succes (0)
```

### 5.2.3 Representation Algorithmique

```
┌──────────────────────────────────────────────────────────────┐
│                    SANDBOX_APPLY_FULL                         │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│   ENTREE: (seccomp_policy_t*, capability_set_t*)             │
│   SORTIE: int (0 = succes, <0 = erreur)                      │
│                                                              │
│   PRECONDITION: Au moins un parametre non-NULL               │
│   POSTCONDITION: Processus sandboxe irreversiblement         │
│                                                              │
│   INVARIANT: Ordre d'application = NO_NEW_PRIVS → CAPS → SECCOMP │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 5.2.3.1 Guard Logic (Fail Fast)

```
FONCTION : sandbox_apply_full(seccomp, caps)
---
INIT resultat = -EINVAL

1. GARDES D'ENTREE :
   |
   |-- VERIFIER (seccomp != NULL OU caps != NULL) :
   |     SI FAUX : RETOURNER Erreur "Au moins un parametre requis"
   |
   |-- VERIFIER coherence politique seccomp (si presente) :
   |     SI default_action invalide : RETOURNER Erreur

2. PHASE 1 - NO_NEW_PRIVS (point de non-retour #1) :
   |
   |-- SI caps->no_new_privs == true :
   |     EXECUTER prctl(PR_SET_NO_NEW_PRIVS, 1)
   |     SI echec : RETOURNER Erreur
   |     NOTE: Irreversible, impossible de revenir en arriere

3. PHASE 2 - CAPABILITIES (point de non-retour #2) :
   |
   |-- EXECUTER capability_apply(caps)
   |     Reduit les privileges selon la politique
   |     SI echec : RETOURNER Erreur

4. PHASE 3 - SECCOMP (point de non-retour #3) :
   |
   |-- COMPILER politique en BPF
   |-- INSTALLER filtre via SYS_seccomp
   |     SI echec : RETOURNER Erreur
   |     NOTE: Plus aucun moyen d'ajouter des privileges

5. RETOURNER Succes (0)
```

### 5.2.4 Diagramme Mermaid

```mermaid
graph TD
    A[Debut: sandbox_apply_full] --> B{seccomp && caps == NULL ?}
    B -- Oui --> C[RETOUR: -EINVAL]
    B -- Non --> D{caps->no_new_privs ?}

    D -- Oui --> E[prctl PR_SET_NO_NEW_PRIVS]
    E --> F{Succes ?}
    F -- Non --> G[RETOUR: -errno]
    F -- Oui --> H{caps != NULL ?}

    D -- Non --> H

    H -- Oui --> I[capability_apply]
    I --> J{Succes ?}
    J -- Non --> K[RETOUR: erreur caps]
    J -- Oui --> L{seccomp != NULL ?}

    H -- Non --> L

    L -- Oui --> M[Compiler BPF]
    M --> N[syscall SYS_seccomp]
    N --> O{Succes ?}
    O -- Non --> P[RETOUR: -errno]
    O -- Oui --> Q[RETOUR: 0 Succes]

    L -- Non --> Q

    style E fill:#ff9999
    style I fill:#ff9999
    style N fill:#ff9999
    style Q fill:#99ff99
```

### 5.3 Visualisation ASCII

```
                    ARCHITECTURE SECCOMP-BPF
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│   ESPACE UTILISATEUR                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  Processus sandboxe                                               │  │
│   │  ┌─────────────────┐                                              │  │
│   │  │   Code App      │                                              │  │
│   │  │   ┌───────────┐ │                                              │  │
│   │  │   │ syscall() │─┼──────────┐                                   │  │
│   │  │   └───────────┘ │          │                                   │  │
│   │  └─────────────────┘          │                                   │  │
│   └───────────────────────────────┼──────────────────────────────────┘  │
│                                   │                                     │
│ ══════════════════════════════════╪═══════════════════════════════════  │
│                                   │                                     │
│   ESPACE KERNEL                   ▼                                     │
│   ┌───────────────────────────────────────────────────────────────────┐ │
│   │                        FILTRE SECCOMP-BPF                          │ │
│   │  ┌─────────────────────────────────────────────────────────────┐  │ │
│   │  │  1. Charger ARCH    ──► BPF_LD [arch_offset]                │  │ │
│   │  │  2. Verifier x86_64 ──► BPF_JEQ AUDIT_ARCH_X86_64 → ou KILL │  │ │
│   │  │  3. Charger NR      ──► BPF_LD [nr_offset]                  │  │ │
│   │  │  4. Comparer        ──► BPF_JEQ syscall_1 → ALLOW           │  │ │
│   │  │  5. Comparer        ──► BPF_JEQ syscall_2 → ALLOW           │  │ │
│   │  │  ...                                                         │  │ │
│   │  │  N. Default         ──► BPF_RET KILL/ERRNO/ALLOW            │  │ │
│   │  └─────────────────────────────────────────────────────────────┘  │ │
│   │                                                                    │ │
│   │  RESULTAT:                                                         │ │
│   │  ┌──────────────┬───────────────────────────────────────────────┐ │ │
│   │  │ RET_ALLOW    │ Syscall execute normalement                   │ │ │
│   │  │ RET_KILL     │ Processus tue (SIGKILL)                       │ │ │
│   │  │ RET_ERRNO(n) │ Syscall echoue avec errno = n                 │ │ │
│   │  │ RET_TRAP     │ Signal SIGSYS envoye                          │ │ │
│   │  │ RET_TRACE    │ Notification au ptrace                        │ │ │
│   │  │ RET_USER_NOTIF│ Notification userspace (superviseur)         │ │ │
│   │  └──────────────┴───────────────────────────────────────────────┘ │ │
│   └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘


                    HIERARCHIE DES CAPABILITIES
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│   ENSEMBLE COMPLET (root traditionnel = TOUTES les capabilities)        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐           │   │
│   │ │ CAP_SYS_ADMIN │ │ CAP_NET_ADMIN │ │ CAP_SYS_PTRACE│           │   │
│   │ │ (God mode)    │ │ (Reseau)      │ │ (Debug)       │           │   │
│   │ └───────────────┘ └───────────────┘ └───────────────┘           │   │
│   │ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐           │   │
│   │ │ CAP_DAC_*     │ │ CAP_CHOWN     │ │ CAP_SETUID    │           │   │
│   │ │ (Bypass DAC)  │ │ (chown files) │ │ (Change UID)  │           │   │
│   │ └───────────────┘ └───────────────┘ └───────────────┘           │   │
│   │                        ... (~40 capabilities) ...                │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                │                                        │
│                     capability_drop()                                   │
│                                │                                        │
│                                ▼                                        │
│   ENSEMBLE REDUIT (apres sandboxing)                                    │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │ ┌───────────────────────┐                                       │   │
│   │ │ CAP_NET_BIND_SERVICE  │  ← Seule capability gardee            │   │
│   │ │ (Bind port < 1024)    │    pour un serveur web                │   │
│   │ └───────────────────────┘                                       │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│   NO_NEW_PRIVS active = IMPOSSIBLE de regagner les capabilities!        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Consequence | Prevention |
|-------|-------------|-------------|------------|
| **Oubli validation arch** | Pas de check AUDIT_ARCH | Attaque x32 ABI | Toujours verifier l'architecture |
| **Ordre incorrect** | seccomp avant NO_NEW_PRIVS | EPERM sans root | NO_NEW_PRIVS → CAPS → SECCOMP |
| **Fuite memoire BPF** | Pas de free() apres erreur | Memory leak | free() dans tous les chemins |
| **Capabilities incompletes** | Oublier bounding set | Privileges residuels | Nettoyer tous les ensembles |
| **TOCTOU notifications** | Pas de check pid_valid | Race condition | Toujours verifier l'ID |

### 5.5 Cours Complet

#### 5.5.1 Introduction a Seccomp

Seccomp (Secure Computing Mode) est un mecanisme de securite du noyau Linux qui restreint les appels systeme disponibles pour un processus. Introduit en 2005, il a evolue en trois modes :

**Mode STRICT (original) :**
```c
prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);
// Seuls read(), write(), exit(), sigreturn() autorises
```

**Mode FILTER (BPF) :**
```c
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);
// ou
syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, flags, &prog);
```

#### 5.5.2 Structure BPF pour Seccomp

Le filtre BPF opere sur une structure `seccomp_data` :

```c
struct seccomp_data {
    int   nr;                    // Numero syscall
    __u32 arch;                  // Architecture (AUDIT_ARCH_*)
    __u64 instruction_pointer;   // IP au moment du syscall
    __u64 args[6];               // Arguments du syscall
};
```

**Instructions BPF fondamentales :**

| Instruction | Description |
|-------------|-------------|
| `BPF_LD \| BPF_W \| BPF_ABS` | Charger 32 bits depuis offset |
| `BPF_JMP \| BPF_JEQ \| BPF_K` | Sauter si A == constante |
| `BPF_RET \| BPF_K` | Retourner une constante |

#### 5.5.3 Linux Capabilities en Detail

Les capabilities decomposent les privileges root :

**Ensembles de capabilities :**

| Ensemble | Role |
|----------|------|
| **Effective** | Capabilities actives pour les checks |
| **Permitted** | Capabilities que le processus PEUT activer |
| **Inheritable** | Capabilities passees aux enfants (avec conditions) |
| **Bounding** | Limite superieure des capabilities possibles |
| **Ambient** | Capabilities automatiquement heritees (depuis Linux 4.3) |

**Capabilities importantes :**

| Capability | Pouvoir |
|------------|---------|
| CAP_SYS_ADMIN | "God mode" - presque tout |
| CAP_NET_BIND_SERVICE | Binder ports < 1024 |
| CAP_DAC_OVERRIDE | Ignorer les permissions fichiers |
| CAP_SYS_PTRACE | ptrace() n'importe quel processus |
| CAP_NET_RAW | Sockets raw, sniffing |

#### 5.5.4 NO_NEW_PRIVS

Le flag `NO_NEW_PRIVS` est crucial pour le sandboxing :

```c
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
```

**Effets :**
- Impossible de gagner des privileges via execve() (setuid/setgid ignores)
- Herite par tous les processus enfants
- IRREVERSIBLE - ne peut jamais etre desactive
- NECESSAIRE pour installer un filtre seccomp sans CAP_SYS_ADMIN

### 5.6 Normes avec explications pedagogiques

```
┌─────────────────────────────────────────────────────────────────┐
│ HORS NORME (compile, mais interdit)                             │
├─────────────────────────────────────────────────────────────────┤
│ if(caps==NULL||cap<0||cap>63)return -EINVAL;                   │
├─────────────────────────────────────────────────────────────────┤
│ CONFORME                                                        │
├─────────────────────────────────────────────────────────────────┤
│ if (caps == NULL || cap < 0 || cap > 63)                       │
│     return (-EINVAL);                                           │
├─────────────────────────────────────────────────────────────────┤
│ POURQUOI ?                                                      │
│                                                                 │
│ - Espaces autour des operateurs : lisibilite                    │
│ - Parentheses autour du return : coherence                      │
│ - Une condition par concept : maintenabilite                    │
└─────────────────────────────────────────────────────────────────┘
```

### 5.7 Simulation avec trace d'execution

**Scenario : sandbox_apply_full avec politique minimale**

```
┌───────┬─────────────────────────────────────────────────┬────────────────────┐
│ Etape │ Instruction                                     │ Etat               │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   1   │ VERIFIER seccomp != NULL ET caps != NULL       │ seccomp=valid      │
│       │                                                 │ caps=valid         │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   2   │ VERIFIER caps->no_new_privs == true            │ VRAI               │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   3   │ APPELER prctl(PR_SET_NO_NEW_PRIVS, 1)          │ ret=0 (succes)     │
│       │                                                 │ IRREVERSIBLE!      │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   4   │ APPELER capability_apply(caps)                  │ Privileges reduits │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   5   │ COMPILER politique BPF                          │ filter[] cree      │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   6   │ APPELER syscall(SYS_seccomp, FILTER, &prog)    │ Filtre installe    │
│       │                                                 │ IRREVERSIBLE!      │
├───────┼─────────────────────────────────────────────────┼────────────────────┤
│   7   │ RETOURNER 0                                     │ Sandbox actif      │
└───────┴─────────────────────────────────────────────────┴────────────────────┘
```

### 5.8 Mnemotechniques (MEME obligatoire)

#### MEME : "YOU SHALL NOT PASS!" - Gandalf et Seccomp

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│        "YOU SHALL NOT PASS!" - Gandalf sur le pont              │
│                                                                 │
│   Le kernel Linux = Gandalf                                     │
│   Les syscalls = Les Balrogs qui veulent passer                 │
│   Le filtre BPF = Le baton de Gandalf                           │
│                                                                 │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐       │
│   │   ptrace    │ --> │   SECCOMP   │ --> │   BLOCKED   │       │
│   │  (Balrog)   │     │  (Gandalf)  │     │   (chute)   │       │
│   └─────────────┘     └─────────────┘     └─────────────┘       │
│                                                                 │
│   Code:                                                         │
│   if (syscall_nr == __NR_ptrace)                               │
│       return SECCOMP_RET_KILL;  // "YOU SHALL NOT PASS!"        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### MEME : "One does not simply..." - Boromir et NO_NEW_PRIVS

```
"One does not simply... regain privileges after NO_NEW_PRIVS"

┌─────────────────────────────────────────────────────────────────┐
│   prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);                      │
│                                                                 │
│   // A partir d'ici, c'est comme entrer au Mordor :            │
│   // - Impossible de revenir en arriere                         │
│   // - setuid binaries ne donnent plus de pouvoirs              │
│   // - Les enfants heritent de la restriction                   │
│   // - C'est DEFINITIF                                          │
│                                                                 │
│   "One does not simply prctl(PR_UNSET_NO_NEW_PRIVS)"           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### MEME : "Airport Security" - TSA et Capabilities

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   A l'aeroport :                                                │
│   - Badge PILOTE = CAP_SYS_ADMIN (acces a tout)                │
│   - Badge CREW   = CAP_NET_BIND (acces limite)                 │
│   - Badge VIP    = CAP_DAC_OVERRIDE (passe-droit fichiers)     │
│   - Pas de badge = Utilisateur normal                           │
│                                                                 │
│   NO_NEW_PRIVS = "Votre badge a ete confisque definitivement"   │
│                  "Vous ne pouvez plus en obtenir un nouveau"    │
│                                                                 │
│   Seccomp = "Liste des objets interdits en cabine"              │
│             read/write = OK (livre, stylo)                      │
│             ptrace/mount = INTERDIT (armes, explosifs)          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.9 Applications pratiques

| Application | Utilisation Seccomp/Capabilities |
|-------------|----------------------------------|
| **Chrome/Chromium** | Renderer sandboxe avec ~50 syscalls |
| **Docker** | Profil seccomp par defaut (313 syscalls bloques) |
| **systemd** | Services avec CapabilityBoundingSet |
| **Firefox** | Sandboxing du processus content |
| **OpenSSH** | Privilege separation |

---

## 6. PIEGES - RECAPITULATIF

| # | Piege | Erreur | Impact | Solution |
|---|-------|--------|--------|----------|
| 1 | Pas de check arch | Filtrage contourne | Exploitation x32 | Toujours BPF_JEQ AUDIT_ARCH |
| 2 | Ordre incorrect | EPERM | Sandbox echoue | NO_NEW_PRIVS d'abord |
| 3 | Fuite memoire | Leak | DoS memoire | free() dans tous les chemins |
| 4 | NULL dereference | Crash | Crash service | Toujours verifier NULL |
| 5 | Capabilities incompletes | Privileges residuels | Bypass sandbox | Nettoyer tous les sets |

---

## 7. QCM

### Question 1
**Quel est le mode seccomp le plus restrictif introduit en 2005 ?**

A) SECCOMP_MODE_FILTER
B) SECCOMP_MODE_STRICT
C) SECCOMP_MODE_BPF
D) SECCOMP_MODE_AUDIT
E) SECCOMP_MODE_DISABLED
F) SECCOMP_MODE_NONE
G) SECCOMP_MODE_TRACE
H) SECCOMP_MODE_KILL
I) SECCOMP_MODE_ALLOW
J) SECCOMP_MODE_LOG

**Reponse : B**
*SECCOMP_MODE_STRICT n'autorise que read, write, exit, sigreturn*

---

### Question 2
**Pourquoi faut-il verifier AUDIT_ARCH_X86_64 dans un filtre seccomp ?**

A) Pour optimiser les performances
B) Pour la compatibilite ARM
C) Pour prevenir les attaques x32 ABI
D) Pour supporter le mode 32 bits
E) Pour le debugging
F) Pour la journalisation
G) Pour la compatibilite systemd
H) Pour le fuzzing
I) Pour les conteneurs
J) Pour les VM

**Reponse : C**
*L'ABI x32 permet de contourner les filtres si l'architecture n'est pas verifiee*

---

### Question 3
**Quel est l'ordre correct pour appliquer un sandbox complet ?**

A) SECCOMP → CAPS → NO_NEW_PRIVS
B) CAPS → SECCOMP → NO_NEW_PRIVS
C) NO_NEW_PRIVS → SECCOMP → CAPS
D) NO_NEW_PRIVS → CAPS → SECCOMP
E) CAPS → NO_NEW_PRIVS → SECCOMP
F) SECCOMP → NO_NEW_PRIVS → CAPS
G) L'ordre n'a pas d'importance
H) Seulement SECCOMP suffit
I) Seulement CAPS suffit
J) Seulement NO_NEW_PRIVS suffit

**Reponse : D**
*NO_NEW_PRIVS requis pour seccomp sans root, CAPS avant SECCOMP pour coherence*

---

### Question 4
**Que fait SECCOMP_RET_USER_NOTIF ?**

A) Tue le processus
B) Retourne une erreur
C) Envoie une notification a un superviseur userspace
D) Log le syscall
E) Autorise le syscall
F) Bloque indefiniment
G) Envoie SIGSYS
H) Notifie ptrace
I) Cree un core dump
J) Relance le syscall

**Reponse : C**
*USER_NOTIF permet a un processus superviseur de traiter le syscall*

---

### Question 5
**Quelle capability permet de binder un port < 1024 ?**

A) CAP_SYS_ADMIN
B) CAP_NET_ADMIN
C) CAP_NET_BIND_SERVICE
D) CAP_NET_RAW
E) CAP_SYS_RESOURCE
F) CAP_DAC_OVERRIDE
G) CAP_CHOWN
H) CAP_SETUID
I) CAP_SYS_PTRACE
J) CAP_IPC_LOCK

**Reponse : C**
*CAP_NET_BIND_SERVICE est specifiquement pour les ports privilegies*

---

### Question 6
**Qu'est-ce que le bounding set des capabilities ?**

A) Les capabilities actives
B) Les capabilities heritables
C) La limite superieure des capabilities possibles
D) Les capabilities par defaut
E) Les capabilities du kernel
F) Les capabilities root
G) Les capabilities minimales
H) Les capabilities maximales
I) Les capabilities temporaires
J) Les capabilities permanentes

**Reponse : C**
*Le bounding set limite quelles capabilities peuvent etre acquises*

---

### Question 7
**Que se passe-t-il si on appelle seccomp sans NO_NEW_PRIVS et sans CAP_SYS_ADMIN ?**

A) Le syscall reussit
B) Le processus est tue
C) EPERM est retourne
D) Le filtre est partiellement applique
E) Le kernel panic
F) Un warning est affiche
G) Le syscall est ignore
H) Une notification est envoyee
I) Le processus est suspendu
J) EINVAL est retourne

**Reponse : C**
*Sans privileges, installer un filtre seccomp echoue avec EPERM*

---

### Question 8
**Quelle instruction BPF charge le numero du syscall ?**

A) BPF_RET
B) BPF_JMP
C) BPF_LD | BPF_W | BPF_ABS
D) BPF_ST
E) BPF_ALU
F) BPF_MISC
G) BPF_LDX
H) BPF_STX
I) BPF_JA
J) BPF_TAX

**Reponse : C**
*BPF_LD avec BPF_ABS charge depuis un offset dans seccomp_data*

---

### Question 9
**Pourquoi les sauts arriere sont-ils interdits dans les filtres seccomp BPF ?**

A) Pour les performances
B) Pour eviter les boucles infinies
C) Pour la compatibilite
D) Pour la securite du kernel
E) Pour la simplicite
F) Pour le debugging
G) Pour la portabilite
H) A et B
I) B et D
J) Toutes les reponses

**Reponse : I**
*Les boucles pourraient bloquer le kernel (DoS) et compromettre la securite*

---

### Question 10
**Qu'est-ce que le probleme TOCTOU dans les notifications userspace seccomp ?**

A) Time Of Check To Time Of Use - race condition
B) Type Of Content Type Of User
C) Transfer Of Control Transfer Of Use
D) Test Of Code Test Of User
E) Time Of Compilation Time Of Usage
F) Type Of Check Type Of Use
G) Transfer Of Check Transfer Of Use
H) Test Of Content Test Of Use
I) Time Of Code Time Of User
J) Type Of Compilation Type Of Usage

**Reponse : A**
*Entre la notification et la reponse, le processus peut avoir change*

---

## 8. RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Exercice** | M2.10_Ex04 - sandbox_enforcer |
| **Difficulte** | 8/10 (★★★★★★★★☆☆) |
| **Concepts** | Seccomp-BPF, Capabilities, NO_NEW_PRIVS |
| **Temps** | ~360 min |
| **XP Base** | 500 |
| **Bonus** | Expert (x4) |
| **Langage** | C17 |
| **Pieges principaux** | Ordre operations, validation arch, TOCTOU |

---

## 9. DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.10.4-d-sandbox-enforcer",
    "generated_at": "2026-01-16 00:00:00",

    "metadata": {
      "exercise_id": "M2.10_Ex04",
      "exercise_name": "sandbox_enforcer",
      "module": "2.10",
      "module_name": "Conteneurs, Virtualisation et Sujets Avances",
      "concept": "d",
      "concept_name": "Seccomp-BPF et Linux Capabilities",
      "type": "complet",
      "tier": 3,
      "tier_info": "Synthese (seccomp + capabilities + BPF + no_new_privs)",
      "phase": 3,
      "difficulty": 8,
      "difficulty_stars": "★★★★★★★★☆☆",
      "language": "c",
      "language_version": "C17",
      "duration_minutes": 360,
      "xp_base": 500,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "bonus_icon": "💀",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(1)",
      "prerequisites": [
        "Appels systeme Linux",
        "Programmation systeme avancee",
        "Structures de donnees C",
        "Gestion memoire"
      ],
      "domains": ["Mem", "Process", "Crypto"],
      "domains_bonus": ["CPU"],
      "tags": ["seccomp", "capabilities", "bpf", "sandbox", "security", "linux", "kernel"],
      "meme_reference": "YOU SHALL NOT PASS - Gandalf"
    },

    "files": {
      "spec.json": "Section 4.9",
      "references/ref_solution.c": "Section 4.3",
      "references/ref_solution_bonus.c": "Section 4.6",
      "alternatives/alt_1.c": "Section 4.4",
      "mutants/mutant_a_boundary.c": "Section 4.10",
      "mutants/mutant_b_safety.c": "Section 4.10",
      "mutants/mutant_c_resource.c": "Section 4.10",
      "mutants/mutant_d_logic.c": "Section 4.10",
      "mutants/mutant_e_return.c": "Section 4.10",
      "tests/main.c": "Section 4.2"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.c",
        "references/ref_solution_bonus.c",
        "alternatives/alt_1.c"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.c",
        "mutants/mutant_b_safety.c",
        "mutants/mutant_c_resource.c",
        "mutants/mutant_d_logic.c",
        "mutants/mutant_e_return.c"
      ]
    },

    "commands": {
      "compile": "gcc -Wall -Wextra -Werror -std=c17 -D_GNU_SOURCE sandbox_enforcer.c main.c -o test",
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_solution.c",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.c -s spec.json --validate"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "L'excellence pedagogique ne se negocie pas"*
*Compatible ENGINE v22.1 + Mutation Tester*
