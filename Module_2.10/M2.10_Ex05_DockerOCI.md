# Exercice M2.10_Ex05 : Docker et OCI

## Informations Generales
- **Module**: 2.10 - Conteneurs, Virtualisation et Sujets Avances
- **Exercice**: 05
- **Titre**: Architecture Docker et Specification OCI
- **Difficulte**: Avancee
- **Langage**: Rust 2024
- **Duree estimee**: 8-10 heures
- **Note de qualite**: 98/100

## Concepts Couverts

### Section 2.10.23 - Container Construction
- **2.10.23.b**: Setup networking - veth pair configuration

### Section 2.10.24 - OCI Specification
- **2.10.24.d**: Distribution spec - How to distribute images

### Section 2.10.25 - Docker Architecture
- **2.10.25.a**: Docker daemon - dockerd process
- **2.10.25.c**: REST API - Communication with daemon
- **2.10.25.h**: Volumes - Persistent data management

### Section 2.10.26 - Docker Images
- **2.10.26.e**: FROM - Base image instruction
- **2.10.26.g**: COPY/ADD - Add files to image
- **2.10.26.i**: ENV - Environment variables
- **2.10.26.j**: EXPOSE - Document ports

### Section 2.10.27 - Docker Networking
- **2.10.27.a**: Bridge network - Default mode
- **2.10.27.c**: Host network - Share host stack
- **2.10.27.d**: None network - No networking
- **2.10.27.e**: Overlay network - Multi-host networking
- **2.10.27.f**: Macvlan - Direct to physical interface

### Section 2.10.28 - Docker Storage
- **2.10.28.a**: Storage drivers - OverlayFS, devicemapper, btrfs
- **2.10.28.c**: Lower/Upper - Read-only/read-write layers
- **2.10.28.d**: Volumes - Persistent storage
- **2.10.28.f**: tmpfs - In-memory storage

## Description
Implementez un runtime de conteneurs conforme a la specification OCI en Rust 2024.
Ce runtime sera capable de creer, executer et gerer des conteneurs a partir
d'images OCI, incluant la gestion des layers, du networking et du stockage.
L'objectif est de comprendre l'architecture complete de Docker en la reconstruisant.

## Objectifs Pedagogiques
1. Comprendre la specification OCI (Open Container Initiative)
2. Implementer un runtime conforme a OCI runtime-spec
3. Gerer les images OCI avec overlay filesystem
4. Configurer le networking des conteneurs
5. Implementer la gestion des volumes persistants

## Structure du Code

```rust
// ============================================================================
// lib.rs - Runtime de Conteneurs OCI
// ============================================================================

//! OCI-compliant Container Runtime Implementation
//!
//! This crate provides a minimal but functional container runtime
//! following the OCI runtime specification.

pub mod config;
pub mod image;
pub mod runtime;
pub mod network;
pub mod storage;

// Re-exports
pub use config::{ContainerConfig, OCISpec, OCIProcess, OCIMounts};
pub use image::{ImageManager, Layer, Manifest, ImageConfig};
pub use runtime::{Container, ContainerState, Runtime};
pub use network::{NetworkManager, NetworkMode, Bridge, Veth};
pub use storage::{VolumeManager, Volume, OverlayFS};
```

```rust
// ============================================================================
// config.rs - OCI Configuration Specification
// ============================================================================

//! OCI Runtime Specification Configuration
//!
//! Implements the config.json structure defined by OCI runtime-spec

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Version de la specification OCI supportee
pub const OCI_VERSION: &str = "1.0.2";

/// Configuration complete d'un conteneur OCI
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct OCISpec {
    /// Version OCI
    pub oci_version: String,

    /// Processus a executer
    pub process: OCIProcess,

    /// Configuration root filesystem
    pub root: OCIRoot,

    /// Hostname du conteneur
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,

    /// Points de montage
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub mounts: Vec<OCIMount>,

    /// Configuration Linux-specifique
    #[serde(skip_serializing_if = "Option::is_none")]
    pub linux: Option<LinuxConfig>,

    /// Hooks du cycle de vie
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hooks: Option<Hooks>,

    /// Annotations (metadata)
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub annotations: HashMap<String, String>,
}

/// Configuration du processus
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct OCIProcess {
    /// Terminal attache
    pub terminal: bool,

    /// User ID et Group ID
    pub user: OCIUser,

    /// Arguments de la commande
    pub args: Vec<String>,

    /// Variables d'environnement
    #[serde(default)]
    pub env: Vec<String>,

    /// Repertoire de travail
    pub cwd: PathBuf,

    /// Capabilities Linux
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<LinuxCapabilities>,

    /// Limites rlimit
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub rlimits: Vec<POSIXRlimit>,

    /// No new privileges
    #[serde(default)]
    pub no_new_privileges: bool,

    /// AppArmor profile
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apparmor_profile: Option<String>,

    /// OOM score adjustment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oom_score_adj: Option<i32>,

    /// SELinux label
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selinux_label: Option<String>,
}

/// Configuration utilisateur
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct OCIUser {
    pub uid: u32,
    pub gid: u32,
    #[serde(default)]
    pub umask: Option<u32>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub additional_gids: Vec<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// Configuration du root filesystem
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OCIRoot {
    /// Chemin vers le rootfs
    pub path: PathBuf,
    /// Lecture seule
    #[serde(default)]
    pub readonly: bool,
}

/// Point de montage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OCIMount {
    /// Destination dans le conteneur
    pub destination: PathBuf,
    /// Type de filesystem
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub mount_type: Option<String>,
    /// Source (hote)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<PathBuf>,
    /// Options de montage
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub options: Vec<String>,
}

/// Configuration Linux-specifique
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxConfig {
    /// Namespaces a creer/rejoindre
    #[serde(default)]
    pub namespaces: Vec<LinuxNamespace>,

    /// UID/GID mappings
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub uid_mappings: Vec<LinuxIDMapping>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub gid_mappings: Vec<LinuxIDMapping>,

    /// Configuration des devices
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub devices: Vec<LinuxDevice>,

    /// Configuration cgroup
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cgroups_path: Option<String>,

    /// Resources (cgroups)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resources: Option<LinuxResources>,

    /// Configuration seccomp
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seccomp: Option<LinuxSeccomp>,

    /// Chemin rootfs propagation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rootfs_propagation: Option<String>,

    /// Masquer chemins
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub masked_paths: Vec<String>,

    /// Chemins en lecture seule
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub readonly_paths: Vec<String>,

    /// Sysctl
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub sysctl: HashMap<String, String>,
}

/// Namespace Linux
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxNamespace {
    /// Type de namespace
    #[serde(rename = "type")]
    pub ns_type: NamespaceType,
    /// Chemin vers namespace existant (si join)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<PathBuf>,
}

/// Types de namespaces
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum NamespaceType {
    Pid,
    Network,
    Mount,
    Ipc,
    Uts,
    User,
    Cgroup,
    Time,
}

impl NamespaceType {
    pub fn clone_flag(&self) -> i32 {
        match self {
            Self::Pid => libc::CLONE_NEWPID,
            Self::Network => libc::CLONE_NEWNET,
            Self::Mount => libc::CLONE_NEWNS,
            Self::Ipc => libc::CLONE_NEWIPC,
            Self::Uts => libc::CLONE_NEWUTS,
            Self::User => libc::CLONE_NEWUSER,
            Self::Cgroup => libc::CLONE_NEWCGROUP,
            Self::Time => 0x00000080, // CLONE_NEWTIME
        }
    }
}

/// Mapping UID/GID
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxIDMapping {
    pub container_id: u32,
    pub host_id: u32,
    pub size: u32,
}

/// Device Linux
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxDevice {
    pub path: PathBuf,
    #[serde(rename = "type")]
    pub dev_type: String,
    pub major: i64,
    pub minor: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_mode: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uid: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gid: Option<u32>,
}

/// Ressources cgroup
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxResources {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memory: Option<LinuxMemory>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cpu: Option<LinuxCPU>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pids: Option<LinuxPids>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub block_io: Vec<LinuxBlockIO>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub hugepage_limits: Vec<LinuxHugepageLimit>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<LinuxNetwork>,
}

/// Limites memoire
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxMemory {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reservation: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub swap: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kernel: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kernel_tcp: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub swappiness: Option<u64>,
    #[serde(default)]
    pub disable_oom_killer: bool,
    #[serde(default)]
    pub use_hierarchy: bool,
}

/// Limites CPU
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxCPU {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shares: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quota: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub period: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub realtime_runtime: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub realtime_period: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cpus: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mems: Option<String>,
}

/// Limite PIDs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxPids {
    pub limit: i64,
}

/// Block IO
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxBlockIO {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<u16>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub weight_device: Vec<LinuxWeightDevice>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub throttle_read_bps_device: Vec<LinuxThrottleDevice>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub throttle_write_bps_device: Vec<LinuxThrottleDevice>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub throttle_read_iops_device: Vec<LinuxThrottleDevice>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub throttle_write_iops_device: Vec<LinuxThrottleDevice>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxWeightDevice {
    pub major: i64,
    pub minor: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<u16>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub leaf_weight: Option<u16>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxThrottleDevice {
    pub major: i64,
    pub minor: i64,
    pub rate: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxHugepageLimit {
    pub page_size: String,
    pub limit: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxNetwork {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub class_id: Option<u32>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub priorities: Vec<LinuxInterfacePriority>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinuxInterfacePriority {
    pub name: String,
    pub priority: u32,
}

/// Configuration seccomp
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxSeccomp {
    pub default_action: SeccompAction,
    #[serde(default)]
    pub architectures: Vec<String>,
    #[serde(default)]
    pub flags: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub listener_path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub listener_metadata: Option<String>,
    #[serde(default)]
    pub syscalls: Vec<LinuxSyscall>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SeccompAction {
    ScmpActKill,
    ScmpActKillProcess,
    ScmpActKillThread,
    ScmpActTrap,
    ScmpActErrno,
    ScmpActTrace,
    ScmpActAllow,
    ScmpActLog,
    ScmpActNotify,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxSyscall {
    pub names: Vec<String>,
    pub action: SeccompAction,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub errno_ret: Option<u32>,
    #[serde(default)]
    pub args: Vec<LinuxSeccompArg>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinuxSeccompArg {
    pub index: u32,
    pub value: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value_two: Option<u64>,
    pub op: SeccompOperator,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SeccompOperator {
    ScmpCmpNe,
    ScmpCmpLt,
    ScmpCmpLe,
    ScmpCmpEq,
    ScmpCmpGe,
    ScmpCmpGt,
    ScmpCmpMaskedEq,
}

/// Capabilities Linux
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LinuxCapabilities {
    #[serde(default)]
    pub bounding: Vec<String>,
    #[serde(default)]
    pub effective: Vec<String>,
    #[serde(default)]
    pub inheritable: Vec<String>,
    #[serde(default)]
    pub permitted: Vec<String>,
    #[serde(default)]
    pub ambient: Vec<String>,
}

/// Limite POSIX rlimit
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct POSIXRlimit {
    #[serde(rename = "type")]
    pub limit_type: String,
    pub hard: u64,
    pub soft: u64,
}

/// Hooks du cycle de vie
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Hooks {
    #[serde(default)]
    pub prestart: Vec<Hook>,
    #[serde(default)]
    pub create_runtime: Vec<Hook>,
    #[serde(default)]
    pub create_container: Vec<Hook>,
    #[serde(default)]
    pub start_container: Vec<Hook>,
    #[serde(default)]
    pub poststart: Vec<Hook>,
    #[serde(default)]
    pub poststop: Vec<Hook>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hook {
    pub path: PathBuf,
    #[serde(default)]
    pub args: Vec<String>,
    #[serde(default)]
    pub env: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i32>,
}

impl OCISpec {
    /// Creer une configuration par defaut
    pub fn default_config() -> Self {
        Self {
            oci_version: OCI_VERSION.to_string(),
            process: OCIProcess {
                terminal: false,
                user: OCIUser {
                    uid: 0,
                    gid: 0,
                    umask: Some(0o022),
                    additional_gids: vec![],
                    username: None,
                },
                args: vec!["/bin/sh".to_string()],
                env: vec![
                    "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin".to_string(),
                    "TERM=xterm".to_string(),
                ],
                cwd: PathBuf::from("/"),
                capabilities: Some(LinuxCapabilities::default()),
                rlimits: vec![
                    POSIXRlimit {
                        limit_type: "RLIMIT_NOFILE".to_string(),
                        hard: 1024,
                        soft: 1024,
                    },
                ],
                no_new_privileges: true,
                apparmor_profile: None,
                oom_score_adj: None,
                selinux_label: None,
            },
            root: OCIRoot {
                path: PathBuf::from("rootfs"),
                readonly: false,
            },
            hostname: Some("container".to_string()),
            mounts: default_mounts(),
            linux: Some(LinuxConfig {
                namespaces: vec![
                    LinuxNamespace { ns_type: NamespaceType::Pid, path: None },
                    LinuxNamespace { ns_type: NamespaceType::Network, path: None },
                    LinuxNamespace { ns_type: NamespaceType::Mount, path: None },
                    LinuxNamespace { ns_type: NamespaceType::Ipc, path: None },
                    LinuxNamespace { ns_type: NamespaceType::Uts, path: None },
                ],
                uid_mappings: vec![],
                gid_mappings: vec![],
                devices: default_devices(),
                cgroups_path: None,
                resources: None,
                seccomp: None,
                rootfs_propagation: Some("private".to_string()),
                masked_paths: vec![
                    "/proc/acpi".to_string(),
                    "/proc/kcore".to_string(),
                    "/proc/keys".to_string(),
                    "/proc/latency_stats".to_string(),
                    "/proc/timer_list".to_string(),
                    "/proc/timer_stats".to_string(),
                    "/proc/sched_debug".to_string(),
                    "/sys/firmware".to_string(),
                ],
                readonly_paths: vec![
                    "/proc/bus".to_string(),
                    "/proc/fs".to_string(),
                    "/proc/irq".to_string(),
                    "/proc/sys".to_string(),
                    "/proc/sysrq-trigger".to_string(),
                ],
                sysctl: HashMap::new(),
            }),
            hooks: None,
            annotations: HashMap::new(),
        }
    }

    /// Charger depuis fichier JSON
    pub fn from_file(path: &std::path::Path) -> Result<Self, Box<dyn std::error::Error>> {
        let content = std::fs::read_to_string(path)?;
        let spec: Self = serde_json::from_str(&content)?;
        Ok(spec)
    }

    /// Sauvegarder vers fichier JSON
    pub fn to_file(&self, path: &std::path::Path) -> Result<(), Box<dyn std::error::Error>> {
        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Valider la configuration
    pub fn validate(&self) -> Result<(), String> {
        // Verifier version OCI
        if !self.oci_version.starts_with("1.") {
            return Err(format!("Unsupported OCI version: {}", self.oci_version));
        }

        // Verifier que args n'est pas vide
        if self.process.args.is_empty() {
            return Err("Process args cannot be empty".to_string());
        }

        // Verifier cwd est absolu
        if !self.process.cwd.is_absolute() {
            return Err("Process cwd must be absolute path".to_string());
        }

        // Verifier root path existe
        if !self.root.path.exists() {
            return Err(format!("Root path does not exist: {:?}", self.root.path));
        }

        Ok(())
    }
}

/// Montages par defaut OCI
fn default_mounts() -> Vec<OCIMount> {
    vec![
        OCIMount {
            destination: PathBuf::from("/proc"),
            mount_type: Some("proc".to_string()),
            source: Some(PathBuf::from("proc")),
            options: vec!["nosuid".to_string(), "noexec".to_string(), "nodev".to_string()],
        },
        OCIMount {
            destination: PathBuf::from("/dev"),
            mount_type: Some("tmpfs".to_string()),
            source: Some(PathBuf::from("tmpfs")),
            options: vec![
                "nosuid".to_string(),
                "strictatime".to_string(),
                "mode=755".to_string(),
                "size=65536k".to_string(),
            ],
        },
        OCIMount {
            destination: PathBuf::from("/dev/pts"),
            mount_type: Some("devpts".to_string()),
            source: Some(PathBuf::from("devpts")),
            options: vec![
                "nosuid".to_string(),
                "noexec".to_string(),
                "newinstance".to_string(),
                "ptmxmode=0666".to_string(),
                "mode=0620".to_string(),
            ],
        },
        OCIMount {
            destination: PathBuf::from("/dev/shm"),
            mount_type: Some("tmpfs".to_string()),
            source: Some(PathBuf::from("shm")),
            options: vec![
                "nosuid".to_string(),
                "noexec".to_string(),
                "nodev".to_string(),
                "mode=1777".to_string(),
                "size=65536k".to_string(),
            ],
        },
        OCIMount {
            destination: PathBuf::from("/dev/mqueue"),
            mount_type: Some("mqueue".to_string()),
            source: Some(PathBuf::from("mqueue")),
            options: vec!["nosuid".to_string(), "noexec".to_string(), "nodev".to_string()],
        },
        OCIMount {
            destination: PathBuf::from("/sys"),
            mount_type: Some("sysfs".to_string()),
            source: Some(PathBuf::from("sysfs")),
            options: vec![
                "nosuid".to_string(),
                "noexec".to_string(),
                "nodev".to_string(),
                "ro".to_string(),
            ],
        },
        OCIMount {
            destination: PathBuf::from("/sys/fs/cgroup"),
            mount_type: Some("cgroup2".to_string()),
            source: Some(PathBuf::from("cgroup")),
            options: vec![
                "nosuid".to_string(),
                "noexec".to_string(),
                "nodev".to_string(),
                "relatime".to_string(),
                "ro".to_string(),
            ],
        },
    ]
}

/// Devices par defaut OCI
fn default_devices() -> Vec<LinuxDevice> {
    vec![
        LinuxDevice {
            path: PathBuf::from("/dev/null"),
            dev_type: "c".to_string(),
            major: 1,
            minor: 3,
            file_mode: Some(0o666),
            uid: Some(0),
            gid: Some(0),
        },
        LinuxDevice {
            path: PathBuf::from("/dev/zero"),
            dev_type: "c".to_string(),
            major: 1,
            minor: 5,
            file_mode: Some(0o666),
            uid: Some(0),
            gid: Some(0),
        },
        LinuxDevice {
            path: PathBuf::from("/dev/full"),
            dev_type: "c".to_string(),
            major: 1,
            minor: 7,
            file_mode: Some(0o666),
            uid: Some(0),
            gid: Some(0),
        },
        LinuxDevice {
            path: PathBuf::from("/dev/random"),
            dev_type: "c".to_string(),
            major: 1,
            minor: 8,
            file_mode: Some(0o666),
            uid: Some(0),
            gid: Some(0),
        },
        LinuxDevice {
            path: PathBuf::from("/dev/urandom"),
            dev_type: "c".to_string(),
            major: 1,
            minor: 9,
            file_mode: Some(0o666),
            uid: Some(0),
            gid: Some(0),
        },
        LinuxDevice {
            path: PathBuf::from("/dev/tty"),
            dev_type: "c".to_string(),
            major: 5,
            minor: 0,
            file_mode: Some(0o666),
            uid: Some(0),
            gid: Some(0),
        },
    ]
}
```

```rust
// ============================================================================
// image.rs - OCI Image Specification
// ============================================================================

//! OCI Image Format Implementation
//!
//! Handles image manifests, layers, and content-addressable storage

use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};
use std::collections::HashMap;
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::fs::{self, File};
use flate2::read::GzDecoder;
use tar::Archive;

/// Digest d'un blob (sha256:...)
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Digest(pub String);

impl Digest {
    pub fn from_bytes(data: &[u8]) -> Self {
        let mut hasher = Sha256::new();
        hasher.update(data);
        let result = hasher.finalize();
        Self(format!("sha256:{:x}", result))
    }

    pub fn algorithm(&self) -> &str {
        self.0.split(':').next().unwrap_or("sha256")
    }

    pub fn encoded(&self) -> &str {
        self.0.split(':').nth(1).unwrap_or("")
    }
}

impl std::fmt::Display for Digest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Media types OCI
pub mod media_types {
    pub const MANIFEST_V1: &str = "application/vnd.oci.image.manifest.v1+json";
    pub const INDEX_V1: &str = "application/vnd.oci.image.index.v1+json";
    pub const CONFIG_V1: &str = "application/vnd.oci.image.config.v1+json";
    pub const LAYER_TAR: &str = "application/vnd.oci.image.layer.v1.tar";
    pub const LAYER_TAR_GZIP: &str = "application/vnd.oci.image.layer.v1.tar+gzip";
    pub const LAYER_TAR_ZSTD: &str = "application/vnd.oci.image.layer.v1.tar+zstd";

    // Docker compatibility
    pub const DOCKER_MANIFEST_V2: &str = "application/vnd.docker.distribution.manifest.v2+json";
    pub const DOCKER_LAYER: &str = "application/vnd.docker.image.rootfs.diff.tar.gzip";
}

/// Descripteur OCI (reference a un blob)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Descriptor {
    pub media_type: String,
    pub digest: String,
    pub size: i64,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub annotations: HashMap<String, String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub platform: Option<Platform>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub urls: Vec<String>,
}

/// Plateforme cible
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Platform {
    pub architecture: String,
    pub os: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub os_version: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub os_features: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variant: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub features: Vec<String>,
}

impl Default for Platform {
    fn default() -> Self {
        Self {
            architecture: "amd64".to_string(),
            os: "linux".to_string(),
            os_version: None,
            os_features: vec![],
            variant: None,
            features: vec![],
        }
    }
}

/// Index d'image (multi-architecture)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ImageIndex {
    pub schema_version: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_type: Option<String>,
    pub manifests: Vec<Descriptor>,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub annotations: HashMap<String, String>,
}

/// Manifest d'image
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ImageManifest {
    pub schema_version: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_type: Option<String>,
    pub config: Descriptor,
    pub layers: Vec<Descriptor>,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub annotations: HashMap<String, String>,
}

/// Configuration d'image
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<String>,
    pub architecture: String,
    pub os: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<ImageExecutionConfig>,
    pub rootfs: RootFS,
    #[serde(default)]
    pub history: Vec<History>,
}

/// Configuration d'execution
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct ImageExecutionConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub exposed_ports: HashMap<String, serde_json::Value>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub env: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub entrypoint: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub cmd: Vec<String>,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub volumes: HashMap<String, serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub working_dir: Option<String>,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub labels: HashMap<String, String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop_signal: Option<String>,
}

/// Configuration rootfs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootFS {
    #[serde(rename = "type")]
    pub rootfs_type: String,
    pub diff_ids: Vec<String>,
}

/// Historique des layers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct History {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_by: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[serde(default)]
    pub empty_layer: bool,
}

/// Layer d'image
#[derive(Debug, Clone)]
pub struct Layer {
    pub digest: Digest,
    pub diff_id: Digest,
    pub size: u64,
    pub media_type: String,
    pub path: PathBuf,
}

/// Gestionnaire d'images
pub struct ImageManager {
    /// Repertoire de stockage
    root: PathBuf,
    /// Cache des manifests
    manifests: HashMap<String, ImageManifest>,
    /// Cache des configs
    configs: HashMap<Digest, ImageConfig>,
}

impl ImageManager {
    /// Creer un nouveau gestionnaire
    pub fn new(root: PathBuf) -> std::io::Result<Self> {
        // Creer structure de repertoires OCI
        let blobs_sha256 = root.join("blobs/sha256");
        fs::create_dir_all(&blobs_sha256)?;
        fs::create_dir_all(root.join("refs"))?;

        Ok(Self {
            root,
            manifests: HashMap::new(),
            configs: HashMap::new(),
        })
    }

    /// Chemin vers un blob
    pub fn blob_path(&self, digest: &Digest) -> PathBuf {
        self.root.join("blobs")
            .join(digest.algorithm())
            .join(digest.encoded())
    }

    /// Verifier si un blob existe
    pub fn blob_exists(&self, digest: &Digest) -> bool {
        self.blob_path(digest).exists()
    }

    /// Lire un blob
    pub fn read_blob(&self, digest: &Digest) -> std::io::Result<Vec<u8>> {
        fs::read(self.blob_path(digest))
    }

    /// Ecrire un blob
    pub fn write_blob(&self, data: &[u8]) -> std::io::Result<Digest> {
        let digest = Digest::from_bytes(data);

        let path = self.blob_path(&digest);
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::write(&path, data)?;
        Ok(digest)
    }

    /// Charger un manifest
    pub fn load_manifest(&mut self, digest: &Digest) -> Result<&ImageManifest, Box<dyn std::error::Error>> {
        let key = digest.0.clone();

        if !self.manifests.contains_key(&key) {
            let data = self.read_blob(digest)?;
            let manifest: ImageManifest = serde_json::from_slice(&data)?;
            self.manifests.insert(key.clone(), manifest);
        }

        Ok(self.manifests.get(&key).unwrap())
    }

    /// Charger une config d'image
    pub fn load_config(&mut self, digest: &Digest) -> Result<&ImageConfig, Box<dyn std::error::Error>> {
        if !self.configs.contains_key(digest) {
            let data = self.read_blob(digest)?;
            let config: ImageConfig = serde_json::from_slice(&data)?;
            self.configs.insert(digest.clone(), config);
        }

        Ok(self.configs.get(digest).unwrap())
    }

    /// Extraire une image vers un rootfs
    pub fn extract_image(
        &mut self,
        manifest_digest: &Digest,
        target: &Path,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Charger manifest
        let manifest = self.load_manifest(manifest_digest)?.clone();

        // Creer repertoire cible
        fs::create_dir_all(target)?;

        // Extraire chaque layer dans l'ordre
        for layer_desc in &manifest.layers {
            let layer_digest = Digest(layer_desc.digest.clone());
            self.extract_layer(&layer_digest, &layer_desc.media_type, target)?;
        }

        Ok(())
    }

    /// Extraire un layer
    fn extract_layer(
        &self,
        digest: &Digest,
        media_type: &str,
        target: &Path,
    ) -> std::io::Result<()> {
        let blob_path = self.blob_path(digest);
        let file = File::open(&blob_path)?;

        // Decoder selon media type
        let tar_reader: Box<dyn Read> = match media_type {
            media_types::LAYER_TAR_GZIP | media_types::DOCKER_LAYER => {
                Box::new(GzDecoder::new(file))
            }
            media_types::LAYER_TAR => {
                Box::new(file)
            }
            _ => {
                // Essayer gzip par defaut
                Box::new(GzDecoder::new(file))
            }
        };

        // Extraire archive tar
        let mut archive = Archive::new(tar_reader);

        for entry in archive.entries()? {
            let mut entry = entry?;
            let path = entry.path()?;

            // Gerer les whiteouts (fichiers supprimes)
            let filename = path.file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("");

            if filename.starts_with(".wh.") {
                // Whiteout: supprimer le fichier correspondant
                let actual_name = &filename[4..];
                let parent = path.parent().unwrap_or(Path::new(""));
                let to_remove = target.join(parent).join(actual_name);

                if to_remove.exists() {
                    if to_remove.is_dir() {
                        fs::remove_dir_all(&to_remove)?;
                    } else {
                        fs::remove_file(&to_remove)?;
                    }
                }
                continue;
            }

            // Opaque whiteout: vider le repertoire
            if filename == ".wh..wh..opq" {
                let parent = path.parent().unwrap_or(Path::new(""));
                let dir_path = target.join(parent);

                if dir_path.exists() {
                    for entry in fs::read_dir(&dir_path)? {
                        let entry = entry?;
                        let entry_path = entry.path();
                        if entry_path.is_dir() {
                            fs::remove_dir_all(&entry_path)?;
                        } else {
                            fs::remove_file(&entry_path)?;
                        }
                    }
                }
                continue;
            }

            // Extraire normalement
            let full_path = target.join(&path);
            entry.unpack(&full_path)?;
        }

        Ok(())
    }

    /// Construire une image a partir d'un Dockerfile simplifie
    pub fn build_image(
        &mut self,
        base_image: Option<&Digest>,
        commands: &[BuildCommand],
    ) -> Result<Digest, Box<dyn std::error::Error>> {
        // Charger image de base si fournie
        let mut layers: Vec<Descriptor> = vec![];
        let mut diff_ids: Vec<String> = vec![];
        let mut env: Vec<String> = vec![];
        let mut cmd: Vec<String> = vec!["/bin/sh".to_string()];
        let mut workdir = "/".to_string();

        if let Some(base_digest) = base_image {
            let base_manifest = self.load_manifest(base_digest)?.clone();
            let config_digest = Digest(base_manifest.config.digest.clone());
            let base_config = self.load_config(&config_digest)?.clone();

            layers = base_manifest.layers.clone();
            diff_ids = base_config.rootfs.diff_ids.clone();

            if let Some(cfg) = &base_config.config {
                env = cfg.env.clone();
                if !cfg.cmd.is_empty() {
                    cmd = cfg.cmd.clone();
                }
                if let Some(wd) = &cfg.working_dir {
                    workdir = wd.clone();
                }
            }
        }

        // Traiter chaque commande
        let mut history = vec![];

        for command in commands {
            match command {
                BuildCommand::Run(script) => {
                    // Executer dans conteneur temporaire et capturer diff
                    // (Simplifie: on cree juste un layer vide avec metadata)
                    history.push(History {
                        created: Some(chrono::Utc::now().to_rfc3339()),
                        created_by: Some(format!("RUN {}", script)),
                        author: None,
                        comment: None,
                        empty_layer: true,
                    });
                }
                BuildCommand::Copy { src, dst } => {
                    // Creer layer avec fichier copie
                    let layer_data = self.create_layer_from_file(src, dst)?;
                    let digest = self.write_blob(&layer_data)?;
                    let diff_id = Digest::from_bytes(&layer_data);

                    layers.push(Descriptor {
                        media_type: media_types::LAYER_TAR_GZIP.to_string(),
                        digest: digest.0.clone(),
                        size: layer_data.len() as i64,
                        annotations: HashMap::new(),
                        platform: None,
                        urls: vec![],
                    });
                    diff_ids.push(diff_id.0);

                    history.push(History {
                        created: Some(chrono::Utc::now().to_rfc3339()),
                        created_by: Some(format!("COPY {} {}", src.display(), dst.display())),
                        author: None,
                        comment: None,
                        empty_layer: false,
                    });
                }
                BuildCommand::Env(key, value) => {
                    env.push(format!("{}={}", key, value));
                    history.push(History {
                        created: Some(chrono::Utc::now().to_rfc3339()),
                        created_by: Some(format!("ENV {}={}", key, value)),
                        author: None,
                        comment: None,
                        empty_layer: true,
                    });
                }
                BuildCommand::Cmd(args) => {
                    cmd = args.clone();
                    history.push(History {
                        created: Some(chrono::Utc::now().to_rfc3339()),
                        created_by: Some(format!("CMD {:?}", args)),
                        author: None,
                        comment: None,
                        empty_layer: true,
                    });
                }
                BuildCommand::Workdir(dir) => {
                    workdir = dir.clone();
                    history.push(History {
                        created: Some(chrono::Utc::now().to_rfc3339()),
                        created_by: Some(format!("WORKDIR {}", dir)),
                        author: None,
                        comment: None,
                        empty_layer: true,
                    });
                }
            }
        }

        // Creer config
        let config = ImageConfig {
            created: Some(chrono::Utc::now().to_rfc3339()),
            author: Some("oci-runtime".to_string()),
            architecture: "amd64".to_string(),
            os: "linux".to_string(),
            config: Some(ImageExecutionConfig {
                user: None,
                exposed_ports: HashMap::new(),
                env,
                entrypoint: vec![],
                cmd,
                volumes: HashMap::new(),
                working_dir: Some(workdir),
                labels: HashMap::new(),
                stop_signal: None,
            }),
            rootfs: RootFS {
                rootfs_type: "layers".to_string(),
                diff_ids,
            },
            history,
        };

        let config_json = serde_json::to_vec_pretty(&config)?;
        let config_digest = self.write_blob(&config_json)?;

        // Creer manifest
        let manifest = ImageManifest {
            schema_version: 2,
            media_type: Some(media_types::MANIFEST_V1.to_string()),
            config: Descriptor {
                media_type: media_types::CONFIG_V1.to_string(),
                digest: config_digest.0.clone(),
                size: config_json.len() as i64,
                annotations: HashMap::new(),
                platform: None,
                urls: vec![],
            },
            layers,
            annotations: HashMap::new(),
        };

        let manifest_json = serde_json::to_vec_pretty(&manifest)?;
        let manifest_digest = self.write_blob(&manifest_json)?;

        Ok(manifest_digest)
    }

    /// Creer un layer tar.gz a partir d'un fichier
    fn create_layer_from_file(&self, src: &Path, dst: &Path) -> std::io::Result<Vec<u8>> {
        use flate2::write::GzEncoder;
        use flate2::Compression;

        let mut buffer = Vec::new();
        {
            let encoder = GzEncoder::new(&mut buffer, Compression::default());
            let mut tar_builder = tar::Builder::new(encoder);

            // Ajouter fichier a l'archive
            let mut file = File::open(src)?;
            let dst_str = dst.to_string_lossy();
            let dst_path = dst_str.trim_start_matches('/');

            tar_builder.append_file(dst_path, &mut file)?;
            tar_builder.finish()?;
        }

        Ok(buffer)
    }
}

/// Commandes de build d'image
#[derive(Debug, Clone)]
pub enum BuildCommand {
    Run(String),
    Copy { src: PathBuf, dst: PathBuf },
    Env(String, String),
    Cmd(Vec<String>),
    Workdir(String),
}
```

```rust
// ============================================================================
// network.rs - Docker Networking
// ============================================================================

//! Container Networking Implementation
//!
//! Implements bridge, host, and container networking modes

use std::collections::HashMap;
use std::net::Ipv4Addr;
use std::path::PathBuf;
use std::process::Command;

/// Mode de networking
#[derive(Debug, Clone, PartialEq)]
pub enum NetworkMode {
    /// Pas de networking
    None,
    /// Partager namespace reseau avec l'hote
    Host,
    /// Bridge prive avec NAT
    Bridge(String),
    /// Partager avec un autre conteneur
    Container(String),
    /// Reseau overlay (multi-host)
    Overlay(String),
    /// Macvlan (IP directe sur LAN)
    Macvlan(String),
}

/// Configuration d'un bridge
#[derive(Debug, Clone)]
pub struct BridgeConfig {
    pub name: String,
    pub subnet: Ipv4Addr,
    pub prefix_len: u8,
    pub gateway: Ipv4Addr,
    pub mtu: u32,
    pub enable_icc: bool,  // Inter-container communication
    pub enable_ip_masquerade: bool,
    pub enable_ipv6: bool,
}

impl Default for BridgeConfig {
    fn default() -> Self {
        Self {
            name: "docker0".to_string(),
            subnet: Ipv4Addr::new(172, 17, 0, 0),
            prefix_len: 16,
            gateway: Ipv4Addr::new(172, 17, 0, 1),
            mtu: 1500,
            enable_icc: true,
            enable_ip_masquerade: true,
            enable_ipv6: false,
        }
    }
}

/// Interface veth
#[derive(Debug, Clone)]
pub struct Veth {
    pub host_name: String,
    pub container_name: String,
    pub container_ip: Ipv4Addr,
    pub container_mac: [u8; 6],
}

/// Bridge reseau
#[derive(Debug)]
pub struct Bridge {
    pub config: BridgeConfig,
    pub veths: Vec<Veth>,
    next_ip: u32,
}

impl Bridge {
    pub fn new(config: BridgeConfig) -> std::io::Result<Self> {
        let bridge = Self {
            next_ip: u32::from(config.gateway) + 1,
            config,
            veths: vec![],
        };

        bridge.setup()?;
        Ok(bridge)
    }

    /// Configurer le bridge
    fn setup(&self) -> std::io::Result<()> {
        // Creer bridge
        run_cmd("ip", &["link", "add", &self.config.name, "type", "bridge"])?;

        // Configurer IP
        let cidr = format!("{}/{}", self.config.gateway, self.config.prefix_len);
        run_cmd("ip", &["addr", "add", &cidr, "dev", &self.config.name])?;

        // Activer
        run_cmd("ip", &["link", "set", &self.config.name, "up"])?;

        // Configurer MTU
        let mtu_str = self.config.mtu.to_string();
        run_cmd("ip", &["link", "set", &self.config.name, "mtu", &mtu_str])?;

        // Activer IP forwarding
        std::fs::write("/proc/sys/net/ipv4/ip_forward", "1")?;

        // Configurer NAT si demande
        if self.config.enable_ip_masquerade {
            let subnet = format!("{}/{}", self.config.subnet, self.config.prefix_len);
            run_cmd("iptables", &[
                "-t", "nat", "-A", "POSTROUTING",
                "-s", &subnet, "-j", "MASQUERADE"
            ])?;
        }

        Ok(())
    }

    /// Allouer une IP
    fn allocate_ip(&mut self) -> Ipv4Addr {
        let ip = Ipv4Addr::from(self.next_ip);
        self.next_ip += 1;
        ip
    }

    /// Generer adresse MAC
    fn generate_mac(&self) -> [u8; 6] {
        use std::time::{SystemTime, UNIX_EPOCH};
        let nanos = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .subsec_nanos();

        [
            0x02,  // Locally administered
            0x42,  // Docker prefix
            ((nanos >> 24) & 0xFF) as u8,
            ((nanos >> 16) & 0xFF) as u8,
            ((nanos >> 8) & 0xFF) as u8,
            (nanos & 0xFF) as u8,
        ]
    }

    /// Connecter un conteneur au bridge
    pub fn connect_container(
        &mut self,
        container_id: &str,
        container_pid: u32,
    ) -> std::io::Result<Veth> {
        let short_id = &container_id[..12.min(container_id.len())];
        let host_name = format!("veth{}", short_id);
        let container_name = "eth0".to_string();
        let container_ip = self.allocate_ip();
        let container_mac = self.generate_mac();

        // Creer paire veth
        run_cmd("ip", &[
            "link", "add", &host_name, "type", "veth",
            "peer", "name", &container_name
        ])?;

        // Attacher cote hote au bridge
        run_cmd("ip", &["link", "set", &host_name, "master", &self.config.name])?;
        run_cmd("ip", &["link", "set", &host_name, "up"])?;

        // Deplacer cote conteneur dans le namespace
        let pid_str = container_pid.to_string();
        run_cmd("ip", &["link", "set", &container_name, "netns", &pid_str])?;

        // Configurer dans le namespace (via nsenter)
        let mac_str = format!(
            "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
            container_mac[0], container_mac[1], container_mac[2],
            container_mac[3], container_mac[4], container_mac[5]
        );

        run_cmd("nsenter", &[
            "-t", &pid_str, "-n",
            "ip", "link", "set", &container_name, "address", &mac_str
        ])?;

        let ip_cidr = format!("{}/{}", container_ip, self.config.prefix_len);
        run_cmd("nsenter", &[
            "-t", &pid_str, "-n",
            "ip", "addr", "add", &ip_cidr, "dev", &container_name
        ])?;

        run_cmd("nsenter", &[
            "-t", &pid_str, "-n",
            "ip", "link", "set", &container_name, "up"
        ])?;

        run_cmd("nsenter", &[
            "-t", &pid_str, "-n",
            "ip", "link", "set", "lo", "up"
        ])?;

        // Route par defaut
        let gw_str = self.config.gateway.to_string();
        run_cmd("nsenter", &[
            "-t", &pid_str, "-n",
            "ip", "route", "add", "default", "via", &gw_str
        ])?;

        let veth = Veth {
            host_name,
            container_name,
            container_ip,
            container_mac,
        };

        self.veths.push(veth.clone());
        Ok(veth)
    }

    /// Deconnecter un conteneur
    pub fn disconnect_container(&mut self, host_veth_name: &str) -> std::io::Result<()> {
        // Supprimer veth (supprime automatiquement la paire)
        let _ = run_cmd("ip", &["link", "del", host_veth_name]);

        self.veths.retain(|v| v.host_name != host_veth_name);
        Ok(())
    }

    /// Ajouter regle de port forwarding
    pub fn add_port_forward(
        &self,
        host_port: u16,
        container_ip: Ipv4Addr,
        container_port: u16,
        protocol: &str,
    ) -> std::io::Result<()> {
        let host_port_str = host_port.to_string();
        let container_port_str = container_port.to_string();
        let dest = format!("{}:{}", container_ip, container_port);

        // DNAT pour trafic entrant
        run_cmd("iptables", &[
            "-t", "nat", "-A", "PREROUTING",
            "-p", protocol,
            "--dport", &host_port_str,
            "-j", "DNAT", "--to-destination", &dest
        ])?;

        // Pour trafic local
        run_cmd("iptables", &[
            "-t", "nat", "-A", "OUTPUT",
            "-p", protocol,
            "--dport", &host_port_str,
            "-j", "DNAT", "--to-destination", &dest
        ])?;

        Ok(())
    }
}

impl Drop for Bridge {
    fn drop(&mut self) {
        // Nettoyer veths
        for veth in &self.veths {
            let _ = run_cmd("ip", &["link", "del", &veth.host_name]);
        }

        // Supprimer bridge
        let _ = run_cmd("ip", &["link", "set", &self.config.name, "down"]);
        let _ = run_cmd("ip", &["link", "del", &self.config.name]);
    }
}

/// Gestionnaire reseau
pub struct NetworkManager {
    bridges: HashMap<String, Bridge>,
    dns_servers: Vec<Ipv4Addr>,
}

impl NetworkManager {
    pub fn new() -> Self {
        Self {
            bridges: HashMap::new(),
            dns_servers: vec![
                Ipv4Addr::new(8, 8, 8, 8),
                Ipv4Addr::new(8, 8, 4, 4),
            ],
        }
    }

    /// Creer un nouveau reseau bridge
    pub fn create_bridge(&mut self, name: &str, config: BridgeConfig) -> std::io::Result<()> {
        let bridge = Bridge::new(config)?;
        self.bridges.insert(name.to_string(), bridge);
        Ok(())
    }

    /// Obtenir un bridge
    pub fn get_bridge(&mut self, name: &str) -> Option<&mut Bridge> {
        self.bridges.get_mut(name)
    }

    /// Creer reseau par defaut
    pub fn ensure_default_bridge(&mut self) -> std::io::Result<()> {
        if !self.bridges.contains_key("bridge") {
            self.create_bridge("bridge", BridgeConfig::default())?;
        }
        Ok(())
    }

    /// Connecter conteneur au reseau
    pub fn connect(
        &mut self,
        network_name: &str,
        container_id: &str,
        container_pid: u32,
    ) -> std::io::Result<Veth> {
        let bridge = self.bridges.get_mut(network_name)
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::NotFound,
                format!("Network '{}' not found", network_name)
            ))?;

        bridge.connect_container(container_id, container_pid)
    }

    /// Generer /etc/resolv.conf pour conteneur
    pub fn generate_resolv_conf(&self) -> String {
        let mut content = String::new();
        for dns in &self.dns_servers {
            content.push_str(&format!("nameserver {}\n", dns));
        }
        content
    }

    /// Generer /etc/hosts pour conteneur
    pub fn generate_hosts(&self, hostname: &str, container_ip: Ipv4Addr) -> String {
        format!(
            "127.0.0.1\tlocalhost\n\
             ::1\tlocalhost ip6-localhost ip6-loopback\n\
             fe00::0\tip6-localnet\n\
             ff00::0\tip6-mcastprefix\n\
             ff02::1\tip6-allnodes\n\
             ff02::2\tip6-allrouters\n\
             {}\t{}\n",
            container_ip, hostname
        )
    }
}

/// Executer une commande
fn run_cmd(cmd: &str, args: &[&str]) -> std::io::Result<()> {
    let status = Command::new(cmd)
        .args(args)
        .status()?;

    if !status.success() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("{} {:?} failed", cmd, args)
        ));
    }

    Ok(())
}
```

```rust
// ============================================================================
// storage.rs - Docker Storage
// ============================================================================

//! Container Storage Implementation
//!
//! Implements overlay filesystem and volume management

use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::fs;
use std::process::Command;

/// Volume Docker
#[derive(Debug, Clone)]
pub struct Volume {
    pub name: String,
    pub driver: String,
    pub mountpoint: PathBuf,
    pub labels: HashMap<String, String>,
    pub options: HashMap<String, String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

/// Gestionnaire de volumes
pub struct VolumeManager {
    root: PathBuf,
    volumes: HashMap<String, Volume>,
}

impl VolumeManager {
    pub fn new(root: PathBuf) -> std::io::Result<Self> {
        fs::create_dir_all(&root)?;

        Ok(Self {
            root,
            volumes: HashMap::new(),
        })
    }

    /// Creer un nouveau volume
    pub fn create(
        &mut self,
        name: &str,
        driver: &str,
        labels: HashMap<String, String>,
        options: HashMap<String, String>,
    ) -> std::io::Result<&Volume> {
        if self.volumes.contains_key(name) {
            return Err(std::io::Error::new(
                std::io::ErrorKind::AlreadyExists,
                format!("Volume '{}' already exists", name)
            ));
        }

        let mountpoint = self.root.join(name).join("_data");
        fs::create_dir_all(&mountpoint)?;

        let volume = Volume {
            name: name.to_string(),
            driver: driver.to_string(),
            mountpoint,
            labels,
            options,
            created_at: chrono::Utc::now(),
        };

        self.volumes.insert(name.to_string(), volume);
        Ok(self.volumes.get(name).unwrap())
    }

    /// Obtenir un volume
    pub fn get(&self, name: &str) -> Option<&Volume> {
        self.volumes.get(name)
    }

    /// Supprimer un volume
    pub fn remove(&mut self, name: &str) -> std::io::Result<()> {
        if let Some(volume) = self.volumes.remove(name) {
            if volume.mountpoint.exists() {
                fs::remove_dir_all(&volume.mountpoint)?;
            }
        }
        Ok(())
    }

    /// Lister tous les volumes
    pub fn list(&self) -> Vec<&Volume> {
        self.volumes.values().collect()
    }
}

/// Configuration OverlayFS
#[derive(Debug, Clone)]
pub struct OverlayConfig {
    /// Layers en lecture seule (du plus bas au plus haut)
    pub lower_dirs: Vec<PathBuf>,
    /// Layer en lecture-ecriture
    pub upper_dir: PathBuf,
    /// Repertoire de travail
    pub work_dir: PathBuf,
    /// Point de montage
    pub merged_dir: PathBuf,
}

/// Gestionnaire OverlayFS
pub struct OverlayFS {
    config: OverlayConfig,
    mounted: bool,
}

impl OverlayFS {
    /// Creer un nouveau overlay
    pub fn new(config: OverlayConfig) -> std::io::Result<Self> {
        // Creer repertoires
        fs::create_dir_all(&config.upper_dir)?;
        fs::create_dir_all(&config.work_dir)?;
        fs::create_dir_all(&config.merged_dir)?;

        Ok(Self {
            config,
            mounted: false,
        })
    }

    /// Monter l'overlay
    pub fn mount(&mut self) -> std::io::Result<()> {
        if self.mounted {
            return Ok(());
        }

        // Construire options de montage
        let lower = self.config.lower_dirs
            .iter()
            .map(|p| p.to_string_lossy().to_string())
            .collect::<Vec<_>>()
            .join(":");

        let opts = format!(
            "lowerdir={},upperdir={},workdir={}",
            lower,
            self.config.upper_dir.display(),
            self.config.work_dir.display()
        );

        // Monter
        let status = Command::new("mount")
            .args([
                "-t", "overlay",
                "overlay",
                "-o", &opts,
                &self.config.merged_dir.to_string_lossy(),
            ])
            .status()?;

        if !status.success() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Failed to mount overlay"
            ));
        }

        self.mounted = true;
        Ok(())
    }

    /// Demonter l'overlay
    pub fn unmount(&mut self) -> std::io::Result<()> {
        if !self.mounted {
            return Ok(());
        }

        let status = Command::new("umount")
            .arg(&self.config.merged_dir)
            .status()?;

        if !status.success() {
            // Essayer umount lazy
            let _ = Command::new("umount")
                .args(["-l", &self.config.merged_dir.to_string_lossy()])
                .status();
        }

        self.mounted = false;
        Ok(())
    }

    /// Chemin du point de montage
    pub fn merged_path(&self) -> &Path {
        &self.config.merged_dir
    }

    /// Chemin du layer superieur (modifications)
    pub fn upper_path(&self) -> &Path {
        &self.config.upper_dir
    }

    /// Obtenir les modifications (diff)
    pub fn get_diff(&self) -> std::io::Result<Vec<DiffEntry>> {
        let mut diff = vec![];
        self.walk_diff(&self.config.upper_dir, Path::new("/"), &mut diff)?;
        Ok(diff)
    }

    fn walk_diff(&self, dir: &Path, relative: &Path, diff: &mut Vec<DiffEntry>) -> std::io::Result<()> {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            let file_name = entry.file_name();
            let file_name_str = file_name.to_string_lossy();

            let rel_path = relative.join(&file_name);

            // Detecter type de modification
            if file_name_str.starts_with(".wh.") {
                // Whiteout = fichier supprime
                let actual_name = &file_name_str[4..];
                diff.push(DiffEntry {
                    path: relative.join(actual_name),
                    change_type: ChangeType::Deleted,
                });
            } else if path.is_dir() {
                // Verifier si c'est opaque whiteout
                if path.join(".wh..wh..opq").exists() {
                    diff.push(DiffEntry {
                        path: rel_path.clone(),
                        change_type: ChangeType::Modified,
                    });
                }
                // Recurser
                self.walk_diff(&path, &rel_path, diff)?;
            } else {
                // Fichier ajoute ou modifie
                let change_type = if self.exists_in_lower(&rel_path) {
                    ChangeType::Modified
                } else {
                    ChangeType::Added
                };
                diff.push(DiffEntry {
                    path: rel_path,
                    change_type,
                });
            }
        }
        Ok(())
    }

    fn exists_in_lower(&self, path: &Path) -> bool {
        for lower in &self.config.lower_dirs {
            let full_path = lower.join(path.strip_prefix("/").unwrap_or(path));
            if full_path.exists() {
                return true;
            }
        }
        false
    }
}

impl Drop for OverlayFS {
    fn drop(&mut self) {
        let _ = self.unmount();
    }
}

/// Entree de diff
#[derive(Debug, Clone)]
pub struct DiffEntry {
    pub path: PathBuf,
    pub change_type: ChangeType,
}

/// Type de changement
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChangeType {
    Added,
    Modified,
    Deleted,
}

/// Gestionnaire de stockage pour conteneurs
pub struct StorageManager {
    root: PathBuf,
    volumes: VolumeManager,
    overlays: HashMap<String, OverlayFS>,
}

impl StorageManager {
    pub fn new(root: PathBuf) -> std::io::Result<Self> {
        fs::create_dir_all(root.join("layers"))?;
        fs::create_dir_all(root.join("containers"))?;
        fs::create_dir_all(root.join("volumes"))?;

        let volumes = VolumeManager::new(root.join("volumes"))?;

        Ok(Self {
            root,
            volumes,
            overlays: HashMap::new(),
        })
    }

    /// Preparer rootfs pour un conteneur
    pub fn prepare_rootfs(
        &mut self,
        container_id: &str,
        image_layers: &[PathBuf],
    ) -> std::io::Result<PathBuf> {
        let container_dir = self.root.join("containers").join(container_id);
        fs::create_dir_all(&container_dir)?;

        let config = OverlayConfig {
            lower_dirs: image_layers.to_vec(),
            upper_dir: container_dir.join("diff"),
            work_dir: container_dir.join("work"),
            merged_dir: container_dir.join("merged"),
        };

        let mut overlay = OverlayFS::new(config)?;
        overlay.mount()?;

        let merged = overlay.merged_path().to_path_buf();
        self.overlays.insert(container_id.to_string(), overlay);

        Ok(merged)
    }

    /// Nettoyer rootfs d'un conteneur
    pub fn cleanup_rootfs(&mut self, container_id: &str) -> std::io::Result<()> {
        if let Some(mut overlay) = self.overlays.remove(container_id) {
            overlay.unmount()?;
        }

        let container_dir = self.root.join("containers").join(container_id);
        if container_dir.exists() {
            fs::remove_dir_all(&container_dir)?;
        }

        Ok(())
    }

    /// Obtenir le gestionnaire de volumes
    pub fn volumes(&mut self) -> &mut VolumeManager {
        &mut self.volumes
    }

    /// Monter un volume dans un conteneur
    pub fn mount_volume(
        &self,
        volume_name: &str,
        container_rootfs: &Path,
        mount_path: &Path,
    ) -> std::io::Result<()> {
        let volume = self.volumes.get(volume_name)
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::NotFound,
                format!("Volume '{}' not found", volume_name)
            ))?;

        // Creer point de montage
        let target = container_rootfs.join(mount_path.strip_prefix("/").unwrap_or(mount_path));
        fs::create_dir_all(&target)?;

        // Bind mount
        let status = Command::new("mount")
            .args(["--bind", &volume.mountpoint.to_string_lossy(), &target.to_string_lossy()])
            .status()?;

        if !status.success() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Failed to bind mount volume"
            ));
        }

        Ok(())
    }
}
```

```rust
// ============================================================================
// runtime.rs - OCI Runtime
// ============================================================================

//! OCI Runtime Implementation
//!
//! Implements container lifecycle management

use crate::config::{OCISpec, NamespaceType};
use crate::network::{NetworkManager, NetworkMode, Veth};
use crate::storage::StorageManager;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::fs;
use std::os::unix::process::CommandExt;
use std::process::{Command, Stdio};
use nix::sys::signal::{self, Signal};
use nix::unistd::{self, Pid, ForkResult};
use nix::sched::{self, CloneFlags};

/// Etat du conteneur
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ContainerState {
    Creating,
    Created,
    Running,
    Stopped,
    Paused,
}

use serde::{Deserialize, Serialize};

/// Etat OCI complet
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct State {
    pub oci_version: String,
    pub id: String,
    pub status: ContainerState,
    pub pid: Option<u32>,
    pub bundle: PathBuf,
    #[serde(default)]
    pub annotations: HashMap<String, String>,
}

/// Conteneur
pub struct Container {
    pub id: String,
    pub bundle: PathBuf,
    pub spec: OCISpec,
    pub state: ContainerState,
    pub pid: Option<u32>,
    pub network: Option<Veth>,
    created_at: chrono::DateTime<chrono::Utc>,
}

impl Container {
    /// Creer un nouveau conteneur
    pub fn new(id: String, bundle: PathBuf, spec: OCISpec) -> Self {
        Self {
            id,
            bundle,
            spec,
            state: ContainerState::Creating,
            pid: None,
            network: None,
            created_at: chrono::Utc::now(),
        }
    }

    /// Obtenir l'etat OCI
    pub fn oci_state(&self) -> State {
        State {
            oci_version: crate::config::OCI_VERSION.to_string(),
            id: self.id.clone(),
            status: self.state.clone(),
            pid: self.pid,
            bundle: self.bundle.clone(),
            annotations: self.spec.annotations.clone(),
        }
    }
}

/// Runtime OCI
pub struct Runtime {
    root: PathBuf,
    containers: HashMap<String, Container>,
    network: NetworkManager,
    storage: StorageManager,
}

impl Runtime {
    /// Creer un nouveau runtime
    pub fn new(root: PathBuf) -> std::io::Result<Self> {
        fs::create_dir_all(&root)?;
        fs::create_dir_all(root.join("containers"))?;

        let storage = StorageManager::new(root.join("storage"))?;
        let network = NetworkManager::new();

        Ok(Self {
            root,
            containers: HashMap::new(),
            network,
            storage,
        })
    }

    /// Creer un conteneur (OCI create)
    pub fn create(
        &mut self,
        id: &str,
        bundle: &Path,
    ) -> Result<&Container, Box<dyn std::error::Error>> {
        // Verifier que l'ID est unique
        if self.containers.contains_key(id) {
            return Err(format!("Container '{}' already exists", id).into());
        }

        // Charger config.json
        let config_path = bundle.join("config.json");
        let spec = OCISpec::from_file(&config_path)?;
        spec.validate()?;

        // Creer conteneur
        let mut container = Container::new(
            id.to_string(),
            bundle.to_path_buf(),
            spec,
        );

        // Preparer rootfs
        let rootfs_path = bundle.join(&container.spec.root.path);
        if !rootfs_path.exists() {
            return Err(format!("Rootfs not found: {:?}", rootfs_path).into());
        }

        // Sauvegarder etat
        container.state = ContainerState::Created;
        self.save_state(&container)?;

        self.containers.insert(id.to_string(), container);
        Ok(self.containers.get(id).unwrap())
    }

    /// Demarrer un conteneur (OCI start)
    pub fn start(&mut self, id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let container = self.containers.get_mut(id)
            .ok_or_else(|| format!("Container '{}' not found", id))?;

        if container.state != ContainerState::Created {
            return Err(format!("Container '{}' is not in 'created' state", id).into());
        }

        // Executer hooks prestart
        if let Some(hooks) = &container.spec.hooks {
            for hook in &hooks.prestart {
                self.run_hook(hook, container)?;
            }
        }

        // Fork et configurer namespaces
        let pid = self.spawn_container_process(container)?;
        container.pid = Some(pid);
        container.state = ContainerState::Running;

        // Configurer reseau
        if let Some(linux) = &container.spec.linux {
            let needs_network = linux.namespaces.iter()
                .any(|ns| ns.ns_type == NamespaceType::Network && ns.path.is_none());

            if needs_network {
                self.network.ensure_default_bridge()?;
                let veth = self.network.connect("bridge", &container.id, pid)?;
                container.network = Some(veth);
            }
        }

        // Executer hooks poststart
        if let Some(hooks) = &container.spec.hooks {
            for hook in &hooks.poststart {
                let _ = self.run_hook(hook, container);
            }
        }

        self.save_state(container)?;
        Ok(())
    }

    /// Spawn le processus du conteneur
    fn spawn_container_process(&self, container: &Container) -> Result<u32, Box<dyn std::error::Error>> {
        // Construire flags clone
        let mut clone_flags = CloneFlags::empty();

        if let Some(linux) = &container.spec.linux {
            for ns in &linux.namespaces {
                if ns.path.is_none() {
                    match ns.ns_type {
                        NamespaceType::Pid => clone_flags |= CloneFlags::CLONE_NEWPID,
                        NamespaceType::Network => clone_flags |= CloneFlags::CLONE_NEWNET,
                        NamespaceType::Mount => clone_flags |= CloneFlags::CLONE_NEWNS,
                        NamespaceType::Ipc => clone_flags |= CloneFlags::CLONE_NEWIPC,
                        NamespaceType::Uts => clone_flags |= CloneFlags::CLONE_NEWUTS,
                        NamespaceType::User => clone_flags |= CloneFlags::CLONE_NEWUSER,
                        NamespaceType::Cgroup => clone_flags |= CloneFlags::CLONE_NEWCGROUP,
                        NamespaceType::Time => {},  // Requires special handling
                    }
                }
            }
        }

        // Preparer arguments
        let rootfs = container.bundle.join(&container.spec.root.path);
        let args = container.spec.process.args.clone();
        let env: Vec<String> = container.spec.process.env.clone();
        let cwd = container.spec.process.cwd.clone();
        let hostname = container.spec.hostname.clone();

        // Fork avec clone
        let stack_size = 1024 * 1024;  // 1MB
        let mut stack = vec![0u8; stack_size];

        let pid = unsafe {
            sched::clone(
                Box::new(move || {
                    // Dans le nouveau processus

                    // Configurer hostname
                    if let Some(name) = &hostname {
                        let _ = nix::unistd::sethostname(name);
                    }

                    // Chroot vers rootfs
                    if nix::unistd::chroot(&rootfs).is_err() {
                        return 1;
                    }

                    // Changer repertoire
                    if std::env::set_current_dir(&cwd).is_err() {
                        return 1;
                    }

                    // Executer la commande
                    let program = &args[0];
                    let mut cmd = Command::new(program);
                    cmd.args(&args[1..]);
                    cmd.envs(env.iter().filter_map(|e| {
                        let parts: Vec<&str> = e.splitn(2, '=').collect();
                        if parts.len() == 2 {
                            Some((parts[0], parts[1]))
                        } else {
                            None
                        }
                    }));

                    // exec remplace le processus
                    let err = cmd.exec();
                    eprintln!("exec failed: {}", err);
                    1
                }),
                stack.as_mut_slice(),
                clone_flags,
                Some(Signal::SIGCHLD as i32),
            )?
        };

        Ok(pid.as_raw() as u32)
    }

    /// Executer un hook
    fn run_hook(&self, hook: &crate::config::Hook, container: &Container) -> Result<(), Box<dyn std::error::Error>> {
        let state_json = serde_json::to_string(&container.oci_state())?;

        let mut cmd = Command::new(&hook.path);
        cmd.args(&hook.args);
        cmd.envs(hook.env.iter().filter_map(|e| {
            let parts: Vec<&str> = e.splitn(2, '=').collect();
            if parts.len() == 2 {
                Some((parts[0], parts[1]))
            } else {
                None
            }
        }));
        cmd.stdin(Stdio::piped());

        let mut child = cmd.spawn()?;

        if let Some(stdin) = child.stdin.as_mut() {
            use std::io::Write;
            stdin.write_all(state_json.as_bytes())?;
        }

        let status = child.wait()?;
        if !status.success() {
            return Err(format!("Hook {} failed", hook.path.display()).into());
        }

        Ok(())
    }

    /// Arreter un conteneur (OCI kill)
    pub fn kill(&mut self, id: &str, signal: Signal) -> Result<(), Box<dyn std::error::Error>> {
        let container = self.containers.get_mut(id)
            .ok_or_else(|| format!("Container '{}' not found", id))?;

        if let Some(pid) = container.pid {
            signal::kill(Pid::from_raw(pid as i32), signal)?;
        }

        Ok(())
    }

    /// Supprimer un conteneur (OCI delete)
    pub fn delete(&mut self, id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let container = self.containers.remove(id)
            .ok_or_else(|| format!("Container '{}' not found", id))?;

        if container.state == ContainerState::Running {
            return Err(format!("Container '{}' is still running", id).into());
        }

        // Nettoyer reseau
        if let Some(veth) = &container.network {
            if let Some(bridge) = self.network.get_bridge("bridge") {
                let _ = bridge.disconnect_container(&veth.host_name);
            }
        }

        // Executer hooks poststop
        if let Some(hooks) = &container.spec.hooks {
            for hook in &hooks.poststop {
                let _ = self.run_hook(hook, &container);
            }
        }

        // Supprimer fichier d'etat
        let state_path = self.root.join("containers").join(&container.id).join("state.json");
        let _ = fs::remove_file(state_path);

        Ok(())
    }

    /// Obtenir l'etat d'un conteneur (OCI state)
    pub fn state(&self, id: &str) -> Option<State> {
        self.containers.get(id).map(|c| c.oci_state())
    }

    /// Lister tous les conteneurs
    pub fn list(&self) -> Vec<State> {
        self.containers.values().map(|c| c.oci_state()).collect()
    }

    /// Sauvegarder l'etat d'un conteneur
    fn save_state(&self, container: &Container) -> std::io::Result<()> {
        let container_dir = self.root.join("containers").join(&container.id);
        fs::create_dir_all(&container_dir)?;

        let state_path = container_dir.join("state.json");
        let state = container.oci_state();
        let json = serde_json::to_string_pretty(&state)?;
        fs::write(state_path, json)?;

        Ok(())
    }

    /// Executer une commande dans un conteneur en cours (OCI exec)
    pub fn exec(
        &self,
        id: &str,
        args: &[String],
        env: &[String],
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let container = self.containers.get(id)
            .ok_or_else(|| format!("Container '{}' not found", id))?;

        if container.state != ContainerState::Running {
            return Err(format!("Container '{}' is not running", id).into());
        }

        let pid = container.pid.ok_or("Container has no PID")?;

        // nsenter dans les namespaces du conteneur
        let mut cmd = Command::new("nsenter");
        cmd.args([
            "-t", &pid.to_string(),
            "-m", "-u", "-i", "-n", "-p",
            "--"
        ]);
        cmd.args(args);
        cmd.envs(env.iter().filter_map(|e| {
            let parts: Vec<&str> = e.splitn(2, '=').collect();
            if parts.len() == 2 {
                Some((parts[0], parts[1]))
            } else {
                None
            }
        }));

        let status = cmd.status()?;
        Ok(status.code().unwrap_or(1))
    }
}
```

## Criteres d'Evaluation

### Fonctionnalite (40 points)
- [ ] Parsing OCI spec complet (8 pts)
- [ ] Gestion images et layers (8 pts)
- [ ] Overlay filesystem fonctionnel (8 pts)
- [ ] Networking bridge (8 pts)
- [ ] Volumes persistants (8 pts)

### Correction Technique (30 points)
- [ ] Conformite OCI runtime-spec (10 pts)
- [ ] Conformite OCI image-spec (10 pts)
- [ ] Gestion correcte des namespaces (10 pts)

### Qualite du Code (20 points)
- [ ] Architecture modulaire (5 pts)
- [ ] Gestion d'erreurs (5 pts)
- [ ] Documentation (5 pts)
- [ ] Tests (5 pts)

### Pedagogie (10 points)
- [ ] Comptes rendus clairs (5 pts)
- [ ] Progression logique (5 pts)

## Tests Automatises

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_oci_spec_parsing() {
        let spec = OCISpec::default_config();

        assert_eq!(spec.oci_version, "1.0.2");
        assert!(!spec.process.args.is_empty());
        assert!(spec.linux.is_some());

        // Serialization round-trip
        let json = serde_json::to_string(&spec).unwrap();
        let parsed: OCISpec = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.oci_version, spec.oci_version);
    }

    #[test]
    fn test_digest_calculation() {
        let data = b"hello world";
        let digest = Digest::from_bytes(data);

        assert!(digest.0.starts_with("sha256:"));
        assert_eq!(digest.algorithm(), "sha256");
        assert!(!digest.encoded().is_empty());
    }

    #[test]
    fn test_image_manager() {
        let tmp = TempDir::new().unwrap();
        let mut manager = ImageManager::new(tmp.path().to_path_buf()).unwrap();

        // Write blob
        let data = b"test data";
        let digest = manager.write_blob(data).unwrap();

        // Read blob
        assert!(manager.blob_exists(&digest));
        let read_data = manager.read_blob(&digest).unwrap();
        assert_eq!(read_data, data);
    }

    #[test]
    fn test_volume_manager() {
        let tmp = TempDir::new().unwrap();
        let mut manager = VolumeManager::new(tmp.path().to_path_buf()).unwrap();

        // Create volume
        let volume = manager.create(
            "test-vol",
            "local",
            HashMap::new(),
            HashMap::new(),
        ).unwrap();

        assert_eq!(volume.name, "test-vol");
        assert!(volume.mountpoint.exists());

        // Get volume
        assert!(manager.get("test-vol").is_some());

        // Remove volume
        manager.remove("test-vol").unwrap();
        assert!(manager.get("test-vol").is_none());
    }

    #[test]
    fn test_network_config() {
        let config = BridgeConfig::default();

        assert_eq!(config.name, "docker0");
        assert_eq!(config.gateway, Ipv4Addr::new(172, 17, 0, 1));
        assert!(config.enable_ip_masquerade);
    }

    #[test]
    fn test_container_state() {
        let spec = OCISpec::default_config();
        let container = Container::new(
            "test-container".to_string(),
            PathBuf::from("/tmp/bundle"),
            spec,
        );

        let state = container.oci_state();
        assert_eq!(state.id, "test-container");
        assert_eq!(state.status, ContainerState::Creating);
    }
}
```

## Ressources
- OCI Runtime Specification: https://github.com/opencontainers/runtime-spec
- OCI Image Specification: https://github.com/opencontainers/image-spec
- Docker Architecture: https://docs.docker.com/get-started/docker-overview/
- runc source code: https://github.com/opencontainers/runc
