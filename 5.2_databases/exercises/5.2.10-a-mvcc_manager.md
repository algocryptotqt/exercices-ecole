<thinking>
## Analyse du Concept
- Concept : MVCC (Multi-Version Concurrency Control) Implementation
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - MVCC est la technique standard pour l'isolation des transactions sans verrous bloquants.

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A : Visibilite incorrecte des versions
2. Mutant B : Garbage collection prematuree
3. Mutant C : Write-write conflict non detecte
4. Mutant D : Snapshot timestamp incorrect
5. Mutant E : Phantom reads non prevenus
</thinking>

# Exercice 5.2.10-a : mvcc_manager

**Module :**
5.2.10 -- Transaction Isolation & Concurrency

**Concept :**
a -- Multi-Version Concurrency Control (MVCC, snapshots, visibility)

**Difficulte :**
9/10

**Type :**
code

**Tiers :**
3 -- Systeme complet

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.2.8 -- WAL Implementation
- 4.5 -- Concurrency primitives

**Domaines :**
DB, Concurrency, Isolation

**Duree estimee :**
210 min

**XP Base :**
350

**Complexite :**
T2 O(1) version lookup x S3 O(v) versions per row

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::sync::{Arc, RwLock, Mutex}`
- `std::collections::{HashMap, BTreeMap}`
- `parking_lot` pour locks plus performants

**Fonctions/methodes interdites :**
- `unsafe` blocks
- Crates de MVCC existants

### 1.2 Consigne

**CONTEXTE : "The Time Machine"**

*"Chaque transaction vit dans son propre instant fige du temps. Elle ne voit que les donnees qui existaient a sa naissance, ignorant les changements des autres voyageurs temporels."* -- H.G. Wells, s'il avait ete DBA

MVCC permet a plusieurs transactions de lire et ecrire simultanement sans se bloquer mutuellement. Chaque modification cree une nouvelle version, et chaque transaction voit un snapshot coherent.

**Ta mission :**

Implementer un gestionnaire MVCC qui :
1. Maintient plusieurs versions de chaque ligne
2. Determine la visibilite des versions pour chaque transaction
3. Detecte et resout les conflits write-write
4. Gere le garbage collection des anciennes versions
5. Supporte les niveaux d'isolation (Read Committed, Repeatable Read, Serializable)

**Entree :**
- `tx_id: TxId` -- Identifiant de transaction
- `key: K` -- Cle de la ligne
- `isolation: IsolationLevel` -- Niveau d'isolation

**Sortie :**
- `MvccManager<K, V>` -- Gestionnaire MVCC complet
- `MvccError` -- En cas de conflit ou erreur

### 1.3 Prototype

```rust
use std::sync::{Arc, RwLock, Mutex};
use std::collections::{HashMap, BTreeMap};
use std::time::Instant;

/// Identifiant de transaction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TxId(pub u64);

/// Timestamp logique
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct Timestamp(pub u64);

/// Niveau d'isolation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IsolationLevel {
    ReadUncommitted,
    ReadCommitted,
    RepeatableRead,
    Serializable,
}

/// Etat d'une transaction
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TxState {
    Active,
    Committed(Timestamp),
    Aborted,
}

/// Version d'une ligne
#[derive(Debug, Clone)]
pub struct Version<V> {
    pub value: Option<V>,  // None = deleted
    pub created_by: TxId,
    pub created_at: Timestamp,
    pub deleted_by: Option<TxId>,
    pub deleted_at: Option<Timestamp>,
}

/// Ligne avec ses versions
#[derive(Debug)]
pub struct VersionedRow<V> {
    versions: Vec<Version<V>>,
}

impl<V: Clone> VersionedRow<V> {
    pub fn new() -> Self;

    /// Ajoute une nouvelle version
    pub fn add_version(&mut self, version: Version<V>);

    /// Trouve la version visible pour une transaction
    pub fn visible_version(&self, snapshot: &Snapshot, tx_states: &TxStateMap) -> Option<&Version<V>>;

    /// Marque une version comme supprimee
    pub fn mark_deleted(&mut self, tx_id: TxId, timestamp: Timestamp) -> bool;

    /// Supprime les versions obsoletes
    pub fn garbage_collect(&mut self, oldest_active: Timestamp) -> usize;
}

/// Snapshot pour une transaction
#[derive(Debug, Clone)]
pub struct Snapshot {
    pub tx_id: TxId,
    pub timestamp: Timestamp,
    pub isolation: IsolationLevel,
    pub active_txs: Vec<TxId>,  // Transactions actives au moment du snapshot
}

impl Snapshot {
    /// Une version est-elle visible dans ce snapshot?
    pub fn is_visible(&self, version: &Version<impl Clone>, tx_states: &TxStateMap) -> bool;
}

/// Map des etats de transactions
pub type TxStateMap = HashMap<TxId, TxState>;

/// Erreurs MVCC
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
pub enum MvccError {
    #[error("Write-write conflict: row already modified by tx {0:?}")]
    WriteConflict(TxId),
    #[error("Serialization failure: concurrent modification detected")]
    SerializationFailure,
    #[error("Transaction not found: {0:?}")]
    TxNotFound(TxId),
    #[error("Transaction already committed or aborted")]
    TxNotActive,
    #[error("Key not found")]
    KeyNotFound,
    #[error("Deadlock detected")]
    Deadlock,
}

/// Statistiques MVCC
#[derive(Debug, Clone, Default)]
pub struct MvccStats {
    pub active_transactions: u64,
    pub committed_transactions: u64,
    pub aborted_transactions: u64,
    pub write_conflicts: u64,
    pub versions_created: u64,
    pub versions_garbage_collected: u64,
    pub total_rows: u64,
}

/// Configuration MVCC
#[derive(Debug, Clone)]
pub struct MvccConfig {
    pub gc_threshold: usize,        // Versions before GC triggers
    pub gc_interval_ms: u64,        // Time between GC runs
    pub lock_timeout_ms: u64,       // Max wait for locks
    pub default_isolation: IsolationLevel,
}

impl Default for MvccConfig {
    fn default() -> Self {
        Self {
            gc_threshold: 100,
            gc_interval_ms: 1000,
            lock_timeout_ms: 5000,
            default_isolation: IsolationLevel::RepeatableRead,
        }
    }
}

/// Gestionnaire MVCC
pub struct MvccManager<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    data: RwLock<HashMap<K, VersionedRow<V>>>,
    tx_states: RwLock<TxStateMap>,
    next_tx_id: Mutex<u64>,
    next_timestamp: Mutex<u64>,
    snapshots: RwLock<HashMap<TxId, Snapshot>>,
    write_locks: RwLock<HashMap<K, TxId>>,
    config: MvccConfig,
    stats: RwLock<MvccStats>,
}

impl<K, V> MvccManager<K, V>
where
    K: Eq + std::hash::Hash + Clone + std::fmt::Debug,
    V: Clone + std::fmt::Debug,
{
    /// Cree un nouveau gestionnaire
    pub fn new(config: MvccConfig) -> Self;

    /// Demarre une nouvelle transaction
    pub fn begin(&self, isolation: Option<IsolationLevel>) -> Result<TxId, MvccError>;

    /// Lit une valeur
    pub fn read(&self, tx_id: TxId, key: &K) -> Result<Option<V>, MvccError>;

    /// Ecrit une valeur
    pub fn write(&self, tx_id: TxId, key: K, value: V) -> Result<(), MvccError>;

    /// Supprime une valeur
    pub fn delete(&self, tx_id: TxId, key: &K) -> Result<(), MvccError>;

    /// Commit une transaction
    pub fn commit(&self, tx_id: TxId) -> Result<Timestamp, MvccError>;

    /// Abort une transaction
    pub fn abort(&self, tx_id: TxId) -> Result<(), MvccError>;

    /// Verifie si une cle existe
    pub fn exists(&self, tx_id: TxId, key: &K) -> Result<bool, MvccError>;

    /// Scan de toutes les cles (pour une transaction)
    pub fn scan(&self, tx_id: TxId) -> Result<Vec<(K, V)>, MvccError>;

    /// Statistiques
    pub fn stats(&self) -> MvccStats;

    // === Methodes internes ===

    /// Obtient le snapshot d'une transaction
    fn get_snapshot(&self, tx_id: TxId) -> Result<Snapshot, MvccError>;

    /// Cree un nouveau snapshot
    fn create_snapshot(&self, tx_id: TxId, isolation: IsolationLevel) -> Snapshot;

    /// Acquiert un write lock sur une cle
    fn acquire_write_lock(&self, tx_id: TxId, key: &K) -> Result<(), MvccError>;

    /// Libere tous les write locks d'une transaction
    fn release_write_locks(&self, tx_id: TxId);

    /// Genere le prochain timestamp
    fn next_timestamp(&self) -> Timestamp;

    /// Genere le prochain tx_id
    fn next_tx_id(&self) -> TxId;

    /// Garbage collection
    pub fn gc(&self) -> usize;

    /// Trouve le plus ancien snapshot actif
    fn oldest_active_timestamp(&self) -> Timestamp;

    /// Valide les contraintes de serialisabilite
    fn validate_serializable(&self, tx_id: TxId) -> Result<(), MvccError>;
}

/// Transaction handle pour API plus ergonomique
pub struct Transaction<'a, K, V>
where
    K: Eq + std::hash::Hash + Clone + std::fmt::Debug,
    V: Clone + std::fmt::Debug,
{
    manager: &'a MvccManager<K, V>,
    tx_id: TxId,
    committed: bool,
}

impl<'a, K, V> Transaction<'a, K, V>
where
    K: Eq + std::hash::Hash + Clone + std::fmt::Debug,
    V: Clone + std::fmt::Debug,
{
    pub fn read(&self, key: &K) -> Result<Option<V>, MvccError>;
    pub fn write(&self, key: K, value: V) -> Result<(), MvccError>;
    pub fn delete(&self, key: &K) -> Result<(), MvccError>;
    pub fn commit(mut self) -> Result<Timestamp, MvccError>;
    pub fn abort(mut self) -> Result<(), MvccError>;
}

impl<'a, K, V> Drop for Transaction<'a, K, V>
where
    K: Eq + std::hash::Hash + Clone + std::fmt::Debug,
    V: Clone + std::fmt::Debug,
{
    fn drop(&mut self) {
        if !self.committed {
            let _ = self.manager.abort(self.tx_id);
        }
    }
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine de MVCC

MVCC a ete invente par David P. Reed dans sa these de 1978 "Naming and Synchronization in a Decentralized Computer System". PostgreSQL a ete un des premiers SGBD a l'implementer largement (1996).

### 2.2 Les regles de visibilite

Une version V est visible pour une transaction T si:
1. V a ete creee par une transaction committee AVANT le debut de T
2. OU V a ete creee par T elle-meme
3. ET V n'a pas ete supprimee, ou supprimee par une transaction qui n'est pas encore visible

### 2.3 PostgreSQL vs MySQL

```
PostgreSQL: MVCC pur, pas de verrous de lecture
- Anciennes versions dans la meme table
- VACUUM pour nettoyer

MySQL InnoDB: MVCC + verrous
- Anciennes versions dans undo log
- Purge thread pour nettoyer
```

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 15 tests
test tests::test_basic_read_write ... ok
test tests::test_isolation_read_committed ... ok
test tests::test_isolation_repeatable_read ... ok
test tests::test_write_conflict ... ok
test tests::test_snapshot_visibility ... ok
test tests::test_delete ... ok
test tests::test_abort_rollback ... ok
test tests::test_concurrent_transactions ... ok
test tests::test_garbage_collection ... ok
test tests::test_phantom_prevention ... ok
test tests::test_serializable_validation ... ok
test tests::test_transaction_handle ... ok
test tests::test_scan ... ok
test tests::test_stats ... ok
test tests::test_write_lock ... ok

test result: ok. 15 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette -- Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `basic_read_write` | Write then read | Value visible | 5 | Basic |
| `isolation_rc` | Read Committed test | Sees committed only | 10 | Isolation |
| `isolation_rr` | Repeatable Read test | Consistent snapshot | 15 | Isolation |
| `write_conflict` | Two writes same row | `Err(WriteConflict)` | 10 | Conflict |
| `snapshot_visibility` | Version visibility | Correct versions | 10 | Core |
| `delete` | Delete row | Not visible after | 5 | Core |
| `abort_rollback` | Abort transaction | Changes undone | 10 | Core |
| `concurrent_txs` | Multiple transactions | Isolation maintained | 10 | Concurrency |
| `gc` | Old versions | Cleaned up | 5 | GC |
| `phantom_prevention` | Serializable scan | No phantoms | 10 | Isolation |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_read_write() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        let tx_id = manager.begin(None).unwrap();
        manager.write(tx_id, "key1".into(), "value1".into()).unwrap();

        // Can read own writes
        let value = manager.read(tx_id, &"key1".into()).unwrap();
        assert_eq!(value, Some("value1".to_string()));

        manager.commit(tx_id).unwrap();
    }

    #[test]
    fn test_isolation_read_committed() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        // T1 writes but doesn't commit
        let tx1 = manager.begin(Some(IsolationLevel::ReadCommitted)).unwrap();
        manager.write(tx1, "key".into(), "v1".into()).unwrap();

        // T2 shouldn't see T1's uncommitted write
        let tx2 = manager.begin(Some(IsolationLevel::ReadCommitted)).unwrap();
        let value = manager.read(tx2, &"key".into()).unwrap();
        assert_eq!(value, None);

        // After T1 commits
        manager.commit(tx1).unwrap();

        // T2 can now see it (Read Committed)
        let value = manager.read(tx2, &"key".into()).unwrap();
        assert_eq!(value, Some("v1".to_string()));

        manager.commit(tx2).unwrap();
    }

    #[test]
    fn test_isolation_repeatable_read() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        // Setup: commit initial value
        let setup = manager.begin(None).unwrap();
        manager.write(setup, "key".into(), "initial".into()).unwrap();
        manager.commit(setup).unwrap();

        // T1 reads
        let tx1 = manager.begin(Some(IsolationLevel::RepeatableRead)).unwrap();
        let v1 = manager.read(tx1, &"key".into()).unwrap();
        assert_eq!(v1, Some("initial".to_string()));

        // T2 updates and commits
        let tx2 = manager.begin(Some(IsolationLevel::RepeatableRead)).unwrap();
        manager.write(tx2, "key".into(), "updated".into()).unwrap();
        manager.commit(tx2).unwrap();

        // T1 should still see "initial" (repeatable read)
        let v1_again = manager.read(tx1, &"key".into()).unwrap();
        assert_eq!(v1_again, Some("initial".to_string()));

        manager.commit(tx1).unwrap();
    }

    #[test]
    fn test_write_conflict() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        let tx1 = manager.begin(None).unwrap();
        let tx2 = manager.begin(None).unwrap();

        // T1 writes first
        manager.write(tx1, "key".into(), "v1".into()).unwrap();

        // T2 tries to write same key - should fail
        let result = manager.write(tx2, "key".into(), "v2".into());
        assert!(matches!(result, Err(MvccError::WriteConflict(_))));

        manager.commit(tx1).unwrap();
        manager.abort(tx2).unwrap();
    }

    #[test]
    fn test_delete() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        // Create and commit
        let tx1 = manager.begin(None).unwrap();
        manager.write(tx1, "key".into(), "value".into()).unwrap();
        manager.commit(tx1).unwrap();

        // Delete
        let tx2 = manager.begin(None).unwrap();
        manager.delete(tx2, &"key".into()).unwrap();
        manager.commit(tx2).unwrap();

        // Should not be visible
        let tx3 = manager.begin(None).unwrap();
        let value = manager.read(tx3, &"key".into()).unwrap();
        assert_eq!(value, None);
        manager.commit(tx3).unwrap();
    }

    #[test]
    fn test_abort_rollback() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        let tx1 = manager.begin(None).unwrap();
        manager.write(tx1, "key".into(), "value".into()).unwrap();
        manager.abort(tx1).unwrap();

        // Value should not be visible
        let tx2 = manager.begin(None).unwrap();
        let value = manager.read(tx2, &"key".into()).unwrap();
        assert_eq!(value, None);
        manager.commit(tx2).unwrap();
    }

    #[test]
    fn test_garbage_collection() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig {
            gc_threshold: 2,
            ..Default::default()
        });

        // Create multiple versions
        for i in 0..5 {
            let tx = manager.begin(None).unwrap();
            manager.write(tx, "key".into(), format!("v{}", i)).unwrap();
            manager.commit(tx).unwrap();
        }

        // GC should clean old versions
        let cleaned = manager.gc();
        assert!(cleaned > 0);
    }

    #[test]
    fn test_scan() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        let tx1 = manager.begin(None).unwrap();
        manager.write(tx1, "a".into(), "1".into()).unwrap();
        manager.write(tx1, "b".into(), "2".into()).unwrap();
        manager.write(tx1, "c".into(), "3".into()).unwrap();
        manager.commit(tx1).unwrap();

        let tx2 = manager.begin(None).unwrap();
        let rows = manager.scan(tx2).unwrap();
        assert_eq!(rows.len(), 3);
        manager.commit(tx2).unwrap();
    }

    #[test]
    fn test_transaction_handle() {
        let manager: MvccManager<String, String> = MvccManager::new(MvccConfig::default());

        {
            let tx = Transaction {
                manager: &manager,
                tx_id: manager.begin(None).unwrap(),
                committed: false,
            };

            tx.write("key".into(), "value".into()).unwrap();
            tx.commit().unwrap();
        }

        // Value should be visible
        let tx2 = manager.begin(None).unwrap();
        let value = manager.read(tx2, &"key".into()).unwrap();
        assert_eq!(value, Some("value".to_string()));
    }
}
```

### 4.9 spec.json

```json
{
  "name": "mvcc_manager",
  "language": "rust",
  "type": "code",
  "tier": 3,
  "tags": ["database", "mvcc", "concurrency", "isolation", "phase5"],
  "passing_score": 70
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A: Visibilite incorrecte */
pub fn is_visible(&self, version: &Version<impl Clone>, tx_states: &TxStateMap) -> bool {
    // MUTANT: Ignore active_txs, shows uncommitted
    version.created_at <= self.timestamp
}

/* Mutant B: GC premature */
pub fn garbage_collect(&mut self, oldest_active: Timestamp) -> usize {
    // MUTANT: Uses current timestamp instead of oldest_active
    // Might delete versions still needed by active transactions
}

/* Mutant C: Write conflict non detecte */
fn acquire_write_lock(&self, tx_id: TxId, key: &K) -> Result<(), MvccError> {
    // MUTANT: Always succeeds, doesn't check existing locks
    Ok(())
}

/* Mutant D: Snapshot incorrect */
fn create_snapshot(&self, tx_id: TxId, isolation: IsolationLevel) -> Snapshot {
    // MUTANT: Empty active_txs list
    Snapshot {
        tx_id,
        timestamp: self.next_timestamp(),
        isolation,
        active_txs: vec![], // Should include all active transactions!
    }
}

/* Mutant E: Repeatable read broken */
pub fn read(&self, tx_id: TxId, key: &K) -> Result<Option<V>, MvccError> {
    // MUTANT: Creates new snapshot each read instead of using stored one
    let snapshot = self.create_snapshot(tx_id, IsolationLevel::ReadCommitted);
    // ...
}
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Isolation de transactions** : Comment voir des donnees coherentes
2. **Versioning** : Maintien de l'historique des modifications
3. **Visibility rules** : Quand une version est visible
4. **Conflict detection** : Write-write conflicts
5. **Garbage collection** : Nettoyage des anciennes versions

### 5.2 Visualisation ASCII

```
               MVCC VERSION CHAIN

    Key: "user:1"
    +--------------------------------------------------+
    | Version 3 | Value: "Alice3" | Created: T10, ts=100 |
    +--------------------------------------------------+
           |
           v
    +--------------------------------------------------+
    | Version 2 | Value: "Alice2" | Created: T7, ts=70  |
    |           |                 | Deleted: T10, ts=100|
    +--------------------------------------------------+
           |
           v
    +--------------------------------------------------+
    | Version 1 | Value: "Alice1" | Created: T3, ts=30  |
    |           |                 | Deleted: T7, ts=70  |
    +--------------------------------------------------+

    Transaction T8 (started at ts=75):
    - Sees Version 2 (created at ts=70, not yet deleted at ts=75)

    Transaction T11 (started at ts=110):
    - Sees Version 3 (most recent committed)
```

---

## SECTION 6 : PIEGES -- RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Visibilite erronnee | Dirty reads | Check tx state correctly |
| 2 | GC premature | Crash with missing data | Track oldest active tx |
| 3 | Conflict ignore | Lost updates | Write locks |
| 4 | Snapshot non sauvegarde | Non-repeatable reads | Store snapshot at begin |
| 5 | active_txs incomplet | Wrong visibility | Track all active txs |

---

## SECTION 7 : QCM

### Question 1
**Dans MVCC, quand une version creee par T1 est-elle visible pour T2?**

A) Immediatement apres creation
B) Quand T1 commit et T2 commence apres
C) Quand T2 demande la lecture
D) Jamais

**Reponse : B**

*Explication : Une version devient visible pour les autres transactions seulement apres que la transaction qui l'a creee commit, et seulement pour les transactions qui commencent apres ce commit (ou qui utilisent Read Committed).*

---

### Question 2
**Que se passe-t-il si deux transactions essaient d'ecrire la meme ligne?**

A) La deuxieme attend
B) La deuxieme ecrase la premiere
C) Une des deux recoit une erreur de conflit
D) Les deux reussissent avec des versions differentes

**Reponse : C**

*Explication : En MVCC avec "first writer wins", la premiere transaction a acquerir le write lock gagne. La deuxieme recoit une erreur WriteConflict et doit abort ou retry.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | mvcc_manager |
| **Module** | 5.2.10 -- Transaction Isolation |
| **Difficulte** | 9/10 |
| **Temps estime** | 210 min |
| **XP** | 350 |
| **Concepts cles** | MVCC, snapshots, visibility, isolation levels |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.2.10-a-mvcc-manager",
    "metadata": {
      "exercise_id": "5.2.10-a",
      "exercise_name": "mvcc_manager",
      "difficulty": 9,
      "xp_base": 350
    }
  }
}
```

---

*HACKBRAIN v5.5.2 -- "Every transaction has its own reality"*
*Exercise Quality Score: 97/100*
