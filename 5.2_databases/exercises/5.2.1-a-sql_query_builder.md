<thinking>
## Analyse du Concept
- Concept : SQL Query Builder Type-Safe
- Phase demandee : 5.2 (Databases)
- Adapte ? OUI - La construction programmatique de requetes SQL est fondamentale pour tout developpeur backend

## Combo Base + Bonus
- Exercice de base : Implementer SELECT, INSERT, UPDATE, DELETE avec parametres
- Bonus 1 : Subqueries et CTEs (Common Table Expressions)
- Bonus 2 : Query validation et SQL AST
- Palier bonus : AVANCE (Subqueries) puis EXPERT (AST validation)
- Progression logique ? OUI - Base = DML standard, Bonus = compositions avancees

## Prerequis & Difficulte
- Prerequis reels : Rust ownership, enums, pattern matching, From trait
- Difficulte estimee : 6/10 (base), 7/10 (bonus subqueries), 9/10 (bonus AST)
- Coherent avec phase 5.2 ? OUI

## Aspect Fun/Culture
- Contexte choisi : "Bobby Tables" - La celebre BD XKCD sur l'injection SQL
- MEME mnemonique : "Little Bobby Tables we call him" - Le rappel permanent de pourquoi parametrer
- Pourquoi c'est fun : Chaque developpeur connait cette BD et les injections SQL

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Injection) : Concatenation directe au lieu de parametres - vulnerable aux injections
2. Mutant B (Index) : Mauvais compteur de parametres $1, $2... - parametres decales
3. Mutant C (Order) : LIMIT avant ORDER BY - SQL invalide
4. Mutant D (Logic) : AND au lieu de OR dans les conditions - logique inversee
5. Mutant E (Escape) : Oubli d'echapper les noms de colonnes - SQL injection via colonnes

## Verdict
VALIDE - L'exercice est complet, securitaire, et teste des competences critiques en production
</thinking>

---

# Exercice 5.2.1-a : sql_query_builder

**Module :**
5.2.1 — SQL Fundamentals

**Concept :**
a — Query Builder Type-Safe (DML Operations)

**Difficulte :**
&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9734;&#9734;&#9734;&#9734; (6/10)

**Type :**
complet

**Tiers :**
2 — Integration de concepts multiples

**Langage :**
Rust Edition 2024

**Prerequis :**
- Rust ownership et borrowing
- Enums et pattern matching
- Trait From/Into
- Generics de base
- Notions SQL (SELECT, INSERT, UPDATE, DELETE)

**Domaines :**
SQL, Security, API Design

**Duree estimee :**
90 min

**XP Base :**
250

**Complexite :**
T[3] O(n) construction lineaire x S[2] O(n) stockage parametres

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
- Rust : `src/lib.rs`, `Cargo.toml`

**Fonctions autorisees :**
- Rust : `std::fmt`, `String`, `Vec`, `Option`, `From/Into`

**Fonctions interdites :**
- Rust : `sqlx`, `diesel`, `sea-query`, toute crate externe de query building
- Format string interpolation directe avec des valeurs utilisateur

### 1.2 Consigne

**BOBBY TABLES DEFENSE SYSTEM — Le Bouclier Anti-Injection**

*"Exploits of a Mom" - XKCD #327*

```
School: Hi, this is your son's school. We're having some computer trouble.
Mom: Oh, dear -- Did he break something?
School: In a way. Did you really name your son Robert'); DROP TABLE Students;--?
Mom: Oh. Yes. Little Bobby Tables we call him.
School: Well, we've lost this year's student records. I hope you're happy.
Mom: And I hope you've learned to sanitize your database inputs.
```

Dans ce monde dangereux ou les utilisateurs peuvent entrer `'; DROP TABLE users;--` dans n'importe quel champ, tu dois construire une **forteresse impenetrable** : un Query Builder qui genere UNIQUEMENT des requetes parametrees.

**Ta mission :**

Creer un systeme de builders fluent pour generer des requetes SQL PostgreSQL securisees :

1. **SelectBuilder** : Construire des requetes SELECT avec WHERE, ORDER BY, LIMIT/OFFSET
2. **InsertBuilder** : Construire des requetes INSERT avec colonnes et valeurs
3. **UpdateBuilder** : Construire des requetes UPDATE avec SET et WHERE
4. **DeleteBuilder** : Construire des requetes DELETE avec WHERE
5. **SqlQuery** : Structure de sortie avec SQL et parametres separes

**Regle d'or :**
> JAMAIS de valeur utilisateur dans la string SQL !
> Toujours `$1`, `$2`, etc. avec les valeurs dans `params`

**Entree :**
- Appels de methodes chainees (fluent API)

**Sortie :**
- `SqlQuery { sql: String, params: Vec<SqlValue> }`

**Contraintes :**
- Format parametres PostgreSQL : `$1`, `$2`, `$3`...
- Support des types : NULL, Bool, Int, Float, Text
- Conditions multiples avec AND/OR
- Operateurs : =, <>, <, <=, >, >=, LIKE, ILIKE, IN, IS NULL, IS NOT NULL

**Exemples :**

| Builder | Methodes | SQL genere | Params |
|---------|----------|------------|--------|
| `SelectBuilder::new("users")` | `.build()` | `SELECT * FROM users` | `[]` |
| `SelectBuilder::new("users")` | `.where_eq("id", 42).build()` | `SELECT * FROM users WHERE id = $1` | `[Int(42)]` |
| `InsertBuilder::new("users")` | `.columns(&["name"]).values(vec!["Alice".into()]).build()` | `INSERT INTO users (name) VALUES ($1)` | `[Text("Alice")]` |
| `UpdateBuilder::new("users")` | `.set("name", "Bob").where_eq("id", 1).build()` | `UPDATE users SET name = $1 WHERE id = $2` | `[Text("Bob"), Int(1)]` |
| `DeleteBuilder::new("users")` | `.where_eq("id", 1).build()` | `DELETE FROM users WHERE id = $1` | `[Int(1)]` |

### 1.3 Prototype

**Rust :**
```rust
use std::fmt;

/// Valeur de parametre SQL
#[derive(Debug, Clone, PartialEq)]
pub enum SqlValue {
    Null,
    Bool(bool),
    Int(i64),
    Float(f64),
    Text(String),
}

/// Direction de tri
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SortDirection {
    Asc,
    Desc,
}

/// Operateur de comparaison
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CompareOp {
    Eq,        // =
    Ne,        // <>
    Lt,        // <
    Le,        // <=
    Gt,        // >
    Ge,        // >=
    Like,      // LIKE
    ILike,     // ILIKE (case-insensitive)
    In,        // IN
    IsNull,    // IS NULL
    IsNotNull, // IS NOT NULL
}

/// Operateur logique
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LogicOp {
    And,
    Or,
}

/// Condition WHERE
#[derive(Debug, Clone)]
pub struct Condition {
    pub column: String,
    pub op: CompareOp,
    pub value: Option<SqlValue>,
}

/// Groupe de conditions
#[derive(Debug, Clone, Default)]
pub struct ConditionGroup {
    pub conditions: Vec<(LogicOp, Condition)>,
}

/// Builder pour requetes SELECT
#[derive(Debug, Clone)]
pub struct SelectBuilder {
    table: String,
    columns: Vec<String>,
    conditions: ConditionGroup,
    order_by: Vec<(String, SortDirection)>,
    limit: Option<u64>,
    offset: Option<u64>,
    distinct: bool,
}

/// Builder pour requetes INSERT
#[derive(Debug, Clone)]
pub struct InsertBuilder {
    table: String,
    columns: Vec<String>,
    values: Vec<Vec<SqlValue>>,
    returning: Vec<String>,
}

/// Builder pour requetes UPDATE
#[derive(Debug, Clone)]
pub struct UpdateBuilder {
    table: String,
    sets: Vec<(String, SqlValue)>,
    conditions: ConditionGroup,
    returning: Vec<String>,
}

/// Builder pour requetes DELETE
#[derive(Debug, Clone)]
pub struct DeleteBuilder {
    table: String,
    conditions: ConditionGroup,
    returning: Vec<String>,
}

/// Requete SQL generee avec ses parametres
#[derive(Debug, Clone, PartialEq)]
pub struct SqlQuery {
    pub sql: String,
    pub params: Vec<SqlValue>,
}

// === IMPLEMENTATIONS REQUISES ===

impl SelectBuilder {
    /// Cree un nouveau SELECT sur la table donnee
    pub fn new(table: &str) -> Self;

    /// Specifie les colonnes (defaut: *)
    pub fn columns(self, cols: &[&str]) -> Self;

    /// SELECT DISTINCT
    pub fn distinct(self) -> Self;

    /// Ajoute une condition WHERE (AND avec les precedentes)
    pub fn where_eq(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_ne(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_lt(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_le(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_gt(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_ge(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_like(self, column: &str, pattern: &str) -> Self;
    pub fn where_ilike(self, column: &str, pattern: &str) -> Self;
    pub fn where_in(self, column: &str, values: Vec<SqlValue>) -> Self;
    pub fn where_null(self, column: &str) -> Self;
    pub fn where_not_null(self, column: &str) -> Self;

    /// Ajoute une condition OR
    pub fn or_where_eq(self, column: &str, value: impl Into<SqlValue>) -> Self;

    /// Tri
    pub fn order_by(self, column: &str, direction: SortDirection) -> Self;

    /// Pagination
    pub fn limit(self, limit: u64) -> Self;
    pub fn offset(self, offset: u64) -> Self;

    /// Genere la requete SQL
    pub fn build(self) -> SqlQuery;
}

impl InsertBuilder {
    /// Cree un nouveau INSERT sur la table donnee
    pub fn new(table: &str) -> Self;

    /// Specifie les colonnes
    pub fn columns(self, cols: &[&str]) -> Self;

    /// Ajoute une ligne de valeurs
    pub fn values(self, vals: Vec<SqlValue>) -> Self;

    /// RETURNING clause (PostgreSQL)
    pub fn returning(self, cols: &[&str]) -> Self;

    /// Genere la requete SQL
    pub fn build(self) -> SqlQuery;
}

impl UpdateBuilder {
    /// Cree un nouveau UPDATE sur la table donnee
    pub fn new(table: &str) -> Self;

    /// SET column = value
    pub fn set(self, column: &str, value: impl Into<SqlValue>) -> Self;

    /// Conditions WHERE (memes methodes que SELECT)
    pub fn where_eq(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_ne(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_gt(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_lt(self, column: &str, value: impl Into<SqlValue>) -> Self;

    /// RETURNING clause
    pub fn returning(self, cols: &[&str]) -> Self;

    /// Genere la requete SQL
    pub fn build(self) -> SqlQuery;
}

impl DeleteBuilder {
    /// Cree un nouveau DELETE sur la table donnee
    pub fn new(table: &str) -> Self;

    /// Conditions WHERE
    pub fn where_eq(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_ne(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_gt(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_lt(self, column: &str, value: impl Into<SqlValue>) -> Self;
    pub fn where_in(self, column: &str, values: Vec<SqlValue>) -> Self;

    /// RETURNING clause
    pub fn returning(self, cols: &[&str]) -> Self;

    /// Genere la requete SQL
    pub fn build(self) -> SqlQuery;
}

// === CONVERSIONS Into<SqlValue> ===
impl From<i32> for SqlValue;
impl From<i64> for SqlValue;
impl From<f64> for SqlValue;
impl From<bool> for SqlValue;
impl From<String> for SqlValue;
impl From<&str> for SqlValue;
impl<T: Into<SqlValue>> From<Option<T>> for SqlValue;
```

### 1.2.2 Enonce Academique

Un **Query Builder** est un patron de conception qui permet de construire des requetes SQL de maniere programmatique, en utilisant une API fluide (method chaining).

**Objectifs pedagogiques :**

1. **Securite** : Comprendre pourquoi les requetes parametrees previennent les injections SQL
2. **SQL DML** : Maitriser SELECT, INSERT, UPDATE, DELETE
3. **API Design** : Concevoir une API ergonomique avec le pattern Builder
4. **Type Safety** : Utiliser le systeme de types Rust pour prevenir les erreurs

**Injection SQL - Le probleme :**
```sql
-- Requete naive (DANGEREUSE !)
"SELECT * FROM users WHERE name = '" + user_input + "'"

-- Si user_input = "'; DROP TABLE users;--"
-- Resultat: SELECT * FROM users WHERE name = ''; DROP TABLE users;--'
```

**Requete parametree - La solution :**
```sql
-- SQL avec placeholder
"SELECT * FROM users WHERE name = $1"
-- Parametres separes: ["Alice"]
-- Le driver SQL echappe automatiquement
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Histoire de Bobby Tables

La bande dessinee XKCD #327 "Exploits of a Mom" est devenue virale en 2007 et reste aujourd'hui LA reference quand on parle d'injection SQL. Le site bobby-tables.com (cree par les fans) compile les bonnes pratiques pour chaque langage.

**Fun fact :** En 2014, une entreprise britannique a legalement enregistre le nom ";DROP TABLE companies;-- LTD" pour faire passer un message aux developpeurs negligents !

### 2.2 Les Plus Grandes Injections SQL de l'Histoire

| Annee | Victime | Impact |
|-------|---------|--------|
| 2008 | Heartland Payment | 134 millions de cartes bancaires |
| 2011 | Sony PlayStation | 77 millions de comptes |
| 2015 | TalkTalk | 157,000 clients, amende de 400k GBP |
| 2019 | Fortnite | Vulnerabilite decouverte (corrigee) |

### 2.3 DANS LA VRAIE VIE

| Metier | Utilisation | Cas concret |
|--------|-------------|-------------|
| **Backend Developer** | ORMs et Query Builders | Diesel, SQLx, SeaORM en Rust |
| **Security Engineer** | Audit de code | Detection de concatenations SQL |
| **DBA** | Optimisation | Analyse des requetes generees |
| **DevOps** | Monitoring | Logs des requetes parametrees |

### 2.4 Pourquoi PostgreSQL utilise $1, $2... ?

Chaque SGBD a sa propre syntaxe pour les parametres :
- **PostgreSQL** : `$1`, `$2`, `$3`...
- **MySQL** : `?` (positionnels)
- **SQLite** : `?` ou `:name` (nommes)
- **Oracle** : `:1`, `:2` ou `:name`
- **SQL Server** : `@p1`, `@p2`...

PostgreSQL a choisi les numeros explicites pour permettre de reutiliser le meme parametre plusieurs fois (`WHERE a = $1 OR b = $1`).

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cat Cargo.toml
[package]
name = "sql_query_builder"
version = "0.1.0"
edition = "2024"

[dependencies]

$ cargo build
   Compiling sql_query_builder v0.1.0
    Finished dev [unoptimized + debuginfo]

$ cargo test
   Compiling sql_query_builder v0.1.0
    Finished test [unoptimized + debuginfo]
     Running unittests src/lib.rs

running 22 tests
test tests::test_simple_select ... ok
test tests::test_select_with_columns ... ok
test tests::test_select_distinct ... ok
test tests::test_select_with_where ... ok
test tests::test_select_with_multiple_conditions ... ok
test tests::test_select_with_or ... ok
test tests::test_select_with_like ... ok
test tests::test_select_with_null ... ok
test tests::test_select_with_order_by ... ok
test tests::test_select_with_pagination ... ok
test tests::test_insert_simple ... ok
test tests::test_insert_with_returning ... ok
test tests::test_insert_multiple_rows ... ok
test tests::test_update_simple ... ok
test tests::test_update_multiple_sets ... ok
test tests::test_update_with_returning ... ok
test tests::test_delete_simple ... ok
test tests::test_delete_with_returning ... ok
test tests::test_sql_value_conversions ... ok
test tests::test_select_in_operator ... ok
test tests::test_complex_query ... ok
test tests::test_no_sql_injection ... ok

test result: ok. 22 passed; 0 failed

$ cargo run --example demo
=== SQL Query Builder Demo ===

-- SELECT all users --
SQL: SELECT * FROM users
Params: []

-- SELECT with WHERE --
SQL: SELECT * FROM users WHERE status = $1 AND age > $2
Params: [Text("active"), Int(18)]

-- INSERT new user --
SQL: INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id
Params: [Text("Alice"), Text("alice@example.com")]

-- UPDATE user --
SQL: UPDATE users SET status = $1 WHERE id = $2
Params: [Text("inactive"), Int(42)]

-- DELETE user --
SQL: DELETE FROM users WHERE id = $1 RETURNING email
Params: [Int(42)]

-- Bobby Tables Test --
Input: Robert'); DROP TABLE Students;--
SQL: SELECT * FROM students WHERE name = $1
Params: [Text("Robert'); DROP TABLE Students;--")]
SECURISE !
```

### 3.1 Code de demonstration

```rust
use sql_query_builder::*;

fn main() {
    println!("=== SQL Query Builder Demo ===\n");

    // SELECT simple
    let query = SelectBuilder::new("users").build();
    println!("-- SELECT all users --");
    println!("SQL: {}", query.sql);
    println!("Params: {:?}\n", query.params);

    // SELECT avec conditions multiples
    let query = SelectBuilder::new("users")
        .where_eq("status", "active")
        .where_gt("age", 18)
        .build();
    println!("-- SELECT with WHERE --");
    println!("SQL: {}", query.sql);
    println!("Params: {:?}\n", query.params);

    // INSERT avec RETURNING
    let query = InsertBuilder::new("users")
        .columns(&["name", "email"])
        .values(vec![
            SqlValue::Text("Alice".into()),
            SqlValue::Text("alice@example.com".into()),
        ])
        .returning(&["id"])
        .build();
    println!("-- INSERT new user --");
    println!("SQL: {}", query.sql);
    println!("Params: {:?}\n", query.params);

    // UPDATE avec WHERE
    let query = UpdateBuilder::new("users")
        .set("status", "inactive")
        .where_eq("id", 42)
        .build();
    println!("-- UPDATE user --");
    println!("SQL: {}", query.sql);
    println!("Params: {:?}\n", query.params);

    // DELETE avec RETURNING
    let query = DeleteBuilder::new("users")
        .where_eq("id", 42)
        .returning(&["email"])
        .build();
    println!("-- DELETE user --");
    println!("SQL: {}", query.sql);
    println!("Params: {:?}\n", query.params);

    // Test Bobby Tables
    let malicious_input = "Robert'); DROP TABLE Students;--";
    let query = SelectBuilder::new("students")
        .where_eq("name", malicious_input)
        .build();
    println!("-- Bobby Tables Test --");
    println!("Input: {}", malicious_input);
    println!("SQL: {}", query.sql);
    println!("Params: {:?}", query.params);
    println!("SECURISE !");
}
```

### 3.2 BONUS AVANCE : Subqueries (OPTIONNEL)

**Difficulte Bonus :**
&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9734;&#9734;&#9734; (7/10)

**Recompense :**
XP x2.5

**Ta mission :**

Ajouter le support des sous-requetes :

```rust
impl SelectBuilder {
    /// WHERE column IN (SELECT ...)
    pub fn where_in_subquery(self, column: &str, subquery: SelectBuilder) -> Self;

    /// WHERE EXISTS (SELECT ...)
    pub fn where_exists(self, subquery: SelectBuilder) -> Self;

    /// FROM (SELECT ...) AS alias
    pub fn from_subquery(subquery: SelectBuilder, alias: &str) -> Self;
}
```

**Exemple :**
```rust
let subquery = SelectBuilder::new("orders")
    .columns(&["user_id"])
    .where_gt("amount", 1000);

let query = SelectBuilder::new("users")
    .columns(&["name", "email"])
    .where_in_subquery("id", subquery)
    .build();

// SQL: SELECT name, email FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount > $1)
// Params: [Int(1000)]
```

### 3.3 BONUS EXPERT : Query Validation (OPTIONNEL)

**Difficulte Bonus :**
&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9734; (9/10)

**Recompense :**
XP x4

**Ta mission :**

Implementer un systeme de validation des requetes AVANT execution :

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum QueryError {
    EmptyTable,
    EmptyColumns,
    MismatchedValues { columns: usize, values: usize },
    UpdateWithoutWhere,
    DeleteWithoutWhere,
    InvalidColumnName(String),
    DuplicateColumn(String),
}

impl SelectBuilder {
    pub fn validate(&self) -> Result<(), QueryError>;
    pub fn build_validated(self) -> Result<SqlQuery, QueryError>;
}

// Meme chose pour Insert, Update, Delete
```

**Contraintes :**
- `UpdateBuilder` et `DeleteBuilder` sans WHERE doivent retourner une erreur (protection contre suppression de toute la table)
- Les noms de colonnes doivent etre valides (alphanumerique + underscore)
- Le nombre de valeurs doit correspondre au nombre de colonnes dans INSERT

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Input | Expected | Points | Trap |
|------|-------|----------|--------|------|
| `test_simple_select` | `SelectBuilder::new("users").build()` | `sql == "SELECT * FROM users"` | 3 | |
| `test_select_columns` | `.columns(&["id", "name"])` | `sql == "SELECT id, name FROM users"` | 3 | |
| `test_select_distinct` | `.distinct()` | `sql.contains("DISTINCT")` | 2 | |
| `test_where_eq` | `.where_eq("id", 42)` | `sql.contains("WHERE id = $1")`, `params[0] == Int(42)` | 5 | |
| `test_where_multiple` | `.where_eq("a", 1).where_gt("b", 2)` | `...AND...`, 2 params | 5 | |
| `test_where_or` | `.where_eq("a", 1).or_where_eq("a", 2)` | `...OR...` | 5 | |
| `test_where_like` | `.where_like("name", "%john%")` | `LIKE $1` | 4 | |
| `test_where_ilike` | `.where_ilike("name", "%john%")` | `ILIKE $1` | 3 | |
| `test_where_in` | `.where_in("id", vec![1,2,3])` | `IN ($1, $2, $3)` | 5 | |
| `test_where_null` | `.where_null("deleted_at")` | `IS NULL`, no param | 4 | |
| `test_where_not_null` | `.where_not_null("email")` | `IS NOT NULL` | 3 | |
| `test_order_by_single` | `.order_by("name", Asc)` | `ORDER BY name ASC` | 4 | |
| `test_order_by_multiple` | `.order_by("a", Desc).order_by("b", Asc)` | `ORDER BY a DESC, b ASC` | 4 | |
| `test_limit` | `.limit(10)` | `LIMIT 10` | 3 | |
| `test_offset` | `.offset(20)` | `OFFSET 20` | 3 | |
| `test_pagination` | `.limit(10).offset(20)` | `LIMIT 10 OFFSET 20` | 3 | |
| `test_insert_simple` | `InsertBuilder...` | `INSERT INTO...VALUES ($1)` | 5 | |
| `test_insert_multi_cols` | `.columns(&["a","b"]).values(...)` | `(a, b) VALUES ($1, $2)` | 5 | |
| `test_insert_multi_rows` | `.values(...).values(...)` | `VALUES ($1), ($2)` | 5 | |
| `test_insert_returning` | `.returning(&["id"])` | `RETURNING id` | 4 | |
| `test_update_simple` | `UpdateBuilder...set...where_eq...` | `UPDATE...SET...WHERE...` | 5 | |
| `test_update_multi_sets` | `.set("a", 1).set("b", 2)` | `SET a = $1, b = $2` | 5 | |
| `test_delete_simple` | `DeleteBuilder...where_eq...` | `DELETE FROM...WHERE...` | 5 | |
| `test_delete_returning` | `.returning(&["id"])` | `RETURNING id` | 3 | |
| `test_conversions` | `From<i32>`, `From<&str>`, etc. | All conversions work | 5 | |
| `test_no_injection` | Malicious input | Value in params, not SQL | 5 | |
| **TOTAL** | | | **100** | |

### 4.2 Tests unitaires complets

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_select() {
        let query = SelectBuilder::new("users").build();
        assert_eq!(query.sql, "SELECT * FROM users");
        assert!(query.params.is_empty());
    }

    #[test]
    fn test_select_with_columns() {
        let query = SelectBuilder::new("users")
            .columns(&["id", "name", "email"])
            .build();
        assert_eq!(query.sql, "SELECT id, name, email FROM users");
    }

    #[test]
    fn test_select_distinct() {
        let query = SelectBuilder::new("orders")
            .columns(&["status"])
            .distinct()
            .build();
        assert_eq!(query.sql, "SELECT DISTINCT status FROM orders");
    }

    #[test]
    fn test_select_with_where() {
        let query = SelectBuilder::new("users")
            .where_eq("id", 42)
            .build();
        assert_eq!(query.sql, "SELECT * FROM users WHERE id = $1");
        assert_eq!(query.params, vec![SqlValue::Int(42)]);
    }

    #[test]
    fn test_select_with_multiple_conditions() {
        let query = SelectBuilder::new("users")
            .where_eq("status", "active")
            .where_gt("age", 18)
            .build();
        assert_eq!(
            query.sql,
            "SELECT * FROM users WHERE status = $1 AND age > $2"
        );
        assert_eq!(query.params.len(), 2);
    }

    #[test]
    fn test_select_with_or() {
        let query = SelectBuilder::new("products")
            .where_eq("category", "electronics")
            .or_where_eq("category", "computers")
            .build();
        assert_eq!(
            query.sql,
            "SELECT * FROM products WHERE category = $1 OR category = $2"
        );
    }

    #[test]
    fn test_select_with_like() {
        let query = SelectBuilder::new("users")
            .where_like("name", "%john%")
            .build();
        assert_eq!(query.sql, "SELECT * FROM users WHERE name LIKE $1");
        assert_eq!(query.params[0], SqlValue::Text("%john%".to_string()));
    }

    #[test]
    fn test_select_with_null() {
        let query = SelectBuilder::new("orders")
            .where_null("shipped_at")
            .build();
        assert_eq!(query.sql, "SELECT * FROM orders WHERE shipped_at IS NULL");
        assert!(query.params.is_empty());
    }

    #[test]
    fn test_select_with_order_by() {
        let query = SelectBuilder::new("products")
            .order_by("price", SortDirection::Desc)
            .order_by("name", SortDirection::Asc)
            .build();
        assert_eq!(
            query.sql,
            "SELECT * FROM products ORDER BY price DESC, name ASC"
        );
    }

    #[test]
    fn test_select_with_pagination() {
        let query = SelectBuilder::new("users")
            .order_by("created_at", SortDirection::Desc)
            .limit(10)
            .offset(20)
            .build();
        assert_eq!(
            query.sql,
            "SELECT * FROM users ORDER BY created_at DESC LIMIT 10 OFFSET 20"
        );
    }

    #[test]
    fn test_insert_simple() {
        let query = InsertBuilder::new("users")
            .columns(&["name", "email"])
            .values(vec![
                SqlValue::Text("Alice".into()),
                SqlValue::Text("alice@example.com".into()),
            ])
            .build();
        assert_eq!(
            query.sql,
            "INSERT INTO users (name, email) VALUES ($1, $2)"
        );
        assert_eq!(query.params.len(), 2);
    }

    #[test]
    fn test_insert_with_returning() {
        let query = InsertBuilder::new("users")
            .columns(&["name"])
            .values(vec![SqlValue::Text("Bob".into())])
            .returning(&["id", "created_at"])
            .build();
        assert_eq!(
            query.sql,
            "INSERT INTO users (name) VALUES ($1) RETURNING id, created_at"
        );
    }

    #[test]
    fn test_insert_multiple_rows() {
        let query = InsertBuilder::new("tags")
            .columns(&["name"])
            .values(vec![SqlValue::Text("rust".into())])
            .values(vec![SqlValue::Text("async".into())])
            .values(vec![SqlValue::Text("database".into())])
            .build();
        assert_eq!(
            query.sql,
            "INSERT INTO tags (name) VALUES ($1), ($2), ($3)"
        );
        assert_eq!(query.params.len(), 3);
    }

    #[test]
    fn test_update_simple() {
        let query = UpdateBuilder::new("users")
            .set("name", "Alice Updated")
            .where_eq("id", 1)
            .build();
        assert_eq!(
            query.sql,
            "UPDATE users SET name = $1 WHERE id = $2"
        );
    }

    #[test]
    fn test_update_multiple_sets() {
        let query = UpdateBuilder::new("users")
            .set("name", "Alice")
            .set("status", "inactive")
            .where_eq("id", 42)
            .build();
        assert_eq!(
            query.sql,
            "UPDATE users SET name = $1, status = $2 WHERE id = $3"
        );
    }

    #[test]
    fn test_update_with_returning() {
        let query = UpdateBuilder::new("products")
            .set("price", 99.99)
            .where_eq("id", 1)
            .returning(&["id", "price", "updated_at"])
            .build();
        assert!(query.sql.contains("RETURNING id, price, updated_at"));
    }

    #[test]
    fn test_delete_simple() {
        let query = DeleteBuilder::new("sessions")
            .where_eq("user_id", 42)
            .build();
        assert_eq!(
            query.sql,
            "DELETE FROM sessions WHERE user_id = $1"
        );
    }

    #[test]
    fn test_delete_with_returning() {
        let query = DeleteBuilder::new("users")
            .where_eq("id", 1)
            .returning(&["id", "email"])
            .build();
        assert_eq!(
            query.sql,
            "DELETE FROM users WHERE id = $1 RETURNING id, email"
        );
    }

    #[test]
    fn test_sql_value_conversions() {
        assert_eq!(SqlValue::from(42i32), SqlValue::Int(42));
        assert_eq!(SqlValue::from(42i64), SqlValue::Int(42));
        assert_eq!(SqlValue::from(3.14f64), SqlValue::Float(3.14));
        assert_eq!(SqlValue::from(true), SqlValue::Bool(true));
        assert_eq!(SqlValue::from("hello"), SqlValue::Text("hello".to_string()));
        assert_eq!(SqlValue::from(None::<i32>), SqlValue::Null);
    }

    #[test]
    fn test_select_in_operator() {
        let query = SelectBuilder::new("users")
            .where_in("status", vec![
                SqlValue::Text("active".into()),
                SqlValue::Text("pending".into()),
            ])
            .build();
        assert_eq!(
            query.sql,
            "SELECT * FROM users WHERE status IN ($1, $2)"
        );
    }

    #[test]
    fn test_no_sql_injection() {
        let malicious = "Robert'); DROP TABLE Students;--";
        let query = SelectBuilder::new("students")
            .where_eq("name", malicious)
            .build();

        // Le SQL ne doit PAS contenir le code malveillant
        assert!(!query.sql.contains("DROP TABLE"));
        assert!(query.sql.contains("$1"));

        // La valeur malveillante doit etre dans les parametres
        assert_eq!(query.params[0], SqlValue::Text(malicious.to_string()));
    }

    #[test]
    fn test_complex_query() {
        let query = SelectBuilder::new("orders")
            .columns(&["id", "user_id", "total", "status"])
            .where_eq("status", "pending")
            .where_gt("total", 100)
            .where_not_null("user_id")
            .order_by("created_at", SortDirection::Desc)
            .limit(50)
            .offset(0)
            .build();

        assert!(query.sql.contains("SELECT id, user_id, total, status"));
        assert!(query.sql.contains("FROM orders"));
        assert!(query.sql.contains("WHERE"));
        assert!(query.sql.contains("ORDER BY created_at DESC"));
        assert!(query.sql.contains("LIMIT 50"));
    }
}
```

### 4.3 Solution de reference

```rust
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum SqlValue {
    Null,
    Bool(bool),
    Int(i64),
    Float(f64),
    Text(String),
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SortDirection {
    Asc,
    Desc,
}

impl fmt::Display for SortDirection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SortDirection::Asc => write!(f, "ASC"),
            SortDirection::Desc => write!(f, "DESC"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CompareOp {
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
    Like,
    ILike,
    In,
    IsNull,
    IsNotNull,
}

impl CompareOp {
    fn to_sql(&self) -> &'static str {
        match self {
            CompareOp::Eq => "=",
            CompareOp::Ne => "<>",
            CompareOp::Lt => "<",
            CompareOp::Le => "<=",
            CompareOp::Gt => ">",
            CompareOp::Ge => ">=",
            CompareOp::Like => "LIKE",
            CompareOp::ILike => "ILIKE",
            CompareOp::In => "IN",
            CompareOp::IsNull => "IS NULL",
            CompareOp::IsNotNull => "IS NOT NULL",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LogicOp {
    And,
    Or,
}

impl fmt::Display for LogicOp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LogicOp::And => write!(f, "AND"),
            LogicOp::Or => write!(f, "OR"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Condition {
    pub column: String,
    pub op: CompareOp,
    pub value: Option<SqlValue>,
    pub in_values: Vec<SqlValue>,
}

#[derive(Debug, Clone, Default)]
pub struct ConditionGroup {
    pub conditions: Vec<(LogicOp, Condition)>,
}

impl ConditionGroup {
    fn new() -> Self {
        Self { conditions: Vec::new() }
    }

    fn add(&mut self, logic: LogicOp, column: &str, op: CompareOp, value: Option<SqlValue>) {
        self.conditions.push((
            logic,
            Condition {
                column: column.to_string(),
                op,
                value,
                in_values: Vec::new(),
            },
        ));
    }

    fn add_in(&mut self, logic: LogicOp, column: &str, values: Vec<SqlValue>) {
        self.conditions.push((
            logic,
            Condition {
                column: column.to_string(),
                op: CompareOp::In,
                value: None,
                in_values: values,
            },
        ));
    }

    fn build(&self, param_offset: &mut usize) -> (String, Vec<SqlValue>) {
        if self.conditions.is_empty() {
            return (String::new(), Vec::new());
        }

        let mut parts = Vec::new();
        let mut params = Vec::new();

        for (i, (logic, cond)) in self.conditions.iter().enumerate() {
            let part = match cond.op {
                CompareOp::IsNull | CompareOp::IsNotNull => {
                    format!("{} {}", cond.column, cond.op.to_sql())
                }
                CompareOp::In => {
                    let placeholders: Vec<String> = cond
                        .in_values
                        .iter()
                        .map(|v| {
                            *param_offset += 1;
                            params.push(v.clone());
                            format!("${}", *param_offset)
                        })
                        .collect();
                    format!("{} IN ({})", cond.column, placeholders.join(", "))
                }
                _ => {
                    *param_offset += 1;
                    if let Some(ref v) = cond.value {
                        params.push(v.clone());
                    }
                    format!("{} {} ${}", cond.column, cond.op.to_sql(), *param_offset)
                }
            };

            if i == 0 {
                parts.push(part);
            } else {
                parts.push(format!("{} {}", logic, part));
            }
        }

        (format!("WHERE {}", parts.join(" ")), params)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct SqlQuery {
    pub sql: String,
    pub params: Vec<SqlValue>,
}

// === SelectBuilder ===

#[derive(Debug, Clone)]
pub struct SelectBuilder {
    table: String,
    columns: Vec<String>,
    conditions: ConditionGroup,
    order_by: Vec<(String, SortDirection)>,
    limit: Option<u64>,
    offset: Option<u64>,
    distinct: bool,
}

impl SelectBuilder {
    pub fn new(table: &str) -> Self {
        Self {
            table: table.to_string(),
            columns: Vec::new(),
            conditions: ConditionGroup::new(),
            order_by: Vec::new(),
            limit: None,
            offset: None,
            distinct: false,
        }
    }

    pub fn columns(mut self, cols: &[&str]) -> Self {
        self.columns = cols.iter().map(|s| s.to_string()).collect();
        self
    }

    pub fn distinct(mut self) -> Self {
        self.distinct = true;
        self
    }

    pub fn where_eq(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Eq, Some(value.into()));
        self
    }

    pub fn where_ne(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Ne, Some(value.into()));
        self
    }

    pub fn where_lt(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Lt, Some(value.into()));
        self
    }

    pub fn where_le(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Le, Some(value.into()));
        self
    }

    pub fn where_gt(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Gt, Some(value.into()));
        self
    }

    pub fn where_ge(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Ge, Some(value.into()));
        self
    }

    pub fn where_like(mut self, column: &str, pattern: &str) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Like, Some(SqlValue::Text(pattern.to_string())));
        self
    }

    pub fn where_ilike(mut self, column: &str, pattern: &str) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::ILike, Some(SqlValue::Text(pattern.to_string())));
        self
    }

    pub fn where_in(mut self, column: &str, values: Vec<SqlValue>) -> Self {
        self.conditions.add_in(LogicOp::And, column, values);
        self
    }

    pub fn where_null(mut self, column: &str) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::IsNull, None);
        self
    }

    pub fn where_not_null(mut self, column: &str) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::IsNotNull, None);
        self
    }

    pub fn or_where_eq(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::Or, column, CompareOp::Eq, Some(value.into()));
        self
    }

    pub fn order_by(mut self, column: &str, direction: SortDirection) -> Self {
        self.order_by.push((column.to_string(), direction));
        self
    }

    pub fn limit(mut self, limit: u64) -> Self {
        self.limit = Some(limit);
        self
    }

    pub fn offset(mut self, offset: u64) -> Self {
        self.offset = Some(offset);
        self
    }

    pub fn build(self) -> SqlQuery {
        let mut parts = Vec::new();
        let mut params = Vec::new();

        // SELECT
        let cols = if self.columns.is_empty() {
            "*".to_string()
        } else {
            self.columns.join(", ")
        };

        if self.distinct {
            parts.push(format!("SELECT DISTINCT {}", cols));
        } else {
            parts.push(format!("SELECT {}", cols));
        }

        // FROM
        parts.push(format!("FROM {}", self.table));

        // WHERE
        let mut param_offset = 0;
        let (where_clause, where_params) = self.conditions.build(&mut param_offset);
        if !where_clause.is_empty() {
            parts.push(where_clause);
            params.extend(where_params);
        }

        // ORDER BY
        if !self.order_by.is_empty() {
            let order_parts: Vec<String> = self
                .order_by
                .iter()
                .map(|(col, dir)| format!("{} {}", col, dir))
                .collect();
            parts.push(format!("ORDER BY {}", order_parts.join(", ")));
        }

        // LIMIT
        if let Some(limit) = self.limit {
            parts.push(format!("LIMIT {}", limit));
        }

        // OFFSET
        if let Some(offset) = self.offset {
            parts.push(format!("OFFSET {}", offset));
        }

        SqlQuery {
            sql: parts.join(" "),
            params,
        }
    }
}

// === InsertBuilder ===

#[derive(Debug, Clone)]
pub struct InsertBuilder {
    table: String,
    columns: Vec<String>,
    values: Vec<Vec<SqlValue>>,
    returning: Vec<String>,
}

impl InsertBuilder {
    pub fn new(table: &str) -> Self {
        Self {
            table: table.to_string(),
            columns: Vec::new(),
            values: Vec::new(),
            returning: Vec::new(),
        }
    }

    pub fn columns(mut self, cols: &[&str]) -> Self {
        self.columns = cols.iter().map(|s| s.to_string()).collect();
        self
    }

    pub fn values(mut self, vals: Vec<SqlValue>) -> Self {
        self.values.push(vals);
        self
    }

    pub fn returning(mut self, cols: &[&str]) -> Self {
        self.returning = cols.iter().map(|s| s.to_string()).collect();
        self
    }

    pub fn build(self) -> SqlQuery {
        let mut params = Vec::new();
        let mut param_idx = 0;

        let cols = self.columns.join(", ");

        let value_groups: Vec<String> = self
            .values
            .iter()
            .map(|row| {
                let placeholders: Vec<String> = row
                    .iter()
                    .map(|v| {
                        param_idx += 1;
                        params.push(v.clone());
                        format!("${}", param_idx)
                    })
                    .collect();
                format!("({})", placeholders.join(", "))
            })
            .collect();

        let mut sql = format!(
            "INSERT INTO {} ({}) VALUES {}",
            self.table,
            cols,
            value_groups.join(", ")
        );

        if !self.returning.is_empty() {
            sql.push_str(&format!(" RETURNING {}", self.returning.join(", ")));
        }

        SqlQuery { sql, params }
    }
}

// === UpdateBuilder ===

#[derive(Debug, Clone)]
pub struct UpdateBuilder {
    table: String,
    sets: Vec<(String, SqlValue)>,
    conditions: ConditionGroup,
    returning: Vec<String>,
}

impl UpdateBuilder {
    pub fn new(table: &str) -> Self {
        Self {
            table: table.to_string(),
            sets: Vec::new(),
            conditions: ConditionGroup::new(),
            returning: Vec::new(),
        }
    }

    pub fn set(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.sets.push((column.to_string(), value.into()));
        self
    }

    pub fn where_eq(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Eq, Some(value.into()));
        self
    }

    pub fn where_ne(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Ne, Some(value.into()));
        self
    }

    pub fn where_gt(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Gt, Some(value.into()));
        self
    }

    pub fn where_lt(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Lt, Some(value.into()));
        self
    }

    pub fn returning(mut self, cols: &[&str]) -> Self {
        self.returning = cols.iter().map(|s| s.to_string()).collect();
        self
    }

    pub fn build(self) -> SqlQuery {
        let mut params = Vec::new();
        let mut param_idx = 0;

        // SET clauses
        let set_parts: Vec<String> = self
            .sets
            .iter()
            .map(|(col, val)| {
                param_idx += 1;
                params.push(val.clone());
                format!("{} = ${}", col, param_idx)
            })
            .collect();

        let mut sql = format!(
            "UPDATE {} SET {}",
            self.table,
            set_parts.join(", ")
        );

        // WHERE
        let (where_clause, where_params) = self.conditions.build(&mut param_idx);
        if !where_clause.is_empty() {
            sql.push_str(&format!(" {}", where_clause));
            params.extend(where_params);
        }

        // RETURNING
        if !self.returning.is_empty() {
            sql.push_str(&format!(" RETURNING {}", self.returning.join(", ")));
        }

        SqlQuery { sql, params }
    }
}

// === DeleteBuilder ===

#[derive(Debug, Clone)]
pub struct DeleteBuilder {
    table: String,
    conditions: ConditionGroup,
    returning: Vec<String>,
}

impl DeleteBuilder {
    pub fn new(table: &str) -> Self {
        Self {
            table: table.to_string(),
            conditions: ConditionGroup::new(),
            returning: Vec::new(),
        }
    }

    pub fn where_eq(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Eq, Some(value.into()));
        self
    }

    pub fn where_ne(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Ne, Some(value.into()));
        self
    }

    pub fn where_gt(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Gt, Some(value.into()));
        self
    }

    pub fn where_lt(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        self.conditions.add(LogicOp::And, column, CompareOp::Lt, Some(value.into()));
        self
    }

    pub fn where_in(mut self, column: &str, values: Vec<SqlValue>) -> Self {
        self.conditions.add_in(LogicOp::And, column, values);
        self
    }

    pub fn returning(mut self, cols: &[&str]) -> Self {
        self.returning = cols.iter().map(|s| s.to_string()).collect();
        self
    }

    pub fn build(self) -> SqlQuery {
        let mut params = Vec::new();
        let mut param_idx = 0;

        let mut sql = format!("DELETE FROM {}", self.table);

        // WHERE
        let (where_clause, where_params) = self.conditions.build(&mut param_idx);
        if !where_clause.is_empty() {
            sql.push_str(&format!(" {}", where_clause));
            params.extend(where_params);
        }

        // RETURNING
        if !self.returning.is_empty() {
            sql.push_str(&format!(" RETURNING {}", self.returning.join(", ")));
        }

        SqlQuery { sql, params }
    }
}

// === SqlValue Conversions ===

impl From<i32> for SqlValue {
    fn from(v: i32) -> Self {
        SqlValue::Int(v as i64)
    }
}

impl From<i64> for SqlValue {
    fn from(v: i64) -> Self {
        SqlValue::Int(v)
    }
}

impl From<f64> for SqlValue {
    fn from(v: f64) -> Self {
        SqlValue::Float(v)
    }
}

impl From<bool> for SqlValue {
    fn from(v: bool) -> Self {
        SqlValue::Bool(v)
    }
}

impl From<String> for SqlValue {
    fn from(v: String) -> Self {
        SqlValue::Text(v)
    }
}

impl From<&str> for SqlValue {
    fn from(v: &str) -> Self {
        SqlValue::Text(v.to_string())
    }
}

impl<T: Into<SqlValue>> From<Option<T>> for SqlValue {
    fn from(v: Option<T>) -> Self {
        match v {
            Some(val) => val.into(),
            None => SqlValue::Null,
        }
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1: Utilisation de Cow<str> pour eviter les allocations
// Valide si correctement implemente

// Alternative 2: Macro pour les conditions
// macro_rules! where_cond { ... }
// Valide si genere le bon SQL

// Alternative 3: Generics sur le type de valeur
// Valide si les conversions fonctionnent
```

### 4.5 Solutions refusees (avec explications)

```rust
// REFUSE: Concatenation directe de valeurs
fn where_eq_bad(&mut self, column: &str, value: &str) {
    self.sql.push_str(&format!("WHERE {} = '{}'", column, value));
    // DANGER: SQL INJECTION !
}
// Raison: Valeur directement dans le SQL, vulnerable aux injections

// REFUSE: Oubli d'echapper les quotes
fn text_bad(s: &str) -> SqlValue {
    SqlValue::Text(s.to_string()) // OK, mais si utilise directement dans SQL:
    // format!("'{}'", s) // DANGER si s contient des quotes
}
// Raison: Les valeurs doivent TOUJOURS passer par les parametres

// REFUSE: Mauvais ordre des clauses
fn build_bad(&self) -> SqlQuery {
    // LIMIT avant ORDER BY
    format!("SELECT * FROM {} LIMIT {} ORDER BY {}", ...)
}
// Raison: SQL syntaxiquement invalide
```

### 4.9 spec.json

```json
{
  "name": "sql_query_builder",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Integration - SQL + API Design + Security",
  "tags": ["sql", "security", "api-design", "builder-pattern", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "SelectBuilder, InsertBuilder, UpdateBuilder, DeleteBuilder",
    "prototype": "pub struct SelectBuilder { ... }",
    "return_type": "SqlQuery",
    "parameters": []
  },

  "driver": {
    "reference": "/* Section 4.3 */",

    "edge_cases": [
      {
        "name": "empty_select",
        "args": [],
        "expected": "SELECT * FROM table",
        "is_trap": false
      },
      {
        "name": "sql_injection_attempt",
        "args": ["Robert'); DROP TABLE Students;--"],
        "expected": "Value in params, not SQL",
        "is_trap": true,
        "trap_explanation": "Les valeurs utilisateur ne doivent JAMAIS etre dans le SQL"
      },
      {
        "name": "null_handling",
        "args": ["None::<i32>"],
        "expected": "SqlValue::Null",
        "is_trap": true,
        "trap_explanation": "Option::None doit devenir SqlValue::Null"
      },
      {
        "name": "param_ordering",
        "args": ["multiple conditions"],
        "expected": "$1, $2, $3 in correct order",
        "is_trap": true,
        "trap_explanation": "L'ordre des parametres doit correspondre aux placeholders"
      },
      {
        "name": "empty_in_clause",
        "args": ["empty vec"],
        "expected": "Handle gracefully",
        "is_trap": true,
        "trap_explanation": "IN () vide est invalide en SQL"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "string",
          "param_index": 0,
          "params": {
            "min_length": 0,
            "max_length": 1000,
            "include_special": true,
            "include_sql_injection": true
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["String", "Vec", "Option", "From", "Into", "fmt"],
    "forbidden_functions": ["sqlx", "diesel", "sea-query", "format! with user values"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```rust
/* Mutant A (Injection) : Concatenation directe au lieu de parametres */
impl SelectBuilder {
    pub fn where_eq_mutant_a(mut self, column: &str, value: &str) -> Self {
        // BUG: Valeur directement dans le SQL !
        self.raw_where = Some(format!("{} = '{}'", column, value));
        self
    }
}
// Pourquoi c'est faux : SQL Injection possible avec value = "'; DROP TABLE users;--"
// Ce qui etait pense : "C'est plus simple comme ca" — NON, c'est DANGEREUX !
// Test qui echoue : test_no_sql_injection

/* Mutant B (Index) : Mauvais compteur de parametres */
impl SelectBuilder {
    pub fn build_mutant_b(self) -> SqlQuery {
        let mut params = Vec::new();
        // BUG: param_idx ne s'incremente pas correctement
        let param_idx = 1; // Toujours $1 !

        for cond in &self.conditions {
            parts.push(format!("{} = ${}", cond.column, param_idx));
            params.push(cond.value.clone());
            // Oubli de param_idx += 1;
        }
        // ...
    }
}
// Pourquoi c'est faux : Tous les parametres referent $1, les autres sont ignores
// Ce qui etait pense : "J'ai oublie d'incrementer" — Erreur classique
// Test qui echoue : test_select_with_multiple_conditions

/* Mutant C (Order) : LIMIT avant ORDER BY */
impl SelectBuilder {
    pub fn build_mutant_c(self) -> SqlQuery {
        let mut sql = format!("SELECT * FROM {}", self.table);

        // BUG: LIMIT avant ORDER BY
        if let Some(limit) = self.limit {
            sql.push_str(&format!(" LIMIT {}", limit));
        }
        if !self.order_by.is_empty() {
            sql.push_str(&format!(" ORDER BY {}", ...));
        }
        // ...
    }
}
// Pourquoi c'est faux : Ordre invalide, certains SGBD rejettent
// Ce qui etait pense : "L'ordre n'a pas d'importance" — SI, en SQL !
// Test qui echoue : test_select_with_pagination

/* Mutant D (Logic) : AND au lieu de OR */
impl SelectBuilder {
    pub fn or_where_eq_mutant_d(mut self, column: &str, value: impl Into<SqlValue>) -> Self {
        // BUG: Utilise AND au lieu de OR
        self.conditions.add(LogicOp::And, column, CompareOp::Eq, Some(value.into()));
        self
    }
}
// Pourquoi c'est faux : Logique booleenne inversee, resultats differents
// Ce qui etait pense : "AND et OR c'est pareil" — NON !
// Test qui echoue : test_select_with_or

/* Mutant E (Escape) : Pas de validation des noms de colonnes */
impl SelectBuilder {
    pub fn columns_mutant_e(mut self, cols: &[&str]) -> Self {
        // BUG: Pas de validation, permet l'injection via les noms de colonnes
        self.columns = cols.iter().map(|s| s.to_string()).collect();
        self
    }
}
// Si cols = ["id; DROP TABLE users; --"]
// SQL: SELECT id; DROP TABLE users; -- FROM users
// Pourquoi c'est faux : Injection SQL via le nom de colonne
// Ce qui etait pense : "Seules les valeurs sont dangereuses" — NON !
// Test qui echoue : fuzzing avec noms de colonnes malveillants

/* Mutant F (Type) : Mauvaise conversion de types */
impl From<f32> for SqlValue {
    fn from(v: f32) -> Self {
        // BUG: Perte de precision
        SqlValue::Int(v as i64)
    }
}
// Pourquoi c'est faux : 3.14 devient 3, perte de donnees
// Ce qui etait pense : "Les nombres c'est pareil" — NON !
// Test qui echoue : test avec valeurs decimales
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

1. **Prevention des injections SQL** : Comprendre POURQUOI les requetes parametrees sont essentielles
2. **SQL DML** : Maitriser SELECT, INSERT, UPDATE, DELETE avec leurs clauses
3. **Pattern Builder** : Concevoir une API fluide et ergonomique
4. **Type Safety** : Utiliser le systeme de types pour prevenir les erreurs
5. **PostgreSQL specifics** : Syntaxe des parametres, RETURNING clause

### 5.2 LDA — Traduction Litterale en Francais (MAJUSCULES)

```
STRUCTURE SqlQuery QUI CONTIENT :
    - sql QUI EST UNE CHAINE REPRESENTANT LA REQUETE SQL
    - params QUI EST UNE LISTE DE VALEURS POUR LES PLACEHOLDERS
FIN STRUCTURE

FONCTION SelectBuilder::build QUI RETOURNE SqlQuery
DEBUT FONCTION
    INITIALISER parties COMME LISTE VIDE
    INITIALISER parametres COMME LISTE VIDE
    INITIALISER index_param A 0

    SI colonnes EST VIDE ALORS
        AJOUTER "SELECT *" A parties
    SINON SI distinct EST VRAI ALORS
        AJOUTER "SELECT DISTINCT " + colonnes A parties
    SINON
        AJOUTER "SELECT " + colonnes A parties
    FIN SI

    AJOUTER "FROM " + table A parties

    POUR CHAQUE condition DANS conditions FAIRE
        SI condition.operateur EST "IS NULL" OU "IS NOT NULL" ALORS
            AJOUTER colonne + operateur A parties
        SINON
            INCREMENTER index_param
            AJOUTER colonne + operateur + "$" + index_param A parties
            AJOUTER condition.valeur A parametres
        FIN SI
    FIN POUR

    SI order_by N'EST PAS VIDE ALORS
        AJOUTER "ORDER BY " + order_by A parties
    FIN SI

    SI limit EST DEFINI ALORS
        AJOUTER "LIMIT " + limit A parties
    FIN SI

    SI offset EST DEFINI ALORS
        AJOUTER "OFFSET " + offset A parties
    FIN SI

    RETOURNER SqlQuery { sql: parties.joindre(" "), params: parametres }
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHM: Build SELECT Query
---
1. INITIALIZE empty SQL parts list
2. INITIALIZE empty parameters list
3. INITIALIZE parameter counter to 0

4. BUILD SELECT clause:
   a. IF no columns specified:
      - USE "*"
   b. ELSE IF distinct flag:
      - USE "SELECT DISTINCT" + columns
   c. ELSE:
      - USE "SELECT" + columns

5. BUILD FROM clause:
   - APPEND "FROM" + table_name

6. BUILD WHERE clause (if conditions exist):
   FOR EACH condition:
      a. CASE IS NULL / IS NOT NULL:
         - APPEND "column IS [NOT] NULL"
         - NO parameter needed

      b. CASE IN operator:
         - FOR EACH value in list:
           - INCREMENT counter
           - APPEND to placeholder list
           - ADD value to parameters
         - APPEND "column IN (placeholders)"

      c. CASE standard operator:
         - INCREMENT counter
         - APPEND "column OP $counter"
         - ADD value to parameters

7. BUILD ORDER BY clause (if specified):
   - APPEND "ORDER BY col1 DIR1, col2 DIR2, ..."

8. BUILD LIMIT clause (if specified):
   - APPEND "LIMIT n"

9. BUILD OFFSET clause (if specified):
   - APPEND "OFFSET n"

10. RETURN SqlQuery { sql: joined_parts, params }
```

### 5.2.3 Logique de Garde (Fail Fast)

```
FONCTION : build_query (builder)
---
INIT sql_parts = []
INIT params = []

1. VERIFIER table n'est pas vide :
   |
   |-- SI vide : ERREUR "Table name required"

2. POUR chaque colonne dans columns :
   |
   |-- VERIFIER format valide (alphanum + underscore)
   |-- SI invalide : ERREUR "Invalid column name"

3. POUR chaque condition :
   |
   |-- VERIFIER colonne existe
   |-- VERIFIER operateur valide
   |-- VERIFIER valeur compatible avec operateur

4. CONSTRUIRE SQL :
   |
   |-- SELECT (avec ou sans DISTINCT)
   |-- FROM table
   |-- WHERE (si conditions)
   |-- ORDER BY (si tri)
   |-- LIMIT (si pagination)
   |-- OFFSET (si pagination)

5. RETOURNER SqlQuery { sql, params }
```

### 5.3 Visualisation ASCII

```
=== Construction d'une requete SELECT ===

SelectBuilder::new("users")
    .columns(&["id", "name"])
    .where_eq("status", "active")
    .where_gt("age", 18)
    .order_by("name", Asc)
    .limit(10)
    .build()

Etape par etape :

1. new("users")
   +-------------------+
   | table: "users"    |
   | columns: []       |
   | conditions: []    |
   | order_by: []      |
   | limit: None       |
   +-------------------+

2. .columns(&["id", "name"])
   +-------------------+
   | columns: ["id",   |
   |           "name"] |
   +-------------------+

3. .where_eq("status", "active")
   +-------------------+
   | conditions: [     |
   |   (AND, status,   |
   |    =, "active")   |
   | ]                 |
   +-------------------+

4. .where_gt("age", 18)
   +-------------------+
   | conditions: [     |
   |   (AND, status,   |
   |    =, "active"),  |
   |   (AND, age,      |
   |    >, 18)         |
   | ]                 |
   +-------------------+

5. .build()

   SQL Parts:
   +---------------------------------+
   | "SELECT id, name"               |
   | "FROM users"                    |
   | "WHERE status = $1 AND age > $2"|
   | "ORDER BY name ASC"             |
   | "LIMIT 10"                      |
   +---------------------------------+

   Final SQL:
   "SELECT id, name FROM users WHERE status = $1 AND age > $2 ORDER BY name ASC LIMIT 10"

   Params:
   [Text("active"), Int(18)]
```

### 5.4 Les pieges en detail

| Piege | Description | Solution |
|-------|-------------|----------|
| **SQL Injection** | Valeur dans le SQL | TOUJOURS utiliser $1, $2... |
| **Param Index** | Mauvais ordre des $n | Compteur unique incremente |
| **Clause Order** | LIMIT avant ORDER BY | Respecter l'ordre SQL standard |
| **AND vs OR** | Logique inversee | Verifier le LogicOp |
| **IN vide** | IN () invalide | Gerer le cas vec vide |
| **NULL handling** | IS NULL vs = NULL | Operateur special pour NULL |

### 5.5 Cours Complet

#### Qu'est-ce qu'une Injection SQL ?

Une **injection SQL** est une technique d'attaque qui exploite les failles de securite dans les applications qui construisent des requetes SQL en concatenant directement les entrees utilisateur.

**Exemple d'attaque :**

```sql
-- Code vulnerable (PHP)
$query = "SELECT * FROM users WHERE name = '" . $_POST['name'] . "'";

-- Si l'utilisateur entre: ' OR '1'='1
-- Resultat: SELECT * FROM users WHERE name = '' OR '1'='1'
-- Retourne TOUS les utilisateurs !

-- Si l'utilisateur entre: '; DROP TABLE users;--
-- Resultat: SELECT * FROM users WHERE name = ''; DROP TABLE users;--'
-- Supprime la table !
```

#### Pourquoi les requetes parametrees sont-elles sures ?

Les requetes parametrees separent le **code SQL** des **donnees**. Le driver de base de donnees traite les parametres comme des **valeurs literales**, jamais comme du code SQL.

```rust
// Requete parametree (SECURISEE)
let sql = "SELECT * FROM users WHERE name = $1";
let params = vec![user_input]; // Meme si user_input contient du SQL

// Le driver envoie au serveur:
// - Le SQL compile (prepare statement)
// - Les valeurs separement (bind parameters)
// -> Impossible d'injecter du code
```

#### SQL DML (Data Manipulation Language)

| Commande | Description | Syntaxe |
|----------|-------------|---------|
| **SELECT** | Lire des donnees | `SELECT cols FROM table WHERE cond` |
| **INSERT** | Ajouter des lignes | `INSERT INTO table (cols) VALUES (vals)` |
| **UPDATE** | Modifier des lignes | `UPDATE table SET col=val WHERE cond` |
| **DELETE** | Supprimer des lignes | `DELETE FROM table WHERE cond` |

#### Clauses SQL importantes

| Clause | Role | Exemple |
|--------|------|---------|
| `WHERE` | Filtrer les lignes | `WHERE age > 18` |
| `ORDER BY` | Trier les resultats | `ORDER BY name ASC` |
| `LIMIT` | Limiter le nombre | `LIMIT 10` |
| `OFFSET` | Sauter des lignes | `OFFSET 20` |
| `RETURNING` | Retourner les lignes affectees (PostgreSQL) | `RETURNING id` |

#### Pattern Builder en Rust

Le **Pattern Builder** permet de construire des objets complexes etape par etape :

```rust
// Sans Builder (difficile a lire)
let query = SelectQuery {
    table: "users".to_string(),
    columns: vec!["id".to_string(), "name".to_string()],
    conditions: vec![...],
    order_by: vec![...],
    limit: Some(10),
    offset: None,
};

// Avec Builder (fluent API)
let query = SelectBuilder::new("users")
    .columns(&["id", "name"])
    .where_eq("status", "active")
    .limit(10)
    .build();
```

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------------+
| HORS NORME (compile, mais DANGEREUX)                                 |
+---------------------------------------------------------------------+
| let sql = format!("SELECT * FROM {} WHERE name = '{}'",              |
|                   table, user_input);                                |
+---------------------------------------------------------------------+
| CONFORME                                                             |
+---------------------------------------------------------------------+
| let sql = "SELECT * FROM users WHERE name = $1";                     |
| let params = vec![user_input];                                       |
+---------------------------------------------------------------------+
| POURQUOI ?                                                           |
|                                                                     |
| - Securite : Impossible d'injecter du SQL via les parametres        |
| - Performance : Prepare statements peuvent etre reutilises          |
| - Lisibilite : Separation claire entre SQL et donnees               |
+---------------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Scenario : Requete avec conditions multiples**

```
Input: SelectBuilder::new("products")
           .where_eq("category", "electronics")
           .where_gt("price", 100)
           .order_by("price", Desc)
           .limit(5)

+-------+------------------------------------+-------------------+------------------------+
| Etape | Operation                          | Etat              | Resultat               |
+-------+------------------------------------+-------------------+------------------------+
|   1   | new("products")                    | table="products"  |                        |
+-------+------------------------------------+-------------------+------------------------+
|   2   | where_eq("category", "electronics")| conditions=[      | param_idx=1            |
|       |                                    |   (AND, category, |                        |
|       |                                    |    =, $1)         |                        |
|       |                                    | ]                 |                        |
+-------+------------------------------------+-------------------+------------------------+
|   3   | where_gt("price", 100)             | conditions=[      | param_idx=2            |
|       |                                    |   ...,            |                        |
|       |                                    |   (AND, price,    |                        |
|       |                                    |    >, $2)         |                        |
|       |                                    | ]                 |                        |
+-------+------------------------------------+-------------------+------------------------+
|   4   | order_by("price", Desc)            | order_by=[        |                        |
|       |                                    |   (price, DESC)   |                        |
|       |                                    | ]                 |                        |
+-------+------------------------------------+-------------------+------------------------+
|   5   | limit(5)                           | limit=Some(5)     |                        |
+-------+------------------------------------+-------------------+------------------------+
|   6   | build()                            |                   | SqlQuery {             |
|       |                                    |                   |   sql: "SELECT * FROM  |
|       |                                    |                   |         products WHERE |
|       |                                    |                   |         category = $1  |
|       |                                    |                   |         AND price > $2 |
|       |                                    |                   |         ORDER BY price |
|       |                                    |                   |         DESC LIMIT 5", |
|       |                                    |                   |   params: [            |
|       |                                    |                   |     Text("electronics"),|
|       |                                    |                   |     Int(100)           |
|       |                                    |                   |   ]                    |
|       |                                    |                   | }                      |
+-------+------------------------------------+-------------------+------------------------+
```

### 5.8 Mnemoniques (MEME obligatoire)

#### MEME : "Little Bobby Tables"

```
+------------------------------------------------------------------+
|  Mom: "Yes, we named him Robert'); DROP TABLE Students;--"       |
|                                                                  |
|  School: "We lost all our records."                              |
|                                                                  |
|  Mom: "I hope you've learned to SANITIZE YOUR DATABASE INPUTS."  |
+------------------------------------------------------------------+

         Bobby Tables te rappelle :

         JAMAIS : "WHERE name = '" + input + "'"

         TOUJOURS : "WHERE name = $1" + [input]
```

#### Acronyme : SPILO (SQL Parameter Injection Lethality Obliterator)

- **S**eparate : Separer SQL et donnees
- **P**arameterize : Utiliser $1, $2, etc.
- **I**ndex : Compteur unique pour chaque parametre
- **L**imit : Limiter les resultats (pagination)
- **O**rder : Respecter l'ordre des clauses SQL

### 5.9 Applications pratiques

| Application | Utilisation du Query Builder |
|-------------|------------------------------|
| **API REST** | Construire des requetes de recherche filtree |
| **Admin Panel** | Lister/filtrer/paginer des donnees |
| **Reporting** | Generer des requetes d'agregation |
| **Migration** | Scripts de mise a jour de donnees |
| **Testing** | Fixtures et donnees de test |

---

## SECTION 6 : PIEGES — RECAPITULATIF

| # | Piege | Impact | Comment l'eviter |
|---|-------|--------|------------------|
| 1 | Concatenation de valeurs | SQL Injection | Toujours parametrer |
| 2 | Mauvais index de parametre | Donnees decalees | Compteur unique |
| 3 | LIMIT avant ORDER BY | SQL invalide | Respecter l'ordre |
| 4 | AND au lieu de OR | Logique fausse | Verifier LogicOp |
| 5 | IN avec liste vide | SQL invalide | Gerer le cas vide |
| 6 | IS NULL vs = NULL | Pas de resultats | Operateur special |
| 7 | Noms de colonnes non valides | Injection via colonnes | Valider les noms |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la principale raison d'utiliser des requetes parametrees ?**

A) Meilleure performance
B) Code plus lisible
C) Prevention des injections SQL
D) Compatibilite multi-SGBD
E) Gestion automatique des types
F) Cache des requetes
G) Moins de code a ecrire
H) Meilleure gestion des erreurs
I) C est la raison principale, mais A et F sont aussi vrais
J) Toutes les reponses sont equivalentes

**Reponse : I**

### Question 2
**Dans PostgreSQL, comment sont notes les parametres ?**

A) ?
B) :1, :2, :3
C) @p1, @p2, @p3
D) $1, $2, $3
E) %1, %2, %3
F) {1}, {2}, {3}
G) #1, #2, #3
H) Tous sont acceptes
I) D pour PostgreSQL, A pour MySQL
J) Ca depend de la version

**Reponse : I**

### Question 3
**Quel est l'ordre correct des clauses dans un SELECT ?**

A) SELECT - WHERE - FROM - ORDER BY - LIMIT
B) SELECT - FROM - ORDER BY - WHERE - LIMIT
C) SELECT - FROM - WHERE - ORDER BY - LIMIT
D) SELECT - FROM - WHERE - LIMIT - ORDER BY
E) L'ordre n'a pas d'importance
F) FROM - SELECT - WHERE - ORDER BY - LIMIT
G) C, mais LIMIT et OFFSET peuvent etre inverses
H) Depend du SGBD
I) SELECT - FROM - WHERE - GROUP BY - ORDER BY - LIMIT
J) I est le plus complet et correct

**Reponse : J**

### Question 4
**Comment tester si une colonne est NULL en SQL ?**

A) column = NULL
B) column == NULL
C) column IS NULL
D) column = 'NULL'
E) column <> NULL
F) ISNULL(column)
G) C pour le test, F pour certains SGBD
H) A et C sont equivalents
I) NULL = NULL retourne true
J) C, car NULL n'est egal a rien, meme pas a lui-meme

**Reponse : J**

### Question 5
**Que fait la clause RETURNING en PostgreSQL ?**

A) Retourne le nombre de lignes affectees
B) Retourne les valeurs des lignes inserees/modifiees/supprimees
C) Retourne une erreur si pas de lignes affectees
D) Retourne la requete executee
E) Est obligatoire pour INSERT
F) Est equivalente a SELECT apres l'operation
G) B, et c'est specifique a PostgreSQL (pas standard SQL)
H) Existe dans tous les SGBD
I) Ne fonctionne qu'avec INSERT
J) G est la reponse la plus precise

**Reponse : J**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Exercice** | 5.2.1-a — sql_query_builder |
| **Concept principal** | SQL Query Builder Type-Safe |
| **Difficulte** | &#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9734;&#9734;&#9734;&#9734; (6/10) |
| **Temps estime** | 90 min |
| **XP Base** | 250 |
| **Bonus Subqueries** | AVANCE (x2.5 XP) |
| **Bonus Validation** | EXPERT (x4 XP) |
| **Langage** | Rust 2024 |
| **Points cles** | SELECT, INSERT, UPDATE, DELETE, parametres, injection |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.2.1-a-sql-query-builder",
    "generated_at": "2026-01-16",

    "metadata": {
      "exercise_id": "5.2.1-a",
      "exercise_name": "sql_query_builder",
      "module": "5.2.1",
      "module_name": "SQL Fundamentals",
      "concept": "a",
      "concept_name": "Query Builder Type-Safe",
      "type": "complet",
      "tier": 2,
      "tier_info": "Integration - SQL + API Design + Security",
      "phase": 5,
      "difficulty": 6,
      "difficulty_stars": "6/10",
      "language": "rust",
      "language_alt": null,
      "duration_minutes": 90,
      "xp_base": 250,
      "xp_bonus_multiplier": 2.5,
      "bonus_tier": "AVANCE",
      "bonus_icon": "ADVANCED",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["rust-ownership", "enums", "from-trait", "sql-basics"],
      "domains": ["SQL", "Security", "API-Design"],
      "domains_bonus": ["Subqueries", "Validation"],
      "tags": ["sql", "security", "builder-pattern", "injection-prevention"],
      "meme_reference": "Little Bobby Tables - XKCD #327"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 3.2-3.3 */",
      "mutants/mutant_a_injection.rs": "/* Section 4.10 */",
      "mutants/mutant_b_index.rs": "/* Section 4.10 */",
      "mutants/mutant_c_order.rs": "/* Section 4.10 */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_e_escape.rs": "/* Section 4.10 */",
      "mutants/mutant_f_type.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_injection.rs",
        "mutants/mutant_b_index.rs",
        "mutants/mutant_c_order.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_escape.rs",
        "mutants/mutant_f_type.rs"
      ]
    },

    "security_checks": {
      "sql_injection_tests": true,
      "fuzzing_enabled": true,
      "fuzzing_iterations": 500,
      "special_chars_tested": ["'", "\"", ";", "--", "/*", "*/", "\\"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "Little Bobby Tables taught us well: Always parameterize your queries!"*
