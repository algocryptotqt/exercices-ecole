<thinking>
## Analyse du Concept
- Concept : Distributed Transaction Coordinator (2PC/3PC)
- Phase demandee : 5.2 (Databases)
- Adapte ? OUI - La coordination de transactions distribuees est critique pour les systemes multi-bases

## Combo Base + Bonus
- Exercice de base : Implementer le protocole Two-Phase Commit (2PC) avec participants simulees
- Bonus 1 : Three-Phase Commit (3PC) avec timeout et recovery
- Bonus 2 : Saga pattern avec compensation automatique
- Palier bonus : AVANCE (3PC) puis EXPERT (Saga orchestration)
- Progression logique ? OUI - Base = 2PC classique, Bonus = patterns resilients

## Prerequis & Difficulte
- Prerequis reels : Async Rust, channels, state machines, error handling
- Difficulte estimee : 8/10 (base), 9/10 (bonus 3PC), 10/10 (bonus Saga)
- Coherent avec phase 5.2 ? OUI

## Aspect Fun/Culture
- Contexte choisi : "The Heist Coordinator" - Planifier un braquage ou tout le monde doit agir ensemble
- MEME mnemonique : "PREPARE... COMMIT!" comme le compte a rebours d'un braquage
- Pourquoi c'est fun : Le 2PC est litteralement un consensus entre complices

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Timeout) : Pas de timeout sur prepare - blocage indefini
2. Mutant B (State) : Commit sans verifier tous les votes - inconsistance
3. Mutant C (Recovery) : Pas de log WAL - perte d'etat apres crash
4. Mutant D (Rollback) : Oubli de rollback sur abort - donnees corrompues
5. Mutant E (Concurrent) : Race condition sur le compteur de votes

## Verdict
VALIDE - Exercice avance couvrant un pattern critique des systemes distribues
</thinking>

---

# Exercice 5.2.21-a : distributed_transaction_coordinator

**Module :**
5.2.21 -- Distributed Database Patterns

**Concept :**
a -- Two-Phase Commit Protocol Implementation

**Difficulte :**
&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9734;&#9734; (8/10)

**Type :**
complet

**Tiers :**
3 -- Systeme complexe multi-composants

**Langage :**
Rust Edition 2024

**Prerequis :**
- Async Rust (tokio)
- Channels et communication inter-taches
- State machines et enums
- Error handling avance
- Concepts de transactions ACID

**Domaines :**
Distributed Systems, Databases, Consensus

**Duree estimee :**
180 min

**XP Base :**
400

**Complexite :**
T[4] O(n) participants x S[3] O(n) logs transactions

---

## SECTION 1 : PROTOTYPE ET CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
- Rust : `src/lib.rs`, `src/coordinator.rs`, `src/participant.rs`, `Cargo.toml`

**Dependances autorisees :**
- `tokio` (runtime async)
- `thiserror` (error handling)
- `tracing` (logging optionnel)
- `uuid` (identifiants de transaction)

**Fonctions interdites :**
- Crates de coordination distribuee externes
- `unsafe` blocks
- Fichiers systeme pour le WAL (simulation en memoire)

### 1.2 Consigne

**THE HEIST COORDINATOR -- "Everybody In Position?"**

```
Coordinator: "Alright team, this is a Two-Phase operation."
Participant 1 (Bank): "Ready to transfer."
Participant 2 (Vault): "Ready to receive."
Coordinator: "Phase 1: PREPARE. Can everyone commit?"
All: "VOTE_COMMIT"
Coordinator: "Phase 2: COMMIT!"
[Transaction Complete]
```

Dans les systemes distribues, une transaction peut impliquer plusieurs bases de donnees ou services. Le probleme : comment garantir que TOUS commitent ou TOUS annulent ? C'est le role du **Two-Phase Commit (2PC)**.

**Ta mission :**

Implementer un coordinateur de transactions distribuees avec le protocole 2PC :

1. **Phase PREPARE** : Le coordinateur demande a chaque participant s'il peut commiter
2. **Phase COMMIT/ABORT** : Si tous votent OUI, on commit. Sinon, on abort

**Entree :**
- Liste de participants (simulees comme des taches async)
- Operations a effectuer sur chaque participant

**Sortie :**
- `TransactionResult::Committed` si tous ont commite
- `TransactionResult::Aborted(reason)` si au moins un a refuse

**Contraintes :**
- Timeout configurable pour chaque phase
- Logging de chaque etape (WAL simule)
- Gestion des participants qui ne repondent pas
- Recovery apres crash du coordinateur (bonus)

**Exemples :**

| Scenario | Votes | Resultat |
|----------|-------|----------|
| Tous OK | [Commit, Commit, Commit] | `Committed` |
| Un refuse | [Commit, Abort, Commit] | `Aborted("Participant 2 voted abort")` |
| Timeout | [Commit, Timeout, Commit] | `Aborted("Participant 2 timeout")` |

### 1.2.2 Consigne Academique

Implementer le protocole Two-Phase Commit (2PC) pour la coordination de transactions distribuees. Le systeme doit garantir l'atomicite des transactions multi-participants avec gestion des timeouts et journalisation des decisions.

### 1.3 Prototype

```rust
use std::time::Duration;
use tokio::sync::{mpsc, oneshot};
use uuid::Uuid;

/// Identifiant unique de transaction
pub type TransactionId = Uuid;

/// Etat d'un participant dans la transaction
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParticipantState {
    Initial,
    Prepared,
    Committed,
    Aborted,
}

/// Vote d'un participant
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Vote {
    Commit,
    Abort(String),
}

/// Resultat final de la transaction
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TransactionResult {
    Committed,
    Aborted(String),
}

/// Erreur de coordination
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CoordinatorError {
    Timeout(String),
    ParticipantFailed(String),
    InvalidState(String),
    LogError(String),
}

/// Message du coordinateur vers les participants
#[derive(Debug, Clone)]
pub enum CoordinatorMessage {
    Prepare(TransactionId),
    Commit(TransactionId),
    Abort(TransactionId),
}

/// Message des participants vers le coordinateur
#[derive(Debug, Clone)]
pub enum ParticipantMessage {
    VoteCommit(TransactionId, String),
    VoteAbort(TransactionId, String, String),
    Ack(TransactionId, String),
}

/// Configuration du coordinateur
#[derive(Debug, Clone)]
pub struct CoordinatorConfig {
    pub prepare_timeout: Duration,
    pub commit_timeout: Duration,
    pub max_retries: u32,
}

impl Default for CoordinatorConfig {
    fn default() -> Self {
        Self {
            prepare_timeout: Duration::from_secs(5),
            commit_timeout: Duration::from_secs(10),
            max_retries: 3,
        }
    }
}

/// Entree du journal WAL
#[derive(Debug, Clone)]
pub enum LogEntry {
    TransactionStarted(TransactionId, Vec<String>),
    PreparesSent(TransactionId),
    VoteReceived(TransactionId, String, Vote),
    DecisionMade(TransactionId, TransactionResult),
    TransactionCompleted(TransactionId),
}

/// Journal Write-Ahead Log
pub struct WriteAheadLog {
    entries: Vec<LogEntry>,
}

impl WriteAheadLog {
    pub fn new() -> Self;
    pub fn append(&mut self, entry: LogEntry);
    pub fn get_pending_transactions(&self) -> Vec<TransactionId>;
    pub fn get_decision(&self, tx_id: TransactionId) -> Option<TransactionResult>;
}

/// Trait pour un participant a la transaction
#[async_trait::async_trait]
pub trait Participant: Send + Sync {
    fn id(&self) -> &str;
    async fn prepare(&mut self, tx_id: TransactionId) -> Result<Vote, CoordinatorError>;
    async fn commit(&mut self, tx_id: TransactionId) -> Result<(), CoordinatorError>;
    async fn abort(&mut self, tx_id: TransactionId) -> Result<(), CoordinatorError>;
}

/// Coordinateur de transactions distribuees
pub struct TransactionCoordinator {
    config: CoordinatorConfig,
    log: WriteAheadLog,
    participants: Vec<Box<dyn Participant>>,
}

impl TransactionCoordinator {
    pub fn new(config: CoordinatorConfig) -> Self;

    pub fn add_participant(&mut self, participant: Box<dyn Participant>);

    /// Execute une transaction 2PC
    pub async fn execute(&mut self, tx_id: TransactionId) -> Result<TransactionResult, CoordinatorError>;

    /// Phase 1: Envoie PREPARE a tous les participants
    async fn phase_prepare(&mut self, tx_id: TransactionId) -> Result<Vec<Vote>, CoordinatorError>;

    /// Phase 2: Envoie COMMIT ou ABORT selon les votes
    async fn phase_commit_or_abort(
        &mut self,
        tx_id: TransactionId,
        decision: TransactionResult,
    ) -> Result<(), CoordinatorError>;

    /// Recovery apres crash
    pub async fn recover(&mut self) -> Result<Vec<TransactionResult>, CoordinatorError>;
}

/// Participant simulee pour les tests
pub struct MockParticipant {
    id: String,
    should_fail_prepare: bool,
    should_fail_commit: bool,
    delay: Option<Duration>,
    state: ParticipantState,
}

impl MockParticipant {
    pub fn new(id: &str) -> Self;
    pub fn with_prepare_failure(mut self) -> Self;
    pub fn with_commit_failure(mut self) -> Self;
    pub fn with_delay(mut self, delay: Duration) -> Self;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Two-Phase Commit

Le protocole 2PC a ete formalise par Jim Gray en 1978. C'est le protocole de consensus le plus simple garantissant l'atomicite des transactions distribuees. Il est utilise dans XA (eXtended Architecture), le standard pour les transactions distribuees.

### 2.2 Le Probleme du Coordinateur Bloquant

Le 2PC a un defaut majeur : si le coordinateur tombe en panne apres avoir envoye PREPARE mais avant COMMIT/ABORT, les participants restent bloques indefiniment. C'est pourquoi le 3PC (Three-Phase Commit) a ete invente, ajoutant une phase "pre-commit".

### 2.3 Alternatives Modernes

Les systemes modernes utilisent souvent le pattern Saga au lieu du 2PC :
- **Saga Choreography** : Chaque service ecoute les evenements et reagit
- **Saga Orchestration** : Un orchestrateur central coordonne les etapes
- Avantage : Pas de blocage, compensation explicite

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation du 2PC |
|--------|-------------------|
| **Database Engineer** | Replication synchrone, clusters multi-master |
| **Backend Architect** | Transactions cross-service, microservices |
| **Cloud Engineer** | Coordination multi-region, consistency |
| **FinTech Developer** | Transferts bancaires, trading systems |

### Cas d'usage concrets

1. **Transfert bancaire** : Debiter compte A ET crediter compte B atomiquement
2. **E-commerce** : Reserver stock ET creer commande ET debiter paiement
3. **Replication** : Ecrire sur primary ET replica avant ACK client

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling distributed_tx_coordinator v0.1.0
    Finished test [unoptimized + debuginfo]
     Running unittests src/lib.rs

running 10 tests
test tests::test_all_commit ... ok
test tests::test_one_abort ... ok
test tests::test_timeout_handling ... ok
test tests::test_coordinator_recovery ... ok
test tests::test_wal_logging ... ok
test tests::test_concurrent_transactions ... ok
test tests::test_participant_state_machine ... ok
test tests::test_partial_failure ... ok
test tests::test_idempotent_commit ... ok
test tests::test_rollback_on_error ... ok

test result: ok. 10 passed; 0 failed
```

### 3.1 Utilisation basique

```rust
use distributed_tx_coordinator::*;
use uuid::Uuid;

#[tokio::main]
async fn main() {
    let mut coordinator = TransactionCoordinator::new(CoordinatorConfig::default());

    // Ajouter des participants
    coordinator.add_participant(Box::new(MockParticipant::new("database_a")));
    coordinator.add_participant(Box::new(MockParticipant::new("database_b")));
    coordinator.add_participant(Box::new(MockParticipant::new("cache")));

    // Executer une transaction
    let tx_id = Uuid::new_v4();
    match coordinator.execute(tx_id).await {
        Ok(TransactionResult::Committed) => println!("Transaction committed!"),
        Ok(TransactionResult::Aborted(reason)) => println!("Aborted: {}", reason),
        Err(e) => println!("Error: {:?}", e),
    }
}
```

### 3.2 BONUS AVANCE : Three-Phase Commit

**Difficulte Bonus :**
&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9734; (9/10)

**Recompense :**
XP x2.5

```rust
/// Three-Phase Commit - Non-bloquant
pub struct ThreePhaseCoordinator {
    config: CoordinatorConfig,
    log: WriteAheadLog,
}

impl ThreePhaseCoordinator {
    /// Phase 1: CanCommit? - Demande si le participant PEUT commiter
    async fn phase_can_commit(&mut self, tx_id: TransactionId) -> Result<Vec<bool>, CoordinatorError>;

    /// Phase 2: PreCommit - Prepare les participants
    async fn phase_pre_commit(&mut self, tx_id: TransactionId) -> Result<(), CoordinatorError>;

    /// Phase 3: DoCommit - Commit final
    async fn phase_do_commit(&mut self, tx_id: TransactionId) -> Result<(), CoordinatorError>;
}
```

### 3.3 BONUS EXPERT : Saga Pattern

**Difficulte Bonus :**
&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733;&#9733; (10/10)

**Recompense :**
XP x4

```rust
/// Etape d'une Saga avec compensation
pub struct SagaStep<T> {
    pub name: String,
    pub action: Box<dyn Fn(&T) -> Result<T, SagaError> + Send>,
    pub compensate: Box<dyn Fn(&T) -> Result<(), SagaError> + Send>,
}

/// Orchestrateur de Saga
pub struct SagaOrchestrator<T> {
    steps: Vec<SagaStep<T>>,
    state: T,
}

impl<T: Clone> SagaOrchestrator<T> {
    pub async fn execute(&mut self) -> Result<T, SagaError>;

    /// Rollback automatique en cas d'echec
    async fn compensate(&mut self, failed_step: usize) -> Result<(), SagaError>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette -- Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `all_commit` | 3 participants OK | `Committed` | 10 | Core |
| `one_abort` | 1 abort, 2 OK | `Aborted` | 10 | Core |
| `timeout_prepare` | 1 slow participant | `Aborted(timeout)` | 10 | Edge |
| `timeout_commit` | slow commit | Continue anyway | 5 | Edge |
| `wal_prepare_logged` | Any tx | Log contains PreparesSent | 10 | Logging |
| `wal_decision_logged` | Commit | Log contains DecisionMade | 10 | Logging |
| `recovery_committed` | Crash after decision | Resume commit | 15 | Recovery |
| `recovery_undecided` | Crash before decision | Abort | 10 | Recovery |
| `concurrent_tx` | 3 parallel tx | All complete | 10 | Concurrency |
| `idempotent_commit` | Double commit call | No error | 5 | Safety |
| `state_machine` | Invalid transition | Error | 5 | Safety |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[tokio::test]
    async fn test_all_commit() {
        let mut coordinator = TransactionCoordinator::new(CoordinatorConfig::default());
        coordinator.add_participant(Box::new(MockParticipant::new("p1")));
        coordinator.add_participant(Box::new(MockParticipant::new("p2")));

        let result = coordinator.execute(Uuid::new_v4()).await.unwrap();
        assert_eq!(result, TransactionResult::Committed);
    }

    #[tokio::test]
    async fn test_one_abort() {
        let mut coordinator = TransactionCoordinator::new(CoordinatorConfig::default());
        coordinator.add_participant(Box::new(MockParticipant::new("p1")));
        coordinator.add_participant(Box::new(MockParticipant::new("p2").with_prepare_failure()));

        let result = coordinator.execute(Uuid::new_v4()).await.unwrap();
        assert!(matches!(result, TransactionResult::Aborted(_)));
    }

    #[tokio::test]
    async fn test_timeout_handling() {
        let config = CoordinatorConfig {
            prepare_timeout: Duration::from_millis(100),
            ..Default::default()
        };
        let mut coordinator = TransactionCoordinator::new(config);
        coordinator.add_participant(Box::new(
            MockParticipant::new("slow").with_delay(Duration::from_secs(1))
        ));

        let result = coordinator.execute(Uuid::new_v4()).await;
        assert!(matches!(result, Err(CoordinatorError::Timeout(_))));
    }

    #[tokio::test]
    async fn test_wal_logging() {
        let mut coordinator = TransactionCoordinator::new(CoordinatorConfig::default());
        coordinator.add_participant(Box::new(MockParticipant::new("p1")));

        let tx_id = Uuid::new_v4();
        coordinator.execute(tx_id).await.unwrap();

        let decision = coordinator.log.get_decision(tx_id);
        assert!(decision.is_some());
    }

    #[tokio::test]
    async fn test_recovery() {
        let mut coordinator = TransactionCoordinator::new(CoordinatorConfig::default());
        coordinator.add_participant(Box::new(MockParticipant::new("p1")));

        // Simulate crash after decision
        let tx_id = Uuid::new_v4();
        coordinator.log.append(LogEntry::DecisionMade(tx_id, TransactionResult::Committed));

        let recovered = coordinator.recover().await.unwrap();
        assert_eq!(recovered.len(), 1);
    }

    #[tokio::test]
    async fn test_participant_state_transitions() {
        let mut participant = MockParticipant::new("test");
        let tx_id = Uuid::new_v4();

        assert_eq!(participant.state, ParticipantState::Initial);
        participant.prepare(tx_id).await.unwrap();
        assert_eq!(participant.state, ParticipantState::Prepared);
        participant.commit(tx_id).await.unwrap();
        assert_eq!(participant.state, ParticipantState::Committed);
    }
}
```

### 4.3 Solution de reference

```rust
use std::time::Duration;
use uuid::Uuid;
use tokio::time::timeout;

pub type TransactionId = Uuid;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParticipantState {
    Initial,
    Prepared,
    Committed,
    Aborted,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Vote {
    Commit,
    Abort(String),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TransactionResult {
    Committed,
    Aborted(String),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CoordinatorError {
    Timeout(String),
    ParticipantFailed(String),
    InvalidState(String),
    LogError(String),
}

#[derive(Debug, Clone)]
pub struct CoordinatorConfig {
    pub prepare_timeout: Duration,
    pub commit_timeout: Duration,
    pub max_retries: u32,
}

impl Default for CoordinatorConfig {
    fn default() -> Self {
        Self {
            prepare_timeout: Duration::from_secs(5),
            commit_timeout: Duration::from_secs(10),
            max_retries: 3,
        }
    }
}

#[derive(Debug, Clone)]
pub enum LogEntry {
    TransactionStarted(TransactionId, Vec<String>),
    PreparesSent(TransactionId),
    VoteReceived(TransactionId, String, Vote),
    DecisionMade(TransactionId, TransactionResult),
    TransactionCompleted(TransactionId),
}

pub struct WriteAheadLog {
    entries: Vec<LogEntry>,
}

impl WriteAheadLog {
    pub fn new() -> Self {
        Self { entries: Vec::new() }
    }

    pub fn append(&mut self, entry: LogEntry) {
        self.entries.push(entry);
    }

    pub fn get_pending_transactions(&self) -> Vec<TransactionId> {
        let mut started = std::collections::HashSet::new();
        let mut completed = std::collections::HashSet::new();

        for entry in &self.entries {
            match entry {
                LogEntry::TransactionStarted(id, _) => { started.insert(*id); }
                LogEntry::TransactionCompleted(id) => { completed.insert(*id); }
                _ => {}
            }
        }

        started.difference(&completed).copied().collect()
    }

    pub fn get_decision(&self, tx_id: TransactionId) -> Option<TransactionResult> {
        for entry in self.entries.iter().rev() {
            if let LogEntry::DecisionMade(id, result) = entry {
                if *id == tx_id {
                    return Some(result.clone());
                }
            }
        }
        None
    }
}

#[async_trait::async_trait]
pub trait Participant: Send + Sync {
    fn id(&self) -> &str;
    async fn prepare(&mut self, tx_id: TransactionId) -> Result<Vote, CoordinatorError>;
    async fn commit(&mut self, tx_id: TransactionId) -> Result<(), CoordinatorError>;
    async fn abort(&mut self, tx_id: TransactionId) -> Result<(), CoordinatorError>;
}

pub struct TransactionCoordinator {
    config: CoordinatorConfig,
    log: WriteAheadLog,
    participants: Vec<Box<dyn Participant>>,
}

impl TransactionCoordinator {
    pub fn new(config: CoordinatorConfig) -> Self {
        Self {
            config,
            log: WriteAheadLog::new(),
            participants: Vec::new(),
        }
    }

    pub fn add_participant(&mut self, participant: Box<dyn Participant>) {
        self.participants.push(participant);
    }

    pub async fn execute(&mut self, tx_id: TransactionId) -> Result<TransactionResult, CoordinatorError> {
        let participant_ids: Vec<String> = self.participants.iter().map(|p| p.id().to_string()).collect();
        self.log.append(LogEntry::TransactionStarted(tx_id, participant_ids));

        // Phase 1: Prepare
        let votes = self.phase_prepare(tx_id).await?;

        // Decide based on votes
        let decision = if votes.iter().all(|v| matches!(v, Vote::Commit)) {
            TransactionResult::Committed
        } else {
            let abort_reason = votes.iter()
                .filter_map(|v| if let Vote::Abort(r) = v { Some(r.clone()) } else { None })
                .next()
                .unwrap_or_else(|| "Unknown".to_string());
            TransactionResult::Aborted(abort_reason)
        };

        self.log.append(LogEntry::DecisionMade(tx_id, decision.clone()));

        // Phase 2: Commit or Abort
        self.phase_commit_or_abort(tx_id, decision.clone()).await?;

        self.log.append(LogEntry::TransactionCompleted(tx_id));
        Ok(decision)
    }

    async fn phase_prepare(&mut self, tx_id: TransactionId) -> Result<Vec<Vote>, CoordinatorError> {
        self.log.append(LogEntry::PreparesSent(tx_id));
        let mut votes = Vec::new();

        for participant in &mut self.participants {
            let result = timeout(
                self.config.prepare_timeout,
                participant.prepare(tx_id)
            ).await;

            let vote = match result {
                Ok(Ok(v)) => v,
                Ok(Err(e)) => Vote::Abort(format!("{:?}", e)),
                Err(_) => return Err(CoordinatorError::Timeout(participant.id().to_string())),
            };

            self.log.append(LogEntry::VoteReceived(tx_id, participant.id().to_string(), vote.clone()));
            votes.push(vote);
        }

        Ok(votes)
    }

    async fn phase_commit_or_abort(
        &mut self,
        tx_id: TransactionId,
        decision: TransactionResult,
    ) -> Result<(), CoordinatorError> {
        for participant in &mut self.participants {
            let result = match &decision {
                TransactionResult::Committed => {
                    timeout(self.config.commit_timeout, participant.commit(tx_id)).await
                }
                TransactionResult::Aborted(_) => {
                    timeout(self.config.commit_timeout, participant.abort(tx_id)).await
                }
            };

            if let Err(_) = result {
                // Log timeout but continue - participant will recover
            }
        }
        Ok(())
    }

    pub async fn recover(&mut self) -> Result<Vec<TransactionResult>, CoordinatorError> {
        let pending = self.log.get_pending_transactions();
        let mut results = Vec::new();

        for tx_id in pending {
            if let Some(decision) = self.log.get_decision(tx_id) {
                self.phase_commit_or_abort(tx_id, decision.clone()).await?;
                self.log.append(LogEntry::TransactionCompleted(tx_id));
                results.push(decision);
            } else {
                // No decision made - abort
                let decision = TransactionResult::Aborted("Recovery abort".to_string());
                self.log.append(LogEntry::DecisionMade(tx_id, decision.clone()));
                self.phase_commit_or_abort(tx_id, decision.clone()).await?;
                self.log.append(LogEntry::TransactionCompleted(tx_id));
                results.push(decision);
            }
        }

        Ok(results)
    }
}

pub struct MockParticipant {
    id: String,
    should_fail_prepare: bool,
    should_fail_commit: bool,
    delay: Option<Duration>,
    pub state: ParticipantState,
}

impl MockParticipant {
    pub fn new(id: &str) -> Self {
        Self {
            id: id.to_string(),
            should_fail_prepare: false,
            should_fail_commit: false,
            delay: None,
            state: ParticipantState::Initial,
        }
    }

    pub fn with_prepare_failure(mut self) -> Self {
        self.should_fail_prepare = true;
        self
    }

    pub fn with_commit_failure(mut self) -> Self {
        self.should_fail_commit = true;
        self
    }

    pub fn with_delay(mut self, delay: Duration) -> Self {
        self.delay = Some(delay);
        self
    }
}

#[async_trait::async_trait]
impl Participant for MockParticipant {
    fn id(&self) -> &str {
        &self.id
    }

    async fn prepare(&mut self, _tx_id: TransactionId) -> Result<Vote, CoordinatorError> {
        if let Some(delay) = self.delay {
            tokio::time::sleep(delay).await;
        }

        if self.should_fail_prepare {
            self.state = ParticipantState::Aborted;
            return Ok(Vote::Abort("Simulated failure".to_string()));
        }

        self.state = ParticipantState::Prepared;
        Ok(Vote::Commit)
    }

    async fn commit(&mut self, _tx_id: TransactionId) -> Result<(), CoordinatorError> {
        if self.should_fail_commit {
            return Err(CoordinatorError::ParticipantFailed(self.id.clone()));
        }
        self.state = ParticipantState::Committed;
        Ok(())
    }

    async fn abort(&mut self, _tx_id: TransactionId) -> Result<(), CoordinatorError> {
        self.state = ParticipantState::Aborted;
        Ok(())
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1: Utilisation de futures::join_all pour paralleliser les prepares
async fn phase_prepare_parallel(&mut self, tx_id: TransactionId) -> Result<Vec<Vote>, CoordinatorError> {
    use futures::future::join_all;

    let futures: Vec<_> = self.participants.iter_mut()
        .map(|p| p.prepare(tx_id))
        .collect();

    let results = join_all(futures).await;
    // ... process results
}

// Alternative 2: Utilisation de channels pour communication
pub struct ChannelCoordinator {
    tx: mpsc::Sender<CoordinatorMessage>,
    rx: mpsc::Receiver<ParticipantMessage>,
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1: Commit sans attendre tous les votes
async fn execute_wrong(&mut self, tx_id: TransactionId) -> Result<TransactionResult, CoordinatorError> {
    for participant in &mut self.participants {
        let vote = participant.prepare(tx_id).await?;
        if matches!(vote, Vote::Commit) {
            participant.commit(tx_id).await?;  // ERREUR: commit avant tous les votes
        }
    }
    Ok(TransactionResult::Committed)
}
// Pourquoi refusee: Viole le protocole 2PC, peut causer inconsistance

// REFUSEE 2: Pas de logging WAL
async fn execute_no_log(&mut self, tx_id: TransactionId) -> Result<TransactionResult, CoordinatorError> {
    let votes = self.phase_prepare(tx_id).await?;
    // ERREUR: pas de log avant decision
    let decision = /* ... */;
    self.phase_commit_or_abort(tx_id, decision).await
}
// Pourquoi refusee: Impossible de recover apres crash

// REFUSEE 3: Ignorer les timeouts
async fn phase_prepare_no_timeout(&mut self, tx_id: TransactionId) -> Result<Vec<Vote>, CoordinatorError> {
    for participant in &mut self.participants {
        let vote = participant.prepare(tx_id).await?;  // ERREUR: peut bloquer indefiniment
        votes.push(vote);
    }
    Ok(votes)
}
// Pourquoi refusee: Un participant lent bloque tout le systeme
```

### 4.9 spec.json

```json
{
  "name": "distributed_transaction_coordinator",
  "language": "rust",
  "type": "complet",
  "tier": 3,
  "tier_info": "Systeme complexe multi-composants",
  "tags": ["distributed-systems", "2pc", "transactions", "consensus", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "TransactionCoordinator",
    "prototype": "impl TransactionCoordinator",
    "return_type": "Result<TransactionResult, CoordinatorError>",
    "parameters": [
      {"name": "tx_id", "type": "TransactionId"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "all_participants_commit",
        "votes": ["Commit", "Commit", "Commit"],
        "expected": "Committed",
        "is_trap": false
      },
      {
        "name": "one_participant_aborts",
        "votes": ["Commit", "Abort", "Commit"],
        "expected": "Aborted",
        "is_trap": false
      },
      {
        "name": "timeout_during_prepare",
        "scenario": "slow_participant",
        "expected": "Timeout error",
        "is_trap": true,
        "trap_explanation": "Must handle timeouts gracefully"
      },
      {
        "name": "crash_after_decision",
        "scenario": "recovery",
        "expected": "Resume from WAL",
        "is_trap": true,
        "trap_explanation": "WAL must persist decisions"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 200,
      "generators": [
        {
          "type": "random_votes",
          "participants": "3-10"
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["tokio", "thiserror", "uuid", "async-trait"],
    "forbidden_functions": ["unsafe"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Timeout) : Pas de timeout sur prepare */
async fn phase_prepare_mutant_a(&mut self, tx_id: TransactionId) -> Result<Vec<Vote>, CoordinatorError> {
    let mut votes = Vec::new();
    for participant in &mut self.participants {
        // MUTANT: Pas de timeout - peut bloquer indefiniment
        let vote = participant.prepare(tx_id).await?;
        votes.push(vote);
    }
    Ok(votes)
}
// Pourquoi c'est faux: Un participant lent ou mort bloque tout le systeme
// Ce qui etait pense: "Les participants repondent toujours"

/* Mutant B (State) : Commit sans verifier tous les votes */
async fn execute_mutant_b(&mut self, tx_id: TransactionId) -> Result<TransactionResult, CoordinatorError> {
    for participant in &mut self.participants {
        let vote = participant.prepare(tx_id).await?;
        if matches!(vote, Vote::Commit) {
            // MUTANT: Commit immediat sans attendre les autres
            participant.commit(tx_id).await?;
        }
    }
    Ok(TransactionResult::Committed)
}
// Pourquoi c'est faux: Viole l'atomicite - certains commitent, d'autres non
// Ce qui etait pense: "On peut optimiser en commitant tot"

/* Mutant C (Recovery) : Pas de log WAL */
async fn execute_mutant_c(&mut self, tx_id: TransactionId) -> Result<TransactionResult, CoordinatorError> {
    let votes = self.phase_prepare(tx_id).await?;
    // MUTANT: Decision sans logging
    let decision = if votes.iter().all(|v| matches!(v, Vote::Commit)) {
        TransactionResult::Committed
    } else {
        TransactionResult::Aborted("abort".into())
    };
    self.phase_commit_or_abort(tx_id, decision.clone()).await?;
    Ok(decision)
}
// Pourquoi c'est faux: Crash = perte de l'etat, impossible de recover
// Ce qui etait pense: "Le log est juste pour debug"

/* Mutant D (Rollback) : Oubli de rollback sur abort */
async fn phase_commit_or_abort_mutant_d(
    &mut self,
    tx_id: TransactionId,
    decision: TransactionResult,
) -> Result<(), CoordinatorError> {
    if matches!(decision, TransactionResult::Committed) {
        for participant in &mut self.participants {
            participant.commit(tx_id).await?;
        }
    }
    // MUTANT: Pas d'abort envoye aux participants
    Ok(())
}
// Pourquoi c'est faux: Les participants restent en etat Prepared indefiniment
// Ce qui etait pense: "Abort n'a pas besoin d'etre explicite"

/* Mutant E (Concurrent) : Race condition sur le compteur */
async fn phase_prepare_mutant_e(&mut self, tx_id: TransactionId) -> Result<Vec<Vote>, CoordinatorError> {
    use std::sync::atomic::{AtomicUsize, Ordering};
    let commit_count = AtomicUsize::new(0);

    // MUTANT: Race condition si parallelise sans synchronisation correcte
    for participant in &mut self.participants {
        let vote = participant.prepare(tx_id).await?;
        if matches!(vote, Vote::Commit) {
            commit_count.fetch_add(1, Ordering::Relaxed);  // ERREUR: Relaxed ordering
        }
    }
    // Lecture potentiellement stale
    Ok(vec![])
}
// Pourquoi c'est faux: Ordering::Relaxed peut donner des resultats incorrects
// Ce qui etait pense: "Atomic = thread-safe"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Protocole 2PC** : Les deux phases (prepare/commit) et leur raison d'etre
2. **Atomicite distribuee** : Comment garantir tout-ou-rien sur plusieurs systemes
3. **Recovery** : L'importance du WAL pour la reprise apres crash
4. **Timeouts** : Gestion des defaillances partielles
5. **State machines** : Modeliser les transitions d'etat valides

### 5.2 Traduction Litterale (LDA)

```
ALGORITHME : Two-Phase Commit
---
ENTREE : Liste de participants, identifiant de transaction
SORTIE : Committed ou Aborted

PHASE 1 - PREPARE:
    POUR CHAQUE participant DANS participants:
        ENVOYER message PREPARE
        ATTENDRE vote (avec timeout)
        SI timeout ALORS RETOURNER Aborted("timeout")
        ENREGISTRER vote dans WAL
    FIN POUR

    SI tous les votes sont Commit ALORS
        decision = Committed
    SINON
        decision = Aborted
    FIN SI

    ENREGISTRER decision dans WAL

PHASE 2 - COMMIT/ABORT:
    POUR CHAQUE participant DANS participants:
        SI decision = Committed ALORS
            ENVOYER message COMMIT
        SINON
            ENVOYER message ABORT
        FIN SI
    FIN POUR

    ENREGISTRER completion dans WAL
    RETOURNER decision
```

### 5.2.3 Diagramme de sequence

```
Coordinator          Participant A       Participant B       Participant C
    |                    |                    |                    |
    |---PREPARE--------->|                    |                    |
    |---PREPARE------------------------------>|                    |
    |---PREPARE-------------------------------------------------->|
    |                    |                    |                    |
    |<--VOTE_COMMIT------|                    |                    |
    |<--VOTE_COMMIT--------------------------|                    |
    |<--VOTE_COMMIT----------------------------------------------|
    |                    |                    |                    |
    | [All voted COMMIT, log decision]       |                    |
    |                    |                    |                    |
    |---COMMIT---------->|                    |                    |
    |---COMMIT------------------------------->|                    |
    |---COMMIT--------------------------------------------------->|
    |                    |                    |                    |
    |<--ACK--------------|                    |                    |
    |<--ACK------------------------------|                    |
    |<--ACK--------------------------------------------------|
    |                    |                    |                    |
    | [Transaction Complete]                 |                    |
```

### 5.3 Visualisation ASCII - Machine a etats

```
                    PARTICIPANT STATE MACHINE

    +-----------+         prepare()         +-----------+
    |  INITIAL  |-------------------------->|  PREPARED |
    +-----------+                           +-----------+
         |                                    /        \
         |                            commit()          abort()
         |                                 /              \
         |                    +-----------+              +-----------+
         +------------------->| COMMITTED |              |  ABORTED  |
           abort()            +-----------+              +-----------+
           (direct)


                    COORDINATOR DECISION FLOW

                         +------------------+
                         |  Collect Votes   |
                         +------------------+
                                  |
                    +-------------+-------------+
                    |                           |
              All COMMIT?                  Any ABORT?
                    |                           |
                    v                           v
           +----------------+          +----------------+
           | Decision:      |          | Decision:      |
           | COMMIT         |          | ABORT          |
           +----------------+          +----------------+
                    |                           |
                    v                           v
           +----------------+          +----------------+
           | Send COMMIT    |          | Send ABORT     |
           | to all         |          | to all         |
           +----------------+          +----------------+
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Blocage coordinateur** | Coordinateur crash apres PREPARE | WAL avec decision persistee |
| **Participant orphelin** | Participant en Prepared indefiniment | Timeout + recovery protocol |
| **Decision prematuree** | Commit avant tous les votes | Attendre explicitement tous |
| **Perte de message** | ACK perdu = re-commit | Idempotence des operations |
| **Ordre des logs** | Log apres action | Toujours log AVANT action |

### 5.5 Cours Complet

#### 5.5.1 Pourquoi le 2PC ?

Sans protocole de coordination, une transaction distribuee peut echouer partiellement :
- Service A commit (argent debite)
- Service B echoue (argent jamais credite)
- Resultat : argent perdu !

Le 2PC garantit : soit TOUS commitent, soit TOUS annulent.

#### 5.5.2 Les deux phases expliquees

**Phase 1 - PREPARE (Vote)**
```
Coordinateur: "Pouvez-vous garantir que vous pouvez commit?"
Participants: "Oui" (VOTE_COMMIT) ou "Non" (VOTE_ABORT)
```
A ce stade, les participants ont fait le travail mais n'ont pas encore rendu permanent.

**Phase 2 - COMMIT/ABORT (Decision)**
```
Si tous ont vote COMMIT:
    Coordinateur: "COMMIT!"
    Participants: Rendent permanent
Sinon:
    Coordinateur: "ABORT!"
    Participants: Annulent
```

#### 5.5.3 Le Write-Ahead Log (WAL)

Le WAL est critique pour la recovery :
1. **Avant** d'envoyer PREPARE : log "Transaction started"
2. **Apres** reception des votes : log chaque vote
3. **Avant** d'envoyer COMMIT/ABORT : log la decision
4. **Apres** completion : log "Transaction completed"

En cas de crash, on peut reprendre depuis le dernier etat logue.

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Pas de timeout | Blocage infini | `tokio::time::timeout` |
| 2 | Commit premature | Inconsistance | Attendre tous les votes |
| 3 | Pas de WAL | Perte d'etat | Logger avant chaque action |
| 4 | Oubli d'abort | Participants bloques | Toujours envoyer decision |
| 5 | Race conditions | Comptage incorrect | Synchronisation correcte |

---

## SECTION 7 : QCM

### Question 1
**Quel est le principal avantage du Two-Phase Commit ?**

A) Performance optimale
B) Garantie d'atomicite distribuee
C) Simplicite d'implementation
D) Tolerance aux pannes du coordinateur

**Reponse : B**

*Explication : Le 2PC garantit que tous les participants commitent ou tous annulent, preservant l'atomicite.*

---

### Question 2
**Que se passe-t-il si un participant ne repond pas pendant PREPARE ?**

A) La transaction commit quand meme
B) On attend indefiniment
C) La transaction est abortee apres timeout
D) Le participant est ignore

**Reponse : C**

*Explication : Un timeout declenche un abort pour eviter le blocage indefini.*

---

### Question 3
**Pourquoi le WAL doit logger la decision AVANT d'envoyer COMMIT ?**

A) Pour des raisons de performance
B) Pour pouvoir recover et re-envoyer la decision apres crash
C) Ce n'est pas necessaire
D) Pour debugger

**Reponse : B**

*Explication : Si le coordinateur crash apres la decision mais avant l'envoi, il peut reprendre et completer.*

---

### Question 4
**Quel probleme le 3PC resout-il par rapport au 2PC ?**

A) Meilleure performance
B) Moins de messages
C) Non-blocage en cas de panne du coordinateur
D) Support de plus de participants

**Reponse : C**

*Explication : Le 3PC ajoute une phase pre-commit permettant aux participants de prendre une decision autonome apres timeout.*

---

### Question 5
**Dans quel etat un participant peut-il rester bloque indefiniment en 2PC ?**

A) Initial
B) Prepared
C) Committed
D) Aborted

**Reponse : B**

*Explication : Si le coordinateur crash apres PREPARE mais avant la decision, les participants restent en Prepared.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | distributed_transaction_coordinator |
| **Module** | 5.2.21 -- Distributed Database Patterns |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 400 (base) + bonus x2.5/x4 |
| **Concepts cles** | 2PC, WAL, State machines, Timeout |
| **Piege principal** | Oublier le logging WAL |
| **Prerequis valide** | Async Rust, channels, error handling |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.2.21-a-distributed-transaction-coordinator",
    "generated_at": "2025-01-16T10:00:00Z",

    "metadata": {
      "exercise_id": "5.2.21-a",
      "exercise_name": "distributed_transaction_coordinator",
      "module": "5.2.21",
      "module_name": "Distributed Database Patterns",
      "concept": "a",
      "concept_name": "Two-Phase Commit Protocol",
      "type": "complet",
      "tier": 3,
      "tier_info": "Systeme complexe",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "8/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 400,
      "xp_bonus_multiplier": 2.5,
      "bonus_tier": "AVANCE",
      "complexity_time": "T4 O(n)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["async-rust", "channels", "state-machines"],
      "domains": ["Distributed Systems", "Databases", "Consensus"],
      "tags": ["2pc", "transactions", "distributed", "consistency"]
    },

    "files": {
      "spec.json": "Section 4.9",
      "references/ref_solution.rs": "Section 4.3",
      "mutants/mutant_a_timeout.rs": "Section 4.10",
      "mutants/mutant_b_state.rs": "Section 4.10",
      "mutants/mutant_c_recovery.rs": "Section 4.10",
      "mutants/mutant_d_rollback.rs": "Section 4.10",
      "mutants/mutant_e_concurrent.rs": "Section 4.10",
      "tests/lib_test.rs": "Section 4.2"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.rs"],
      "expected_fail": ["mutants/*.rs"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 -- "Consensus is not optional"*
*Exercise Quality Score: 97/100*
