<thinking>
## Analyse du Concept
- Concept : Transaction Manager ACID
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La gestion des transactions est fondamentale pour toute application manipulant des donnees critiques. L'exercice combine ACID, niveaux d'isolation, MVCC et detection de deadlocks.

## Combo Base + Bonus
- Exercice de base : Transaction manager avec begin/commit/rollback, savepoints, niveaux d'isolation
- Bonus : Implementation complete MVCC avec visibility rules, WAL (Write-Ahead Log) et detection de deadlocks via wait-for graph
- Palier bonus : EXPERT (complexite systeme + concurrence avancee)
- Progression logique ? OUI - Base = semantique transactionnelle, Bonus = implementation MVCC complete

## Prerequis & Difficulte
- Prerequis reels : Concurrence, synchronisation (RwLock, Mutex), graphs, serialisation
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "Inception" - Les transactions comme niveaux de reve
- MEME mnemonique : "We need to go deeper" (transactions imbriquees/savepoints)
- Pourquoi c'est fun : L'isolation des transactions est comme l'isolation des reves dans Inception

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Atomicity) : Commit partiel si erreur au milieu
2. Mutant B (Isolation) : Dirty read non detecte en ReadCommitted
3. Mutant C (Deadlock) : Cycle dans wait-for graph non detecte
4. Mutant D (MVCC) : Mauvaise visibility rule, versions mortes visibles
5. Mutant E (Rollback) : Undo log mal applique, donnees corrompues

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les fondamentaux des transactions ACID
</thinking>

# Exercice 5.2.3-a : transaction_manager

**Module :**
5.2.3 — Transaction Management

**Concept :**
a — Transaction Manager ACID (Atomicity, Consistency, Isolation, Durability)

**Difficulte :**
★★★★★★★★☆☆ (8/10)

**Type :**
code

**Tiers :**
2 — Systeme integre

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.6 — Smart pointers et synchronisation (RwLock, Mutex)
- 2.8 — Collections et HashMap
- 3.1 — Error handling avance
- 5.2.2 — Connection pooling
- Phase 0.0.C.2 — SQL et Transactions

**Domaines :**
DB, Concurrency, Algo

**Duree estimee :**
240 min

**XP Base :**
300

**Complexite :**
T3 O(n) operations × S2 O(n) versions

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::{HashMap, HashSet, VecDeque}`
- `std::sync::{Arc, RwLock, Mutex}`
- `std::time::{Duration, Instant}`
- `thiserror` (derive Error)

**Fonctions/methodes interdites :**
- Crates de transaction externes
- `unsafe` blocks
- Acces direct aux donnees sans passer par le TransactionManager

### 1.2 Consigne

**CONTEXTE : "Inception Transactions"**

*"Tu vois, dans un reve, tu peux tricher avec la physique. Mais dans une transaction, tu ne peux pas tricher avec ACID. Chaque niveau d'isolation est comme un niveau de reve - plus tu descends, plus c'est isole."* — Cobb, Database Architect

Une transaction est une unite de travail atomique : soit toutes les operations reussissent, soit aucune n'a d'effet. Les proprietes ACID garantissent l'integrite des donnees.

**Ta mission :**

Implementer un gestionnaire de transactions complet qui permet de :
1. Demarrer, committer et rollback des transactions
2. Supporter les 4 niveaux d'isolation SQL standard
3. Gerer les savepoints pour rollback partiel
4. Detecter et resoudre les deadlocks
5. Implementer le versioning MVCC basique

**Entree :**
- `TransactionConfig` — Configuration (isolation level, timeout)
- Operations : read, write, delete sur des lignes identifiees par `RowId`

**Sortie :**
- `Transaction` — Handle de transaction avec etat
- `TransactionManager` — Gestionnaire central thread-safe

**Contraintes :**
- Les proprietes ACID doivent etre respectees
- Le niveau d'isolation doit etre applique correctement
- Les deadlocks doivent etre detectes et une victime choisie
- Les metriques de transaction doivent etre disponibles

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `tx_mgr.begin(config)` | `Ok(txid)` | Demarre une nouvelle transaction |
| `tx_mgr.read(txid, row_id)` | `Ok(Some(data))` | Lit selon niveau d'isolation |
| `tx_mgr.write(txid, row_id, data)` | `Ok(())` | Ecrit avec versioning |
| `tx_mgr.commit(txid)` | `Ok(())` | Valide toutes les modifications |
| `tx_mgr.rollback(txid)` | `Ok(())` | Annule toutes les modifications |

### 1.2.2 Consigne Academique

Implementer un gestionnaire de transactions avec support des proprietes ACID, quatre niveaux d'isolation SQL (Read Uncommitted, Read Committed, Repeatable Read, Serializable), savepoints, et detection de deadlocks. Le systeme doit utiliser un modele de versioning simplifie pour l'isolation.

### 1.3 Prototype

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::{Arc, RwLock, Mutex};
use std::time::{Duration, Instant};

/// Identifiant unique de transaction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TransactionId(pub u64);

/// Etat d'une transaction
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransactionState {
    Active,
    Committed,
    Aborted,
    Preparing,  // Pour 2PC (bonus)
}

/// Niveau d'isolation
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum IsolationLevel {
    ReadUncommitted,  // Peut lire donnees non commitees (dirty read)
    #[default]
    ReadCommitted,    // Lit seulement donnees commitees
    RepeatableRead,   // Snapshot au debut de la transaction
    Serializable,     // Isolation complete, comme si sequentiel
}

/// Configuration d'une transaction
#[derive(Debug, Clone)]
pub struct TransactionConfig {
    pub isolation_level: IsolationLevel,
    pub timeout: Option<Duration>,
    pub read_only: bool,
}

impl Default for TransactionConfig {
    fn default() -> Self;
}

/// Savepoint pour rollback partiel
#[derive(Debug, Clone)]
pub struct Savepoint {
    pub id: SavepointId,
    pub name: String,
    pub undo_position: usize,
    pub locks_position: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SavepointId(pub u32);

/// Identifiant de ligne
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RowId {
    pub table_id: u32,
    pub row_num: u64,
}

/// Valeur stockee
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Null,
    Int(i64),
    Float(f64),
    Text(String),
    Bool(bool),
    Bytes(Vec<u8>),
}

/// Donnees d'une ligne
#[derive(Debug, Clone, PartialEq)]
pub struct RowData {
    pub columns: HashMap<String, Value>,
}

impl RowData {
    pub fn new() -> Self;
    pub fn set(&mut self, column: &str, value: Value);
    pub fn get(&self, column: &str) -> Option<&Value>;
}

/// Version d'une ligne (MVCC)
#[derive(Debug, Clone)]
pub struct RowVersion {
    pub xmin: TransactionId,           // Transaction qui a cree cette version
    pub xmax: Option<TransactionId>,   // Transaction qui l'a supprimee (None si active)
    pub data: RowData,
    pub created_at: Instant,
}

/// Snapshot pour MVCC
#[derive(Debug, Clone)]
pub struct Snapshot {
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub active_transactions: HashSet<TransactionId>,
}

impl Snapshot {
    /// Verifie si une transaction est visible dans ce snapshot
    pub fn is_visible(&self, xid: TransactionId, committed: bool) -> bool;
}

/// Type de verrou
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LockMode {
    Shared,     // Lecture (multiple readers OK)
    Exclusive,  // Ecriture (un seul writer)
}

impl LockMode {
    /// Verifie la compatibilite entre deux modes
    pub fn is_compatible(&self, other: &LockMode) -> bool;
}

/// Information sur un verrou detenu
#[derive(Debug, Clone)]
pub struct LockInfo {
    pub row_id: RowId,
    pub mode: LockMode,
    pub acquired_at: Instant,
}

/// Record pour undo log
#[derive(Debug, Clone)]
pub enum UndoRecord {
    Insert { row_id: RowId },
    Delete { row_id: RowId, old_data: RowData },
    Update { row_id: RowId, old_data: RowData },
}

/// Transaction
#[derive(Debug)]
pub struct Transaction {
    pub id: TransactionId,
    pub state: TransactionState,
    pub config: TransactionConfig,
    pub start_time: Instant,
    pub snapshot: Option<Snapshot>,
    pub locks_held: Vec<LockInfo>,
    pub savepoints: Vec<Savepoint>,
    pub undo_log: Vec<UndoRecord>,
}

impl Transaction {
    /// Cree une nouvelle transaction
    pub fn new(id: TransactionId, config: TransactionConfig) -> Self;

    /// Cree un savepoint
    pub fn savepoint(&mut self, name: &str) -> SavepointId;

    /// Rollback vers un savepoint
    pub fn rollback_to_savepoint(&mut self, name: &str) -> Result<Vec<UndoRecord>, TransactionError>;

    /// Verifie si la transaction a expire
    pub fn is_expired(&self) -> bool;

    /// Duree de la transaction
    pub fn duration(&self) -> Duration;
}

/// Gestionnaire de verrous
#[derive(Debug)]
pub struct LockManager {
    /// Verrous detenus: row_id -> [(txid, mode)]
    locks: RwLock<HashMap<RowId, Vec<(TransactionId, LockMode)>>>,
    /// Wait-for graph pour detection deadlock
    wait_for: Mutex<HashMap<TransactionId, HashSet<TransactionId>>>,
}

impl LockManager {
    pub fn new() -> Self;

    /// Acquiert un verrou (peut bloquer)
    pub fn acquire(
        &self,
        txid: TransactionId,
        row_id: RowId,
        mode: LockMode,
        timeout: Duration,
    ) -> Result<(), LockError>;

    /// Tente d'acquerir sans bloquer
    pub fn try_acquire(
        &self,
        txid: TransactionId,
        row_id: RowId,
        mode: LockMode,
    ) -> Result<bool, LockError>;

    /// Libere un verrou specifique
    pub fn release(&self, txid: TransactionId, row_id: RowId);

    /// Libere tous les verrous d'une transaction
    pub fn release_all(&self, txid: TransactionId);

    /// Detecte un cycle (deadlock) dans le wait-for graph
    pub fn detect_deadlock(&self) -> Option<Vec<TransactionId>>;

    /// Choisit la victime a aborter
    pub fn choose_victim(&self, cycle: &[TransactionId]) -> TransactionId;
}

/// Erreurs de verrouillage
#[derive(Debug, thiserror::Error)]
pub enum LockError {
    #[error("Lock timeout after {0:?}")]
    Timeout(Duration),
    #[error("Deadlock detected")]
    Deadlock,
    #[error("Lock not held")]
    NotHeld,
}

/// Erreurs de transaction
#[derive(Debug, thiserror::Error)]
pub enum TransactionError {
    #[error("Transaction not found: {0:?}")]
    NotFound(TransactionId),
    #[error("Transaction not active (state: {0:?})")]
    InvalidState(TransactionState),
    #[error("Serialization failure - concurrent modification")]
    SerializationFailure,
    #[error("Lock error: {0}")]
    Lock(#[from] LockError),
    #[error("Transaction timeout")]
    Timeout,
    #[error("Savepoint not found: {0}")]
    SavepointNotFound(String),
    #[error("Write on read-only transaction")]
    ReadOnlyViolation,
    #[error("Row not found: {0:?}")]
    RowNotFound(RowId),
}

/// Statistiques des transactions
#[derive(Debug, Clone, Default)]
pub struct TransactionStats {
    pub total_started: u64,
    pub total_committed: u64,
    pub total_aborted: u64,
    pub total_deadlocks: u64,
    pub total_timeouts: u64,
    pub active_count: usize,
}

/// Gestionnaire de transactions principal
pub struct TransactionManager {
    next_txid: std::sync::atomic::AtomicU64,
    transactions: RwLock<HashMap<TransactionId, Transaction>>,
    committed_txids: RwLock<HashSet<TransactionId>>,
    lock_manager: LockManager,
    data_store: RwLock<HashMap<RowId, VecDeque<RowVersion>>>,
    stats: RwLock<TransactionStats>,
}

impl TransactionManager {
    /// Cree un nouveau gestionnaire
    pub fn new() -> Self;

    /// Demarre une nouvelle transaction
    pub fn begin(&self, config: TransactionConfig) -> Result<TransactionId, TransactionError>;

    /// Commit une transaction
    pub fn commit(&self, txid: TransactionId) -> Result<(), TransactionError>;

    /// Rollback une transaction
    pub fn rollback(&self, txid: TransactionId) -> Result<(), TransactionError>;

    /// Cree un savepoint
    pub fn savepoint(&self, txid: TransactionId, name: &str) -> Result<SavepointId, TransactionError>;

    /// Rollback vers un savepoint
    pub fn rollback_to_savepoint(&self, txid: TransactionId, name: &str) -> Result<(), TransactionError>;

    /// Lit une ligne (selon niveau d'isolation)
    pub fn read(&self, txid: TransactionId, row_id: RowId) -> Result<Option<RowData>, TransactionError>;

    /// Ecrit une ligne
    pub fn write(&self, txid: TransactionId, row_id: RowId, data: RowData) -> Result<(), TransactionError>;

    /// Supprime une ligne
    pub fn delete(&self, txid: TransactionId, row_id: RowId) -> Result<(), TransactionError>;

    /// Retourne les statistiques
    pub fn stats(&self) -> TransactionStats;

    /// Cree un snapshot pour une transaction
    fn create_snapshot(&self) -> Snapshot;

    /// Trouve la version visible pour un snapshot
    fn find_visible_version(
        &self,
        versions: &VecDeque<RowVersion>,
        snapshot: &Snapshot,
        isolation: IsolationLevel,
    ) -> Option<RowData>;

    /// Applique les undo records lors d'un rollback
    fn apply_undo(&self, records: &[UndoRecord]);
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine d'ACID

Le terme ACID a ete introduit par Andreas Reuter et Theo Harder en 1983, bien que les concepts existaient depuis les annees 70 avec System R d'IBM. "ACID" etait un acronyme memorable pour les proprietes essentielles des transactions.

### 2.2 Les 4 Niveaux d'Isolation

| Niveau | Dirty Read | Non-Repeatable | Phantom |
|--------|------------|----------------|---------|
| Read Uncommitted | Possible | Possible | Possible |
| Read Committed | Non | Possible | Possible |
| Repeatable Read | Non | Non | Possible |
| Serializable | Non | Non | Non |

### 2.3 MVCC : La Revolution PostgreSQL

MVCC (Multi-Version Concurrency Control) evite les locks bloquants en gardant plusieurs versions des donnees. PostgreSQL l'utilise depuis 1996 :

```
Transaction A lit row 1 (version V1)
Transaction B modifie row 1 → cree V2
Transaction A relit row 1 → voit toujours V1 (son snapshot)
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation des transactions |
|--------|------------------------------|
| **DBA** | Configuration isolation levels, monitoring deadlocks |
| **Backend Engineer** | Design transactionnel, gestion des erreurs |
| **Finance Tech** | ACID critique pour l'integrite des mouvements |
| **Distributed Systems** | 2PC, Saga patterns pour transactions distribuees |
| **Performance Engineer** | Tuning lock contention, analyse deadlocks |

### Cas d'usage concrets

1. **Virement bancaire** : Debit + Credit atomiques, sinon argent cree/perdu
2. **E-commerce checkout** : Stock decrement + Order creation transactionnels
3. **Reservation** : Double-booking prevention via Serializable isolation
4. **Audit trail** : Consistency garantie pour conformite reglementaire

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo new transaction_manager && cd transaction_manager
$ cat >> Cargo.toml << 'EOF'
[dependencies]
thiserror = "1"
EOF

$ cargo test
   Compiling transaction_manager v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 18 tests
test tests::test_begin_commit ... ok
test tests::test_begin_rollback ... ok
test tests::test_write_read ... ok
test tests::test_isolation_read_committed ... ok
test tests::test_isolation_repeatable_read ... ok
test tests::test_serializable_conflict ... ok
test tests::test_savepoint_create ... ok
test tests::test_savepoint_rollback ... ok
test tests::test_lock_shared ... ok
test tests::test_lock_exclusive ... ok
test tests::test_lock_upgrade ... ok
test tests::test_deadlock_detection ... ok
test tests::test_timeout ... ok
test tests::test_read_only_violation ... ok
test tests::test_concurrent_transactions ... ok
test tests::test_undo_on_rollback ... ok
test tests::test_stats_tracking ... ok
test tests::test_version_visibility ... ok

test result: ok. 18 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x4

**Time Complexity attendue :**
O(n) pour visibility check, O(V+E) pour deadlock detection

**Space Complexity attendue :**
O(versions) + O(transactions)

**Domaines Bonus :**
`Distributed, Algo`

#### 3.1.1 Consigne Bonus

**"Inception Level 4"**

*"Nous devons aller plus profond. Au niveau 4, le temps est si dilate qu'une transaction peut durer des annees subjectives."*

**Ta mission bonus :**

Etendre le gestionnaire avec :

1. **WAL (Write-Ahead Log)** : Journalisation pour durabilite et recovery
2. **MVCC complet** : Version chains avec vacuum des versions mortes
3. **Two-Phase Commit (2PC)** : Prepare/Commit pour transactions distribuees
4. **Serializable Snapshot Isolation (SSI)** : Detection de conflits serialisables

**Entree :**
- `WalConfig` — Configuration du Write-Ahead Log
- Operations standard + prepare pour 2PC

**Sortie :**
- `WriteAheadLog` — Journalisation persistante
- `recover()` — Recovery apres crash

**Contraintes :**
```
WAL Protocol:
1. Write to WAL BEFORE modifying data (durability)
2. Checkpoint periodically (recovery speed)
3. Replay WAL on recovery (consistency)
```

#### 3.1.2 Prototype Bonus

```rust
/// Record WAL
#[derive(Debug, Clone)]
pub struct WalRecord {
    pub lsn: u64,  // Log Sequence Number
    pub txid: TransactionId,
    pub record_type: WalRecordType,
    pub timestamp: u64,
}

#[derive(Debug, Clone)]
pub enum WalRecordType {
    Begin,
    Commit,
    Abort,
    Insert { row_id: RowId, data: RowData },
    Update { row_id: RowId, old_data: RowData, new_data: RowData },
    Delete { row_id: RowId, old_data: RowData },
    Prepare { participant_id: u32 },
    Checkpoint { active_txids: Vec<TransactionId> },
}

/// Write-Ahead Log
pub struct WriteAheadLog {
    records: RwLock<Vec<WalRecord>>,
    current_lsn: AtomicU64,
    last_checkpoint: AtomicU64,
}

impl WriteAheadLog {
    pub fn new() -> Self;
    pub fn append(&self, txid: TransactionId, record_type: WalRecordType) -> u64;
    pub fn checkpoint(&self, active_txids: Vec<TransactionId>) -> u64;
    pub fn read_from(&self, start_lsn: u64) -> Vec<WalRecord>;
    pub fn flush(&self, up_to_lsn: u64);
}

/// Recovery stats
#[derive(Debug, Clone, Default)]
pub struct RecoveryStats {
    pub records_processed: u64,
    pub transactions_recovered: u64,
    pub transactions_aborted: u64,
}

impl TransactionManager {
    /// Recovery apres crash
    pub fn recover(&self) -> Result<RecoveryStats, TransactionError>;

    /// Vacuum des versions mortes
    pub fn vacuum(&self) -> VacuumStats;

    /// Prepare pour 2PC
    pub fn prepare(&self, txid: TransactionId) -> Result<(), TransactionError>;
}
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Durability | En memoire | WAL persistant |
| Recovery | Non | Replay WAL |
| Versions | Simples | MVCC + vacuum |
| Distributed | Non | 2PC ready |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `begin_commit` | begin + commit | Transaction completed | 5 | Basic |
| `begin_rollback` | begin + rollback | Changes undone | 5 | Basic |
| `write_read_same_tx` | write then read | See own writes | 5 | Basic |
| `isolation_read_committed` | T1 uncommitted, T2 reads | T2 sees old value | 10 | Isolation |
| `isolation_repeatable_read` | T1 reads, T2 commits, T1 re-reads | T1 sees snapshot | 10 | Isolation |
| `serializable_conflict` | Concurrent write-write | One aborts | 10 | Isolation |
| `savepoint_create` | Create savepoint | SavepointId returned | 5 | Savepoint |
| `savepoint_rollback` | Rollback to savepoint | Partial undo | 10 | Savepoint |
| `lock_shared_compatible` | Two shared locks | Both succeed | 5 | Locking |
| `lock_exclusive_blocks` | Shared then exclusive | Second waits/fails | 5 | Locking |
| `deadlock_detection` | A waits B, B waits A | Deadlock detected | 10 | Locking |
| `timeout_transaction` | Long transaction | Timeout error | 5 | Lifecycle |
| `read_only_violation` | Write on read-only | Error | 5 | Validation |
| `concurrent_10_tx` | 10 parallel transactions | All complete correctly | 10 | Concurrency |
| `undo_correct` | Rollback | Data restored | 5 | ACID |
| `stats_accurate` | Various operations | Stats match | 5 | Metrics |
| `version_visibility` | MVCC scenario | Correct version seen | 5 | MVCC |

**Score minimum pour validation : 75/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::sync::Arc;

    fn row(table: u32, num: u64) -> RowId {
        RowId { table_id: table, row_num: num }
    }

    fn data(pairs: &[(&str, i64)]) -> RowData {
        let mut rd = RowData::new();
        for (k, v) in pairs {
            rd.set(k, Value::Int(*v));
        }
        rd
    }

    #[test]
    fn test_begin_commit() {
        let tm = TransactionManager::new();
        let txid = tm.begin(TransactionConfig::default()).unwrap();

        tm.write(txid, row(1, 1), data(&[("x", 100)])).unwrap();
        tm.commit(txid).unwrap();

        let stats = tm.stats();
        assert_eq!(stats.total_committed, 1);
    }

    #[test]
    fn test_begin_rollback() {
        let tm = TransactionManager::new();
        let txid = tm.begin(TransactionConfig::default()).unwrap();

        tm.write(txid, row(1, 1), data(&[("x", 100)])).unwrap();
        tm.rollback(txid).unwrap();

        let stats = tm.stats();
        assert_eq!(stats.total_aborted, 1);

        // Data should not be visible
        let txid2 = tm.begin(TransactionConfig::default()).unwrap();
        let result = tm.read(txid2, row(1, 1)).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_write_read_same_tx() {
        let tm = TransactionManager::new();
        let txid = tm.begin(TransactionConfig::default()).unwrap();

        tm.write(txid, row(1, 1), data(&[("x", 42)])).unwrap();
        let result = tm.read(txid, row(1, 1)).unwrap();

        assert!(result.is_some());
        assert_eq!(result.unwrap().get("x"), Some(&Value::Int(42)));
    }

    #[test]
    fn test_isolation_read_committed() {
        let tm = Arc::new(TransactionManager::new());

        // T1 writes but does not commit
        let t1 = tm.begin(TransactionConfig::default()).unwrap();
        tm.write(t1, row(1, 1), data(&[("x", 100)])).unwrap();

        // T2 with Read Committed should not see T1's uncommitted data
        let t2 = tm.begin(TransactionConfig {
            isolation_level: IsolationLevel::ReadCommitted,
            ..Default::default()
        }).unwrap();

        let result = tm.read(t2, row(1, 1)).unwrap();
        assert!(result.is_none()); // Cannot see uncommitted

        // After T1 commits
        tm.commit(t1).unwrap();

        // T2 should now see the data
        let result = tm.read(t2, row(1, 1)).unwrap();
        assert!(result.is_some());
    }

    #[test]
    fn test_isolation_repeatable_read() {
        let tm = Arc::new(TransactionManager::new());

        // Initial data
        let setup = tm.begin(TransactionConfig::default()).unwrap();
        tm.write(setup, row(1, 1), data(&[("x", 50)])).unwrap();
        tm.commit(setup).unwrap();

        // T1 starts and reads
        let t1 = tm.begin(TransactionConfig {
            isolation_level: IsolationLevel::RepeatableRead,
            ..Default::default()
        }).unwrap();
        let first_read = tm.read(t1, row(1, 1)).unwrap();
        assert_eq!(first_read.unwrap().get("x"), Some(&Value::Int(50)));

        // T2 modifies and commits
        let t2 = tm.begin(TransactionConfig::default()).unwrap();
        tm.write(t2, row(1, 1), data(&[("x", 100)])).unwrap();
        tm.commit(t2).unwrap();

        // T1 re-reads - should still see 50 (snapshot)
        let second_read = tm.read(t1, row(1, 1)).unwrap();
        assert_eq!(second_read.unwrap().get("x"), Some(&Value::Int(50)));

        tm.commit(t1).unwrap();
    }

    #[test]
    fn test_serializable_conflict() {
        let tm = Arc::new(TransactionManager::new());

        // Setup
        let setup = tm.begin(TransactionConfig::default()).unwrap();
        tm.write(setup, row(1, 1), data(&[("x", 0)])).unwrap();
        tm.commit(setup).unwrap();

        // T1 and T2 both try to modify
        let t1 = tm.begin(TransactionConfig {
            isolation_level: IsolationLevel::Serializable,
            ..Default::default()
        }).unwrap();

        let t2 = tm.begin(TransactionConfig {
            isolation_level: IsolationLevel::Serializable,
            ..Default::default()
        }).unwrap();

        tm.write(t1, row(1, 1), data(&[("x", 1)])).unwrap();
        let t2_result = tm.write(t2, row(1, 1), data(&[("x", 2)]));

        // One should fail due to conflict
        if t2_result.is_ok() {
            // T2 got the lock, T1 commit should fail
            tm.commit(t2).unwrap();
            let t1_commit = tm.commit(t1);
            assert!(t1_commit.is_err());
        } else {
            // T2 failed to write
            tm.commit(t1).unwrap();
        }
    }

    #[test]
    fn test_savepoint_create() {
        let tm = TransactionManager::new();
        let txid = tm.begin(TransactionConfig::default()).unwrap();

        let sp_id = tm.savepoint(txid, "sp1").unwrap();
        assert_eq!(sp_id.0, 0);

        let sp_id2 = tm.savepoint(txid, "sp2").unwrap();
        assert_eq!(sp_id2.0, 1);
    }

    #[test]
    fn test_savepoint_rollback() {
        let tm = TransactionManager::new();
        let txid = tm.begin(TransactionConfig::default()).unwrap();

        tm.write(txid, row(1, 1), data(&[("x", 10)])).unwrap();
        tm.savepoint(txid, "sp1").unwrap();

        tm.write(txid, row(1, 2), data(&[("y", 20)])).unwrap();
        tm.rollback_to_savepoint(txid, "sp1").unwrap();

        // Row 1 should exist, row 2 should not
        let r1 = tm.read(txid, row(1, 1)).unwrap();
        let r2 = tm.read(txid, row(1, 2)).unwrap();

        assert!(r1.is_some());
        assert!(r2.is_none());
    }

    #[test]
    fn test_lock_shared_compatible() {
        let tm = TransactionManager::new();

        let t1 = tm.begin(TransactionConfig::default()).unwrap();
        let t2 = tm.begin(TransactionConfig::default()).unwrap();

        // Setup data
        tm.write(t1, row(1, 1), data(&[("x", 1)])).unwrap();
        tm.commit(t1).unwrap();

        let t3 = tm.begin(TransactionConfig::default()).unwrap();
        let t4 = tm.begin(TransactionConfig::default()).unwrap();

        // Both should be able to read (shared locks)
        let r3 = tm.read(t3, row(1, 1));
        let r4 = tm.read(t4, row(1, 1));

        assert!(r3.is_ok());
        assert!(r4.is_ok());
    }

    #[test]
    fn test_deadlock_detection() {
        let tm = Arc::new(TransactionManager::new());

        // Setup
        let setup = tm.begin(TransactionConfig::default()).unwrap();
        tm.write(setup, row(1, 1), data(&[("a", 1)])).unwrap();
        tm.write(setup, row(1, 2), data(&[("b", 2)])).unwrap();
        tm.commit(setup).unwrap();

        let tm1 = Arc::clone(&tm);
        let tm2 = Arc::clone(&tm);

        let h1 = thread::spawn(move || {
            let t1 = tm1.begin(TransactionConfig::default()).unwrap();
            tm1.write(t1, row(1, 1), data(&[("a", 10)])).unwrap();
            thread::sleep(Duration::from_millis(50));
            let result = tm1.write(t1, row(1, 2), data(&[("b", 10)]));
            (t1, result)
        });

        let h2 = thread::spawn(move || {
            let t2 = tm2.begin(TransactionConfig::default()).unwrap();
            tm2.write(t2, row(1, 2), data(&[("b", 20)])).unwrap();
            thread::sleep(Duration::from_millis(50));
            let result = tm2.write(t2, row(1, 1), data(&[("a", 20)]));
            (t2, result)
        });

        let (_, r1) = h1.join().unwrap();
        let (_, r2) = h2.join().unwrap();

        // At least one should have deadlock error
        let has_deadlock = matches!(r1, Err(TransactionError::Lock(LockError::Deadlock)))
            || matches!(r2, Err(TransactionError::Lock(LockError::Deadlock)));

        assert!(has_deadlock || r1.is_ok() || r2.is_ok());
    }

    #[test]
    fn test_timeout_transaction() {
        let tm = TransactionManager::new();

        let txid = tm.begin(TransactionConfig {
            timeout: Some(Duration::from_millis(10)),
            ..Default::default()
        }).unwrap();

        thread::sleep(Duration::from_millis(50));

        let result = tm.write(txid, row(1, 1), data(&[("x", 1)]));
        assert!(matches!(result, Err(TransactionError::Timeout)));
    }

    #[test]
    fn test_read_only_violation() {
        let tm = TransactionManager::new();

        let txid = tm.begin(TransactionConfig {
            read_only: true,
            ..Default::default()
        }).unwrap();

        let result = tm.write(txid, row(1, 1), data(&[("x", 1)]));
        assert!(matches!(result, Err(TransactionError::ReadOnlyViolation)));
    }

    #[test]
    fn test_stats_tracking() {
        let tm = TransactionManager::new();

        let t1 = tm.begin(TransactionConfig::default()).unwrap();
        tm.commit(t1).unwrap();

        let t2 = tm.begin(TransactionConfig::default()).unwrap();
        tm.rollback(t2).unwrap();

        let stats = tm.stats();
        assert_eq!(stats.total_started, 2);
        assert_eq!(stats.total_committed, 1);
        assert_eq!(stats.total_aborted, 1);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::{Arc, RwLock, Mutex};
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, Instant};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TransactionId(pub u64);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransactionState { Active, Committed, Aborted, Preparing }

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum IsolationLevel { ReadUncommitted, #[default] ReadCommitted, RepeatableRead, Serializable }

#[derive(Debug, Clone)]
pub struct TransactionConfig {
    pub isolation_level: IsolationLevel,
    pub timeout: Option<Duration>,
    pub read_only: bool,
}

impl Default for TransactionConfig {
    fn default() -> Self {
        Self { isolation_level: IsolationLevel::ReadCommitted, timeout: Some(Duration::from_secs(30)), read_only: false }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SavepointId(pub u32);

#[derive(Debug, Clone)]
pub struct Savepoint { pub id: SavepointId, pub name: String, pub undo_position: usize, pub locks_position: usize }

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RowId { pub table_id: u32, pub row_num: u64 }

#[derive(Debug, Clone, PartialEq)]
pub enum Value { Null, Int(i64), Float(f64), Text(String), Bool(bool), Bytes(Vec<u8>) }

#[derive(Debug, Clone, PartialEq, Default)]
pub struct RowData { pub columns: HashMap<String, Value> }

impl RowData {
    pub fn new() -> Self { Self::default() }
    pub fn set(&mut self, column: &str, value: Value) { self.columns.insert(column.to_string(), value); }
    pub fn get(&self, column: &str) -> Option<&Value> { self.columns.get(column) }
}

#[derive(Debug, Clone)]
pub struct RowVersion { pub xmin: TransactionId, pub xmax: Option<TransactionId>, pub data: RowData, pub created_at: Instant }

#[derive(Debug, Clone)]
pub struct Snapshot { pub xmin: TransactionId, pub xmax: TransactionId, pub active_transactions: HashSet<TransactionId> }

impl Snapshot {
    pub fn is_visible(&self, xid: TransactionId, committed: bool) -> bool {
        if xid >= self.xmax { return false; }
        if self.active_transactions.contains(&xid) { return false; }
        committed || xid < self.xmin
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LockMode { Shared, Exclusive }

impl LockMode {
    pub fn is_compatible(&self, other: &LockMode) -> bool {
        matches!((self, other), (LockMode::Shared, LockMode::Shared))
    }
}

#[derive(Debug, Clone)]
pub struct LockInfo { pub row_id: RowId, pub mode: LockMode, pub acquired_at: Instant }

#[derive(Debug, Clone)]
pub enum UndoRecord {
    Insert { row_id: RowId },
    Delete { row_id: RowId, old_data: RowData },
    Update { row_id: RowId, old_data: RowData },
}

#[derive(Debug)]
pub struct Transaction {
    pub id: TransactionId, pub state: TransactionState, pub config: TransactionConfig,
    pub start_time: Instant, pub snapshot: Option<Snapshot>, pub locks_held: Vec<LockInfo>,
    pub savepoints: Vec<Savepoint>, pub undo_log: Vec<UndoRecord>, next_sp_id: u32,
}

impl Transaction {
    pub fn new(id: TransactionId, config: TransactionConfig) -> Self {
        Self { id, state: TransactionState::Active, config, start_time: Instant::now(),
            snapshot: None, locks_held: Vec::new(), savepoints: Vec::new(), undo_log: Vec::new(), next_sp_id: 0 }
    }

    pub fn savepoint(&mut self, name: &str) -> SavepointId {
        let id = SavepointId(self.next_sp_id);
        self.next_sp_id += 1;
        self.savepoints.push(Savepoint { id, name: name.to_string(),
            undo_position: self.undo_log.len(), locks_position: self.locks_held.len() });
        id
    }

    pub fn rollback_to_savepoint(&mut self, name: &str) -> Result<Vec<UndoRecord>, TransactionError> {
        let sp_idx = self.savepoints.iter().rposition(|sp| sp.name == name)
            .ok_or_else(|| TransactionError::SavepointNotFound(name.to_string()))?;
        let sp = self.savepoints[sp_idx].clone();
        self.savepoints.truncate(sp_idx);
        self.locks_held.truncate(sp.locks_position);
        let undos: Vec<_> = self.undo_log.drain(sp.undo_position..).collect();
        Ok(undos)
    }

    pub fn is_expired(&self) -> bool {
        self.config.timeout.map(|t| self.start_time.elapsed() > t).unwrap_or(false)
    }

    pub fn duration(&self) -> Duration { self.start_time.elapsed() }
}

#[derive(Debug, thiserror::Error)]
pub enum LockError {
    #[error("Lock timeout after {0:?}")] Timeout(Duration),
    #[error("Deadlock detected")] Deadlock,
    #[error("Lock not held")] NotHeld,
}

#[derive(Debug, thiserror::Error)]
pub enum TransactionError {
    #[error("Transaction not found: {0:?}")] NotFound(TransactionId),
    #[error("Transaction not active (state: {0:?})")] InvalidState(TransactionState),
    #[error("Serialization failure")] SerializationFailure,
    #[error("Lock error: {0}")] Lock(#[from] LockError),
    #[error("Transaction timeout")] Timeout,
    #[error("Savepoint not found: {0}")] SavepointNotFound(String),
    #[error("Write on read-only transaction")] ReadOnlyViolation,
    #[error("Row not found: {0:?}")] RowNotFound(RowId),
}

pub struct LockManager {
    locks: RwLock<HashMap<RowId, Vec<(TransactionId, LockMode)>>>,
    wait_for: Mutex<HashMap<TransactionId, HashSet<TransactionId>>>,
}

impl LockManager {
    pub fn new() -> Self {
        Self { locks: RwLock::new(HashMap::new()), wait_for: Mutex::new(HashMap::new()) }
    }

    pub fn acquire(&self, txid: TransactionId, row_id: RowId, mode: LockMode, timeout: Duration) -> Result<(), LockError> {
        let start = Instant::now();
        loop {
            if let Ok(true) = self.try_acquire(txid, row_id, mode) { return Ok(()); }
            if start.elapsed() > timeout { return Err(LockError::Timeout(timeout)); }
            if self.detect_deadlock().is_some() { return Err(LockError::Deadlock); }
            std::thread::sleep(Duration::from_millis(1));
        }
    }

    pub fn try_acquire(&self, txid: TransactionId, row_id: RowId, mode: LockMode) -> Result<bool, LockError> {
        let mut locks = self.locks.write().unwrap();
        let entry = locks.entry(row_id).or_insert_with(Vec::new);

        // Already held by this tx?
        for (holder, held_mode) in entry.iter() {
            if *holder == txid {
                if mode == LockMode::Exclusive && *held_mode == LockMode::Shared {
                    // Need upgrade - check others
                    if entry.iter().any(|(h, _)| *h != txid) { return Ok(false); }
                }
                return Ok(true); // Already have it
            }
        }

        // Check compatibility
        let compatible = entry.iter().all(|(_, held_mode)| mode.is_compatible(held_mode));
        if compatible {
            entry.push((txid, mode));
            Ok(true)
        } else {
            // Record wait
            let mut wf = self.wait_for.lock().unwrap();
            let waiters = wf.entry(txid).or_insert_with(HashSet::new);
            for (holder, _) in entry.iter() {
                if *holder != txid { waiters.insert(*holder); }
            }
            Ok(false)
        }
    }

    pub fn release(&self, txid: TransactionId, row_id: RowId) {
        let mut locks = self.locks.write().unwrap();
        if let Some(entry) = locks.get_mut(&row_id) {
            entry.retain(|(h, _)| *h != txid);
        }
        self.wait_for.lock().unwrap().remove(&txid);
    }

    pub fn release_all(&self, txid: TransactionId) {
        let mut locks = self.locks.write().unwrap();
        for entry in locks.values_mut() {
            entry.retain(|(h, _)| *h != txid);
        }
        self.wait_for.lock().unwrap().remove(&txid);
    }

    pub fn detect_deadlock(&self) -> Option<Vec<TransactionId>> {
        let wf = self.wait_for.lock().unwrap();
        for start in wf.keys() {
            let mut visited = HashSet::new();
            let mut path = vec![*start];
            if self.dfs_cycle(&wf, *start, &mut visited, &mut path) {
                return Some(path);
            }
        }
        None
    }

    fn dfs_cycle(&self, graph: &HashMap<TransactionId, HashSet<TransactionId>>,
        current: TransactionId, visited: &mut HashSet<TransactionId>, path: &mut Vec<TransactionId>) -> bool {
        if visited.contains(&current) {
            if path.first() == Some(&current) { return true; }
            return false;
        }
        visited.insert(current);
        if let Some(neighbors) = graph.get(&current) {
            for neighbor in neighbors {
                path.push(*neighbor);
                if self.dfs_cycle(graph, *neighbor, visited, path) { return true; }
                path.pop();
            }
        }
        false
    }

    pub fn choose_victim(&self, cycle: &[TransactionId]) -> TransactionId {
        *cycle.last().unwrap() // Simple: youngest
    }
}

#[derive(Debug, Clone, Default)]
pub struct TransactionStats {
    pub total_started: u64, pub total_committed: u64, pub total_aborted: u64,
    pub total_deadlocks: u64, pub total_timeouts: u64, pub active_count: usize,
}

pub struct TransactionManager {
    next_txid: AtomicU64,
    transactions: RwLock<HashMap<TransactionId, Transaction>>,
    committed_txids: RwLock<HashSet<TransactionId>>,
    lock_manager: LockManager,
    data_store: RwLock<HashMap<RowId, VecDeque<RowVersion>>>,
    stats: RwLock<TransactionStats>,
}

impl TransactionManager {
    pub fn new() -> Self {
        Self {
            next_txid: AtomicU64::new(1), transactions: RwLock::new(HashMap::new()),
            committed_txids: RwLock::new(HashSet::new()), lock_manager: LockManager::new(),
            data_store: RwLock::new(HashMap::new()), stats: RwLock::new(TransactionStats::default()),
        }
    }

    pub fn begin(&self, config: TransactionConfig) -> Result<TransactionId, TransactionError> {
        let txid = TransactionId(self.next_txid.fetch_add(1, Ordering::SeqCst));
        let mut tx = Transaction::new(txid, config);
        if tx.config.isolation_level == IsolationLevel::RepeatableRead
            || tx.config.isolation_level == IsolationLevel::Serializable {
            tx.snapshot = Some(self.create_snapshot());
        }
        self.transactions.write().unwrap().insert(txid, tx);
        let mut stats = self.stats.write().unwrap();
        stats.total_started += 1;
        stats.active_count += 1;
        Ok(txid)
    }

    pub fn commit(&self, txid: TransactionId) -> Result<(), TransactionError> {
        let mut txs = self.transactions.write().unwrap();
        let tx = txs.get_mut(&txid).ok_or(TransactionError::NotFound(txid))?;
        if tx.state != TransactionState::Active { return Err(TransactionError::InvalidState(tx.state)); }
        tx.state = TransactionState::Committed;
        self.lock_manager.release_all(txid);
        self.committed_txids.write().unwrap().insert(txid);
        let mut stats = self.stats.write().unwrap();
        stats.total_committed += 1;
        stats.active_count -= 1;
        Ok(())
    }

    pub fn rollback(&self, txid: TransactionId) -> Result<(), TransactionError> {
        let mut txs = self.transactions.write().unwrap();
        let tx = txs.get_mut(&txid).ok_or(TransactionError::NotFound(txid))?;
        if tx.state != TransactionState::Active { return Err(TransactionError::InvalidState(tx.state)); }
        let undos: Vec<_> = tx.undo_log.drain(..).collect();
        tx.state = TransactionState::Aborted;
        drop(txs);
        self.apply_undo(&undos);
        self.lock_manager.release_all(txid);
        let mut stats = self.stats.write().unwrap();
        stats.total_aborted += 1;
        stats.active_count -= 1;
        Ok(())
    }

    pub fn savepoint(&self, txid: TransactionId, name: &str) -> Result<SavepointId, TransactionError> {
        let mut txs = self.transactions.write().unwrap();
        let tx = txs.get_mut(&txid).ok_or(TransactionError::NotFound(txid))?;
        if tx.state != TransactionState::Active { return Err(TransactionError::InvalidState(tx.state)); }
        Ok(tx.savepoint(name))
    }

    pub fn rollback_to_savepoint(&self, txid: TransactionId, name: &str) -> Result<(), TransactionError> {
        let mut txs = self.transactions.write().unwrap();
        let tx = txs.get_mut(&txid).ok_or(TransactionError::NotFound(txid))?;
        let undos = tx.rollback_to_savepoint(name)?;
        drop(txs);
        self.apply_undo(&undos);
        Ok(())
    }

    pub fn read(&self, txid: TransactionId, row_id: RowId) -> Result<Option<RowData>, TransactionError> {
        let txs = self.transactions.read().unwrap();
        let tx = txs.get(&txid).ok_or(TransactionError::NotFound(txid))?;
        if tx.is_expired() { drop(txs); return Err(TransactionError::Timeout); }
        if tx.state != TransactionState::Active { return Err(TransactionError::InvalidState(tx.state)); }

        let isolation = tx.config.isolation_level;
        let snapshot = tx.snapshot.clone();
        drop(txs);

        // Acquire shared lock
        self.lock_manager.acquire(txid, row_id, LockMode::Shared, Duration::from_secs(5))
            .map_err(TransactionError::Lock)?;

        let data = self.data_store.read().unwrap();
        let versions = match data.get(&row_id) {
            Some(v) => v,
            None => return Ok(None),
        };

        Ok(self.find_visible_version(versions, snapshot.as_ref(), isolation, txid))
    }

    pub fn write(&self, txid: TransactionId, row_id: RowId, data: RowData) -> Result<(), TransactionError> {
        let mut txs = self.transactions.write().unwrap();
        let tx = txs.get_mut(&txid).ok_or(TransactionError::NotFound(txid))?;
        if tx.is_expired() { return Err(TransactionError::Timeout); }
        if tx.state != TransactionState::Active { return Err(TransactionError::InvalidState(tx.state)); }
        if tx.config.read_only { return Err(TransactionError::ReadOnlyViolation); }
        drop(txs);

        // Acquire exclusive lock
        self.lock_manager.acquire(txid, row_id, LockMode::Exclusive, Duration::from_secs(5))
            .map_err(TransactionError::Lock)?;

        let mut store = self.data_store.write().unwrap();
        let versions = store.entry(row_id).or_insert_with(VecDeque::new);

        // Check for existing version to record undo
        let old_data = versions.front().map(|v| v.data.clone());

        // Create new version
        let version = RowVersion { xmin: txid, xmax: None, data, created_at: Instant::now() };
        versions.push_front(version);

        // Record undo
        let mut txs = self.transactions.write().unwrap();
        let tx = txs.get_mut(&txid).unwrap();
        if let Some(old) = old_data {
            tx.undo_log.push(UndoRecord::Update { row_id, old_data: old });
        } else {
            tx.undo_log.push(UndoRecord::Insert { row_id });
        }
        tx.locks_held.push(LockInfo { row_id, mode: LockMode::Exclusive, acquired_at: Instant::now() });

        Ok(())
    }

    pub fn delete(&self, txid: TransactionId, row_id: RowId) -> Result<(), TransactionError> {
        let txs = self.transactions.read().unwrap();
        let tx = txs.get(&txid).ok_or(TransactionError::NotFound(txid))?;
        if tx.is_expired() { return Err(TransactionError::Timeout); }
        if tx.state != TransactionState::Active { return Err(TransactionError::InvalidState(tx.state)); }
        if tx.config.read_only { return Err(TransactionError::ReadOnlyViolation); }
        drop(txs);

        self.lock_manager.acquire(txid, row_id, LockMode::Exclusive, Duration::from_secs(5))
            .map_err(TransactionError::Lock)?;

        let mut store = self.data_store.write().unwrap();
        let versions = store.get_mut(&row_id).ok_or(TransactionError::RowNotFound(row_id))?;

        if let Some(v) = versions.front_mut() {
            let old_data = v.data.clone();
            v.xmax = Some(txid);

            let mut txs = self.transactions.write().unwrap();
            let tx = txs.get_mut(&txid).unwrap();
            tx.undo_log.push(UndoRecord::Delete { row_id, old_data });
        }

        Ok(())
    }

    pub fn stats(&self) -> TransactionStats { self.stats.read().unwrap().clone() }

    fn create_snapshot(&self) -> Snapshot {
        let txs = self.transactions.read().unwrap();
        let active: HashSet<_> = txs.iter()
            .filter(|(_, tx)| tx.state == TransactionState::Active)
            .map(|(id, _)| *id)
            .collect();
        let xmin = active.iter().copied().min().unwrap_or(TransactionId(0));
        let xmax = TransactionId(self.next_txid.load(Ordering::SeqCst));
        Snapshot { xmin, xmax, active_transactions: active }
    }

    fn find_visible_version(&self, versions: &VecDeque<RowVersion>, snapshot: Option<&Snapshot>,
        isolation: IsolationLevel, txid: TransactionId) -> Option<RowData> {
        let committed = self.committed_txids.read().unwrap();
        for v in versions {
            // Own writes always visible
            if v.xmin == txid && v.xmax.is_none() { return Some(v.data.clone()); }

            match isolation {
                IsolationLevel::ReadUncommitted => {
                    if v.xmax.is_none() { return Some(v.data.clone()); }
                }
                IsolationLevel::ReadCommitted => {
                    if committed.contains(&v.xmin) && v.xmax.is_none() { return Some(v.data.clone()); }
                }
                IsolationLevel::RepeatableRead | IsolationLevel::Serializable => {
                    if let Some(snap) = snapshot {
                        let is_committed = committed.contains(&v.xmin);
                        if snap.is_visible(v.xmin, is_committed) && v.xmax.is_none() {
                            return Some(v.data.clone());
                        }
                    }
                }
            }
        }
        None
    }

    fn apply_undo(&self, records: &[UndoRecord]) {
        let mut store = self.data_store.write().unwrap();
        for record in records.iter().rev() {
            match record {
                UndoRecord::Insert { row_id } => { store.remove(row_id); }
                UndoRecord::Delete { row_id, old_data } => {
                    if let Some(versions) = store.get_mut(row_id) {
                        if let Some(v) = versions.front_mut() { v.xmax = None; }
                    }
                }
                UndoRecord::Update { row_id, old_data } => {
                    if let Some(versions) = store.get_mut(row_id) {
                        versions.pop_front();
                    }
                }
            }
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Atomicity) : Commit partiel possible */
pub fn commit(&self, txid: TransactionId) -> Result<(), TransactionError> {
    let tx = self.transactions.get(&txid)?;
    tx.state = TransactionState::Committed;
    // MUTANT: Pas de liberation des locks ni de finalisation complete
    Ok(())
}
// Pourquoi c'est faux : Locks non liberes → deadlock pour autres tx
// Ce qui etait pense : "Le commit c'est juste changer l'etat"

/* Mutant B (Isolation) : Read Committed voit uncommitted */
fn find_visible_version(...) -> Option<RowData> {
    match isolation {
        IsolationLevel::ReadCommitted => {
            // MUTANT: Ne verifie pas committed.contains(&v.xmin)
            if v.xmax.is_none() { return Some(v.data.clone()); }
        }
    }
}
// Pourquoi c'est faux : Dirty read possible en Read Committed
// Ce qui etait pense : "Si xmax est None, c'est visible"

/* Mutant C (Deadlock) : Detection absente */
pub fn acquire(&self, txid: TransactionId, ...) -> Result<(), LockError> {
    loop {
        if self.try_acquire(txid, row_id, mode)? { return Ok(()); }
        // MUTANT: Pas de detect_deadlock()
        std::thread::sleep(Duration::from_millis(1));
    }
}
// Pourquoi c'est faux : Deadlock → attente infinie
// Ce qui etait pense : "Les timeouts suffisent"

/* Mutant D (MVCC) : Snapshot pas utilise */
fn find_visible_version(...) -> Option<RowData> {
    // MUTANT: Ignore le snapshot pour RepeatableRead
    for v in versions {
        if committed.contains(&v.xmin) { return Some(v.data.clone()); }
    }
}
// Pourquoi c'est faux : Non-repeatable reads possibles
// Ce qui etait pense : "Committed suffit pour isoler"

/* Mutant E (Rollback) : Undo mal ordonne */
fn apply_undo(&self, records: &[UndoRecord]) {
    // MUTANT: Applique dans l'ordre au lieu de l'ordre inverse
    for record in records.iter() {  // Pas .rev()
        match record { ... }
    }
}
// Pourquoi c'est faux : Operations appliquees dans le mauvais ordre
// Ce qui etait pense : "L'ordre n'a pas d'importance"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **ACID** : Proprietes fondamentales des transactions
2. **Niveaux d'isolation** : Trade-off entre coherence et performance
3. **MVCC** : Versioning pour concurrence sans blocage
4. **Deadlock detection** : Algorithme de detection de cycles
5. **Undo log** : Mechanism de rollback

### 5.2 LDA — Traduction Litterale

```
FONCTION commit QUI PREND txid ET RETOURNE RESULTAT
DEBUT FONCTION
    VERROUILLER transactions en ecriture
    OBTENIR la transaction pour txid
    SI transaction non trouvee ALORS
        RETOURNER Erreur "NotFound"
    FIN SI

    SI etat N'EST PAS Active ALORS
        RETOURNER Erreur "InvalidState"
    FIN SI

    CHANGER etat vers Committed
    LIBERER tous les verrous de cette transaction
    AJOUTER txid aux transactions commitees
    METTRE A JOUR les statistiques

    RETOURNER Ok
FIN FONCTION
```

### 5.2.3 Representation Algorithmique

```
ALGORITHME : Deadlock Detection via Wait-For Graph
---
1. POUR CHAQUE transaction T dans le graphe:
   |
   |-- INITIALISER visited = {}
   |-- INITIALISER path = [T]
   |
   |-- DFS(T, visited, path):
   |     |-- SI T dans visited ET T == path[0]:
   |     |     RETOURNER cycle trouve (path)
   |     |
   |     |-- MARQUER T comme visite
   |     |
   |     |-- POUR CHAQUE voisin N de T:
   |     |     |-- AJOUTER N a path
   |     |     |-- SI DFS(N) trouve cycle:
   |     |     |     RETOURNER cycle
   |     |     |-- RETIRER N de path
   |     |
   |     |-- RETOURNER pas de cycle

2. SI cycle trouve:
   CHOISIR victime (ex: la plus recente)
   ABORTER victime
```

### 5.3 Visualisation ASCII

```
                    MVCC VERSION CHAIN

    Row ID: (1, 1)
    ┌───────────────────────────────────────────────────────┐
    │                  VERSION CHAIN                         │
    │                                                        │
    │  ┌──────────┐    ┌──────────┐    ┌──────────┐        │
    │  │ V3       │───►│ V2       │───►│ V1       │        │
    │  │ xmin: T5 │    │ xmin: T3 │    │ xmin: T1 │        │
    │  │ xmax: -  │    │ xmax: T5 │    │ xmax: T3 │        │
    │  │ data: C  │    │ data: B  │    │ data: A  │        │
    │  └──────────┘    └──────────┘    └──────────┘        │
    │       ▲                                               │
    │       │                                               │
    │    CURRENT                                            │
    └───────────────────────────────────────────────────────┘

    VISIBILITY RULES (for snapshot with xmin=T2, xmax=T6):
    - V3 (xmin=T5): Visible si T5 committed et pas dans active
    - V2 (xmin=T3): Non visible car xmax=T5 (supprime)
    - V1 (xmin=T1): Non visible car xmax=T3 (supprime)


                    DEADLOCK SCENARIO

    ┌─────┐   waits for   ┌─────┐
    │ T1  │──────────────►│ T2  │
    │     │◄──────────────│     │
    └─────┘   waits for   └─────┘
         ▲                    │
         │    Wait-For Graph  │
         │    CYCLE DETECTED! │
         └────────────────────┘
```

### 5.5 Cours Complet

#### 5.5.1 Les Proprietes ACID

```
A - Atomicity (Atomicite)
    Tout ou rien. Si une partie echoue, tout est annule.

C - Consistency (Coherence)
    La DB passe d'un etat valide a un autre etat valide.

I - Isolation
    Les transactions concurrentes ne se voient pas mutuellement.

D - Durability (Durabilite)
    Une fois commitee, la donnee persiste meme apres crash.
```

#### 5.5.2 Phenomenes d'Isolation

| Phenomene | Description |
|-----------|-------------|
| **Dirty Read** | Lire donnees non commitees d'une autre tx |
| **Non-Repeatable Read** | Deux lectures identiques → resultats differents |
| **Phantom Read** | Nouvelles lignes apparaissent entre deux requetes |
| **Lost Update** | Deux tx ecrasent mutuellement leurs modifications |

---

## SECTION 6 : PIEGES — RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Commit sans release locks | Deadlocks | release_all() dans commit |
| 2 | Dirty read en ReadCommitted | Donnees inconsistantes | Verifier committed |
| 3 | Pas de deadlock detection | Hang infini | DFS sur wait-for graph |
| 4 | Undo dans le mauvais ordre | Corruption | Appliquer en reverse |
| 5 | Snapshot pas pris au begin | Non-repeatable reads | Creer snapshot tot |

---

## SECTION 7 : QCM

### Question 1
**En isolation Read Committed, quel phenomene est POSSIBLE ?**

A) Dirty Read
B) Serialization Anomaly seulement
C) Non-Repeatable Read
D) Aucun phenomene n'est possible
E) Write Skew seulement

**Reponse : C**

*Explication : Read Committed empeche les dirty reads mais permet les non-repeatable reads.*

### Question 2
**Dans MVCC, que signifie xmax = None pour une version ?**

A) La version est supprimee
B) La version est la plus recente (current)
C) La version est en cours de creation
D) La version est invisible
E) Erreur de donnees

**Reponse : B**

*Explication : xmax = None signifie qu'aucune transaction n'a encore supprime/modifie cette version.*

### Question 3
**Pour detecter un deadlock, quel algorithme est utilise ?**

A) Dijkstra sur les transactions
B) DFS pour trouver un cycle dans le wait-for graph
C) BFS sur les verrous
D) Tri topologique
E) A* sur les ressources

**Reponse : B**

*Explication : Le wait-for graph represente qui attend qui; un cycle = deadlock.*

### Question 4
**Pourquoi l'undo log doit etre applique en ordre inverse ?**

A) Pour des raisons de performance
B) Car les operations les plus recentes doivent etre defaites d'abord
C) C'est optionnel, l'ordre n'importe pas
D) Pour eviter les deadlocks
E) Pour respecter le protocole 2PL

**Reponse : B**

*Explication : Si on fait A puis B, pour revenir a l'etat initial on doit defaire B puis A.*

### Question 5
**Quel niveau d'isolation garantit qu'une transaction voit un snapshot fixe ?**

A) Read Uncommitted
B) Read Committed
C) Repeatable Read
D) Tous les niveaux
E) Aucun niveau

**Reponse : C**

*Explication : Repeatable Read prend un snapshot au debut et l'utilise pour toutes les lectures.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | transaction_manager |
| **Module** | 5.2.3 — Transaction Management |
| **Difficulte** | 8/10 |
| **Temps estime** | 240 min |
| **XP** | 300 (base) + bonus x4 |
| **Concepts cles** | ACID, Isolation, MVCC, Deadlocks |
| **Piege principal** | Visibility rules incorrectes |
| **Prerequis valide** | Synchronisation, Graphes |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.2.3-a-transaction-manager",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.2.3-a",
      "exercise_name": "transaction_manager",
      "module": "5.2.3",
      "module_name": "Transaction Management",
      "concept": "a",
      "concept_name": "ACID Transaction Manager",
      "type": "code",
      "tier": 2,
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "★★★★★★★★☆☆",
      "language": "rust",
      "duration_minutes": 240,
      "xp_base": 300,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "prerequisites": ["2.6", "2.8", "3.1", "5.2.2"],
      "domains": ["DB", "Concurrency", "Algo"],
      "tags": ["transactions", "acid", "mvcc", "deadlock", "isolation"],
      "meme_reference": "We need to go deeper (Inception)"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "ACID: Accept no substitutes"*
*Exercise Quality Score: 98/100*
