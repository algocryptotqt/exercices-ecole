# Exercice 3.4.5-a : first_overflow

**Module :**
3.4.5 — Stack Exploitation

**Concept :**
a — Principes du stack buffer overflow

**Difficulte :**
★★★★★☆☆☆☆☆ (5/10)

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Python 3.12

**Prerequis :**
- Exercice 3.4.1-a (register_decoder)
- Comprehension de la pile (stack)
- Bases du C

**Domaines :**
Exploit, Stack, Memory

**Duree estimee :**
45 min

**XP Base :**
150

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`first_overflow.py`

**Fonctions autorisees :**
- `json` (module standard)
- `re` (expressions regulieres)
- `sys` (arguments)
- `struct` (packing)
- Fonctions built-in Python

**Fonctions interdites :**
- pwntools
- Bibliotheques d'exploitation

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Hackers (1995)"

*"Hack the planet!"*

Dans le film culte **Hackers**, les protagonistes explorent les systemes informatiques avec creativite et determination. Le buffer overflow est l'une des plus anciennes et plus fondamentales techniques d'exploitation - c'est le "Hello World" du hacking.

En 1988, le **Morris Worm** a utilise un buffer overflow dans `fingerd` pour se propager sur Internet, infectant environ 10% des machines connectees. Cette technique a plus de 35 ans et reste pertinente aujourd'hui!

#### 2.4.2 Enonce Academique

Un **buffer overflow** se produit quand un programme ecrit plus de donnees dans un buffer que sa capacite ne le permet. Sur la pile (stack), cela peut ecraser :
1. Les variables locales
2. Le **saved RBP** (frame pointer sauvegarde)
3. Le **saved RIP** (adresse de retour)

Controler l'adresse de retour = controler l'execution du programme.

**Ta mission :**

Creer un analyseur de vulnerabilites stack overflow qui :

1. **Identifie** les fonctions dangereuses dans du code C
2. **Calcule** la taille du buffer et l'offset vers saved RIP
3. **Genere** un pattern de Bruijn pour trouver l'offset
4. **Analyse** un crash dump pour determiner l'offset exact
5. **Cree** un PoC (Proof of Concept) qui controle RIP

**Fonctions dangereuses :**
| Fonction | Danger | Alternative securisee |
|----------|--------|----------------------|
| `gets()` | CRITIQUE - Aucune limite | `fgets()` |
| `strcpy()` | Pas de verification taille | `strncpy()` / `strlcpy()` |
| `strcat()` | Pas de verification taille | `strncat()` / `strlcat()` |
| `sprintf()` | Pas de limite | `snprintf()` |
| `scanf("%s")` | Pas de limite | `scanf("%Ns")` avec N |
| `vsprintf()` | Pas de limite | `vsnprintf()` |

**Layout de la stack :**
```
Adresses hautes
+------------------------+
|     Arguments          |
+------------------------+
|     Return Address     | <- saved RIP (cible!)
+------------------------+
|     Saved RBP          | <- saved frame pointer
+------------------------+
|   Variables locales    |
|      (buffer)          | <- debut de l'overflow
+------------------------+
Adresses basses
```

**Entree :**
```json
{
  "source_code": "void vuln() { char buf[64]; gets(buf); }",
  "crash_info": {
    "rip": "0x4141414141414141",
    "pattern_found": "Aa0Aa1Aa2Aa3...",
    "pattern_offset": null
  },
  "target": {
    "buffer_size": 64,
    "arch": "x86_64",
    "has_canary": false,
    "pie": false
  }
}
```

**Sortie :**
```json
{
  "vulnerabilities": [
    {
      "function": "gets",
      "line": 1,
      "severity": "critical",
      "description": "gets() has no bounds checking",
      "recommendation": "Use fgets() instead"
    }
  ],
  "stack_layout": {
    "buffer_start": 0,
    "buffer_size": 64,
    "saved_rbp_offset": 64,
    "saved_rip_offset": 72
  },
  "pattern": {
    "generated": "Aa0Aa1Aa2Aa3Aa4Aa5...",
    "length": 100
  },
  "crash_analysis": {
    "rip_value": "0x4141414141414141",
    "offset_found": 72,
    "pattern_chars": "AAAAAAAA"
  },
  "poc_payload": {
    "padding": "A" * 72,
    "new_rip": "\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42",
    "total_length": 80,
    "description": "Overwrites RIP with 0x4242424242424242"
  }
}
```

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
first_overflow.py - Analyseur de vulnerabilites stack overflow
"""

import json
import sys
import re
import string

# Fonctions dangereuses et leur severite
DANGEROUS_FUNCTIONS = {
    "gets": {"severity": "critical", "description": "No bounds checking at all"},
    "strcpy": {"severity": "high", "description": "No length limit"},
    "strcat": {"severity": "high", "description": "No length limit"},
    "sprintf": {"severity": "high", "description": "No output limit"},
    "scanf": {"severity": "medium", "description": "Dangerous with %s"},
    "vsprintf": {"severity": "high", "description": "No output limit"},
    "getwd": {"severity": "medium", "description": "May overflow PATH_MAX"}
}

def find_dangerous_functions(source_code: str) -> list:
    """
    Identifie les fonctions dangereuses dans le code source.

    Args:
        source_code: Code C a analyser

    Returns:
        Liste des vulnerabilites trouvees
    """
    pass

def calculate_stack_layout(buffer_size: int, arch: str = "x86_64") -> dict:
    """
    Calcule le layout de la stack et les offsets.

    Args:
        buffer_size: Taille du buffer vulnerable
        arch: Architecture (x86_64 ou x86)

    Returns:
        Dictionnaire avec les offsets
    """
    pass

def generate_debruijn_pattern(length: int) -> str:
    """
    Genere un pattern de Bruijn pour trouver les offsets.

    Args:
        length: Longueur du pattern a generer

    Returns:
        Pattern unique
    """
    pass

def find_pattern_offset(pattern: str, value: str) -> int:
    """
    Trouve l'offset d'une valeur dans un pattern de Bruijn.

    Args:
        pattern: Le pattern complet
        value: La valeur trouvee dans RIP (hex string ou bytes)

    Returns:
        Offset ou -1 si non trouve
    """
    pass

def analyze_crash(crash_info: dict, pattern: str = None) -> dict:
    """
    Analyse un crash dump pour determiner l'offset.

    Args:
        crash_info: Informations du crash (RIP, pattern)
        pattern: Pattern utilise (optionnel)

    Returns:
        Analyse du crash
    """
    pass

def generate_poc_payload(offset: int, target_address: int = 0x4242424242424242, arch: str = "x86_64") -> dict:
    """
    Genere un payload PoC pour controler RIP.

    Args:
        offset: Offset vers saved RIP
        target_address: Adresse cible
        arch: Architecture

    Returns:
        Payload complet
    """
    pass

def analyze_overflow(data: dict) -> dict:
    """
    Point d'entree principal pour l'analyse.

    Args:
        data: Donnees d'entree

    Returns:
        Analyse complete
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'histoire du buffer overflow

Le premier buffer overflow documente remonte a **1972** dans le rapport "Computer Security Technology Planning Study" de l'US Air Force. Mais c'est le **Morris Worm de 1988** qui a rendu cette technique celebre.

En 1996, Aleph One publie "Smashing the Stack for Fun and Profit" dans Phrack Magazine, qui reste le tutoriel de reference 30 ans plus tard!

### Pourquoi les buffers overflows existent encore ?

Malgre 35+ ans de connaissance du probleme :
- Le C et C++ restent utilises pour la performance
- Les anciennes bases de code sont difficiles a migrer
- Les developpeurs font des erreurs
- Les protections peuvent parfois etre contournees

En 2024, des CVEs de buffer overflow sont encore publiees regulierement!

### Le pattern de Bruijn

Nomme d'apres le mathematicien neerlandais **Nicolaas Govert de Bruijn**, ce pattern a la propriete que toute sous-sequence de n caracteres est unique. Cela permet d'identifier exactement quel offset correspond a une valeur trouvee en memoire.

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Pentester / Red Team Operator**

Les pentesters utilisent quotidiennement l'analyse de buffer overflow :
- **Bug bounty** : Trouver des vulnerabilites dans des logiciels
- **Audit de code** : Identifier les fonctions dangereuses
- **Developpement d'exploits** : Creer des PoC pour les rapports

**Cas d'usage concret :**

Lors d'un pentest d'application legacy :
1. Scanner le code avec des outils statiques (Coverity, CodeQL)
2. Identifier les fonctions `strcpy`, `gets`, etc.
3. Fuzzer l'application pour trouver les crashs
4. Analyser les crash dumps pour calculer les offsets
5. Developper un exploit fonctionnel
6. Documenter pour le rapport client

**Outils professionnels :**
- **checksec** : Verifier les protections
- **GDB + pwndbg/GEF** : Debugger et analyser
- **pwntools** : Framework d'exploitation Python
- **AFL++** : Fuzzer pour trouver les crashs

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
first_overflow.py  vulnerable_program.json

$ cat vulnerable_program.json
{"source_code": "void vuln() {\\n  char buf[64];\\n  gets(buf);\\n  printf(\\\"Input: %s\\\\n\\\", buf);\\n}", "crash_info": {"rip": "0x4130614139614138"}, "target": {"buffer_size": 64, "arch": "x86_64", "has_canary": false}}

$ python3 first_overflow.py vulnerable_program.json
{
  "vulnerabilities": [
    {
      "function": "gets",
      "severity": "critical",
      "description": "No bounds checking at all",
      "recommendation": "Use fgets() instead"
    }
  ],
  "stack_layout": {
    "buffer_start": 0,
    "buffer_size": 64,
    "saved_rbp_offset": 64,
    "saved_rip_offset": 72
  },
  "pattern": {
    "generated": "Aa0Aa1Aa2...",
    "length": 100
  },
  "crash_analysis": {
    "rip_value": "0x4130614139614138",
    "offset_found": 72,
    "pattern_chars": "8aA9aA0a"
  },
  "poc_payload": {
    "padding": 72,
    "new_rip": "0x4242424242424242",
    "total_length": 80
  }
}

$ # Generer juste un pattern
$ echo '{"generate_pattern": 200}' | python3 first_overflow.py -
{"pattern": "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"}
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★☆☆☆ (7/10)

**Recompense :**
XP x2

### 3.1.1 Consigne Bonus

**Extension "Fuzzer basique" :**

1. **Implementer un fuzzer** qui genere des inputs de tailles croissantes
2. **Detecter les patterns de crash** (SIGSEGV, SIGBUS, etc.)
3. **Analyser automatiquement** les crashs pour trouver les offsets
4. **Supporter les protections** : Detecter si canary/PIE/NX actifs

### 3.1.2 Prototype Bonus

```python
def generate_fuzz_inputs(min_size: int, max_size: int, step: int) -> list:
    """
    Genere une liste d'inputs pour fuzzing.
    """
    pass

def detect_protections(binary_info: dict) -> dict:
    """
    Detecte les protections actives.
    """
    pass

def automated_crash_analysis(crashes: list) -> dict:
    """
    Analyse automatique de multiples crashs.
    """
    pass
```

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| detect_gets | source avec gets() | severity=critical | 10 |
| detect_strcpy | source avec strcpy() | severity=high | 10 |
| detect_multiple | gets + strcpy | 2 vulnerabilites | 10 |
| stack_layout_64 | buf=64, x86_64 | rip_offset=72 | 15 |
| stack_layout_32 | buf=64, x86 | rip_offset=68 | 10 |
| pattern_gen | length=100 | pattern unique | 10 |
| pattern_find | pattern + offset 72 | offset=72 | 15 |
| poc_gen | offset=72 | payload valide | 10 |
| full_analysis | code complet | analyse complete | 10 |

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
first_overflow.py - Solution de reference
"""

import json
import sys
import re
import string

DANGEROUS_FUNCTIONS = {
    "gets": {"severity": "critical", "description": "No bounds checking at all", "recommendation": "Use fgets() instead"},
    "strcpy": {"severity": "high", "description": "No length limit", "recommendation": "Use strncpy() or strlcpy()"},
    "strcat": {"severity": "high", "description": "No length limit", "recommendation": "Use strncat() or strlcat()"},
    "sprintf": {"severity": "high", "description": "No output limit", "recommendation": "Use snprintf()"},
    "scanf": {"severity": "medium", "description": "Dangerous with %s format", "recommendation": "Use scanf(\"%Ns\", ...) with limit"},
    "vsprintf": {"severity": "high", "description": "No output limit", "recommendation": "Use vsnprintf()"},
    "getwd": {"severity": "medium", "description": "May overflow PATH_MAX buffer", "recommendation": "Use getcwd()"}
}

def find_dangerous_functions(source_code: str) -> list:
    """Identifie les fonctions dangereuses dans le code source."""
    vulnerabilities = []

    for func_name, info in DANGEROUS_FUNCTIONS.items():
        # Pattern pour trouver les appels de fonction
        # Gere: gets(buf), gets( buf ), etc.
        pattern = rf'\b{func_name}\s*\('

        for match in re.finditer(pattern, source_code):
            # Trouver le numero de ligne
            line_num = source_code[:match.start()].count('\\n') + 1

            vulnerabilities.append({
                "function": func_name,
                "line": line_num,
                "position": match.start(),
                "severity": info["severity"],
                "description": info["description"],
                "recommendation": info["recommendation"]
            })

    # Trier par position dans le code
    vulnerabilities.sort(key=lambda x: x["position"])

    return vulnerabilities

def calculate_stack_layout(buffer_size: int, arch: str = "x86_64") -> dict:
    """Calcule le layout de la stack et les offsets."""
    if arch == "x86_64":
        word_size = 8
    else:  # x86
        word_size = 4

    # Alignement sur la taille du mot
    # Le buffer peut etre suivi de padding pour alignement
    aligned_buffer = buffer_size
    if buffer_size % word_size != 0:
        aligned_buffer = buffer_size + (word_size - buffer_size % word_size)

    # Layout: [buffer][padding?][saved_rbp][saved_rip]
    saved_rbp_offset = aligned_buffer
    saved_rip_offset = saved_rbp_offset + word_size

    return {
        "buffer_start": 0,
        "buffer_size": buffer_size,
        "buffer_aligned": aligned_buffer,
        "saved_rbp_offset": saved_rbp_offset,
        "saved_rip_offset": saved_rip_offset,
        "word_size": word_size,
        "architecture": arch
    }

def generate_debruijn_pattern(length: int, n: int = 4) -> str:
    """
    Genere un pattern de Bruijn de longueur specifiee.
    Utilise un alphabet de lettres majuscules, minuscules et chiffres.
    """
    # Alphabet: Aa0, Ba1, Ca2, etc.
    # Cree des sequences uniques de n caracteres
    alphabet = string.ascii_uppercase + string.ascii_lowercase + string.digits

    # Generateur de sequence de Bruijn simplifie
    # On cree des triplets uniques: Aa0, Aa1, ..., Aa9, Ab0, ...
    pattern = []

    for upper in string.ascii_uppercase:
        for lower in string.ascii_lowercase:
            for digit in string.digits:
                pattern.append(upper + lower + digit)
                if len(''.join(pattern)) >= length:
                    return ''.join(pattern)[:length]

    return ''.join(pattern)[:length]

def find_pattern_offset(pattern: str, value: str) -> int:
    """Trouve l'offset d'une valeur dans un pattern de Bruijn."""
    # Convertir la valeur hex en bytes puis en string
    if value.startswith('0x'):
        value = value[2:]

    # Convertir hex en bytes (little endian)
    try:
        value_bytes = bytes.fromhex(value)
        # Little endian: inverser les bytes
        value_str = value_bytes[::-1].decode('ascii', errors='ignore')
    except:
        value_str = value

    # Chercher dans le pattern
    # On cherche des sous-chaines de 4 ou 8 caracteres
    for length in [8, 4]:
        if len(value_str) >= length:
            search_str = value_str[:length]
            offset = pattern.find(search_str)
            if offset != -1:
                return offset

    # Essayer aussi la version non-inversee
    try:
        value_str_be = bytes.fromhex(value).decode('ascii', errors='ignore')
        for length in [8, 4]:
            if len(value_str_be) >= length:
                search_str = value_str_be[:length]
                offset = pattern.find(search_str)
                if offset != -1:
                    return offset
    except:
        pass

    return -1

def analyze_crash(crash_info: dict, pattern: str = None) -> dict:
    """Analyse un crash dump pour determiner l'offset."""
    rip_value = crash_info.get("rip", "0x0")

    result = {
        "rip_value": rip_value,
        "offset_found": -1,
        "pattern_chars": None,
        "analysis": []
    }

    # Si c'est une adresse avec des 'A' (0x41)
    if '41414141' in rip_value.replace('0x', ''):
        result["analysis"].append("RIP contains 'AAAA' pattern - classic overflow")

    # Si un pattern est fourni, chercher l'offset
    if pattern:
        offset = find_pattern_offset(pattern, rip_value)
        if offset != -1:
            result["offset_found"] = offset
            result["pattern_chars"] = pattern[offset:offset+8] if len(pattern) > offset+8 else pattern[offset:]
            result["analysis"].append(f"Pattern found at offset {offset}")

    # Analyser la valeur RIP
    try:
        rip_int = int(rip_value, 16)
        # Verifier si c'est une adresse valide (dans les ranges typiques)
        if 0x400000 <= rip_int <= 0x7fffffffffff:
            result["analysis"].append("RIP looks like a valid address")
        else:
            result["analysis"].append("RIP is likely corrupted/controlled")
    except:
        pass

    return result

def generate_poc_payload(offset: int, target_address: int = 0x4242424242424242, arch: str = "x86_64") -> dict:
    """Genere un payload PoC pour controler RIP."""
    if arch == "x86_64":
        word_size = 8
        pack_format = '<Q'  # Little-endian unsigned long long
    else:
        word_size = 4
        pack_format = '<I'  # Little-endian unsigned int
        target_address = target_address & 0xFFFFFFFF

    # Importer struct pour le packing
    import struct

    # Creer le padding
    padding = b'A' * offset

    # Packer l'adresse cible
    target_bytes = struct.pack(pack_format, target_address)

    # Payload complet
    payload = padding + target_bytes

    return {
        "padding_char": "A",
        "padding_length": offset,
        "target_address": hex(target_address),
        "target_bytes": target_bytes.hex(),
        "total_length": len(payload),
        "payload_hex": payload.hex(),
        "payload_repr": f"b'A' * {offset} + {target_bytes!r}",
        "description": f"Overwrites RIP with {hex(target_address)}"
    }

def analyze_overflow(data: dict) -> dict:
    """Point d'entree principal pour l'analyse."""
    result = {}

    # Si on demande juste un pattern
    if "generate_pattern" in data:
        length = data["generate_pattern"]
        result["pattern"] = generate_debruijn_pattern(length)
        return result

    # Analyse du code source
    source_code = data.get("source_code", "")
    if source_code:
        result["vulnerabilities"] = find_dangerous_functions(source_code)

    # Calcul du stack layout
    target = data.get("target", {})
    buffer_size = target.get("buffer_size", 64)
    arch = target.get("arch", "x86_64")

    result["stack_layout"] = calculate_stack_layout(buffer_size, arch)

    # Generation du pattern
    pattern_length = max(100, result["stack_layout"]["saved_rip_offset"] + 32)
    pattern = generate_debruijn_pattern(pattern_length)
    result["pattern"] = {
        "generated": pattern,
        "length": len(pattern)
    }

    # Analyse du crash
    crash_info = data.get("crash_info", {})
    if crash_info:
        result["crash_analysis"] = analyze_crash(crash_info, pattern)

        # Si on a trouve l'offset, generer le PoC
        if result["crash_analysis"]["offset_found"] != -1:
            offset = result["crash_analysis"]["offset_found"]
        else:
            # Utiliser l'offset calcule
            offset = result["stack_layout"]["saved_rip_offset"]

        result["poc_payload"] = generate_poc_payload(offset, arch=arch)

    # Verifier les protections
    has_canary = target.get("has_canary", False)
    has_pie = target.get("pie", False)
    has_nx = target.get("nx", True)

    result["protections"] = {
        "stack_canary": has_canary,
        "pie": has_pie,
        "nx": has_nx,
        "exploitable": not has_canary,
        "notes": []
    }

    if has_canary:
        result["protections"]["notes"].append("Stack canary present - need canary leak first")
    if has_pie:
        result["protections"]["notes"].append("PIE enabled - need address leak for reliable exploitation")
    if has_nx:
        result["protections"]["notes"].append("NX enabled - cannot execute shellcode on stack, need ROP/ret2libc")

    return result

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: first_overflow.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = analyze_overflow(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "first_overflow",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 1,
  "tags": ["stack", "overflow", "exploitation", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_overflow",
    "prototype": "def analyze_overflow(data: dict) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "gets_detection",
        "args": [{"source_code": "void f() { char b[64]; gets(b); }"}],
        "check": "len(result['vulnerabilities']) > 0 and result['vulnerabilities'][0]['severity'] == 'critical'"
      },
      {
        "name": "stack_layout_64",
        "args": [{"target": {"buffer_size": 64, "arch": "x86_64"}}],
        "check": "result['stack_layout']['saved_rip_offset'] == 72"
      },
      {
        "name": "pattern_generation",
        "args": [{"generate_pattern": 100}],
        "check": "'pattern' in result and len(result['pattern']) == 100"
      }
    ]
  }
}
```

### 4.10 Solutions Mutantes

```python
# Mutant A: Mauvais calcul d'offset pour x86_64
def calculate_stack_layout_mutant_a(buffer_size, arch):
    # ERREUR: Oublie le saved RBP
    return {"saved_rip_offset": buffer_size}  # Devrait etre buffer_size + 8

# Pourquoi c'est faux: Il y a saved RBP entre le buffer et saved RIP
```

```python
# Mutant B: Pattern non-unique
def generate_pattern_mutant_b(length):
    return "A" * length  # Pas un pattern de Bruijn!

# Pourquoi c'est faux: On ne peut pas trouver l'offset avec des 'A' repetes
```

```python
# Mutant C: Ne detecte pas strcpy
def find_dangerous_mutant_c(source):
    if "gets" in source:
        return [{"function": "gets"}]
    return []  # Manque strcpy, strcat, etc.!

# Pourquoi c'est faux: Toutes les fonctions dangereuses doivent etre detectees
```

```python
# Mutant D: Mauvais endianness pour l'adresse
def generate_poc_mutant_d(offset, target):
    import struct
    # ERREUR: Big endian au lieu de little endian
    return struct.pack('>Q', target)  # Devrait etre '<Q'

# Pourquoi c'est faux: x86/x64 est little-endian
```

```python
# Mutant E: Offset mal calcule pour x86
def calculate_stack_layout_mutant_e(buffer_size, arch):
    if arch == "x86":
        return {"saved_rip_offset": buffer_size + 8}  # ERREUR: 8 au lieu de 4

# Pourquoi c'est faux: Sur x86, les pointeurs font 4 bytes, pas 8
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

1. **Vulnerabilites classiques** : Identifier les fonctions dangereuses
2. **Layout de la stack** : Comprendre ou sont les donnees
3. **Patterns de Bruijn** : Technique pour trouver les offsets
4. **Analyse de crash** : Interpreter les crash dumps
5. **Generation de payloads** : Creer des PoC basiques

### 5.2 LDA - Traduction litterale

```
FONCTION analyze_overflow(data)
DEBUT
    DECLARER result COMME DICTIONNAIRE

    SI source_code EXISTE DANS data ALORS
        POUR CHAQUE fonction_dangereuse FAIRE
            SI fonction_dangereuse DANS source_code ALORS
                AJOUTER vulnerabilite A result
            FIN SI
        FIN POUR
    FIN SI

    CALCULER stack_layout AVEC buffer_size ET arch
    GENERER pattern de Bruijn

    SI crash_info EXISTE ALORS
        ANALYSER crash pour trouver offset
        GENERER poc_payload
    FIN SI

    RETOURNER result
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
    BUFFER OVERFLOW - Anatomie
    ==========================

    AVANT OVERFLOW:
    +------------------------+ <- Adresses hautes
    |   Return Address       |
    |   (saved RIP)          | <- Ou l'execution retourne
    +------------------------+
    |   Saved Frame Pointer  |
    |   (saved RBP)          | <- Ancien base pointer
    +------------------------+
    |                        |
    |   Buffer local         |
    |   char buf[64]         | <- 64 bytes reserves
    |                        |
    +------------------------+ <- Adresses basses (RSP)


    APRES OVERFLOW (input > 64 bytes):
    +------------------------+
    | 0x4242424242424242     | <- RIP ECRASE! On controle l'execution
    +------------------------+
    | AAAAAAAAAAAAAAAA       | <- RBP ecrase
    +------------------------+
    | AAAAAAAAAAAAAAAAA      |
    | AAAAAAAAAAAAAAAAA      | <- Buffer rempli de 'A'
    | AAAAAAAAAAAAAAAAA      |
    | AAAAAAAAAAAAAAAAA      |
    +------------------------+

    INPUT: [64 bytes padding] + [8 bytes RBP] + [8 bytes new RIP]
           AAAA...............AAA + AAAAAAAA + 0x424242...


    PATTERN DE BRUIJN:
    ==================

    Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7...
    |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|
     0  3  6  9 12 15 18 21 24 27 30 33 36 39 42 45 48 51

    Chaque sequence de 4 caracteres est UNIQUE.
    Si RIP = 0x41366141 = "Aa6A" -> offset = 18

    Crash: RIP = 0x4130614139614138 = "8aA9aA0a" (reversed)
           -> Chercher dans pattern -> offset = 72!


    FONCTIONS DANGEREUSES:
    ======================

    CRITIQUE:
    +--------+     +----------------+
    | gets() | --> | Pas de limite! |
    +--------+     | Buffer de 64?  |
                   | Input de 1000? |
                   | OVERFLOW!      |
                   +----------------+

    SAFE ALTERNATIVE:
    +-------------------+     +------------------+
    | fgets(buf, 64,    | --> | Maximum 63 chars |
    |       stdin)      |     | + null terminator|
    +-------------------+     | = SAFE           |
                              +------------------+
```

### 5.4 Les pieges en detail

#### Piege 1 : Alignement du buffer

```python
# MAUVAIS: Ignore l'alignement
def calc_offset(buf_size):
    return buf_size + 8  # Parfois faux!

# BON: Considere l'alignement
def calc_offset(buf_size, word_size=8):
    aligned = buf_size
    if buf_size % word_size != 0:
        aligned = buf_size + (word_size - buf_size % word_size)
    return aligned + word_size  # +saved_rbp
```

#### Piege 2 : Little-endian vs Big-endian

```python
# MAUVAIS
addr_bytes = bytes([0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48])
# -> 0x4142434445464748 en memoire

# BON (little-endian)
addr_bytes = struct.pack('<Q', 0x4847464544434241)
# -> Bytes inverses en memoire, mais valeur correcte quand lue
```

#### Piege 3 : Prototype realiste du stack

Le compilateur peut ajouter du padding supplementaire :
- Alignement SSE (16 bytes)
- Variables entre le buffer et RBP
- Red zone sur x86_64 (128 bytes sous RSP)

### 5.5 Cours Complet

#### 5.5.1 Pourquoi les buffer overflows fonctionnent

En C, il n'y a pas de verification automatique des bornes :

```c
void vulnerable() {
    char buffer[64];
    gets(buffer);  // Lit jusqu'a newline, AUCUNE limite!
}
```

L'utilisateur peut entrer 1000 caracteres - le programme les ecrit tous en memoire, ecrasant tout ce qui suit le buffer.

#### 5.5.2 Le call stack en detail

```
main() appelle vuln():

1. CALL vuln
   - PUSH return_address (RIP de main)
   - JMP vuln

2. Prologue de vuln:
   - PUSH RBP           (sauvegarder l'ancien frame pointer)
   - MOV RBP, RSP       (nouveau frame = sommet de pile)
   - SUB RSP, 64        (reserver 64 bytes pour buffer)

3. ...execution...

4. Epilogue de vuln:
   - LEAVE              (MOV RSP, RBP; POP RBP)
   - RET                (POP RIP; JMP RIP) <- Si RIP corrompu = REDIRECTION!
```

#### 5.5.3 Protections modernes

| Protection | Description | Bypass |
|------------|-------------|--------|
| **Stack Canary** | Valeur aleatoire avant RIP | Leak via format string ou autre vuln |
| **ASLR** | Adresses randomisees | Leak d'adresse, bruteforce 32-bit |
| **NX/DEP** | Stack non-executable | ROP, ret2libc |
| **PIE** | Code randomise | Leak d'adresse code |

### 5.8 Mnemotechniques

#### MEME : "Le Debordement de Baignoire"

```
BUFFER = Baignoire
DONNEES = Eau
SAVED RIP = Tapis de bain

      Robinet (input)
          |
          v
    +===========+ <- Bord de la baignoire (limite buffer)
    |           |
    |   Eau     |
    |  (data)   |
    +===========+
    |///////////| <- Tapis de bain (saved RIP)
    +===========+

    Si tu ouvres le robinet trop fort:
    - L'eau deborde
    - Le tapis est trempe (RIP ecrase)
    - Tu glisses et tu tombes ou tu veux (code execution!)

    MORALE: Toujours verifier la taille avant de remplir!
```

### 5.9 Applications pratiques

1. **Audit de code legacy** : Scanner les bases de code C/C++ anciennes
2. **CTF challenges** : Base de nombreux challenges pwn
3. **Bug bounty** : Trouver des vulns dans les logiciels
4. **Developpement securise** : Savoir quoi eviter

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Oublier saved RBP | Offset faux de 8 bytes | Toujours compter RBP |
| 2 | Mauvais endianness | Adresse inversee | Utiliser struct.pack('<Q') |
| 3 | Ignorer l'alignement | Offset imprecis | Aligner sur word_size |
| 4 | Pattern non-unique | Offset impossible | Utiliser de Bruijn |
| 5 | Arch x86 vs x64 | Tailles differentes | Adapter word_size |

---

## SECTION 7 : QCM

### Question 1
**Quelle fonction C est la plus dangereuse pour les buffer overflows ?**

A) fgets()
B) gets()
C) strncpy()
D) snprintf()
E) read()

**Reponse : B**

---

### Question 2
**Sur x86_64, quelle est la taille de saved RBP et saved RIP ?**

A) 4 bytes chacun
B) 8 bytes chacun
C) 4 bytes pour RBP, 8 bytes pour RIP
D) 16 bytes chacun
E) Variable selon le compilateur

**Reponse : B**

---

### Question 3
**A quoi sert un pattern de Bruijn ?**

A) Chiffrer le payload
B) Trouver l'offset exact vers RIP
C) Bypasser ASLR
D) Generer du shellcode
E) Compresser les donnees

**Reponse : B**

---

### Question 4
**Quel est l'ordre des elements sur la stack (de bas en haut) ?**

A) RIP, RBP, buffer, args
B) buffer, RBP, RIP, args
C) args, buffer, RBP, RIP
D) RBP, buffer, RIP, args
E) buffer, args, RBP, RIP

**Reponse : B** (du bas vers le haut: buffer -> RBP -> RIP -> args)

---

### Question 5
**Pourquoi utilise-t-on le little-endian pour les adresses sur x86/x64 ?**

A) C'est plus rapide
B) C'est l'architecture native de x86/x64
C) Pour eviter la detection
D) Pour compresser les donnees
E) Par convention arbitraire

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | 5/10 |
| **Temps estime** | 45 min |
| **XP Base** | 150 |
| **XP Bonus** | x2 (300 total) |
| **Concepts cles** | Buffer overflow, Stack layout, de Bruijn, Dangerous functions |
| **Langage** | Python 3.12 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.5-a-first-overflow",
    "generated_at": "2026-01-16 16:00:00",

    "metadata": {
      "exercise_id": "3.4.5-a",
      "exercise_name": "first_overflow",
      "module": "3.4.5",
      "module_name": "Stack Exploitation",
      "concept": "a",
      "concept_name": "Principes du stack buffer overflow",
      "type": "code",
      "tier": 1,
      "difficulty": 5,
      "language": "python",
      "duration_minutes": 45,
      "xp_base": 150,
      "xp_bonus_multiplier": 2,
      "tags": ["stack", "overflow", "exploitation", "buffer", "pwn"]
    }
  }
}
```
