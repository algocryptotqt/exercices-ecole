# Exercice 3.4.1-b : asm_emulator

**Module :**
3.4.1 â€” x86-64 Assembly Fundamentals

**Concept :**
b â€” Instructions de donnÃ©es et modes d'adressage

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Python 3.12

**PrÃ©requis :**
- Exercice 3.4.1-a (register_decoder)
- ComprÃ©hension des registres x86-64
- Bases d'assembleur

**Domaines :**
CPU, ASM, Encodage

**DurÃ©e estimÃ©e :**
60 min

**XP Base :**
200

**ComplexitÃ© :**
T4 O(nÃ—m) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`asm_emulator.py`

**Fonctions autorisÃ©es :**
- `json` (module standard)
- `re` (expressions rÃ©guliÃ¨res)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- Unicorn Engine
- Capstone
- Keystone
- Tout Ã©mulateur externe

### 1.2 Consigne

#### 2.4.1 ğŸ® Contexte Culturel â€” "Inception"

*"You mustn't be afraid to dream a little bigger, darling."*

Dans **Inception**, Dom Cobb et son Ã©quipe construisent des rÃªves Ã  l'intÃ©rieur de rÃªves, chaque niveau ayant ses propres rÃ¨gles physiques. Ton Ã©mulateur est comme l'**Architecte** du film : il crÃ©e un monde virtuel oÃ¹ les instructions assembleur s'exÃ©cutent selon des rÃ¨gles prÃ©cises.

Chaque instruction est comme un Ã©lÃ©ment du rÃªve :
- **MOV** : Transporte une idÃ©e d'un endroit Ã  un autre
- **ADD** : Combine deux pensÃ©es
- **XOR** : MÃ©lange deux rÃ©alitÃ©s de faÃ§on rÃ©versible

Comme Cobb qui doit comprendre chaque niveau du rÃªve pour naviguer, tu dois comprendre chaque instruction pour tracer l'exÃ©cution.

#### 2.4.2 Ã‰noncÃ© AcadÃ©mique

Un Ã©mulateur de processeur simule l'exÃ©cution d'instructions sur une architecture donnÃ©e. Cette technique est fondamentale en :
- **Analyse de malware** : ExÃ©cuter du code malveillant en environnement contrÃ´lÃ©
- **Debugging** : Comprendre l'Ã©tat du programme instruction par instruction
- **DÃ©veloppement d'exploits** : Tester des payloads sans risque

**Ta mission :**

ImplÃ©menter un Ã©mulateur x86-64 simplifiÃ© qui :

1. **Parse** des instructions assembleur au format Intel
2. **Maintient** l'Ã©tat des registres (RAX, RBX, RCX, RDX, RSI, RDI, R8-R15)
3. **Simule** une mÃ©moire de 4 KB
4. **ExÃ©cute** les instructions pas Ã  pas
5. **Retourne** l'Ã©tat final

**Instructions Ã  supporter :**

| Instruction | Syntaxe | Description |
|-------------|---------|-------------|
| MOV | `mov dest, src` | Copie src vers dest |
| LEA | `lea dest, [addr]` | Charge l'adresse effective |
| PUSH | `push src` | Empile src |
| POP | `pop dest` | DÃ©pile vers dest |
| ADD | `add dest, src` | dest = dest + src |
| SUB | `sub dest, src` | dest = dest - src |
| INC | `inc dest` | dest = dest + 1 |
| DEC | `dec dest` | dest = dest - 1 |
| AND | `and dest, src` | dest = dest & src |
| OR | `or dest, src` | dest = dest \| src |
| XOR | `xor dest, src` | dest = dest ^ src |
| NOT | `not dest` | dest = ~dest |
| SHL | `shl dest, count` | Shift left |
| SHR | `shr dest, count` | Shift right (logical) |
| NOP | `nop` | Aucune opÃ©ration |

**Modes d'adressage Ã  supporter :**
- **ImmÃ©diat** : `mov rax, 0x1337`
- **Registre** : `mov rax, rbx`
- **MÃ©moire directe** : `mov rax, [0x1000]`
- **MÃ©moire base** : `mov rax, [rbx]`
- **MÃ©moire base+offset** : `mov rax, [rbx+8]`

**EntrÃ©e :**
```json
{
  "instructions": ["mov rax, 0x1337", "mov rbx, rax", "add rbx, 0x10"],
  "initial_state": {
    "registers": {"RAX": 0, "RBX": 0, ...},
    "memory": {"0x1000": 255, ...}
  }
}
```

**Sortie :**
```json
{
  "final_state": {
    "registers": {"RAX": 4919, "RBX": 4935, ...},
    "memory": {...}
  },
  "execution_trace": [
    {"instruction": "mov rax, 0x1337", "changes": {"RAX": 4919}}
  ]
}
```

**Contraintes :**
- Registres 64 bits (valeurs 0 Ã  2^64-1)
- MÃ©moire 4 KB (adresses 0x0 Ã  0xFFF)
- Les accÃ¨s mÃ©moire hors limites retournent 0
- Format Intel (destination avant source)

**Exemples :**

| Instructions | Ã‰tat final RAX |
|-------------|----------------|
| `mov rax, 0x10` | 16 |
| `mov rax, 0x10; add rax, 0x5` | 21 |
| `mov rax, 0xff; xor rax, 0xff` | 0 |
| `mov rax, 1; shl rax, 4` | 16 |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
asm_emulator.py - Ã‰mulateur x86-64 simplifiÃ©
"""

import json
import sys
import re

class X64Emulator:
    """Ã‰mulateur x86-64 simplifiÃ©."""

    REGISTERS = ['RAX', 'RBX', 'RCX', 'RDX', 'RSI', 'RDI',
                 'RSP', 'RBP', 'R8', 'R9', 'R10', 'R11',
                 'R12', 'R13', 'R14', 'R15']

    def __init__(self, initial_state=None):
        """Initialise l'Ã©mulateur."""
        pass

    def parse_operand(self, operand: str) -> tuple:
        """Parse un opÃ©rande et retourne (type, value)."""
        pass

    def get_value(self, operand: str) -> int:
        """RÃ©cupÃ¨re la valeur d'un opÃ©rande."""
        pass

    def set_value(self, operand: str, value: int):
        """DÃ©finit la valeur d'un opÃ©rande."""
        pass

    def execute_instruction(self, instruction: str) -> dict:
        """ExÃ©cute une instruction et retourne les changements."""
        pass

    def run(self, instructions: list) -> dict:
        """ExÃ©cute une liste d'instructions."""
        pass

def main():
    """Point d'entrÃ©e principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### Format Intel vs AT&T

Il existe deux syntaxes pour l'assembleur x86 :

**Intel (Windows, NASM, MASM) :**
```asm
mov rax, rbx    ; destination, source
add rax, 10     ; rax = rax + 10
```

**AT&T (GCC, Linux traditionnel) :**
```asm
movq %rbx, %rax    ; source, destination (inversÃ©!)
addq $10, %rax     ; prÃ©fixes % et $
```

Nous utilisons le format Intel car il est plus intuitif et correspond Ã  la documentation Intel.

### L'instruction XOR pour le zÃ©ro

`xor rax, rax` est la faÃ§on la plus efficace de mettre un registre Ã  zÃ©ro :
- **1 byte** d'encodage (vs 5+ pour `mov rax, 0`)
- **Plus rapide** (le CPU reconnaÃ®t ce pattern)
- **Pas de dÃ©pendance** sur l'ancienne valeur

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

**MÃ©tier : DÃ©veloppeur d'outils de sÃ©curitÃ©**

Les Ã©mulateurs comme Unicorn Engine sont utilisÃ©s quotidiennement pour :
- **Unpacking de malware** : ExÃ©cuter du code obfusquÃ© pour le dÃ©chiffrer
- **Fuzzing** : Tester des inputs sans risquer un crash rÃ©el
- **Analyse symbolique** : Combiner Ã©mulation et rÃ©solution de contraintes

**Cas d'usage concret :**
Chez FireEye/Trellix, les analystes utilisent des Ã©mulateurs pour :
- ExÃ©cuter du shellcode capturÃ© sans risque
- DÃ©terminer les syscalls effectuÃ©s par un malware
- Contourner les protections anti-VM

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
asm_emulator.py  test_input.json

$ cat test_input.json
{"instructions": ["mov rax, 0x1337", "mov rbx, rax", "add rbx, 0x10", "shl rbx, 4", "xor rax, rbx"], "initial_state": {"registers": {}, "memory": {}}}

$ python3 asm_emulator.py test_input.json
{"final_state": {"registers": {"RAX": 78704, "RBX": 79152, "RCX": 0, "RDX": 0, "RSI": 0, "RDI": 0, "RSP": 0, "RBP": 0, "R8": 0, "R9": 0, "R10": 0, "R11": 0, "R12": 0, "R13": 0, "R14": 0, "R15": 0}, "memory": {}}, "execution_trace": [{"instruction": "mov rax, 0x1337", "changes": {"RAX": 4919}}, {"instruction": "mov rbx, rax", "changes": {"RBX": 4919}}, {"instruction": "add rbx, 0x10", "changes": {"RBX": 4935}}, {"instruction": "shl rbx, 4", "changes": {"RBX": 78960}}, {"instruction": "xor rax, rbx", "changes": {"RAX": 78704}}]}
```

---

## ğŸ”¥ SECTION 3.1 : BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(nÃ—m)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
CPU, ASM, Mem, MD

### 3.1.1 Consigne Bonus

**Extension "Full ALU" :**

Ajouter le support pour :

1. **Instructions de multiplication/division** :
   - `imul dest, src` (multiplication signÃ©e)
   - `idiv src` (RAX / src, quotient dans RAX, reste dans RDX)

2. **Instructions conditionnelles** :
   - `cmp op1, op2` (met Ã  jour les flags)
   - Gestion des flags : ZF, SF, CF, OF

3. **Instructions de rotation** :
   - `rol dest, count` (rotate left)
   - `ror dest, count` (rotate right)

4. **Adressage avancÃ©** :
   - `[base + index*scale + offset]`
   - Ex: `mov rax, [rbx + rcx*8 + 16]`

### 3.1.2 Prototype Bonus

```python
class X64EmulatorAdvanced(X64Emulator):
    """Ã‰mulateur avancÃ© avec flags et instructions supplÃ©mentaires."""

    def __init__(self, initial_state=None):
        super().__init__(initial_state)
        self.flags = {'ZF': False, 'SF': False, 'CF': False, 'OF': False}

    def update_flags(self, result: int, operation: str):
        """Met Ã  jour les flags aprÃ¨s une opÃ©ration."""
        pass

    def execute_cmp(self, op1: str, op2: str):
        """ExÃ©cute une comparaison."""
        pass
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Instructions | 15 | 20+ |
| Flags | Non gÃ©rÃ©s | ZF, SF, CF, OF |
| Adressage | Base+offset | SIB complet |
| Multiplication | Non | IMUL |
| Division | Non | IDIV |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| mov_imm | `mov rax, 0x1337` | RAX=4919 | 5 |
| mov_reg | `mov rax, 0x10; mov rbx, rax` | RBX=16 | 5 |
| add_basic | `mov rax, 10; add rax, 5` | RAX=15 | 5 |
| sub_basic | `mov rax, 10; sub rax, 3` | RAX=7 | 5 |
| xor_zero | `mov rax, 0xff; xor rax, rax` | RAX=0 | 5 |
| shl_basic | `mov rax, 1; shl rax, 4` | RAX=16 | 5 |
| shr_basic | `mov rax, 16; shr rax, 2` | RAX=4 | 5 |
| and_mask | `mov rax, 0xff; and rax, 0x0f` | RAX=15 | 5 |
| or_combine | `mov rax, 0xf0; or rax, 0x0f` | RAX=255 | 5 |
| not_invert | `mov rax, 0; not rax` | RAX=0xFFFFFFFFFFFFFFFF | 10 |
| inc_dec | `mov rax, 10; inc rax; dec rax` | RAX=10 | 5 |
| memory_write | `mov [0x100], rax` avec RAX=42 | mem[0x100]=42 | 10 |
| memory_read | `mov rax, [0x100]` avec mem[0x100]=99 | RAX=99 | 10 |
| push_pop | `mov rax, 42; push rax; pop rbx` | RBX=42 | 10 |
| complex_chain | SÃ©quence de 10+ instructions | Ã‰tat correct | 15 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de rÃ©fÃ©rence

```python
#!/usr/bin/env python3
"""
asm_emulator.py - Solution de rÃ©fÃ©rence
"""

import json
import sys
import re

class X64Emulator:
    """Ã‰mulateur x86-64 simplifiÃ©."""

    REGISTERS = ['RAX', 'RBX', 'RCX', 'RDX', 'RSI', 'RDI',
                 'RSP', 'RBP', 'R8', 'R9', 'R10', 'R11',
                 'R12', 'R13', 'R14', 'R15']

    MEMORY_SIZE = 0x1000  # 4 KB

    def __init__(self, initial_state=None):
        """Initialise l'Ã©mulateur."""
        self.registers = {reg: 0 for reg in self.REGISTERS}
        self.memory = {}

        if initial_state:
            for reg, val in initial_state.get('registers', {}).items():
                if reg.upper() in self.registers:
                    self.registers[reg.upper()] = val
            for addr, val in initial_state.get('memory', {}).items():
                addr_int = int(addr, 16) if isinstance(addr, str) else addr
                self.memory[addr_int] = val

        # Initialiser RSP Ã  une valeur raisonnable
        if self.registers['RSP'] == 0:
            self.registers['RSP'] = 0xF00

    def parse_hex(self, value: str) -> int:
        """Parse une valeur hexadÃ©cimale ou dÃ©cimale."""
        value = value.strip()
        if value.lower().startswith('0x'):
            return int(value, 16)
        if value.startswith('-'):
            return int(value)
        try:
            return int(value, 16)
        except ValueError:
            return int(value)

    def parse_operand(self, operand: str) -> tuple:
        """
        Parse un opÃ©rande et retourne (type, value).
        Types: 'reg', 'imm', 'mem_direct', 'mem_reg', 'mem_reg_offset'
        """
        operand = operand.strip()

        # Registre
        if operand.upper() in self.REGISTERS:
            return ('reg', operand.upper())

        # MÃ©moire
        mem_match = re.match(r'\[(.+)\]', operand)
        if mem_match:
            inner = mem_match.group(1).strip()

            # MÃ©moire directe: [0x1000]
            if re.match(r'^0x[0-9a-fA-F]+$|^\d+$', inner):
                return ('mem_direct', self.parse_hex(inner))

            # MÃ©moire base + offset: [rbx+8] ou [rbx-8]
            offset_match = re.match(r'(\w+)\s*([+-])\s*(\d+|0x[0-9a-fA-F]+)', inner)
            if offset_match:
                base_reg = offset_match.group(1).upper()
                sign = 1 if offset_match.group(2) == '+' else -1
                offset = self.parse_hex(offset_match.group(3))
                return ('mem_reg_offset', (base_reg, sign * offset))

            # MÃ©moire base seule: [rbx]
            if inner.upper() in self.REGISTERS:
                return ('mem_reg', inner.upper())

        # ImmÃ©diat
        try:
            return ('imm', self.parse_hex(operand))
        except:
            raise ValueError(f"OpÃ©rande invalide: {operand}")

    def get_value(self, operand: str) -> int:
        """RÃ©cupÃ¨re la valeur d'un opÃ©rande."""
        op_type, op_val = self.parse_operand(operand)

        if op_type == 'reg':
            return self.registers[op_val]
        elif op_type == 'imm':
            return op_val
        elif op_type == 'mem_direct':
            return self.memory.get(op_val, 0)
        elif op_type == 'mem_reg':
            addr = self.registers[op_val]
            return self.memory.get(addr, 0)
        elif op_type == 'mem_reg_offset':
            base_reg, offset = op_val
            addr = (self.registers[base_reg] + offset) & 0xFFFFFFFFFFFFFFFF
            return self.memory.get(addr, 0)

        return 0

    def set_value(self, operand: str, value: int):
        """DÃ©finit la valeur d'un opÃ©rande."""
        # Masquer Ã  64 bits
        value = value & 0xFFFFFFFFFFFFFFFF

        op_type, op_val = self.parse_operand(operand)

        if op_type == 'reg':
            self.registers[op_val] = value
        elif op_type == 'mem_direct':
            if 0 <= op_val < self.MEMORY_SIZE:
                self.memory[op_val] = value
        elif op_type == 'mem_reg':
            addr = self.registers[op_val]
            if 0 <= addr < self.MEMORY_SIZE:
                self.memory[addr] = value
        elif op_type == 'mem_reg_offset':
            base_reg, offset = op_val
            addr = (self.registers[base_reg] + offset) & 0xFFFFFFFFFFFFFFFF
            if 0 <= addr < self.MEMORY_SIZE:
                self.memory[addr] = value

    def execute_instruction(self, instruction: str) -> dict:
        """ExÃ©cute une instruction et retourne les changements."""
        instruction = instruction.strip().lower()
        changes = {}

        # NOP
        if instruction == 'nop':
            return changes

        # Parser l'instruction
        parts = re.split(r'[,\s]+', instruction, maxsplit=2)
        opcode = parts[0]

        if opcode == 'mov':
            dest, src = parts[1], parts[2]
            old_val = self.get_value(dest)
            new_val = self.get_value(src)
            self.set_value(dest, new_val)
            changes[dest.upper()] = new_val

        elif opcode == 'lea':
            dest = parts[1]
            # LEA: charge l'adresse, pas la valeur
            addr_match = re.match(r'\[(.+)\]', parts[2])
            if addr_match:
                inner = addr_match.group(1)
                # Calculer l'adresse effective
                offset_match = re.match(r'(\w+)\s*([+-])\s*(\d+|0x[0-9a-fA-F]+)', inner)
                if offset_match:
                    base_reg = offset_match.group(1).upper()
                    sign = 1 if offset_match.group(2) == '+' else -1
                    offset = self.parse_hex(offset_match.group(3))
                    addr = (self.registers[base_reg] + sign * offset) & 0xFFFFFFFFFFFFFFFF
                elif inner.upper() in self.REGISTERS:
                    addr = self.registers[inner.upper()]
                else:
                    addr = self.parse_hex(inner)
                self.set_value(dest, addr)
                changes[dest.upper()] = addr

        elif opcode == 'push':
            src = parts[1]
            val = self.get_value(src)
            self.registers['RSP'] -= 8
            self.memory[self.registers['RSP']] = val
            changes['RSP'] = self.registers['RSP']

        elif opcode == 'pop':
            dest = parts[1]
            val = self.memory.get(self.registers['RSP'], 0)
            self.set_value(dest, val)
            self.registers['RSP'] += 8
            changes[dest.upper()] = val
            changes['RSP'] = self.registers['RSP']

        elif opcode == 'add':
            dest, src = parts[1], parts[2]
            result = (self.get_value(dest) + self.get_value(src)) & 0xFFFFFFFFFFFFFFFF
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'sub':
            dest, src = parts[1], parts[2]
            result = (self.get_value(dest) - self.get_value(src)) & 0xFFFFFFFFFFFFFFFF
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'inc':
            dest = parts[1]
            result = (self.get_value(dest) + 1) & 0xFFFFFFFFFFFFFFFF
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'dec':
            dest = parts[1]
            result = (self.get_value(dest) - 1) & 0xFFFFFFFFFFFFFFFF
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'and':
            dest, src = parts[1], parts[2]
            result = self.get_value(dest) & self.get_value(src)
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'or':
            dest, src = parts[1], parts[2]
            result = self.get_value(dest) | self.get_value(src)
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'xor':
            dest, src = parts[1], parts[2]
            result = self.get_value(dest) ^ self.get_value(src)
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'not':
            dest = parts[1]
            result = (~self.get_value(dest)) & 0xFFFFFFFFFFFFFFFF
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'shl':
            dest, count = parts[1], parts[2]
            shift = self.get_value(count) & 63  # Masquer Ã  6 bits
            result = (self.get_value(dest) << shift) & 0xFFFFFFFFFFFFFFFF
            self.set_value(dest, result)
            changes[dest.upper()] = result

        elif opcode == 'shr':
            dest, count = parts[1], parts[2]
            shift = self.get_value(count) & 63
            result = self.get_value(dest) >> shift
            self.set_value(dest, result)
            changes[dest.upper()] = result

        return changes

    def run(self, instructions: list) -> dict:
        """ExÃ©cute une liste d'instructions."""
        trace = []

        for instr in instructions:
            # Ignorer les lignes vides et commentaires
            instr = instr.strip()
            if not instr or instr.startswith(';'):
                continue

            # Retirer les commentaires en ligne
            if ';' in instr:
                instr = instr.split(';')[0].strip()

            changes = self.execute_instruction(instr)
            trace.append({
                'instruction': instr,
                'changes': changes
            })

        return {
            'final_state': {
                'registers': dict(self.registers),
                'memory': {hex(k): v for k, v in self.memory.items()}
            },
            'execution_trace': trace
        }


def main():
    """Point d'entrÃ©e principal."""
    if len(sys.argv) < 2:
        print("Usage: asm_emulator.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    instructions = data.get('instructions', [])
    initial_state = data.get('initial_state', {})

    emulator = X64Emulator(initial_state)
    result = emulator.run(instructions)

    print(json.dumps(result))


if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptÃ©es

```python
# Alternative: Utilisation de dictionnaire pour les opcodes
class X64EmulatorAlt:
    def __init__(self):
        self.opcodes = {
            'mov': self._mov,
            'add': self._add,
            'sub': self._sub,
            # ...
        }

    def execute_instruction(self, instruction):
        parts = instruction.split()
        opcode = parts[0]
        if opcode in self.opcodes:
            return self.opcodes[opcode](*parts[1:])
```

### 4.5 Solutions refusÃ©es (avec explications)

```python
# REFUSÃ‰: Pas de masquage 64 bits
def execute_add(self, dest, src):
    result = self.get_value(dest) + self.get_value(src)
    self.set_value(dest, result)  # Peut dÃ©passer 64 bits!

# Pourquoi c'est faux: Les registres sont limitÃ©s Ã  64 bits
```

```python
# REFUSÃ‰: Ne gÃ¨re pas le format Intel correctement
def execute_mov(self, instruction):
    # mov src, dest  <- FAUX! AT&T format
    parts = instruction.split(',')
    src, dest = parts[0], parts[1]  # Ordre inversÃ©!

# Pourquoi c'est faux: Intel = dest, src
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```python
class X64EmulatorAdvanced(X64Emulator):
    """Ã‰mulateur avancÃ© avec flags."""

    def __init__(self, initial_state=None):
        super().__init__(initial_state)
        self.flags = {'ZF': False, 'SF': False, 'CF': False, 'OF': False}

    def update_flags(self, result: int, bit_width: int = 64):
        """Met Ã  jour les flags aprÃ¨s une opÃ©ration."""
        self.flags['ZF'] = (result == 0)
        self.flags['SF'] = bool(result & (1 << (bit_width - 1)))

    def execute_cmp(self, op1: str, op2: str):
        """Compare deux opÃ©randes."""
        val1 = self.get_value(op1)
        val2 = self.get_value(op2)
        result = (val1 - val2) & 0xFFFFFFFFFFFFFFFF
        self.update_flags(result)
        self.flags['CF'] = val1 < val2

    def execute_imul(self, dest: str, src: str):
        """Multiplication signÃ©e."""
        val1 = self.get_value(dest)
        val2 = self.get_value(src)
        # Convertir en signÃ©
        if val1 & (1 << 63):
            val1 -= (1 << 64)
        if val2 & (1 << 63):
            val2 -= (1 << 64)
        result = (val1 * val2) & 0xFFFFFFFFFFFFFFFF
        self.set_value(dest, result)
        return {dest.upper(): result}
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "asm_emulator",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isolÃ©",
  "tags": ["assembly", "x86-64", "emulation", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "X64Emulator.run",
    "prototype": "def run(self, instructions: list) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "instructions", "type": "list"}
    ]
  },

  "driver": {
    "reference_file": "references/ref_solution.py",

    "edge_cases": [
      {
        "name": "empty_instructions",
        "args": [{"instructions": [], "initial_state": {}}],
        "expected_keys": ["final_state", "execution_trace"],
        "is_trap": true,
        "trap_explanation": "Liste vide doit retourner Ã©tat initial"
      },
      {
        "name": "mov_immediate",
        "args": [{"instructions": ["mov rax, 0x1337"], "initial_state": {}}],
        "check": "result['final_state']['registers']['RAX'] == 4919"
      },
      {
        "name": "xor_zero",
        "args": [{"instructions": ["mov rax, 0xff", "xor rax, rax"], "initial_state": {}}],
        "check": "result['final_state']['registers']['RAX'] == 0"
      },
      {
        "name": "overflow_64bit",
        "args": [{"instructions": ["mov rax, 0xffffffffffffffff", "add rax, 1"], "initial_state": {}}],
        "check": "result['final_state']['registers']['RAX'] == 0",
        "is_trap": true,
        "trap_explanation": "L'overflow 64-bit doit wrap autour de 0"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 200
    }
  },

  "norm": {
    "allowed_functions": ["json", "sys", "re"],
    "forbidden_functions": ["unicorn", "capstone", "keystone"],
    "check_security": false,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A (Boundary) : Ne masque pas Ã  64 bits
def execute_add_mutant(self, dest, src):
    result = self.get_value(dest) + self.get_value(src)
    # Manque: result & 0xFFFFFFFFFFFFFFFF
    self.set_value(dest, result)

# Pourquoi c'est faux: Les registres x86-64 sont limitÃ©s Ã  64 bits
```

```python
# Mutant B (Logic) : Ordre src/dest inversÃ© (AT&T style)
def execute_mov_mutant(self, instruction):
    parts = instruction.split(',')
    src = parts[0].split()[1]  # Premier opÃ©rande = source (FAUX)
    dest = parts[1].strip()     # DeuxiÃ¨me = destination
    self.set_value(dest, self.get_value(src))

# Pourquoi c'est faux: Intel = dest, src (pas src, dest)
```

```python
# Mutant C (Safety) : Ne gÃ¨re pas les accÃ¨s mÃ©moire hors limites
def get_value_mutant(self, operand):
    if operand.startswith('['):
        addr = self.parse_address(operand)
        return self.memory[addr]  # KeyError si addr pas dans memory

# Pourquoi c'est faux: Doit retourner 0 pour adresses non initialisÃ©es
```

```python
# Mutant D (Parse) : Ne gÃ¨re pas les commentaires
def run_mutant(self, instructions):
    for instr in instructions:
        self.execute_instruction(instr)  # Crash sur "; comment"

# Pourquoi c'est faux: Les commentaires ASM sont courants
```

```python
# Mutant E (Return) : SHL/SHR ne masque pas le count
def execute_shl_mutant(self, dest, count):
    shift = self.get_value(count)  # Pas de & 63!
    result = self.get_value(dest) << shift
    self.set_value(dest, result)

# Pourquoi c'est faux: x86 masque le shift count Ã  6 bits (0-63)
```

---

## ğŸ§  SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

1. **Parsing d'instructions** : DÃ©composer la syntaxe assembleur
2. **Modes d'adressage** : ImmÃ©diat, registre, mÃ©moire
3. **SÃ©mantique des instructions** : Ce que fait vraiment chaque opcode
4. **Gestion mÃ©moire** : Stack (PUSH/POP), accÃ¨s directs
5. **ArithmÃ©tique binaire** : Overflow, masquage 64 bits

### 5.2 LDA â€” Traduction littÃ©rale en franÃ§ais (MAJUSCULES)

```
CLASSE X64Emulator
    ATTRIBUTS:
        registers : DICTIONNAIRE DE REGISTRES
        memory : DICTIONNAIRE D'ADRESSES MÃ‰MOIRE

MÃ‰THODE execute_instruction(instruction)
DÃ‰BUT MÃ‰THODE
    DÃ‰CLARER opcode COMME CHAÃNE
    DÃ‰CLARER operandes COMME LISTE

    SÃ‰PARER instruction EN opcode ET operandes

    SI opcode EST Ã‰GAL Ã€ 'mov' ALORS
        AFFECTER get_value(operandes[1]) Ã€ dest_value
        set_value(operandes[0], dest_value)
    SINON SI opcode EST Ã‰GAL Ã€ 'add' ALORS
        AFFECTER get_value(operandes[0]) PLUS get_value(operandes[1]) Ã€ result
        AFFECTER result ET 0xFFFFFFFFFFFFFFFF Ã€ result_masked
        set_value(operandes[0], result_masked)
    SINON SI opcode EST Ã‰GAL Ã€ 'xor' ALORS
        AFFECTER get_value(operandes[0]) XOR get_value(operandes[1]) Ã€ result
        set_value(operandes[0], result)
    FIN SI

    RETOURNER DICTIONNAIRE DES CHANGEMENTS
FIN MÃ‰THODE
```

### 5.3 Visualisation ASCII

```
                    Ã‰TAT DE L'Ã‰MULATEUR
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                         â”‚
    â”‚   REGISTRES                    MÃ‰MOIRE (4 KB)           â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚   â”‚ RAX: 0x00001337 â”‚         â”‚ 0x000: 00 00 00 ... â”‚   â”‚
    â”‚   â”‚ RBX: 0x00000000 â”‚         â”‚ 0x100: 42 00 00 ... â”‚   â”‚
    â”‚   â”‚ RCX: 0x00000000 â”‚         â”‚ 0x200: FF FF 00 ... â”‚   â”‚
    â”‚   â”‚ RDX: 0x00000000 â”‚         â”‚  ...                â”‚   â”‚
    â”‚   â”‚ RSI: 0x00000000 â”‚         â”‚ 0xF00: [stack top]  â”‚   â”‚
    â”‚   â”‚ RDI: 0x00000000 â”‚         â”‚ 0xFFF: [stack base] â”‚   â”‚
    â”‚   â”‚ RSP: 0x00000F00 â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”‚   â”‚
    â”‚   â”‚ RBP: 0x00000FF0 â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚   â”‚ R8-R15: 0x0     â”‚                                   â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
    â”‚                                                         â”‚
    â”‚   INSTRUCTION COURANTE: mov rax, 0x1337                 â”‚
    â”‚                                                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    MODES D'ADRESSAGE:

    1. ImmÃ©diat:        mov rax, 0x1337
                              â†“
                        RAX â† 0x1337

    2. Registre:        mov rbx, rax
                              â†“
                        RBX â† valeur de RAX

    3. MÃ©moire:         mov rax, [0x100]
                              â†“
                        RAX â† contenu Ã  l'adresse 0x100

    4. Base+Offset:     mov rax, [rbx+8]
                              â†“
                        RAX â† contenu Ã  l'adresse (RBX + 8)
```

### 5.4 Les piÃ¨ges en dÃ©tail

#### PiÃ¨ge 1 : Overflow 64 bits

```python
# MAUVAIS
result = 0xFFFFFFFFFFFFFFFF + 1  # = 0x10000000000000000 (65 bits!)

# BON
result = (0xFFFFFFFFFFFFFFFF + 1) & 0xFFFFFFFFFFFFFFFF  # = 0
```

#### PiÃ¨ge 2 : Shift count

Le x86 masque le shift count Ã  6 bits (0-63). `shl rax, 64` est Ã©quivalent Ã  `shl rax, 0`.

#### PiÃ¨ge 3 : NOT et les valeurs nÃ©gatives

`not rax` avec RAX=0 donne 0xFFFFFFFFFFFFFFFF (tous les bits Ã  1), pas -1 en Python.

### 5.5 Cours Complet

#### 5.5.1 Instructions de donnÃ©es

**MOV (Move)** : L'instruction la plus utilisÃ©e. Copie une valeur de source vers destination.
```asm
mov rax, 42        ; RAX = 42
mov rbx, rax       ; RBX = RAX
mov [0x100], rax   ; MÃ©moire[0x100] = RAX
mov rax, [rbx]     ; RAX = MÃ©moire[RBX]
```

**LEA (Load Effective Address)** : Calcule une adresse sans accÃ©der Ã  la mÃ©moire.
```asm
lea rax, [rbx+8]   ; RAX = RBX + 8 (calcul, pas accÃ¨s mÃ©moire)
```

#### 5.5.2 Instructions arithmÃ©tiques

| Instruction | OpÃ©ration | Flags affectÃ©s |
|-------------|-----------|----------------|
| ADD | dest = dest + src | OF, SF, ZF, CF |
| SUB | dest = dest - src | OF, SF, ZF, CF |
| INC | dest = dest + 1 | OF, SF, ZF |
| DEC | dest = dest - 1 | OF, SF, ZF |

#### 5.5.3 Instructions logiques

| Instruction | OpÃ©ration | Usage typique |
|-------------|-----------|---------------|
| AND | dest = dest & src | Masquage de bits |
| OR | dest = dest \| src | Combinaison de bits |
| XOR | dest = dest ^ src | Mise Ã  zÃ©ro (xor rax, rax) |
| NOT | dest = ~dest | Inversion de tous les bits |

#### 5.5.4 Shifts et rotations

| Instruction | OpÃ©ration |
|-------------|-----------|
| SHL | Shift left (multiplie par 2^n) |
| SHR | Shift right logical (divise par 2^n, unsigned) |
| SAR | Shift right arithmetic (prÃ©serve le signe) |
| ROL | Rotate left |
| ROR | Rotate right |

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (fonctionne, mais interdit)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ class emu:                                                      â”‚
â”‚   def mov(s,d,v): s.r[d]=v                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ class X64Emulator:                                              â”‚
â”‚     """Ã‰mulateur x86-64 simplifiÃ©."""                           â”‚
â”‚                                                                 â”‚
â”‚     def execute_mov(self, dest: str, src: str) -> dict:         â”‚
â”‚         """ExÃ©cute l'instruction MOV."""                        â”‚
â”‚         value = self.get_value(src)                             â”‚
â”‚         self.set_value(dest, value)                             â”‚
â”‚         return {dest: value}                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚ â€¢ Noms explicites et professionnels                             â”‚
â”‚ â€¢ Documentation des mÃ©thodes                                    â”‚
â”‚ â€¢ Type hints pour la clartÃ©                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**Instructions :** `["mov rax, 0x10", "mov rbx, rax", "add rbx, 5", "shl rbx, 2"]`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction        â”‚ RAX         â”‚ RBX         â”‚ Explication              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   0   â”‚ (Ã©tat initial)     â”‚ 0           â”‚ 0           â”‚ Registres Ã  zÃ©ro         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ mov rax, 0x10      â”‚ 16          â”‚ 0           â”‚ RAX â† 0x10 (16)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ mov rbx, rax       â”‚ 16          â”‚ 16          â”‚ RBX â† RAX                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ add rbx, 5         â”‚ 16          â”‚ 21          â”‚ RBX â† 16 + 5             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ shl rbx, 2         â”‚ 16          â”‚ 84          â”‚ RBX â† 21 << 2 = 21 Ã— 4   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Inception â€” Niveaux de rÃªve" â€” Modes d'adressage

```
Niveau 0 (RÃ©alitÃ©)     â†’ ImmÃ©diat:  mov rax, 42
                         La valeur est lÃ , directement

Niveau 1 (RÃªve)        â†’ Registre:  mov rax, rbx
                         On regarde dans un autre "endroit"

Niveau 2 (RÃªveÂ²)       â†’ MÃ©moire:   mov rax, [rbx]
                         On regarde ce qui est pointÃ©

Niveau 3 (Limbes)      â†’ Base+Off:  mov rax, [rbx+rcx*8+16]
                         On navigue profondÃ©ment dans la structure
```

#### ğŸ”¥ MEME : "XOR â€” Le bouton reset universel"

```python
# Avant: RAX contient n'importe quoi (0xDEADBEEF...)
xor rax, rax  # Le bouton "reset" magique

# AprÃ¨s: RAX = 0
# Pourquoi? Parce que x ^ x = 0 pour tout x
# C'est comme diviser un nombre par lui-mÃªme: Ã§a donne toujours 1
# Sauf qu'en XOR, Ã§a donne toujours 0
```

### 5.9 Applications pratiques

1. **DÃ©veloppement d'outils de fuzzing** : Ã‰muler du code pour tester des inputs
2. **Unpacking de malware** : ExÃ©cuter le code de dÃ©compression
3. **CTF challenges** : RÃ©soudre des crackmes par Ã©mulation
4. **DÃ©veloppement d'exploits** : Tester des ROP chains

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | ConsÃ©quence | Solution |
|---|-------|-------------|----------|
| 1 | Pas de masquage 64-bit | Valeurs > 2^64 | `result & 0xFFFFFFFFFFFFFFFF` |
| 2 | Format AT&T vs Intel | Arguments inversÃ©s | Toujours dest, src |
| 3 | AccÃ¨s mÃ©moire non initialisÃ©e | KeyError | Retourner 0 par dÃ©faut |
| 4 | Shift count non masquÃ© | Comportement incorrect | `count & 63` |
| 5 | Commentaires ASM ignorÃ©s | Crash sur parsing | Filtrer les `;` |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quelle est la sortie de `xor rax, rax` si RAX contenait 0xDEADBEEF ?**

A) 0xDEADBEEF
B) 0x21524110
C) 0xFFFFFFFF
D) 0
E) 0xDEADBEEFDEADBEEF
F) Erreur
G) DÃ©pend de RBX
H) 0xFFFFFFFFFFFFFFFF
I) 1
J) -1

**RÃ©ponse : D**

---

### Question 2
**Que fait l'instruction `lea rax, [rbx+8]` ?**

A) Charge la valeur Ã  l'adresse RBX+8 dans RAX
B) Stocke RAX Ã  l'adresse RBX+8
C) Calcule RBX+8 et met le rÃ©sultat dans RAX
D) Compare RAX avec la valeur Ã  RBX+8
E) Ajoute 8 Ã  RBX et met dans RAX
F) Erreur de syntaxe
G) Ã‰quivalent Ã  `mov rax, rbx; add rax, 8`
H) C et G sont corrects
I) Aucune des rÃ©ponses
J) DÃ©pend des flags

**RÃ©ponse : H**

---

### Question 3
**Quelle valeur contient RAX aprÃ¨s `mov rax, 1; shl rax, 4` ?**

A) 4
B) 5
C) 8
D) 16
E) 32
F) 1
G) 0
H) 64
I) 15
J) 17

**RÃ©ponse : D**

---

### Question 4
**Dans le format Intel, quel est l'ordre des opÃ©randes ?**

A) source, destination
B) destination, source
C) DÃ©pend de l'instruction
D) DÃ©pend du compilateur
E) Registre toujours en premier
F) MÃ©moire toujours en premier
G) Pas d'ordre dÃ©fini
H) ImmÃ©diat toujours en dernier
I) Comme en mathÃ©matiques (a = b)
J) B et I sont corrects

**RÃ©ponse : J**

---

### Question 5
**Que se passe-t-il si on exÃ©cute `add rax, 1` avec RAX = 0xFFFFFFFFFFFFFFFF ?**

A) RAX = 0x10000000000000000
B) RAX = 0
C) Erreur d'overflow
D) RAX = 0xFFFFFFFFFFFFFFFF
E) RAX = -1
F) Le programme crash
G) RAX = 1
H) Comportement indÃ©fini
I) Exception processeur
J) RAX = 0x0000000000000000 avec CF=1

**RÃ©ponse : J** (ou B si on ignore les flags)

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| **Temps estimÃ©** | 60 min |
| **XP Base** | 200 |
| **XP Bonus** | Ã—3 (600 total) |
| **Concepts clÃ©s** | Instructions x86, Modes d'adressage, Ã‰mulation |
| **Langage** | Python 3.12 |
| **PrÃ©requis** | 3.4.1-a, Bases assembleur |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.1-b-asm-emulator",
    "generated_at": "2026-01-16 14:45:00",

    "metadata": {
      "exercise_id": "3.4.1-b",
      "exercise_name": "asm_emulator",
      "module": "3.4.1",
      "module_name": "x86-64 Assembly Fundamentals",
      "concept": "b",
      "concept_name": "Instructions de donnÃ©es et modes d'adressage",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isolÃ©",
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "python",
      "duration_minutes": 60,
      "xp_base": 200,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T4 O(nÃ—m)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["3.4.1-a"],
      "domains": ["CPU", "ASM", "Encodage"],
      "domains_bonus": ["Mem", "MD"],
      "tags": ["assembly", "x86-64", "emulation", "parsing"],
      "meme_reference": "Inception - Dream Levels"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.py": "/* Section 4.3 */",
      "references/ref_solution_bonus.py": "/* Section 4.6 */",
      "mutants/mutant_a_boundary.py": "/* Section 4.10 */",
      "mutants/mutant_b_logic.py": "/* Section 4.10 */",
      "mutants/mutant_c_safety.py": "/* Section 4.10 */",
      "mutants/mutant_d_parse.py": "/* Section 4.10 */",
      "mutants/mutant_e_return.py": "/* Section 4.10 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.py",
        "references/ref_solution_bonus.py"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.py",
        "mutants/mutant_b_logic.py",
        "mutants/mutant_c_safety.py",
        "mutants/mutant_d_parse.py",
        "mutants/mutant_e_return.py"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_solution.py",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.py -s spec.json --validate"
    }
  }
}
```
