# Exercice 3.4.4-d : Le Bypasseur de CFI

## Metadata
- **Exercice ID**: 3.4.4-d
- **Titre**: Le Bypasseur de CFI
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Protection Bypass (Niveau 2)
- **Difficulté**: ⭐⭐⭐⭐⭐⭐⭐⭐ (8/10 - Expert+)
- **Tier**: 2
- **XP**: 650

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.4.r | CFI - Control Flow Integrity |
| 3.4.4.s | CET - Control-flow Enforcement Technology |
| 3.4.4.t | Shadow Stack |
| 3.4.4.u | CET Bypass Techniques |
| 3.4.4.v | Intel MPK (Memory Protection Keys) |

## Prerequis
- Module 3.4.4-a : Protection Detector
- Module 3.4.6-a : ROP Builder (notions de gadgets)
- Comprehension de l'architecture x86-64 et des appels indirects
- Notions de graphe de flot de controle (CFG)

---

## Section 1 : Prototype de Fonction

```python
"""
Module: cfi_bypasser - Analyse et Bypass CFI/CET
Architecture: x86-64 avec extensions CET
Contraintes: Simulation sans matériel CET réel
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Optional


class CFIType(Enum):
    """Types de CFI implémentés."""
    NONE = auto()
    CLANG_CFI = auto()      # LLVM CFI (type-based)
    MSVC_CFG = auto()       # Windows Control Flow Guard
    GCC_VTV = auto()        # Virtual Table Verification
    INTEL_CET = auto()      # Hardware CET (IBT + Shadow Stack)
    CUSTOM = auto()


class GadgetType(Enum):
    """Types de gadgets ROP."""
    REGULAR = auto()        # Gadget standard (pas call-preceded)
    CALL_PRECEDED = auto()  # Précédé d'une instruction CALL
    ENDBR_GADGET = auto()   # Commence par ENDBR64
    JOP_GADGET = auto()     # Jump-Oriented (jmp reg)
    COP_GADGET = auto()     # Call-Oriented (call reg)


@dataclass
class Gadget:
    """Représentation d'un gadget."""
    address: int
    instructions: list[str]
    gadget_type: GadgetType
    cfi_valid: bool = False
    endbr_present: bool = False
    call_site_offset: Optional[int] = None  # Offset du CALL qui précède


@dataclass
class CFIMetadata:
    """Métadonnées CFI d'un binaire."""
    cfi_type: CFIType
    valid_targets: set[int]           # Adresses de branch valides
    indirect_calls: list[dict]        # Infos sur les appels indirects
    vtable_entries: dict[str, list[int]]  # Tables virtuelles
    shadow_stack_enabled: bool = False
    ibt_enabled: bool = False          # Indirect Branch Tracking


@dataclass
class ShadowStackState:
    """État simulé de la Shadow Stack."""
    entries: list[int] = field(default_factory=list)
    max_size: int = 1024
    overflow_count: int = 0
    underflow_count: int = 0


def analyze_cfi_protections(binary_info: dict) -> dict:
    """
    Analyse les protections CFI d'un binaire.

    Args:
        binary_info: Dict avec sections, symboles et métadonnées

    Returns:
        Dict avec:
        - cfi_type: Type de CFI détecté
        - coverage: Pourcentage du code protégé
        - valid_targets: Cibles valides pour branches indirectes
        - weaknesses: Faiblesses identifiées

    Exemple:
        >>> info = {"sections": [...], "cfi_metadata": {...}}
        >>> result = analyze_cfi_protections(info)
        >>> result["cfi_type"]
        "INTEL_CET"
    """
    pass


def simulate_shadow_stack(
    call_sequence: list[dict],
    initial_rsp: int
) -> dict:
    """
    Simule le comportement de la Shadow Stack.

    Args:
        call_sequence: Liste de {"type": "call"/"ret", "target": addr}
        initial_rsp: Valeur initiale de RSP

    Returns:
        Dict avec:
        - final_state: État final de la shadow stack
        - violations: Liste des violations détectées
        - operations: Historique des opérations

    Exemple:
        >>> seq = [
        ...     {"type": "call", "target": 0x401000, "return_addr": 0x401100},
        ...     {"type": "ret", "target": 0x401100}
        ... ]
        >>> result = simulate_shadow_stack(seq, 0x7fff0000)
        >>> len(result["violations"])
        0
    """
    pass


def find_cfi_valid_gadgets(
    gadgets: list[Gadget],
    cfi_metadata: CFIMetadata
) -> dict:
    """
    Identifie les gadgets valides sous protection CFI.

    Args:
        gadgets: Liste de gadgets découverts
        cfi_metadata: Métadonnées CFI du binaire

    Returns:
        Dict avec:
        - valid_gadgets: Gadgets utilisables malgré CFI
        - invalid_gadgets: Gadgets bloqués par CFI
        - bypass_candidates: Gadgets potentiels pour bypass

    Exemple:
        >>> gadgets = [Gadget(0x401000, ["pop rdi", "ret"], GadgetType.REGULAR)]
        >>> result = find_cfi_valid_gadgets(gadgets, cfi_meta)
        >>> len(result["valid_gadgets"])
        0  # Gadget sans ENDBR bloqué par IBT
    """
    pass


def generate_cet_bypass_strategy(
    cfi_metadata: CFIMetadata,
    available_gadgets: list[Gadget],
    target_function: int
) -> dict:
    """
    Génère une stratégie de bypass CET.

    Args:
        cfi_metadata: Métadonnées CFI
        available_gadgets: Gadgets disponibles
        target_function: Adresse de la fonction cible

    Returns:
        Dict avec:
        - strategy: Nom de la stratégie
        - steps: Étapes d'exploitation
        - success_probability: Probabilité estimée
        - requirements: Prérequis pour le bypass

    Stratégies possibles:
    - "endbr_chain": Utiliser uniquement des gadgets avec ENDBR
    - "shadow_stack_pivot": Pivoter vers une shadow stack contrôlée
    - "race_condition": Exploiter race condition dans vérification
    - "exception_handler": Utiliser exception handling
    """
    pass


def analyze_vtable_cfi(
    vtables: dict[str, list[int]],
    valid_methods: dict[str, set[int]]
) -> dict:
    """
    Analyse la protection CFI des tables virtuelles (VTV/CFI).

    Args:
        vtables: Mapping nom_classe -> liste d'adresses de méthodes
        valid_methods: Mapping nom_type -> ensemble de méthodes valides

    Returns:
        Dict avec:
        - protected_classes: Classes avec vtable protégée
        - vulnerable_entries: Entrées potentiellement exploitables
        - type_confusion_targets: Cibles pour confusion de type

    Exemple:
        >>> vtables = {"Base": [0x401000, 0x401100], "Derived": [0x401200, 0x401300]}
        >>> valid = {"Base": {0x401000, 0x401100}}
        >>> result = analyze_vtable_cfi(vtables, valid)
    """
    pass


def check_ibt_compliance(instructions: list[str]) -> dict:
    """
    Vérifie la conformité IBT (Indirect Branch Tracking) d'un bloc.

    Args:
        instructions: Liste d'instructions assembleur

    Returns:
        Dict avec:
        - compliant: Booléen de conformité
        - indirect_branches: Branches indirects trouvés
        - missing_endbr: Cibles sans ENDBR

    Exemple:
        >>> instrs = ["endbr64", "push rbp", "mov rbp, rsp", "jmp rax"]
        >>> result = check_ibt_compliance(instrs)
        >>> result["compliant"]
        True  # Commence par endbr64
    """
    pass


def simulate_mpk_bypass(
    memory_regions: list[dict],
    pkru_value: int,
    target_region: int
) -> dict:
    """
    Simule un bypass de Intel MPK (Memory Protection Keys).

    Args:
        memory_regions: Régions avec leurs pkey
        pkru_value: Valeur actuelle du registre PKRU
        target_region: Index de la région cible

    Returns:
        Dict avec:
        - current_access: Accès actuels à la région
        - bypass_possible: Si bypass est possible
        - required_pkru: Valeur PKRU nécessaire
        - bypass_method: Méthode de bypass suggérée

    Exemple:
        >>> regions = [{"start": 0x1000, "pkey": 1, "perms": "rw"}]
        >>> result = simulate_mpk_bypass(regions, 0x55555555, 0)
        >>> result["current_access"]
        "none"  # pkey 1 bloqué par PKRU
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Introduction au Control Flow Integrity (CFI)

Le **Control Flow Integrity (CFI)** est une technique de sécurité qui restreint les cibles valides des branches indirects (call/jmp via registre ou mémoire, ret). L'objectif est de bloquer les attaques ROP/JOP/COP en forçant le programme à suivre un graphe de flot de contrôle (CFG) préétabli.

### 2.2 Types de CFI (3.4.4.r)

#### CFI Logiciel (Compiler-Based)

```
1. Clang CFI (LLVM)
   - Type-based: vérifie que le type du pointeur de fonction correspond
   - Vcall: protège les appels virtuels C++
   - Icall: protège les appels indirects
   - Implémenté via instrumentation à la compilation

2. Microsoft CFG (Control Flow Guard)
   - Bitmap des cibles valides
   - Vérifié à chaque appel indirect
   - Supporté nativement par Windows

3. GCC VTV (Virtual Table Verification)
   - Protège spécifiquement les vtables C++
   - Vérifie l'intégrité des pointeurs de vtable
```

#### Overhead et Limitations

```
Type        | Overhead Performance | Protection
------------|---------------------|------------
Clang CFI   | 1-5%                | Branches indirects uniquement
MS CFG      | 2-8%                | Appels indirects
GCC VTV     | 5-10%               | Vtables uniquement
Intel CET   | <1% (hardware)      | Complet (IBT + Shadow Stack)
```

### 2.3 Intel CET - Control-flow Enforcement Technology (3.4.4.s)

**Intel CET** est une protection matérielle introduite dans les processeurs Intel (Tiger Lake+) et AMD (Zen 3+).

#### Composants de CET

```
1. Indirect Branch Tracking (IBT)
   - Chaque cible de branche indirect doit commencer par ENDBR32/ENDBR64
   - Si la cible ne commence pas par ENDBR, #CP exception

2. Shadow Stack
   - Stack matérielle séparée pour les adresses de retour
   - Comparaison automatique lors de RET
   - Mismatch = #CP exception
```

#### Instructions CET

```asm
; Indirect Branch Tracking
ENDBR64        ; Marque une cible valide de branche (64-bit)
ENDBR32        ; Marque une cible valide de branche (32-bit)

; Shadow Stack
INCSSPQ rax    ; Incrémente SSP (Shadow Stack Pointer)
RDSSPQ rax     ; Lit la valeur de SSP
SAVEPREVSSP    ; Sauvegarde SSP précédent pour context switch
RSTORSSP mem   ; Restaure SSP depuis mémoire
WRSSD mem, reg ; Écrit sur shadow stack (superviseur)
WRSSQ mem, reg ; Écrit sur shadow stack 64-bit
```

### 2.4 Shadow Stack (3.4.4.t)

La **Shadow Stack** maintient une copie des adresses de retour, séparée de la stack normale.

#### Fonctionnement

```
Lors d'un CALL:
1. Push return address sur la stack normale
2. Push return address sur la shadow stack (matériel)

Lors d'un RET:
1. Pop return address de la stack normale
2. Pop return address de la shadow stack
3. Compare les deux valeurs
4. Si différent: #CP (Control Protection) exception
```

#### États de la Shadow Stack

```python
class ShadowStackOperation:
    """Opérations sur la Shadow Stack."""

    def push(self, return_addr: int):
        """Appelé lors d'un CALL."""
        if len(self.stack) >= self.max_size:
            raise ShadowStackOverflow()
        self.stack.append(return_addr)

    def pop_and_verify(self, normal_stack_addr: int) -> bool:
        """Appelé lors d'un RET."""
        if not self.stack:
            raise ShadowStackUnderflow()
        shadow_addr = self.stack.pop()
        return shadow_addr == normal_stack_addr
```

### 2.5 Techniques de Bypass CET (3.4.4.u)

Malgré sa robustesse, CET a des limitations exploitables.

#### Bypass IBT

```
1. ENDBR Gadgets
   - Certaines fonctions commencent par ENDBR suivi de code utile
   - Chercher des "ENDBR gadgets": endbr64; pop rdi; ret

2. JOP avec ENDBR
   - Construire des chaînes JOP où chaque cible a ENDBR
   - Plus contraignant mais possible

3. Call-Preceded Gadgets
   - Gadgets qui suivent immédiatement un CALL (non vérifié par IBT)
   - call func; <gadget ici> est valide
```

#### Bypass Shadow Stack

```
1. Stack Pivoting pré-CALL
   - Pivoter vers une zone contrôlée AVANT le premier call
   - La shadow stack ne protège que les adresses pushées après activation

2. Exception Handling
   - Les gestionnaires d'exception peuvent modifier le contexte
   - Certains unwinders ne vérifient pas la shadow stack

3. Signal Handlers
   - Lors de la livraison d'un signal, le kernel modifie les deux stacks
   - Race conditions possibles

4. Write primitives sur Shadow Stack
   - Si on obtient une primitive d'écriture arbitraire
   - WRSSQ instruction (nécessite ring 0 ou bug)
```

### 2.6 Intel MPK - Memory Protection Keys (3.4.4.v)

**Memory Protection Keys (MPK)** permet de restreindre l'accès mémoire sans modifier les page tables.

#### Mécanisme

```
- Chaque page peut avoir un "pkey" (0-15)
- Le registre PKRU définit les permissions par pkey
- PKRU: 32 bits, 2 bits par pkey (Access Disable, Write Disable)
```

#### Format PKRU

```
PKRU bits pour pkey N:
- Bit 2*N: Access Disable (AD) - bloque lecture et écriture
- Bit 2*N+1: Write Disable (WD) - bloque écriture seulement

Exemple: PKRU = 0x55555554
- pkey 0: 00 (full access)
- pkey 1: 01 (read-only)
- pkey 2-15: 01 (read-only)
```

#### Instructions MPK

```asm
RDPKRU         ; Lit PKRU dans EAX (ECX=0)
WRPKRU         ; Écrit EAX dans PKRU (ECX=0, EDX=0)
```

#### Bypass MPK

```python
def bypass_mpk_analysis(pkru_gadgets: list) -> dict:
    """
    Analyse les possibilités de bypass MPK.

    Stratégies:
    1. WRPKRU gadget: Trouver un gadget pour modifier PKRU
    2. Signal handler: PKRU est sauvegardé/restauré sur signal
    3. Kernel bug: PKRU mal restauré après syscall
    """
    pass
```

### 2.7 Analyse CFI Pratique

#### Détection de CFI dans un binaire

```python
def detect_cfi_type(binary_path: str) -> CFIType:
    """Détecte le type de CFI utilisé."""

    # Check for Clang CFI
    # Présence de __cfi_check, __cfi_slowpath

    # Check for Microsoft CFG
    # Présence de _guard_check_icall, Guard CF Table

    # Check for Intel CET
    # ENDBR64 au début des fonctions, GNU_PROPERTY_X86_FEATURE_1_IBT

    # Check for GCC VTV
    # __VLTRegisterSet*, __VLTVerifyVtablePointer
```

#### Trouver des gadgets ENDBR

```python
def find_endbr_gadgets(code: bytes, base_addr: int) -> list[Gadget]:
    """
    Trouve les gadgets qui commencent par ENDBR64.

    ENDBR64 = f3 0f 1e fa
    """
    endbr64 = b'\xf3\x0f\x1e\xfa'
    gadgets = []

    offset = 0
    while True:
        idx = code.find(endbr64, offset)
        if idx == -1:
            break

        # Analyser les instructions suivantes
        addr = base_addr + idx
        instrs = disassemble(code[idx:idx+20])

        # Chercher un RET dans les 20 bytes
        if contains_ret(instrs):
            gadget = Gadget(
                address=addr,
                instructions=instrs,
                gadget_type=GadgetType.ENDBR_GADGET,
                cfi_valid=True,
                endbr_present=True
            )
            gadgets.append(gadget)

        offset = idx + 1

    return gadgets
```

### 2.8 Construction de Chaînes CFI-Compliant

```python
def build_cfi_compliant_chain(
    endbr_gadgets: list[Gadget],
    goal: str
) -> list[int]:
    """
    Construit une chaîne ROP respectant IBT.

    Contraintes:
    - Chaque cible doit commencer par ENDBR64
    - Moins de gadgets disponibles = plus difficile
    """

    # Exemple: Appeler system("/bin/sh")
    # Besoin: pop rdi; ret avec ENDBR64

    chain = []

    # Chercher: endbr64; pop rdi; ret
    pop_rdi = find_gadget(endbr_gadgets, ["pop rdi", "ret"])
    if not pop_rdi:
        raise CFIBypassFailed("No ENDBR pop rdi gadget")

    chain.append(pop_rdi.address)
    chain.append(binsh_addr)  # "/bin/sh"

    # Appeler system - doit aussi avoir ENDBR64 (fonction normale)
    chain.append(system_addr)

    return chain
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - CFI/CET Analyzer and Bypasser
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Optional
import re


class CFIType(Enum):
    NONE = auto()
    CLANG_CFI = auto()
    MSVC_CFG = auto()
    GCC_VTV = auto()
    INTEL_CET = auto()
    CUSTOM = auto()


class GadgetType(Enum):
    REGULAR = auto()
    CALL_PRECEDED = auto()
    ENDBR_GADGET = auto()
    JOP_GADGET = auto()
    COP_GADGET = auto()


@dataclass
class Gadget:
    address: int
    instructions: list
    gadget_type: GadgetType
    cfi_valid: bool = False
    endbr_present: bool = False
    call_site_offset: Optional[int] = None


@dataclass
class CFIMetadata:
    cfi_type: CFIType
    valid_targets: set
    indirect_calls: list
    vtable_entries: dict
    shadow_stack_enabled: bool = False
    ibt_enabled: bool = False


@dataclass
class ShadowStackState:
    entries: list = field(default_factory=list)
    max_size: int = 1024
    overflow_count: int = 0
    underflow_count: int = 0


# ENDBR64 opcode
ENDBR64_BYTES = bytes([0xf3, 0x0f, 0x1e, 0xfa])
ENDBR32_BYTES = bytes([0xf3, 0x0f, 0x1e, 0xfb])


def analyze_cfi_protections(binary_info: dict) -> dict:
    """Analyse les protections CFI d'un binaire."""

    result = {
        "cfi_type": "NONE",
        "cfi_type_enum": CFIType.NONE,
        "coverage": 0.0,
        "valid_targets": set(),
        "weaknesses": [],
        "details": {}
    }

    sections = binary_info.get("sections", [])
    symbols = binary_info.get("symbols", [])
    cfi_metadata = binary_info.get("cfi_metadata", {})
    properties = binary_info.get("gnu_properties", [])

    # Detect CFI type from symbols
    symbol_names = {s.get("name", "") for s in symbols}

    # Check for Clang CFI
    if "__cfi_check" in symbol_names or "__cfi_slowpath" in symbol_names:
        result["cfi_type"] = "CLANG_CFI"
        result["cfi_type_enum"] = CFIType.CLANG_CFI
        result["details"]["clang_cfi"] = {
            "has_cfi_check": "__cfi_check" in symbol_names,
            "has_slowpath": "__cfi_slowpath" in symbol_names
        }

    # Check for Microsoft CFG
    elif "_guard_check_icall" in symbol_names or "GuardCFCheckFunction" in symbol_names:
        result["cfi_type"] = "MSVC_CFG"
        result["cfi_type_enum"] = CFIType.MSVC_CFG
        result["details"]["cfg"] = {
            "guard_check": "_guard_check_icall" in symbol_names
        }

    # Check for GCC VTV
    elif any("__VLT" in s for s in symbol_names):
        result["cfi_type"] = "GCC_VTV"
        result["cfi_type_enum"] = CFIType.GCC_VTV
        result["details"]["vtv"] = {
            "vtable_verify": any("VerifyVtable" in s for s in symbol_names)
        }

    # Check for Intel CET
    if "GNU_PROPERTY_X86_FEATURE_1_IBT" in properties or \
       cfi_metadata.get("ibt_enabled", False):
        result["cfi_type"] = "INTEL_CET"
        result["cfi_type_enum"] = CFIType.INTEL_CET
        result["details"]["cet"] = {
            "ibt_enabled": True,
            "shadow_stack": "GNU_PROPERTY_X86_FEATURE_1_SHSTK" in properties or \
                           cfi_metadata.get("shadow_stack_enabled", False)
        }

    # Calculate coverage
    total_functions = len([s for s in symbols if s.get("type") == "FUNC"])
    protected_functions = cfi_metadata.get("protected_functions", 0)
    if total_functions > 0:
        result["coverage"] = (protected_functions / total_functions) * 100

    # Get valid targets
    result["valid_targets"] = set(cfi_metadata.get("valid_targets", []))

    # Identify weaknesses
    weaknesses = []

    if result["cfi_type"] == "CLANG_CFI":
        weaknesses.append("Type confusion may bypass type-based CFI")
        weaknesses.append("Indirect jumps (JOP) may not be fully covered")

    if result["cfi_type"] == "MSVC_CFG":
        weaknesses.append("CFG bitmap may have valid non-function targets")
        weaknesses.append("Return addresses not protected (use /CETCOMPAT)")

    if result["cfi_type"] == "INTEL_CET":
        if not result["details"].get("cet", {}).get("shadow_stack", False):
            weaknesses.append("Shadow Stack not enabled - ROP still possible")
        weaknesses.append("ENDBR gadgets may exist")
        weaknesses.append("Call-preceded gadgets bypass IBT")

    if result["cfi_type"] == "NONE":
        weaknesses.append("No CFI protection - full ROP/JOP/COP possible")

    result["weaknesses"] = weaknesses

    return result


def simulate_shadow_stack(
    call_sequence: list,
    initial_rsp: int
) -> dict:
    """Simule le comportement de la Shadow Stack."""

    state = ShadowStackState()
    violations = []
    operations = []
    current_rsp = initial_rsp

    for i, op in enumerate(call_sequence):
        op_type = op.get("type")
        target = op.get("target", 0)
        return_addr = op.get("return_addr", 0)

        if op_type == "call":
            # CALL: push return address to both stacks
            if len(state.entries) >= state.max_size:
                state.overflow_count += 1
                violations.append({
                    "index": i,
                    "type": "shadow_stack_overflow",
                    "operation": op
                })
            else:
                state.entries.append(return_addr)
                operations.append({
                    "index": i,
                    "operation": "push",
                    "address": return_addr,
                    "stack_depth": len(state.entries)
                })
            current_rsp -= 8

        elif op_type == "ret":
            # RET: pop and verify
            if not state.entries:
                state.underflow_count += 1
                violations.append({
                    "index": i,
                    "type": "shadow_stack_underflow",
                    "operation": op
                })
            else:
                shadow_addr = state.entries.pop()
                operations.append({
                    "index": i,
                    "operation": "pop",
                    "shadow_addr": shadow_addr,
                    "actual_target": target,
                    "stack_depth": len(state.entries)
                })

                if shadow_addr != target:
                    violations.append({
                        "index": i,
                        "type": "return_address_mismatch",
                        "expected": shadow_addr,
                        "actual": target,
                        "operation": op
                    })
            current_rsp += 8

    return {
        "final_state": {
            "entries": list(state.entries),
            "depth": len(state.entries),
            "overflow_count": state.overflow_count,
            "underflow_count": state.underflow_count
        },
        "violations": violations,
        "violation_count": len(violations),
        "operations": operations,
        "final_rsp": current_rsp
    }


def find_cfi_valid_gadgets(
    gadgets: list,
    cfi_metadata: CFIMetadata
) -> dict:
    """Identifie les gadgets valides sous protection CFI."""

    valid_gadgets = []
    invalid_gadgets = []
    bypass_candidates = []

    valid_targets = cfi_metadata.valid_targets
    ibt_enabled = cfi_metadata.ibt_enabled
    shadow_stack = cfi_metadata.shadow_stack_enabled

    for gadget in gadgets:
        is_valid = True
        bypass_reason = None

        # Check IBT compliance
        if ibt_enabled:
            if gadget.gadget_type == GadgetType.ENDBR_GADGET:
                # ENDBR gadgets are valid for IBT
                gadget.cfi_valid = True
            elif gadget.gadget_type == GadgetType.CALL_PRECEDED:
                # Call-preceded gadgets might work (execution falls through)
                gadget.cfi_valid = True
                bypass_reason = "call_preceded_bypass"
            else:
                # Regular gadgets blocked by IBT
                is_valid = False
                gadget.cfi_valid = False

        # Check if in valid targets set (for software CFI)
        if cfi_metadata.cfi_type in [CFIType.CLANG_CFI, CFIType.MSVC_CFG]:
            if gadget.address not in valid_targets:
                is_valid = False

        # Categorize
        if is_valid:
            valid_gadgets.append(gadget)
            if bypass_reason:
                bypass_candidates.append({
                    "gadget": gadget,
                    "bypass_method": bypass_reason
                })
        else:
            invalid_gadgets.append(gadget)

    # Find additional bypass candidates
    # Look for ENDBR gadgets that could be useful
    for gadget in valid_gadgets:
        if gadget.endbr_present:
            # Check if useful operations follow ENDBR
            instrs_str = " ".join(gadget.instructions).lower()
            useful_patterns = ["pop r", "mov r", "xchg", "add rsp", "leave"]

            for pattern in useful_patterns:
                if pattern in instrs_str:
                    if gadget not in [bc["gadget"] for bc in bypass_candidates]:
                        bypass_candidates.append({
                            "gadget": gadget,
                            "bypass_method": "endbr_useful_gadget",
                            "useful_operation": pattern
                        })
                    break

    return {
        "valid_gadgets": valid_gadgets,
        "valid_count": len(valid_gadgets),
        "invalid_gadgets": invalid_gadgets,
        "invalid_count": len(invalid_gadgets),
        "bypass_candidates": bypass_candidates,
        "bypass_count": len(bypass_candidates),
        "cfi_type": cfi_metadata.cfi_type.name
    }


def generate_cet_bypass_strategy(
    cfi_metadata: CFIMetadata,
    available_gadgets: list,
    target_function: int
) -> dict:
    """Génère une stratégie de bypass CET."""

    strategies = []

    # Analyze available gadgets
    endbr_gadgets = [g for g in available_gadgets
                    if g.gadget_type == GadgetType.ENDBR_GADGET]
    call_preceded = [g for g in available_gadgets
                    if g.gadget_type == GadgetType.CALL_PRECEDED]

    # Strategy 1: ENDBR Chain
    if len(endbr_gadgets) >= 3:
        # Check if we have useful ENDBR gadgets
        useful_endbr = []
        for g in endbr_gadgets:
            instrs = " ".join(g.instructions).lower()
            if any(op in instrs for op in ["pop rdi", "pop rsi", "pop rdx", "ret"]):
                useful_endbr.append(g)

        if useful_endbr:
            strategies.append({
                "strategy": "endbr_chain",
                "priority": 1,
                "description": "Build ROP chain using only ENDBR-prefixed gadgets",
                "success_probability": 0.7,
                "requirements": [
                    "Enough ENDBR gadgets for desired operations",
                    "Target function must have ENDBR (normal functions do)"
                ],
                "steps": [
                    f"Found {len(useful_endbr)} useful ENDBR gadgets",
                    "Chain ENDBR gadgets to set up registers",
                    f"Jump to target function at 0x{target_function:x}",
                    "All targets begin with ENDBR64, bypassing IBT"
                ],
                "gadgets_needed": useful_endbr[:5]
            })

    # Strategy 2: Call-Preceded Gadgets
    if call_preceded:
        strategies.append({
            "strategy": "call_preceded_chain",
            "priority": 2,
            "description": "Use gadgets immediately following CALL instructions",
            "success_probability": 0.5,
            "requirements": [
                "Gadgets after CALL are not checked by IBT",
                "Need to find useful call-preceded sequences"
            ],
            "steps": [
                f"Found {len(call_preceded)} call-preceded gadgets",
                "These gadgets are reached via fall-through, not jump",
                "Chain them for register setup",
                "May need to combine with ENDBR gadgets"
            ],
            "gadgets_available": len(call_preceded)
        })

    # Strategy 3: Shadow Stack Pivot (if no shadow stack)
    if not cfi_metadata.shadow_stack_enabled:
        strategies.append({
            "strategy": "traditional_rop",
            "priority": 1,
            "description": "Shadow Stack disabled - traditional ROP viable",
            "success_probability": 0.9,
            "requirements": [
                "Only IBT to bypass, no shadow stack",
                "Use ENDBR gadgets or call-preceded"
            ],
            "steps": [
                "Shadow Stack not enabled, RET addresses not verified",
                "Focus only on IBT bypass",
                "Use any valid ENDBR/call-preceded gadget",
                "Standard ROP chain construction"
            ]
        })
    else:
        # Shadow stack is enabled - more complex bypass needed
        strategies.append({
            "strategy": "exception_handler",
            "priority": 3,
            "description": "Exploit exception handling to bypass shadow stack",
            "success_probability": 0.3,
            "requirements": [
                "Ability to trigger controlled exception",
                "Exception handlers may modify both stacks",
                "Depends on specific runtime/OS behavior"
            ],
            "steps": [
                "Trigger a controlled exception (div by zero, null deref)",
                "Exception unwinder modifies shadow stack",
                "Exploit any inconsistencies in stack restoration",
                "This is highly environment-dependent"
            ]
        })

        strategies.append({
            "strategy": "signal_handler_race",
            "priority": 4,
            "description": "Race condition during signal delivery",
            "success_probability": 0.1,
            "requirements": [
                "Ability to send signals to the process",
                "Timing-sensitive race condition",
                "Kernel version specific"
            ],
            "steps": [
                "Send signal while in critical section",
                "Signal handler saves/restores context",
                "Race to modify stack between save and return",
                "Extremely difficult in practice"
            ]
        })

    # Sort by priority
    strategies.sort(key=lambda x: x["priority"])

    # Determine overall recommendation
    if strategies:
        best = strategies[0]
        return {
            "target_function": hex(target_function),
            "cfi_active": cfi_metadata.cfi_type.name,
            "ibt_enabled": cfi_metadata.ibt_enabled,
            "shadow_stack_enabled": cfi_metadata.shadow_stack_enabled,
            "recommended_strategy": best,
            "alternative_strategies": strategies[1:] if len(strategies) > 1 else [],
            "overall_success_estimate": best["success_probability"],
            "total_strategies_found": len(strategies)
        }
    else:
        return {
            "target_function": hex(target_function),
            "error": "No viable bypass strategy found",
            "cfi_active": cfi_metadata.cfi_type.name,
            "recommendation": "Consider finding more gadgets or alternative vulnerabilities"
        }


def analyze_vtable_cfi(
    vtables: dict,
    valid_methods: dict
) -> dict:
    """Analyse la protection CFI des tables virtuelles."""

    protected_classes = []
    vulnerable_entries = []
    type_confusion_targets = []

    for class_name, vtable_addrs in vtables.items():
        valid_for_type = valid_methods.get(class_name, set())

        is_protected = True
        class_vulns = []

        for i, addr in enumerate(vtable_addrs):
            if addr not in valid_for_type:
                is_protected = False
                class_vulns.append({
                    "class": class_name,
                    "vtable_index": i,
                    "address": hex(addr),
                    "reason": "Method not in valid set for this type"
                })

        if is_protected:
            protected_classes.append(class_name)
        else:
            vulnerable_entries.extend(class_vulns)

    # Find type confusion opportunities
    # Look for methods valid for one type but not another
    all_classes = list(vtables.keys())
    for i, class_a in enumerate(all_classes):
        for class_b in all_classes[i+1:]:
            addrs_a = set(vtables[class_a])
            addrs_b = set(vtables[class_b])
            valid_a = valid_methods.get(class_a, set())
            valid_b = valid_methods.get(class_b, set())

            # Addresses in A's vtable that are valid for B but not A
            confusion_targets = (addrs_a & valid_b) - valid_a

            for addr in confusion_targets:
                type_confusion_targets.append({
                    "source_class": class_a,
                    "target_class": class_b,
                    "address": hex(addr),
                    "attack": f"Confuse {class_a} pointer as {class_b}"
                })

    return {
        "total_classes": len(vtables),
        "protected_classes": protected_classes,
        "protected_count": len(protected_classes),
        "vulnerable_entries": vulnerable_entries,
        "vulnerable_count": len(vulnerable_entries),
        "type_confusion_targets": type_confusion_targets,
        "type_confusion_count": len(type_confusion_targets),
        "overall_protection": len(protected_classes) / len(vtables) * 100 if vtables else 0
    }


def check_ibt_compliance(instructions: list) -> dict:
    """Vérifie la conformité IBT d'un bloc."""

    result = {
        "compliant": False,
        "starts_with_endbr": False,
        "indirect_branches": [],
        "missing_endbr": [],
        "analysis": []
    }

    if not instructions:
        result["analysis"].append("Empty instruction list")
        return result

    # Check if starts with ENDBR
    first_instr = instructions[0].lower().strip()
    if first_instr.startswith("endbr"):
        result["starts_with_endbr"] = True
        result["compliant"] = True
        result["analysis"].append("Block starts with ENDBR - valid indirect branch target")

    # Find indirect branches
    indirect_patterns = [
        (r"jmp\s+(r[a-z0-9]+|\[.+\])", "indirect_jmp"),
        (r"call\s+(r[a-z0-9]+|\[.+\])", "indirect_call"),
        (r"ret", "ret")
    ]

    for i, instr in enumerate(instructions):
        instr_lower = instr.lower().strip()

        for pattern, branch_type in indirect_patterns:
            if re.search(pattern, instr_lower):
                result["indirect_branches"].append({
                    "index": i,
                    "instruction": instr,
                    "type": branch_type
                })

                # For indirect branches, the target needs ENDBR
                if branch_type != "ret":
                    result["analysis"].append(
                        f"Indirect branch at index {i}: target must have ENDBR"
                    )

    # Check for JMP/CALL to labels that might not have ENDBR
    # This is a simplified check - real analysis would need more context

    return result


def simulate_mpk_bypass(
    memory_regions: list,
    pkru_value: int,
    target_region: int
) -> dict:
    """Simule un bypass de Intel MPK."""

    if target_region >= len(memory_regions):
        return {"error": "Invalid target region index"}

    target = memory_regions[target_region]
    pkey = target.get("pkey", 0)
    base_perms = target.get("perms", "")

    # Decode PKRU for this pkey
    # Each pkey uses 2 bits: bit 2*pkey = AD (Access Disable), bit 2*pkey+1 = WD (Write Disable)
    ad_bit = (pkru_value >> (2 * pkey)) & 1
    wd_bit = (pkru_value >> (2 * pkey + 1)) & 1

    # Determine current access
    if ad_bit:
        current_access = "none"
    elif wd_bit:
        current_access = "read-only"
    else:
        current_access = "read-write"

    # Determine required PKRU for full access
    # Clear both AD and WD bits for target pkey
    mask = ~(0b11 << (2 * pkey))
    required_pkru = pkru_value & mask

    # Analyze bypass possibilities
    bypass_methods = []

    # Method 1: WRPKRU gadget
    bypass_methods.append({
        "method": "wrpkru_gadget",
        "description": "Find and use a WRPKRU gadget to modify PKRU",
        "requirements": ["ROP chain capability", "WRPKRU gadget in binary"],
        "difficulty": "medium"
    })

    # Method 2: Signal handler
    bypass_methods.append({
        "method": "signal_handler",
        "description": "PKRU is saved on signal entry and restored on return",
        "requirements": ["Ability to corrupt signal frame", "Control signal handler"],
        "difficulty": "hard"
    })

    # Method 3: Kernel transition
    bypass_methods.append({
        "method": "kernel_pkru_restore",
        "description": "Some syscalls may not properly restore PKRU",
        "requirements": ["Specific kernel version", "Syscall that modifies PKRU"],
        "difficulty": "very_hard"
    })

    return {
        "target_region": {
            "index": target_region,
            "start": hex(target.get("start", 0)),
            "pkey": pkey,
            "base_permissions": base_perms
        },
        "pkru_analysis": {
            "current_value": hex(pkru_value),
            "pkey_bits": f"AD={ad_bit}, WD={wd_bit}",
            "current_access": current_access
        },
        "bypass_possible": current_access != "read-write",
        "required_pkru": hex(required_pkru),
        "pkru_change_needed": hex(pkru_value ^ required_pkru),
        "bypass_methods": bypass_methods,
        "recommended_method": bypass_methods[0] if bypass_methods else None
    }


def main():
    """Démonstration de l'analyse CFI."""

    print("CFI/CET Analysis Demo")
    print("=" * 60)

    # Simulate binary with Intel CET
    binary_info = {
        "sections": [{"name": ".text", "addr": 0x401000}],
        "symbols": [
            {"name": "main", "type": "FUNC"},
            {"name": "helper", "type": "FUNC"}
        ],
        "gnu_properties": ["GNU_PROPERTY_X86_FEATURE_1_IBT"],
        "cfi_metadata": {
            "ibt_enabled": True,
            "shadow_stack_enabled": True,
            "protected_functions": 2,
            "valid_targets": {0x401000, 0x401100}
        }
    }

    cfi_result = analyze_cfi_protections(binary_info)
    print(f"\nCFI Type: {cfi_result['cfi_type']}")
    print(f"Coverage: {cfi_result['coverage']:.1f}%")
    print("Weaknesses:")
    for w in cfi_result["weaknesses"]:
        print(f"  - {w}")

    # Simulate shadow stack
    print("\n" + "=" * 60)
    print("Shadow Stack Simulation")

    call_seq = [
        {"type": "call", "target": 0x401000, "return_addr": 0x401050},
        {"type": "call", "target": 0x401100, "return_addr": 0x401020},
        {"type": "ret", "target": 0x401020},  # Valid return
        {"type": "ret", "target": 0x401050},  # Valid return
    ]

    ss_result = simulate_shadow_stack(call_seq, 0x7fff0000)
    print(f"Violations: {ss_result['violation_count']}")
    print(f"Final stack depth: {ss_result['final_state']['depth']}")

    # Simulate ROP attack (modified return)
    print("\nSimulating ROP attack...")
    attack_seq = [
        {"type": "call", "target": 0x401000, "return_addr": 0x401050},
        {"type": "ret", "target": 0xdeadbeef},  # Attacker-controlled!
    ]

    attack_result = simulate_shadow_stack(attack_seq, 0x7fff0000)
    print(f"Attack detected: {attack_result['violation_count'] > 0}")
    if attack_result["violations"]:
        v = attack_result["violations"][0]
        print(f"Violation: expected 0x{v['expected']:x}, got 0x{v['actual']:x}")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.4-d",
  "title": "Le Bypasseur de CFI",
  "module": "3.4",
  "tier": 2,
  "difficulty": 8,
  "xp_value": 650,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 60,
  "memory_limit_mb": 256,

  "test_cases": [
    {
      "id": "detect_intel_cet",
      "description": "Detect Intel CET from GNU properties",
      "input": {
        "function": "analyze_cfi_protections",
        "args": {
          "binary_info": {
            "sections": [],
            "symbols": [],
            "gnu_properties": ["GNU_PROPERTY_X86_FEATURE_1_IBT", "GNU_PROPERTY_X86_FEATURE_1_SHSTK"],
            "cfi_metadata": {"ibt_enabled": true, "shadow_stack_enabled": true, "protected_functions": 10}
          }
        }
      },
      "expected": {
        "cfi_type": "INTEL_CET",
        "details": {"cet": {"ibt_enabled": true, "shadow_stack": true}}
      },
      "points": 15
    },
    {
      "id": "detect_clang_cfi",
      "description": "Detect Clang CFI from symbols",
      "input": {
        "function": "analyze_cfi_protections",
        "args": {
          "binary_info": {
            "sections": [],
            "symbols": [{"name": "__cfi_check", "type": "FUNC"}, {"name": "__cfi_slowpath", "type": "FUNC"}],
            "gnu_properties": [],
            "cfi_metadata": {}
          }
        }
      },
      "expected": {
        "cfi_type": "CLANG_CFI"
      },
      "points": 10
    },
    {
      "id": "shadow_stack_valid",
      "description": "Valid call/ret sequence",
      "input": {
        "function": "simulate_shadow_stack",
        "args": {
          "call_sequence": [
            {"type": "call", "target": 4198400, "return_addr": 4198500},
            {"type": "ret", "target": 4198500}
          ],
          "initial_rsp": 140733193388032
        }
      },
      "expected": {
        "violation_count": 0,
        "final_state": {"depth": 0}
      },
      "points": 15
    },
    {
      "id": "shadow_stack_attack",
      "description": "Detect ROP attack via shadow stack mismatch",
      "input": {
        "function": "simulate_shadow_stack",
        "args": {
          "call_sequence": [
            {"type": "call", "target": 4198400, "return_addr": 4198500},
            {"type": "ret", "target": 3735928559}
          ],
          "initial_rsp": 140733193388032
        }
      },
      "expected": {
        "violation_count": 1,
        "violations": [{"type": "return_address_mismatch"}]
      },
      "points": 20
    },
    {
      "id": "find_endbr_gadgets",
      "description": "Identify ENDBR gadgets as CFI-valid",
      "input": {
        "function": "find_cfi_valid_gadgets",
        "args": {
          "gadgets": [
            {"address": 4198400, "instructions": ["endbr64", "pop rdi", "ret"], "gadget_type": "ENDBR_GADGET", "endbr_present": true},
            {"address": 4198500, "instructions": ["pop rsi", "ret"], "gadget_type": "REGULAR", "endbr_present": false}
          ],
          "cfi_metadata": {"cfi_type": "INTEL_CET", "valid_targets": [], "indirect_calls": [], "vtable_entries": {}, "ibt_enabled": true, "shadow_stack_enabled": false}
        }
      },
      "expected": {
        "valid_count": 1,
        "invalid_count": 1
      },
      "points": 15
    },
    {
      "id": "bypass_strategy_no_shstk",
      "description": "Strategy when shadow stack disabled",
      "input": {
        "function": "generate_cet_bypass_strategy",
        "args": {
          "cfi_metadata": {"cfi_type": "INTEL_CET", "valid_targets": [], "indirect_calls": [], "vtable_entries": {}, "ibt_enabled": true, "shadow_stack_enabled": false},
          "available_gadgets": [
            {"address": 4198400, "instructions": ["endbr64", "pop rdi", "ret"], "gadget_type": "ENDBR_GADGET", "endbr_present": true}
          ],
          "target_function": 4198656
        }
      },
      "expected": {
        "shadow_stack_enabled": false,
        "recommended_strategy": {"strategy": "traditional_rop"}
      },
      "points": 15
    },
    {
      "id": "ibt_compliance_check",
      "description": "Check IBT compliance of instruction block",
      "input": {
        "function": "check_ibt_compliance",
        "args": {
          "instructions": ["endbr64", "push rbp", "mov rbp, rsp", "call rax"]
        }
      },
      "expected": {
        "compliant": true,
        "starts_with_endbr": true
      },
      "points": 10
    },
    {
      "id": "mpk_bypass_analysis",
      "description": "Analyze MPK bypass for blocked region",
      "input": {
        "function": "simulate_mpk_bypass",
        "args": {
          "memory_regions": [{"start": 4096, "pkey": 1, "perms": "rw"}],
          "pkru_value": 1431655765,
          "target_region": 0
        }
      },
      "expected": {
        "pkru_analysis": {"current_access": "none"},
        "bypass_possible": true
      },
      "points": 15
    }
  ],

  "edge_cases": [
    {
      "id": "no_cfi",
      "description": "Binary without any CFI",
      "input": {
        "function": "analyze_cfi_protections",
        "args": {
          "binary_info": {"sections": [], "symbols": [], "gnu_properties": [], "cfi_metadata": {}}
        }
      },
      "expected_behavior": "Should return cfi_type: NONE with appropriate weaknesses"
    },
    {
      "id": "nested_calls",
      "description": "Deeply nested call stack",
      "input": {
        "function": "simulate_shadow_stack",
        "args": {
          "call_sequence": "10 nested calls followed by 10 returns",
          "initial_rsp": 140733193388032
        }
      },
      "expected_behavior": "Stack depth should track correctly through nesting"
    }
  ],

  "validation": {
    "required_functions": [
      "analyze_cfi_protections",
      "simulate_shadow_stack",
      "find_cfi_valid_gadgets",
      "generate_cet_bypass_strategy",
      "analyze_vtable_cfi",
      "check_ibt_compliance",
      "simulate_mpk_bypass"
    ],
    "required_classes": ["CFIType", "GadgetType", "Gadget", "CFIMetadata", "ShadowStackState"],
    "forbidden_imports": ["os.system", "subprocess", "ctypes"],
    "min_test_coverage": 80
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour cfi_bypasser.py
"""

import unittest


class TestCFIDetectionMutations(unittest.TestCase):
    """Tests de mutation pour la détection CFI."""

    def setUp(self):
        from cfi_bypasser import (
            analyze_cfi_protections, CFIType
        )
        self.analyze = analyze_cfi_protections
        self.CFIType = CFIType

    # Mutant 1: Wrong CFI type detection
    def test_mutant_cet_vs_clang(self):
        """MUTANT: Confusing Intel CET with Clang CFI."""
        cet_binary = {
            "sections": [],
            "symbols": [],
            "gnu_properties": ["GNU_PROPERTY_X86_FEATURE_1_IBT"],
            "cfi_metadata": {"ibt_enabled": True}
        }

        clang_binary = {
            "sections": [],
            "symbols": [{"name": "__cfi_check", "type": "FUNC"}],
            "gnu_properties": [],
            "cfi_metadata": {}
        }

        cet_result = self.analyze(cet_binary)
        clang_result = self.analyze(clang_binary)

        self.assertEqual(cet_result["cfi_type"], "INTEL_CET")
        self.assertEqual(clang_result["cfi_type"], "CLANG_CFI")
        self.assertNotEqual(cet_result["cfi_type"], clang_result["cfi_type"])

    # Mutant 2: Missing shadow stack detection
    def test_mutant_shadow_stack_detection(self):
        """MUTANT: Not detecting shadow stack enablement."""
        with_shstk = {
            "sections": [],
            "symbols": [],
            "gnu_properties": ["GNU_PROPERTY_X86_FEATURE_1_IBT", "GNU_PROPERTY_X86_FEATURE_1_SHSTK"],
            "cfi_metadata": {"shadow_stack_enabled": True}
        }

        without_shstk = {
            "sections": [],
            "symbols": [],
            "gnu_properties": ["GNU_PROPERTY_X86_FEATURE_1_IBT"],
            "cfi_metadata": {"shadow_stack_enabled": False}
        }

        result_with = self.analyze(with_shstk)
        result_without = self.analyze(without_shstk)

        self.assertTrue(result_with["details"]["cet"]["shadow_stack"])
        self.assertFalse(result_without["details"]["cet"]["shadow_stack"])


class TestShadowStackMutations(unittest.TestCase):
    """Tests de mutation pour la Shadow Stack."""

    def setUp(self):
        from cfi_bypasser import simulate_shadow_stack
        self.simulate = simulate_shadow_stack

    # Mutant 3: Not detecting return address mismatch
    def test_mutant_mismatch_detection(self):
        """MUTANT: Not reporting mismatch when return differs."""
        sequence = [
            {"type": "call", "target": 0x401000, "return_addr": 0x401050},
            {"type": "ret", "target": 0xDEADBEEF}  # Wrong return!
        ]

        result = self.simulate(sequence, 0x7fff0000)

        self.assertGreater(result["violation_count"], 0)
        self.assertEqual(result["violations"][0]["type"], "return_address_mismatch")

    # Mutant 4: Wrong stack depth tracking
    def test_mutant_stack_depth(self):
        """MUTANT: Incorrect depth calculation."""
        sequence = [
            {"type": "call", "target": 0x1000, "return_addr": 0x1100},
            {"type": "call", "target": 0x2000, "return_addr": 0x1200},
            {"type": "call", "target": 0x3000, "return_addr": 0x2100},
        ]

        result = self.simulate(sequence, 0x7fff0000)

        self.assertEqual(result["final_state"]["depth"], 3)

    # Mutant 5: Not detecting underflow
    def test_mutant_underflow_detection(self):
        """MUTANT: Missing underflow detection on extra ret."""
        sequence = [
            {"type": "ret", "target": 0x1000}  # No call before this!
        ]

        result = self.simulate(sequence, 0x7fff0000)

        self.assertGreater(result["violation_count"], 0)
        self.assertEqual(result["violations"][0]["type"], "shadow_stack_underflow")


class TestGadgetValidationMutations(unittest.TestCase):
    """Tests de mutation pour la validation des gadgets."""

    def setUp(self):
        from cfi_bypasser import (
            find_cfi_valid_gadgets, Gadget, GadgetType, CFIMetadata, CFIType
        )
        self.find_gadgets = find_cfi_valid_gadgets
        self.Gadget = Gadget
        self.GadgetType = GadgetType
        self.CFIMetadata = CFIMetadata
        self.CFIType = CFIType

    # Mutant 6: ENDBR gadgets marked as invalid
    def test_mutant_endbr_valid(self):
        """MUTANT: Rejecting valid ENDBR gadgets."""
        gadgets = [
            self.Gadget(0x401000, ["endbr64", "pop rdi", "ret"],
                       self.GadgetType.ENDBR_GADGET, endbr_present=True)
        ]

        cfi_meta = self.CFIMetadata(
            cfi_type=self.CFIType.INTEL_CET,
            valid_targets=set(),
            indirect_calls=[],
            vtable_entries={},
            ibt_enabled=True,
            shadow_stack_enabled=False
        )

        result = self.find_gadgets(gadgets, cfi_meta)

        self.assertEqual(result["valid_count"], 1)
        self.assertEqual(result["invalid_count"], 0)

    # Mutant 7: Regular gadgets not blocked by IBT
    def test_mutant_regular_blocked(self):
        """MUTANT: Not blocking regular gadgets under IBT."""
        gadgets = [
            self.Gadget(0x401000, ["pop rdi", "ret"],
                       self.GadgetType.REGULAR, endbr_present=False)
        ]

        cfi_meta = self.CFIMetadata(
            cfi_type=self.CFIType.INTEL_CET,
            valid_targets=set(),
            indirect_calls=[],
            vtable_entries={},
            ibt_enabled=True,
            shadow_stack_enabled=True
        )

        result = self.find_gadgets(gadgets, cfi_meta)

        self.assertEqual(result["valid_count"], 0)
        self.assertEqual(result["invalid_count"], 1)


class TestIBTComplianceMutations(unittest.TestCase):
    """Tests de mutation pour la vérification IBT."""

    def setUp(self):
        from cfi_bypasser import check_ibt_compliance
        self.check = check_ibt_compliance

    # Mutant 8: Not checking for ENDBR at start
    def test_mutant_endbr_start_check(self):
        """MUTANT: Not verifying ENDBR at beginning."""
        with_endbr = ["endbr64", "push rbp", "ret"]
        without_endbr = ["push rbp", "mov rbp, rsp", "ret"]

        result_with = self.check(with_endbr)
        result_without = self.check(without_endbr)

        self.assertTrue(result_with["compliant"])
        self.assertTrue(result_with["starts_with_endbr"])
        self.assertFalse(result_without["compliant"])
        self.assertFalse(result_without["starts_with_endbr"])

    # Mutant 9: Not detecting indirect branches
    def test_mutant_indirect_detection(self):
        """MUTANT: Missing indirect branch detection."""
        instrs = ["endbr64", "mov rax, [rbx]", "jmp rax", "ret"]

        result = self.check(instrs)

        self.assertGreater(len(result["indirect_branches"]), 0)
        indirect_types = [b["type"] for b in result["indirect_branches"]]
        self.assertIn("indirect_jmp", indirect_types)


class TestMPKBypassMutations(unittest.TestCase):
    """Tests de mutation pour le bypass MPK."""

    def setUp(self):
        from cfi_bypasser import simulate_mpk_bypass
        self.simulate = simulate_mpk_bypass

    # Mutant 10: Wrong PKRU bit decoding
    def test_mutant_pkru_decoding(self):
        """MUTANT: Incorrect PKRU bit interpretation."""
        regions = [{"start": 0x1000, "pkey": 1, "perms": "rw"}]

        # PKRU = 0x55555554 = 01010101...0100
        # pkey 0: 00 (full access)
        # pkey 1: 01 (AD=0, WD=1 = read-only)
        pkru = 0x55555554

        result = self.simulate(regions, pkru, 0)

        # pkey 1 with WD=1 should be read-only
        # Wait, the region is at index 0 but uses pkey 1
        self.assertEqual(result["pkru_analysis"]["current_access"], "read-only")


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Que signifie ENDBR64 dans le contexte d'Intel CET ?**

- [ ] A) Fin de bloc de code
- [x] B) Marqueur de cible valide pour branche indirecte
- [ ] C) Instruction de debug
- [ ] D) Terminaison de boucle

**Explication**: ENDBR64 (End Branch 64-bit) marque une cible valide pour les branches indirects. Sans cette instruction au début, un JMP/CALL indirect vers cette adresse déclenche une exception #CP.

---

### Question 2
**Comment la Shadow Stack détecte-t-elle une attaque ROP ?**

- [ ] A) En vérifiant la signature des gadgets
- [x] B) En comparant l'adresse de retour avec une copie sécurisée
- [ ] C) En analysant le flux de données
- [ ] D) En comptant le nombre de RET

**Explication**: La Shadow Stack maintient une copie matérielle des adresses de retour. Lors de RET, l'adresse sur la stack normale est comparée à celle sur la shadow stack. Une différence indique une corruption.

---

### Question 3
**Qu'est-ce qu'un gadget "call-preceded" et pourquoi peut-il bypasser IBT ?**

- [ ] A) Un gadget qui appelle une fonction, toujours bloqué par IBT
- [x] B) Un gadget après un CALL, atteint par fall-through sans vérification IBT
- [ ] C) Un gadget qui précède un CALL
- [ ] D) Un gadget avec ENDBR au milieu

**Explication**: Les gadgets call-preceded sont atteints par fall-through après un CALL (le CALL exécute, puis l'exécution continue). IBT ne vérifie que les cibles de branches, pas le fall-through.

---

### Question 4
**Quelle est la principale limitation de Clang CFI par rapport à Intel CET ?**

- [ ] A) Clang CFI est plus lent
- [ ] B) Clang CFI ne protège que les vtables
- [x] C) Clang CFI peut être bypassé par type confusion
- [ ] D) Clang CFI ne fonctionne pas sur x64

**Explication**: Clang CFI est type-based : il vérifie que le type du pointeur de fonction correspond. Une type confusion peut tromper cette vérification en faisant passer un objet d'un type pour un autre.

---

### Question 5
**Comment Intel MPK restreint-il l'accès mémoire ?**

- [ ] A) En modifiant les page tables
- [x] B) Via le registre PKRU qui définit les permissions par pkey
- [ ] C) En chiffrant les pages mémoire
- [ ] D) En utilisant de la mémoire ECC

**Explication**: MPK assigne un pkey (0-15) à chaque page. Le registre PKRU (32 bits, 2 bits par pkey) définit si l'accès et/ou l'écriture sont autorisés pour chaque pkey, sans modifier les page tables.

---

### Question 6
**Pourquoi la désactivation de la Shadow Stack affaiblit-elle considérablement CET ?**

- [ ] A) IBT devient aussi désactivé
- [ ] B) Les pages mémoire deviennent exécutables
- [x] C) ROP classique redevient possible avec des ENDBR gadgets
- [ ] D) Le binaire ne peut plus s'exécuter

**Explication**: Sans Shadow Stack, seul IBT protège le binaire. On peut construire des chaînes ROP en utilisant uniquement des gadgets commençant par ENDBR64, ce qui est plus restrictif mais faisable.

---

### Question 7
**Que se passe-t-il si un JMP indirect cible une adresse sans ENDBR64 avec IBT activé ?**

- [ ] A) Le saut est ignoré
- [ ] B) L'instruction ENDBR est insérée automatiquement
- [x] C) Une exception #CP (Control Protection) est levée
- [ ] D) Le programme continue normalement

**Explication**: IBT vérifie que chaque cible de branche indirecte commence par ENDBR32/ENDBR64. Si ce n'est pas le cas, une exception #CP est générée, terminant généralement le programme.

---

### Question 8
**Quelle stratégie de bypass est la plus viable contre CET avec Shadow Stack activée ?**

- [ ] A) Bruteforce des adresses de retour
- [ ] B) ROP classique avec gadgets standards
- [x] C) Exploitation des gestionnaires d'exception ou signaux
- [ ] D) Utilisation de JOP (Jump-Oriented Programming)

**Explication**: Avec Shadow Stack activée, modifier les adresses de retour est détecté. Les gestionnaires d'exception et signaux peuvent modifier le contexte et potentiellement créer des inconsistances entre les deux stacks.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Confondre IBT et Shadow Stack**: IBT protège les JMP/CALL indirects, Shadow Stack protège RET.

2. **Oublier les call-preceded gadgets**: Ces gadgets ne sont pas vérifiés par IBT.

3. **PKRU mal décodé**: 2 bits par pkey, pas 1. AD et WD sont distincts.

4. **Assumer que ENDBR = protection totale**: Il existe des ENDBR gadgets utiles.

5. **Ignorer les exceptions**: Exception handlers peuvent bypass Shadow Stack.

### Bonnes Pratiques

```python
# Toujours vérifier les deux composants de CET séparément
def assess_cet_protection(binary_info):
    ibt = binary_info.get("ibt_enabled", False)
    shstk = binary_info.get("shadow_stack_enabled", False)

    if ibt and shstk:
        return "Full CET protection"
    elif ibt:
        return "Partial CET - ROP via ENDBR gadgets possible"
    elif shstk:
        return "Partial CET - JOP/COP possible"
    else:
        return "No CET protection"

# Rechercher systematiquement les ENDBR gadgets
ENDBR64 = b'\xf3\x0f\x1e\xfa'
def find_all_endbr(code: bytes) -> list[int]:
    offsets = []
    pos = 0
    while True:
        idx = code.find(ENDBR64, pos)
        if idx == -1:
            break
        offsets.append(idx)
        pos = idx + 1
    return offsets
```

---

## Section 8 : Ressources et Références

### Documentation Intel
- Intel CET Specification: software.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html
- Intel MPK: lwn.net/Articles/643797/

### Papers Académiques
- "Control-Flow Integrity: Principles, Implementations, and Applications" - Abadi et al.
- "Bypassing Intel CET with Counterfeit Objects" - USENIX 2022

### Outils
- ROPgadget avec support ENDBR: github.com/JonathanSalwan/ROPgadget
- checksec.sh: Détection des protections

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| analyze_cfi_protections | 20 |
| simulate_shadow_stack | 25 |
| find_cfi_valid_gadgets | 20 |
| generate_cet_bypass_strategy | 15 |
| check_ibt_compliance | 10 |
| simulate_mpk_bypass | 10 |
| **Total** | **100** |

### Seuils
- **A** (90-100): Expert en CFI/CET, capable de bypass avancés
- **B** (75-89): Bonne maîtrise des concepts
- **C** (60-74): Compréhension de base suffisante
- **D** (45-59): Notions à approfondir
- **F** (<45): Revoir le cours intégré
