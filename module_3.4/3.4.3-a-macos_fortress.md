# Exercice 3.4.3-a : macos_fortress

**Module :**
3.4.3 — macOS/iOS Specifics

**Concept :**
a — Analyse de securite macOS et format Mach-O

**Difficulte :**
★★★★★★★★☆☆ (8/10)

**Type :**
code

**Tiers :**
2 — Concepts combines

**Langage :**
Python 3.12

**Prerequis :**
- Exercice 3.4.1 (Fondamentaux assembleur)
- Comprehension des formats binaires (ELF)
- Bases de securite systeme

**Domaines :**
BinFormat, Security, macOS

**Duree estimee :**
90 min

**XP Base :**
250

**Complexite :**
T4 O(n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`macos_fortress.py`

**Fonctions autorisees :**
- `json` (module standard)
- `struct` (parsing binaire)
- `sys` (arguments)
- `re` (expressions regulieres)
- Fonctions built-in Python

**Fonctions interdites :**
- `lief` ou autres parsers Mach-O externes
- `macholib`
- Tout module d'analyse binaire externe

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Mr. Robot"

*"Control is an illusion."*

Dans **Mr. Robot**, Elliot Alderson doit souvent penetrer des systemes Apple ultra-securises. macOS est repute pour sa securite renforcee : signature de code, SIP, Hardened Runtime... Comme Elliot qui analyse chaque couche de securite avant de frapper, tu vas apprendre a dissequer les protections macOS.

Le format **Mach-O** (Mach Object) est le format binaire natif de macOS et iOS, equivalent de l'ELF sous Linux. Chaque binaire macOS est une forteresse avec plusieurs niveaux de protection. Ta mission : apprendre a lire les plans de cette forteresse.

#### 2.4.2 Enonce Academique

Le format Mach-O est la base de tout executable macOS/iOS. Comprendre ce format est essentiel pour :
- **Analyse de malware** macOS
- **Reverse engineering** d'applications iOS
- **Developpement d'exploits** pour l'ecosysteme Apple
- **Analyse forensique** de systemes compromis

**Ta mission :**

Implementer un analyseur de securite Mach-O style `checksec` qui :

1. **Parse** les headers Mach-O (magic, CPU type, file type)
2. **Analyse** les Load Commands (segments, libraries)
3. **Detecte** la signature de code (LC_CODE_SIGNATURE)
4. **Identifie** les entitlements et leur impact securite
5. **Evalue** la compatibilite Hardened Runtime
6. **Determine** les restrictions SIP applicables

**Structure Mach-O :**
```
+------------------+
| Mach-O Header    |  <- Magic, CPU type, flags
+------------------+
| Load Commands    |  <- Segments, libraries, signature
+------------------+
| Segment __TEXT   |  <- Code executable
+------------------+
| Segment __DATA   |  <- Donnees modifiables
+------------------+
| Segment __LINKEDIT|  <- Signature, symbols
+------------------+
```

**Entree :**
```json
{
  "mach_o_header": {
    "magic": "0xFEEDFACF",
    "cpu_type": "0x0100000C",
    "cpu_subtype": "0x00000000",
    "file_type": 2,
    "ncmds": 19,
    "sizeofcmds": 1872,
    "flags": "0x00200085"
  },
  "load_commands": [
    {"cmd": "LC_SEGMENT_64", "segname": "__TEXT", "vmaddr": "0x100000000", "vmsize": "0x4000", "fileoff": 0, "filesize": 16384, "maxprot": 5, "initprot": 5},
    {"cmd": "LC_SEGMENT_64", "segname": "__DATA", "vmaddr": "0x100004000", "vmsize": "0x4000", "fileoff": 16384, "filesize": 16384, "maxprot": 3, "initprot": 3},
    {"cmd": "LC_SEGMENT_64", "segname": "__LINKEDIT", "vmaddr": "0x100008000", "vmsize": "0x4000", "fileoff": 32768, "filesize": 4096, "maxprot": 1, "initprot": 1},
    {"cmd": "LC_CODE_SIGNATURE", "dataoff": 36864, "datasize": 320},
    {"cmd": "LC_LOAD_DYLIB", "name": "/usr/lib/libSystem.B.dylib"}
  ],
  "entitlements": {
    "com.apple.security.cs.allow-jit": false,
    "com.apple.security.cs.allow-unsigned-executable-memory": false,
    "com.apple.security.cs.disable-library-validation": false,
    "com.apple.security.app-sandbox": true,
    "com.apple.security.get-task-allow": false
  }
}
```

**Sortie :**
```json
{
  "binary_info": {
    "magic": "MH_MAGIC_64",
    "cpu_type": "ARM64",
    "file_type": "MH_EXECUTE",
    "is_pie": true,
    "is_fat": false
  },
  "security_analysis": {
    "code_signed": true,
    "hardened_runtime": true,
    "library_validation": true,
    "allow_jit": false,
    "allow_unsigned_memory": false,
    "sandboxed": true,
    "sip_protected": true,
    "get_task_allow": false
  },
  "segments": {
    "__TEXT": {"executable": true, "writable": false},
    "__DATA": {"executable": false, "writable": true},
    "__LINKEDIT": {"executable": false, "writable": false}
  },
  "dylibs": ["/usr/lib/libSystem.B.dylib"],
  "risk_assessment": {
    "level": "low",
    "weaknesses": [],
    "notes": ["Hardened runtime enabled", "App sandbox active"]
  }
}
```

**Magic Numbers Mach-O :**
| Magic | Description |
|-------|-------------|
| 0xFEEDFACE | MH_MAGIC (32-bit) |
| 0xFEEDFACF | MH_MAGIC_64 (64-bit) |
| 0xCAFEBABE | FAT_MAGIC (Universal) |
| 0xBEBAFECA | FAT_CIGAM (Universal, swapped) |

**CPU Types :**
| Value | Architecture |
|-------|--------------|
| 0x07 | x86 |
| 0x01000007 | x86_64 |
| 0x0C | ARM |
| 0x0100000C | ARM64 |

**File Types :**
| Value | Type |
|-------|------|
| 1 | MH_OBJECT |
| 2 | MH_EXECUTE |
| 6 | MH_DYLIB |
| 8 | MH_BUNDLE |

**Flags importants :**
| Flag | Valeur | Description |
|------|--------|-------------|
| MH_PIE | 0x200000 | Position Independent Executable |
| MH_NO_HEAP_EXECUTION | 0x1000000 | Heap non executable |
| MH_ALLOW_STACK_EXECUTION | 0x20000 | Stack executable (dangereux!) |

**Exemples :**

| Scenario | Risk Level |
|----------|------------|
| Hardened + Sandbox + Signed | low |
| Signed but allow-jit | medium |
| No signature | high |
| get-task-allow = true (debug) | critical |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
macos_fortress.py - Analyseur de securite Mach-O
"""

import json
import sys
import struct

# Magic numbers
MH_MAGIC = 0xFEEDFACE
MH_MAGIC_64 = 0xFEEDFACF
FAT_MAGIC = 0xCAFEBABE
FAT_CIGAM = 0xBEBAFECA

# CPU Types
CPU_TYPE_X86 = 0x07
CPU_TYPE_X86_64 = 0x01000007
CPU_TYPE_ARM = 0x0C
CPU_TYPE_ARM64 = 0x0100000C

# File Types
MH_OBJECT = 1
MH_EXECUTE = 2
MH_DYLIB = 6
MH_BUNDLE = 8

# Flags
MH_PIE = 0x200000
MH_NO_HEAP_EXECUTION = 0x1000000
MH_ALLOW_STACK_EXECUTION = 0x20000

def parse_magic(magic_str: str) -> dict:
    """Analyse le magic number Mach-O."""
    pass

def parse_cpu_type(cpu_type_str: str) -> str:
    """Identifie le type de CPU."""
    pass

def analyze_flags(flags_str: str) -> dict:
    """Analyse les flags de securite."""
    pass

def analyze_segments(load_commands: list) -> dict:
    """Analyse les permissions des segments."""
    pass

def analyze_entitlements(entitlements: dict) -> dict:
    """Analyse les entitlements et leur impact securite."""
    pass

def assess_risk(security_analysis: dict) -> dict:
    """Evalue le niveau de risque global."""
    pass

def analyze_macho(data: dict) -> dict:
    """
    Analyse complete d'un binaire Mach-O.

    Args:
        data: Dictionnaire contenant header, load_commands, entitlements

    Returns:
        Analyse de securite complete
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'heritage NeXT

Le format Mach-O vient de **NeXTSTEP**, le systeme d'exploitation cree par Steve Jobs apres son depart d'Apple en 1985. Quand Apple a rachete NeXT en 1997, ils ont herite de ce format binaire qui est devenu la base de macOS et iOS.

Le "Mach" dans Mach-O fait reference au **microkernel Mach** developpe a Carnegie Mellon University, qui forme le coeur de XNU (le kernel de macOS).

### Universal Binaries (Fat Binaries)

Apple a utilise les "Fat Binaries" lors de trois grandes transitions :
1. **68k vers PowerPC** (1994)
2. **PowerPC vers Intel** (2006)
3. **Intel vers Apple Silicon** (2020)

Un Fat Binary contient plusieurs architectures dans un seul fichier, permettant la compatibilite multi-plateforme.

### System Integrity Protection (SIP)

Introduit avec El Capitan (2015), SIP est une revolution dans la securite macOS :
- Meme root ne peut pas modifier les fichiers systeme
- Protection contre les rootkits kernel
- Verification de l'integrite au boot

Pour contourner SIP, il faut booter en Recovery Mode et executer `csrutil disable` - une action volontaire qui necessite un acces physique.

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Chercheur en securite Apple / iOS Security Researcher**

Les chercheurs en securite Apple sont parmi les plus recherches au monde :
- **Bug bounties** Apple jusqu'a $2M pour un exploit kernel iOS
- **Jailbreak developers** analysent les protections pour les contourner
- **Forensic analysts** extraient des donnees d'iPhones pour les enquetes

**Cas d'usage concret :**

Chez **Cellebrite** ou **GrayKey** (outils d'extraction iOS pour les forces de l'ordre) :
- Analyse des binaires systeme iOS pour trouver des vulnerabilites
- Bypass du Secure Enclave pour extraire les cles de chiffrement
- Exploitation de failles dans les parsers Mach-O

Le programme **Apple Security Research Device** (SRD) fournit des iPhones specialement configures aux chercheurs agrees pour faciliter la recherche de vulnerabilites.

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
macos_fortress.py  test_binary.json

$ cat test_binary.json
{"mach_o_header": {"magic": "0xFEEDFACF", "cpu_type": "0x0100000C", "file_type": 2, "flags": "0x00200085", "ncmds": 15}, "load_commands": [{"cmd": "LC_SEGMENT_64", "segname": "__TEXT", "vmaddr": "0x100000000", "vmsize": "0x4000", "maxprot": 5, "initprot": 5}, {"cmd": "LC_SEGMENT_64", "segname": "__DATA", "vmaddr": "0x100004000", "vmsize": "0x4000", "maxprot": 3, "initprot": 3}, {"cmd": "LC_CODE_SIGNATURE", "dataoff": 32768, "datasize": 256}], "entitlements": {"com.apple.security.app-sandbox": true, "com.apple.security.cs.allow-jit": false}}

$ python3 macos_fortress.py test_binary.json
{"binary_info": {"magic": "MH_MAGIC_64", "cpu_type": "ARM64", "file_type": "MH_EXECUTE", "is_pie": true}, "security_analysis": {"code_signed": true, "hardened_runtime": true, "sandboxed": true, "allow_jit": false}, "risk_assessment": {"level": "low", "weaknesses": []}}

$ # Test avec un binaire non signe
$ echo '{"mach_o_header": {"magic": "0xFEEDFACF", "cpu_type": "0x01000007", "file_type": 2, "flags": "0x00000085"}, "load_commands": [], "entitlements": {}}' | python3 macos_fortress.py -
{"binary_info": {"magic": "MH_MAGIC_64", "cpu_type": "x86_64", "file_type": "MH_EXECUTE", "is_pie": false}, "security_analysis": {"code_signed": false, "hardened_runtime": false}, "risk_assessment": {"level": "high", "weaknesses": ["No code signature", "PIE disabled"]}}
```

---

## SECTION 3.1 : BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★☆ (9/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
BinFormat, Security, Crypto, macOS

### 3.1.1 Consigne Bonus

**Extension "Deep Analysis" :**

Etendre l'analyseur pour :

1. **Parser les certificats** de signature (extraire CN, OU, O)
2. **Detecter les dylib hijacking** potentiels (LC_RPATH vulnerables)
3. **Analyser les sections** (__objc_classlist, __objc_protolist)
4. **Identifier les frameworks** prives utilises (risque App Store)
5. **Calculer l'entropie** des sections pour detecter le packing

**Contraintes supplementaires :**
```
+-----------------------------------------------+
|  Parser CN/OU des certificats de signature    |
|  Detecter @rpath/@loader_path vulnerables     |
|  Lister les classes Objective-C               |
|  Flag si frameworks prives Apple utilises     |
|  Entropie > 7.5 = potentiellement packe       |
+-----------------------------------------------+
```

### 3.1.2 Prototype Bonus

```python
def analyze_code_signature(signature_data: dict) -> dict:
    """
    Analyse detaillee de la signature de code.

    Returns:
        Dictionnaire avec issuer, subject, validity, team_id
    """
    pass

def detect_dylib_hijacking(load_commands: list) -> list:
    """
    Detecte les vulnerabilites de dylib hijacking.

    Returns:
        Liste des chemins @rpath/@loader_path vulnerables
    """
    pass

def calculate_section_entropy(section_data: bytes) -> float:
    """
    Calcule l'entropie de Shannon d'une section.

    Returns:
        Entropie (0.0 - 8.0)
    """
    pass
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Signature | Presence detectee | Certificats parses |
| Dylibs | Listees | Hijacking detecte |
| Sections | Permissions | Entropie + classes ObjC |
| Risk | Basique | Avance avec recommendations |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| magic_64 | magic=0xFEEDFACF | MH_MAGIC_64 | 5 |
| magic_32 | magic=0xFEEDFACE | MH_MAGIC | 5 |
| magic_fat | magic=0xCAFEBABE | FAT_MAGIC | 5 |
| cpu_arm64 | cpu_type=0x0100000C | ARM64 | 5 |
| cpu_x64 | cpu_type=0x01000007 | x86_64 | 5 |
| pie_enabled | flags=0x00200085 | is_pie=true | 10 |
| pie_disabled | flags=0x00000085 | is_pie=false | 10 |
| signed | LC_CODE_SIGNATURE present | code_signed=true | 10 |
| unsigned | Pas de LC_CODE_SIGNATURE | code_signed=false | 10 |
| sandbox | entitlement app-sandbox=true | sandboxed=true | 10 |
| risk_low | signe + hardened + sandbox | level=low | 10 |
| risk_high | pas signe | level=high | 10 |
| segments | TEXT/DATA/LINKEDIT | Permissions correctes | 5 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
macos_fortress.py - Solution de reference
"""

import json
import sys

# Constants
MH_MAGIC = 0xFEEDFACE
MH_MAGIC_64 = 0xFEEDFACF
FAT_MAGIC = 0xCAFEBABE
FAT_CIGAM = 0xBEBAFECA

CPU_TYPES = {
    0x07: "x86",
    0x01000007: "x86_64",
    0x0C: "ARM",
    0x0100000C: "ARM64"
}

FILE_TYPES = {
    1: "MH_OBJECT",
    2: "MH_EXECUTE",
    6: "MH_DYLIB",
    8: "MH_BUNDLE"
}

# Flags
MH_PIE = 0x200000
MH_NO_HEAP_EXECUTION = 0x1000000
MH_ALLOW_STACK_EXECUTION = 0x20000

def parse_hex(value) -> int:
    """Parse une valeur hexadecimale."""
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        value = value.strip()
        if value.lower().startswith('0x'):
            return int(value, 16)
        return int(value, 16)
    return 0

def parse_magic(magic_str: str) -> dict:
    """Analyse le magic number Mach-O."""
    magic = parse_hex(magic_str)

    magic_names = {
        MH_MAGIC: ("MH_MAGIC", False, False),
        MH_MAGIC_64: ("MH_MAGIC_64", True, False),
        FAT_MAGIC: ("FAT_MAGIC", False, True),
        FAT_CIGAM: ("FAT_CIGAM", False, True)
    }

    name, is_64, is_fat = magic_names.get(magic, ("UNKNOWN", False, False))

    return {
        "name": name,
        "is_64bit": is_64,
        "is_fat": is_fat
    }

def parse_cpu_type(cpu_type_str: str) -> str:
    """Identifie le type de CPU."""
    cpu_type = parse_hex(cpu_type_str)
    return CPU_TYPES.get(cpu_type, f"UNKNOWN(0x{cpu_type:x})")

def analyze_flags(flags_str: str) -> dict:
    """Analyse les flags de securite."""
    flags = parse_hex(flags_str)

    return {
        "is_pie": bool(flags & MH_PIE),
        "no_heap_execution": bool(flags & MH_NO_HEAP_EXECUTION),
        "allow_stack_execution": bool(flags & MH_ALLOW_STACK_EXECUTION),
        "raw_flags": f"0x{flags:08x}"
    }

def analyze_segments(load_commands: list) -> dict:
    """Analyse les permissions des segments."""
    segments = {}

    # Protection bits: R=1, W=2, X=4
    for cmd in load_commands:
        if cmd.get("cmd") == "LC_SEGMENT_64" or cmd.get("cmd") == "LC_SEGMENT":
            segname = cmd.get("segname", "")
            initprot = cmd.get("initprot", 0)

            segments[segname] = {
                "executable": bool(initprot & 4),
                "writable": bool(initprot & 2),
                "readable": bool(initprot & 1),
                "vmaddr": cmd.get("vmaddr", "0x0"),
                "vmsize": cmd.get("vmsize", "0x0")
            }

    return segments

def extract_dylibs(load_commands: list) -> list:
    """Extrait la liste des dylibs."""
    dylibs = []

    for cmd in load_commands:
        if cmd.get("cmd") in ["LC_LOAD_DYLIB", "LC_LOAD_WEAK_DYLIB", "LC_REEXPORT_DYLIB"]:
            name = cmd.get("name", "")
            if name:
                dylibs.append(name)

    return dylibs

def has_code_signature(load_commands: list) -> bool:
    """Verifie si le binaire a une signature de code."""
    for cmd in load_commands:
        if cmd.get("cmd") == "LC_CODE_SIGNATURE":
            return True
    return False

def analyze_entitlements(entitlements: dict) -> dict:
    """Analyse les entitlements et leur impact securite."""
    if not entitlements:
        return {
            "sandboxed": False,
            "allow_jit": False,
            "allow_unsigned_memory": False,
            "library_validation": True,  # Default on
            "get_task_allow": False,
            "hardened_runtime": True  # Assume if no weakening entitlements
        }

    # Check for security-weakening entitlements
    allow_jit = entitlements.get("com.apple.security.cs.allow-jit", False)
    allow_unsigned = entitlements.get("com.apple.security.cs.allow-unsigned-executable-memory", False)
    disable_lib_val = entitlements.get("com.apple.security.cs.disable-library-validation", False)
    sandboxed = entitlements.get("com.apple.security.app-sandbox", False)
    get_task_allow = entitlements.get("com.apple.security.get-task-allow", False)

    # Hardened runtime is weakened if any of these are true
    hardened = not (allow_jit or allow_unsigned or disable_lib_val)

    return {
        "sandboxed": sandboxed,
        "allow_jit": allow_jit,
        "allow_unsigned_memory": allow_unsigned,
        "library_validation": not disable_lib_val,
        "get_task_allow": get_task_allow,
        "hardened_runtime": hardened
    }

def assess_risk(binary_info: dict, security_analysis: dict) -> dict:
    """Evalue le niveau de risque global."""
    weaknesses = []
    notes = []

    # Check for weaknesses
    if not security_analysis.get("code_signed", False):
        weaknesses.append("No code signature")

    if not binary_info.get("is_pie", False):
        weaknesses.append("PIE disabled")

    if security_analysis.get("allow_jit", False):
        weaknesses.append("JIT allowed (hardened runtime weakened)")

    if security_analysis.get("allow_unsigned_memory", False):
        weaknesses.append("Unsigned executable memory allowed")

    if not security_analysis.get("library_validation", True):
        weaknesses.append("Library validation disabled")

    if security_analysis.get("get_task_allow", False):
        weaknesses.append("get-task-allow enabled (debug build)")

    if binary_info.get("allow_stack_execution", False):
        weaknesses.append("Stack execution allowed")

    # Positive notes
    if security_analysis.get("hardened_runtime", False):
        notes.append("Hardened runtime enabled")

    if security_analysis.get("sandboxed", False):
        notes.append("App sandbox active")

    if security_analysis.get("code_signed", False):
        notes.append("Code signed")

    # Determine risk level
    if security_analysis.get("get_task_allow", False):
        level = "critical"
    elif len(weaknesses) >= 3:
        level = "high"
    elif len(weaknesses) >= 1:
        level = "medium"
    else:
        level = "low"

    return {
        "level": level,
        "weaknesses": weaknesses,
        "notes": notes
    }

def analyze_macho(data: dict) -> dict:
    """Analyse complete d'un binaire Mach-O."""
    header = data.get("mach_o_header", {})
    load_commands = data.get("load_commands", [])
    entitlements = data.get("entitlements", {})

    # Parse magic
    magic_info = parse_magic(header.get("magic", "0x0"))

    # Parse flags
    flags_info = analyze_flags(header.get("flags", "0x0"))

    # Binary info
    binary_info = {
        "magic": magic_info["name"],
        "cpu_type": parse_cpu_type(header.get("cpu_type", "0x0")),
        "file_type": FILE_TYPES.get(header.get("file_type", 0), "UNKNOWN"),
        "is_pie": flags_info["is_pie"],
        "is_fat": magic_info["is_fat"],
        "is_64bit": magic_info["is_64bit"],
        "allow_stack_execution": flags_info["allow_stack_execution"],
        "no_heap_execution": flags_info["no_heap_execution"]
    }

    # Security analysis
    entitlement_info = analyze_entitlements(entitlements)

    security_analysis = {
        "code_signed": has_code_signature(load_commands),
        "hardened_runtime": entitlement_info["hardened_runtime"],
        "library_validation": entitlement_info["library_validation"],
        "allow_jit": entitlement_info["allow_jit"],
        "allow_unsigned_memory": entitlement_info["allow_unsigned_memory"],
        "sandboxed": entitlement_info["sandboxed"],
        "get_task_allow": entitlement_info["get_task_allow"]
    }

    # Segments
    segments = analyze_segments(load_commands)

    # Dylibs
    dylibs = extract_dylibs(load_commands)

    # Risk assessment
    risk = assess_risk(binary_info, security_analysis)

    return {
        "binary_info": binary_info,
        "security_analysis": security_analysis,
        "segments": segments,
        "dylibs": dylibs,
        "risk_assessment": risk
    }

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: macos_fortress.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = analyze_macho(data)
    print(json.dumps(result))

if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptees

```python
# Alternative 1: Utilisation de dataclasses
from dataclasses import dataclass, asdict

@dataclass
class MachOBinaryInfo:
    magic: str
    cpu_type: str
    file_type: str
    is_pie: bool
    is_fat: bool

def analyze_macho_alt(data: dict) -> dict:
    info = MachOBinaryInfo(...)
    return asdict(info)
```

```python
# Alternative 2: Approche fonctionnelle avec pipeline
def analyze_macho_functional(data: dict) -> dict:
    pipeline = [
        parse_header,
        analyze_security,
        assess_risk
    ]
    result = data
    for step in pipeline:
        result = step(result)
    return result
```

### 4.5 Solutions refusees (avec explications)

```python
# REFUSE: Ne gere pas les valeurs hexadecimales en string
def parse_flags_bad(flags):
    return flags & MH_PIE  # Echoue si flags = "0x200085"

# Pourquoi c'est faux: Les entrees peuvent etre en string hex
```

```python
# REFUSE: Assume que tous les champs sont presents
def analyze_bad(data):
    return {
        "cpu": CPU_TYPES[data["mach_o_header"]["cpu_type"]]
    }  # KeyError si cpu_type absent

# Pourquoi c'est faux: Doit gerer les champs manquants
```

### 4.6 Solution bonus de reference

```python
import math

def calculate_entropy(data: bytes) -> float:
    """Calcule l'entropie de Shannon."""
    if not data:
        return 0.0

    freq = {}
    for byte in data:
        freq[byte] = freq.get(byte, 0) + 1

    length = len(data)
    entropy = 0.0

    for count in freq.values():
        p = count / length
        entropy -= p * math.log2(p)

    return entropy

def detect_dylib_hijacking(load_commands: list) -> list:
    """Detecte les chemins vulnerables."""
    vulnerabilities = []

    for cmd in load_commands:
        if cmd.get("cmd") == "LC_RPATH":
            rpath = cmd.get("path", "")
            if "@loader_path" in rpath or "@executable_path" in rpath:
                vulnerabilities.append({
                    "type": "rpath_injection",
                    "path": rpath,
                    "risk": "medium"
                })

    for cmd in load_commands:
        if cmd.get("cmd") == "LC_LOAD_DYLIB":
            name = cmd.get("name", "")
            if name.startswith("@rpath/"):
                vulnerabilities.append({
                    "type": "dylib_hijacking",
                    "dylib": name,
                    "risk": "high"
                })

    return vulnerabilities
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "macos_fortress",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 2,
  "tier_info": "Concepts combines",
  "tags": ["macos", "mach-o", "security", "binary-analysis", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_macho",
    "prototype": "def analyze_macho(data: dict) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "data", "type": "dict"}
    ]
  },

  "driver": {
    "reference_file": "references/ref_solution.py",

    "edge_cases": [
      {
        "name": "empty_input",
        "args": [{"mach_o_header": {}, "load_commands": [], "entitlements": {}}],
        "expected_keys": ["binary_info", "security_analysis", "risk_assessment"]
      },
      {
        "name": "arm64_signed_sandboxed",
        "args": [{"mach_o_header": {"magic": "0xFEEDFACF", "cpu_type": "0x0100000C", "file_type": 2, "flags": "0x00200085"}, "load_commands": [{"cmd": "LC_CODE_SIGNATURE"}], "entitlements": {"com.apple.security.app-sandbox": true}}],
        "check": "result['risk_assessment']['level'] == 'low'"
      },
      {
        "name": "unsigned_x64",
        "args": [{"mach_o_header": {"magic": "0xFEEDFACF", "cpu_type": "0x01000007", "file_type": 2, "flags": "0x85"}, "load_commands": [], "entitlements": {}}],
        "check": "result['risk_assessment']['level'] in ['high', 'medium']"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 300
    }
  },

  "norm": {
    "allowed_functions": ["json", "sys", "struct", "re"],
    "forbidden_functions": ["lief", "macholib"],
    "check_security": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A (Logic): Inverse le sens de PIE
def analyze_flags_mutant_a(flags_str):
    flags = parse_hex(flags_str)
    return {
        "is_pie": not bool(flags & MH_PIE)  # INVERSE!
    }

# Pourquoi c'est faux: PIE=1 signifie PIE active, pas desactive
```

```python
# Mutant B (Boundary): Ne gere pas les magic numbers big-endian
def parse_magic_mutant_b(magic_str):
    magic = parse_hex(magic_str)
    if magic == MH_MAGIC_64:
        return {"name": "MH_MAGIC_64"}
    return {"name": "UNKNOWN"}  # Manque FAT_CIGAM!

# Pourquoi c'est faux: Les Fat binaries peuvent etre en big-endian
```

```python
# Mutant C (Safety): Crash si entitlements manquant
def analyze_entitlements_mutant_c(entitlements):
    return {
        "sandboxed": entitlements["com.apple.security.app-sandbox"]
    }  # KeyError!

# Pourquoi c'est faux: Doit utiliser .get() avec default
```

```python
# Mutant D (Return): Risk assessment toujours "low"
def assess_risk_mutant_d(binary_info, security_analysis):
    return {"level": "low", "weaknesses": []}

# Pourquoi c'est faux: Ne detecte pas les faiblesses
```

```python
# Mutant E (Parse): Ne convertit pas les hex strings
def parse_cpu_type_mutant_e(cpu_type_str):
    return CPU_TYPES.get(cpu_type_str, "UNKNOWN")  # Cherche string, pas int!

# Pourquoi c'est faux: cpu_type peut etre "0x0100000C" (string)
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

1. **Format Mach-O** : Structure des binaires macOS/iOS
2. **Mecanismes de securite Apple** : SIP, Hardened Runtime, Code Signing
3. **Entitlements** : Permissions et leur impact securite
4. **Analyse binaire** : Parsing de headers et metadata

### 5.2 LDA - Traduction litterale en francais (MAJUSCULES)

```
FONCTION analyze_macho QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAMETRE data QUI EST UN DICTIONNAIRE
DEBUT FONCTION
    DECLARER header COMME DICTIONNAIRE
    DECLARER load_commands COMME LISTE
    DECLARER entitlements COMME DICTIONNAIRE

    AFFECTER data['mach_o_header'] OU DICTIONNAIRE VIDE A header
    AFFECTER data['load_commands'] OU LISTE VIDE A load_commands
    AFFECTER data['entitlements'] OU DICTIONNAIRE VIDE A entitlements

    DECLARER magic_info COMME RESULTAT DE parse_magic(header['magic'])
    DECLARER flags_info COMME RESULTAT DE analyze_flags(header['flags'])

    CONSTRUIRE binary_info AVEC magic, cpu_type, file_type, is_pie

    POUR CHAQUE cmd DANS load_commands FAIRE
        SI cmd['cmd'] EST EGAL A 'LC_CODE_SIGNATURE' ALORS
            AFFECTER VRAI A code_signed
        FIN SI
    FIN POUR

    APPELER assess_risk AVEC binary_info ET security_analysis

    RETOURNER DICTIONNAIRE AVEC binary_info, security_analysis, risk_assessment
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Analyse de securite Mach-O
---
1. EXTRAIRE les donnees d'entree :
   a. Header Mach-O (magic, cpu_type, flags)
   b. Load Commands (segments, signature, dylibs)
   c. Entitlements (permissions)

2. PARSER le magic number :
   - SI 0xFEEDFACF : binaire 64-bit
   - SI 0xCAFEBABE : Fat/Universal binary

3. ANALYSER les flags :
   - VERIFIER si MH_PIE (0x200000) est set
   - VERIFIER si stack execution est autorisee

4. PARCOURIR les Load Commands :
   - DETECTER LC_CODE_SIGNATURE pour signature
   - EXTRAIRE les segments et leurs permissions
   - LISTER les dylibs chargees

5. EVALUER les entitlements :
   - IDENTIFIER les permissions dangereuses
   - DETERMINER si Hardened Runtime est affaibli

6. CALCULER le niveau de risque :
   - CRITICAL si get-task-allow
   - HIGH si pas signe ou plusieurs faiblesses
   - MEDIUM si une faiblesse mineure
   - LOW si tout est securise
```

### 5.3 Visualisation ASCII

```
                     FORMAT MACH-O
    +================================================+
    |                                                |
    |   MACH-O HEADER (28-32 bytes)                  |
    |   +------------------------------------------+ |
    |   | Magic:     0xFEEDFACF (64-bit)          | |
    |   | CPU Type:  ARM64 (0x0100000C)           | |
    |   | File Type: MH_EXECUTE (2)               | |
    |   | Flags:     MH_PIE | MH_TWOLEVEL         | |
    |   | N cmds:    19 load commands             | |
    |   +------------------------------------------+ |
    |                                                |
    |   LOAD COMMANDS                                |
    |   +------------------------------------------+ |
    |   | LC_SEGMENT_64 __TEXT                    | |
    |   |   vmaddr: 0x100000000                   | |
    |   |   prot: r-x (readable, executable)     | |
    |   +------------------------------------------+ |
    |   | LC_SEGMENT_64 __DATA                    | |
    |   |   vmaddr: 0x100004000                   | |
    |   |   prot: rw- (readable, writable)       | |
    |   +------------------------------------------+ |
    |   | LC_CODE_SIGNATURE                       | |
    |   |   offset: 36864, size: 320             | |
    |   +------------------------------------------+ |
    |   | LC_LOAD_DYLIB                           | |
    |   |   /usr/lib/libSystem.B.dylib           | |
    |   +------------------------------------------+ |
    |                                                |
    |   SEGMENT DATA                                 |
    |   +------------------------------------------+ |
    |   | __TEXT: Code executable                 | |
    |   | __DATA: Variables globales              | |
    |   | __LINKEDIT: Signature + symboles        | |
    |   +------------------------------------------+ |
    |                                                |
    +================================================+


    COUCHES DE SECURITE macOS
    -------------------------

    +---------------------------------------------------+
    |  NIVEAU 4 : App Sandbox                           |
    |  - Limite les fichiers accessibles                |
    |  - Bloque les operations reseau non autorisees    |
    +---------------------------------------------------+
                          |
    +---------------------------------------------------+
    |  NIVEAU 3 : Hardened Runtime                      |
    |  - Bloque l'injection de code                     |
    |  - Empeche la modification de memoire executable  |
    +---------------------------------------------------+
                          |
    +---------------------------------------------------+
    |  NIVEAU 2 : Code Signing + Notarization           |
    |  - Verifie l'identite du developpeur              |
    |  - Apple scanne le binaire (notarization)         |
    +---------------------------------------------------+
                          |
    +---------------------------------------------------+
    |  NIVEAU 1 : System Integrity Protection (SIP)     |
    |  - Protege les fichiers systeme                   |
    |  - Bloque les kexts non signes                    |
    +---------------------------------------------------+
                          |
    +---------------------------------------------------+
    |  NIVEAU 0 : Secure Boot + T2/Secure Enclave       |
    |  - Verifie l'integrite au boot                    |
    |  - Stockage securise des cles                     |
    +---------------------------------------------------+
```

### 5.4 Les pieges en detail

#### Piege 1 : Valeurs hexadecimales en string

```python
# MAUVAIS: Assume que flags est un int
def check_pie(flags):
    return flags & 0x200000

# BON: Convertit d'abord en int
def check_pie(flags):
    if isinstance(flags, str):
        flags = int(flags, 16) if flags.startswith('0x') else int(flags)
    return bool(flags & 0x200000)
```

#### Piege 2 : Entitlements et Hardened Runtime

Le Hardened Runtime est **affaibli** (pas desactive) par certains entitlements :
- `allow-jit` : Permet la compilation JIT
- `allow-unsigned-executable-memory` : Permet W^X bypass
- `disable-library-validation` : Permet le chargement de dylibs non signees

#### Piege 3 : Fat Binaries et endianness

Les Fat binaries utilisent big-endian pour la compatibilite historique avec PowerPC. Le magic `0xCAFEBABE` en big-endian devient `0xBEBAFECA` en little-endian.

### 5.5 Cours Complet

#### 5.5.1 Structure Mach-O en detail

**Header Mach-O :**
```c
struct mach_header_64 {
    uint32_t magic;       // 0xFEEDFACF
    int32_t  cputype;     // CPU_TYPE_ARM64
    int32_t  cpusubtype;  // CPU_SUBTYPE_ARM64_ALL
    uint32_t filetype;    // MH_EXECUTE
    uint32_t ncmds;       // Nombre de load commands
    uint32_t sizeofcmds;  // Taille totale des commands
    uint32_t flags;       // MH_PIE, etc.
    uint32_t reserved;    // Padding (64-bit seulement)
};
```

**Load Commands principaux :**
| Command | Description |
|---------|-------------|
| LC_SEGMENT_64 | Definit un segment memoire |
| LC_LOAD_DYLIB | Charge une bibliotheque dynamique |
| LC_CODE_SIGNATURE | Pointe vers la signature de code |
| LC_ENCRYPTION_INFO | Info de chiffrement (iOS apps) |
| LC_RPATH | Chemin de recherche de dylibs |

#### 5.5.2 System Integrity Protection (SIP)

SIP protege les chemins suivants :
- `/System`
- `/usr` (sauf `/usr/local`)
- `/bin`
- `/sbin`
- Applications Apple pre-installees

Meme root ne peut pas :
- Modifier ces fichiers
- Attacher un debugger aux processus systeme
- Charger des kexts non signes
- Modifier le kernel boot args

#### 5.5.3 Hardened Runtime

Introduit avec macOS 10.14 Mojave, le Hardened Runtime :
- **Bloque l'injection de dylib** : `DYLD_INSERT_LIBRARIES` ignore
- **Empeche la modification de code** : Pages W^X enforces
- **Valide les libraries** : Seules les libs signees peuvent etre chargees
- **Protege les ressources** : Camera, micro, etc. necessitent permission

#### 5.5.4 Code Signing et Notarization

```bash
# Signer un binaire
codesign -s "Developer ID" --options runtime myapp

# Notariser (envoyer a Apple pour scan)
xcrun notarytool submit myapp.dmg --apple-id ... --password ...

# Verifier une signature
codesign -dv --verbose=4 /Applications/Safari.app
```

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------+
| X HORS NORME (fonctionne, mais interdit)                      |
+---------------------------------------------------------------+
| import lief; binary = lief.parse("binary")                    |
+---------------------------------------------------------------+
| OK CONFORME                                                   |
+---------------------------------------------------------------+
| def parse_macho_header(data):                                 |
|     """Parse manuellement les headers Mach-O."""              |
|     magic = struct.unpack('<I', data[:4])[0]                  |
|     cpu_type = struct.unpack('<i', data[4:8])[0]              |
|     return {"magic": magic, "cpu_type": cpu_type}             |
+---------------------------------------------------------------+
| POURQUOI ?                                                    |
|                                                               |
| . L'objectif est de COMPRENDRE le format, pas d'utiliser      |
|   une bibliotheque qui fait tout le travail                   |
| . En situation reelle (CTF, analyse malware), on peut         |
|   avoir besoin de parser des formats corrompus/modifies       |
+---------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Entree :**
```json
{
  "mach_o_header": {"magic": "0xFEEDFACF", "cpu_type": "0x0100000C", "file_type": 2, "flags": "0x00200085"},
  "load_commands": [{"cmd": "LC_CODE_SIGNATURE", "dataoff": 32768}],
  "entitlements": {"com.apple.security.app-sandbox": true}
}
```

```
+-------+----------------------------------+------------------------+---------------------------+
| Etape | Operation                        | Resultat               | Explication               |
+-------+----------------------------------+------------------------+---------------------------+
|   1   | parse_magic("0xFEEDFACF")        | MH_MAGIC_64, 64-bit    | Binaire 64-bit detecte    |
+-------+----------------------------------+------------------------+---------------------------+
|   2   | parse_cpu_type("0x0100000C")     | ARM64                  | Apple Silicon             |
+-------+----------------------------------+------------------------+---------------------------+
|   3   | analyze_flags("0x00200085")      | is_pie=true            | 0x200000 bit set          |
+-------+----------------------------------+------------------------+---------------------------+
|   4   | has_code_signature(cmds)         | true                   | LC_CODE_SIGNATURE present |
+-------+----------------------------------+------------------------+---------------------------+
|   5   | analyze_entitlements(ent)        | sandboxed=true         | app-sandbox active        |
+-------+----------------------------------+------------------------+---------------------------+
|   6   | assess_risk(info, security)      | level="low"            | Tout securise             |
+-------+----------------------------------+------------------------+---------------------------+
```

### 5.8 Mnemotechniques

#### MEME : "La forteresse Apple"

```
APPLE SECURITY = Un chateau medieval

+------------------------------------------+
|                                          |
|    [Donjon] = Secure Enclave             |
|        |                                 |
|    [Murailles] = System Integrity        |
|        |       Protection (SIP)          |
|    [Douves] = Hardened Runtime           |
|        |                                 |
|    [Pont-levis] = Code Signing           |
|        |                                 |
|    [Gardes] = Gatekeeper                 |
|        |                                 |
|   [Visiteurs] = App Sandbox              |
|                                          |
+------------------------------------------+

Pour rentrer dans le chateau (executer du code):
1. Montrer son badge (Code Signing)
2. Etre fouille (Notarization)
3. Rester dans la zone visiteurs (Sandbox)
4. Ne pas toucher aux murs (SIP)
```

#### Astuce : "CAFE BABE" et "FEED FACE"

Les magic numbers sont des jeux de mots hexadecimaux :
- `0xCAFEBABE` = "Cafe Babe" (Fat binary)
- `0xFEEDFACE` = "Feed Face" (Mach-O 32-bit)
- `0xFEEDFACF` = "Feed Facf" (Mach-O 64-bit, le F final pour 64)

### 5.9 Applications pratiques

1. **Analyse de malware macOS** : Detecter les binaires suspects
2. **Audit de securite** : Verifier les protections avant deployment
3. **iOS Jailbreak research** : Comprendre les protections a contourner
4. **Forensique** : Analyser des binaires captures sur des systemes compromis

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Valeurs hex en string | TypeError ou mauvais parsing | Convertir avec int(x, 16) |
| 2 | Entitlements manquants | KeyError | Utiliser .get() avec default |
| 3 | Fat binary endianness | Magic non reconnu | Gerer big et little endian |
| 4 | PIE flag mal interprete | Faux negatif securite | Verifier le bon bit (0x200000) |
| 5 | Segments manquants | Analyse incomplete | Boucler sur tous les LC |

---

## SECTION 7 : QCM

### Question 1
**Quel magic number identifie un binaire Mach-O 64-bit ?**

A) 0xCAFEBABE
B) 0xFEEDFACE
C) 0xFEEDFACF
D) 0x7F454C46
E) 0xBEBAFECA
F) 0xCEFAEDFE
G) 0x4D5A
H) 0xDEADBEEF
I) 0x0100000C
J) 0x00200000

**Reponse : C**

---

### Question 2
**Quel entitlement AFFAIBLIT le Hardened Runtime ?**

A) com.apple.security.app-sandbox
B) com.apple.security.cs.allow-jit
C) com.apple.security.network.client
D) com.apple.security.files.user-selected.read-only
E) com.apple.security.temporary-exception.files.home-relative-path.read-only
F) com.apple.developer.kernel.increased-memory-limit
G) com.apple.security.app-protection
H) com.apple.developer.associated-domains
I) com.apple.security.automation.apple-events
J) com.apple.developer.networking.wifi-info

**Reponse : B**

---

### Question 3
**Que signifie le flag MH_PIE (0x200000) ?**

A) Le binaire est signe
B) Le binaire utilise la pile
C) Le binaire peut etre charge a une adresse aleatoire
D) Le binaire est un dylib
E) Le binaire est chiffre
F) Le binaire est un Fat binary
G) Le binaire a des entitlements
H) Le binaire est sandbox
I) Le binaire est notarise
J) Le binaire supporte ARM64

**Reponse : C**

---

### Question 4
**Quel composant verifie la signature avant l'execution sur macOS ?**

A) System Integrity Protection
B) Hardened Runtime
C) Gatekeeper
D) App Sandbox
E) Secure Enclave
F) FileVault
G) XProtect
H) MRT (Malware Removal Tool)
I) notarytool
J) codesign

**Reponse : C**

---

### Question 5
**Quelle valeur de file_type indique un executable ?**

A) 1 (MH_OBJECT)
B) 2 (MH_EXECUTE)
C) 6 (MH_DYLIB)
D) 8 (MH_BUNDLE)
E) 10 (MH_DSYM)
F) 11 (MH_KEXT_BUNDLE)
G) 5 (MH_CORE)
H) 7 (MH_DYLINKER)
I) 9 (MH_DYLIB_STUB)
J) 3 (MH_FVMLIB)

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | 8/10 |
| **Temps estime** | 90 min |
| **XP Base** | 250 |
| **XP Bonus** | x3 (750 total) |
| **Concepts cles** | Mach-O, Code Signing, SIP, Hardened Runtime |
| **Langage** | Python 3.12 |
| **Prerequis** | 3.4.1, Formats binaires |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.3-a-macos-fortress",
    "generated_at": "2026-01-16 15:00:00",

    "metadata": {
      "exercise_id": "3.4.3-a",
      "exercise_name": "macos_fortress",
      "module": "3.4.3",
      "module_name": "macOS/iOS Specifics",
      "concept": "a",
      "concept_name": "Analyse de securite macOS et format Mach-O",
      "type": "code",
      "tier": 2,
      "tier_info": "Concepts combines",
      "phase": 3,
      "difficulty": 8,
      "difficulty_stars": "8/10",
      "language": "python",
      "duration_minutes": 90,
      "xp_base": 250,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T4 O(n)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["3.4.1", "Binary formats"],
      "domains": ["BinFormat", "Security", "macOS"],
      "domains_bonus": ["Crypto"],
      "tags": ["macos", "mach-o", "security", "binary-analysis", "ios"],
      "meme_reference": "Mr. Robot"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.py": "/* Section 4.3 */",
      "references/ref_solution_bonus.py": "/* Section 4.6 */",
      "mutants/mutant_a_logic.py": "/* Section 4.10 */",
      "mutants/mutant_b_boundary.py": "/* Section 4.10 */",
      "mutants/mutant_c_safety.py": "/* Section 4.10 */",
      "mutants/mutant_d_return.py": "/* Section 4.10 */",
      "mutants/mutant_e_parse.py": "/* Section 4.10 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.py",
        "references/ref_solution_bonus.py"
      ],
      "expected_fail": [
        "mutants/mutant_a_logic.py",
        "mutants/mutant_b_boundary.py",
        "mutants/mutant_c_safety.py",
        "mutants/mutant_d_return.py",
        "mutants/mutant_e_parse.py"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_solution.py",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.py -s spec.json --validate"
    }
  }
}
```
