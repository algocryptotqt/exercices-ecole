# Exercice 3.4.4-b : canary_hunter

**Module :**
3.4.4 â€” Memory Protections & Bypass

**Concept :**
b â€” Canary Bypass Techniques

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Python 3.12

**PrÃ©requis :**
- Exercice 3.4.4-a (protection_detector)
- Exercice 3.4.5-a (first_overflow)
- ComprÃ©hension des stack canaries

**Domaines :**
CPU, Mem, Crypto

**DurÃ©e estimÃ©e :**
75 min

**XP Base :**
250

**ComplexitÃ© :**
T4 O(n) Ã— S2 O(1)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`canary_hunter.py`

**Fonctions autorisÃ©es :**
- `socket` (communication rÃ©seau simulÃ©e)
- `struct` (packing/unpacking)
- `json`, `sys`, `re`
- Fonctions built-in Python

**Fonctions interdites :**
- pwntools (implÃ©mentation manuelle requise)
- BibliothÃ¨ques d'exploitation automatique

### 1.2 Consigne

#### 2.4.1 ğŸ® Contexte Culturel â€” "Metal Gear Solid"

*"A cornered fox is more dangerous than a jackal!"*

Dans **Metal Gear Solid**, Solid Snake doit infiltrer des installations hautement sÃ©curisÃ©es. Les **stack canaries** sont comme les gardes patrouillant dans Shadow Moses : ils dÃ©tectent toute intrusion et dÃ©clenchent l'alerte.

Mais Snake a des techniques pour contourner les gardes :
- **Observer leurs patterns** (leak byte par byte)
- **Exploiter leurs faiblesses** (fork = mÃªme canary)
- **Attaquer leur base** (overwrite TLS)

Ton objectif : devenir le Snake de l'exploitation binaire. Analyse le systÃ¨me de sÃ©curitÃ© et trouve le chemin vers le shell.

#### 2.4.2 Ã‰noncÃ© AcadÃ©mique

Un **stack canary** (ou stack cookie) est une valeur alÃ©atoire placÃ©e entre les variables locales et l'adresse de retour sauvegardÃ©e. Avant le retour de fonction, cette valeur est vÃ©rifiÃ©e. Si elle a Ã©tÃ© modifiÃ©e, le programme appelle `__stack_chk_fail` et termine.

**CaractÃ©ristiques d'un canary Linux x86-64 :**
- 8 bytes (64 bits)
- Premier byte = 0x00 (null byte pour bloquer strcpy)
- GÃ©nÃ©rÃ© au dÃ©marrage par le kernel (random)
- StockÃ© dans le TLS (Thread Local Storage) via `fs:0x28`

**Ta mission :**

ImplÃ©menter un simulateur de leak de canary qui :

1. **Simule** un service rÃ©seau qui fork() Ã  chaque connexion
2. **ImplÃ©mente** un leak byte-par-byte via timing ou crash
3. **Calcule** la complexitÃ© du bruteforce selon le mode (fork/thread)
4. **GÃ©nÃ¨re** un payload qui contourne le canary

**EntrÃ©e :**
```json
{
  "service_mode": "fork",
  "canary_value": "0x00deadbeefcafe00",
  "buffer_size": 64,
  "canary_offset": 72,
  "leak_primitive": "byte_by_byte",
  "connection_timeout": 0.1
}
```

**Sortie :**
```json
{
  "leaked_canary": "0x00deadbeefcafe00",
  "bytes_leaked": [0, 222, 173, 190, 239, 202, 254, 0],
  "attempts_per_byte": [1, 127, 89, 45, 201, 156, 78, 1],
  "total_attempts": 698,
  "bruteforce_complexity": "2^56 without leak, 8*128 average with leak",
  "payload_generated": "AAAA...canary...RIP"
}
```

**Modes supportÃ©s :**

| Mode | Comportement | ComplexitÃ© leak |
|------|--------------|-----------------|
| fork | MÃªme canary aprÃ¨s fork | 8 Ã— 256 max (2048 attempts) |
| thread | MÃªme canary (mÃªme processus) | 8 Ã— 256 max |
| exec | Nouveau canary | Impossible sans autre primitive |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
canary_hunter.py - Simulateur de leak de stack canary
"""

import json
import sys
import struct
from typing import List, Tuple, Optional

class CanaryHunter:
    """Simulateur de leak de stack canary."""

    def __init__(self, config: dict):
        """Initialise le hunter avec la configuration."""
        pass

    def simulate_connection(self, payload: bytes) -> Tuple[bool, Optional[bytes]]:
        """
        Simule une connexion au service.

        Returns:
            (crash: bool, response: Optional[bytes])
        """
        pass

    def leak_byte(self, position: int, known_bytes: bytes) -> Tuple[int, int]:
        """
        Leak un byte du canary Ã  la position donnÃ©e.

        Returns:
            (byte_value: int, attempts: int)
        """
        pass

    def leak_canary(self) -> dict:
        """
        Leak le canary complet byte par byte.

        Returns:
            Dictionnaire avec canary leakÃ© et statistiques
        """
        pass

    def generate_payload(self, leaked_canary: int, target_rip: int) -> bytes:
        """
        GÃ©nÃ¨re un payload avec le canary leakÃ©.

        Returns:
            Payload complet pour overflow + canary + RIP
        """
        pass

    def calculate_complexity(self) -> dict:
        """
        Calcule la complexitÃ© thÃ©orique du bruteforce.
        """
        pass

def main():
    """Point d'entrÃ©e principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### L'histoire des canaries

Le terme "canary" vient des **canaris dans les mines de charbon**. Les mineurs emmenaient des canaris car ces oiseaux sont trÃ¨s sensibles aux gaz toxiques. Si le canari mourait, les mineurs savaient qu'il fallait Ã©vacuer.

De mÃªme, le stack canary "meurt" (dÃ©tecte une modification) avant que l'exploitation ne puisse se produire.

### Le null byte initial

Le premier byte du canary est toujours 0x00 sur Linux. Pourquoi ?

Parce que `strcpy()` et fonctions similaires s'arrÃªtent au null byte. Ainsi, mÃªme si un attaquant utilise `strcpy()` pour overflow, il ne peut pas Ã©craser le canary correctement car la copie s'arrÃªte au 0x00.

**Mais** : si l'attaquant contrÃ´le la source caractÃ¨re par caractÃ¨re (read(), recv()), le null byte n'est pas un obstacle.

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

**MÃ©tier : DÃ©veloppeur d'exploits / Red Team**

Les techniques de leak de canary sont utilisÃ©es quotidiennement dans :
- **CTF competitions** : Quasi tous les challenges pwn modernes
- **Bug bounty** : Exploitation de services rÃ©seaux vulnÃ©rables
- **Audits de sÃ©curitÃ©** : Test des protections en place

**Exemple rÃ©el : CVE-2018-6789 (Exim)**
Une vulnÃ©rabilitÃ© dans le serveur mail Exim permettait un heap overflow. Le canary devait Ãªtre leakÃ© via une primitive de lecture avant de pouvoir exploiter l'overflow.

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cat config.json
{"service_mode": "fork", "canary_value": "0x00aabbccddeeff00", "buffer_size": 64, "canary_offset": 72, "leak_primitive": "byte_by_byte"}

$ python3 canary_hunter.py config.json
{"leaked_canary": "0x00aabbccddeeff00", "bytes_leaked": [0, 170, 187, 204, 221, 238, 255, 0], "total_attempts": 892, "bruteforce_complexity": "2^56 without leak, 1024 average with leak", "success": true}
```

---

## ğŸ”¥ SECTION 3.1 : BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Domaines Bonus :**
Mem, Crypto, Algo

### 3.1.1 Consigne Bonus

**Extension "TLS Overwrite" :**

1. **Simuler** l'overwrite du canary dans le TLS (fs:0x28)
2. **ImplÃ©menter** une dÃ©tection automatique de la position TLS
3. **GÃ©rer** le cas oÃ¹ le canary est rÃ©gÃ©nÃ©rÃ© (threads)
4. **Optimiser** le leak avec binary search quand possible

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| fork_mode_leak | fork, canary connu | canary leakÃ© correct | 15 |
| first_byte_null | canary 0x00... | premier byte = 0 toujours | 10 |
| last_byte_null | canary ...00 | dernier byte = 0 | 10 |
| attempts_count | N/A | attempts <= 2048 | 10 |
| payload_generation | canary + RIP | payload valide | 15 |
| complexity_calc | fork mode | O(8*256) | 10 |
| exec_mode | exec mode | impossible sans leak | 10 |
| thread_mode | thread mode | mÃªme que fork | 10 |
| binary_leak | byte par byte | 8 bytes corrects | 10 |

### 4.3 Solution de rÃ©fÃ©rence

```python
#!/usr/bin/env python3
"""
canary_hunter.py - Solution de rÃ©fÃ©rence
"""

import json
import sys
import struct
from typing import List, Tuple, Optional

class CanaryHunter:
    """Simulateur de leak de stack canary."""

    def __init__(self, config: dict):
        self.service_mode = config.get('service_mode', 'fork')
        self.buffer_size = config.get('buffer_size', 64)
        self.canary_offset = config.get('canary_offset', 72)
        self.leak_primitive = config.get('leak_primitive', 'byte_by_byte')

        # Parse canary value
        canary_str = config.get('canary_value', '0x0')
        if isinstance(canary_str, str):
            self.canary_value = int(canary_str, 16)
        else:
            self.canary_value = canary_str

        # Statistiques
        self.total_attempts = 0
        self.attempts_per_byte = []

    def canary_to_bytes(self) -> bytes:
        """Convertit le canary en bytes (little-endian)."""
        return struct.pack('<Q', self.canary_value)

    def simulate_connection(self, payload: bytes) -> Tuple[bool, Optional[bytes]]:
        """
        Simule une connexion au service.
        Le service crash si le canary est incorrect.
        """
        if len(payload) <= self.buffer_size:
            # Pas d'overflow
            return (False, b"OK")

        # VÃ©rifier le canary dans le payload
        canary_start = self.canary_offset
        canary_end = canary_start + 8

        if len(payload) >= canary_end:
            payload_canary = payload[canary_start:canary_end]
            real_canary = self.canary_to_bytes()

            # Comparer byte par byte (pour leak partiel)
            for i in range(min(len(payload_canary), 8)):
                if payload_canary[i] != real_canary[i]:
                    # Crash - canary mismatch
                    return (True, None)

            # Canary correct
            return (False, b"Canary OK")

        # Overflow mais pas jusqu'au canary
        return (False, b"Partial overflow")

    def leak_byte(self, position: int, known_bytes: bytes) -> Tuple[int, int]:
        """
        Leak un byte du canary Ã  la position donnÃ©e.
        Utilise le fait que fork() conserve le mÃªme canary.
        """
        attempts = 0

        # Construire le padding jusqu'au canary
        padding = b'A' * self.canary_offset

        # Position 0 et 7 sont toujours 0x00 sur Linux x86-64
        if position == 0:
            return (0x00, 1)

        # Pour les autres positions, brute force
        for guess in range(256):
            attempts += 1

            # Construire le payload avec les bytes connus + guess
            canary_attempt = known_bytes + bytes([guess])
            payload = padding + canary_attempt

            crash, _ = self.simulate_connection(payload)

            if not crash:
                # Ce byte est correct
                return (guess, attempts)

        # Ne devrait pas arriver si le mode est fork
        return (0, attempts)

    def leak_canary(self) -> dict:
        """Leak le canary complet byte par byte."""
        if self.service_mode == 'exec':
            return {
                'error': 'Cannot leak canary in exec mode',
                'leaked_canary': None,
                'success': False
            }

        leaked_bytes = []
        self.attempts_per_byte = []
        self.total_attempts = 0

        for pos in range(8):
            known = bytes(leaked_bytes)
            byte_val, attempts = self.leak_byte(pos, known)
            leaked_bytes.append(byte_val)
            self.attempts_per_byte.append(attempts)
            self.total_attempts += attempts

        # Reconstruire le canary
        leaked_canary = struct.unpack('<Q', bytes(leaked_bytes))[0]

        return {
            'leaked_canary': hex(leaked_canary),
            'bytes_leaked': leaked_bytes,
            'attempts_per_byte': self.attempts_per_byte,
            'total_attempts': self.total_attempts,
            'success': leaked_canary == self.canary_value
        }

    def generate_payload(self, leaked_canary: int, target_rip: int) -> bytes:
        """GÃ©nÃ¨re un payload avec le canary leakÃ©."""
        # Padding jusqu'au canary
        padding = b'A' * self.canary_offset

        # Canary leakÃ©
        canary_bytes = struct.pack('<Q', leaked_canary)

        # 8 bytes pour saved RBP (on peut mettre n'importe quoi)
        saved_rbp = b'B' * 8

        # Target RIP
        rip_bytes = struct.pack('<Q', target_rip)

        return padding + canary_bytes + saved_rbp + rip_bytes

    def calculate_complexity(self) -> dict:
        """Calcule la complexitÃ© thÃ©orique."""
        if self.service_mode == 'exec':
            return {
                'without_leak': '2^64 (impossible)',
                'with_leak': 'N/A - canary changes on each exec',
                'practical': 'Requires different vulnerability'
            }

        # Mode fork ou thread - canary reste le mÃªme
        # 7 bytes Ã  deviner (premier est 0x00)
        # Chaque byte: 256 possibilitÃ©s max, 128 en moyenne

        return {
            'without_leak': '2^56 (7 random bytes)',
            'with_leak_max': '7 * 256 = 1792 attempts',
            'with_leak_avg': '7 * 128 = 896 attempts',
            'practical': 'Feasible with byte-by-byte leak'
        }

    def analyze(self) -> dict:
        """Analyse complÃ¨te."""
        leak_result = self.leak_canary()
        complexity = self.calculate_complexity()

        result = {
            **leak_result,
            'bruteforce_complexity': complexity
        }

        if leak_result.get('success'):
            # GÃ©nÃ©rer un payload exemple
            leaked = int(leak_result['leaked_canary'], 16)
            payload = self.generate_payload(leaked, 0x4141414141414141)
            result['payload_length'] = len(payload)
            result['payload_hex'] = payload.hex()

        return result


def main():
    if len(sys.argv) < 2:
        print("Usage: canary_hunter.py <config.json>", file=sys.stderr)
        sys.exit(1)

    with open(sys.argv[1], 'r') as f:
        config = json.load(f)

    hunter = CanaryHunter(config)
    result = hunter.analyze()

    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
```

### 4.9 spec.json

```json
{
  "name": "canary_hunter",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 1,
  "tags": ["canary", "bypass", "exploitation", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "CanaryHunter.analyze",
    "prototype": "def analyze(self) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "fork_mode_success",
        "args": [{"service_mode": "fork", "canary_value": "0x00112233445566", "buffer_size": 64, "canary_offset": 72}],
        "check": "result['success'] == True"
      },
      {
        "name": "first_byte_zero",
        "args": [{"service_mode": "fork", "canary_value": "0x00aabbccddeeff00", "buffer_size": 64, "canary_offset": 72}],
        "check": "result['bytes_leaked'][0] == 0"
      },
      {
        "name": "exec_mode_fails",
        "args": [{"service_mode": "exec", "canary_value": "0x00112233445566", "buffer_size": 64, "canary_offset": 72}],
        "check": "result['success'] == False"
      }
    ]
  }
}
```

### 4.10 Solutions Mutantes

```python
# Mutant A: Oublie que le premier byte est toujours 0x00
def leak_byte_mutant_a(self, position, known_bytes):
    # Brute force tous les bytes, y compris position 0
    for guess in range(256):
        # ... leak logic
    # Inefficace: 256 tentatives inutiles pour byte 0

# Mutant B: Ne gÃ¨re pas le mode exec
def leak_canary_mutant_b(self):
    # Tente le leak mÃªme en mode exec
    # Ã‰choue car canary change Ã  chaque exec
    pass

# Mutant C: Mauvais endianness
def generate_payload_mutant_c(self, leaked_canary, target_rip):
    # Utilise big-endian au lieu de little-endian
    canary_bytes = struct.pack('>Q', leaked_canary)  # FAUX!
    return padding + canary_bytes + ...

# Mutant D: Oublie saved RBP entre canary et RIP
def generate_payload_mutant_d(self, leaked_canary, target_rip):
    return padding + canary_bytes + rip_bytes  # Manque RBP!

# Mutant E: Compte mal les attempts
def leak_byte_mutant_e(self, position, known_bytes):
    attempts = 1  # Commence Ã  1 au lieu de 0
    # Statistiques faussÃ©es
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Fonctionnement des canaries** : GÃ©nÃ©ration, stockage, vÃ©rification
2. **Leak byte-par-byte** : Exploiter fork() pour leak progressif
3. **ComplexitÃ© du bruteforce** : Calculs probabilistes
4. **GÃ©nÃ©ration de payload** : Structure stack complÃ¨te

### 5.3 Visualisation ASCII

```
        STACK LAYOUT AVEC CANARY

    Adresses hautes
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    Return Address   â”‚ â† Ce qu'on veut contrÃ´ler
    â”‚      (8 bytes)      â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚     Saved RBP       â”‚
    â”‚      (8 bytes)      â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚   STACK CANARY      â”‚ â† Gardien (8 bytes)
    â”‚  0x00XXXXXXXXXXXX00 â”‚   Premier et dernier = 0x00
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                     â”‚
    â”‚   Variables locales â”‚ â† Buffer vulnÃ©rable ici
    â”‚      (64 bytes)     â”‚
    â”‚                     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Adresses basses


    TECHNIQUE DE LEAK BYTE-PAR-BYTE

    Tentative 1: AAAA...AA + 0x00
                              â†“
                 Si pas crash â†’ Premier byte = 0x00 âœ“

    Tentative 2: AAAA...AA + 0x00 + 0x??
                                    â†“
                 Tester 0x00 Ã  0xFF jusqu'Ã  pas crash

    ...rÃ©pÃ©ter pour 8 bytes...

    RÃ©sultat: Canary complet leakÃ©!


    POURQUOI FORK() AIDE

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     fork()    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Parent     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚    Child     â”‚
    â”‚ Canary: 0xAA â”‚               â”‚ Canary: 0xAA â”‚ â† MÃŠME canary!
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                   crash ou pas?
                                          â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚                       â”‚
                         Crash (mauvais)       OK (byte correct)
                              â”‚                       â”‚
                              â†“                       â†“
                        RÃ©essayer              Passer au suivant
```

### 5.5 Cours Complet

#### 5.5.1 Stack Canary : MÃ©canisme de protection

Le stack canary est une valeur alÃ©atoire insÃ©rÃ©e par le compilateur entre les variables locales et les donnÃ©es de contrÃ´le (saved RBP, return address).

**Insertion par GCC :**
```c
// Code source
void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);
}

// Code compilÃ© (pseudo-ASM)
vulnerable:
    push rbp
    mov rbp, rsp
    sub rsp, 80           ; 64 + padding
    mov rax, fs:0x28      ; Charger canary depuis TLS
    mov [rbp-8], rax      ; Sauvegarder sur la stack
    ; ... code de la fonction ...
    mov rax, [rbp-8]      ; Recharger canary
    xor rax, fs:0x28      ; Comparer avec TLS
    jne __stack_chk_fail  ; Si diffÃ©rent â†’ crash
    leave
    ret
```

#### 5.5.2 Techniques de bypass

**1. Leak via over-read**
Si le programme a une vulnÃ©rabilitÃ© de lecture (format string, buffer over-read), on peut lire le canary directement.

**2. Leak byte-par-byte (cet exercice)**
Si le programme fork() et qu'on peut dÃ©tecter un crash vs non-crash :
- Tester chaque byte (256 possibilitÃ©s)
- 8 bytes Ã— 256 = 2048 tentatives max

**3. Bruteforce (32-bit uniquement)**
Sur 32 bits, le canary fait 4 bytes dont 1 null = 2^24 possibilitÃ©s.
Avec beaucoup de connexions, faisable.

**4. Overwrite TLS**
Si on peut Ã©crire Ã  l'adresse `fs:0x28`, on peut dÃ©finir notre propre canary.

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel est le premier byte d'un canary Linux x86-64 ?**

A) Un byte alÃ©atoire
B) 0xFF
C) 0x00
D) 0x41
E) DÃ©pend de la version du kernel
F) Le mÃªme que le dernier byte
G) Toujours 0x7F
H) Variable selon ASLR
I) DÃ©fini par le programme
J) B ou C selon la configuration

**RÃ©ponse : C**

---

### Question 2
**Pourquoi fork() facilite-t-il le leak de canary ?**

A) fork() dÃ©sactive les canaries
B) Le canary est passÃ© en argument Ã  fork()
C) Le child hÃ©rite du mÃªme canary que le parent
D) fork() gÃ©nÃ¨re un nouveau canary prÃ©visible
E) Le canary est stockÃ© dans un fichier aprÃ¨s fork()
F) fork() affiche le canary en debug
G) Le canary devient 0 aprÃ¨s fork()
H) fork() permet de lire /proc/self/canary
I) Aucune relation
J) fork() stocke le canary en mÃ©moire partagÃ©e

**RÃ©ponse : C**

---

### Question 3
**Combien de tentatives maximum pour leak un canary 64-bit via byte-par-byte ?**

A) 256
B) 512
C) 1024
D) 2048
E) 2^64
F) 2^56
G) 8
H) 64
I) 256^8
J) Impossible Ã  dÃ©terminer

**RÃ©ponse : D** (8 bytes Ã— 256 = 2048, mais en pratique ~1024 en moyenne car premier byte = 0)

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10) |
| **Temps estimÃ©** | 75 min |
| **XP Base** | 250 |
| **XP Bonus** | Ã—3 (750 total) |
| **Concepts clÃ©s** | Stack canary, leak, fork(), bruteforce |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.4-b-canary-hunter",
    "metadata": {
      "exercise_id": "3.4.4-b",
      "exercise_name": "canary_hunter",
      "module": "3.4.4",
      "module_name": "Memory Protections & Bypass",
      "type": "code",
      "tier": 1,
      "difficulty": 8,
      "language": "python"
    }
  }
}
```
