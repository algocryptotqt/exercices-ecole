# Exercice 3.4.5-b : Le Maître des Offsets

## Metadata
- **Exercice ID**: 3.4.5-b
- **Titre**: Le Maître des Offsets
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Exploitation Stack (Niveau 3)
- **Difficulté**: ⭐⭐⭐⭐⭐ (5/10 - Intermédiaire)
- **Tier**: 2
- **XP**: 400

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.5.e | Pattern Creation (pattern_create, cyclic) |
| 3.4.5.f | Offset Finding (pattern_offset, cyclic_find) |
| 3.4.5.g | Controlling RIP |
| 3.4.5.h | Alignment (stack 16-byte) |

## Prerequis
- Module 3.4.5-a : Le Premier Overflow (bases du buffer overflow)
- Comprehension de la stack x86-64
- Notions de registres (RSP, RBP, RIP)

---

## Section 1 : Prototype de Fonction

```python
"""
Module: offset_master - Toolkit de Détermination d'Offset pour Exploitation
Architecture: x86-64
Contraintes: Aucune dépendance externe (pwntools-like from scratch)
"""

from typing import Optional
import string


def generate_de_bruijn_sequence(alphabet: str, n: int, length: int) -> str:
    """
    Génère une séquence de de Bruijn.

    Une séquence de de Bruijn B(k,n) contient chaque sous-chaîne possible
    de longueur n exactement une fois. Utile pour déterminer des offsets.

    Args:
        alphabet: Caractères à utiliser (ex: string.ascii_lowercase)
        n: Longueur des sous-séquences uniques
        length: Longueur totale souhaitée

    Returns:
        Séquence de de Bruijn tronquée à length caractères

    Exemple:
        >>> pattern = generate_de_bruijn_sequence("abc", 2, 10)
        >>> len(pattern)
        10
        >>> pattern[:9]  # B(3,2) commence par "aabacabcb..."
        'aabacabcb'
    """
    pass


def pattern_create(length: int, charset: str = "default") -> bytes:
    """
    Crée un pattern unique pour identifier les offsets (style Metasploit).

    Args:
        length: Longueur du pattern en bytes
        charset: "default" pour Aa0-Zz9, ou chaîne personnalisée

    Returns:
        Pattern de bytes avec sous-séquences uniques de 4 bytes

    Exemple:
        >>> pattern = pattern_create(100)
        >>> len(pattern)
        100
        >>> pattern[:20]
        b'Aa0Aa1Aa2Aa3Aa4Aa5Aa'
    """
    pass


def pattern_offset(pattern: bytes, value: int, arch: str = "x64") -> Optional[int]:
    """
    Trouve l'offset d'une valeur dans un pattern.

    Args:
        pattern: Le pattern généré par pattern_create
        value: Valeur trouvée (ex: RIP crashé sur 0x41366141)
        arch: "x64" ou "x86" pour l'ordre des bytes

    Returns:
        Offset en bytes, ou None si non trouvé

    Exemple:
        >>> pattern = pattern_create(500)
        >>> # Si RIP = 0x41366141 ("Aa6A" en little-endian)
        >>> offset = pattern_offset(pattern, 0x41366141, "x64")
        >>> offset
        20
    """
    pass


def cyclic(length: int, n: int = 4) -> bytes:
    """
    Génère un pattern cyclique (style pwntools).

    Args:
        length: Longueur souhaitée
        n: Taille des sous-séquences uniques (default 4 pour 32-bit)

    Returns:
        Pattern cyclique

    Exemple:
        >>> p = cyclic(20)
        >>> p
        b'aaaabaaacaaadaaaeaaa'
    """
    pass


def cyclic_find(subseq: bytes, n: int = 4) -> int:
    """
    Trouve l'offset d'une sous-séquence dans le pattern cyclique.

    Args:
        subseq: Bytes à chercher (ex: b'faaa' ou valeur comme b'\\x61\\x61\\x61\\x66')
        n: Taille des sous-séquences

    Returns:
        Offset, ou -1 si non trouvé

    Exemple:
        >>> cyclic_find(b'faaa')
        20
        >>> cyclic_find(b'\\x61\\x61\\x61\\x66')  # 'faaa' little-endian
        20
    """
    pass


def calculate_padding(
    buffer_size: int,
    saved_rbp_offset: int,
    target_offset: str = "rip"
) -> dict:
    """
    Calcule le padding nécessaire pour atteindre différentes cibles.

    Args:
        buffer_size: Taille du buffer vulnérable
        saved_rbp_offset: Offset vers saved RBP (souvent = buffer_size)
        target_offset: "rbp", "rip", ou "beyond_rip"

    Returns:
        Dict avec padding calculé et structure de la stack

    Exemple:
        >>> result = calculate_padding(64, 64, "rip")
        >>> result["padding_to_rip"]
        72  # 64 (buffer) + 8 (saved RBP)
    """
    pass


def check_alignment(rsp_after_ret: int, required_alignment: int = 16) -> dict:
    """
    Vérifie l'alignement de la stack après un RET.

    Args:
        rsp_after_ret: Valeur de RSP après le RET
        required_alignment: Alignement requis (16 pour x64 ABI)

    Returns:
        Dict avec:
        - aligned: Booléen
        - current_alignment: Alignement actuel
        - adjustment_needed: Bytes à ajouter
        - needs_ret_gadget: Si un RET supplémentaire est nécessaire

    Exemple:
        >>> result = check_alignment(0x7fff0008, 16)
        >>> result["aligned"]
        False
        >>> result["needs_ret_gadget"]
        True
    """
    pass


def generate_payload_skeleton(
    padding: int,
    rip_value: int,
    args: list[int] = None,
    alignment_gadget: int = None
) -> bytes:
    """
    Génère un squelette de payload avec padding automatique.

    Args:
        padding: Bytes de padding avant RIP
        rip_value: Adresse à placer dans RIP
        args: Arguments supplémentaires (pour ROP)
        alignment_gadget: Adresse de ret gadget si alignement nécessaire

    Returns:
        Payload complet en bytes

    Exemple:
        >>> payload = generate_payload_skeleton(72, 0x401234)
        >>> len(payload)
        80  # 72 padding + 8 (RIP)
    """
    pass


def analyze_crash(
    crash_rip: int,
    crash_rsp: int,
    crash_rbp: int,
    pattern: bytes
) -> dict:
    """
    Analyse un crash pour déterminer tous les offsets pertinents.

    Args:
        crash_rip: Valeur de RIP au moment du crash
        crash_rsp: Valeur de RSP au moment du crash
        crash_rbp: Valeur de RBP au moment du crash
        pattern: Pattern utilisé pour le crash

    Returns:
        Dict avec analyse complète des offsets

    Exemple:
        >>> pattern = pattern_create(200)
        >>> result = analyze_crash(0x41376141, 0x7fff0000, 0x41366141, pattern)
        >>> result["rip_offset"]
        24
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Séquences de de Bruijn (3.4.5.e)

Une **séquence de de Bruijn** B(k,n) sur un alphabet de k symboles est une séquence cyclique où chaque sous-séquence possible de longueur n apparaît exactement une fois.

#### Propriétés

```
B(k,n) a longueur k^n
Exemple: B(2,3) sur {0,1} = "00010111" (longueur 2³ = 8)

Chaque triplet de bits apparaît une fois:
000, 001, 010, 101, 011, 111, 110, 100 (cyclique)
```

#### Algorithme de construction (Martin)

```python
def de_bruijn(k, n):
    """
    Génère une séquence de de Bruijn B(k,n).
    Algorithme: FKM (Frank-Koenig-Marshall)
    """
    alphabet = list(range(k))
    a = [0] * (k * n)
    sequence = []

    def db(t, p):
        if t > n:
            if n % p == 0:
                sequence.extend(a[1:p + 1])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            for j in range(a[t - p] + 1, k):
                a[t] = j
                db(t + 1, t)

    db(1, 1)
    return sequence
```

### 2.2 Pattern Metasploit (pattern_create)

Metasploit utilise un pattern spécifique pour les exploits:

```
Alphabet par défaut:
- Majuscules: A-Z (26 caractères)
- Minuscules: a-z (26 caractères)
- Chiffres: 0-9 (10 caractères)

Format: [UPPER][lower][digit][UPPER][lower][digit+1]...
Exemple: Aa0Aa1Aa2...Aa9Ab0Ab1...
```

#### Génération

```python
def metasploit_pattern(length):
    """Pattern style Metasploit/msfpattern."""
    upper = string.ascii_uppercase
    lower = string.ascii_lowercase
    digits = string.digits

    pattern = []
    for u in upper:
        for l in lower:
            for d in digits:
                pattern.append(u + l + d)
                if len(''.join(pattern)) >= length:
                    return ''.join(pattern)[:length]

    return ''.join(pattern)[:length]
```

### 2.3 Recherche d'Offset (3.4.5.f)

Quand un programme crash avec RIP contenant une partie du pattern, on peut retrouver l'offset exact.

#### Processus

```
1. Envoyer pattern de 500 bytes
2. Programme crash: RIP = 0x41366141
3. Convertir en bytes (little-endian): b'Aa6A'
4. Chercher dans le pattern: index = 20
5. Offset vers RIP = 20 bytes
```

#### Considérations d'endianness

```python
def value_to_bytes(value, arch):
    """Convertit une valeur en bytes selon l'architecture."""
    if arch == "x64":
        # 8 bytes, little-endian
        return value.to_bytes(8, 'little')
    else:  # x86
        # 4 bytes, little-endian
        return value.to_bytes(4, 'little')
```

### 2.4 Contrôle de RIP (3.4.5.g)

Une fois l'offset trouvé, on peut contrôler précisément RIP:

```
Structure de la stack:
+------------------+ <- RSP initial
|    buffer[64]    |
+------------------+ <- buffer + 64
|   saved RBP      | (8 bytes)
+------------------+ <- buffer + 72
|   saved RIP      | (8 bytes) <- CIBLE
+------------------+
```

#### Payload minimal

```python
def control_rip_payload(offset, target_rip):
    """
    Génère un payload pour contrôler RIP.
    """
    padding = b'A' * offset
    rip = target_rip.to_bytes(8, 'little')
    return padding + rip
```

### 2.5 Alignement Stack 16-byte (3.4.5.h)

L'ABI System V x86-64 requiert que RSP soit aligné sur 16 bytes avant un CALL.

#### Problème courant

```
Avant le crash:
RSP = 0x7fffffffde58  (aligné: 0x58 % 16 = 8 -> NON aligné)

movaps [rsp+0x50], xmm0  <- CRASH si RSP non aligné!
```

#### Solution: RET gadget

```python
def add_alignment_gadget(payload, ret_gadget):
    """
    Ajoute un RET gadget pour réaligner la stack.

    Avant: payload -> target
    Après: payload -> ret_gadget -> target

    Le RET supplémentaire fait: RSP += 8, réalignant la stack.
    """
    # Si RSP % 16 == 8, ajouter un RET
    return payload[:offset] + p64(ret_gadget) + payload[offset:]
```

### 2.6 Exemple Complet d'Exploitation

```python
def full_exploitation_example():
    """
    Exemple complet de détermination d'offset et exploitation.
    """

    # Étape 1: Générer pattern
    pattern = pattern_create(500)

    # Étape 2: Envoyer et récupérer crash info
    # (simulation)
    crash_rip = 0x6141376141366141  # "Aa6Aa7Aa" en little-endian
    crash_rbp = 0x6141356141346141  # "Aa4Aa5Aa"

    # Étape 3: Trouver offsets
    rip_offset = pattern_offset(pattern, crash_rip, "x64")
    rbp_offset = pattern_offset(pattern, crash_rbp, "x64")

    print(f"RBP offset: {rbp_offset}")  # 64
    print(f"RIP offset: {rip_offset}")  # 72

    # Étape 4: Vérifier alignement
    # RSP après overflow + 72 bytes
    alignment = check_alignment(0x7fffffffde08, 16)

    # Étape 5: Construire payload
    target = 0x00401196  # Fonction win()
    ret_gadget = 0x0040101a if alignment["needs_ret_gadget"] else None

    payload = generate_payload_skeleton(
        rip_offset,
        target,
        alignment_gadget=ret_gadget
    )

    return payload
```

### 2.7 Patterns Cycliques (pwntools style)

```python
def cyclic_impl(length, alphabet=string.ascii_lowercase, n=4):
    """
    Génère un pattern cyclique style pwntools.

    Utilise un alphabet plus simple (a-z) avec des séquences
    de n=4 caractères pour compatibilité 32-bit.
    """
    k = len(alphabet)

    # Générer séquence de de Bruijn
    def db_gen(t, p, a):
        if t > n:
            if n % p == 0:
                for i in range(1, p + 1):
                    yield alphabet[a[i]]
        else:
            a[t] = a[t - p]
            yield from db_gen(t + 1, p, a)
            for j in range(a[t - p] + 1, k):
                a[t] = j
                yield from db_gen(t + 1, t, a)

    a = [0] * (k * n)
    gen = db_gen(1, 1, a)

    result = []
    for char in gen:
        result.append(char)
        if len(result) >= length:
            break

    return ''.join(result).encode()
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - Offset Master Toolkit
"""

import string
from typing import Optional


def generate_de_bruijn_sequence(alphabet: str, n: int, length: int) -> str:
    """Génère une séquence de de Bruijn."""
    k = len(alphabet)
    a = [0] * (k * n)
    sequence = []

    def db(t, p):
        if t > n:
            if n % p == 0:
                for i in range(1, p + 1):
                    sequence.append(alphabet[a[i]])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            for j in range(a[t - p] + 1, k):
                a[t] = j
                db(t + 1, t)

    db(1, 1)

    # La séquence complète a longueur k^n
    # Tronquer à la longueur demandée
    return ''.join(sequence[:length])


def pattern_create(length: int, charset: str = "default") -> bytes:
    """Crée un pattern unique style Metasploit."""
    if charset == "default":
        upper = string.ascii_uppercase
        lower = string.ascii_lowercase
        digits = string.digits
    else:
        # Diviser le charset personnalisé en 3 parties
        third = len(charset) // 3
        upper = charset[:third]
        lower = charset[third:2*third]
        digits = charset[2*third:]

    pattern = []
    done = False

    for u in upper:
        if done:
            break
        for l in lower:
            if done:
                break
            for d in digits:
                pattern.extend([u, l, d])
                if len(pattern) >= length:
                    done = True
                    break

    return ''.join(pattern[:length]).encode()


def pattern_offset(pattern: bytes, value: int, arch: str = "x64") -> Optional[int]:
    """Trouve l'offset d'une valeur dans un pattern."""
    # Déterminer le nombre de bytes selon l'architecture
    if arch == "x64":
        num_bytes = 8
    else:  # x86
        num_bytes = 4

    # Convertir la valeur en bytes (little-endian)
    try:
        value_bytes = value.to_bytes(num_bytes, 'little')
    except OverflowError:
        return None

    # Chercher les 4 premiers bytes significatifs (non-nuls)
    # Car le pattern Metasploit utilise des caractères imprimables
    search_bytes = value_bytes.rstrip(b'\x00')
    if len(search_bytes) < 4:
        # Essayer de trouver avec les bytes disponibles
        search_bytes = value_bytes[:4]

    # Chercher dans le pattern
    offset = pattern.find(search_bytes)
    if offset != -1:
        return offset

    # Essayer avec seulement 4 bytes
    search_bytes = value_bytes[:4]
    offset = pattern.find(search_bytes)

    return offset if offset != -1 else None


def cyclic(length: int, n: int = 4) -> bytes:
    """Génère un pattern cyclique style pwntools."""
    alphabet = string.ascii_lowercase
    k = len(alphabet)
    sequence = []

    a = [0] * (k * n)

    def db(t, p):
        if t > n:
            if n % p == 0:
                for i in range(1, p + 1):
                    sequence.append(alphabet[a[i]])
                    if len(sequence) >= length:
                        return True
            return False
        else:
            a[t] = a[t - p]
            if db(t + 1, p):
                return True
            for j in range(a[t - p] + 1, k):
                a[t] = j
                if db(t + 1, t):
                    return True
            return False

    db(1, 1)

    return ''.join(sequence[:length]).encode()


def cyclic_find(subseq: bytes, n: int = 4) -> int:
    """Trouve l'offset d'une sous-séquence dans le pattern cyclique."""
    # Générer assez de pattern pour chercher
    # La longueur max d'un pattern avec alphabet=26, n=4 est 26^4 = 456976
    max_len = 26 ** n

    # Si la sous-séquence est une valeur numérique (little-endian)
    if len(subseq) == 4 and not all(c in string.ascii_lowercase.encode() for c in subseq):
        # Convertir de little-endian si nécessaire
        pass  # Déjà en bytes

    # Générer le pattern et chercher
    pattern = cyclic(min(max_len, 100000), n)

    offset = pattern.find(subseq)
    return offset


def calculate_padding(
    buffer_size: int,
    saved_rbp_offset: int,
    target_offset: str = "rip"
) -> dict:
    """Calcule le padding nécessaire pour différentes cibles."""
    result = {
        "buffer_size": buffer_size,
        "saved_rbp_offset": saved_rbp_offset,
        "stack_layout": {
            "buffer_start": 0,
            "buffer_end": buffer_size,
            "saved_rbp": saved_rbp_offset,
            "saved_rip": saved_rbp_offset + 8,
            "after_rip": saved_rbp_offset + 16
        }
    }

    if target_offset == "rbp":
        result["padding_needed"] = saved_rbp_offset
        result["target_description"] = "Overwrite saved RBP"
    elif target_offset == "rip":
        result["padding_to_rip"] = saved_rbp_offset + 8
        result["padding_needed"] = saved_rbp_offset + 8
        result["target_description"] = "Overwrite saved RIP (return address)"
    elif target_offset == "beyond_rip":
        result["padding_needed"] = saved_rbp_offset + 16
        result["target_description"] = "Write beyond saved RIP (for ROP chain)"

    return result


def check_alignment(rsp_after_ret: int, required_alignment: int = 16) -> dict:
    """Vérifie l'alignement de la stack après un RET."""
    current_alignment = rsp_after_ret % required_alignment
    aligned = (current_alignment == 0)

    adjustment_needed = 0 if aligned else (required_alignment - current_alignment)

    return {
        "aligned": aligned,
        "rsp_value": hex(rsp_after_ret),
        "current_alignment": current_alignment,
        "required_alignment": required_alignment,
        "adjustment_needed": adjustment_needed,
        "needs_ret_gadget": not aligned and adjustment_needed == 8,
        "explanation": (
            "Stack is aligned" if aligned else
            f"Stack misaligned by {current_alignment} bytes. "
            f"Add {'a RET gadget' if adjustment_needed == 8 else f'{adjustment_needed} bytes'} to realign."
        )
    }


def generate_payload_skeleton(
    padding: int,
    rip_value: int,
    args: list = None,
    alignment_gadget: int = None
) -> bytes:
    """Génère un squelette de payload avec padding automatique."""
    payload = b'A' * padding

    # Ajouter gadget d'alignement si nécessaire
    if alignment_gadget is not None:
        payload += alignment_gadget.to_bytes(8, 'little')

    # Ajouter l'adresse RIP cible
    payload += rip_value.to_bytes(8, 'little')

    # Ajouter les arguments (pour ROP)
    if args:
        for arg in args:
            if isinstance(arg, int):
                payload += arg.to_bytes(8, 'little')
            elif isinstance(arg, bytes):
                payload += arg
            else:
                payload += str(arg).encode()

    return payload


def analyze_crash(
    crash_rip: int,
    crash_rsp: int,
    crash_rbp: int,
    pattern: bytes
) -> dict:
    """Analyse un crash pour déterminer tous les offsets."""
    result = {
        "crash_info": {
            "rip": hex(crash_rip),
            "rsp": hex(crash_rsp),
            "rbp": hex(crash_rbp)
        },
        "pattern_length": len(pattern)
    }

    # Trouver offset RIP
    rip_offset = pattern_offset(pattern, crash_rip, "x64")
    result["rip_offset"] = rip_offset
    result["rip_controlled"] = rip_offset is not None

    # Trouver offset RBP
    rbp_offset = pattern_offset(pattern, crash_rbp, "x64")
    result["rbp_offset"] = rbp_offset
    result["rbp_controlled"] = rbp_offset is not None

    # Calculer la taille du buffer
    if rip_offset is not None and rbp_offset is not None:
        result["buffer_size_estimate"] = rbp_offset
        result["saved_rbp_to_rip_gap"] = rip_offset - rbp_offset

        if result["saved_rbp_to_rip_gap"] == 8:
            result["layout_standard"] = True
            result["analysis"] = (
                f"Standard stack layout detected. "
                f"Buffer size: ~{rbp_offset} bytes. "
                f"Padding to RIP: {rip_offset} bytes."
            )
        else:
            result["layout_standard"] = False
            result["analysis"] = (
                f"Non-standard layout. Gap between RBP and RIP: "
                f"{result['saved_rbp_to_rip_gap']} bytes."
            )
    elif rip_offset is not None:
        result["analysis"] = f"RIP controlled at offset {rip_offset}. RBP offset unknown."
    else:
        result["analysis"] = "Could not determine offsets from crash values."

    # Recommandation de payload
    if rip_offset is not None:
        result["payload_recommendation"] = {
            "padding": rip_offset,
            "format": f"b'A' * {rip_offset} + p64(target_address)"
        }

    return result


def p64(value: int) -> bytes:
    """Pack un entier en 8 bytes little-endian."""
    return value.to_bytes(8, 'little')


def p32(value: int) -> bytes:
    """Pack un entier en 4 bytes little-endian."""
    return value.to_bytes(4, 'little')


def u64(data: bytes) -> int:
    """Unpack 8 bytes little-endian en entier."""
    return int.from_bytes(data[:8], 'little')


def u32(data: bytes) -> int:
    """Unpack 4 bytes little-endian en entier."""
    return int.from_bytes(data[:4], 'little')


def main():
    """Démonstration du toolkit."""
    print("Offset Master Toolkit Demo")
    print("=" * 60)

    # Générer un pattern
    pattern = pattern_create(200)
    print(f"\nPattern (first 50 bytes): {pattern[:50]}")

    # Simuler un crash
    # Supposons buffer[64], donc RBP à offset 64, RIP à offset 72
    crash_rip_bytes = pattern[72:80]
    crash_rbp_bytes = pattern[64:72]

    crash_rip = int.from_bytes(crash_rip_bytes, 'little')
    crash_rbp = int.from_bytes(crash_rbp_bytes, 'little')

    print(f"\nSimulated crash:")
    print(f"  RIP = 0x{crash_rip:016x}")
    print(f"  RBP = 0x{crash_rbp:016x}")

    # Analyser le crash
    analysis = analyze_crash(crash_rip, 0x7fff0000, crash_rbp, pattern)
    print(f"\nAnalysis:")
    print(f"  RIP offset: {analysis['rip_offset']}")
    print(f"  RBP offset: {analysis['rbp_offset']}")
    print(f"  {analysis['analysis']}")

    # Vérifier alignement
    alignment = check_alignment(0x7fff0008, 16)
    print(f"\nAlignment check:")
    print(f"  Aligned: {alignment['aligned']}")
    print(f"  {alignment['explanation']}")

    # Générer payload
    target = 0x00401234
    ret_gadget = 0x0040101a

    payload = generate_payload_skeleton(
        72,
        target,
        alignment_gadget=ret_gadget if alignment["needs_ret_gadget"] else None
    )

    print(f"\nGenerated payload:")
    print(f"  Length: {len(payload)} bytes")
    print(f"  Target: 0x{target:016x}")

    # Pattern cyclique
    print("\n" + "=" * 60)
    print("Cyclic pattern (pwntools style):")
    cyc = cyclic(50)
    print(f"  {cyc}")

    # Recherche dans cyclic
    offset = cyclic_find(b'eaaa')
    print(f"  Offset of 'eaaa': {offset}")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.5-b",
  "title": "Le Maitre des Offsets",
  "module": "3.4",
  "tier": 2,
  "difficulty": 5,
  "xp_value": 400,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 30,
  "memory_limit_mb": 128,

  "test_cases": [
    {
      "id": "pattern_create_length",
      "description": "Pattern create generates correct length",
      "input": {
        "function": "pattern_create",
        "args": {"length": 100}
      },
      "expected": {
        "type": "bytes",
        "length": 100
      },
      "points": 10
    },
    {
      "id": "pattern_create_unique",
      "description": "Pattern contains unique 4-byte sequences",
      "input": {
        "function": "pattern_create",
        "args": {"length": 500}
      },
      "expected": {
        "unique_4byte_sequences": true
      },
      "points": 15
    },
    {
      "id": "pattern_offset_find",
      "description": "Find offset of value in pattern",
      "input": {
        "function": "pattern_offset",
        "args": {
          "pattern": "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5",
          "value": 1631666017,
          "arch": "x64"
        }
      },
      "expected": {
        "offset": 20
      },
      "points": 20
    },
    {
      "id": "cyclic_generate",
      "description": "Cyclic pattern generation",
      "input": {
        "function": "cyclic",
        "args": {"length": 20, "n": 4}
      },
      "expected": {
        "starts_with": "aaaa",
        "length": 20
      },
      "points": 10
    },
    {
      "id": "cyclic_find_offset",
      "description": "Find offset in cyclic pattern",
      "input": {
        "function": "cyclic_find",
        "args": {"subseq": "faaa", "n": 4}
      },
      "expected": {
        "offset": 20
      },
      "points": 15
    },
    {
      "id": "calculate_padding_rip",
      "description": "Calculate padding to RIP",
      "input": {
        "function": "calculate_padding",
        "args": {"buffer_size": 64, "saved_rbp_offset": 64, "target_offset": "rip"}
      },
      "expected": {
        "padding_to_rip": 72
      },
      "points": 10
    },
    {
      "id": "check_alignment_misaligned",
      "description": "Detect misaligned stack",
      "input": {
        "function": "check_alignment",
        "args": {"rsp_after_ret": 140737488289800, "required_alignment": 16}
      },
      "expected": {
        "aligned": false,
        "needs_ret_gadget": true
      },
      "points": 10
    },
    {
      "id": "generate_payload",
      "description": "Generate payload with alignment gadget",
      "input": {
        "function": "generate_payload_skeleton",
        "args": {"padding": 72, "rip_value": 4198708, "alignment_gadget": 4198426}
      },
      "expected": {
        "length": 88
      },
      "points": 15
    },
    {
      "id": "analyze_crash_full",
      "description": "Full crash analysis",
      "input": {
        "function": "analyze_crash",
        "args": {
          "crash_rip": 6076984268653261121,
          "crash_rsp": 140737488289792,
          "crash_rbp": 6076915529560826177,
          "pattern": "pattern_create(200)"
        }
      },
      "expected": {
        "rip_controlled": true,
        "rbp_controlled": true
      },
      "points": 20
    }
  ],

  "edge_cases": [
    {
      "id": "pattern_not_found",
      "description": "Value not in pattern",
      "input": {
        "function": "pattern_offset",
        "args": {"pattern": "Aa0Aa1", "value": 3735928559, "arch": "x64"}
      },
      "expected_behavior": "Return None for value not found"
    },
    {
      "id": "zero_padding",
      "description": "Zero padding payload",
      "input": {
        "function": "generate_payload_skeleton",
        "args": {"padding": 0, "rip_value": 4198708}
      },
      "expected_behavior": "Return just the RIP value packed"
    }
  ],

  "validation": {
    "required_functions": [
      "generate_de_bruijn_sequence",
      "pattern_create",
      "pattern_offset",
      "cyclic",
      "cyclic_find",
      "calculate_padding",
      "check_alignment",
      "generate_payload_skeleton",
      "analyze_crash"
    ],
    "forbidden_imports": ["pwntools", "pwnlib", "subprocess"],
    "min_test_coverage": 85
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour offset_master.py
"""

import unittest
import string


class TestPatternCreationMutations(unittest.TestCase):
    """Tests de mutation pour la création de patterns."""

    def setUp(self):
        from offset_master import pattern_create, generate_de_bruijn_sequence
        self.pattern_create = pattern_create
        self.de_bruijn = generate_de_bruijn_sequence

    # Mutant 1: Pattern length incorrect
    def test_mutant_pattern_length(self):
        """MUTANT: Pattern length off by one."""
        for length in [50, 100, 200, 500]:
            pattern = self.pattern_create(length)
            self.assertEqual(len(pattern), length,
                           f"Pattern should be exactly {length} bytes")

    # Mutant 2: Non-unique subsequences
    def test_mutant_unique_subsequences(self):
        """MUTANT: Pattern with duplicate 4-byte sequences."""
        pattern = self.pattern_create(500)

        # Check that all 4-byte sequences are unique
        subsequences = set()
        for i in range(len(pattern) - 3):
            subseq = pattern[i:i+4]
            self.assertNotIn(subseq, subsequences,
                           f"Duplicate subsequence found at offset {i}")
            subsequences.add(subseq)

    # Mutant 3: de Bruijn with wrong alphabet
    def test_mutant_debruijn_alphabet(self):
        """MUTANT: Using wrong alphabet in de Bruijn."""
        seq = self.de_bruijn("abc", 2, 20)

        # Every character should be from the alphabet
        for c in seq:
            self.assertIn(c, "abc",
                         f"Character '{c}' not in alphabet")


class TestOffsetFindingMutations(unittest.TestCase):
    """Tests de mutation pour la recherche d'offset."""

    def setUp(self):
        from offset_master import pattern_create, pattern_offset
        self.pattern_create = pattern_create
        self.pattern_offset = pattern_offset

    # Mutant 4: Wrong endianness
    def test_mutant_endianness(self):
        """MUTANT: Using big-endian instead of little-endian."""
        pattern = self.pattern_create(200)

        # Get bytes at offset 20
        expected_bytes = pattern[20:24]
        value_le = int.from_bytes(expected_bytes, 'little')

        offset = self.pattern_offset(pattern, value_le, "x64")
        self.assertEqual(offset, 20,
                        "Should find offset with little-endian interpretation")

    # Mutant 5: Off-by-one offset
    def test_mutant_offset_exact(self):
        """MUTANT: Returning offset +/- 1."""
        pattern = self.pattern_create(200)

        # Test multiple known offsets
        for expected_offset in [0, 20, 50, 100]:
            value_bytes = pattern[expected_offset:expected_offset+4]
            value = int.from_bytes(value_bytes, 'little')
            found_offset = self.pattern_offset(pattern, value, "x64")

            self.assertEqual(found_offset, expected_offset,
                           f"Offset should be exactly {expected_offset}")


class TestCyclicMutations(unittest.TestCase):
    """Tests de mutation pour les patterns cycliques."""

    def setUp(self):
        from offset_master import cyclic, cyclic_find
        self.cyclic = cyclic
        self.cyclic_find = cyclic_find

    # Mutant 6: Cyclic not starting correctly
    def test_mutant_cyclic_start(self):
        """MUTANT: Cyclic not starting with 'aaaa'."""
        pattern = self.cyclic(100, 4)
        self.assertTrue(pattern.startswith(b'aaaa'),
                       "Cyclic pattern should start with 'aaaa'")

    # Mutant 7: cyclic_find returns wrong offset
    def test_mutant_cyclic_find_accuracy(self):
        """MUTANT: cyclic_find returning incorrect offset."""
        pattern = self.cyclic(1000, 4)

        # Test finding various subsequences
        test_cases = [
            (b'aaaa', 0),
            (b'baaa', 4),
            (b'caaa', 8),
        ]

        for subseq, expected in test_cases:
            found = self.cyclic_find(subseq, 4)
            self.assertEqual(found, expected,
                           f"'{subseq.decode()}' should be at offset {expected}")


class TestAlignmentMutations(unittest.TestCase):
    """Tests de mutation pour la vérification d'alignement."""

    def setUp(self):
        from offset_master import check_alignment
        self.check = check_alignment

    # Mutant 8: Alignment check inverted
    def test_mutant_alignment_logic(self):
        """MUTANT: Returning aligned=True when misaligned."""
        # 0x7fff0008 % 16 = 8, so NOT aligned
        result = self.check(0x7fff0008, 16)
        self.assertFalse(result["aligned"])
        self.assertTrue(result["needs_ret_gadget"])

        # 0x7fff0010 % 16 = 0, so aligned
        result = self.check(0x7fff0010, 16)
        self.assertTrue(result["aligned"])
        self.assertFalse(result["needs_ret_gadget"])

    # Mutant 9: Wrong adjustment calculation
    def test_mutant_adjustment(self):
        """MUTANT: Calculating wrong adjustment needed."""
        result = self.check(0x7fff0008, 16)
        self.assertEqual(result["current_alignment"], 8)
        self.assertEqual(result["adjustment_needed"], 8)


class TestPayloadGenerationMutations(unittest.TestCase):
    """Tests de mutation pour la génération de payload."""

    def setUp(self):
        from offset_master import generate_payload_skeleton
        self.generate = generate_payload_skeleton

    # Mutant 10: Payload length incorrect
    def test_mutant_payload_length(self):
        """MUTANT: Payload length wrong."""
        # Without alignment gadget: padding + 8 (RIP)
        payload = self.generate(72, 0x401234)
        self.assertEqual(len(payload), 80)

        # With alignment gadget: padding + 8 (gadget) + 8 (RIP)
        payload = self.generate(72, 0x401234, alignment_gadget=0x40101a)
        self.assertEqual(len(payload), 88)


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Qu'est-ce qu'une séquence de de Bruijn B(k,n) ?**

- [ ] A) Une séquence de k caractères répétée n fois
- [x] B) Une séquence où chaque sous-chaîne de longueur n apparaît exactement une fois
- [ ] C) Une séquence aléatoire de longueur k*n
- [ ] D) Une séquence triée alphabétiquement

**Explication**: Une séquence de de Bruijn B(k,n) sur un alphabet de k symboles contient chaque sous-séquence possible de longueur n exactement une fois, ce qui la rend idéale pour identifier des offsets.

---

### Question 2
**Pourquoi utilise-t-on des patterns uniques pour trouver des offsets ?**

- [ ] A) Pour compresser les données
- [ ] B) Pour chiffrer le payload
- [x] C) Pour identifier précisément quelle partie du buffer écrase RIP
- [ ] D) Pour éviter les bad characters

**Explication**: Avec un pattern où chaque sous-séquence de 4 bytes est unique, la valeur trouvée dans RIP lors du crash permet de déterminer exactement l'offset dans le buffer.

---

### Question 3
**Dans un crash avec RIP=0x41366141, comment interpréter cette valeur ?**

- [ ] A) C'est l'adresse d'une fonction
- [x] B) En little-endian, c'est "Aa6A" du pattern, indiquant l'offset
- [ ] C) C'est une erreur système
- [ ] D) C'est le canary

**Explication**: 0x41366141 en little-endian donne les bytes 0x41, 0x61, 0x36, 0x41 = "Aa6A". En trouvant cette séquence dans le pattern, on obtient l'offset exact.

---

### Question 4
**Quel est l'offset vers RIP si le buffer fait 64 bytes avec une stack standard ?**

- [ ] A) 64 bytes
- [x] B) 72 bytes (64 buffer + 8 saved RBP)
- [ ] C) 80 bytes
- [ ] D) 56 bytes

**Explication**: Sur x86-64, après le buffer vient le saved RBP (8 bytes), puis le saved RIP. Donc offset = buffer_size + 8.

---

### Question 5
**Pourquoi faut-il parfois ajouter un RET gadget pour l'alignement ?**

- [ ] A) Pour exécuter plus de code
- [ ] B) Pour bypasser le canary
- [x] C) L'ABI x64 requiert RSP aligné sur 16 bytes avant un CALL
- [ ] D) Pour éviter les bad characters

**Explication**: L'ABI System V x86-64 exige que RSP soit aligné sur 16 bytes avant un CALL. Certaines fonctions (comme celles utilisant SIMD) crashent si mal alignées. Un RET supplémentaire ajuste RSP de 8 bytes.

---

### Question 6
**Quelle est la différence entre pattern_create (Metasploit) et cyclic (pwntools) ?**

- [ ] A) Ils sont identiques
- [x] B) Metasploit utilise Aa0-Zz9, pwntools utilise aaaa-zzzz
- [ ] C) pwntools génère des patterns plus longs
- [ ] D) Metasploit est plus rapide

**Explication**: pattern_create utilise un alphabet mixte (majuscules, minuscules, chiffres) en format "Aa0Aa1...", tandis que cyclic utilise uniquement des minuscules en format "aaaabaaacaaa...".

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Oublier l'endianness**: x86/x64 sont little-endian.

2. **Confondre offset RBP et RIP**: RIP = RBP offset + 8.

3. **Ignorer l'alignement**: Cause des crashs mystérieux avec SSE/AVX.

4. **Pattern trop court**: Générer au moins 500 bytes pour être sûr.

### Bonnes Pratiques

```python
# Toujours vérifier que l'offset trouvé est cohérent
def verify_offset(pattern, offset, crash_value):
    expected = pattern[offset:offset+8]
    actual = crash_value.to_bytes(8, 'little')[:len(expected)]
    return expected == actual

# Utiliser des helpers pour la lisibilité
def p64(x): return x.to_bytes(8, 'little')
def u64(x): return int.from_bytes(x, 'little')
```

---

## Section 8 : Ressources et Références

### Outils
- Metasploit pattern_create: rapid7.com
- pwntools cyclic: docs.pwntools.com

### Documentation
- x86-64 ABI: refspecs.linuxfoundation.org

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| pattern_create/de_bruijn | 20 |
| pattern_offset | 25 |
| cyclic/cyclic_find | 20 |
| check_alignment | 15 |
| generate_payload_skeleton | 10 |
| analyze_crash | 10 |
| **Total** | **100** |
