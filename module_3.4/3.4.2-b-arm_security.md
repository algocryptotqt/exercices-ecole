# Exercice 3.4.2-b : ARM Security Features

## Metadata
- **Exercice ID**: 3.4.2-b
- **Titre**: ARM Security Features
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Architecture ARM (Niveau 2)
- **Difficulté**: ⭐⭐⭐⭐⭐⭐⭐⭐ (8/10 - Expert+)
- **Tier**: 2
- **XP**: 700

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.2.h | ARM Protections (PXN, PAN) |
| 3.4.4.w | ARM MTE (Memory Tagging Extension) |
| 3.4.4.x | ARM BTI (Branch Target Identification) |
| 3.4.4.y | ARM PAC (Pointer Authentication Codes) |
| 3.4.4.z | PAC Bypass Techniques |

## Prerequis
- Module 3.4.2-a : ARM Decoder (decodage d'instructions ARM64)
- Comprehension de l'architecture ARMv8.x/v9
- Notions de securite memoire et control flow integrity
- Bases de l'exploitation binaire

---

## Section 1 : Prototype de Fonction

```python
"""
Module: arm_security - Analyse des Fonctionnalités de Sécurité ARM
Architecture: ARM64 (AArch64) avec extensions ARMv8.3+
Contraintes: Simulation sans hardware ARM réel
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Optional
import struct


class ARMSecurityFeature(Enum):
    """Fonctionnalités de sécurité ARM."""
    PXN = auto()      # Privileged Execute Never
    PAN = auto()      # Privileged Access Never
    MTE = auto()      # Memory Tagging Extension
    BTI = auto()      # Branch Target Identification
    PAC = auto()      # Pointer Authentication
    PACGA = auto()    # PAC Generic Authentication


class PACKey(Enum):
    """Clés PAC disponibles."""
    IA = "APIAKey"    # Instruction Address key A
    IB = "APIBKey"    # Instruction Address key B
    DA = "APDAKey"    # Data Address key A
    DB = "APDBKey"    # Data Address key B
    GA = "APGAKey"    # Generic Authentication key


class MTEMode(Enum):
    """Modes MTE."""
    DISABLED = 0
    SYNC = 1          # Synchronous checking
    ASYNC = 2         # Asynchronous checking
    ASYMM = 3         # Asymmetric


@dataclass
class PACContext:
    """Contexte pour les opérations PAC."""
    keys: dict[PACKey, int] = field(default_factory=dict)
    modifier: int = 0
    pac_mask: int = 0x007F000000000000  # Bits 48-54 typiques


@dataclass
class MTEContext:
    """Contexte pour les opérations MTE."""
    mode: MTEMode = MTEMode.DISABLED
    tag_granule: int = 16  # Bytes per tag (toujours 16)
    memory_tags: dict[int, int] = field(default_factory=dict)  # addr -> tag


@dataclass
class BTIContext:
    """Contexte pour BTI."""
    enabled: bool = False
    landing_pads: set[int] = field(default_factory=set)  # Adresses avec BTI


def analyze_arm_security_features(binary_info: dict) -> dict:
    """
    Analyse les fonctionnalités de sécurité ARM d'un binaire.

    Args:
        binary_info: Dict avec headers ELF, sections, et attributs

    Returns:
        Dict avec:
        - features: Liste des features détectées
        - pac_enabled: État PAC
        - bti_enabled: État BTI
        - mte_compatible: Compatibilité MTE
        - protection_level: Niveau de protection global

    Exemple:
        >>> info = {"elf_flags": 0x800000, "gnu_properties": [...]}
        >>> result = analyze_arm_security_features(info)
        >>> "PAC" in result["features"]
        True
    """
    pass


def simulate_pac_sign(
    pointer: int,
    context: int,
    key: PACKey,
    pac_context: PACContext
) -> int:
    """
    Simule la signature PAC d'un pointeur.

    Args:
        pointer: Pointeur à signer (64 bits)
        context: Modificateur de contexte (souvent SP)
        key: Clé PAC à utiliser
        pac_context: Contexte avec les clés

    Returns:
        Pointeur signé avec PAC dans les bits supérieurs

    Exemple:
        >>> ctx = PACContext(keys={PACKey.IA: 0x123456789ABCDEF0})
        >>> signed = simulate_pac_sign(0x400000, 0, PACKey.IA, ctx)
        >>> signed != 0x400000
        True
    """
    pass


def simulate_pac_auth(
    signed_pointer: int,
    context: int,
    key: PACKey,
    pac_context: PACContext
) -> dict:
    """
    Simule l'authentification PAC d'un pointeur.

    Args:
        signed_pointer: Pointeur avec PAC
        context: Modificateur de contexte
        key: Clé PAC utilisée
        pac_context: Contexte avec les clés

    Returns:
        Dict avec:
        - valid: Booléen de validité
        - original_pointer: Pointeur sans PAC
        - expected_pac: PAC attendu
        - actual_pac: PAC trouvé

    Exemple:
        >>> result = simulate_pac_auth(signed_ptr, 0, PACKey.IA, ctx)
        >>> result["valid"]
        True
    """
    pass


def simulate_mte_operations(
    operations: list[dict],
    mte_context: MTEContext
) -> dict:
    """
    Simule des opérations mémoire avec MTE.

    Args:
        operations: Liste de {"type": "load"/"store", "addr": int, "tag": int}
        mte_context: Contexte MTE avec tags mémoire

    Returns:
        Dict avec:
        - results: Résultats de chaque opération
        - violations: Violations de tag détectées
        - tags_assigned: Tags assignés

    Exemple:
        >>> ctx = MTEContext(mode=MTEMode.SYNC)
        >>> ops = [{"type": "store", "addr": 0x1000, "ptr_tag": 5, "data": 0}]
        >>> result = simulate_mte_operations(ops, ctx)
    """
    pass


def check_bti_compliance(
    instructions: list[str],
    entry_points: list[int]
) -> dict:
    """
    Vérifie la conformité BTI d'un bloc de code ARM64.

    Args:
        instructions: Liste d'instructions assembleur ARM64
        entry_points: Adresses qui doivent avoir landing pads

    Returns:
        Dict avec:
        - compliant: Booléen de conformité globale
        - missing_bti: Points d'entrée sans BTI
        - indirect_branches: Branches indirects trouvés
        - landing_pads: Landing pads détectés

    Exemple:
        >>> instrs = ["bti c", "stp x29, x30, [sp, #-16]!", "bl func"]
        >>> result = check_bti_compliance(instrs, [0])
        >>> result["compliant"]
        True
    """
    pass


def analyze_pac_bypass_scenarios(
    binary_info: dict,
    available_primitives: list[str]
) -> dict:
    """
    Analyse les scénarios de bypass PAC possibles.

    Args:
        binary_info: Informations sur le binaire
        available_primitives: Primitives disponibles (leak, write, uaf, etc.)

    Returns:
        Dict avec:
        - bypass_possible: Booléen
        - strategies: Liste de stratégies viables
        - difficulty: Difficulté estimée

    Stratégies PAC bypass:
    - pac_oracle: Timing/crash oracle pour bruteforce
    - signing_gadget: Gadget qui signe des pointeurs arbitraires
    - pac_forgery: Forger PAC via collision
    - context_manipulation: Manipuler le modificateur
    """
    pass


def simulate_pxn_pan_checks(
    access_info: dict,
    current_el: int
) -> dict:
    """
    Simule les vérifications PXN et PAN.

    Args:
        access_info: {"type": "exec"/"read"/"write", "addr": int, "privileged": bool}
        current_el: Exception Level actuel (0-3)

    Returns:
        Dict avec:
        - pxn_blocks: Si PXN bloque l'exécution
        - pan_blocks: Si PAN bloque l'accès
        - allowed: Si l'accès est autorisé
        - reason: Explication

    Exemple:
        >>> access = {"type": "exec", "addr": 0xFFFF0000, "user_page": True}
        >>> result = simulate_pxn_pan_checks(access, 1)
        >>> result["pxn_blocks"]
        True
    """
    pass


def generate_pac_signed_rop_chain(
    gadgets: list[dict],
    pac_context: PACContext,
    target: int
) -> dict:
    """
    Génère une chaîne ROP avec des adresses signées PAC.

    Args:
        gadgets: Liste de gadgets avec adresses
        pac_context: Contexte PAC pour signature
        target: Adresse cible finale

    Returns:
        Dict avec:
        - chain: Chaîne ROP avec pointeurs signés
        - signing_context: Contexte utilisé pour chaque signature
        - success_probability: Probabilité de succès
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Introduction aux Fonctionnalités de Sécurité ARM

ARM a introduit plusieurs fonctionnalités de sécurité matérielles dans les architectures ARMv8.x et ARMv9, visant à contrer les attaques d'exploitation mémoire.

### 2.2 PXN et PAN (3.4.2.h)

#### PXN - Privileged Execute Never

**PXN** empêche le kernel d'exécuter du code dans les pages mappées pour l'userspace.

```
Sans PXN:
- Attaquant mappe shellcode en userspace
- Exploit kernel jump vers ce shellcode
- Code malveillant exécuté en mode privilégié

Avec PXN:
- Page descriptor contient bit PXN
- CPU vérifie PXN lors de l'instruction fetch
- Exécution depuis page user en EL1+ = Data Abort
```

#### PAN - Privileged Access Never

**PAN** empêche le kernel d'accéder (lecture/écriture) aux pages userspace sauf via des instructions spéciales.

```
Registre PSTATE.PAN:
- PAN=1: Accès user depuis EL1 déclenche fault
- PAN=0: Accès normal autorisé

Instructions privilégiées pour accès user:
- LDTR/STTR: Load/Store with Translation
- Ces instructions sont explicitement autorisées même avec PAN=1
```

#### Exemple de vérification

```python
def check_pxn_pan(page_descriptor, access_type, current_el, pstate_pan):
    """
    Vérifie si un accès est autorisé par PXN/PAN.
    """
    pxn_bit = (page_descriptor >> 53) & 1
    user_accessible = (page_descriptor >> 6) & 1  # AP[1]

    if current_el >= 1 and user_accessible:
        # Accès kernel vers page user
        if access_type == "execute" and pxn_bit:
            return False, "PXN blocks privileged execution"
        if access_type in ["read", "write"] and pstate_pan:
            return False, "PAN blocks privileged access"

    return True, "Access allowed"
```

### 2.3 ARM MTE - Memory Tagging Extension (3.4.4.w)

**MTE** assigne des tags de 4 bits aux pointeurs et aux régions mémoire, vérifiant la correspondance lors des accès.

#### Architecture MTE

```
Pointer format (64 bits):
[63:60] - Tag (4 bits)
[59:0]  - Adresse virtuelle

Memory granule: 16 bytes
Chaque granule de 16 bytes a un tag de 4 bits associé

Lors d'un accès mémoire:
1. CPU extrait le tag du pointeur (bits 63:60)
2. CPU lit le tag de la mémoire cible
3. Si tags différents: Tag Check Fault
```

#### Modes MTE

```python
class MTEMode:
    DISABLED = 0  # Pas de vérification
    SYNC = 1      # Vérification synchrone, fault immédiat
    ASYNC = 2     # Vérification asynchrone, fault différé (plus performant)
    ASYMM = 3     # Sync pour reads, async pour writes
```

#### Instructions MTE

```asm
; Instructions de manipulation de tags
IRG Xd, Xn, Xm    ; Insert Random tag into Xd
ADDG Xd, Xn, #imm ; Add with tag (incrémente aussi le tag)
SUBG Xd, Xn, #imm ; Sub with tag
GMI Xd, Xn, Xm    ; Tag mask insert

; Instructions de stockage/chargement de tags
STG [Xn], Xt      ; Store allocation tag
LDG Xt, [Xn]      ; Load allocation tag
STZG [Xn]         ; Store tag and zero memory
```

#### Protection contre les vulnérabilités

```
MTE protège contre:
- Use-After-Free: Tag du pointeur != tag de la mémoire réallouée
- Buffer Overflow: Tags différents entre buffers adjacents
- Double Free: Tag modifié après première libération

Limitations:
- 16 tags possibles (4 bits) = collision ~6% avec random
- Granularité de 16 bytes
- Overhead mémoire pour stocker les tags
```

### 2.4 ARM BTI - Branch Target Identification (3.4.4.x)

**BTI** est l'équivalent ARM d'Intel CET IBT. Il marque les cibles valides de branches indirects.

#### Instructions BTI

```asm
BTI c    ; Valid target for indirect CALL (BLR)
BTI j    ; Valid target for indirect JUMP (BR)
BTI jc   ; Valid target for both CALL and JUMP
BTI      ; Valid target for both (alias de BTI jc)
```

#### Encodage

```
BTI c  = D503245F
BTI j  = D503249F
BTI jc = D50324DF
```

#### Vérification

```python
def check_bti_landing(instruction_at_target, branch_type):
    """
    Vérifie si la cible a un landing pad BTI approprié.
    """
    if not bti_enabled:
        return True

    bti_type = extract_bti_type(instruction_at_target)

    if bti_type is None:
        return False  # Pas de BTI = fault

    if branch_type == "BLR":  # Indirect call
        return bti_type in ["c", "jc"]
    elif branch_type == "BR":  # Indirect jump
        return bti_type in ["j", "jc"]

    return True
```

### 2.5 ARM PAC - Pointer Authentication Codes (3.4.4.y)

**PAC** signe cryptographiquement les pointeurs pour détecter les modifications.

#### Architecture PAC

```
Pointer signé (64 bits):
[63:VA_top] - PAC (signature)
[VA_top:0]  - Adresse virtuelle

Où VA_top dépend de la configuration de l'espace d'adressage:
- TCR_EL1.T0SZ définit la taille de l'espace user
- Typiquement bits 48-54 ou 48-63 pour PAC
```

#### Clés PAC

```
5 clés disponibles:
- APIAKey: Instruction Address, usage général
- APIBKey: Instruction Address, usage alternatif
- APDAKey: Data Address, pointeurs de données
- APDBKey: Data Address, alternatif
- APGAKey: Generic Authentication (données arbitraires)
```

#### Instructions PAC

```asm
; Signature
PACIA X0, X1     ; Sign X0 with APIA key, X1 as modifier
PACIB X0, X1     ; Sign with APIB key
PACDA X0, X1     ; Sign data pointer with APDA key
PACDZA X0        ; Sign data pointer with zero modifier
PACGA X0, X1, X2 ; Generic authentication

; Authentification
AUTIA X0, X1     ; Authenticate X0 with APIA key
AUTDA X0, X1     ; Authenticate data pointer
XPACI X0         ; Strip PAC bits (sans vérification)

; Combined instructions
BLRAA X0, X1     ; Authenticate and branch with link
BRAA X0, X1      ; Authenticate and branch
RETAA            ; Authenticate return address and return
```

#### Algorithme de signature (simplifié)

```python
def pac_sign(pointer, modifier, key):
    """
    Simule la signature PAC (algorithme réel est QARMA).
    """
    # Extraire l'adresse effective
    va_bits = pointer & VA_MASK

    # Calculer le PAC (hash cryptographique)
    input_data = (va_bits << 64) | modifier
    pac = qarma_encrypt(input_data, key)

    # Insérer le PAC dans les bits supérieurs
    pac_masked = pac & PAC_MASK
    signed_pointer = va_bits | (pac_masked << PAC_SHIFT)

    return signed_pointer

def pac_auth(signed_pointer, modifier, key):
    """
    Vérifie le PAC et retourne le pointeur ou corrupted pointer.
    """
    extracted_pac = (signed_pointer >> PAC_SHIFT) & PAC_MASK
    va_bits = signed_pointer & VA_MASK

    expected_pac = pac_sign(va_bits, modifier, key) >> PAC_SHIFT

    if extracted_pac == expected_pac:
        return va_bits  # Pointeur valide
    else:
        # Pointer corrompu avec pattern reconnaissable
        return va_bits | ERROR_CODE  # Déclenche fault à l'usage
```

### 2.6 Techniques de Bypass PAC (3.4.4.z)

#### 1. PAC Oracle Attack

```python
def pac_oracle_bruteforce(target_ptr, modifier, bits_to_guess):
    """
    Bruteforce PAC via timing ou crash oracle.
    """
    # Le PAC a typiquement 7-15 bits
    # 2^15 = 32768 tentatives max

    for guess in range(2 ** bits_to_guess):
        forged_pac = guess << PAC_SHIFT
        test_ptr = (target_ptr & VA_MASK) | forged_pac

        if oracle_test(test_ptr, modifier):
            return test_ptr

    return None
```

#### 2. Signing Gadget

```
Si on trouve un gadget qui:
1. Prend un pointeur arbitraire
2. Le signe avec PAC
3. Le stocke quelque part de lisible

On peut signer n'importe quel pointeur!

Exemple de gadget dangereux:
    LDR X0, [X1]      ; Charge pointeur arbitraire
    PACIA X0, SP      ; Signe avec SP comme modifier
    STR X0, [X2]      ; Stocke le résultat
```

#### 3. Context Manipulation

```python
def pac_context_manipulation(target, original_modifier, controlled_modifier):
    """
    Si on contrôle le modifier utilisé lors de l'auth,
    on peut forger un pointeur.
    """
    # Signer le target avec notre modifier contrôlé
    signed = pac_sign(target, controlled_modifier, key)

    # Lors de l'auth, fournir le même modifier
    # Le PAC correspondra!
    return signed
```

#### 4. Substitution Attack

```
Si deux pointeurs P1 et P2 sont signés avec le même modifier:
- PAC(P1, mod) et PAC(P2, mod)
- On peut substituer un par l'autre dans certains contextes
```

### 2.7 Combinaison des Protections

```
Apple Silicon (M1/M2/M3):
- PAC: Activé par défaut
- BTI: Supporté mais dépend du binaire
- MTE: Non supporté (Apple utilise d'autres mécanismes)

Android (ARMv9+):
- MTE: Activé sur certains appareils (Pixel 8+)
- PAC: Supporté depuis ARMv8.3
- BTI: Supporté depuis ARMv8.5

Protection multicouche:
1. BTI: Contrôle les cibles de branches
2. PAC: Authentifie les adresses de retour
3. MTE: Détecte corruption mémoire
4. PXN/PAN: Isole kernel et userspace
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - ARM Security Features Analyzer
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Optional
import hashlib
import struct


class ARMSecurityFeature(Enum):
    PXN = auto()
    PAN = auto()
    MTE = auto()
    BTI = auto()
    PAC = auto()
    PACGA = auto()


class PACKey(Enum):
    IA = "APIAKey"
    IB = "APIBKey"
    DA = "APDAKey"
    DB = "APDBKey"
    GA = "APGAKey"


class MTEMode(Enum):
    DISABLED = 0
    SYNC = 1
    ASYNC = 2
    ASYMM = 3


@dataclass
class PACContext:
    keys: dict = field(default_factory=dict)
    modifier: int = 0
    pac_mask: int = 0x007F000000000000
    pac_bits: int = 7


@dataclass
class MTEContext:
    mode: MTEMode = MTEMode.DISABLED
    tag_granule: int = 16
    memory_tags: dict = field(default_factory=dict)


@dataclass
class BTIContext:
    enabled: bool = False
    landing_pads: set = field(default_factory=set)


# Constants
VA_MASK_48 = 0x0000FFFFFFFFFFFF  # 48-bit VA
VA_MASK_52 = 0x000FFFFFFFFFFFFF  # 52-bit VA
PAC_ERROR_CODE = 0x0020000000000000  # Error indicator


def _simple_pac_hash(pointer: int, modifier: int, key: int) -> int:
    """Simplified PAC hash for simulation (real PAC uses QARMA)."""
    # Combine inputs
    data = struct.pack(">QQQ", pointer & VA_MASK_48, modifier, key)
    h = hashlib.sha256(data).digest()
    # Use first 8 bytes as PAC basis
    pac_value = struct.unpack(">Q", h[:8])[0]
    return pac_value


def analyze_arm_security_features(binary_info: dict) -> dict:
    """Analyse les fonctionnalités de sécurité ARM d'un binaire."""

    features = []
    details = {}

    elf_flags = binary_info.get("elf_flags", 0)
    gnu_properties = binary_info.get("gnu_properties", [])
    note_sections = binary_info.get("note_sections", [])

    # Check PAC from ELF flags or GNU properties
    # GNU_PROPERTY_AARCH64_FEATURE_1_PAC = 0x2
    pac_enabled = False
    if "GNU_PROPERTY_AARCH64_FEATURE_1_PAC" in gnu_properties:
        pac_enabled = True
        features.append("PAC")
    elif elf_flags & 0x1:  # Some compilers use this flag
        pac_enabled = True
        features.append("PAC")

    details["pac"] = {
        "enabled": pac_enabled,
        "keys_used": binary_info.get("pac_keys", ["IA", "DA"])
    }

    # Check BTI
    # GNU_PROPERTY_AARCH64_FEATURE_1_BTI = 0x1
    bti_enabled = False
    if "GNU_PROPERTY_AARCH64_FEATURE_1_BTI" in gnu_properties:
        bti_enabled = True
        features.append("BTI")

    details["bti"] = {
        "enabled": bti_enabled,
        "landing_pads_count": binary_info.get("bti_count", 0)
    }

    # Check MTE compatibility
    # MTE requires specific memory attributes and kernel support
    mte_compatible = binary_info.get("mte_compatible", False)
    if mte_compatible:
        features.append("MTE")

    details["mte"] = {
        "compatible": mte_compatible,
        "mode": binary_info.get("mte_mode", "unknown")
    }

    # PXN/PAN are kernel features, check if binary expects them
    if binary_info.get("expects_pxn", False):
        features.append("PXN")
    if binary_info.get("expects_pan", False):
        features.append("PAN")

    # Calculate protection level
    protection_score = 0
    if pac_enabled:
        protection_score += 30
    if bti_enabled:
        protection_score += 20
    if mte_compatible:
        protection_score += 25
    if "PXN" in features:
        protection_score += 15
    if "PAN" in features:
        protection_score += 10

    if protection_score >= 80:
        protection_level = "high"
    elif protection_score >= 50:
        protection_level = "medium"
    elif protection_score > 0:
        protection_level = "low"
    else:
        protection_level = "none"

    return {
        "features": features,
        "feature_count": len(features),
        "pac_enabled": pac_enabled,
        "bti_enabled": bti_enabled,
        "mte_compatible": mte_compatible,
        "protection_level": protection_level,
        "protection_score": protection_score,
        "details": details
    }


def simulate_pac_sign(
    pointer: int,
    context: int,
    key: PACKey,
    pac_context: PACContext
) -> int:
    """Simule la signature PAC d'un pointeur."""

    # Get the key value
    key_value = pac_context.keys.get(key, 0)
    if key_value == 0:
        # No key set, return original pointer
        return pointer

    # Extract virtual address (mask off any existing PAC)
    va = pointer & VA_MASK_48

    # Compute PAC
    pac_hash = _simple_pac_hash(va, context, key_value)

    # Extract PAC bits (use configured number of bits)
    pac_bits = pac_context.pac_bits
    pac_mask = (1 << pac_bits) - 1
    pac_value = pac_hash & pac_mask

    # Insert PAC into upper bits
    pac_shift = 48  # Start of PAC region for 48-bit VA
    signed_pointer = va | (pac_value << pac_shift)

    return signed_pointer


def simulate_pac_auth(
    signed_pointer: int,
    context: int,
    key: PACKey,
    pac_context: PACContext
) -> dict:
    """Simule l'authentification PAC d'un pointeur."""

    # Get the key value
    key_value = pac_context.keys.get(key, 0)

    # Extract components
    va = signed_pointer & VA_MASK_48
    pac_shift = 48
    pac_bits = pac_context.pac_bits
    pac_mask = (1 << pac_bits) - 1

    actual_pac = (signed_pointer >> pac_shift) & pac_mask

    # Compute expected PAC
    expected_hash = _simple_pac_hash(va, context, key_value)
    expected_pac = expected_hash & pac_mask

    # Verify
    valid = (actual_pac == expected_pac)

    result = {
        "valid": valid,
        "original_pointer": va,
        "expected_pac": expected_pac,
        "actual_pac": actual_pac,
        "context_used": context,
        "key_used": key.value
    }

    if not valid:
        # In real PAC, invalid auth corrupts pointer with error code
        result["corrupted_pointer"] = va | PAC_ERROR_CODE

    return result


def simulate_mte_operations(
    operations: list,
    mte_context: MTEContext
) -> dict:
    """Simule des opérations mémoire avec MTE."""

    results = []
    violations = []
    tags_assigned = {}

    if mte_context.mode == MTEMode.DISABLED:
        # MTE disabled, all operations succeed
        for i, op in enumerate(operations):
            results.append({
                "index": i,
                "operation": op,
                "status": "success",
                "mte_check": "disabled"
            })
        return {
            "results": results,
            "violations": [],
            "violation_count": 0,
            "tags_assigned": {},
            "mte_mode": "disabled"
        }

    for i, op in enumerate(operations):
        op_type = op.get("type")
        addr = op.get("addr", 0)
        ptr_tag = op.get("ptr_tag", 0)  # Tag in pointer (bits 59:56)

        # Align address to granule
        granule_addr = (addr // mte_context.tag_granule) * mte_context.tag_granule

        # Get or assign memory tag
        if granule_addr not in mte_context.memory_tags:
            # Assign tag on first access (normally done by allocator)
            if op_type == "store" and "assign_tag" in op:
                mte_context.memory_tags[granule_addr] = op["assign_tag"]
                tags_assigned[granule_addr] = op["assign_tag"]
            else:
                # Default tag
                mte_context.memory_tags[granule_addr] = 0

        mem_tag = mte_context.memory_tags[granule_addr]

        # Check tag match
        tag_match = (ptr_tag == mem_tag)

        result = {
            "index": i,
            "operation": op_type,
            "address": hex(addr),
            "ptr_tag": ptr_tag,
            "mem_tag": mem_tag,
            "tag_match": tag_match
        }

        if not tag_match:
            violation = {
                "index": i,
                "type": "tag_mismatch",
                "address": hex(addr),
                "ptr_tag": ptr_tag,
                "mem_tag": mem_tag,
                "operation": op_type
            }
            violations.append(violation)

            if mte_context.mode == MTEMode.SYNC:
                result["status"] = "fault"
                result["fault_type"] = "synchronous_tag_check_fault"
            elif mte_context.mode == MTEMode.ASYNC:
                result["status"] = "deferred_fault"
                result["fault_type"] = "asynchronous_tag_check_fault"
            else:  # ASYMM
                if op_type == "load":
                    result["status"] = "fault"
                else:
                    result["status"] = "deferred_fault"
        else:
            result["status"] = "success"

        results.append(result)

    return {
        "results": results,
        "violations": violations,
        "violation_count": len(violations),
        "tags_assigned": tags_assigned,
        "mte_mode": mte_context.mode.name
    }


def check_bti_compliance(
    instructions: list,
    entry_points: list
) -> dict:
    """Vérifie la conformité BTI d'un bloc de code ARM64."""

    landing_pads = {}
    indirect_branches = []
    missing_bti = []

    # Parse instructions and find BTI landing pads
    for i, instr in enumerate(instructions):
        instr_lower = instr.lower().strip()

        # Check for BTI instructions
        if instr_lower.startswith("bti"):
            parts = instr_lower.split()
            if len(parts) > 1:
                bti_type = parts[1]  # c, j, or jc
            else:
                bti_type = "jc"  # default
            landing_pads[i] = bti_type

        # Check for indirect branches
        if any(instr_lower.startswith(br) for br in ["br x", "blr x", "br\t", "blr\t"]):
            branch_type = "BR" if instr_lower.startswith("br") else "BLR"
            indirect_branches.append({
                "index": i,
                "instruction": instr,
                "type": branch_type
            })

    # Check entry points have landing pads
    for ep in entry_points:
        if ep not in landing_pads:
            missing_bti.append({
                "entry_point": ep,
                "instruction": instructions[ep] if ep < len(instructions) else "unknown"
            })

    # Determine compliance
    compliant = len(missing_bti) == 0

    return {
        "compliant": compliant,
        "missing_bti": missing_bti,
        "missing_count": len(missing_bti),
        "indirect_branches": indirect_branches,
        "branch_count": len(indirect_branches),
        "landing_pads": landing_pads,
        "landing_pad_count": len(landing_pads)
    }


def analyze_pac_bypass_scenarios(
    binary_info: dict,
    available_primitives: list
) -> dict:
    """Analyse les scénarios de bypass PAC possibles."""

    strategies = []
    pac_bits = binary_info.get("pac_bits", 7)
    has_pac = binary_info.get("pac_enabled", False)

    if not has_pac:
        return {
            "bypass_possible": True,
            "reason": "PAC not enabled",
            "strategies": [{"name": "none_needed", "description": "No PAC to bypass"}],
            "difficulty": "trivial"
        }

    # Analyze available primitives
    primitives = set(available_primitives)

    # Strategy 1: PAC Oracle (timing/crash)
    if "crash_oracle" in primitives or "timing_oracle" in primitives:
        attempts = 2 ** pac_bits
        strategies.append({
            "name": "pac_oracle",
            "description": f"Bruteforce PAC via oracle ({attempts} attempts max)",
            "requirements": ["crash_oracle or timing_oracle"],
            "success_rate": 0.99,
            "difficulty": "medium",
            "attempts_needed": attempts // 2  # Average
        })

    # Strategy 2: Signing Gadget
    if "signing_gadget" in primitives:
        strategies.append({
            "name": "signing_gadget",
            "description": "Use existing gadget to sign arbitrary pointers",
            "requirements": ["signing_gadget", "control_of_input_register"],
            "success_rate": 0.95,
            "difficulty": "easy"
        })

    # Strategy 3: Context Manipulation
    if "stack_pivot" in primitives or "sp_control" in primitives:
        strategies.append({
            "name": "context_manipulation",
            "description": "Control the SP/modifier used during PAC auth",
            "requirements": ["sp_control"],
            "success_rate": 0.8,
            "difficulty": "medium"
        })

    # Strategy 4: Substitution
    if "arbitrary_read" in primitives and "arbitrary_write" in primitives:
        strategies.append({
            "name": "substitution",
            "description": "Substitute one PAC-signed pointer for another with same modifier",
            "requirements": ["arbitrary_read", "arbitrary_write"],
            "success_rate": 0.7,
            "difficulty": "hard"
        })

    # Strategy 5: PAC Forgery (very hard)
    if "key_leak" in primitives:
        strategies.append({
            "name": "pac_forgery",
            "description": "Forge PAC with leaked key",
            "requirements": ["key_leak"],
            "success_rate": 1.0,
            "difficulty": "very_hard"
        })

    # Determine overall bypass possibility and difficulty
    if strategies:
        bypass_possible = True
        # Sort by success rate
        strategies.sort(key=lambda s: s["success_rate"], reverse=True)
        best_difficulty = strategies[0]["difficulty"]
    else:
        bypass_possible = False
        best_difficulty = "impossible"
        strategies.append({
            "name": "none",
            "description": "No viable bypass with available primitives",
            "requirements": ["Need: crash_oracle, signing_gadget, or key_leak"],
            "success_rate": 0.0,
            "difficulty": "impossible"
        })

    return {
        "bypass_possible": bypass_possible,
        "pac_bits": pac_bits,
        "strategies": strategies,
        "best_strategy": strategies[0] if strategies else None,
        "difficulty": best_difficulty,
        "primitives_available": list(primitives)
    }


def simulate_pxn_pan_checks(
    access_info: dict,
    current_el: int
) -> dict:
    """Simule les vérifications PXN et PAN."""

    access_type = access_info.get("type", "read")
    user_page = access_info.get("user_page", False)
    pxn_set = access_info.get("pxn_set", True)
    pan_enabled = access_info.get("pan_enabled", True)
    using_ldtr_sttr = access_info.get("unprivileged_access", False)

    pxn_blocks = False
    pan_blocks = False
    allowed = True
    reason = "Access allowed"

    # PXN check: blocks privileged execution of user pages
    if current_el >= 1 and user_page and access_type == "execute":
        if pxn_set:
            pxn_blocks = True
            allowed = False
            reason = "PXN blocks privileged execution of user page"

    # PAN check: blocks privileged data access to user pages
    if current_el >= 1 and user_page and access_type in ["read", "write"]:
        if pan_enabled and not using_ldtr_sttr:
            pan_blocks = True
            allowed = False
            reason = "PAN blocks privileged access to user page"

    # EL0 accessing kernel pages
    if current_el == 0 and not user_page:
        allowed = False
        reason = "User cannot access kernel page (AP bits)"

    return {
        "pxn_blocks": pxn_blocks,
        "pan_blocks": pan_blocks,
        "allowed": allowed,
        "reason": reason,
        "access_type": access_type,
        "current_el": current_el,
        "user_page": user_page,
        "checks_performed": {
            "pxn_checked": access_type == "execute" and user_page,
            "pan_checked": access_type in ["read", "write"] and user_page
        }
    }


def generate_pac_signed_rop_chain(
    gadgets: list,
    pac_context: PACContext,
    target: int
) -> dict:
    """Génère une chaîne ROP avec des adresses signées PAC."""

    chain = []
    signing_info = []

    if not pac_context.keys:
        # No PAC keys configured, return unsigned chain
        return {
            "chain": [g["address"] for g in gadgets] + [target],
            "signing_context": [],
            "success_probability": 1.0,
            "pac_enabled": False
        }

    # For ROP with PAC, typically uses RETAA which authenticates with IA key
    key = PACKey.IA

    # Sign each gadget address
    # The modifier for RETAA is typically SP at the time of return
    # We simulate with sequential SP values

    base_sp = 0x7FFFFFF00000
    sp = base_sp

    for i, gadget in enumerate(gadgets):
        addr = gadget["address"]

        # Sign the return address
        signed_addr = simulate_pac_sign(addr, sp, key, pac_context)

        chain.append(signed_addr)
        signing_info.append({
            "original": hex(addr),
            "signed": hex(signed_addr),
            "modifier_sp": hex(sp),
            "stack_position": i
        })

        # SP changes after each return (gadget pops values)
        pop_count = gadget.get("pops", 1)
        sp += 8 * pop_count

    # Sign the target
    signed_target = simulate_pac_sign(target, sp, key, pac_context)
    chain.append(signed_target)
    signing_info.append({
        "original": hex(target),
        "signed": hex(signed_target),
        "modifier_sp": hex(sp),
        "stack_position": len(gadgets)
    })

    # Success probability depends on matching SP values
    # If SP is predictable, high success; otherwise depends on spray
    success_probability = 0.8  # Assuming some SP uncertainty

    return {
        "chain": chain,
        "chain_length": len(chain),
        "signing_context": signing_info,
        "success_probability": success_probability,
        "pac_enabled": True,
        "key_used": key.value,
        "base_sp": hex(base_sp)
    }


def main():
    """Démonstration de l'analyse de sécurité ARM."""

    print("ARM Security Features Analysis")
    print("=" * 60)

    # Analyze binary with PAC and BTI
    binary_info = {
        "elf_flags": 0x1,
        "gnu_properties": [
            "GNU_PROPERTY_AARCH64_FEATURE_1_PAC",
            "GNU_PROPERTY_AARCH64_FEATURE_1_BTI"
        ],
        "pac_bits": 7,
        "pac_enabled": True,
        "mte_compatible": False,
        "bti_count": 150
    }

    result = analyze_arm_security_features(binary_info)
    print(f"\nFeatures detected: {result['features']}")
    print(f"Protection level: {result['protection_level']}")
    print(f"Protection score: {result['protection_score']}/100")

    # Simulate PAC operations
    print("\n" + "=" * 60)
    print("PAC Simulation")

    pac_ctx = PACContext(
        keys={PACKey.IA: 0x123456789ABCDEF0},
        pac_bits=7
    )

    pointer = 0x0000000000401000
    sp_modifier = 0x7FFFFFF00100

    signed = simulate_pac_sign(pointer, sp_modifier, PACKey.IA, pac_ctx)
    print(f"Original:  0x{pointer:016x}")
    print(f"Signed:    0x{signed:016x}")

    auth_result = simulate_pac_auth(signed, sp_modifier, PACKey.IA, pac_ctx)
    print(f"Auth valid: {auth_result['valid']}")

    # Test with wrong modifier
    wrong_auth = simulate_pac_auth(signed, 0xDEADBEEF, PACKey.IA, pac_ctx)
    print(f"Wrong modifier auth: {wrong_auth['valid']}")

    # MTE Simulation
    print("\n" + "=" * 60)
    print("MTE Simulation")

    mte_ctx = MTEContext(mode=MTEMode.SYNC)
    mte_ctx.memory_tags[0x1000] = 5  # Tag 5 for this granule

    ops = [
        {"type": "load", "addr": 0x1000, "ptr_tag": 5},   # Match
        {"type": "store", "addr": 0x1000, "ptr_tag": 3},  # Mismatch!
    ]

    mte_result = simulate_mte_operations(ops, mte_ctx)
    print(f"Operations: {len(ops)}")
    print(f"Violations: {mte_result['violation_count']}")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.2-b",
  "title": "ARM Security Features",
  "module": "3.4",
  "tier": 2,
  "difficulty": 8,
  "xp_value": 700,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 60,
  "memory_limit_mb": 256,

  "test_cases": [
    {
      "id": "detect_pac_bti",
      "description": "Detect PAC and BTI from GNU properties",
      "input": {
        "function": "analyze_arm_security_features",
        "args": {
          "binary_info": {
            "elf_flags": 0,
            "gnu_properties": ["GNU_PROPERTY_AARCH64_FEATURE_1_PAC", "GNU_PROPERTY_AARCH64_FEATURE_1_BTI"],
            "mte_compatible": false
          }
        }
      },
      "expected": {
        "pac_enabled": true,
        "bti_enabled": true,
        "features": ["PAC", "BTI"]
      },
      "points": 15
    },
    {
      "id": "pac_sign_verify",
      "description": "Sign pointer and verify PAC",
      "input": {
        "function": "simulate_pac_sign_and_auth",
        "args": {
          "pointer": 4198400,
          "context": 140737488355584,
          "key": "IA",
          "pac_context": {"keys": {"IA": 1311768467463790320}, "pac_bits": 7}
        }
      },
      "expected": {
        "signed_differs": true,
        "auth_valid": true
      },
      "points": 20
    },
    {
      "id": "pac_auth_failure",
      "description": "Detect invalid PAC authentication",
      "input": {
        "function": "simulate_pac_auth",
        "args": {
          "signed_pointer": 35465847065542656,
          "context": 12345,
          "key": "IA",
          "pac_context": {"keys": {"IA": 1311768467463790320}, "pac_bits": 7}
        }
      },
      "expected": {
        "valid": false
      },
      "points": 15
    },
    {
      "id": "mte_tag_mismatch",
      "description": "Detect MTE tag violation",
      "input": {
        "function": "simulate_mte_operations",
        "args": {
          "operations": [
            {"type": "load", "addr": 4096, "ptr_tag": 5}
          ],
          "mte_context": {"mode": "SYNC", "tag_granule": 16, "memory_tags": {"4096": 3}}
        }
      },
      "expected": {
        "violation_count": 1,
        "violations": [{"type": "tag_mismatch"}]
      },
      "points": 15
    },
    {
      "id": "bti_compliance_check",
      "description": "Check BTI landing pad compliance",
      "input": {
        "function": "check_bti_compliance",
        "args": {
          "instructions": ["bti c", "stp x29, x30, [sp, #-16]!", "mov x0, x1", "ret"],
          "entry_points": [0]
        }
      },
      "expected": {
        "compliant": true,
        "missing_count": 0
      },
      "points": 15
    },
    {
      "id": "bti_missing_landing",
      "description": "Detect missing BTI landing pad",
      "input": {
        "function": "check_bti_compliance",
        "args": {
          "instructions": ["stp x29, x30, [sp, #-16]!", "blr x0"],
          "entry_points": [0]
        }
      },
      "expected": {
        "compliant": false,
        "missing_count": 1
      },
      "points": 10
    },
    {
      "id": "pac_bypass_analysis",
      "description": "Analyze PAC bypass with oracle primitive",
      "input": {
        "function": "analyze_pac_bypass_scenarios",
        "args": {
          "binary_info": {"pac_enabled": true, "pac_bits": 7},
          "available_primitives": ["crash_oracle", "arbitrary_read"]
        }
      },
      "expected": {
        "bypass_possible": true,
        "strategies": [{"name": "pac_oracle"}]
      },
      "points": 15
    },
    {
      "id": "pxn_pan_check",
      "description": "Verify PXN blocks privileged exec of user page",
      "input": {
        "function": "simulate_pxn_pan_checks",
        "args": {
          "access_info": {"type": "execute", "user_page": true, "pxn_set": true, "pan_enabled": true},
          "current_el": 1
        }
      },
      "expected": {
        "pxn_blocks": true,
        "allowed": false
      },
      "points": 10
    }
  ],

  "edge_cases": [
    {
      "id": "no_security_features",
      "description": "Binary with no ARM security features",
      "input": {
        "function": "analyze_arm_security_features",
        "args": {
          "binary_info": {"elf_flags": 0, "gnu_properties": [], "mte_compatible": false}
        }
      },
      "expected_behavior": "Should return empty features list with protection_level 'none'"
    },
    {
      "id": "mte_disabled",
      "description": "MTE operations with MTE disabled",
      "input": {
        "function": "simulate_mte_operations",
        "args": {
          "operations": [{"type": "load", "addr": 4096, "ptr_tag": 5}],
          "mte_context": {"mode": "DISABLED"}
        }
      },
      "expected_behavior": "All operations should succeed regardless of tags"
    }
  ],

  "validation": {
    "required_functions": [
      "analyze_arm_security_features",
      "simulate_pac_sign",
      "simulate_pac_auth",
      "simulate_mte_operations",
      "check_bti_compliance",
      "analyze_pac_bypass_scenarios",
      "simulate_pxn_pan_checks",
      "generate_pac_signed_rop_chain"
    ],
    "required_classes": ["ARMSecurityFeature", "PACKey", "MTEMode", "PACContext", "MTEContext", "BTIContext"],
    "forbidden_imports": ["os.system", "subprocess"],
    "min_test_coverage": 80
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour arm_security.py
"""

import unittest


class TestARMFeatureDetectionMutations(unittest.TestCase):
    """Tests de mutation pour la détection des features ARM."""

    def setUp(self):
        from arm_security import analyze_arm_security_features

        self.analyze = analyze_arm_security_features

    # Mutant 1: PAC not detected from GNU properties
    def test_mutant_pac_detection(self):
        """MUTANT: Not detecting PAC from GNU_PROPERTY."""
        binary_info = {
            "elf_flags": 0,
            "gnu_properties": ["GNU_PROPERTY_AARCH64_FEATURE_1_PAC"],
            "mte_compatible": False
        }

        result = self.analyze(binary_info)

        self.assertTrue(result["pac_enabled"])
        self.assertIn("PAC", result["features"])

    # Mutant 2: BTI confused with PAC
    def test_mutant_bti_vs_pac(self):
        """MUTANT: Confusing BTI and PAC detection."""
        pac_only = {
            "elf_flags": 0,
            "gnu_properties": ["GNU_PROPERTY_AARCH64_FEATURE_1_PAC"],
            "mte_compatible": False
        }
        bti_only = {
            "elf_flags": 0,
            "gnu_properties": ["GNU_PROPERTY_AARCH64_FEATURE_1_BTI"],
            "mte_compatible": False
        }

        pac_result = self.analyze(pac_only)
        bti_result = self.analyze(bti_only)

        self.assertTrue(pac_result["pac_enabled"])
        self.assertFalse(pac_result["bti_enabled"])
        self.assertTrue(bti_result["bti_enabled"])
        self.assertFalse(bti_result["pac_enabled"])


class TestPACMutations(unittest.TestCase):
    """Tests de mutation pour PAC."""

    def setUp(self):
        from arm_security import (
            simulate_pac_sign, simulate_pac_auth,
            PACContext, PACKey
        )
        self.sign = simulate_pac_sign
        self.auth = simulate_pac_auth
        self.PACContext = PACContext
        self.PACKey = PACKey

    # Mutant 3: PAC not actually modifying pointer
    def test_mutant_pac_modifies_pointer(self):
        """MUTANT: PAC sign not changing the pointer."""
        ctx = self.PACContext(
            keys={self.PACKey.IA: 0x123456789ABCDEF0},
            pac_bits=7
        )

        pointer = 0x401000
        signed = self.sign(pointer, 0x100, self.PACKey.IA, ctx)

        self.assertNotEqual(signed, pointer,
                           "Signed pointer must differ from original")

    # Mutant 4: Auth always returns valid
    def test_mutant_auth_validates_correctly(self):
        """MUTANT: Auth always returning valid=True."""
        ctx = self.PACContext(
            keys={self.PACKey.IA: 0x123456789ABCDEF0},
            pac_bits=7
        )

        pointer = 0x401000
        context = 0x100

        # Sign correctly
        signed = self.sign(pointer, context, self.PACKey.IA, ctx)
        valid_auth = self.auth(signed, context, self.PACKey.IA, ctx)

        # Try wrong context
        invalid_auth = self.auth(signed, 0xDEAD, self.PACKey.IA, ctx)

        self.assertTrue(valid_auth["valid"])
        self.assertFalse(invalid_auth["valid"])

    # Mutant 5: Wrong key usage
    def test_mutant_key_distinction(self):
        """MUTANT: Not distinguishing between PAC keys."""
        ctx = self.PACContext(
            keys={
                self.PACKey.IA: 0x1111111111111111,
                self.PACKey.DA: 0x2222222222222222
            },
            pac_bits=7
        )

        pointer = 0x401000
        context = 0

        signed_ia = self.sign(pointer, context, self.PACKey.IA, ctx)
        signed_da = self.sign(pointer, context, self.PACKey.DA, ctx)

        # Different keys should produce different signatures
        self.assertNotEqual(signed_ia, signed_da,
                           "Different keys must produce different PACs")


class TestMTEMutations(unittest.TestCase):
    """Tests de mutation pour MTE."""

    def setUp(self):
        from arm_security import (
            simulate_mte_operations, MTEContext, MTEMode
        )
        self.simulate = simulate_mte_operations
        self.MTEContext = MTEContext
        self.MTEMode = MTEMode

    # Mutant 6: Tag mismatch not detected
    def test_mutant_tag_mismatch_detection(self):
        """MUTANT: Not detecting tag mismatches."""
        ctx = self.MTEContext(mode=self.MTEMode.SYNC)
        ctx.memory_tags[0x1000] = 5

        ops = [{"type": "load", "addr": 0x1000, "ptr_tag": 3}]  # Tag mismatch!

        result = self.simulate(ops, ctx)

        self.assertGreater(result["violation_count"], 0,
                          "Should detect tag mismatch")

    # Mutant 7: MTE disabled mode still checking
    def test_mutant_mte_disabled_mode(self):
        """MUTANT: MTE disabled but still checking tags."""
        ctx = self.MTEContext(mode=self.MTEMode.DISABLED)
        ctx.memory_tags[0x1000] = 5

        ops = [{"type": "load", "addr": 0x1000, "ptr_tag": 3}]  # Would be mismatch

        result = self.simulate(ops, ctx)

        self.assertEqual(result["violation_count"], 0,
                        "MTE disabled should not report violations")


class TestBTIMutations(unittest.TestCase):
    """Tests de mutation pour BTI."""

    def setUp(self):
        from arm_security import check_bti_compliance
        self.check = check_bti_compliance

    # Mutant 8: BTI not recognized
    def test_mutant_bti_recognition(self):
        """MUTANT: Not recognizing BTI instructions."""
        instrs = ["bti c", "mov x0, x1", "ret"]
        result = self.check(instrs, [0])

        self.assertIn(0, result["landing_pads"])
        self.assertTrue(result["compliant"])

    # Mutant 9: Missing BTI not reported
    def test_mutant_missing_bti_report(self):
        """MUTANT: Not reporting missing BTI at entry points."""
        instrs = ["mov x0, x1", "ret"]  # No BTI at start
        result = self.check(instrs, [0])

        self.assertFalse(result["compliant"])
        self.assertGreater(result["missing_count"], 0)


class TestPXNPANMutations(unittest.TestCase):
    """Tests de mutation pour PXN/PAN."""

    def setUp(self):
        from arm_security import simulate_pxn_pan_checks
        self.check = simulate_pxn_pan_checks

    # Mutant 10: PXN check inverted
    def test_mutant_pxn_check(self):
        """MUTANT: PXN allowing instead of blocking."""
        access = {
            "type": "execute",
            "user_page": True,
            "pxn_set": True,
            "pan_enabled": False
        }

        result = self.check(access, current_el=1)

        self.assertTrue(result["pxn_blocks"])
        self.assertFalse(result["allowed"])


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Que fait l'instruction BTI c sur ARM64 ?**

- [ ] A) Termine une branche
- [x] B) Marque une cible valide pour les appels indirects (BLR)
- [ ] C) Active le mode BTI
- [ ] D) Vérifie l'intégrité d'une branche

**Explication**: BTI c (Branch Target Identification - Call) marque le début d'une cible valide pour les instructions BLR (Branch with Link to Register). Sans cette instruction, un BLR vers cette adresse déclencherait une exception.

---

### Question 2
**Combien de bits sont utilisés pour les tags MTE ?**

- [x] A) 4 bits
- [ ] B) 8 bits
- [ ] C) 16 bits
- [ ] D) 32 bits

**Explication**: MTE utilise 4 bits pour les tags, permettant 16 valeurs possibles (0-15). Ces bits sont stockés dans les bits supérieurs du pointeur (59:56) et associés à chaque granule de 16 bytes en mémoire.

---

### Question 3
**Quel est le rôle du modifier dans la signature PAC ?**

- [ ] A) Chiffrer le pointeur
- [x] B) Ajouter du contexte pour différencier les signatures du même pointeur
- [ ] C) Compresser l'adresse
- [ ] D) Vérifier l'alignement

**Explication**: Le modifier (souvent SP ou un autre registre) ajoute du contexte à la signature. Le même pointeur signé avec différents modifiers produit différents PACs, empêchant la réutilisation de signatures dans des contextes différents.

---

### Question 4
**Que se passe-t-il si un pointeur signé avec PAC est authentifié avec le mauvais modifier ?**

- [ ] A) Le pointeur est retourné normalement
- [ ] B) Une exception est immédiatement levée
- [x] C) Le pointeur est corrompu avec un pattern d'erreur
- [ ] D) Le modifier est ignoré

**Explication**: En cas d'échec d'authentification PAC, le pointeur n'est pas immédiatement rejeté mais corrompu (certains bits sont inversés). L'utilisation de ce pointeur corrompu déclenchera ensuite une fault (généralement lors du déréférencement).

---

### Question 5
**Quelle est la différence entre PXN et PAN ?**

- [ ] A) PXN protège le userspace, PAN protège le kernel
- [x] B) PXN bloque l'exécution privilégiée de pages user, PAN bloque l'accès données
- [ ] C) Les deux font la même chose
- [ ] D) PXN est software, PAN est hardware

**Explication**: PXN (Privileged Execute Never) empêche le kernel d'exécuter du code dans les pages user. PAN (Privileged Access Never) empêche le kernel de lire/écrire les pages user (sauf via LDTR/STTR).

---

### Question 6
**Dans MTE mode ASYNC, que se passe-t-il lors d'un tag mismatch ?**

- [ ] A) Fault immédiat
- [ ] B) L'opération est annulée
- [x] C) Le fault est signalé de manière différée (meilleure performance)
- [ ] D) Le tag est automatiquement corrigé

**Explication**: En mode asynchrone (ASYNC), MTE ne bloque pas immédiatement sur un mismatch mais accumule les erreurs pour les signaler plus tard. Cela offre de meilleures performances au prix d'une détection moins précise de l'instruction fautive.

---

### Question 7
**Quelle technique de bypass PAC exploite un gadget qui signe des pointeurs arbitraires ?**

- [ ] A) PAC Oracle
- [x] B) Signing Gadget
- [ ] C) Context Manipulation
- [ ] D) Key Leak

**Explication**: Un "signing gadget" est une séquence de code existante qui prend un pointeur en entrée, le signe avec PAC, et le rend accessible. Si un attaquant peut contrôler l'entrée de ce gadget, il peut signer n'importe quel pointeur.

---

### Question 8
**Pourquoi les instructions LDTR/STTR sont-elles spéciales par rapport à PAN ?**

- [ ] A) Elles désactivent PAN globalement
- [ ] B) Elles sont plus rapides
- [x] C) Elles sont autorisées à accéder aux pages user même avec PAN activé
- [ ] D) Elles ne fonctionnent qu'en EL0

**Explication**: LDTR/STTR (Load/Store with Translation at EL0) sont des instructions qui effectuent l'accès comme si on était en EL0. Le kernel les utilise intentionnellement pour accéder aux données userspace, et PAN les autorise explicitement.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Confondre PAC bits et VA bits**: Le PAC est dans les bits supérieurs, pas la VA.

2. **Oublier le modifier PAC**: Sans le bon modifier, l'auth échouera.

3. **Granule MTE**: 16 bytes, pas 1 byte. Les tags sont par granule.

4. **BTI types**: BTI c pour calls (BLR), BTI j pour jumps (BR).

5. **PAC keys**: Utiliser la bonne clé (IA vs DA vs GA).

### Bonnes Pratiques

```python
# Toujours vérifier le mode MTE avant de supposer la protection
if mte_context.mode != MTEMode.DISABLED:
    # MTE checks are active
    verify_tags(ptr_tag, mem_tag)

# PAC: Sauvegarder le modifier utilisé pour la signature
signed = pac_sign(ptr, sp, key)  # sp est le modifier
# Plus tard, utiliser le même modifier pour auth
auth_result = pac_auth(signed, sp, key)

# BTI: Toujours vérifier le type de branche
if branch_type == "BLR":
    required_bti = ["c", "jc"]
elif branch_type == "BR":
    required_bti = ["j", "jc"]
```

---

## Section 8 : Ressources et Références

### Documentation ARM
- ARM Architecture Reference Manual (ARMv8/v9)
- ARM MTE Documentation: developer.arm.com/documentation
- ARM BTI Specification: developer.arm.com/bti

### Papers Académiques
- "PAC it up: Towards Pointer Integrity using ARM Pointer Authentication"
- "PARTS: Pointer Authentication for ARM Trustzone Security"

### Outils
- QEMU avec support PAC/MTE: qemu.org
- Android MTE Guide: source.android.com/docs/security/memory-safety

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| analyze_arm_security_features | 15 |
| simulate_pac_sign/auth | 25 |
| simulate_mte_operations | 20 |
| check_bti_compliance | 15 |
| analyze_pac_bypass_scenarios | 15 |
| simulate_pxn_pan_checks | 10 |
| **Total** | **100** |

### Seuils
- **A** (90-100): Expert en sécurité ARM moderne
- **B** (75-89): Bonne compréhension des mécanismes
- **C** (60-74): Concepts de base maîtrisés
- **D** (45-59): Révision nécessaire
- **F** (<45): Revoir le cours intégré
