# Exercice 3.4.1-a : register_decoder

**Module :**
3.4.1 â€” x86-64 Assembly Fundamentals

**Concept :**
a â€” Registres gÃ©nÃ©raux et conventions d'appel

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Python 3.12

**PrÃ©requis :**
- Bases de programmation Python
- ComprÃ©hension des systÃ¨mes de numÃ©ration (hexadÃ©cimal)
- Notions de base sur l'architecture x86-64

**Domaines :**
CPU, ASM, Encodage

**DurÃ©e estimÃ©e :**
45 min

**XP Base :**
150

**ComplexitÃ© :**
T3 O(n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`register_decoder.py`

**Fonctions autorisÃ©es :**
- `json` (module standard)
- `re` (expressions rÃ©guliÃ¨res)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- BibliothÃ¨ques d'Ã©mulation (unicorn, capstone)
- Modules externes non standards

### 1.2 Consigne

#### 2.4.1 ğŸ® Contexte Culturel â€” "The Matrix Reloaded"

*"To understand the Matrix, you must first understand the registers."*

Dans **The Matrix Reloaded**, Neo dÃ©couvre qu'il peut percevoir le code source de la Matrice elle-mÃªme. Les registres du processeur sont comme ces colonnes de caractÃ¨res verts qui dÃ©filent : ils contiennent l'Ã©tat exact de la machine Ã  un instant T.

Imagine que tu es **l'OpÃ©rateur du Nebuchadnezzar**. Tank ou Dozer reÃ§oivent des dumps de registres depuis les machines de la Matrice et doivent les dÃ©coder pour comprendre ce que fait un programme. Chaque registre raconte une histoire : RAX contient peut-Ãªtre le rÃ©sultat d'une fonction, RDI le premier argument, RSP pointe vers la pile...

Comme Neo qui apprend Ã  "voir" la Matrice, tu vas apprendre Ã  "voir" l'Ã©tat d'un processeur x86-64 Ã  travers ses registres.

#### 2.4.2 Ã‰noncÃ© AcadÃ©mique

En architecture x86-64, les registres gÃ©nÃ©raux sont les unitÃ©s de stockage les plus rapides du processeur. La convention d'appel **System V AMD64 ABI** (utilisÃ©e sur Linux, macOS, BSD) dÃ©finit comment les arguments sont passÃ©s aux fonctions et comment les valeurs sont retournÃ©es.

**Ta mission :**

Ã‰crire un programme `register_decoder.py` qui :

1. **Parse** un dump de registres au format texte (clÃ©=valeur hexadÃ©cimale)
2. **Identifie** les arguments de fonction selon la convention System V AMD64
3. **DÃ©termine** la valeur de retour potentielle
4. **Calcule** la profondeur de pile (diffÃ©rence RSP/RBP)
5. **DÃ©tecte** la convention d'appel (SysV ou Windows x64)

**EntrÃ©e :**
- Fichier JSON contenant :
  - `registers` : dictionnaire des registres avec valeurs hexadÃ©cimales
  - `convention` : "sysv" ou "windows"

**Sortie :**
- JSON avec l'analyse complÃ¨te sur stdout

**Contraintes :**
- Les valeurs de registres sont en hexadÃ©cimal (avec ou sans prÃ©fixe 0x)
- Le programme doit gÃ©rer les registres manquants gracieusement
- Les arguments sont identifiÃ©s selon la convention spÃ©cifiÃ©e
- La sortie doit Ãªtre du JSON valide

**Registres System V AMD64 ABI :**
| Registre | RÃ´le |
|----------|------|
| RAX | Valeur de retour |
| RDI | 1er argument |
| RSI | 2Ã¨me argument |
| RDX | 3Ã¨me argument |
| RCX | 4Ã¨me argument |
| R8 | 5Ã¨me argument |
| R9 | 6Ã¨me argument |
| RSP | Stack Pointer |
| RBP | Base Pointer |

**Registres Windows x64 ABI :**
| Registre | RÃ´le |
|----------|------|
| RAX | Valeur de retour |
| RCX | 1er argument |
| RDX | 2Ã¨me argument |
| R8 | 3Ã¨me argument |
| R9 | 4Ã¨me argument |
| RSP | Stack Pointer |
| RBP | Base Pointer |

**Exemples :**

| EntrÃ©e | Sortie |
|--------|--------|
| `{"registers": {"RAX": "0x1337", "RDI": "0x7fff0000", "RSI": "0x10", "RSP": "0x7fffffffe000", "RBP": "0x7fffffffe040"}, "convention": "sysv"}` | `{"return_value": 4919, "arguments": [140733193388032, 16], "stack_depth": 64, "convention": "sysv"}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
register_decoder.py - Analyse de dumps de registres x86-64
"""

import json
import sys

def parse_hex(value: str) -> int:
    """Convertit une valeur hexadÃ©cimale en entier."""
    pass

def decode_registers(data: dict) -> dict:
    """
    Analyse un dump de registres et retourne l'interprÃ©tation.

    Args:
        data: Dictionnaire contenant 'registers' et 'convention'

    Returns:
        Dictionnaire avec return_value, arguments, stack_depth, convention
    """
    pass

def main():
    """Point d'entrÃ©e principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### L'Ã©volution des registres x86

Les registres x86 ont une histoire fascinante. Ã€ l'origine, le processeur 8086 d'Intel (1978) avait des registres 16 bits : AX, BX, CX, DX. Avec le 80386, ils sont passÃ©s Ã  32 bits (EAX, EBX...). Enfin, AMD a Ã©tendu l'architecture Ã  64 bits avec l'AMD64 en 2003, crÃ©ant RAX, RBX... et ajoutant R8-R15.

Le "A" de RAX signifie "Accumulator" â€” historiquement, c'Ã©tait le registre principal pour les opÃ©rations arithmÃ©tiques. Le "X" vient de "eXtended".

### Pourquoi deux conventions d'appel diffÃ©rentes ?

Microsoft et les systÃ¨mes Unix ont fait des choix diffÃ©rents lors de la transition vers le 64 bits :
- **System V** (Unix) : 6 arguments dans les registres, plus efficace pour les fonctions avec peu d'arguments
- **Windows** : 4 arguments dans les registres + "shadow space" obligatoire, simplifie le debugging

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

**MÃ©tier : Reverse Engineer / Analyste Malware**

Les analystes malware utilisent quotidiennement la lecture de registres pour :
- **Analyser des crashs** : Comprendre l'Ã©tat du programme au moment du crash
- **DÃ©bugger des exploits** : Voir comment un overflow a corrompu les registres
- **Tracer l'exÃ©cution** : Suivre les arguments passÃ©s aux fonctions systÃ¨me

**Cas d'usage concret :**
Chez CrowdStrike ou Mandiant, quand un malware est dÃ©tectÃ©, les analystes capturent l'Ã©tat des registres pour comprendre :
- Quels arguments ont Ã©tÃ© passÃ©s Ã  `CreateRemoteThread` ?
- Quelle adresse a Ã©tÃ© retournÃ©e par `VirtualAlloc` ?
- OÃ¹ pointe le stack pointer aprÃ¨s l'exploit ?

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
register_decoder.py  test_input.json

$ cat test_input.json
{"registers": {"RAX": "0x0", "RDI": "0x7fff5fbff8c0", "RSI": "0x64", "RDX": "0x3", "RSP": "0x7fff5fbff700", "RBP": "0x7fff5fbff750"}, "convention": "sysv"}

$ python3 register_decoder.py test_input.json
{"return_value": 0, "arguments": [140734799804608, 100, 3], "stack_depth": 80, "convention": "sysv"}

$ echo '{"registers": {"RAX": "1337", "RCX": "0x100", "RDX": "0x200"}, "convention": "windows"}' | python3 register_decoder.py -
{"return_value": 4919, "arguments": [256, 512], "stack_depth": 0, "convention": "windows"}
```

---

## âš¡ SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—2

**Time Complexity attendue :**
O(n)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
CPU, ASM, Mem

### 3.1.1 Consigne Bonus

**Extension "Full Trace" :**

Ã‰tendre le programme pour :

1. **DÃ©tecter automatiquement** la convention d'appel (heuristique basÃ©e sur les valeurs)
2. **Analyser les flags** RFLAGS (ZF, SF, CF, OF) si prÃ©sents
3. **Identifier les syscalls** Linux (si RAX contient un numÃ©ro de syscall connu)
4. **Calculer** si le stack est alignÃ© sur 16 bytes (requis par ABI)

**Contraintes supplÃ©mentaires :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RFLAGS prÃ©sent â†’ analyser bits        â”‚
â”‚  DÃ©tecter syscall si RAX < 500         â”‚
â”‚  VÃ©rifier alignement RSP % 16 == 0     â”‚
â”‚  Auto-detect si convention non fournie â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```python
def decode_registers_advanced(data: dict) -> dict:
    """
    Version avancÃ©e avec dÃ©tection automatique et analyse RFLAGS.

    Returns:
        Dictionnaire Ã©tendu avec flags_analysis, syscall_info, stack_aligned
    """
    pass
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Convention | Fournie | Auto-dÃ©tectÃ©e si absente |
| RFLAGS | IgnorÃ© | AnalysÃ© bit par bit |
| Syscalls | Non dÃ©tectÃ©s | IdentifiÃ©s par numÃ©ro |
| Alignement | Non vÃ©rifiÃ© | VÃ©rifiÃ© (16 bytes) |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| basic_sysv | `{"registers": {"RAX": "0x0", "RDI": "0x1000"}, "convention": "sysv"}` | `{"return_value": 0, "arguments": [4096], ...}` | 10 |
| basic_windows | `{"registers": {"RAX": "0xff", "RCX": "0x100"}, "convention": "windows"}` | `{"return_value": 255, "arguments": [256], ...}` | 10 |
| no_prefix | `{"registers": {"RAX": "1337"}, "convention": "sysv"}` | `{"return_value": 4919, ...}` | 5 |
| stack_depth | `{"registers": {"RSP": "0x7fff0000", "RBP": "0x7fff0080"}, "convention": "sysv"}` | `{"stack_depth": 128, ...}` | 10 |
| all_args_sysv | 6 arguments complets | Tous identifiÃ©s correctement | 15 |
| missing_registers | Registres partiels | Gestion gracieuse | 10 |
| null_values | RAX=0x0 | return_value: 0, pas null | 5 |
| large_values | Valeurs 64-bit max | Pas d'overflow | 10 |
| edge_negative | RSP > RBP | stack_depth nÃ©gatif ou 0 | 10 |
| stdin_input | Via stdin (-) | Lecture correcte | 5 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de rÃ©fÃ©rence

```python
#!/usr/bin/env python3
"""
register_decoder.py - Solution de rÃ©fÃ©rence
"""

import json
import sys

SYSV_ARG_REGS = ['RDI', 'RSI', 'RDX', 'RCX', 'R8', 'R9']
WINDOWS_ARG_REGS = ['RCX', 'RDX', 'R8', 'R9']

def parse_hex(value: str) -> int:
    """Convertit une valeur hexadÃ©cimale en entier."""
    if value is None:
        return 0
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    try:
        return int(value, 16)
    except ValueError:
        return int(value)

def decode_registers(data: dict) -> dict:
    """Analyse un dump de registres et retourne l'interprÃ©tation."""
    registers = data.get('registers', {})
    convention = data.get('convention', 'sysv').lower()

    # Normaliser les noms de registres en majuscules
    regs = {k.upper(): v for k, v in registers.items()}

    # Valeur de retour
    return_value = parse_hex(regs.get('RAX', '0'))

    # Arguments selon la convention
    if convention == 'windows':
        arg_regs = WINDOWS_ARG_REGS
    else:
        arg_regs = SYSV_ARG_REGS

    arguments = []
    for reg in arg_regs:
        if reg in regs:
            arguments.append(parse_hex(regs[reg]))

    # Profondeur de pile
    rsp = parse_hex(regs.get('RSP', '0'))
    rbp = parse_hex(regs.get('RBP', '0'))
    stack_depth = rbp - rsp if rbp >= rsp else 0

    return {
        'return_value': return_value,
        'arguments': arguments,
        'stack_depth': stack_depth,
        'convention': convention
    }

def main():
    """Point d'entrÃ©e principal."""
    if len(sys.argv) < 2:
        print("Usage: register_decoder.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = decode_registers(data)
    print(json.dumps(result))

if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptÃ©es

```python
# Alternative 1: Utilisation de regex pour parser hex
import re

def parse_hex_alt(value: str) -> int:
    match = re.match(r'(?:0x)?([0-9a-fA-F]+)', str(value))
    return int(match.group(1), 16) if match else 0
```

```python
# Alternative 2: Dictionnaire de registres avec get et default
def decode_registers_alt(data: dict) -> dict:
    regs = {k.upper(): parse_hex(v) for k, v in data.get('registers', {}).items()}
    convention = data.get('convention', 'sysv')

    arg_map = {
        'sysv': ['RDI', 'RSI', 'RDX', 'RCX', 'R8', 'R9'],
        'windows': ['RCX', 'RDX', 'R8', 'R9']
    }

    return {
        'return_value': regs.get('RAX', 0),
        'arguments': [regs[r] for r in arg_map[convention] if r in regs],
        'stack_depth': max(0, regs.get('RBP', 0) - regs.get('RSP', 0)),
        'convention': convention
    }
```

### 4.5 Solutions refusÃ©es (avec explications)

```python
# REFUSÃ‰: Ne gÃ¨re pas l'absence de prÃ©fixe 0x
def parse_hex_bad(value: str) -> int:
    return int(value, 16)  # Ã‰choue si value = "1337" sans 0x

# Pourquoi c'est faux: Les dumps peuvent avoir des formats variÃ©s
```

```python
# REFUSÃ‰: Ordre des arguments incorrect pour Windows
WINDOWS_ARG_REGS_BAD = ['RDI', 'RSI', 'RDX', 'RCX']  # C'est l'ordre SysV!

# Pourquoi c'est faux: Windows utilise RCX, RDX, R8, R9
```

```python
# REFUSÃ‰: Stack depth peut Ãªtre nÃ©gatif (crash ou situation anormale)
stack_depth = rbp - rsp  # Sans vÃ©rification, peut retourner nÃ©gatif

# Pourquoi c'est faux: Un stack depth nÃ©gatif est possible mais doit Ãªtre gÃ©rÃ©
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```python
#!/usr/bin/env python3
"""
register_decoder.py - Solution bonus avec analyse avancÃ©e
"""

import json
import sys

SYSV_ARG_REGS = ['RDI', 'RSI', 'RDX', 'RCX', 'R8', 'R9']
WINDOWS_ARG_REGS = ['RCX', 'RDX', 'R8', 'R9']

# Quelques syscalls Linux courants
LINUX_SYSCALLS = {
    0: 'read', 1: 'write', 2: 'open', 3: 'close',
    9: 'mmap', 10: 'mprotect', 11: 'munmap',
    59: 'execve', 60: 'exit', 231: 'exit_group'
}

RFLAGS_BITS = {
    0: 'CF',   # Carry Flag
    2: 'PF',   # Parity Flag
    6: 'ZF',   # Zero Flag
    7: 'SF',   # Sign Flag
    11: 'OF'   # Overflow Flag
}

def parse_hex(value: str) -> int:
    if value is None:
        return 0
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    try:
        return int(value, 16)
    except ValueError:
        return int(value)

def analyze_rflags(rflags: int) -> dict:
    """Analyse les bits de RFLAGS."""
    result = {}
    for bit, name in RFLAGS_BITS.items():
        result[name] = bool(rflags & (1 << bit))
    return result

def detect_convention(regs: dict) -> str:
    """Heuristique pour dÃ©tecter la convention d'appel."""
    # Si RDI a une valeur typique d'adresse et RCX non, probablement SysV
    rdi = regs.get('RDI', 0)
    rcx = regs.get('RCX', 0)

    # Heuristique simple: si RDI ressemble Ã  une adresse haute (stack/heap)
    if rdi > 0x7f0000000000:
        return 'sysv'
    if rcx > 0x7f0000000000:
        return 'windows'
    return 'sysv'  # DÃ©faut

def decode_registers_advanced(data: dict) -> dict:
    """Version avancÃ©e avec dÃ©tection automatique."""
    registers = data.get('registers', {})
    regs = {k.upper(): parse_hex(v) for k, v in registers.items()}

    # Auto-dÃ©tection si pas de convention fournie
    convention = data.get('convention')
    if convention is None:
        convention = detect_convention(regs)
    else:
        convention = convention.lower()

    # Arguments
    arg_regs = WINDOWS_ARG_REGS if convention == 'windows' else SYSV_ARG_REGS
    arguments = [regs[r] for r in arg_regs if r in regs]

    # Return value et syscall detection
    rax = regs.get('RAX', 0)
    syscall_info = None
    if rax in LINUX_SYSCALLS:
        syscall_info = {'number': rax, 'name': LINUX_SYSCALLS[rax]}

    # Stack analysis
    rsp = regs.get('RSP', 0)
    rbp = regs.get('RBP', 0)
    stack_depth = max(0, rbp - rsp)
    stack_aligned = (rsp % 16 == 0)

    # RFLAGS analysis
    flags_analysis = None
    if 'RFLAGS' in regs:
        flags_analysis = analyze_rflags(regs['RFLAGS'])

    return {
        'return_value': rax,
        'arguments': arguments,
        'stack_depth': stack_depth,
        'stack_aligned': stack_aligned,
        'convention': convention,
        'convention_detected': data.get('convention') is None,
        'syscall_info': syscall_info,
        'flags_analysis': flags_analysis
    }

def main():
    if len(sys.argv) < 2:
        print("Usage: register_decoder.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    # Utiliser version avancÃ©e si des features bonus sont demandÃ©es
    if 'RFLAGS' in data.get('registers', {}) or data.get('convention') is None:
        result = decode_registers_advanced(data)
    else:
        result = decode_registers(data)

    print(json.dumps(result))

if __name__ == "__main__":
    main()
```

### 4.7 Solutions alternatives bonus

```python
# Alternative: DÃ©tection de convention basÃ©e sur patterns de valeurs
def detect_convention_v2(regs: dict) -> str:
    """DÃ©tection basÃ©e sur les valeurs prÃ©sentes."""
    sysv_score = sum(1 for r in SYSV_ARG_REGS[:4] if r in regs and regs[r] != 0)
    win_score = sum(1 for r in WINDOWS_ARG_REGS if r in regs and regs[r] != 0)
    return 'windows' if win_score > sysv_score else 'sysv'
```

### 4.8 Solutions refusÃ©es bonus

```python
# REFUSÃ‰: Syscall detection trop large
def is_syscall_bad(rax):
    return rax < 1000  # Trop permissif, inclut des valeurs non-syscall

# Pourquoi: Seuls les syscalls documentÃ©s doivent Ãªtre identifiÃ©s
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "register_decoder",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isolÃ©",
  "tags": ["assembly", "x86-64", "registers", "abi", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "decode_registers",
    "prototype": "def decode_registers(data: dict) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "data", "type": "dict"}
    ]
  },

  "driver": {
    "reference": "def ref_decode_registers(data): regs = {k.upper(): (int(str(v).replace('0x',''), 16) if v else 0) for k, v in data.get('registers', {}).items()}; conv = data.get('convention', 'sysv').lower(); arg_regs = ['RCX','RDX','R8','R9'] if conv == 'windows' else ['RDI','RSI','RDX','RCX','R8','R9']; return {'return_value': regs.get('RAX', 0), 'arguments': [regs[r] for r in arg_regs if r in regs], 'stack_depth': max(0, regs.get('RBP', 0) - regs.get('RSP', 0)), 'convention': conv}",

    "edge_cases": [
      {
        "name": "null_input",
        "args": [{"registers": {}, "convention": "sysv"}],
        "expected": {"return_value": 0, "arguments": [], "stack_depth": 0, "convention": "sysv"},
        "is_trap": true,
        "trap_explanation": "Dictionnaire vide doit retourner des valeurs par dÃ©faut"
      },
      {
        "name": "basic_sysv",
        "args": [{"registers": {"RAX": "0x1337", "RDI": "0x100"}, "convention": "sysv"}],
        "expected": {"return_value": 4919, "arguments": [256], "stack_depth": 0, "convention": "sysv"}
      },
      {
        "name": "basic_windows",
        "args": [{"registers": {"RAX": "0xff", "RCX": "0x200"}, "convention": "windows"}],
        "expected": {"return_value": 255, "arguments": [512], "stack_depth": 0, "convention": "windows"}
      },
      {
        "name": "no_hex_prefix",
        "args": [{"registers": {"RAX": "ff"}, "convention": "sysv"}],
        "expected": {"return_value": 255, "arguments": [], "stack_depth": 0, "convention": "sysv"},
        "is_trap": true,
        "trap_explanation": "Les valeurs sans prÃ©fixe 0x doivent Ãªtre acceptÃ©es"
      },
      {
        "name": "stack_depth_calc",
        "args": [{"registers": {"RSP": "0x7fff0000", "RBP": "0x7fff0040"}, "convention": "sysv"}],
        "expected": {"return_value": 0, "arguments": [], "stack_depth": 64, "convention": "sysv"}
      },
      {
        "name": "all_sysv_args",
        "args": [{"registers": {"RDI": "0x1", "RSI": "0x2", "RDX": "0x3", "RCX": "0x4", "R8": "0x5", "R9": "0x6"}, "convention": "sysv"}],
        "expected": {"return_value": 0, "arguments": [1, 2, 3, 4, 5, 6], "stack_depth": 0, "convention": "sysv"}
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator_code": "lambda: {'registers': {'RAX': hex(random.randint(0, 2**64-1)), 'RDI': hex(random.randint(0, 2**64-1))}, 'convention': random.choice(['sysv', 'windows'])}"
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["json", "sys", "re"],
    "forbidden_functions": ["unicorn", "capstone", "keystone"],
    "check_security": false,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A (Boundary) : Off-by-one dans l'ordre des arguments
SYSV_ARG_REGS_MUTANT = ['RSI', 'RDI', 'RDX', 'RCX', 'R8', 'R9']  # RDI et RSI inversÃ©s!

def decode_registers_mutant_a(data):
    # Bug: RDI et RSI sont inversÃ©s
    regs = {k.upper(): parse_hex(v) for k, v in data.get('registers', {}).items()}
    arguments = [regs[r] for r in SYSV_ARG_REGS_MUTANT if r in regs]
    return {'arguments': arguments, ...}

# Pourquoi c'est faux: L'ordre des arguments SysV est RDI, RSI, RDX, RCX, R8, R9
# Ce qui Ã©tait pensÃ©: L'Ã©tudiant confond l'ordre des deux premiers arguments
```

```python
# Mutant B (Safety) : Ne gÃ¨re pas les valeurs None/absentes
def decode_registers_mutant_b(data):
    regs = data['registers']  # Crash si 'registers' absent
    rax = int(regs['RAX'], 16)  # Crash si RAX absent ou None
    return {'return_value': rax}

# Pourquoi c'est faux: Les registres peuvent Ãªtre partiellement prÃ©sents
# Ce qui Ã©tait pensÃ©: Tous les registres sont toujours fournis
```

```python
# Mutant C (Logic) : Utilise la mauvaise convention pour Windows
def decode_registers_mutant_c(data):
    convention = data.get('convention', 'sysv')
    # Bug: utilise toujours SysV mÃªme si convention == 'windows'
    arg_regs = ['RDI', 'RSI', 'RDX', 'RCX', 'R8', 'R9']
    # ...

# Pourquoi c'est faux: Windows utilise RCX, RDX, R8, R9
# Ce qui Ã©tait pensÃ©: Les deux conventions utilisent les mÃªmes registres
```

```python
# Mutant D (Return) : Retourne stack_depth nÃ©gatif sans protection
def decode_registers_mutant_d(data):
    regs = {k.upper(): parse_hex(v) for k, v in data.get('registers', {}).items()}
    rsp = regs.get('RSP', 0)
    rbp = regs.get('RBP', 0)
    stack_depth = rbp - rsp  # Peut Ãªtre nÃ©gatif!
    return {'stack_depth': stack_depth}

# Pourquoi c'est faux: Un stack depth nÃ©gatif indique une situation anormale
# Ce qui Ã©tait pensÃ©: RBP est toujours >= RSP
```

```python
# Mutant E (Parse) : Ne gÃ¨re pas les valeurs sans prÃ©fixe 0x
def parse_hex_mutant_e(value):
    return int(value, 16)  # Ã‰choue si value = "0x1337"

# Pourquoi c'est faux: int("0x1337", 16) fonctionne, mais le code est fragile
# Ce qui Ã©tait pensÃ©: Toutes les valeurs ont le mÃªme format
```

---

## ğŸ§  SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne les **fondamentaux de l'architecture x86-64** Ã  travers l'analyse de dumps de registres :

1. **Les registres gÃ©nÃ©raux** : RAX, RBX, RCX, RDX, RSI, RDI, R8-R15
2. **Les conventions d'appel** : Comment les arguments sont passÃ©s aux fonctions
3. **La pile** : RÃ´le de RSP et RBP, notion de stack frame
4. **La diffÃ©rence SysV/Windows** : Deux mondes, deux conventions

### 5.2 LDA â€” Traduction littÃ©rale en franÃ§ais (MAJUSCULES)

```
FONCTION decode_registers QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAMÃˆTRE data QUI EST UN DICTIONNAIRE
DÃ‰BUT FONCTION
    DÃ‰CLARER registers COMME DICTIONNAIRE
    DÃ‰CLARER convention COMME CHAÃNE
    DÃ‰CLARER regs COMME DICTIONNAIRE
    DÃ‰CLARER arg_regs COMME LISTE
    DÃ‰CLARER arguments COMME LISTE

    AFFECTER data['registers'] OU DICTIONNAIRE VIDE Ã€ registers
    AFFECTER data['convention'] OU 'sysv' Ã€ convention

    POUR CHAQUE clÃ©, valeur DANS registers FAIRE
        AFFECTER LA VALEUR CONVERTIE EN MAJUSCULE Ã€ regs[clÃ©.upper()]
    FIN POUR

    SI convention EST Ã‰GAL Ã€ 'windows' ALORS
        AFFECTER ['RCX', 'RDX', 'R8', 'R9'] Ã€ arg_regs
    SINON
        AFFECTER ['RDI', 'RSI', 'RDX', 'RCX', 'R8', 'R9'] Ã€ arg_regs
    FIN SI

    AFFECTER LISTE VIDE Ã€ arguments
    POUR CHAQUE reg DANS arg_regs FAIRE
        SI reg EST DANS regs ALORS
            AJOUTER parse_hex(regs[reg]) Ã€ arguments
        FIN SI
    FIN POUR

    AFFECTER parse_hex(regs['RSP']) OU 0 Ã€ rsp
    AFFECTER parse_hex(regs['RBP']) OU 0 Ã€ rbp
    AFFECTER MAX(0, rbp - rsp) Ã€ stack_depth

    RETOURNER DICTIONNAIRE AVEC return_value, arguments, stack_depth, convention
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : DÃ©codage de Registres x86-64
---
1. LIRE le fichier JSON d'entrÃ©e
   - SI fichier = "-" : LIRE depuis stdin
   - SINON : LIRE depuis le fichier spÃ©cifiÃ©

2. EXTRAIRE les donnÃ©es :
   a. RÃ‰CUPÃ‰RER le dictionnaire 'registers'
   b. RÃ‰CUPÃ‰RER la convention ('sysv' ou 'windows')

3. NORMALISER les noms de registres :
   - CONVERTIR toutes les clÃ©s en MAJUSCULES

4. DÃ‰TERMINER les registres d'arguments :
   - SI convention = 'windows' :
       arg_regs = [RCX, RDX, R8, R9]
   - SINON (sysv) :
       arg_regs = [RDI, RSI, RDX, RCX, R8, R9]

5. EXTRAIRE les valeurs :
   a. return_value = parse_hex(RAX) ou 0
   b. POUR CHAQUE registre dans arg_regs :
        SI prÃ©sent : AJOUTER sa valeur Ã  arguments
   c. stack_depth = MAX(0, RBP - RSP)

6. RETOURNER le rÃ©sultat en JSON
```

### 5.2.3 ReprÃ©sentation Algorithmique avec Guards

```
FONCTION : parse_hex(value)
---
INIT result = 0

1. VÃ‰RIFIER si value est None ou vide :
   |
   |-- RETOURNER 0

2. NORMALISER la valeur :
   |
   |-- SUPPRIMER espaces avec strip()
   |-- SI commence par '0x' ou '0X' :
   |     CONVERTIR en int base 16
   |     RETOURNER
   |
   |-- SINON :
   |     ESSAYER int(value, 16)
   |     SI Ã©chec : ESSAYER int(value, 10)
   |     RETOURNER
```

```mermaid
graph TD
    A[DÃ©but: decode_registers] --> B{registers fourni ?}
    B -- Non --> C[registers = {}]
    B -- Oui --> D[Normaliser clÃ©s en majuscules]
    C --> D
    D --> E{convention = ?}
    E -- windows --> F[arg_regs = RCX,RDX,R8,R9]
    E -- sysv --> G[arg_regs = RDI,RSI,RDX,RCX,R8,R9]
    F --> H[Extraire arguments]
    G --> H
    H --> I[Calculer stack_depth]
    I --> J[Construire rÃ©sultat JSON]
    J --> K[RETOURNER]
```

### 5.3 Visualisation ASCII

```
                    REGISTRES x86-64
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                 â”‚
    â”‚   REGISTRES GÃ‰NÃ‰RAUX (64 bits)                  â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
    â”‚   â”‚ RAX â”‚ Accumulateur / Valeur retour    â”‚     â”‚
    â”‚   â”‚ RBX â”‚ Base (callee-saved)             â”‚     â”‚
    â”‚   â”‚ RCX â”‚ Compteur / Arg4 SysV / Arg1 Win â”‚     â”‚
    â”‚   â”‚ RDX â”‚ DonnÃ©es / Arg3 SysV / Arg2 Win  â”‚     â”‚
    â”‚   â”‚ RSI â”‚ Source Index / Arg2 SysV        â”‚     â”‚
    â”‚   â”‚ RDI â”‚ Dest Index / Arg1 SysV          â”‚     â”‚
    â”‚   â”‚ RSP â”‚ Stack Pointer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”  â”‚
    â”‚   â”‚ RBP â”‚ Base Pointer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¤  â”‚
    â”‚   â”‚ R8  â”‚ Arg5 SysV / Arg3 Win            â”‚  â”‚  â”‚
    â”‚   â”‚ R9  â”‚ Arg6 SysV / Arg4 Win            â”‚  â”‚  â”‚
    â”‚   â”‚R10-R15â”‚ Usage gÃ©nÃ©ral                 â”‚  â”‚  â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
    â”‚                                              â”‚  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”˜
                                                   â”‚
                    PILE (STACK)                   â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
    Adresses hautes
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Arguments (7+)    â”‚  â† Si > 6 args (SysV)
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚   Return Address    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† RBP (Base Pointer)
    â”‚   Saved RBP         â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚   Variables locales â”‚
    â”‚         ...         â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† RSP (Stack Pointer)
    â”‚   (espace libre)    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Adresses basses

    Stack Depth = RBP - RSP
```

### 5.4 Les piÃ¨ges en dÃ©tail

#### PiÃ¨ge 1 : Confusion des conventions d'appel

```python
# MAUVAIS: Utiliser SysV pour tout
def get_first_arg(regs):
    return regs.get('RDI', 0)  # Faux sur Windows!

# BON: VÃ©rifier la convention
def get_first_arg(regs, convention):
    if convention == 'windows':
        return regs.get('RCX', 0)
    return regs.get('RDI', 0)
```

#### PiÃ¨ge 2 : Parsing hexadÃ©cimal fragile

```python
# MAUVAIS: Assume le prÃ©fixe 0x
value = int("1337", 16)  # Marche
value = int("0x1337", 16)  # Marche aussi... par chance

# BON: GÃ©rer tous les cas
def parse_hex(value):
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    return int(value, 16)  # Essayer quand mÃªme en base 16
```

#### PiÃ¨ge 3 : Stack depth nÃ©gatif

Dans certains cas (optimisations, frame pointer omission), RBP peut Ãªtre infÃ©rieur Ã  RSP ou mÃªme non utilisÃ©.

### 5.5 Cours Complet

#### 5.5.1 Les registres x86-64 en profondeur

L'architecture x86-64 dispose de 16 registres gÃ©nÃ©raux de 64 bits :

**Registres historiques (hÃ©ritÃ©s du 8086) :**
- **RAX** : Accumulator - historiquement pour l'arithmÃ©tique, aujourd'hui valeur de retour
- **RBX** : Base - souvent utilisÃ© comme pointeur, callee-saved
- **RCX** : Counter - boucles, shifts, 4Ã¨me arg SysV / 1er arg Windows
- **RDX** : Data - I/O, multiplication 128-bit, 3Ã¨me arg SysV / 2Ã¨me arg Windows

**Registres d'index :**
- **RSI** : Source Index - opÃ©rations sur chaÃ®nes, 2Ã¨me arg SysV
- **RDI** : Destination Index - opÃ©rations sur chaÃ®nes, 1er arg SysV

**Registres de pile :**
- **RSP** : Stack Pointer - pointe vers le sommet de la pile
- **RBP** : Base Pointer - pointe vers la base du frame courant

**Nouveaux registres AMD64 :**
- **R8-R15** : 8 registres supplÃ©mentaires, R8-R9 pour arguments

#### 5.5.2 System V AMD64 ABI

La convention System V est utilisÃ©e sur Linux, macOS, FreeBSD, et la plupart des systÃ¨mes Unix.

**Passage d'arguments :**
1. RDI, RSI, RDX, RCX, R8, R9 (entiers/pointeurs)
2. XMM0-XMM7 (flottants)
3. Pile pour les arguments supplÃ©mentaires

**Valeur de retour :**
- RAX (entiers jusqu'Ã  64 bits)
- RAX:RDX (entiers 128 bits)
- XMM0 (flottants)

**Registres callee-saved :** RBX, RBP, R12-R15
**Registres caller-saved :** RAX, RCX, RDX, RSI, RDI, R8-R11

#### 5.5.3 Windows x64 ABI

Microsoft a fait des choix diffÃ©rents pour Windows 64-bit :

**Passage d'arguments :**
1. RCX, RDX, R8, R9 (entiers/pointeurs)
2. XMM0-XMM3 (flottants)
3. "Shadow space" de 32 bytes obligatoire sur la pile
4. Pile pour les arguments supplÃ©mentaires

**Pourquoi le shadow space ?**
- Simplifie le debugging (arguments toujours accessibles)
- Permet aux fonctions variadiques de "spiller" les arguments facilement

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (fonctionne, mais interdit)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ def f(data): return {"return_value": int(data["registers"]     â”‚
â”‚ ["RAX"], 16), ...}  # Tout sur une ligne                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ def f(data):                                                    â”‚
â”‚     regs = data.get("registers", {})                            â”‚
â”‚     rax = parse_hex(regs.get("RAX", "0"))                       â”‚
â”‚     return {"return_value": rax, ...}                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ LisibilitÃ© : Code dÃ©composÃ© en Ã©tapes claires                 â”‚
â”‚ â€¢ Debugging : Plus facile d'identifier les erreurs              â”‚
â”‚ â€¢ Maintenance : Modifications plus simples                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**EntrÃ©e :** `{"registers": {"RAX": "0x2a", "RDI": "0x7fff0000", "RSI": "0x10", "RSP": "0x7fff1000", "RBP": "0x7fff1040"}, "convention": "sysv"}`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                                 â”‚ Variables           â”‚ Explication              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ AFFECTER data['registers'] Ã€ registers      â”‚ registers = {...}   â”‚ Extraction des registres â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ AFFECTER 'sysv' Ã€ convention                â”‚ convention = 'sysv' â”‚ Convention spÃ©cifiÃ©e     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ NORMALISER clÃ©s en majuscules               â”‚ regs = {RAX: 0x2a}  â”‚ Uniformisation           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ CHOISIR arg_regs pour sysv                  â”‚ [RDI,RSI,RDX,...]   â”‚ 6 registres pour SysV    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ EXTRAIRE arguments depuis arg_regs          â”‚ [0x7fff0000, 0x10]  â”‚ RDI et RSI prÃ©sents      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ CALCULER stack_depth = RBP - RSP            â”‚ 0x40 = 64           â”‚ 0x7fff1040 - 0x7fff1000  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ RETOURNER rÃ©sultat                          â”‚ {return_value: 42}  â”‚ RAX = 0x2a = 42          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "The Matrix - Blue Pill vs Red Pill" â€” Choisir sa convention

Comme Neo doit choisir entre la pilule bleue (rester dans l'ignorance) et la pilule rouge (voir la vÃ©ritÃ©), tu dois choisir ta convention :

- **Pilule Bleue (Windows)** : RCX, RDX, R8, R9 â€” "C'est plus simple, 4 arguments max dans les registres"
- **Pilule Rouge (SysV/Linux)** : RDI, RSI, RDX, RCX, R8, R9 â€” "6 arguments, plus efficace mais plus complexe"

```python
if convention == "windows":
    return take_blue_pill()  # RCX first
else:
    return take_red_pill()   # RDI first, see deeper
```

#### ğŸ”¥ MEME : "Registres comme les Avengers"

- **RAX** = Iron Man (le leader, retourne toujours avec la solution)
- **RDI** = Captain America (premier Ã  entrer, premier argument)
- **RSP** = Hulk (bas de la pile, force brute vers le bas)
- **RBP** = Thor (ancrÃ©, stable, base solide)

### 5.9 Applications pratiques

1. **Analyse de crash dumps** : Quand un programme crash, le systÃ¨me sauvegarde l'Ã©tat des registres
2. **Debugging avec GDB** : `info registers` affiche l'Ã©tat courant
3. **Reverse engineering** : Comprendre les arguments passÃ©s aux fonctions
4. **Exploitation** : Identifier oÃ¹ placer les gadgets ROP

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | ConsÃ©quence | Solution |
|---|-------|-------------|----------|
| 1 | Confondre conventions SysV/Windows | Arguments mal identifiÃ©s | VÃ©rifier le paramÃ¨tre convention |
| 2 | Ne pas gÃ©rer l'absence de 0x | Erreur de parsing | Normaliser avant conversion |
| 3 | Oublier que RBP peut Ãªtre < RSP | Stack depth nÃ©gatif | Utiliser max(0, rbp - rsp) |
| 4 | Case sensitivity des registres | KeyError | Normaliser en majuscules |
| 5 | Assumer tous les registres prÃ©sents | KeyError ou None | Utiliser .get() avec dÃ©faut |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Dans la convention System V AMD64, quel registre contient le premier argument entier d'une fonction ?**

A) RAX
B) RCX
C) RDI
D) RSI
E) R8
F) RBX
G) RSP
H) RBP
I) RDX
J) R9

**RÃ©ponse : C**

---

### Question 2
**Dans la convention Windows x64, quel registre contient le premier argument entier ?**

A) RDI
B) RSI
C) RDX
D) RCX
E) R8
F) RAX
G) RBX
H) R9
I) RSP
J) RBP

**RÃ©ponse : D**

---

### Question 3
**Quel registre contient la valeur de retour d'une fonction dans les deux conventions ?**

A) RDI
B) RSI
C) RDX
D) RCX
E) RAX
F) RBX
G) RSP
H) RBP
I) R8
J) R9

**RÃ©ponse : E**

---

### Question 4
**Si RSP = 0x7fff1000 et RBP = 0x7fff1080, quelle est la profondeur de pile (stack depth) ?**

A) 0x80 (128 bytes)
B) 0x1080 bytes
C) 0x7fff1080 bytes
D) -128 bytes
E) 0 bytes
F) 0x1000 bytes
G) 64 bytes
H) 256 bytes
I) Impossible Ã  calculer
J) DÃ©pend de la convention

**RÃ©ponse : A**

---

### Question 5
**Combien d'arguments peuvent Ãªtre passÃ©s dans les registres avec la convention System V AMD64 ?**

A) 2
B) 4
C) 6
D) 8
E) Aucun, tout passe par la pile
F) 3
G) 5
H) 7
I) 16
J) IllimitÃ©

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10) |
| **Temps estimÃ©** | 45 min |
| **XP Base** | 150 |
| **XP Bonus** | Ã—2 (300 total) |
| **Concepts clÃ©s** | Registres x86-64, ABI SysV/Windows, Stack frames |
| **Langage** | Python 3.12 |
| **PrÃ©requis** | Bases Python, HexadÃ©cimal |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.1-a-register-decoder",
    "generated_at": "2026-01-16 14:30:00",

    "metadata": {
      "exercise_id": "3.4.1-a",
      "exercise_name": "register_decoder",
      "module": "3.4.1",
      "module_name": "x86-64 Assembly Fundamentals",
      "concept": "a",
      "concept_name": "Registres gÃ©nÃ©raux et conventions d'appel",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isolÃ©",
      "phase": 3,
      "difficulty": 6,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†",
      "language": "python",
      "duration_minutes": 45,
      "xp_base": 150,
      "xp_bonus_multiplier": 2,
      "bonus_tier": "STANDARD",
      "bonus_icon": "âš¡",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["Bases Python", "HexadÃ©cimal", "Architecture x86-64"],
      "domains": ["CPU", "ASM", "Encodage"],
      "domains_bonus": ["Mem"],
      "tags": ["assembly", "x86-64", "registers", "abi", "reverse-engineering"],
      "meme_reference": "The Matrix - Blue Pill vs Red Pill"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.py": "/* Section 4.3 */",
      "references/ref_solution_bonus.py": "/* Section 4.6 */",
      "alternatives/alt_1.py": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.py": "/* Section 4.10 */",
      "mutants/mutant_b_safety.py": "/* Section 4.10 */",
      "mutants/mutant_c_logic.py": "/* Section 4.10 */",
      "mutants/mutant_d_return.py": "/* Section 4.10 */",
      "mutants/mutant_e_parse.py": "/* Section 4.10 */",
      "tests/test_input.json": "/* Test data */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.py",
        "references/ref_solution_bonus.py",
        "alternatives/alt_1.py"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.py",
        "mutants/mutant_b_safety.py",
        "mutants/mutant_c_logic.py",
        "mutants/mutant_d_return.py",
        "mutants/mutant_e_parse.py"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_solution.py",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.py -s spec.json --validate"
    }
  }
}
```
