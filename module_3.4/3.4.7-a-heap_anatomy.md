# Exercice 3.4.7-a : heap_anatomy

**Module :**
3.4.7 — Heap Exploitation

**Concept :**
a — Structure interne du heap glibc

**Difficulte :**
★★★★★★★★☆☆ (8/10)

**Type :**
code

**Tiers :**
2 — Concept composite

**Langage :**
Python 3.12

**Prerequis :**
- Programmation Python avancee
- Notions de gestion memoire dynamique
- Bases de l'exploitation binaire
- Comprehension du format hexadecimal

**Domaines :**
Heap, Mem, Exploit

**Duree estimee :**
90 min

**XP Base :**
300

**Complexite :**
T3 O(n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`heap_anatomy.py`

**Fonctions autorisees :**
- `json` (module standard)
- `struct` (parsing binaire)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- pwntools
- gdb bindings
- Modules d'analyse heap externes

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Inception"

*"You mustn't be afraid to dream a little bigger, darling."*

Dans **Inception**, Cobb et son equipe naviguent entre differentes couches de reves, chacune avec ses propres regles et structures. Le heap est similaire : une structure en couches avec des arenas, des bins, et des chunks qui s'emboitent les uns dans les autres.

Comme les architectes de reves qui doivent comprendre chaque niveau pour manipuler la realite, tu vas apprendre a "voir" la structure interne du heap glibc. Les chunks sont comme les elements du reve, les bins comme les niveaux de profondeur, et le top chunk comme le Limbe - la reserve infinie de memoire.

#### 2.4.2 Enonce Academique

Le heap glibc (ptmalloc2) est l'allocateur memoire par defaut sur Linux. Comprendre sa structure interne est essentiel pour l'exploitation heap.

**Ta mission :**

Ecrire un programme `heap_anatomy.py` qui :

1. **Parse** un dump memoire du heap au format hexadecimal
2. **Identifie** les chunks (alloues et liberes)
3. **Reconstruit** les bins (fastbins, tcache, unsorted, small, large)
4. **Detecte** les anomalies potentielles (corruption, double-free)
5. **Visualise** l'etat du heap

**Structure d'un chunk malloc :**
```
┌──────────────────────────────────────────┐
│  prev_size (8 bytes si prev est free)    │
├──────────────────────────────────────────┤
│  size | A | M | P  (8 bytes)             │
│  - A: NON_MAIN_ARENA                     │
│  - M: IS_MMAPPED                         │
│  - P: PREV_INUSE                         │
├──────────────────────────────────────────┤
│  fd (si free, sinon user data)           │
├──────────────────────────────────────────┤
│  bk (si free, sinon user data)           │
├──────────────────────────────────────────┤
│  user data...                            │
└──────────────────────────────────────────┘
```

**Entree :**
- Fichier JSON contenant :
  - `heap_base` : Adresse de base du heap
  - `heap_dump` : Donnees hexadecimales du heap
  - `arena_addr` : Adresse de l'arena principale (optionnel)
  - `glibc_version` : Version glibc (ex: "2.31")

**Sortie :**
- JSON avec l'analyse complete sur stdout

**Contraintes :**
- Supporter les chunks de taille minimum (0x20 sur 64-bit)
- Gerer les flags A, M, P correctement
- Detecter les free chunks via les flags et la structure
- Taille du chunk = size & ~0x7 (masquer les 3 bits de flags)

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"heap_base": "0x555555559000", "heap_dump": "0000000000000000 3102000000000000 4141414141414141...", "glibc_version": "2.31"}` | `{"chunks": [{"addr": "0x555555559000", "size": 560, "flags": {"P": true, "M": false, "A": false}, "state": "allocated"}], ...}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
heap_anatomy.py - Analyse de la structure interne du heap glibc
"""

import json
import struct
import sys

MALLOC_ALIGN = 16  # Alignement sur 64-bit
MIN_CHUNK_SIZE = 0x20  # Taille minimum chunk 64-bit
SIZE_BITS = 0x7  # Masque pour les flags (P, M, A)

def parse_heap_dump(hex_dump: str) -> bytes:
    """Convertit un dump hexadecimal en bytes."""
    pass

def parse_chunk(data: bytes, offset: int, heap_base: int) -> dict:
    """
    Parse un chunk malloc a l'offset donne.

    Args:
        data: Donnees brutes du heap
        offset: Offset dans le dump
        heap_base: Adresse de base du heap

    Returns:
        Dictionnaire decrivant le chunk
    """
    pass

def identify_bins(chunks: list, glibc_version: str) -> dict:
    """
    Identifie les bins et reconstruit les free lists.

    Args:
        chunks: Liste des chunks parses
        glibc_version: Version de glibc

    Returns:
        Dictionnaire des bins avec leurs contenus
    """
    pass

def detect_anomalies(chunks: list, bins: dict) -> list:
    """
    Detecte les anomalies potentielles (corruption, double-free).

    Args:
        chunks: Liste des chunks
        bins: Dictionnaire des bins

    Returns:
        Liste des anomalies detectees
    """
    pass

def analyze_heap(data: dict) -> dict:
    """
    Analyse complete d'un dump heap.

    Args:
        data: Donnees d'entree (heap_base, heap_dump, etc.)

    Returns:
        Analyse complete du heap
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'histoire de ptmalloc2

ptmalloc2 (pthread malloc version 2) est base sur dlmalloc de Doug Lea, adapte pour le multi-threading par Wolfram Gloger en 1999. Il est devenu l'allocateur par defaut de glibc et donc de la majorite des systemes Linux.

### Pourquoi tant de bins ?

Les differents types de bins optimisent les performances :
- **Tcache** (glibc 2.26+) : Cache per-thread, ultra-rapide, pas de locks
- **Fastbins** : Petites allocations frequentes, LIFO, pas de coalescing
- **Unsorted bin** : File d'attente temporaire avant tri
- **Small bins** : Tailles fixes, doubly-linked, FIFO
- **Large bins** : Tailles variables, tries par taille

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Chercheur en Vulnerabilites / Exploit Developer**

Les experts en exploitation heap utilisent ces connaissances pour :
- **Developper des exploits** : Use-after-free, heap overflow, tcache poisoning
- **Bypasser les protections** : Safe-linking (glibc 2.32+), tcache keys
- **Analyser des malwares** : Comprendre les techniques d'heap spray

**Cas d'usage concret :**
Chez Google Project Zero ou ZDI, les chercheurs analysent les dumps heap pour :
- Identifier comment un bug memoire peut etre exploite
- Determiner la "heap feng shui" necessaire pour un exploit fiable
- Verifier si les protections modernes bloquent l'exploitation

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
heap_anatomy.py  heap_dump.json

$ cat heap_dump.json
{
  "heap_base": "0x555555559000",
  "heap_dump": "0000000000000000 2102000000000000 4141414141414141 4141414141414141 0000000000000000 3100000000000000 0060555555550000 0060555555550000",
  "glibc_version": "2.31"
}

$ python3 heap_anatomy.py heap_dump.json
{
  "heap_base": "0x555555559000",
  "chunks": [
    {
      "addr": "0x555555559000",
      "prev_size": 0,
      "size": 544,
      "real_size": 544,
      "flags": {"P": true, "M": false, "A": false},
      "state": "allocated",
      "data_preview": "41414141..."
    },
    {
      "addr": "0x555555559220",
      "prev_size": 0,
      "size": 48,
      "real_size": 48,
      "flags": {"P": true, "M": false, "A": false},
      "state": "free",
      "fd": "0x555555560000",
      "bk": "0x555555560000"
    }
  ],
  "bins": {
    "tcache": {},
    "fastbins": [],
    "unsorted": [],
    "smallbins": [],
    "largebins": []
  },
  "anomalies": [],
  "top_chunk": {
    "addr": "0x555555559250",
    "size": "0x20db0"
  }
}

$ echo '{"heap_base": "0x10000", "heap_dump": "0000000000000000 2100000000000000 0020000000000000 0020000000000000", "glibc_version": "2.35"}' | python3 heap_anatomy.py -
{"chunks": [...], "anomalies": ["Potential tcache double-free detected at 0x10000"]}
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★☆ (9/10)

**Recompense :**
XP x2

**Time Complexity attendue :**
O(n)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
Heap, Exploit, Forensics

### 3.1.1 Consigne Bonus

**Extension "Full Heap Forensics" :**

Etendre le programme pour :

1. **Parser les tcache** structures (tcache_perthread_struct)
2. **Verifier safe-linking** (glibc 2.32+) : decoder les pointeurs XOR
3. **Detecter tcache poisoning** : pointeurs invalides dans tcache
4. **Reconstruire l'historique** : ordre probable des allocations/liberations
5. **Generer une visualisation ASCII** du heap layout

**Contraintes supplementaires :**
```
┌─────────────────────────────────────────┐
│  Safe-linking : fd = (addr >> 12) ^ fd  │
│  Tcache key check pour double-free      │
│  Supporter glibc 2.27 a 2.38            │
└─────────────────────────────────────────┘
```

### 3.1.2 Prototype Bonus

```python
def decode_safe_linking(encoded_ptr: int, chunk_addr: int) -> int:
    """Decode un pointeur protege par safe-linking."""
    pass

def parse_tcache_struct(data: bytes, heap_base: int, glibc_version: str) -> dict:
    """Parse la structure tcache_perthread_struct."""
    pass

def detect_tcache_poisoning(tcache: dict, heap_base: int, heap_size: int) -> list:
    """Detecte les pointeurs tcache invalides."""
    pass

def visualize_heap(chunks: list, bins: dict) -> str:
    """Genere une visualisation ASCII du heap."""
    pass
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Bins | Identifies | + Tcache parsed |
| Safe-linking | Non gere | Decode automatiquement |
| Detection | Anomalies basiques | + Tcache poisoning |
| Visualisation | JSON | + ASCII art |
| Versions glibc | 2.31 | 2.27 - 2.38 |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| basic_chunk | Un chunk alloue simple | chunk parse correctement | 10 |
| free_chunk | Chunk avec fd/bk | state: "free", fd/bk corrects | 10 |
| multiple_chunks | 5 chunks consecutifs | Tous identifies | 15 |
| flags_parsing | Chunk avec P=1, M=0, A=0 | flags corrects | 10 |
| size_masking | size = 0x231 | real_size = 0x230, P=1 | 10 |
| top_chunk | Heap avec top chunk | top_chunk identifie | 10 |
| fastbin_detect | Chunk dans fastbin range | bins.fastbins rempli | 10 |
| anomaly_detect | Chunk corrompu | anomalies non vide | 15 |
| empty_heap | Heap vide | chunks: [] | 5 |
| large_chunk | Chunk > 0x400 | Identifie comme large | 5 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
heap_anatomy.py - Solution de reference
"""

import json
import struct
import sys

MALLOC_ALIGN = 16
MIN_CHUNK_SIZE = 0x20
SIZE_BITS = 0x7
FASTBIN_MAX = 0x80
SMALLBIN_MAX = 0x400

PREV_INUSE = 0x1
IS_MMAPPED = 0x2
NON_MAIN_ARENA = 0x4

def parse_hex(value: str) -> int:
    """Convertit une valeur hexadecimale en entier."""
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    return int(value, 16)

def parse_heap_dump(hex_dump: str) -> bytes:
    """Convertit un dump hexadecimal en bytes."""
    hex_dump = hex_dump.replace(' ', '').replace('\n', '')
    if hex_dump.startswith('0x'):
        hex_dump = hex_dump[2:]
    return bytes.fromhex(hex_dump)

def read_qword(data: bytes, offset: int) -> int:
    """Lit un qword (8 bytes) little-endian."""
    if offset + 8 > len(data):
        return 0
    return struct.unpack('<Q', data[offset:offset+8])[0]

def parse_chunk(data: bytes, offset: int, heap_base: int) -> dict:
    """Parse un chunk malloc a l'offset donne."""
    if offset + MIN_CHUNK_SIZE > len(data):
        return None

    prev_size = read_qword(data, offset)
    size_field = read_qword(data, offset + 8)

    flags = {
        'P': bool(size_field & PREV_INUSE),
        'M': bool(size_field & IS_MMAPPED),
        'A': bool(size_field & NON_MAIN_ARENA)
    }

    real_size = size_field & ~SIZE_BITS

    if real_size < MIN_CHUNK_SIZE or real_size > 0x100000:
        return None

    chunk_addr = heap_base + offset

    # Lire fd et bk potentiels
    fd = read_qword(data, offset + 16) if offset + 24 <= len(data) else 0
    bk = read_qword(data, offset + 24) if offset + 32 <= len(data) else 0

    # Heuristique pour determiner si free
    # Un chunk free a generalement fd/bk qui pointent vers d'autres chunks ou bins
    is_free = False
    if fd != 0 and (fd >> 40) in [0x55, 0x56, 0x7f]:  # Adresses heap/libc typiques
        is_free = True

    # Lire quelques bytes de data pour preview
    data_start = offset + 16
    data_preview = data[data_start:data_start+16].hex() if data_start + 16 <= len(data) else ""

    chunk = {
        'addr': hex(chunk_addr),
        'prev_size': prev_size,
        'size': size_field,
        'real_size': real_size,
        'flags': flags,
        'state': 'free' if is_free else 'allocated',
        'data_preview': data_preview
    }

    if is_free:
        chunk['fd'] = hex(fd)
        chunk['bk'] = hex(bk)

    return chunk

def identify_bins(chunks: list, glibc_version: str) -> dict:
    """Identifie les bins et reconstruit les free lists."""
    bins = {
        'tcache': {},
        'fastbins': [],
        'unsorted': [],
        'smallbins': [],
        'largebins': []
    }

    for chunk in chunks:
        if chunk['state'] != 'free':
            continue

        size = chunk['real_size']

        if size <= FASTBIN_MAX:
            bins['fastbins'].append(chunk['addr'])
        elif size <= SMALLBIN_MAX:
            bins['smallbins'].append(chunk['addr'])
        else:
            bins['largebins'].append(chunk['addr'])

    return bins

def detect_anomalies(chunks: list, bins: dict) -> list:
    """Detecte les anomalies potentielles."""
    anomalies = []

    seen_addrs = set()
    for chunk in chunks:
        addr = chunk['addr']
        if addr in seen_addrs:
            anomalies.append(f"Duplicate chunk address detected: {addr}")
        seen_addrs.add(addr)

        # Verifier taille coherente
        if chunk['real_size'] < MIN_CHUNK_SIZE:
            anomalies.append(f"Invalid chunk size at {addr}: {chunk['real_size']}")

        # Verifier alignement
        addr_int = int(addr, 16)
        if addr_int % MALLOC_ALIGN != 0:
            anomalies.append(f"Misaligned chunk at {addr}")

    return anomalies

def find_top_chunk(data: bytes, chunks: list, heap_base: int) -> dict:
    """Trouve le top chunk (wilderness)."""
    if not chunks:
        return None

    last_chunk = chunks[-1]
    last_end = int(last_chunk['addr'], 16) + last_chunk['real_size'] - heap_base

    if last_end + 16 <= len(data):
        top_size = read_qword(data, last_end + 8)
        if top_size & ~SIZE_BITS > 0x1000:  # Top chunk est generalement grand
            return {
                'addr': hex(heap_base + last_end),
                'size': hex(top_size & ~SIZE_BITS)
            }

    return None

def analyze_heap(data: dict) -> dict:
    """Analyse complete d'un dump heap."""
    heap_base = parse_hex(data.get('heap_base', '0'))
    hex_dump = data.get('heap_dump', '')
    glibc_version = data.get('glibc_version', '2.31')

    heap_data = parse_heap_dump(hex_dump)

    chunks = []
    offset = 0

    while offset < len(heap_data) - MIN_CHUNK_SIZE:
        chunk = parse_chunk(heap_data, offset, heap_base)
        if chunk is None:
            break
        chunks.append(chunk)
        offset += chunk['real_size']

        # Eviter boucle infinie
        if chunk['real_size'] == 0:
            break

    bins = identify_bins(chunks, glibc_version)
    anomalies = detect_anomalies(chunks, bins)
    top_chunk = find_top_chunk(heap_data, chunks, heap_base)

    result = {
        'heap_base': hex(heap_base),
        'chunks': chunks,
        'bins': bins,
        'anomalies': anomalies
    }

    if top_chunk:
        result['top_chunk'] = top_chunk

    return result

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: heap_anatomy.py <input.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = analyze_heap(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptees

```python
# Alternative 1: Utilisation de ctypes pour les structures
import ctypes

class MallocChunk(ctypes.Structure):
    _fields_ = [
        ('prev_size', ctypes.c_uint64),
        ('size', ctypes.c_uint64),
        ('fd', ctypes.c_uint64),
        ('bk', ctypes.c_uint64),
    ]

def parse_chunk_ctypes(data: bytes, offset: int) -> dict:
    chunk = MallocChunk.from_buffer_copy(data[offset:offset+32])
    return {
        'prev_size': chunk.prev_size,
        'size': chunk.size,
        'fd': chunk.fd,
        'bk': chunk.bk
    }
```

### 4.5 Solutions refusees (avec explications)

```python
# REFUSE: Ne masque pas les flags de taille
def parse_chunk_bad(data, offset):
    size = struct.unpack('<Q', data[offset+8:offset+16])[0]
    return {'size': size}  # Inclut les flags P, M, A!

# Pourquoi c'est faux: La vraie taille est size & ~0x7
```

```python
# REFUSE: Assume que tous les chunks sont alloues
def analyze_heap_bad(data):
    chunks = []
    for chunk in parse_all_chunks(data):
        chunk['state'] = 'allocated'  # Toujours!
    return chunks

# Pourquoi c'est faux: Les chunks free ont une structure differente
```

### 4.6 Solution bonus de reference

```python
#!/usr/bin/env python3
"""
heap_anatomy.py - Solution bonus avec safe-linking et tcache
"""

import json
import struct
import sys

# ... (code de base) ...

TCACHE_MAX_BINS = 64
TCACHE_FILL_COUNT = 7

def decode_safe_linking(encoded_ptr: int, chunk_addr: int) -> int:
    """Decode un pointeur protege par safe-linking (glibc 2.32+)."""
    return encoded_ptr ^ (chunk_addr >> 12)

def parse_tcache_struct(data: bytes, heap_base: int, glibc_version: str) -> dict:
    """Parse la structure tcache_perthread_struct au debut du heap."""
    tcache = {'entries': {}, 'counts': {}}

    version_tuple = tuple(map(int, glibc_version.split('.')))
    has_safe_linking = version_tuple >= (2, 32)

    # tcache_perthread_struct est au debut du heap (apres le premier chunk)
    # Structure: counts[TCACHE_MAX_BINS] puis entries[TCACHE_MAX_BINS]

    offset = 0x10  # Apres le header du premier chunk

    # Lire counts (2 bytes chacun dans glibc moderne)
    for i in range(TCACHE_MAX_BINS):
        if offset + 2 > len(data):
            break
        count = struct.unpack('<H', data[offset:offset+2])[0]
        if count > 0:
            tcache['counts'][hex((i + 2) * 0x10)] = count
        offset += 2

    # Aligner sur 8 bytes si necessaire
    offset = (offset + 7) & ~7

    # Lire entries (pointeurs 8 bytes)
    for i in range(TCACHE_MAX_BINS):
        if offset + 8 > len(data):
            break
        entry = struct.unpack('<Q', data[offset:offset+8])[0]
        if entry != 0:
            bin_size = hex((i + 2) * 0x10)
            if bin_size not in tcache['entries']:
                tcache['entries'][bin_size] = []

            if has_safe_linking:
                # Decoder le pointeur
                decoded = decode_safe_linking(entry, heap_base + offset)
                tcache['entries'][bin_size].append({
                    'encoded': hex(entry),
                    'decoded': hex(decoded)
                })
            else:
                tcache['entries'][bin_size].append(hex(entry))
        offset += 8

    return tcache

def detect_tcache_poisoning(tcache: dict, heap_base: int, heap_size: int) -> list:
    """Detecte les pointeurs tcache invalides."""
    anomalies = []

    heap_end = heap_base + heap_size

    for bin_size, entries in tcache.get('entries', {}).items():
        for entry in entries:
            if isinstance(entry, dict):
                ptr = int(entry['decoded'], 16)
            else:
                ptr = int(entry, 16)

            # Verifier que le pointeur est dans une range valide
            if ptr != 0:
                if ptr < 0x10000 or ptr > 0x7fffffffffff:
                    anomalies.append(f"Tcache poisoning: invalid pointer {hex(ptr)} in bin {bin_size}")
                elif ptr < heap_base or ptr >= heap_end:
                    anomalies.append(f"Tcache poisoning: out-of-heap pointer {hex(ptr)} in bin {bin_size}")

    return anomalies

def visualize_heap(chunks: list, bins: dict, width: int = 60) -> str:
    """Genere une visualisation ASCII du heap."""
    lines = []
    lines.append("=" * width)
    lines.append("HEAP LAYOUT".center(width))
    lines.append("=" * width)

    for i, chunk in enumerate(chunks):
        state_char = 'F' if chunk['state'] == 'free' else 'A'
        size_str = f"0x{chunk['real_size']:x}"
        addr_str = chunk['addr']

        line = f"| [{state_char}] {addr_str} | size: {size_str:>8} |"
        lines.append(line)

        if chunk['state'] == 'free':
            lines.append(f"|     fd: {chunk.get('fd', 'N/A'):>16} |")
            lines.append(f"|     bk: {chunk.get('bk', 'N/A'):>16} |")

        lines.append("-" * width)

    lines.append("")
    lines.append("BINS SUMMARY".center(width))
    lines.append("-" * width)

    for bin_type, entries in bins.items():
        if entries:
            count = len(entries) if isinstance(entries, list) else len(entries.keys())
            lines.append(f"| {bin_type:>12}: {count} entries")

    lines.append("=" * width)

    return "\n".join(lines)

def analyze_heap_advanced(data: dict) -> dict:
    """Analyse avancee avec tcache et safe-linking."""
    result = analyze_heap(data)

    heap_base = int(result['heap_base'], 16)
    hex_dump = data.get('heap_dump', '')
    glibc_version = data.get('glibc_version', '2.31')

    heap_data = parse_heap_dump(hex_dump)

    # Parser tcache
    tcache = parse_tcache_struct(heap_data, heap_base, glibc_version)
    result['bins']['tcache'] = tcache

    # Detecter tcache poisoning
    tcache_anomalies = detect_tcache_poisoning(tcache, heap_base, len(heap_data))
    result['anomalies'].extend(tcache_anomalies)

    # Generer visualisation
    result['visualization'] = visualize_heap(result['chunks'], result['bins'])

    return result
```

### 4.7 Solutions refusees bonus

```python
# REFUSE: Ne decode pas safe-linking
def parse_tcache_bad(data, heap_base):
    entries = []
    # Lit les pointeurs bruts sans decoder
    for ptr in raw_pointers:
        entries.append(ptr)  # Encodé!
    return entries

# Pourquoi: Sur glibc 2.32+, les pointeurs sont XOR avec (addr >> 12)
```

### 4.8 spec.json (ENGINE v22.1)

```json
{
  "name": "heap_anatomy",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 2,
  "tier_info": "Concept composite",
  "tags": ["heap", "glibc", "exploitation", "memory", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_heap",
    "prototype": "def analyze_heap(data: dict) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "data", "type": "dict"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "empty_heap",
        "args": [{"heap_base": "0x10000", "heap_dump": "", "glibc_version": "2.31"}],
        "expected": {"chunks": [], "bins": {"tcache": {}, "fastbins": [], "unsorted": [], "smallbins": [], "largebins": []}, "anomalies": []}
      },
      {
        "name": "single_allocated",
        "args": [{"heap_base": "0x10000", "heap_dump": "0000000000000000 2100000000000000 4141414141414141 4141414141414141", "glibc_version": "2.31"}],
        "check": "len(result['chunks']) == 1 and result['chunks'][0]['state'] == 'allocated'"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 200
    }
  },

  "norm": {
    "allowed_functions": ["json", "struct", "sys"],
    "forbidden_functions": ["pwntools", "gdb"],
    "check_security": false,
    "blocking": true
  }
}
```

### 4.9 Solutions Mutantes (minimum 5)

```python
# Mutant A (Boundary) : Ne masque pas les flags
def parse_chunk_mutant_a(data, offset, heap_base):
    size_field = read_qword(data, offset + 8)
    return {'real_size': size_field}  # Inclut P, M, A!

# Pourquoi c'est faux: real_size doit etre size_field & ~0x7
```

```python
# Mutant B (Logic) : Inverse la detection free/allocated
def parse_chunk_mutant_b(data, offset, heap_base):
    # ...
    is_free = False  # Toujours allocated
    return {'state': 'allocated'}

# Pourquoi c'est faux: Les chunks free doivent etre identifies
```

```python
# Mutant C (Safety) : Buffer overflow dans read_qword
def read_qword_mutant_c(data, offset):
    return struct.unpack('<Q', data[offset:offset+8])[0]  # Pas de bounds check!

# Pourquoi c'est faux: Crash si offset + 8 > len(data)
```

```python
# Mutant D (Parse) : Mauvais endianness
def read_qword_mutant_d(data, offset):
    return struct.unpack('>Q', data[offset:offset+8])[0]  # Big-endian!

# Pourquoi c'est faux: x86 est little-endian
```

```python
# Mutant E (Return) : Oublie de retourner les bins
def analyze_heap_mutant_e(data):
    chunks = parse_all_chunks(data)
    return {'chunks': chunks}  # Pas de bins!

# Pourquoi c'est faux: bins est requis dans la sortie
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne les **fondamentaux de la structure heap glibc** :

1. **Structure des chunks** : prev_size, size, flags, fd/bk
2. **Les bins** : Comment glibc organise les chunks liberes
3. **Detection d'anomalies** : Identifier les corruptions potentielles
4. **Evolution glibc** : Changements de securite (tcache, safe-linking)

### 5.2 LDA - Traduction litterale en francais (MAJUSCULES)

```
FONCTION analyze_heap QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAMETRE data QUI EST UN DICTIONNAIRE
DEBUT FONCTION
    DECLARER heap_base COMME ENTIER
    DECLARER heap_data COMME BYTES
    DECLARER chunks COMME LISTE
    DECLARER offset COMME ENTIER

    AFFECTER parse_hex(data['heap_base']) A heap_base
    AFFECTER parse_heap_dump(data['heap_dump']) A heap_data
    AFFECTER 0 A offset

    TANT QUE offset < longueur(heap_data) - MIN_CHUNK_SIZE FAIRE
        DECLARER chunk COMME DICTIONNAIRE
        AFFECTER parse_chunk(heap_data, offset, heap_base) A chunk

        SI chunk EST NULL ALORS
            SORTIR DE LA BOUCLE
        FIN SI

        AJOUTER chunk A chunks
        INCREMENTER offset DE chunk['real_size']
    FIN TANT QUE

    DECLARER bins COMME DICTIONNAIRE
    AFFECTER identify_bins(chunks, glibc_version) A bins

    DECLARER anomalies COMME LISTE
    AFFECTER detect_anomalies(chunks, bins) A anomalies

    RETOURNER DICTIONNAIRE AVEC chunks, bins, anomalies
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Analyse de Heap glibc
---
1. LIRE les parametres d'entree :
   a. heap_base : adresse de base du heap
   b. heap_dump : donnees hexadecimales
   c. glibc_version : version de la libc

2. CONVERTIR le dump hex en bytes

3. PARCOURIR le heap chunk par chunk :
   a. LIRE prev_size (8 bytes)
   b. LIRE size avec flags (8 bytes)
   c. EXTRAIRE les flags P, M, A
   d. CALCULER real_size = size & ~0x7
   e. DETERMINER si free ou allocated
   f. SI free : LIRE fd et bk
   g. AVANCER de real_size bytes

4. CLASSIFIER les chunks free dans les bins :
   a. size <= 0x80 : fastbins
   b. size <= 0x400 : smallbins
   c. size > 0x400 : largebins

5. DETECTER les anomalies :
   a. Tailles invalides
   b. Alignement incorrect
   c. Pointeurs suspects

6. RETOURNER l'analyse complete
```

### 5.3 Visualisation ASCII

```
                    STRUCTURE DU HEAP GLIBC
    ┌─────────────────────────────────────────────────────────┐
    │                      ARENA                              │
    │  ┌─────────────────────────────────────────────────┐    │
    │  │  mutex, flags, fastbins[], bins[], ...          │    │
    │  └─────────────────────────────────────────────────┘    │
    │                          │                              │
    │                          ▼                              │
    │  ┌─────────────────────────────────────────────────┐    │
    │  │              HEAP MEMORY                        │    │
    │  │                                                 │    │
    │  │   CHUNK 1 (allocated)                           │    │
    │  │  ┌─────────────────────────────┐                │    │
    │  │  │ prev_size (if prev free)    │ 8 bytes        │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │ size         |A|M|P|        │ 8 bytes        │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │                             │                │    │
    │  │  │     USER DATA               │                │    │
    │  │  │                             │                │    │
    │  │  └─────────────────────────────┘                │    │
    │  │                                                 │    │
    │  │   CHUNK 2 (free)                                │    │
    │  │  ┌─────────────────────────────┐                │    │
    │  │  │ prev_size                   │ 8 bytes        │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │ size         |A|M|P|        │ 8 bytes        │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │ fd (forward pointer)        │ 8 bytes        │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │ bk (backward pointer)       │ 8 bytes        │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │ (unused space)              │                │    │
    │  │  └─────────────────────────────┘                │    │
    │  │                                                 │    │
    │  │   TOP CHUNK (wilderness)                        │    │
    │  │  ┌─────────────────────────────┐                │    │
    │  │  │ 0                           │                │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │ large size    |0|0|P|       │                │    │
    │  │  ├─────────────────────────────┤                │    │
    │  │  │                             │                │    │
    │  │  │  (available memory)         │                │    │
    │  │  │                             │                │    │
    │  │  └─────────────────────────────┘                │    │
    │  └─────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────┘

                    BINS ORGANISATION
    ┌──────────────────────────────────────────────────────────┐
    │  TCACHE (glibc 2.26+)           Per-thread, fastest      │
    │  ┌─────────────────────────────────────────────────┐     │
    │  │ counts[64]  │ entries[64] ─► chunk ─► chunk ─► │     │
    │  └─────────────────────────────────────────────────┘     │
    │                                                          │
    │  FASTBINS (size <= 0x80)        LIFO, singly-linked      │
    │  ┌─────────────────────────────────────────────────┐     │
    │  │ [0x20] ─► chunk ─► chunk                        │     │
    │  │ [0x30] ─► chunk                                 │     │
    │  │ [0x40] ─► ...                                   │     │
    │  └─────────────────────────────────────────────────┘     │
    │                                                          │
    │  UNSORTED BIN                   Temporary queue          │
    │  ┌─────────────────────────────────────────────────┐     │
    │  │ chunk ◄─► chunk ◄─► chunk                       │     │
    │  └─────────────────────────────────────────────────┘     │
    │                                                          │
    │  SMALL BINS (size <= 0x400)     Doubly-linked, FIFO     │
    │  ┌─────────────────────────────────────────────────┐     │
    │  │ [0x90]  ◄─► chunk ◄─► chunk                     │     │
    │  │ [0xa0]  ◄─► chunk                               │     │
    │  └─────────────────────────────────────────────────┘     │
    │                                                          │
    │  LARGE BINS (size > 0x400)      Sorted by size          │
    │  ┌─────────────────────────────────────────────────┐     │
    │  │ chunk(big) ◄─► chunk(medium) ◄─► chunk(small)   │     │
    │  └─────────────────────────────────────────────────┘     │
    └──────────────────────────────────────────────────────────┘
```

### 5.4 Les pieges en detail

#### Piege 1 : Oublier de masquer les flags de taille

```python
# MAUVAIS
size = struct.unpack('<Q', data[offset+8:offset+16])[0]
next_offset = offset + size  # FAUX! Inclut les flags

# BON
size_field = struct.unpack('<Q', data[offset+8:offset+16])[0]
real_size = size_field & ~0x7  # Masquer P, M, A
next_offset = offset + real_size
```

#### Piege 2 : Confusion entre fd et user data

```python
# Un chunk allocated n'a pas de fd/bk!
if chunk['state'] == 'allocated':
    # fd et bk sont en fait des user data
    pass
elif chunk['state'] == 'free':
    fd = read_qword(data, offset + 16)  # Seulement si free
```

### 5.5 Cours Complet

#### 5.5.1 ptmalloc2 en profondeur

ptmalloc2 utilise plusieurs strategies pour optimiser les allocations :

**Arenas :**
- Une arena principale + arenas secondaires pour le multi-threading
- Chaque arena a ses propres bins et mutex
- Reduit la contention entre threads

**Chunks :**
- Taille minimum : 0x20 (32 bytes sur 64-bit)
- Alignement : 16 bytes (0x10)
- Les flags utilisent les 3 bits de poids faible (toujours 0 pour alignement)

#### 5.5.2 Evolution des protections

| Version | Protection | Impact |
|---------|-----------|--------|
| 2.26 | tcache | Per-thread cache, plus de fastbin attacks directs |
| 2.29 | tcache key | Detection double-free dans tcache |
| 2.32 | Safe-linking | fd XOR (addr >> 12), bypass heap overflow |
| 2.34 | tcache count checks | Limite les tcache poisoning |

### 5.6 Normes avec explications pedagogiques

```
┌─────────────────────────────────────────────────────────────────┐
│ ❌ HORS NORME (fonctionne, mais interdit)                       │
├─────────────────────────────────────────────────────────────────┤
│ from pwn import *  # Import de pwntools                         │
│ heap = pwnlib.heap.parse(data)  # Utilisation de lib externe   │
├─────────────────────────────────────────────────────────────────┤
│ ✅ CONFORME                                                     │
├─────────────────────────────────────────────────────────────────┤
│ import struct                                                    │
│ def parse_chunk(data, offset):                                  │
│     size = struct.unpack('<Q', data[offset+8:offset+16])[0]    │
│     real_size = size & ~0x7                                     │
├─────────────────────────────────────────────────────────────────┤
│ POURQUOI ?                                                      │
│                                                                 │
│ - Comprehension : Implementation manuelle force l'apprentissage │
│ - Portabilite : Pas de dependance externe                       │
│ - Flexibilite : Adaptation a differentes versions glibc         │
└─────────────────────────────────────────────────────────────────┘
```

### 5.7 Simulation avec trace d'execution

**Entree :** `{"heap_base": "0x555555559000", "heap_dump": "0000000000000000 2100000000000000 41414141..."}`

```
┌───────┬──────────────────────────────────┬───────────────────────┬──────────────────────────┐
│ Etape │ Instruction                      │ Variables             │ Explication              │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   1   │ LIRE heap_base                   │ 0x555555559000        │ Base du heap             │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   2   │ CONVERTIR hex_dump en bytes      │ b'\x00\x00...'        │ Donnees binaires         │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   3   │ LIRE prev_size a offset 0        │ 0                     │ Chunk precedent utilise  │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   4   │ LIRE size_field a offset 8       │ 0x21                  │ size=0x20, P=1           │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   5   │ MASQUER flags                    │ real_size = 0x20      │ 0x21 & ~0x7 = 0x20       │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   6   │ EXTRAIRE flags                   │ P=1, M=0, A=0         │ Prev in use              │
├───────┼──────────────────────────────────┼───────────────────────┼──────────────────────────┤
│   7   │ AJOUTER chunk a liste            │ chunks = [...]        │ Premier chunk parse      │
└───────┴──────────────────────────────────┴───────────────────────┴──────────────────────────┘
```

### 5.8 Mnemotechniques

#### MEME : "Inception" - Les niveaux de bins

Comme les niveaux de reves dans Inception :
- **Tcache** = Niveau 1 (le plus rapide, juste sous la surface)
- **Fastbins** = Niveau 2 (rapide mais un peu plus profond)
- **Unsorted** = Limbo (zone de transition)
- **Small/Large bins** = Niveau 3+ (le plus profond, le plus lent)

#### MEME : "Les flags comme des feux de circulation"

- **P (PREV_INUSE)** = Feu vert : "Le chunk precedent est utilise, pas de consolidation"
- **M (IS_MMAPPED)** = Feu bleu : "Je suis special, alloue via mmap()"
- **A (NON_MAIN_ARENA)** = Feu orange : "Je viens d'une autre arena"

### 5.9 Applications pratiques

1. **Developpement d'exploits** : Comprendre le layout pour heap feng shui
2. **Forensics** : Analyser des dumps memoire post-mortem
3. **Fuzzing** : Detecter les corruptions heap automatiquement
4. **Debugging** : Comprendre pourquoi malloc/free crash

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Ne pas masquer les flags | Taille incorrecte, offset faux | size & ~0x7 |
| 2 | Mauvais endianness | Valeurs completement fausses | struct.unpack('<Q', ...) |
| 3 | Ignorer les chunks free | Analyse incomplete | Verifier fd/bk pour detection |
| 4 | Buffer overflow | Crash sur dumps partiels | Verifier bounds avant read |
| 5 | Oublier safe-linking | Pointeurs faux sur glibc 2.32+ | XOR decode |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la taille minimum d'un chunk malloc sur x86-64 ?**

A) 8 bytes
B) 16 bytes
C) 24 bytes
D) 32 bytes
E) 64 bytes
F) 0x10 bytes
G) 0x18 bytes
H) 0x30 bytes
I) Depend de l'allocation
J) Variable

**Reponse : D (32 bytes = 0x20)**

---

### Question 2
**Que signifie le flag P (PREV_INUSE) dans le champ size d'un chunk ?**

A) Le chunk courant est utilise
B) Le chunk precedent est utilise (pas free)
C) Le chunk est protege
D) Le chunk est dans une arena privee
E) Le chunk a ete mmap()
F) Le chunk est dans le tcache
G) Le chunk est aligne
H) Le chunk est le top chunk
I) Le chunk precedent est free
J) Aucune signification

**Reponse : B**

---

### Question 3
**Dans quelle version de glibc le tcache a-t-il ete introduit ?**

A) 2.20
B) 2.23
C) 2.26
D) 2.29
E) 2.31
F) 2.32
G) 2.35
H) 2.17
I) 2.19
J) Toujours present

**Reponse : C (glibc 2.26)**

---

### Question 4
**Quelle est la formule de safe-linking (glibc 2.32+) ?**

A) fd = fd XOR heap_base
B) fd = fd XOR (addr >> 12)
C) fd = fd + heap_base
D) fd = fd XOR 0xdeadbeef
E) fd = fd ROL 12
F) fd = ~fd
G) fd = fd XOR key
H) fd = fd >> 12
I) fd = fd & 0xfff
J) Pas de formule

**Reponse : B**

---

### Question 5
**Quel bin est utilise pour les chunks de taille <= 0x80 ?**

A) Tcache uniquement
B) Fastbins
C) Small bins
D) Large bins
E) Unsorted bin
F) Top chunk
G) Tcache puis fastbins
H) Aucun bin
I) Depend de la version
J) Main arena

**Reponse : G (Tcache en priorite, puis fastbins)**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | ★★★★★★★★☆☆ (8/10) |
| **Temps estime** | 90 min |
| **XP Base** | 300 |
| **XP Bonus** | x2 (600 total) |
| **Concepts cles** | Chunks, Bins, Flags, Tcache, Safe-linking |
| **Langage** | Python 3.12 |
| **Prerequis** | Gestion memoire, Hexadecimal, Structures |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.7-a-heap-anatomy",
    "generated_at": "2026-01-16 15:00:00",

    "metadata": {
      "exercise_id": "3.4.7-a",
      "exercise_name": "heap_anatomy",
      "module": "3.4.7",
      "module_name": "Heap Exploitation",
      "concept": "a",
      "concept_name": "Structure interne du heap glibc",
      "type": "code",
      "tier": 2,
      "tier_info": "Concept composite",
      "phase": 3,
      "difficulty": 8,
      "difficulty_stars": "★★★★★★★★☆☆",
      "language": "python",
      "duration_minutes": 90,
      "xp_base": 300,
      "xp_bonus_multiplier": 2,
      "bonus_tier": "STANDARD",
      "bonus_icon": "⚡",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["Gestion memoire", "Hexadecimal", "Exploitation binaire"],
      "domains": ["Heap", "Mem", "Exploit"],
      "domains_bonus": ["Forensics"],
      "tags": ["heap", "glibc", "ptmalloc2", "chunks", "bins"],
      "meme_reference": "Inception - Les niveaux de reves"
    },

    "files": {
      "spec.json": "/* Section 4.8 */",
      "references/ref_solution.py": "/* Section 4.3 */",
      "references/ref_solution_bonus.py": "/* Section 4.6 */",
      "mutants/mutant_a_boundary.py": "/* Section 4.9 */",
      "mutants/mutant_b_logic.py": "/* Section 4.9 */",
      "mutants/mutant_c_safety.py": "/* Section 4.9 */",
      "mutants/mutant_d_parse.py": "/* Section 4.9 */",
      "mutants/mutant_e_return.py": "/* Section 4.9 */"
    }
  }
}
```
