# Exercice 3.4.6-a : rop_builder

**Module :**
3.4.6 — ROP Advanced Techniques

**Concept :**
a — Construction de chaines ROP (Gadget Finding, Chain Building)

**Difficulte :**
★★★★★★★★☆☆ (8/10)

**Type :**
code

**Tiers :**
2 — Concepts multiples integres

**Langage :**
Python 3.12

**Prerequis :**
- Comprehension de l'architecture x86-64
- Maitrise des stack buffer overflows
- Bases des conventions d'appel (SysV ABI)
- Notions de shellcode et NX bypass

**Domaines :**
Exploit, ASM, ROP

**Duree estimee :**
90 min

**XP Base :**
300

**Complexite :**
T4 O(n*m) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`rop_builder.py`

**Fonctions autorisees :**
- `struct` (packing/unpacking)
- `json` (entree/sortie)
- `re` (expressions regulieres)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- `pwntools` (implementation manuelle requise)
- `ropper`, `ROPgadget` (recherche manuelle)
- Bibliotheques binaires (capstone, keystone)

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "Inception"

*"You mustn't be afraid to dream a little bigger, darling."*

Dans **Inception**, Cobb et son equipe construisent des reves a l'interieur de reves, empilant des niveaux de realite pour atteindre leur objectif. Le Return-Oriented Programming (ROP) est exactement cela : empiler des fragments de code existant (gadgets) pour construire un programme entierement nouveau.

Chaque gadget est comme un niveau de reve : il execute quelques instructions puis "remonte" (RET) au niveau suivant. En enchainant ces gadgets avec precision, tu peux faire executer n'importe quoi au processeur, meme si NX/DEP empeche l'execution de nouveau code.

Comme les architectes de reves, tu vas devenir un architecte de chaines ROP.

#### 2.4.2 Enonce Academique

Le Return-Oriented Programming est une technique d'exploitation qui contourne les protections NX/DEP en reutilisant des sequences d'instructions existantes dans le binaire, appelees "gadgets". Chaque gadget se termine par une instruction `ret` qui transfere le controle au gadget suivant.

**Ta mission :**

Ecrire un programme `rop_builder.py` qui :

1. **Recherche** des gadgets dans une representation binaire
2. **Categorise** les gadgets par fonction (load, store, arithmetic, etc.)
3. **Construit** une chaine ROP pour appeler `mprotect()`
4. **Optimise** la chaine (nombre minimal de gadgets)

**Entree :**
- Fichier JSON contenant :
  - `gadgets` : liste de gadgets avec adresse et instructions
  - `objective` : fonction a appeler ("mprotect", "execve", "system")
  - `args` : arguments pour la fonction
  - `constraints` : contraintes (bad chars, taille max)

**Sortie :**
- JSON avec la chaine ROP, le layout stack, et les metadonnees

**Contraintes :**
- Les gadgets doivent se terminer par `ret`
- Respecter la convention SysV AMD64 (RDI, RSI, RDX, RCX, R8, R9)
- Gerer l'alignement stack (16 bytes avant call)
- Filtrer les bad characters dans les adresses

**Gadgets essentiels a connaitre :**
| Gadget | Utilite |
|--------|---------|
| `pop rdi; ret` | Charger 1er argument |
| `pop rsi; ret` | Charger 2eme argument |
| `pop rdx; ret` | Charger 3eme argument |
| `ret` | NOP ROP (alignement) |
| `leave; ret` | Stack pivot |
| `syscall; ret` | Appel systeme |

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"gadgets": [...], "objective": "mprotect", "args": {"addr": "0x400000", "len": "0x1000", "prot": 7}}` | `{"rop_chain": [...], "total_size": 48, "stack_layout": [...]}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
rop_builder.py - Constructeur de chaines ROP
"""

import json
import struct
import sys
import re

def pack64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    pass

def categorize_gadgets(gadgets: list) -> dict:
    """
    Categorise les gadgets par fonction.

    Returns:
        Dictionnaire avec categories: pop_rdi, pop_rsi, pop_rdx, etc.
    """
    pass

def find_gadget(gadgets: dict, category: str, constraints: dict = None) -> dict:
    """
    Trouve le meilleur gadget pour une categorie donnee.

    Args:
        gadgets: Gadgets categorises
        category: Categorie recherchee
        constraints: Contraintes (bad_chars, etc.)

    Returns:
        Gadget trouve ou None
    """
    pass

def build_rop_chain(gadgets: dict, objective: str, args: dict) -> list:
    """
    Construit une chaine ROP pour l'objectif specifie.

    Args:
        gadgets: Gadgets categorises
        objective: "mprotect", "execve", etc.
        args: Arguments de la fonction

    Returns:
        Liste de tuples (adresse, description)
    """
    pass

def optimize_chain(chain: list) -> list:
    """
    Optimise la chaine ROP (supprime les gadgets redondants).
    """
    pass

def create_rop_payload(data: dict) -> dict:
    """
    Cree le payload ROP complet.

    Args:
        data: Donnees d'entree

    Returns:
        Dictionnaire avec rop_chain, stack_layout, payload_bytes
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'invention du ROP

Le Return-Oriented Programming a ete formalise en 2007 par Hovav Shacham dans son papier seminal "The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)".

Avant ROP, les attaquants utilisaient "return-into-libc" qui appelait des fonctions entieres. ROP a generalise cette idee en permettant d'utiliser n'importe quelle sequence d'instructions terminee par `ret`.

### Pourquoi ROP fonctionne meme avec NX ?

NX (No-eXecute) empeche l'execution de code dans les zones de donnees (stack, heap). Mais ROP n'injecte pas de nouveau code ! Il reutilise du code existant (deja marque executable) de maniere creative.

C'est comme si on t'interdisait d'ecrire de nouveaux mots, mais qu'on te laissait decouper des mots dans des journaux pour faire une lettre de rancon.

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Exploit Developer / Red Team Operator**

Les developpeurs d'exploits utilisent ROP quotidiennement :

**Cas d'usage concret - Exploitation de navigateur :**
1. Trouver une vulnerabilite dans le moteur JavaScript
2. Obtenir une primitive read/write arbitraire
3. Construire une chaine ROP pour appeler `mprotect()` et rendre une page RWX
4. Executer un shellcode pour obtenir un reverse shell

**Cas d'usage concret - CTF Pwn Challenges :**
La majorite des challenges pwn modernes requierent ROP car les binaires ont NX active. Les meilleurs joueurs connaissent par coeur les gadgets courants.

**Outils professionnels :** ROPgadget, ropper, pwntools ROP(), angr

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
rop_builder.py  gadgets.json

$ cat gadgets.json
{
  "gadgets": [
    {"addr": "0x401234", "insn": "pop rdi; ret"},
    {"addr": "0x401238", "insn": "pop rsi; pop r15; ret"},
    {"addr": "0x401240", "insn": "pop rdx; ret"},
    {"addr": "0x401250", "insn": "ret"},
    {"addr": "0x401260", "insn": "syscall; ret"}
  ],
  "objective": "mprotect",
  "args": {
    "addr": "0x7fff0000",
    "len": "0x1000",
    "prot": 7
  },
  "constraints": {
    "bad_chars": ["0x00", "0x0a"],
    "max_size": 256
  }
}

$ python3 rop_builder.py gadgets.json
{
  "rop_chain": [
    {"addr": "0x401234", "value": null, "purpose": "pop rdi; ret"},
    {"addr": "0x7fff0000", "value": null, "purpose": "arg0: addr"},
    {"addr": "0x401238", "value": null, "purpose": "pop rsi; pop r15; ret"},
    {"addr": "0x1000", "value": null, "purpose": "arg1: len"},
    {"addr": "0x0", "value": null, "purpose": "junk for r15"},
    {"addr": "0x401240", "value": null, "purpose": "pop rdx; ret"},
    {"addr": "0x7", "value": null, "purpose": "arg2: prot (RWX)"},
    {"addr": "0x401260", "value": null, "purpose": "syscall; ret"}
  ],
  "total_size": 64,
  "gadget_count": 8,
  "stack_layout": "See visualization",
  "has_bad_chars": false,
  "payload_hex": "3412400000000000..."
}

$ python3 rop_builder.py gadgets.json --visualize
Stack Layout (low to high):
+------------------+
| 0x401234         | <- pop rdi; ret
+------------------+
| 0x7fff0000       | <- RDI value (addr)
+------------------+
| 0x401238         | <- pop rsi; pop r15; ret
+------------------+
| 0x1000           | <- RSI value (len)
+------------------+
| 0x0              | <- R15 junk
+------------------+
| 0x401240         | <- pop rdx; ret
+------------------+
| 0x7              | <- RDX value (prot)
+------------------+
| 0x401260         | <- syscall; ret
+------------------+
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★☆ (9/10)

**Recompense :**
XP x2

**Time Complexity attendue :**
O(n*m)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
Exploit, Optim, ROP

### 3.1.1 Consigne Bonus

**Extension "Smart ROP Builder" :**

Etendre le programme pour :

1. **Generer** automatiquement des gadgets manquants via combinaison
2. **Detecter** les contraintes d'alignement et ajouter des "ret" si necessaire
3. **Supporter** les objectifs chains (mprotect puis execve)
4. **Calculer** la complexite de la chaine (nombre d'operations)

**Contraintes supplementaires :**
```
+-----------------------------------------------+
|  Auto-alignment: RSP % 16 == 0 avant syscall  |
|  Gadget synthesis: combiner gadgets simples   |
|  Chain objectives: [mprotect, write_shellcode,|
|                     jump_to_shellcode]        |
|  Complexity score: operations / gadgets       |
+-----------------------------------------------+
```

### 3.1.2 Prototype Bonus

```python
def synthesize_gadget(gadgets: dict, target: str) -> list:
    """
    Synthetise un gadget manquant en combinant d'autres gadgets.

    Ex: pop rdx manquant -> utiliser mov rdx, rax + pop rax
    """
    pass

def ensure_alignment(chain: list, gadgets: dict) -> list:
    """
    Ajoute des gadgets 'ret' pour assurer l'alignement 16 bytes.
    """
    pass

def build_multi_stage_chain(gadgets: dict, stages: list) -> list:
    """
    Construit une chaine multi-etapes.
    """
    pass
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Gadgets | Utilise ceux fournis | Synthetise si manquants |
| Alignement | Manuel | Automatique |
| Objectif | Un seul | Multi-etapes |
| Optimisation | Basique | Score de complexite |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| basic_categorize | Liste gadgets | Categories correctes | 10 |
| mprotect_chain | objective=mprotect | Chain complete | 15 |
| execve_chain | objective=execve | Chain avec /bin/sh | 15 |
| bad_chars_filter | bad_chars=[0x00] | Gadgets filtres | 10 |
| alignment_check | Chain desalignee | Ajout de ret | 10 |
| missing_gadget | pop rdx manquant | Erreur ou synthese | 10 |
| optimize_chain | Chain avec redondances | Chain optimisee | 10 |
| stack_layout | Toute chaine | Layout correct | 10 |
| payload_hex | Toute chaine | Bytes corrects | 10 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
rop_builder.py - Solution de reference
"""

import json
import struct
import sys
import re

def pack64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    return struct.pack('<Q', value)

def parse_hex(value) -> int:
    """Parse une valeur hexadecimale ou entiere."""
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    try:
        return int(value, 16)
    except ValueError:
        return int(value)

def has_bad_chars(addr: int, bad_chars: list) -> bool:
    """Verifie si une adresse contient des bad chars."""
    addr_bytes = pack64(addr)
    for bc in bad_chars:
        bc_byte = parse_hex(bc) if isinstance(bc, str) else bc
        if bc_byte in addr_bytes:
            return True
    return False

def categorize_gadgets(gadgets: list) -> dict:
    """Categorise les gadgets par fonction."""
    categories = {
        'pop_rdi': [],
        'pop_rsi': [],
        'pop_rdx': [],
        'pop_rcx': [],
        'pop_r8': [],
        'pop_r9': [],
        'pop_rax': [],
        'ret': [],
        'syscall': [],
        'call_rax': [],
        'leave_ret': [],
        'mov': [],
        'xchg': []
    }

    for g in gadgets:
        addr = parse_hex(g['addr'])
        insn = g['insn'].lower().strip()

        # Detecter les pop
        if 'pop rdi' in insn and 'ret' in insn:
            categories['pop_rdi'].append({'addr': addr, 'insn': g['insn'],
                                          'pops': insn.count('pop')})
        if 'pop rsi' in insn and 'ret' in insn:
            categories['pop_rsi'].append({'addr': addr, 'insn': g['insn'],
                                          'pops': insn.count('pop')})
        if 'pop rdx' in insn and 'ret' in insn:
            categories['pop_rdx'].append({'addr': addr, 'insn': g['insn'],
                                          'pops': insn.count('pop')})
        if 'pop rcx' in insn and 'ret' in insn:
            categories['pop_rcx'].append({'addr': addr, 'insn': g['insn'],
                                          'pops': insn.count('pop')})
        if 'pop rax' in insn and 'ret' in insn:
            categories['pop_rax'].append({'addr': addr, 'insn': g['insn'],
                                          'pops': insn.count('pop')})

        # Detecter ret seul
        if insn == 'ret':
            categories['ret'].append({'addr': addr, 'insn': g['insn']})

        # Detecter syscall
        if 'syscall' in insn:
            categories['syscall'].append({'addr': addr, 'insn': g['insn']})

        # Detecter leave; ret
        if 'leave' in insn and 'ret' in insn:
            categories['leave_ret'].append({'addr': addr, 'insn': g['insn']})

    return categories

def find_gadget(gadgets: dict, category: str, constraints: dict = None) -> dict:
    """Trouve le meilleur gadget pour une categorie."""
    if category not in gadgets or not gadgets[category]:
        return None

    candidates = gadgets[category]

    # Filtrer par bad chars si contraintes
    if constraints and 'bad_chars' in constraints:
        candidates = [g for g in candidates
                     if not has_bad_chars(g['addr'], constraints['bad_chars'])]

    if not candidates:
        return None

    # Preferer les gadgets avec moins de pops (plus simples)
    if 'pops' in candidates[0]:
        candidates.sort(key=lambda x: x.get('pops', 1))

    return candidates[0]

def build_rop_chain(gadgets: dict, objective: str, args: dict,
                    constraints: dict = None) -> list:
    """Construit une chaine ROP pour l'objectif specifie."""
    chain = []

    if objective == "mprotect":
        # mprotect(addr, len, prot)
        # RDI = addr, RSI = len, RDX = prot
        # syscall number in RAX = 10

        addr = parse_hex(args.get('addr', 0))
        length = parse_hex(args.get('len', 0x1000))
        prot = parse_hex(args.get('prot', 7))

        # pop rdi; ret -> addr
        g = find_gadget(gadgets, 'pop_rdi', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': hex(addr), 'purpose': 'arg0: addr'})
            # Ajouter junk pour les pops supplementaires
            for _ in range(g.get('pops', 1) - 1):
                chain.append({'addr': '0x0', 'purpose': 'junk'})

        # pop rsi; ret -> len
        g = find_gadget(gadgets, 'pop_rsi', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': hex(length), 'purpose': 'arg1: len'})
            for _ in range(g.get('pops', 1) - 1):
                chain.append({'addr': '0x0', 'purpose': 'junk'})

        # pop rdx; ret -> prot
        g = find_gadget(gadgets, 'pop_rdx', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': hex(prot), 'purpose': 'arg2: prot (RWX)'})
            for _ in range(g.get('pops', 1) - 1):
                chain.append({'addr': '0x0', 'purpose': 'junk'})

        # pop rax; ret -> 10 (mprotect syscall)
        g = find_gadget(gadgets, 'pop_rax', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': '0xa', 'purpose': 'syscall number: mprotect'})

        # syscall
        g = find_gadget(gadgets, 'syscall', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})

    elif objective == "execve":
        # execve("/bin/sh", NULL, NULL)
        # RDI = addr of "/bin/sh", RSI = NULL, RDX = NULL
        # syscall number in RAX = 59

        binsh_addr = parse_hex(args.get('binsh_addr', 0))

        # pop rdi; ret -> binsh_addr
        g = find_gadget(gadgets, 'pop_rdi', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': hex(binsh_addr), 'purpose': 'arg0: /bin/sh addr'})
            for _ in range(g.get('pops', 1) - 1):
                chain.append({'addr': '0x0', 'purpose': 'junk'})

        # pop rsi; ret -> NULL
        g = find_gadget(gadgets, 'pop_rsi', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': '0x0', 'purpose': 'arg1: NULL (argv)'})
            for _ in range(g.get('pops', 1) - 1):
                chain.append({'addr': '0x0', 'purpose': 'junk'})

        # pop rdx; ret -> NULL
        g = find_gadget(gadgets, 'pop_rdx', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': '0x0', 'purpose': 'arg2: NULL (envp)'})

        # pop rax; ret -> 59 (execve syscall)
        g = find_gadget(gadgets, 'pop_rax', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})
            chain.append({'addr': '0x3b', 'purpose': 'syscall number: execve'})

        # syscall
        g = find_gadget(gadgets, 'syscall', constraints)
        if g:
            chain.append({'addr': hex(g['addr']), 'purpose': g['insn']})

    return chain

def optimize_chain(chain: list) -> list:
    """Optimise la chaine ROP."""
    # Supprimer les ret consecutifs inutiles
    optimized = []
    for i, item in enumerate(chain):
        if item['purpose'] == 'ret':
            if i > 0 and optimized and optimized[-1]['purpose'] == 'ret':
                continue  # Skip double ret
        optimized.append(item)
    return optimized

def create_rop_payload(data: dict) -> dict:
    """Cree le payload ROP complet."""
    gadgets_raw = data.get('gadgets', [])
    objective = data.get('objective', 'mprotect')
    args = data.get('args', {})
    constraints = data.get('constraints', {})

    # Categoriser les gadgets
    gadgets = categorize_gadgets(gadgets_raw)

    # Construire la chaine
    chain = build_rop_chain(gadgets, objective, args, constraints)

    # Optimiser
    chain = optimize_chain(chain)

    # Generer le payload bytes
    payload = b''
    for item in chain:
        addr = parse_hex(item['addr'])
        payload += pack64(addr)

    # Verifier les bad chars dans le payload final
    has_bad = False
    if 'bad_chars' in constraints:
        for bc in constraints['bad_chars']:
            bc_byte = parse_hex(bc) if isinstance(bc, str) else bc
            if bc_byte in payload:
                has_bad = True
                break

    return {
        'rop_chain': chain,
        'total_size': len(payload),
        'gadget_count': len(chain),
        'has_bad_chars': has_bad,
        'payload_hex': payload.hex(),
        'gadgets_available': {k: len(v) for k, v in gadgets.items()},
        'objective': objective
    }

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: rop_builder.py <input.json> [--visualize]", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    visualize = '--visualize' in sys.argv

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = create_rop_payload(data)

    if visualize:
        print("Stack Layout (low to high):")
        print("+------------------+")
        for item in result['rop_chain']:
            print(f"| {item['addr']:<16} | <- {item['purpose']}")
            print("+------------------+")
    else:
        print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptees

```python
# Alternative 1: Utilisation de dataclasses pour les gadgets
from dataclasses import dataclass

@dataclass
class Gadget:
    addr: int
    insn: str
    pops: int = 1

    def to_dict(self):
        return {'addr': hex(self.addr), 'insn': self.insn}
```

```python
# Alternative 2: Regex compile pour categorisation
GADGET_PATTERNS = {
    'pop_rdi': re.compile(r'pop\s+rdi.*ret', re.I),
    'pop_rsi': re.compile(r'pop\s+rsi.*ret', re.I),
    'syscall': re.compile(r'syscall', re.I),
}
```

### 4.5 Solutions refusees (avec explications)

```python
# REFUSE: Utilise pwntools
from pwn import ROP, ELF

def build_chain(binary_path):
    elf = ELF(binary_path)
    rop = ROP(elf)
    rop.mprotect(addr, size, 7)
    return rop.chain()

# Pourquoi c'est faux: L'exercice demande une implementation manuelle
```

```python
# REFUSE: Ne gere pas les pops multiples
def build_chain_bad(gadgets, objective, args):
    chain = []
    # Utilise pop rsi; pop r15; ret sans ajouter de junk pour r15
    chain.append(gadgets['pop_rsi'][0])
    chain.append(args['len'])
    # Manque le junk pour r15!

# Pourquoi c'est faux: pop rsi; pop r15; ret pop DEUX valeurs
```

### 4.6 Solution bonus de reference

```python
#!/usr/bin/env python3
"""
rop_builder.py - Solution bonus avec synthese de gadgets
"""

# ... (fonctions de base) ...

def synthesize_gadget(gadgets: dict, target: str) -> list:
    """Synthetise un gadget manquant."""

    if target == 'pop_rdx':
        # Si pop rdx manquant, essayer: pop rax; ret + mov rdx, rax; ret
        if gadgets['pop_rax'] and any('mov rdx, rax' in g['insn'].lower()
                                       for cat in gadgets.values() for g in cat):
            return [
                {'type': 'gadget', 'purpose': 'pop rax for rdx'},
                {'type': 'value', 'purpose': 'value for rdx'},
                {'type': 'gadget', 'purpose': 'mov rdx, rax'}
            ]

    return None  # Synthese impossible

def ensure_alignment(chain: list, gadgets: dict) -> list:
    """Ajoute des ret pour aligner a 16 bytes."""
    # Compter les items (chaque item = 8 bytes)
    size = len(chain) * 8

    # Avant un syscall/call, RSP doit etre aligne sur 16
    if size % 16 != 0:
        ret_gadget = find_gadget(gadgets, 'ret')
        if ret_gadget:
            # Inserer un ret avant le syscall
            for i, item in enumerate(chain):
                if 'syscall' in item.get('purpose', ''):
                    chain.insert(i, {'addr': hex(ret_gadget['addr']),
                                    'purpose': 'alignment ret'})
                    break

    return chain

def build_multi_stage_chain(gadgets: dict, stages: list) -> list:
    """Construit une chaine multi-etapes."""
    full_chain = []

    for stage in stages:
        objective = stage['objective']
        args = stage.get('args', {})

        stage_chain = build_rop_chain(gadgets, objective, args)
        full_chain.extend(stage_chain)

    return full_chain
```

### 4.7 Solutions alternatives bonus

```python
# Alternative: Score de complexite
def calculate_complexity_score(chain: list) -> float:
    """Calcule un score de complexite."""
    gadget_count = len([c for c in chain if 'ret' in c.get('purpose', '')])
    value_count = len(chain) - gadget_count

    return gadget_count / max(value_count, 1)
```

### 4.8 Solutions refusees bonus

```python
# REFUSE: Alignement incorrect
def ensure_alignment_bad(chain, gadgets):
    # Ajoute des ret sans verifier la position
    while len(chain) % 2 != 0:
        chain.append({'addr': '0x0', 'purpose': 'padding'})
    return chain

# Pourquoi c'est faux: 0x0 n'est pas un gadget valide
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "rop_builder",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 2,
  "tags": ["rop", "exploitation", "x86-64", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "create_rop_payload",
    "prototype": "def create_rop_payload(data: dict) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "data", "type": "dict"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "basic_mprotect",
        "args": [{"gadgets": [{"addr": "0x401234", "insn": "pop rdi; ret"}], "objective": "mprotect", "args": {"addr": "0x1000"}}],
        "expected_contains": ["rop_chain", "payload_hex"]
      },
      {
        "name": "bad_chars",
        "args": [{"gadgets": [{"addr": "0x401200", "insn": "pop rdi; ret"}, {"addr": "0x401234", "insn": "pop rdi; ret"}], "objective": "mprotect", "args": {}, "constraints": {"bad_chars": ["0x00"]}}],
        "is_trap": true,
        "trap_explanation": "Gadget a 0x401200 contient 0x00"
      }
    ]
  },

  "norm": {
    "allowed_functions": ["struct", "json", "re", "sys"],
    "forbidden_functions": ["pwn", "pwntools", "ropper", "ropgadget"],
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A (Order) : Mauvais ordre des arguments
def build_chain_mutant_a(gadgets, objective, args):
    # Met RSI avant RDI
    chain = []
    chain.extend(set_rsi(args['len']))  # Devrait etre apres RDI!
    chain.extend(set_rdi(args['addr']))
    return chain

# Pourquoi c'est faux: L'ordre SysV est RDI, RSI, RDX
```

```python
# Mutant B (Pops) : Ignore les pops multiples
def process_gadget_mutant_b(gadget, value):
    # pop rsi; pop r15; ret
    return [gadget['addr'], value]  # Manque le junk pour r15!

# Pourquoi c'est faux: pop r15 va lire la prochaine valeur
```

```python
# Mutant C (Endian) : Mauvais endianness
def pack64_mutant_c(value):
    return struct.pack('>Q', value)  # Big-endian!

# Pourquoi c'est faux: x86-64 est little-endian
```

```python
# Mutant D (Syscall) : Oublie le numero de syscall
def build_mprotect_mutant_d(gadgets, args):
    chain = []
    chain.extend(set_rdi(args['addr']))
    chain.extend(set_rsi(args['len']))
    chain.extend(set_rdx(args['prot']))
    # Manque: set RAX = 10!
    chain.append(gadgets['syscall'])
    return chain

# Pourquoi c'est faux: syscall lit le numero dans RAX
```

```python
# Mutant E (Filter) : Ne filtre pas les bad chars
def find_gadget_mutant_e(gadgets, category, constraints):
    return gadgets[category][0]  # Ignore constraints!

# Pourquoi c'est faux: Le payload peut contenir des null bytes
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne le **Return-Oriented Programming (ROP)** :

1. **Concept de gadget** : Sequence d'instructions terminee par `ret`
2. **Categorisation** : Classer les gadgets par fonction
3. **Chain building** : Assembler les gadgets pour un objectif
4. **Contraintes** : Bad chars, alignement, pops multiples

### 5.2 LDA - Traduction litterale en francais (MAJUSCULES)

```
FONCTION build_rop_chain QUI RETOURNE UNE LISTE ET PREND EN PARAMETRES gadgets, objective, args
DEBUT FONCTION
    DECLARER chain COMME LISTE VIDE

    SI objective EST EGAL A "mprotect" ALORS
        DECLARER addr, len, prot DEPUIS args

        TROUVER gadget_rdi DANS gadgets['pop_rdi']
        SI gadget_rdi EXISTE ALORS
            AJOUTER gadget_rdi.addr A chain
            AJOUTER addr A chain
            POUR i DE 1 A gadget_rdi.pops - 1 FAIRE
                AJOUTER 0 (junk) A chain
            FIN POUR
        FIN SI

        TROUVER gadget_rsi DANS gadgets['pop_rsi']
        SI gadget_rsi EXISTE ALORS
            AJOUTER gadget_rsi.addr A chain
            AJOUTER len A chain
            AJOUTER junk SI pops > 1
        FIN SI

        TROUVER gadget_rdx DANS gadgets['pop_rdx']
        SI gadget_rdx EXISTE ALORS
            AJOUTER gadget_rdx.addr A chain
            AJOUTER prot A chain
        FIN SI

        TROUVER gadget_syscall DANS gadgets['syscall']
        AJOUTER gadget_syscall.addr A chain
    FIN SI

    RETOURNER chain
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Construction de chaine ROP
---
1. PARSER l'entree JSON
   a. EXTRAIRE la liste des gadgets
   b. EXTRAIRE l'objectif (mprotect, execve)
   c. EXTRAIRE les arguments
   d. EXTRAIRE les contraintes

2. CATEGORISER les gadgets :
   a. POUR CHAQUE gadget :
      - ANALYSER l'instruction
      - CLASSIFIER par type (pop_rdi, pop_rsi, etc.)
      - COMPTER les pops

3. CONSTRUIRE la chaine :
   a. POUR CHAQUE argument requis :
      - TROUVER le gadget appropriate
      - VERIFIER les bad chars
      - AJOUTER gadget + valeur + junk
   b. AJOUTER le gadget final (syscall)

4. OPTIMISER la chaine :
   a. SUPPRIMER les ret consecutifs inutiles
   b. VERIFIER l'alignement

5. GENERER le payload bytes
```

### 5.3 Visualisation ASCII

```
                    ROP CHAIN CONCEPT
    +--------------------------------------------------+
    |                                                  |
    |   Stack normale:         Stack avec ROP:         |
    |   +--------------+       +--------------+        |
    |   | local vars   |       | gadget1 addr | <-RSP  |
    |   | saved RBP    |       | value1       |        |
    |   | return addr  | <-RSP | gadget2 addr |        |
    |   +--------------+       | value2       |        |
    |                          | gadget3 addr |        |
    |                          | ...          |        |
    |                          +--------------+        |
    |                                                  |
    +--------------------------------------------------+

              EXECUTION D'UN GADGET
    +--------------------------------------------------+
    |                                                  |
    |   gadget: pop rdi; ret                           |
    |                                                  |
    |   1. RET pop l'adresse du gadget dans RIP       |
    |   2. pop rdi lit la valeur suivante dans RDI    |
    |   3. ret pop l'adresse du gadget suivant        |
    |                                                  |
    |   Stack avant:     Stack apres pop rdi:          |
    |   +---------+      +---------+                   |
    |   | gadget1 | RSP->| value   | RSP->+--------+  |
    |   | value   |      | gadget2 |      |gadget2 |  |
    |   | gadget2 |      +---------+      +--------+  |
    |   +---------+                                    |
    |                                                  |
    +--------------------------------------------------+

              EXEMPLE COMPLET: mprotect(0x400000, 0x1000, 7)
    +--------------------------------------------------+
    |                                                  |
    |   RDI = addr (0x400000)                          |
    |   RSI = len (0x1000)                             |
    |   RDX = prot (7 = RWX)                           |
    |   RAX = 10 (mprotect syscall)                    |
    |                                                  |
    |   Stack layout:                                  |
    |   +------------------+                           |
    |   | pop rdi; ret     | -> charge RDI             |
    |   | 0x400000         | -> valeur pour RDI        |
    |   | pop rsi;pop r15  | -> charge RSI             |
    |   | 0x1000           | -> valeur pour RSI        |
    |   | 0x0 (junk)       | -> junk pour r15          |
    |   | pop rdx; ret     | -> charge RDX             |
    |   | 0x7              | -> valeur pour RDX        |
    |   | pop rax; ret     | -> charge RAX             |
    |   | 0xa              | -> syscall number         |
    |   | syscall; ret     | -> execute mprotect       |
    |   +------------------+                           |
    |                                                  |
    +--------------------------------------------------+
```

### 5.4 Les pieges en detail

#### Piege 1 : Oublier les pops multiples

```python
# MAUVAIS: Ignore le pop r15 dans "pop rsi; pop r15; ret"
chain.append(gadgets['pop_rsi'])
chain.append(rsi_value)
chain.append(next_gadget)  # r15 va recevoir next_gadget!

# BON: Ajouter du junk pour chaque pop supplementaire
chain.append(gadgets['pop_rsi'])
chain.append(rsi_value)
chain.append(0x0)  # junk pour r15
chain.append(next_gadget)
```

#### Piege 2 : Bad characters

```python
# MAUVAIS: Ne verifie pas les bad chars
def find_gadget(gadgets, category):
    return gadgets[category][0]  # 0x401200 contient 0x00!

# BON: Filtrer
def find_gadget(gadgets, category, bad_chars):
    for g in gadgets[category]:
        if not has_bad_chars(g['addr'], bad_chars):
            return g
    return None
```

### 5.5 Cours Complet

#### 5.5.1 Le Return-Oriented Programming en profondeur

**Principe fondamental :**
ROP exploite le fait que l'instruction `ret` lit l'adresse de retour depuis la stack et saute a cette adresse. En controlant la stack, on controle l'execution.

**Structure d'un gadget :**
```asm
; Gadget typique
pop rdi      ; Lit une valeur de la stack dans RDI
ret          ; Retourne au gadget suivant
```

**Types de gadgets :**
1. **Load gadgets** : `pop REG; ret` - chargent une valeur dans un registre
2. **Store gadgets** : `mov [REG], REG; ret` - ecrivent en memoire
3. **Arithmetic** : `add REG, REG; ret` - operations arithmetiques
4. **Control** : `jmp REG`, `call REG` - controle de flux

#### 5.5.2 Convention SysV AMD64 et ROP

Pour appeler une fonction ou un syscall, il faut :
1. **RDI** = 1er argument
2. **RSI** = 2eme argument
3. **RDX** = 3eme argument
4. **RCX** = 4eme argument (ou R10 pour syscall)
5. **R8** = 5eme argument
6. **R9** = 6eme argument
7. **RAX** = numero de syscall

**Syscalls courants :**
- `execve` = 59
- `mprotect` = 10
- `read` = 0
- `write` = 1

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------+
| HORS NORME                                                    |
+---------------------------------------------------------------+
| from pwn import ROP  # Automatisation interdite               |
+---------------------------------------------------------------+
| CONFORME                                                      |
+---------------------------------------------------------------+
| def categorize_gadgets(gadgets):                              |
|     # Implementation manuelle de la categorisation            |
|     for g in gadgets:                                         |
|         if 'pop rdi' in g['insn']:                            |
|             categories['pop_rdi'].append(g)                   |
+---------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Entree :** gadgets + objective="mprotect" + args

```
+-------+-------------------------------------------+------------------------+
| Etape | Instruction                               | Resultat               |
+-------+-------------------------------------------+------------------------+
|   1   | categorize_gadgets(gadgets)               | {pop_rdi: [...], ...}  |
+-------+-------------------------------------------+------------------------+
|   2   | find_gadget('pop_rdi')                    | {addr: 0x401234}       |
+-------+-------------------------------------------+------------------------+
|   3   | chain.append(gadget_addr)                 | [0x401234]             |
+-------+-------------------------------------------+------------------------+
|   4   | chain.append(args['addr'])                | [0x401234, 0x400000]   |
+-------+-------------------------------------------+------------------------+
|   5   | ... (rsi, rdx, rax, syscall)              | [full chain]           |
+-------+-------------------------------------------+------------------------+
|   6   | pack64 pour chaque element                | bytes payload          |
+-------+-------------------------------------------+------------------------+
```

### 5.8 Mnemotechniques

#### MEME : "Inception - Reves empiles"

Comme dans Inception ou chaque niveau de reve doit etre parfaitement construit :
- **Niveau 1** : pop rdi (le reve le plus externe)
- **Niveau 2** : pop rsi
- **Niveau 3** : pop rdx
- **Kick** : syscall (le kick qui remonte tout)

#### MEME : "LEGO ROP"

Les gadgets sont comme des briques LEGO :
- Chaque brique a une fonction specifique
- On les empile pour construire ce qu'on veut
- Certaines briques sont rares (pop rdx!)

### 5.9 Applications pratiques

1. **Bypass NX/DEP** : ROP permet l'execution de code meme avec NX
2. **ASLR partial bypass** : Avec un leak, ROP sur la libc
3. **CFI bypass** : Certains CFI sont vulnérables au ROP
4. **Kernel exploitation** : ROP kernel avec gadgets dans vmlinux

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Pops multiples ignores | Chain corrompue | Compter les pops |
| 2 | Bad chars non filtres | Exploit echoue | Verifier chaque adresse |
| 3 | Mauvais ordre arguments | Fonction echoue | Respecter SysV ABI |
| 4 | Oublier RAX pour syscall | Syscall incorrect | Toujours set RAX |
| 5 | Alignement non respecte | Crash | Ajouter des ret |

---

## SECTION 7 : QCM

### Question 1
**Qu'est-ce qu'un gadget ROP ?**

A) Un programme malveillant
B) Une sequence d'instructions terminee par ret
C) Un shellcode complet
D) Une fonction de la libc
E) Un debugger
F) Un compilateur
G) Une protection memoire
H) Un type de malware
I) Un format de fichier
J) Un protocole reseau

**Reponse : B**

---

### Question 2
**Quel registre contient le premier argument dans SysV AMD64 ?**

A) RAX
B) RBX
C) RCX
D) RDX
E) RSI
F) RDI
G) R8
H) R9
I) RSP
J) RBP

**Reponse : F**

---

### Question 3
**Quel est le numero de syscall pour mprotect sur Linux x86-64 ?**

A) 0
B) 1
C) 10
D) 59
E) 60
F) 221
G) 226
H) 80
I) 128
J) 255

**Reponse : C**

---

### Question 4
**Que fait le gadget "pop rsi; pop r15; ret" ?**

A) Pop une valeur dans RSI
B) Pop deux valeurs dans RSI et R15
C) Pop trois valeurs
D) Ne fait rien
E) Crash le programme
F) Appelle une fonction
G) Execute un syscall
H) Ecrit en memoire
I) Lit de la memoire
J) Modifie les flags

**Reponse : B**

---

### Question 5
**Pourquoi ROP contourne-t-il NX/DEP ?**

A) Il desactive NX
B) Il execute du code existant deja executable
C) Il modifie les permissions
D) Il utilise le kernel
E) Il exploite un bug dans NX
F) Il utilise du JIT
G) Il modifie le binaire
H) Il utilise de la memoire partagee
I) Il patche le systeme
J) Il utilise ptrace

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | 8/10 |
| **Temps estime** | 90 min |
| **XP Base** | 300 |
| **XP Bonus** | x2 (600 total) |
| **Concepts cles** | ROP, Gadgets, SysV ABI, mprotect, execve |
| **Langage** | Python 3.12 |
| **Prerequis** | Stack overflow, x86-64, Conventions d'appel |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.6-a-rop-builder",
    "generated_at": "2026-01-16",

    "metadata": {
      "exercise_id": "3.4.6-a",
      "exercise_name": "rop_builder",
      "module": "3.4.6",
      "module_name": "ROP Advanced Techniques",
      "concept": "a",
      "concept_name": "Construction de chaines ROP",
      "type": "code",
      "tier": 2,
      "phase": 3,
      "difficulty": 8,
      "language": "python",
      "duration_minutes": 90,
      "xp_base": 300,
      "prerequisites": ["Stack overflow", "x86-64", "SysV ABI"],
      "domains": ["Exploit", "ASM", "ROP"],
      "tags": ["rop", "gadgets", "exploitation"]
    }
  }
}
```
