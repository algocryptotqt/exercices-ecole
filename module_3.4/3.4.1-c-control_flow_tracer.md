# Exercice 3.4.1-c : control_flow_tracer

**Module :**
3.4.1 â€” x86-64 Assembly Fundamentals

**Concept :**
c â€” Instructions de contrÃ´le de flux et comparaisons

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Python 3.12

**PrÃ©requis :**
- Exercice 3.4.1-a (register_decoder)
- Exercice 3.4.1-b (asm_emulator)
- ComprÃ©hension des flags CPU

**Domaines :**
CPU, ASM, Algo

**DurÃ©e estimÃ©e :**
60 min

**XP Base :**
200

**ComplexitÃ© :**
T4 O(nÃ—m) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`control_flow_tracer.py`

**Fonctions autorisÃ©es :**
- `json`, `re`, `sys`
- Fonctions built-in Python

**Fonctions interdites :**
- BibliothÃ¨ques d'analyse binaire externes

### 1.2 Consigne

#### 2.4.1 ğŸ® Contexte Culturel â€” "Dark Souls"

*"You Died."*

Dans **Dark Souls**, chaque dÃ©cision compte. Un mauvais timing, une mauvaise direction, et c'est le game over. Le control flow d'un programme, c'est pareil : chaque branchement (JMP, JZ, JNE...) est une dÃ©cision qui peut mener au succÃ¨s ou Ã  l'Ã©chec.

Comme un joueur qui Ã©tudie les patterns des boss, tu dois analyser le Control Flow Graph (CFG) pour comprendre tous les chemins possibles d'un programme. Chaque bloc de base est comme une zone du jeu, et les sauts conditionnels sont les portes qui te mÃ¨nent vers la victoire... ou la dÃ©faite.

#### 2.4.2 Ã‰noncÃ© AcadÃ©mique

Un **Control Flow Graph (CFG)** reprÃ©sente tous les chemins d'exÃ©cution possibles d'un programme. Chaque **bloc de base** contient des instructions sÃ©quentielles sans branchement interne. Les **arÃªtes** reprÃ©sentent les transitions possibles (sauts, appels, retours).

**Ta mission :**

ImplÃ©menter un analyseur de CFG qui :

1. **Parse** un CFG au format JSON (blocs avec instructions et successeurs)
2. **Ã‰numÃ¨re** tous les chemins d'exÃ©cution depuis l'entrÃ©e
3. **Calcule** les conditions symboliques pour atteindre chaque bloc
4. **Identifie** les prologues/Ã©pilogues de fonctions
5. **DÃ©tecte** les boucles et rÃ©cursions potentielles

**Instructions de contrÃ´le Ã  supporter :**

| Instruction | Description | Condition |
|-------------|-------------|-----------|
| JMP | Saut inconditionnel | Toujours |
| JZ/JE | Saut si zÃ©ro/Ã©gal | ZF = 1 |
| JNZ/JNE | Saut si non-zÃ©ro/non-Ã©gal | ZF = 0 |
| JG/JNLE | Saut si supÃ©rieur (signÃ©) | ZF=0 ET SF=OF |
| JL/JNGE | Saut si infÃ©rieur (signÃ©) | SF â‰  OF |
| JGE/JNL | Saut si supÃ©rieur ou Ã©gal | SF = OF |
| JLE/JNG | Saut si infÃ©rieur ou Ã©gal | ZF=1 OU SFâ‰ OF |
| JA/JNBE | Saut si supÃ©rieur (non-signÃ©) | CF=0 ET ZF=0 |
| JB/JNAE | Saut si infÃ©rieur (non-signÃ©) | CF = 1 |
| CALL | Appel de fonction | Toujours |
| RET | Retour de fonction | Toujours |
| CMP | Comparaison (soustraction sans stockage) | Met Ã  jour flags |
| TEST | ET logique (sans stockage) | Met Ã  jour flags |

**EntrÃ©e :**
```json
{
  "entry": "block_0",
  "blocks": {
    "block_0": {
      "instructions": ["push rbp", "mov rbp, rsp", "cmp rdi, 0x10", "jle block_1"],
      "successors": ["block_1", "block_2"]
    },
    "block_1": {
      "instructions": ["mov rax, 1", "jmp block_exit"],
      "successors": ["block_exit"]
    },
    "block_2": {
      "instructions": ["mov rax, 2", "jmp block_exit"],
      "successors": ["block_exit"]
    },
    "block_exit": {
      "instructions": ["pop rbp", "ret"],
      "successors": []
    }
  }
}
```

**Sortie :**
```json
{
  "paths": [
    {
      "blocks": ["block_0", "block_1", "block_exit"],
      "conditions": ["RDI <= 0x10"],
      "symbolic_constraints": {"RDI": "<=16"}
    },
    {
      "blocks": ["block_0", "block_2", "block_exit"],
      "conditions": ["RDI > 0x10"],
      "symbolic_constraints": {"RDI": ">16"}
    }
  ],
  "function_analysis": {
    "has_prologue": true,
    "has_epilogue": true,
    "stack_frame_size": 0
  },
  "loops_detected": [],
  "unreachable_blocks": []
}
```

### 1.3 Prototype

```python
#!/usr/bin/env python3
"""
control_flow_tracer.py - Analyseur de Control Flow Graph
"""

import json
import sys
from typing import List, Dict, Set, Tuple

class CFGAnalyzer:
    """Analyseur de Control Flow Graph."""

    def __init__(self, cfg: dict):
        """Initialise l'analyseur avec un CFG."""
        pass

    def find_all_paths(self) -> List[List[str]]:
        """Trouve tous les chemins depuis l'entrÃ©e."""
        pass

    def compute_path_conditions(self, path: List[str]) -> List[str]:
        """Calcule les conditions pour un chemin donnÃ©."""
        pass

    def detect_loops(self) -> List[dict]:
        """DÃ©tecte les boucles dans le CFG."""
        pass

    def analyze_function(self) -> dict:
        """Analyse les caractÃ©ristiques de fonction."""
        pass

    def analyze(self) -> dict:
        """Analyse complÃ¨te du CFG."""
        pass

def main():
    """Point d'entrÃ©e principal."""
    pass

if __name__ == "__main__":
    main()
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### Les flags et les comparaisons

L'instruction `CMP a, b` effectue `a - b` sans stocker le rÃ©sultat, mais met Ã  jour les flags :
- **ZF (Zero Flag)** : 1 si rÃ©sultat = 0 (donc a = b)
- **SF (Sign Flag)** : 1 si rÃ©sultat nÃ©gatif (bit de signe = 1)
- **CF (Carry Flag)** : 1 si emprunt/dÃ©bordement non-signÃ©
- **OF (Overflow Flag)** : 1 si dÃ©bordement signÃ©

### Pourquoi JG et JA sont diffÃ©rents ?

- **JG (Jump if Greater)** : Comparaison signÃ©e. `cmp -1, 1; jg` ne saute PAS (-1 < 1)
- **JA (Jump if Above)** : Comparaison non-signÃ©e. `cmp -1, 1; ja` SAUTE (0xFFFF... > 1)

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

**MÃ©tier : Analyste de vulnÃ©rabilitÃ©s**

L'analyse de CFG est au cÅ“ur de :
- **Recherche de vulnÃ©rabilitÃ©s** : Identifier les chemins menant Ã  des Ã©tats dangereux
- **Fuzzing guidÃ© par couverture** : Maximiser les blocs de base atteints
- **VÃ©rification formelle** : Prouver l'absence de bugs

**Outils professionnels utilisant les CFG :**
- IDA Pro / Binary Ninja : Visualisation de CFG
- angr : ExÃ©cution symbolique basÃ©e sur CFG
- Ghidra : Analyse de dÃ©compilation

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cat test_cfg.json
{"entry": "block_0", "blocks": {"block_0": {"instructions": ["cmp rax, 0x10", "jle block_1", "jmp block_2"], "successors": ["block_1", "block_2"]}, "block_1": {"instructions": ["mov rbx, 1", "ret"], "successors": []}, "block_2": {"instructions": ["mov rbx, 2", "ret"], "successors": []}}}

$ python3 control_flow_tracer.py test_cfg.json
{"paths": [{"blocks": ["block_0", "block_1"], "conditions": ["RAX <= 16"]}, {"blocks": ["block_0", "block_2"], "conditions": ["RAX > 16"]}], "function_analysis": {"has_prologue": false, "has_epilogue": true}, "loops_detected": [], "unreachable_blocks": []}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Description | Points |
|------|-------------|--------|
| simple_branch | CFG avec un if simple | 10 |
| nested_branch | CFG avec if/else imbriquÃ©s | 15 |
| loop_detection | CFG avec boucle | 15 |
| unreachable | CFG avec bloc non atteignable | 10 |
| function_prologue | DÃ©tection push rbp; mov rbp, rsp | 10 |
| function_epilogue | DÃ©tection pop rbp; ret | 10 |
| multiple_paths | 4+ chemins diffÃ©rents | 15 |
| symbolic_conditions | Conditions symboliques correctes | 15 |

### 4.3 Solution de rÃ©fÃ©rence

```python
#!/usr/bin/env python3
"""
control_flow_tracer.py - Solution de rÃ©fÃ©rence
"""

import json
import sys
import re
from typing import List, Dict, Set, Optional
from collections import deque

class CFGAnalyzer:
    """Analyseur de Control Flow Graph."""

    JUMP_CONDITIONS = {
        'jz': 'ZF=1', 'je': 'ZF=1',
        'jnz': 'ZF=0', 'jne': 'ZF=0',
        'jg': 'ZF=0 AND SF=OF', 'jnle': 'ZF=0 AND SF=OF',
        'jl': 'SF!=OF', 'jnge': 'SF!=OF',
        'jge': 'SF=OF', 'jnl': 'SF=OF',
        'jle': 'ZF=1 OR SF!=OF', 'jng': 'ZF=1 OR SF!=OF',
        'ja': 'CF=0 AND ZF=0', 'jnbe': 'CF=0 AND ZF=0',
        'jb': 'CF=1', 'jnae': 'CF=1', 'jc': 'CF=1',
        'jae': 'CF=0', 'jnb': 'CF=0', 'jnc': 'CF=0',
        'jbe': 'CF=1 OR ZF=1', 'jna': 'CF=1 OR ZF=1'
    }

    def __init__(self, cfg: dict):
        self.entry = cfg.get('entry', 'block_0')
        self.blocks = cfg.get('blocks', {})
        self.paths = []
        self.loops = []

    def parse_comparison(self, instructions: List[str]) -> Optional[dict]:
        """Extrait la comparaison d'un bloc."""
        for instr in instructions:
            instr_lower = instr.lower().strip()
            if instr_lower.startswith('cmp '):
                parts = instr_lower[4:].split(',')
                if len(parts) == 2:
                    return {
                        'op1': parts[0].strip().upper(),
                        'op2': parts[1].strip()
                    }
            elif instr_lower.startswith('test '):
                parts = instr_lower[5:].split(',')
                if len(parts) == 2:
                    return {
                        'op1': parts[0].strip().upper(),
                        'op2': parts[1].strip(),
                        'is_test': True
                    }
        return None

    def get_jump_type(self, instructions: List[str]) -> Optional[str]:
        """Trouve le type de saut conditionnel."""
        for instr in instructions:
            instr_lower = instr.lower().strip()
            for jmp_type in self.JUMP_CONDITIONS:
                if instr_lower.startswith(jmp_type + ' '):
                    return jmp_type
        return None

    def condition_to_symbolic(self, cmp_info: dict, jmp_type: str, taken: bool) -> str:
        """Convertit une comparaison en condition symbolique."""
        if not cmp_info:
            return "unknown"

        op1 = cmp_info['op1']
        op2 = cmp_info['op2']

        # Simplification des conditions
        conditions_map = {
            ('jle', True): f"{op1} <= {op2}",
            ('jle', False): f"{op1} > {op2}",
            ('jl', True): f"{op1} < {op2}",
            ('jl', False): f"{op1} >= {op2}",
            ('jge', True): f"{op1} >= {op2}",
            ('jge', False): f"{op1} < {op2}",
            ('jg', True): f"{op1} > {op2}",
            ('jg', False): f"{op1} <= {op2}",
            ('je', True): f"{op1} == {op2}",
            ('je', False): f"{op1} != {op2}",
            ('jz', True): f"{op1} == {op2}",
            ('jz', False): f"{op1} != {op2}",
            ('jne', True): f"{op1} != {op2}",
            ('jne', False): f"{op1} == {op2}",
            ('jnz', True): f"{op1} != {op2}",
            ('jnz', False): f"{op1} == {op2}",
        }

        return conditions_map.get((jmp_type, taken), f"{jmp_type}({taken})")

    def find_all_paths(self, max_depth: int = 100) -> List[List[str]]:
        """Trouve tous les chemins depuis l'entrÃ©e (avec limite de profondeur)."""
        paths = []
        stack = [(self.entry, [self.entry], set([self.entry]))]

        while stack:
            current, path, visited = stack.pop()

            if current not in self.blocks:
                continue

            block = self.blocks[current]
            successors = block.get('successors', [])

            if not successors:
                # Bloc terminal
                paths.append(path)
            else:
                for succ in successors:
                    if succ in visited:
                        # DÃ©tection de boucle
                        loop_start = path.index(succ) if succ in path else -1
                        if loop_start >= 0:
                            self.loops.append({
                                'start': succ,
                                'blocks': path[loop_start:]
                            })
                        # On peut quand mÃªme ajouter le chemin jusqu'ici
                        paths.append(path + [succ + " (loop)"])
                    elif len(path) < max_depth:
                        new_visited = visited | {succ}
                        stack.append((succ, path + [succ], new_visited))

        return paths

    def compute_path_conditions(self, path: List[str]) -> List[str]:
        """Calcule les conditions symboliques pour un chemin."""
        conditions = []

        for i, block_name in enumerate(path[:-1]):
            if block_name not in self.blocks:
                continue

            block = self.blocks[block_name]
            instructions = block.get('instructions', [])
            successors = block.get('successors', [])

            if len(successors) <= 1:
                continue

            next_block = path[i + 1].replace(" (loop)", "")
            cmp_info = self.parse_comparison(instructions)
            jmp_type = self.get_jump_type(instructions)

            if cmp_info and jmp_type:
                # Le premier successeur est gÃ©nÃ©ralement le "taken"
                taken = (next_block == successors[0])
                cond = self.condition_to_symbolic(cmp_info, jmp_type, taken)
                conditions.append(cond)

        return conditions

    def detect_loops(self) -> List[dict]:
        """Retourne les boucles dÃ©tectÃ©es."""
        return self.loops

    def analyze_function(self) -> dict:
        """Analyse les caractÃ©ristiques de fonction (prologue/Ã©pilogue)."""
        has_prologue = False
        has_epilogue = False
        stack_frame_size = 0

        # Chercher le prologue dans le bloc d'entrÃ©e
        if self.entry in self.blocks:
            entry_instrs = self.blocks[self.entry].get('instructions', [])
            entry_str = ' '.join(instr.lower() for instr in entry_instrs)

            if 'push rbp' in entry_str and 'mov rbp' in entry_str:
                has_prologue = True

            # Chercher sub rsp, X pour la taille du frame
            for instr in entry_instrs:
                match = re.match(r'sub\s+rsp\s*,\s*(0x[0-9a-f]+|\d+)', instr.lower())
                if match:
                    val = match.group(1)
                    stack_frame_size = int(val, 16) if val.startswith('0x') else int(val)

        # Chercher l'Ã©pilogue dans les blocs terminaux
        for block_name, block in self.blocks.items():
            if not block.get('successors'):
                instrs = block.get('instructions', [])
                instrs_str = ' '.join(instr.lower() for instr in instrs)
                if 'pop rbp' in instrs_str or 'leave' in instrs_str:
                    if 'ret' in instrs_str:
                        has_epilogue = True

        return {
            'has_prologue': has_prologue,
            'has_epilogue': has_epilogue,
            'stack_frame_size': stack_frame_size
        }

    def find_unreachable(self) -> List[str]:
        """Trouve les blocs non atteignables."""
        reachable = set()
        queue = deque([self.entry])

        while queue:
            current = queue.popleft()
            if current in reachable or current not in self.blocks:
                continue
            reachable.add(current)
            for succ in self.blocks[current].get('successors', []):
                if succ not in reachable:
                    queue.append(succ)

        all_blocks = set(self.blocks.keys())
        return list(all_blocks - reachable)

    def analyze(self) -> dict:
        """Analyse complÃ¨te du CFG."""
        paths = self.find_all_paths()

        analyzed_paths = []
        for path in paths:
            conditions = self.compute_path_conditions(path)
            analyzed_paths.append({
                'blocks': path,
                'conditions': conditions
            })

        return {
            'paths': analyzed_paths,
            'function_analysis': self.analyze_function(),
            'loops_detected': self.detect_loops(),
            'unreachable_blocks': self.find_unreachable()
        }


def main():
    if len(sys.argv) < 2:
        print("Usage: control_flow_tracer.py <cfg.json | ->", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file == '-':
        cfg = json.load(sys.stdin)
    else:
        with open(input_file, 'r') as f:
            cfg = json.load(f)

    analyzer = CFGAnalyzer(cfg)
    result = analyzer.analyze()

    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "control_flow_tracer",
  "language": "python",
  "version": "3.12",
  "type": "code",
  "tier": 1,
  "tags": ["assembly", "cfg", "control-flow", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "CFGAnalyzer.analyze",
    "prototype": "def analyze(self) -> dict",
    "return_type": "dict"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "simple_if",
        "args": [{"entry": "b0", "blocks": {"b0": {"instructions": ["cmp rax, 0", "jz b1"], "successors": ["b1", "b2"]}, "b1": {"instructions": ["ret"], "successors": []}, "b2": {"instructions": ["ret"], "successors": []}}}],
        "check": "len(result['paths']) == 2"
      },
      {
        "name": "loop_detected",
        "args": [{"entry": "start", "blocks": {"start": {"instructions": ["mov rcx, 10"], "successors": ["loop"]}, "loop": {"instructions": ["dec rcx", "jnz loop"], "successors": ["loop", "end"]}, "end": {"instructions": ["ret"], "successors": []}}}],
        "check": "len(result['loops_detected']) > 0"
      }
    ]
  }
}
```

### 4.10 Solutions Mutantes

```python
# Mutant A: Ne dÃ©tecte pas les boucles
def find_all_paths_mutant(self):
    # Pas de dÃ©tection de visited â†’ boucle infinie!
    pass

# Mutant B: Inverse les conditions
def condition_to_symbolic_mutant(self, cmp_info, jmp_type, taken):
    # taken et not taken inversÃ©s
    return self.condition_to_symbolic(cmp_info, jmp_type, not taken)

# Mutant C: Ignore les blocs sans successeurs
def find_all_paths_mutant_c(self):
    # Ne compte pas les chemins terminaux
    pass
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Control Flow Graph** : ReprÃ©sentation des chemins d'exÃ©cution
2. **Analyse symbolique** : Raisonner sur les conditions sans valeurs concrÃ¨tes
3. **DÃ©tection de boucles** : Algorithmes de graphes (DFS avec marquage)
4. **Prologues/Ã‰pilogues** : Conventions de stack frame

### 5.3 Visualisation ASCII

```
            CONTROL FLOW GRAPH
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                     â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
    â”‚    â”‚  block_0    â”‚ â—„â”€â”€ Entry        â”‚
    â”‚    â”‚ cmp rdi, 16 â”‚                  â”‚
    â”‚    â”‚ jle block_1 â”‚                  â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                  â”‚
    â”‚           â”‚                         â”‚
    â”‚     â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                   â”‚
    â”‚     â”‚           â”‚                   â”‚
    â”‚     â–¼           â–¼                   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
    â”‚ â”‚block_1 â”‚  â”‚block_2 â”‚              â”‚
    â”‚ â”‚rdi<=16 â”‚  â”‚rdi>16  â”‚              â”‚
    â”‚ â”‚mov rax,1â”‚ â”‚mov rax,2â”‚             â”‚
    â”‚ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜              â”‚
    â”‚      â”‚          â”‚                   â”‚
    â”‚      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                   â”‚
    â”‚           â”‚                         â”‚
    â”‚           â–¼                         â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
    â”‚    â”‚ block_exit  â”‚                  â”‚
    â”‚    â”‚ pop rbp     â”‚                  â”‚
    â”‚    â”‚ ret         â”‚ â—„â”€â”€ Exit         â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
    â”‚                                     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Chemin 1: block_0 â†’ block_1 â†’ block_exit
              Condition: RDI <= 16

    Chemin 2: block_0 â†’ block_2 â†’ block_exit
              Condition: RDI > 16
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**AprÃ¨s `cmp rax, rbx` suivi de `jg target`, le saut est pris si :**

A) RAX = RBX
B) RAX > RBX (signÃ©)
C) RAX < RBX (signÃ©)
D) RAX > RBX (non-signÃ©)
E) RAX < RBX (non-signÃ©)
F) Toujours
G) Jamais
H) RAX >= RBX
I) RAX <= RBX
J) RAX != RBX

**RÃ©ponse : B**

---

### Question 2
**Quelle est la diffÃ©rence entre JA et JG ?**

A) Aucune
B) JA = signed, JG = unsigned
C) JA = unsigned, JG = signed
D) JA vÃ©rifie CF, JG vÃ©rifie ZF
E) JA saute toujours, JG jamais
F) JA = jump above (non-signÃ©), JG = jump greater (signÃ©)
G) C et F sont corrects
H) JA utilise OF, JG utilise SF
I) JA est obsolÃ¨te
J) DÃ©pend de l'architecture

**RÃ©ponse : G**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| **Temps estimÃ©** | 60 min |
| **XP Base** | 200 |
| **Concepts clÃ©s** | CFG, Branches, Flags, Analyse symbolique |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.4.1-c-control-flow-tracer",
    "metadata": {
      "exercise_id": "3.4.1-c",
      "exercise_name": "control_flow_tracer",
      "type": "code",
      "tier": 1,
      "difficulty": 7,
      "language": "python"
    }
  }
}
```
