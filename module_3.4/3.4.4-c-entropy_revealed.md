# Exercice 3.4.4-c : L'Entropie Révélée

## Metadata
- **Exercice ID**: 3.4.4-c
- **Titre**: L'Entropie Révélée
- **Module**: 3.4 - Exploitation Binaire
- **Niveau**: Protection Bypass (Niveau 2)
- **Difficulté**: ⭐⭐⭐⭐⭐⭐⭐ (7/10 - Expert)
- **Tier**: 2
- **XP**: 550

## Concepts Couverts
| ID Concept | Description |
|------------|-------------|
| 3.4.4.f | ASLR Entropie (28 bits mmap, 30 bits stack, 8 bits brk) |
| 3.4.4.g | ASLR Bypass - Leak |
| 3.4.4.h | ASLR Bypass - Partial Overwrite |
| 3.4.4.i | ASLR Bypass - Bruteforce |
| 3.4.4.n | PIE Impact |

## Prerequis
- Module 3.4.4-a : Protection Detector (detection des protections)
- Comprehension de la memoire virtuelle et de la pagination
- Bases des vulnerabilites buffer overflow
- Notions de probabilites et de theorie de l'information

---

## Section 1 : Prototype de Fonction

```python
"""
Module: entropy_revealed - Analyse ASLR et Stratégies de Bypass
Architecture: x86-64 / x86 (32-bit)
Contraintes: Aucune dépendance externe
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional


class Architecture(Enum):
    """Architecture cible."""
    X86 = "32-bit"
    X64 = "64-bit"


class Region(Enum):
    """Régions mémoire soumises à ASLR."""
    STACK = "stack"
    HEAP = "heap"
    MMAP = "mmap"
    PIE = "pie"
    VDSO = "vdso"
    LIBC = "libc"


@dataclass
class ASLRConfig:
    """Configuration ASLR du système."""
    architecture: Architecture
    aslr_level: int  # 0=off, 1=partial, 2=full
    pie_enabled: bool
    regions: dict[Region, bool]  # Which regions are randomized


@dataclass
class LeakInfo:
    """Information sur un leak disponible."""
    region: Region
    leaked_bytes: int  # Nombre de bytes connus (LSB)
    base_offset: int  # Offset depuis la base de la région


def analyze_entropy(config: ASLRConfig) -> dict:
    """
    Analyse l'entropie ASLR pour chaque région mémoire.

    Args:
        config: Configuration ASLR du système

    Returns:
        Dict avec l'entropie (en bits) pour chaque région active

    Exemple:
        >>> config = ASLRConfig(
        ...     architecture=Architecture.X64,
        ...     aslr_level=2,
        ...     pie_enabled=True,
        ...     regions={Region.STACK: True, Region.MMAP: True, Region.PIE: True}
        ... )
        >>> result = analyze_entropy(config)
        >>> result["stack"]["entropy_bits"]
        30
        >>> result["mmap"]["entropy_bits"]
        28
    """
    pass


def calculate_bruteforce_complexity(
    config: ASLRConfig,
    target_region: Region,
    leak: Optional[LeakInfo] = None
) -> dict:
    """
    Calcule la complexité du bruteforce pour une région.

    Args:
        config: Configuration ASLR
        target_region: Région à cibler
        leak: Information de leak optionnelle

    Returns:
        Dict avec:
        - remaining_entropy: bits d'entropie restants
        - attempts_required: nombre de tentatives moyennes
        - success_probability: probabilité par tentative
        - time_estimate_1000_per_sec: temps estimé en secondes

    Exemple:
        >>> config = ASLRConfig(Architecture.X64, 2, True, {Region.LIBC: True})
        >>> leak = LeakInfo(Region.LIBC, 2, 0)  # 2 bytes leaked
        >>> result = calculate_bruteforce_complexity(config, Region.LIBC, leak)
        >>> result["remaining_entropy"]
        28
    """
    pass


def analyze_partial_leak_impact(
    config: ASLRConfig,
    leak: LeakInfo,
    target_offset: int
) -> dict:
    """
    Analyse l'impact d'un leak partiel sur la prédictibilité d'une adresse.

    Args:
        config: Configuration ASLR
        leak: Information sur le leak
        target_offset: Offset de l'adresse cible depuis la base leakée

    Returns:
        Dict avec:
        - known_bits: nombre de bits connus
        - unknown_bits: entropie restante
        - same_page: si cible est sur la même page
        - partial_overwrite_possible: si partial overwrite viable

    Exemple:
        >>> config = ASLRConfig(Architecture.X64, 2, True, {Region.LIBC: True})
        >>> leak = LeakInfo(Region.LIBC, 3, 0x0)  # 3 bytes leaked
        >>> result = analyze_partial_leak_impact(config, leak, 0x500)
        >>> result["same_page"]
        True
    """
    pass


def generate_partial_overwrite_payload(
    leak: LeakInfo,
    target_offset: int,
    payload_bytes: int
) -> dict:
    """
    Génère un payload de partial overwrite pour contourner PIE/ASLR.

    Args:
        leak: Information sur le leak disponible
        target_offset: Offset cible depuis la base leakée
        payload_bytes: Nombre de bytes à écrire (1-3)

    Returns:
        Dict avec:
        - payload: bytes à écrire
        - success_probability: probabilité de succès
        - addresses_covered: plage d'adresses possibles

    Exemple:
        >>> leak = LeakInfo(Region.PIE, 2, 0x1000)  # LSB 2 bytes known
        >>> result = generate_partial_overwrite_payload(leak, 0x1234, 2)
        >>> result["payload"]
        b'\\x34\\x12'
    """
    pass


def recommend_bypass_strategy(
    config: ASLRConfig,
    available_leaks: list[LeakInfo],
    constraints: dict
) -> dict:
    """
    Recommande la stratégie optimale de bypass ASLR.

    Args:
        config: Configuration ASLR
        available_leaks: Leaks disponibles
        constraints: {"max_attempts": int, "can_fork": bool, "time_limit": float}

    Returns:
        Dict avec:
        - strategy: nom de la stratégie recommandée
        - description: explication
        - success_rate: taux de succès estimé
        - steps: étapes à suivre

    Stratégies possibles:
    - "full_leak": Leaker plus de bytes
    - "partial_overwrite": Utiliser partial overwrite
    - "bruteforce": Bruteforce si entropie faible
    - "ret2csu": Utiliser gadgets indépendants de ASLR
    - "info_disclosure": Chercher une info disclosure
    """
    pass


def compare_architectures(target_region: Region) -> dict:
    """
    Compare l'entropie ASLR entre 32-bit et 64-bit.

    Args:
        target_region: Région à comparer

    Returns:
        Dict avec comparaison détaillée des deux architectures

    Exemple:
        >>> result = compare_architectures(Region.STACK)
        >>> result["x86"]["entropy_bits"]
        19
        >>> result["x64"]["entropy_bits"]
        30
    """
    pass
```

---

## Section 2 : Cours Intégré (Référentiel Complet)

### 2.1 Introduction à l'ASLR

L'**Address Space Layout Randomization (ASLR)** est une technique de sécurité qui randomise les adresses de base des régions mémoire à chaque exécution d'un programme. L'objectif est de rendre imprévisible l'emplacement du code et des données, compliquant l'exploitation de vulnérabilités.

### 2.2 Niveaux ASLR sous Linux

```
/proc/sys/kernel/randomize_va_space:
- 0: ASLR désactivé
- 1: Partial ASLR (stack, mmap, VDSO randomisés)
- 2: Full ASLR (+ heap randomisé, brk() randomisé)
```

### 2.3 Entropie par Région (3.4.4.f)

L'entropie mesure le nombre de bits aléatoires dans une adresse. Plus l'entropie est élevée, plus le bruteforce est difficile.

#### Entropie x86-64 (Linux)

| Région | Bits d'Entropie | Adresses Possibles | Alignement |
|--------|-----------------|-------------------|------------|
| Stack | 30 bits | ~1 milliard | 16 bytes |
| mmap | 28 bits | ~268 millions | 4KB page |
| Heap (brk) | 13 bits | ~8192 | 4KB page |
| PIE | 28 bits | ~268 millions | 4KB page |
| VDSO | 11 bits | ~2048 | 4KB page |

#### Entropie x86 (32-bit)

| Région | Bits d'Entropie | Adresses Possibles | Alignement |
|--------|-----------------|-------------------|------------|
| Stack | 19 bits | ~524K | 16 bytes |
| mmap | 8 bits | ~256 | 4KB page |
| Heap | 13 bits | ~8192 | 4KB page |
| PIE | 8 bits | ~256 | 4KB page |
| VDSO | 8 bits | ~256 | 4KB page |

#### Formule de Calcul

```
Entropie_effective = Entropie_base - log2(Alignement/granularité_random)
Adresses_possibles = 2^Entropie_effective
```

### 2.4 Bypass par Leak d'Adresse (3.4.4.g)

Un **information disclosure** ou **memory leak** permet de récupérer une adresse valide à l'exécution.

#### Sources communes de leak

```
1. Format String: %p, %x pour leaker des adresses
2. Uninitialized Memory: Stack/heap non initialisé
3. Out-of-Bounds Read: Buffer over-read
4. Error Messages: Stack traces, debug info
5. /proc/self/maps: Si accessible
6. Use-After-Free: Pointers dangling
```

#### Calcul du leak impact

```
Si on leak N bytes d'une adresse:
- Bits connus = N * 8
- Entropie restante = Entropie_originale - (Bits_connus - 12)
  (12 bits = offset dans page, toujours connus implicitement)

Exemple: Leak 3 bytes d'adresse libc sur x64
- Bits connus: 24
- Page offset: 12 bits (non-entropiques)
- Réduction effective: 24 - 12 = 12 bits
- Entropie restante: 28 - 12 = 16 bits
```

### 2.5 Bypass par Partial Overwrite (3.4.4.h)

Le **partial overwrite** exploite le fait que seuls les bits de poids faible (LSB) d'une adresse changent au sein d'une même région randomisée.

#### Principe

```
Adresse originale: 0x7f42_1234_5678
                       ^^^^-^^^^ ASLR randomisé
                             ^^^^ Offset dans page (prévisible)

Partial Overwrite de 2 bytes:
- Overwrite: 0x5678 → 0xABCD
- Résultat: 0x7f42_1234_ABCD
- Succès si cible est à offset 0xABCD dans même région
```

#### Conditions de succès

```python
def partial_overwrite_viable(leak_bytes, target_offset, region_size):
    """
    Vérifie si partial overwrite peut atteindre la cible.
    """
    addressable_range = (1 << (leak_bytes * 8))
    return target_offset < addressable_range
```

#### Probabilité avec pages différentes

```
Si la cible n'est pas dans la même page:
- On doit deviner les bits du numéro de page
- P(succès) = 1 / 2^(bits_à_deviner)

Exemple: Overwrite 2 bytes, cible à +0x12345
- Offset 0x12345 > 0xFFFF (2 bytes)
- Page cible: 0x12 = différente
- Besoin de deviner 4 bits supplémentaires
- P(succès) = 1/16
```

### 2.6 Bypass par Bruteforce (3.4.4.i)

Quand l'entropie est faible, le bruteforce devient viable.

#### Analyse de viabilité

```python
def bruteforce_viable(entropy_bits, attempts_per_second, time_limit_seconds):
    """
    Détermine si le bruteforce est réalisable.
    """
    total_attempts = 2 ** entropy_bits
    avg_attempts = total_attempts / 2  # En moyenne, succès à mi-chemin
    time_required = avg_attempts / attempts_per_second
    return time_required <= time_limit_seconds
```

#### Scénarios favorables

```
1. Architecture 32-bit: Entropie mmap/PIE = 8 bits
   - 256 tentatives moyennes
   - Faisable en quelques secondes

2. Fork-based services: Même ASLR layout après fork()
   - Permet leak byte-by-byte
   - Réduit considérablement l'entropie effective

3. Partial leak disponible:
   - Chaque byte leaké réduit l'entropie de ~8 bits
   - 3 bytes leakés sur x64: 28 - 16 = 12 bits restants
```

### 2.7 Impact de PIE (3.4.4.n)

**Position Independent Executable (PIE)** randomise l'adresse de base du binaire lui-même, pas seulement des bibliothèques.

#### Conséquences

```
Sans PIE:
- Adresse .text/.data/.bss prévisibles
- Gadgets ROP dans le binaire utilisables directement
- GOT/PLT à adresses fixes

Avec PIE:
- Tout le binaire est randomisé
- Nécessite leak d'adresse du binaire
- Gadgets PIE-indépendants (ret2csu) deviennent précieux
```

#### Stratégies anti-PIE

```python
# 1. Partial overwrite si on contrôle un pointeur
# Exploite le fait que les offsets internes sont constants

# 2. ret2csu - utilise __libc_csu_init gadgets
# Présent dans tous les binaires liés à glibc

# 3. Leak adresse PIE puis calcul
base_pie = leaked_addr - known_offset
target = base_pie + target_offset
```

### 2.8 Formules de Calcul Importantes

```python
# Entropie effective après leak
def remaining_entropy(base_entropy, leaked_bytes, page_aligned=True):
    leaked_bits = leaked_bytes * 8
    if page_aligned:
        # Les 12 bits de poids faible sont l'offset dans la page
        # Ils ne contribuent pas à l'entropie ASLR
        effective_leak = max(0, leaked_bits - 12)
    else:
        effective_leak = leaked_bits
    return max(0, base_entropy - effective_leak)

# Temps moyen de bruteforce
def avg_bruteforce_time(entropy_bits, attempts_per_sec):
    return (2 ** entropy_bits) / (2 * attempts_per_sec)

# Probabilité de succès par tentative
def success_probability(entropy_bits):
    return 1.0 / (2 ** entropy_bits)

# Nombre de tentatives pour probabilité P de succès
def attempts_for_probability(entropy_bits, target_probability):
    import math
    # P(au moins 1 succès en N essais) = 1 - (1 - p)^N
    # N = log(1 - P_target) / log(1 - p)
    p = success_probability(entropy_bits)
    return math.ceil(math.log(1 - target_probability) / math.log(1 - p))
```

---

## Section 3 : Zone de Correction

```python
"""
CORRECTION COMPLETE - Analyse ASLR et Bypass
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional
import math


class Architecture(Enum):
    X86 = "32-bit"
    X64 = "64-bit"


class Region(Enum):
    STACK = "stack"
    HEAP = "heap"
    MMAP = "mmap"
    PIE = "pie"
    VDSO = "vdso"
    LIBC = "libc"


@dataclass
class ASLRConfig:
    architecture: Architecture
    aslr_level: int
    pie_enabled: bool
    regions: dict


@dataclass
class LeakInfo:
    region: Region
    leaked_bytes: int
    base_offset: int


# Entropie par défaut (en bits) pour chaque région et architecture
ENTROPY_TABLE = {
    Architecture.X64: {
        Region.STACK: 30,
        Region.HEAP: 13,
        Region.MMAP: 28,
        Region.PIE: 28,
        Region.VDSO: 11,
        Region.LIBC: 28,  # mmap'd, same as mmap
    },
    Architecture.X86: {
        Region.STACK: 19,
        Region.HEAP: 13,
        Region.MMAP: 8,
        Region.PIE: 8,
        Region.VDSO: 8,
        Region.LIBC: 8,
    }
}

# Alignement par région (en bytes)
ALIGNMENT = {
    Region.STACK: 16,
    Region.HEAP: 4096,
    Region.MMAP: 4096,
    Region.PIE: 4096,
    Region.VDSO: 4096,
    Region.LIBC: 4096,
}


def analyze_entropy(config: ASLRConfig) -> dict:
    """Analyse l'entropie ASLR pour chaque région."""
    result = {}

    if config.aslr_level == 0:
        # ASLR désactivé
        for region in Region:
            result[region.value] = {
                "entropy_bits": 0,
                "possible_addresses": 1,
                "randomized": False,
                "alignment": ALIGNMENT[region]
            }
        return result

    base_entropy = ENTROPY_TABLE[config.architecture]

    for region in Region:
        is_randomized = config.regions.get(region, False)

        # Cas spécial: heap seulement randomisé en ASLR level 2
        if region == Region.HEAP and config.aslr_level < 2:
            is_randomized = False

        # Cas spécial: PIE
        if region == Region.PIE and not config.pie_enabled:
            is_randomized = False

        if is_randomized:
            entropy = base_entropy[region]
            possible = 2 ** entropy
        else:
            entropy = 0
            possible = 1

        result[region.value] = {
            "entropy_bits": entropy,
            "possible_addresses": possible,
            "randomized": is_randomized,
            "alignment": ALIGNMENT[region]
        }

    return result


def calculate_bruteforce_complexity(
    config: ASLRConfig,
    target_region: Region,
    leak: Optional[LeakInfo] = None
) -> dict:
    """Calcule la complexité du bruteforce pour une région."""

    entropy_analysis = analyze_entropy(config)
    region_data = entropy_analysis[target_region.value]
    base_entropy = region_data["entropy_bits"]

    # Calcul de l'entropie restante après leak
    if leak and leak.region == target_region:
        # Les 12 bits LSB sont l'offset dans la page (non-entropiques)
        leaked_entropy_bits = leak.leaked_bytes * 8
        # Seuls les bits au-delà de l'offset de page comptent
        effective_leak = max(0, leaked_entropy_bits - 12)
        remaining_entropy = max(0, base_entropy - effective_leak)
    else:
        remaining_entropy = base_entropy

    # Calculs de complexité
    if remaining_entropy == 0:
        attempts = 1
        probability = 1.0
        time_estimate = 0.001
    else:
        total_space = 2 ** remaining_entropy
        attempts = total_space // 2  # En moyenne
        probability = 1.0 / total_space
        time_estimate = attempts / 1000.0  # À 1000 tentatives/sec

    return {
        "base_entropy": base_entropy,
        "remaining_entropy": remaining_entropy,
        "leak_reduction": base_entropy - remaining_entropy,
        "attempts_required": attempts,
        "success_probability": probability,
        "time_estimate_1000_per_sec": time_estimate,
        "viable_bruteforce": remaining_entropy <= 16  # Moins de 65K tentatives
    }


def analyze_partial_leak_impact(
    config: ASLRConfig,
    leak: LeakInfo,
    target_offset: int
) -> dict:
    """Analyse l'impact d'un leak partiel."""

    entropy_analysis = analyze_entropy(config)
    region_data = entropy_analysis[leak.region.value]
    base_entropy = region_data["entropy_bits"]

    # Bits connus grâce au leak
    known_bits = leak.leaked_bytes * 8

    # Vérifier si cible est sur la même page (offset < 4096)
    page_size = 4096
    leak_page_offset = leak.base_offset % page_size
    target_page_offset = target_offset % page_size

    # Calculer si même page
    leak_page = leak.base_offset // page_size
    target_page = target_offset // page_size
    same_page = (leak_page == target_page)

    # Entropie restante
    # Pour partial overwrite, on peut cibler dans la plage des bytes leakés
    max_reachable_offset = (1 << known_bits) - 1

    if target_offset <= max_reachable_offset:
        # Cible atteignable par partial overwrite
        partial_overwrite_possible = True
        unknown_bits = 0
    else:
        # Doit deviner les bits supplémentaires
        partial_overwrite_possible = False
        extra_bits_needed = (target_offset.bit_length() - known_bits)
        unknown_bits = max(0, extra_bits_needed)

    # Si on reste dans la même région randomisée
    if same_page:
        unknown_bits = 0
        partial_overwrite_possible = True

    return {
        "leak_bytes": leak.leaked_bytes,
        "known_bits": known_bits,
        "unknown_bits": unknown_bits,
        "target_offset": target_offset,
        "same_page": same_page,
        "partial_overwrite_possible": partial_overwrite_possible,
        "max_reachable_offset": max_reachable_offset,
        "success_probability": 1.0 if unknown_bits == 0 else 1.0 / (2 ** unknown_bits)
    }


def generate_partial_overwrite_payload(
    leak: LeakInfo,
    target_offset: int,
    payload_bytes: int
) -> dict:
    """Génère un payload de partial overwrite."""

    if payload_bytes < 1 or payload_bytes > 8:
        return {"error": "payload_bytes must be between 1 and 8"}

    # Calculer les bytes à écrire (little-endian)
    mask = (1 << (payload_bytes * 8)) - 1
    payload_value = target_offset & mask
    payload = payload_value.to_bytes(payload_bytes, 'little')

    # Calculer la plage d'adresses couvertes
    base_alignment = 1 << (payload_bytes * 8)
    addresses_covered = base_alignment

    # Probabilité de succès
    # Si target_offset peut être atteint avec payload_bytes
    max_offset = (1 << (payload_bytes * 8)) - 1

    if target_offset <= max_offset:
        success_probability = 1.0
    else:
        # Besoin de deviner les bits supérieurs
        upper_bits = target_offset >> (payload_bytes * 8)
        guesses_needed = upper_bits + 1
        success_probability = 1.0 / guesses_needed

    # Formater le payload pour affichage
    payload_hex = ''.join(f'\\x{b:02x}' for b in payload)

    return {
        "payload": payload,
        "payload_hex": payload_hex,
        "payload_int": payload_value,
        "target_offset": target_offset,
        "bytes_written": payload_bytes,
        "success_probability": success_probability,
        "addresses_covered": addresses_covered,
        "requires_bruteforce": success_probability < 1.0
    }


def recommend_bypass_strategy(
    config: ASLRConfig,
    available_leaks: list,
    constraints: dict
) -> dict:
    """Recommande la stratégie optimale de bypass ASLR."""

    max_attempts = constraints.get("max_attempts", 1000000)
    can_fork = constraints.get("can_fork", False)
    time_limit = constraints.get("time_limit", 3600.0)

    entropy_analysis = analyze_entropy(config)

    # Analyser les leaks disponibles
    best_leak = None
    min_remaining_entropy = float('inf')

    for leak in available_leaks:
        complexity = calculate_bruteforce_complexity(config, leak.region, leak)
        if complexity["remaining_entropy"] < min_remaining_entropy:
            min_remaining_entropy = complexity["remaining_entropy"]
            best_leak = leak

    # Déterminer la stratégie
    strategies = []

    # Stratégie 1: Si entropie très faible, bruteforce direct
    if min_remaining_entropy <= 8:
        strategies.append({
            "strategy": "bruteforce",
            "priority": 1,
            "description": f"Bruteforce direct viable avec {2**min_remaining_entropy} tentatives max",
            "success_rate": 0.99,
            "steps": [
                "Utiliser le leak existant pour réduire l'espace de recherche",
                f"Effectuer jusqu'à {2**min_remaining_entropy} tentatives",
                "Chaque tentative teste une adresse de base différente"
            ]
        })

    # Stratégie 2: Partial overwrite si leak suffisant
    if best_leak and best_leak.leaked_bytes >= 2:
        strategies.append({
            "strategy": "partial_overwrite",
            "priority": 2 if min_remaining_entropy > 8 else 3,
            "description": "Utiliser partial overwrite pour cibler une adresse proche",
            "success_rate": 0.95 if best_leak.leaked_bytes >= 3 else 0.5,
            "steps": [
                f"Utiliser les {best_leak.leaked_bytes} bytes leakés",
                "Calculer l'offset relatif vers la cible",
                "Écrire seulement les bytes LSB nécessaires",
                "Cibler des gadgets/fonctions proches de l'adresse leakée"
            ]
        })

    # Stratégie 3: Fork-based leak si disponible
    if can_fork:
        strategies.append({
            "strategy": "fork_byte_leak",
            "priority": 1,
            "description": "Leak byte-par-byte via fork() (même ASLR layout)",
            "success_rate": 0.99,
            "steps": [
                "Exploiter que fork() préserve le layout ASLR",
                "Leaker un byte à la fois via crash/no-crash oracle",
                "Reconstruire l'adresse complète",
                "Utiliser l'adresse pour l'exploitation"
            ]
        })

    # Stratégie 4: Recommander plus de leak
    if min_remaining_entropy > 16 and not can_fork:
        strategies.append({
            "strategy": "full_leak",
            "priority": 1,
            "description": "Leaker plus de bytes pour réduire l'entropie",
            "success_rate": 0.9,
            "steps": [
                "Chercher une primitive de lecture supplémentaire",
                "Format string: utiliser %p pour leaker plus",
                "Buffer over-read: augmenter la taille de lecture",
                f"Objectif: leaker au moins {(min_remaining_entropy // 8) + 2} bytes supplémentaires"
            ]
        })

    # Stratégie 5: ret2csu si PIE mais gadgets disponibles
    if config.pie_enabled and min_remaining_entropy > 20:
        strategies.append({
            "strategy": "ret2csu",
            "priority": 3,
            "description": "Utiliser __libc_csu_init gadgets (indépendants de PIE leak)",
            "success_rate": 0.7,
            "steps": [
                "Identifier les gadgets universels dans __libc_csu_init",
                "Construire une chaîne ROP utilisant ces gadgets",
                "Appeler une fonction connue pour leaker plus d'info",
                "Pivoter vers exploitation complète"
            ]
        })

    # Trier par priorité
    strategies.sort(key=lambda x: x["priority"])

    return {
        "current_entropy": min_remaining_entropy,
        "best_leak": {
            "region": best_leak.region.value if best_leak else None,
            "bytes": best_leak.leaked_bytes if best_leak else 0
        } if best_leak else None,
        "recommended_strategy": strategies[0] if strategies else None,
        "alternative_strategies": strategies[1:] if len(strategies) > 1 else [],
        "bruteforce_viable": min_remaining_entropy <= 20 and
                           (2 ** min_remaining_entropy) / 1000 <= time_limit
    }


def compare_architectures(target_region: Region) -> dict:
    """Compare l'entropie ASLR entre 32-bit et 64-bit."""

    x86_entropy = ENTROPY_TABLE[Architecture.X86].get(target_region, 0)
    x64_entropy = ENTROPY_TABLE[Architecture.X64].get(target_region, 0)

    x86_attempts = 2 ** x86_entropy if x86_entropy > 0 else 1
    x64_attempts = 2 ** x64_entropy if x64_entropy > 0 else 1

    # Temps de bruteforce à 1000 tentatives/sec
    x86_time = x86_attempts / (2 * 1000)
    x64_time = x64_attempts / (2 * 1000)

    return {
        "region": target_region.value,
        "x86": {
            "architecture": "32-bit",
            "entropy_bits": x86_entropy,
            "possible_addresses": x86_attempts,
            "avg_bruteforce_attempts": x86_attempts // 2,
            "bruteforce_time_1000_ps": x86_time,
            "bruteforce_viable": x86_entropy <= 16
        },
        "x64": {
            "architecture": "64-bit",
            "entropy_bits": x64_entropy,
            "possible_addresses": x64_attempts,
            "avg_bruteforce_attempts": x64_attempts // 2,
            "bruteforce_time_1000_ps": x64_time,
            "bruteforce_viable": x64_entropy <= 16
        },
        "comparison": {
            "entropy_difference": x64_entropy - x86_entropy,
            "difficulty_ratio": x64_attempts / x86_attempts if x86_attempts > 0 else float('inf'),
            "recommendation": "Target 32-bit if available" if x86_entropy < x64_entropy else "Similar difficulty"
        }
    }


# Fonction principale pour l'exercice
def main():
    """Démonstration de l'analyse ASLR."""

    # Configuration: Linux x64 avec full ASLR et PIE
    config = ASLRConfig(
        architecture=Architecture.X64,
        aslr_level=2,
        pie_enabled=True,
        regions={
            Region.STACK: True,
            Region.HEAP: True,
            Region.MMAP: True,
            Region.PIE: True,
            Region.LIBC: True,
            Region.VDSO: True
        }
    )

    print("ASLR Entropy Analysis")
    print("=" * 60)

    entropy = analyze_entropy(config)
    for region, data in entropy.items():
        if data["randomized"]:
            print(f"{region:8s}: {data['entropy_bits']:2d} bits "
                  f"({data['possible_addresses']:>12,} addresses)")

    print("\nBruteforce Complexity with 2-byte Leak")
    print("=" * 60)

    leak = LeakInfo(Region.LIBC, 2, 0)
    complexity = calculate_bruteforce_complexity(config, Region.LIBC, leak)
    print(f"Base entropy:      {complexity['base_entropy']} bits")
    print(f"Remaining entropy: {complexity['remaining_entropy']} bits")
    print(f"Attempts required: {complexity['attempts_required']:,}")
    print(f"Viable bruteforce: {complexity['viable_bruteforce']}")

    print("\nPartial Overwrite Analysis")
    print("=" * 60)

    partial = analyze_partial_leak_impact(config, leak, 0x500)
    print(f"Target offset:     0x{partial['target_offset']:x}")
    print(f"Same page:         {partial['same_page']}")
    print(f"Partial viable:    {partial['partial_overwrite_possible']}")

    print("\nArchitecture Comparison (LIBC)")
    print("=" * 60)

    comparison = compare_architectures(Region.LIBC)
    print(f"x86 entropy:  {comparison['x86']['entropy_bits']} bits")
    print(f"x64 entropy:  {comparison['x64']['entropy_bits']} bits")
    print(f"Difficulty ratio: {comparison['comparison']['difficulty_ratio']:.0f}x harder on x64")


if __name__ == "__main__":
    main()
```

---

## Section 4 : Fichier spec.json (ENGINE v22.1)

```json
{
  "exercise_id": "3.4.4-c",
  "title": "L'Entropie Révélée",
  "module": "3.4",
  "tier": 2,
  "difficulty": 7,
  "xp_value": 550,
  "language": "python",
  "version": "3.12",
  "timeout_seconds": 45,
  "memory_limit_mb": 256,

  "test_cases": [
    {
      "id": "entropy_x64_full",
      "description": "Analyze x64 full ASLR entropy",
      "input": {
        "function": "analyze_entropy",
        "args": {
          "config": {
            "architecture": "X64",
            "aslr_level": 2,
            "pie_enabled": true,
            "regions": {"STACK": true, "MMAP": true, "LIBC": true}
          }
        }
      },
      "expected": {
        "stack": {"entropy_bits": 30, "randomized": true},
        "mmap": {"entropy_bits": 28, "randomized": true},
        "libc": {"entropy_bits": 28, "randomized": true}
      },
      "points": 15
    },
    {
      "id": "entropy_x86_partial",
      "description": "Analyze x86 with partial ASLR",
      "input": {
        "function": "analyze_entropy",
        "args": {
          "config": {
            "architecture": "X86",
            "aslr_level": 1,
            "pie_enabled": false,
            "regions": {"STACK": true, "HEAP": true, "MMAP": true}
          }
        }
      },
      "expected": {
        "stack": {"entropy_bits": 19, "randomized": true},
        "heap": {"entropy_bits": 0, "randomized": false},
        "mmap": {"entropy_bits": 8, "randomized": true}
      },
      "points": 15
    },
    {
      "id": "bruteforce_no_leak",
      "description": "Bruteforce complexity without leak",
      "input": {
        "function": "calculate_bruteforce_complexity",
        "args": {
          "config": {
            "architecture": "X64",
            "aslr_level": 2,
            "pie_enabled": true,
            "regions": {"LIBC": true}
          },
          "target_region": "LIBC",
          "leak": null
        }
      },
      "expected": {
        "remaining_entropy": 28,
        "viable_bruteforce": false
      },
      "points": 15
    },
    {
      "id": "bruteforce_with_leak",
      "description": "Bruteforce complexity with 3-byte leak",
      "input": {
        "function": "calculate_bruteforce_complexity",
        "args": {
          "config": {
            "architecture": "X64",
            "aslr_level": 2,
            "pie_enabled": true,
            "regions": {"LIBC": true}
          },
          "target_region": "LIBC",
          "leak": {"region": "LIBC", "leaked_bytes": 3, "base_offset": 0}
        }
      },
      "expected": {
        "remaining_entropy": 16,
        "leak_reduction": 12,
        "viable_bruteforce": true
      },
      "points": 20
    },
    {
      "id": "partial_leak_same_page",
      "description": "Partial leak impact on same page",
      "input": {
        "function": "analyze_partial_leak_impact",
        "args": {
          "config": {
            "architecture": "X64",
            "aslr_level": 2,
            "pie_enabled": true,
            "regions": {"LIBC": true}
          },
          "leak": {"region": "LIBC", "leaked_bytes": 2, "base_offset": 0},
          "target_offset": 512
        }
      },
      "expected": {
        "same_page": true,
        "partial_overwrite_possible": true,
        "unknown_bits": 0
      },
      "points": 15
    },
    {
      "id": "partial_overwrite_payload",
      "description": "Generate 2-byte partial overwrite payload",
      "input": {
        "function": "generate_partial_overwrite_payload",
        "args": {
          "leak": {"region": "PIE", "leaked_bytes": 2, "base_offset": 4096},
          "target_offset": 4660,
          "payload_bytes": 2
        }
      },
      "expected": {
        "payload_int": 4660,
        "bytes_written": 2,
        "success_probability": 1.0
      },
      "points": 15
    },
    {
      "id": "compare_arch_mmap",
      "description": "Compare x86 vs x64 mmap entropy",
      "input": {
        "function": "compare_architectures",
        "args": {
          "target_region": "MMAP"
        }
      },
      "expected": {
        "x86": {"entropy_bits": 8, "bruteforce_viable": true},
        "x64": {"entropy_bits": 28, "bruteforce_viable": false}
      },
      "points": 15
    },
    {
      "id": "strategy_fork_available",
      "description": "Recommend strategy when fork available",
      "input": {
        "function": "recommend_bypass_strategy",
        "args": {
          "config": {
            "architecture": "X64",
            "aslr_level": 2,
            "pie_enabled": true,
            "regions": {"LIBC": true}
          },
          "available_leaks": [{"region": "LIBC", "leaked_bytes": 1, "base_offset": 0}],
          "constraints": {"max_attempts": 1000, "can_fork": true, "time_limit": 60.0}
        }
      },
      "expected": {
        "recommended_strategy": {"strategy": "fork_byte_leak"}
      },
      "points": 20
    }
  ],

  "edge_cases": [
    {
      "id": "aslr_disabled",
      "description": "ASLR completely disabled",
      "input": {
        "function": "analyze_entropy",
        "args": {
          "config": {
            "architecture": "X64",
            "aslr_level": 0,
            "pie_enabled": false,
            "regions": {}
          }
        }
      },
      "expected_behavior": "All regions show 0 entropy"
    },
    {
      "id": "full_leak",
      "description": "Leak all 6 bytes of address",
      "input": {
        "function": "calculate_bruteforce_complexity",
        "args": {
          "config": {"architecture": "X64", "aslr_level": 2, "pie_enabled": true, "regions": {"LIBC": true}},
          "target_region": "LIBC",
          "leak": {"region": "LIBC", "leaked_bytes": 6, "base_offset": 0}
        }
      },
      "expected_behavior": "Remaining entropy should be 0 or minimal"
    },
    {
      "id": "cross_page_partial",
      "description": "Partial overwrite spanning pages",
      "input": {
        "function": "analyze_partial_leak_impact",
        "args": {
          "config": {"architecture": "X64", "aslr_level": 2, "pie_enabled": true, "regions": {"PIE": true}},
          "leak": {"region": "PIE", "leaked_bytes": 2, "base_offset": 0},
          "target_offset": 65536
        }
      },
      "expected_behavior": "Should indicate need for additional bits"
    }
  ],

  "validation": {
    "required_functions": [
      "analyze_entropy",
      "calculate_bruteforce_complexity",
      "analyze_partial_leak_impact",
      "generate_partial_overwrite_payload",
      "recommend_bypass_strategy",
      "compare_architectures"
    ],
    "required_classes": ["Architecture", "Region", "ASLRConfig", "LeakInfo"],
    "forbidden_imports": ["os.system", "subprocess", "ctypes"],
    "min_test_coverage": 85
  }
}
```

---

## Section 5 : Tests de Mutation

```python
"""
Tests de mutation pour entropy_revealed.py
Vérifie la robustesse de l'implémentation contre les mutations.
"""

import unittest
from copy import deepcopy


class TestEntropyMutations(unittest.TestCase):
    """Tests de mutation pour l'analyse d'entropie."""

    def setUp(self):
        """Configuration commune."""
        from entropy_revealed import (
            ASLRConfig, Architecture, Region, LeakInfo,
            analyze_entropy, calculate_bruteforce_complexity,
            analyze_partial_leak_impact, generate_partial_overwrite_payload,
            compare_architectures, ENTROPY_TABLE
        )
        self.ASLRConfig = ASLRConfig
        self.Architecture = Architecture
        self.Region = Region
        self.LeakInfo = LeakInfo
        self.analyze_entropy = analyze_entropy
        self.calculate_bruteforce = calculate_bruteforce_complexity
        self.analyze_partial = analyze_partial_leak_impact
        self.generate_payload = generate_partial_overwrite_payload
        self.compare_arch = compare_architectures
        self.ENTROPY_TABLE = ENTROPY_TABLE

    # Mutant 1: Entropy values off by one
    def test_mutant_entropy_off_by_one(self):
        """MUTANT: entropy_bits += 1 for all regions."""
        config = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.STACK: True, self.Region.MMAP: True}
        )
        result = self.analyze_entropy(config)

        # Correct values from ENTROPY_TABLE
        self.assertEqual(result["stack"]["entropy_bits"], 30,
                        "Stack entropy should be exactly 30 bits")
        self.assertEqual(result["mmap"]["entropy_bits"], 28,
                        "Mmap entropy should be exactly 28 bits")

    # Mutant 2: Wrong architecture lookup
    def test_mutant_wrong_architecture(self):
        """MUTANT: Using X86 values for X64 architecture."""
        config_x64 = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.MMAP: True}
        )
        config_x86 = self.ASLRConfig(
            architecture=self.Architecture.X86,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.MMAP: True}
        )

        result_x64 = self.analyze_entropy(config_x64)
        result_x86 = self.analyze_entropy(config_x86)

        # X64 mmap should have 28 bits, X86 only 8 bits
        self.assertNotEqual(
            result_x64["mmap"]["entropy_bits"],
            result_x86["mmap"]["entropy_bits"],
            "X64 and X86 should have different entropy values"
        )

    # Mutant 3: Leak reduction formula wrong
    def test_mutant_leak_reduction_formula(self):
        """MUTANT: Not subtracting page offset bits from leak."""
        config = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.LIBC: True}
        )

        # 3 bytes leaked = 24 bits
        # Page offset = 12 bits (not entropic)
        # Effective leak = 24 - 12 = 12 bits
        # Remaining = 28 - 12 = 16 bits
        leak = self.LeakInfo(self.Region.LIBC, 3, 0)
        result = self.calculate_bruteforce(config, self.Region.LIBC, leak)

        self.assertEqual(result["remaining_entropy"], 16,
                        "Should account for 12-bit page offset in leak calculation")
        self.assertEqual(result["leak_reduction"], 12,
                        "Effective leak should be 12 bits (24 - 12)")

    # Mutant 4: Partial overwrite endianness wrong
    def test_mutant_payload_endianness(self):
        """MUTANT: Using big-endian instead of little-endian."""
        leak = self.LeakInfo(self.Region.PIE, 2, 0x1000)
        result = self.generate_payload(leak, 0x1234, 2)

        # Little-endian: 0x1234 -> bytes([0x34, 0x12])
        expected_le = bytes([0x34, 0x12])
        self.assertEqual(result["payload"], expected_le,
                        "Payload must be little-endian")

    # Mutant 5: ASLR level check inverted
    def test_mutant_aslr_level_logic(self):
        """MUTANT: Checking aslr_level > 2 instead of < 2 for heap."""
        config_level1 = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=1,
            pie_enabled=False,
            regions={self.Region.HEAP: True}
        )
        config_level2 = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=False,
            regions={self.Region.HEAP: True}
        )

        result1 = self.analyze_entropy(config_level1)
        result2 = self.analyze_entropy(config_level2)

        # Heap only randomized at level 2
        self.assertFalse(result1["heap"]["randomized"],
                        "Heap should NOT be randomized at ASLR level 1")
        self.assertTrue(result2["heap"]["randomized"],
                       "Heap SHOULD be randomized at ASLR level 2")


class TestBruteforceMutations(unittest.TestCase):
    """Tests de mutation pour les calculs de bruteforce."""

    def setUp(self):
        from entropy_revealed import (
            ASLRConfig, Architecture, Region, LeakInfo,
            calculate_bruteforce_complexity
        )
        self.ASLRConfig = ASLRConfig
        self.Architecture = Architecture
        self.Region = Region
        self.LeakInfo = LeakInfo
        self.calculate = calculate_bruteforce_complexity

    # Mutant 6: Division instead of bit shift
    def test_mutant_power_calculation(self):
        """MUTANT: Using /2 instead of ** for space calculation."""
        config = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.STACK: True}
        )

        result = self.calculate(config, self.Region.STACK, None)

        # 30 bits = 2^30 addresses, avg = 2^29 attempts
        expected_attempts = (2 ** 30) // 2
        self.assertEqual(result["attempts_required"], expected_attempts,
                        "Attempts should be 2^(entropy-1)")

    # Mutant 7: Viable threshold wrong
    def test_mutant_viable_threshold(self):
        """MUTANT: viable_bruteforce threshold set to 8 instead of 16."""
        config = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.LIBC: True}
        )

        # 4 bytes leaked = 32 bits - 12 = 20 bits effective
        # 28 - 20 = 8 bits remaining -> should be viable
        leak = self.LeakInfo(self.Region.LIBC, 4, 0)
        result = self.calculate(config, self.Region.LIBC, leak)

        # At 8 bits remaining (256 attempts), bruteforce is definitely viable
        if result["remaining_entropy"] <= 16:
            self.assertTrue(result["viable_bruteforce"],
                           f"Bruteforce should be viable at {result['remaining_entropy']} bits")


class TestPartialOverwriteMutations(unittest.TestCase):
    """Tests de mutation pour partial overwrite."""

    def setUp(self):
        from entropy_revealed import (
            ASLRConfig, Architecture, Region, LeakInfo,
            analyze_partial_leak_impact, generate_partial_overwrite_payload
        )
        self.ASLRConfig = ASLRConfig
        self.Architecture = Architecture
        self.Region = Region
        self.LeakInfo = LeakInfo
        self.analyze_partial = analyze_partial_leak_impact
        self.generate_payload = generate_partial_overwrite_payload

    # Mutant 8: Page size wrong
    def test_mutant_page_size(self):
        """MUTANT: Using 1024 instead of 4096 for page size."""
        config = self.ASLRConfig(
            architecture=self.Architecture.X64,
            aslr_level=2,
            pie_enabled=True,
            regions={self.Region.PIE: True}
        )

        # Offset 2048 is on page 0 (4096-byte pages)
        leak = self.LeakInfo(self.Region.PIE, 2, 0)
        result = self.analyze_partial(config, leak, 2048)

        self.assertTrue(result["same_page"],
                       "Offset 2048 should be on same page (page size = 4096)")

    # Mutant 9: Mask calculation wrong
    def test_mutant_payload_mask(self):
        """MUTANT: Using wrong mask for payload extraction."""
        leak = self.LeakInfo(self.Region.PIE, 2, 0)

        # Target 0x12345 with 2 bytes should give 0x2345
        result = self.generate_payload(leak, 0x12345, 2)

        # 2 bytes = 16 bits mask = 0xFFFF
        expected_value = 0x12345 & 0xFFFF  # = 0x2345
        self.assertEqual(result["payload_int"], expected_value,
                        "Payload should be masked correctly")


class TestComparisonMutations(unittest.TestCase):
    """Tests de mutation pour la comparaison d'architectures."""

    def setUp(self):
        from entropy_revealed import (
            Architecture, Region, compare_architectures
        )
        self.Architecture = Architecture
        self.Region = Region
        self.compare = compare_architectures

    # Mutant 10: Swapped architecture values
    def test_mutant_swapped_architectures(self):
        """MUTANT: Returning x86 values in x64 field and vice versa."""
        result = self.compare(self.Region.MMAP)

        # X64 should always have higher entropy than X86 for mmap
        self.assertGreater(
            result["x64"]["entropy_bits"],
            result["x86"]["entropy_bits"],
            "X64 must have higher entropy than X86"
        )

        # Specific values
        self.assertEqual(result["x64"]["entropy_bits"], 28)
        self.assertEqual(result["x86"]["entropy_bits"], 8)


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

---

## Section 6 : QCM d'Auto-Évaluation

### Question 1
**Quelle est l'entropie ASLR de la stack sur Linux x86-64 ?**

- [ ] A) 19 bits
- [x] B) 30 bits
- [ ] C) 28 bits
- [ ] D) 40 bits

**Explication**: Sur x86-64 Linux, la stack a 30 bits d'entropie ASLR, permettant environ 1 milliard de positions possibles. La valeur 19 bits correspond à x86 32-bit.

---

### Question 2
**Si vous avez un leak de 3 bytes d'une adresse libc sur x64 (ASLR full), combien de bits d'entropie restent ?**

- [ ] A) 4 bits
- [x] B) 16 bits
- [ ] C) 28 bits
- [ ] D) 24 bits

**Explication**: Base = 28 bits. Leak = 24 bits, mais 12 bits sont l'offset dans la page (non-entropiques). Réduction effective = 24-12 = 12 bits. Restant = 28-12 = 16 bits.

---

### Question 3
**Pourquoi le bruteforce ASLR est-il viable sur x86 32-bit mais pas sur x64 ?**

- [ ] A) x86 n'a pas d'ASLR
- [ ] B) x64 a des protections supplémentaires
- [x] C) x86 mmap n'a que 8 bits d'entropie vs 28 bits sur x64
- [ ] D) Le bruteforce est impossible sur les deux

**Explication**: Sur x86, mmap et PIE n'ont que 8 bits d'entropie (256 positions), rendant le bruteforce rapide. Sur x64, 28 bits signifie 268 millions de positions.

---

### Question 4
**Qu'est-ce qu'un partial overwrite permet de faire ?**

- [ ] A) Désactiver complètement ASLR
- [x] B) Modifier seulement les LSB d'une adresse pour cibler une adresse proche
- [ ] C) Leaker le canary
- [ ] D) Bypasser PIE complètement

**Explication**: Le partial overwrite écrit seulement les bytes de poids faible (LSB) d'une adresse, permettant de rediriger vers une cible proche sans connaître les bits de poids fort randomisés par ASLR.

---

### Question 5
**Dans quel cas un service qui fork() facilite-t-il le bypass ASLR ?**

- [ ] A) fork() désactive ASLR pour les enfants
- [ ] B) fork() réduit l'entropie de moitié
- [x] C) Les processus enfants héritent du même layout ASLR que le parent
- [ ] D) fork() crée une primitive de lecture automatique

**Explication**: fork() copie le processus entier, incluant le layout mémoire ASLR. Cela permet de faire des tentatives multiples contre la même disposition, et d'utiliser un oracle crash/no-crash pour leaker byte par byte.

---

### Question 6
**Quelle est la différence entre ASLR level 1 et level 2 sous Linux ?**

- [ ] A) Level 2 ajoute la randomisation de la stack
- [x] B) Level 2 ajoute la randomisation du heap (brk)
- [ ] C) Level 2 active PIE automatiquement
- [ ] D) Les deux sont identiques

**Explication**: ASLR level 1 randomise stack, mmap et VDSO. Level 2 ajoute la randomisation du heap (zone brk). PIE est une option de compilation séparée.

---

### Question 7
**Comment PIE affecte-t-il l'exploitation par rapport à un binaire non-PIE ?**

- [ ] A) PIE empêche complètement l'exploitation
- [x] B) PIE randomise les adresses du binaire lui-même, nécessitant un leak
- [ ] C) PIE ne change rien si ASLR est activé
- [ ] D) PIE rend le heap non-exécutable

**Explication**: PIE (Position Independent Executable) randomise l'adresse de base du binaire. Sans PIE, les gadgets ROP dans le binaire principal sont à des adresses fixes et utilisables directement.

---

### Question 8
**Quelle stratégie utiliser si l'entropie restante après leak est de 20 bits et qu'on ne peut pas fork() ?**

- [ ] A) Bruteforce direct (seulement 1 million de tentatives)
- [ ] B) Partial overwrite
- [x] C) Chercher un leak supplémentaire pour réduire l'entropie
- [ ] D) Abandonner l'exploitation

**Explication**: 20 bits = ~1 million de positions. Sans fork(), chaque crash peut alerter et le service peut avoir des protections. Il vaut mieux chercher un leak supplémentaire pour descendre sous 16 bits.

---

## Section 7 : Conseils et Pièges

### Pièges Courants

1. **Oublier l'offset de page**: Les 12 bits LSB ne sont pas entropiques (offset dans la page 4KB).

2. **Confondre architectures**: x86 et x64 ont des entropies très différentes.

3. **Ignorer l'alignement**: Les adresses sont alignées sur des frontières spécifiques.

4. **Endianness du payload**: x86/x64 sont little-endian.

5. **Surestimer le bruteforce**: Même 16 bits = 65536 tentatives, peut être détecté.

### Bonnes Pratiques

```python
# Toujours vérifier l'architecture avant d'appliquer les valeurs d'entropie
entropy = ENTROPY_TABLE[config.architecture][region]

# Calculer correctement l'entropie restante après leak
effective_leak = max(0, leaked_bytes * 8 - 12)  # -12 pour offset page
remaining = max(0, base_entropy - effective_leak)

# Générer les payloads en little-endian
payload = target_offset.to_bytes(num_bytes, 'little')

# Vérifier si la cible est atteignable par partial overwrite
max_reachable = (1 << (payload_bytes * 8)) - 1
reachable = target_offset <= max_reachable
```

---

## Section 8 : Ressources et Références

### Documentation Officielle
- Linux ASLR: kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html
- ELF PIE: man7.org/linux/man-pages/man8/ld.so.8.html

### Papers Académiques
- "On the Effectiveness of ASLR" - Shacham et al.
- "ASLR-Guard: Stopping Address Space Leakage" - Lu et al.

### Ressources Pratiques
- Phrack: "Bypassing PaX ASLR protection"
- CTF Wiki: ASLR bypass techniques

---

## Barème de Notation

| Critère | Points |
|---------|--------|
| analyze_entropy correct | 20 |
| calculate_bruteforce_complexity | 25 |
| analyze_partial_leak_impact | 20 |
| generate_partial_overwrite_payload | 15 |
| recommend_bypass_strategy | 15 |
| compare_architectures | 5 |
| **Total** | **100** |

### Seuils
- **A** (90-100): Maîtrise complète de l'analyse ASLR
- **B** (75-89): Bonne compréhension, quelques imprécisions
- **C** (60-74): Concepts de base acquis
- **D** (45-59): Compréhension partielle
- **F** (<45): Révision nécessaire
