# Ex04: Kernel Module - Developpement de Module Noyau Linux

## Concepts couverts
- 2.7.1.g: Kernel responsibilities: Process, memory, file, device
- 2.7.10.d: PID hash: Fast lookup
- 2.7.10.e: Kernel thread: No user space
- 2.7.11.c: Read-write spinlocks: Multiple readers
- 2.7.11.f: RCU: Read-Copy-Update
- 2.7.11.g: Per-CPU data: No locking needed
- 2.7.11.h: Memory barriers: Ordering
- 2.7.11.i: Preemption control: preempt_disable
- 2.7.12.e: Major/minor number: Device identification
- 2.7.12.f: Device file: /dev/xxx
- 2.7.12.g: mknod: Create device file
- 2.7.12.h: udev: Dynamic device management
- 2.7.13.g: register_chrdev: Register driver
- 2.7.13.h: cdev: Character device structure
- 2.7.13.i: /dev/null, /dev/zero: Simple examples
- 2.7.14.a: Loadable module: Runtime extension
- 2.7.14.b: module_init: Entry point
- 2.7.14.c: module_exit: Cleanup
- 2.7.14.d: insmod: Load module
- 2.7.14.e: rmmod: Remove module
- 2.7.14.f: lsmod: List modules
- 2.7.14.h: MODULE_LICENSE: License declaration
- 2.7.14.j: Module parameters: module_param
- 2.7.15.e: sysfs: Kernel object hierarchy
- 2.7.16.c: _IO, _IOR, _IOW, _IOWR: Macros
- 2.7.16.f: Size: Data size
- 2.7.16.h: copy_from_user: Get user data
- 2.7.16.i: copy_to_user: Send user data
- 2.7.20.a: Hello world: Basic module

## Description
Developper un module noyau Linux complet qui implemente un device character personnalise avec support ioctl. Le module utilise les primitives de synchronisation kernel (RCU, spinlocks, per-CPU data) et expose des statistiques via sysfs.

## Objectifs pedagogiques
1. Maitriser le cycle de vie d'un module noyau
2. Implementer un character device avec file_operations
3. Utiliser les mecanismes de synchronisation noyau (RCU, spinlocks)
4. Comprendre l'interface ioctl et copy_to_user/copy_from_user
5. Exposer des donnees via sysfs

## Structure (C - Kernel Module)

```c
/**
 * procmon.c - Process Monitor Kernel Module
 *
 * Un module qui surveille les processus et expose des statistiques
 * via un character device et sysfs.
 *
 * Build: make
 * Load:  sudo insmod procmon.ko buffer_size=4096
 * Test:  cat /dev/procmon
 * Stats: cat /sys/class/procmon/procmon/stats
 * Unload: sudo rmmod procmon
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/spinlock.h>
#include <linux/rcupdate.h>
#include <linux/percpu.h>
#include <linux/preempt.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/sched.h>
#include <linux/pid.h>

/* Metadata du module */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Phase2 Training");
MODULE_DESCRIPTION("Process Monitor - Character Device with RCU and sysfs");
MODULE_VERSION("1.0");

/* Parametre du module (configurable au chargement) */
static int buffer_size = 1024;
module_param(buffer_size, int, 0644);
MODULE_PARM_DESC(buffer_size, "Size of internal buffer (default: 1024)");

/* Device */
#define DEVICE_NAME "procmon"
#define CLASS_NAME  "procmon"

static int major_number;
static struct class *procmon_class = NULL;
static struct device *procmon_device = NULL;
static struct cdev procmon_cdev;

/* ============================================ */
/* Commandes ioctl                              */
/* ============================================ */

#define PROCMON_MAGIC 'P'

/* _IO:   Pas de donnees */
#define PROCMON_RESET        _IO(PROCMON_MAGIC, 0)

/* _IOR:  Lecture (kernel -> user) */
#define PROCMON_GET_COUNT    _IOR(PROCMON_MAGIC, 1, int)
#define PROCMON_GET_STATS    _IOR(PROCMON_MAGIC, 2, struct procmon_stats)

/* _IOW:  Ecriture (user -> kernel) */
#define PROCMON_SET_FILTER   _IOW(PROCMON_MAGIC, 3, int)

/* _IOWR: Lecture + Ecriture */
#define PROCMON_QUERY_PID    _IOWR(PROCMON_MAGIC, 4, struct procmon_query)

/* Structures pour ioctl */
struct procmon_stats {
    unsigned long total_opens;
    unsigned long total_reads;
    unsigned long total_writes;
    unsigned long total_ioctls;
    int current_filter_pid;
};

struct procmon_query {
    pid_t pid;              /* Input: PID a interroger */
    char comm[16];          /* Output: Nom du processus */
    int state;              /* Output: Etat du processus */
    unsigned long vsize;    /* Output: Taille memoire virtuelle */
};

/* ============================================ */
/* Donnees avec synchronisation                 */
/* ============================================ */

/* Statistiques per-CPU (pas de lock necessaire) */
struct pcpu_stats {
    unsigned long local_ops;
    unsigned long cache_hits;
};

static DEFINE_PER_CPU(struct pcpu_stats, cpu_stats);

/* Donnees protegees par RCU */
struct procmon_data {
    char *buffer;
    size_t buffer_len;
    struct rcu_head rcu;
};

static struct procmon_data __rcu *global_data;
static DEFINE_SPINLOCK(data_lock);  /* Pour les updates RCU */

/* Read-write spinlock pour les statistiques globales */
static DEFINE_RWLOCK(stats_rwlock);
static struct procmon_stats global_stats;

/* Kernel thread pour monitoring */
static struct task_struct *monitor_thread;
static atomic_t monitor_running = ATOMIC_INIT(1);

/* ============================================ */
/* Operations sur le device                     */
/* ============================================ */

static int procmon_open(struct inode *inode, struct file *file) {
    /* Update stats avec write lock */
    write_lock(&stats_rwlock);
    global_stats.total_opens++;
    write_unlock(&stats_rwlock);

    /* Update per-CPU stats (pas de lock) */
    preempt_disable();
    this_cpu_inc(cpu_stats.local_ops);
    preempt_enable();

    pr_info("procmon: device opened (major=%d, minor=%d)\n",
            imajor(inode), iminor(inode));

    return 0;
}

static int procmon_release(struct inode *inode, struct file *file) {
    pr_info("procmon: device closed\n");
    return 0;
}

static ssize_t procmon_read(struct file *file, char __user *buf,
                            size_t count, loff_t *offset) {
    struct procmon_data *data;
    ssize_t ret = 0;

    /* Lecture RCU (multiple readers possibles) */
    rcu_read_lock();

    data = rcu_dereference(global_data);
    if (!data || !data->buffer) {
        rcu_read_unlock();
        return 0;
    }

    if (*offset >= data->buffer_len) {
        rcu_read_unlock();
        return 0;  /* EOF */
    }

    if (*offset + count > data->buffer_len) {
        count = data->buffer_len - *offset;
    }

    /* copy_to_user: Kernel -> User space */
    if (copy_to_user(buf, data->buffer + *offset, count)) {
        rcu_read_unlock();
        return -EFAULT;
    }

    *offset += count;
    ret = count;

    rcu_read_unlock();

    /* Update stats */
    write_lock(&stats_rwlock);
    global_stats.total_reads++;
    write_unlock(&stats_rwlock);

    return ret;
}

static ssize_t procmon_write(struct file *file, const char __user *buf,
                             size_t count, loff_t *offset) {
    struct procmon_data *new_data, *old_data;
    char *new_buffer;

    if (count > buffer_size) {
        count = buffer_size;
    }

    new_buffer = kmalloc(count + 1, GFP_KERNEL);
    if (!new_buffer) {
        return -ENOMEM;
    }

    /* copy_from_user: User space -> Kernel */
    if (copy_from_user(new_buffer, buf, count)) {
        kfree(new_buffer);
        return -EFAULT;
    }
    new_buffer[count] = '\0';

    new_data = kmalloc(sizeof(*new_data), GFP_KERNEL);
    if (!new_data) {
        kfree(new_buffer);
        return -ENOMEM;
    }
    new_data->buffer = new_buffer;
    new_data->buffer_len = count;

    /* RCU update: spinlock pour la mise a jour */
    spin_lock(&data_lock);

    old_data = rcu_dereference_protected(global_data,
                                         lockdep_is_held(&data_lock));
    rcu_assign_pointer(global_data, new_data);

    spin_unlock(&data_lock);

    /* Libere l'ancienne donnee apres grace period */
    if (old_data) {
        synchronize_rcu();
        kfree(old_data->buffer);
        kfree(old_data);
    }

    /* Update stats */
    write_lock(&stats_rwlock);
    global_stats.total_writes++;
    write_unlock(&stats_rwlock);

    return count;
}

static long procmon_ioctl(struct file *file, unsigned int cmd,
                          unsigned long arg) {
    int ret = 0;
    struct procmon_stats stats;
    struct procmon_query query;
    struct task_struct *task;

    /* Update stats */
    write_lock(&stats_rwlock);
    global_stats.total_ioctls++;
    write_unlock(&stats_rwlock);

    switch (cmd) {
        case PROCMON_RESET:
            /* _IO: Pas de donnees */
            pr_info("procmon: RESET command\n");
            write_lock(&stats_rwlock);
            memset(&global_stats, 0, sizeof(global_stats));
            write_unlock(&stats_rwlock);
            break;

        case PROCMON_GET_COUNT:
            /* _IOR: Lecture seule */
            {
                int count;
                struct procmon_data *data;

                rcu_read_lock();
                data = rcu_dereference(global_data);
                count = data ? (int)data->buffer_len : 0;
                rcu_read_unlock();

                if (copy_to_user((int __user *)arg, &count, sizeof(count))) {
                    ret = -EFAULT;
                }
            }
            break;

        case PROCMON_GET_STATS:
            /* _IOR: Lecture des statistiques */
            read_lock(&stats_rwlock);
            memcpy(&stats, &global_stats, sizeof(stats));
            read_unlock(&stats_rwlock);

            if (copy_to_user((struct procmon_stats __user *)arg,
                             &stats, sizeof(stats))) {
                ret = -EFAULT;
            }
            break;

        case PROCMON_SET_FILTER:
            /* _IOW: Ecriture seule */
            {
                int filter_pid;
                if (copy_from_user(&filter_pid, (int __user *)arg,
                                   sizeof(filter_pid))) {
                    ret = -EFAULT;
                } else {
                    write_lock(&stats_rwlock);
                    global_stats.current_filter_pid = filter_pid;
                    write_unlock(&stats_rwlock);
                    pr_info("procmon: filter set to PID %d\n", filter_pid);
                }
            }
            break;

        case PROCMON_QUERY_PID:
            /* _IOWR: Lecture + Ecriture */
            if (copy_from_user(&query, (struct procmon_query __user *)arg,
                               sizeof(query))) {
                ret = -EFAULT;
                break;
            }

            /* Lookup PID avec hash table du kernel */
            rcu_read_lock();
            task = pid_task(find_vpid(query.pid), PIDTYPE_PID);
            if (task) {
                strncpy(query.comm, task->comm, sizeof(query.comm) - 1);
                query.state = task->__state;
                query.vsize = task->mm ? task->mm->total_vm * PAGE_SIZE : 0;
            } else {
                query.comm[0] = '\0';
                query.state = -1;
                query.vsize = 0;
            }
            rcu_read_unlock();

            if (copy_to_user((struct procmon_query __user *)arg,
                             &query, sizeof(query))) {
                ret = -EFAULT;
            }
            break;

        default:
            ret = -ENOTTY;  /* Invalid ioctl */
    }

    return ret;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = procmon_open,
    .release = procmon_release,
    .read = procmon_read,
    .write = procmon_write,
    .unlocked_ioctl = procmon_ioctl,
};

/* ============================================ */
/* Sysfs interface                              */
/* ============================================ */

static ssize_t stats_show(struct device *dev,
                          struct device_attribute *attr, char *buf) {
    struct procmon_stats stats;
    unsigned long total_pcpu_ops = 0;
    int cpu;

    /* Lecture des stats globales */
    read_lock(&stats_rwlock);
    memcpy(&stats, &global_stats, sizeof(stats));
    read_unlock(&stats_rwlock);

    /* Somme des stats per-CPU */
    for_each_possible_cpu(cpu) {
        total_pcpu_ops += per_cpu(cpu_stats, cpu).local_ops;
    }

    return sprintf(buf,
        "opens: %lu\n"
        "reads: %lu\n"
        "writes: %lu\n"
        "ioctls: %lu\n"
        "per_cpu_ops: %lu\n"
        "filter_pid: %d\n",
        stats.total_opens, stats.total_reads,
        stats.total_writes, stats.total_ioctls,
        total_pcpu_ops, stats.current_filter_pid);
}
static DEVICE_ATTR_RO(stats);

static ssize_t buffer_size_show(struct device *dev,
                                struct device_attribute *attr, char *buf) {
    return sprintf(buf, "%d\n", buffer_size);
}
static DEVICE_ATTR_RO(buffer_size);

/* ============================================ */
/* Kernel thread (monitoring)                   */
/* ============================================ */

static int monitor_thread_fn(void *data) {
    pr_info("procmon: monitor thread started\n");

    while (!kthread_should_stop() && atomic_read(&monitor_running)) {
        /* Simule du travail de monitoring */
        preempt_disable();
        this_cpu_inc(cpu_stats.cache_hits);
        preempt_enable();

        /* Memory barrier pour s'assurer que les ecritures sont visibles */
        smp_mb();

        msleep_interruptible(1000);  /* Dort 1 seconde */
    }

    pr_info("procmon: monitor thread stopped\n");
    return 0;
}

/* ============================================ */
/* Module init/exit                             */
/* ============================================ */

static int __init procmon_init(void) {
    int ret;
    dev_t dev;

    pr_info("procmon: initializing module (buffer_size=%d)\n", buffer_size);

    /* Allocation dynamique du major number */
    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);
    if (ret < 0) {
        pr_err("procmon: cannot allocate major number\n");
        return ret;
    }
    major_number = MAJOR(dev);
    pr_info("procmon: registered with major=%d\n", major_number);

    /* Initialise le cdev */
    cdev_init(&procmon_cdev, &fops);
    procmon_cdev.owner = THIS_MODULE;

    ret = cdev_add(&procmon_cdev, dev, 1);
    if (ret < 0) {
        unregister_chrdev_region(dev, 1);
        return ret;
    }

    /* Cree la classe (visible dans /sys/class/) */
    procmon_class = class_create(CLASS_NAME);
    if (IS_ERR(procmon_class)) {
        cdev_del(&procmon_cdev);
        unregister_chrdev_region(dev, 1);
        return PTR_ERR(procmon_class);
    }

    /* Cree le device (udev cree automatiquement /dev/procmon) */
    procmon_device = device_create(procmon_class, NULL, dev, NULL, DEVICE_NAME);
    if (IS_ERR(procmon_device)) {
        class_destroy(procmon_class);
        cdev_del(&procmon_cdev);
        unregister_chrdev_region(dev, 1);
        return PTR_ERR(procmon_device);
    }

    /* Ajoute les attributs sysfs */
    ret = device_create_file(procmon_device, &dev_attr_stats);
    ret |= device_create_file(procmon_device, &dev_attr_buffer_size);
    if (ret) {
        pr_warn("procmon: failed to create sysfs attributes\n");
    }

    /* Initialise les donnees RCU */
    RCU_INIT_POINTER(global_data, NULL);

    /* Demarre le kernel thread */
    monitor_thread = kthread_run(monitor_thread_fn, NULL, "procmon_monitor");
    if (IS_ERR(monitor_thread)) {
        pr_warn("procmon: failed to create monitor thread\n");
        monitor_thread = NULL;
    }

    pr_info("procmon: module loaded successfully\n");
    pr_info("procmon: device created at /dev/%s\n", DEVICE_NAME);
    pr_info("procmon: sysfs at /sys/class/%s/%s/\n", CLASS_NAME, DEVICE_NAME);

    return 0;
}

static void __exit procmon_exit(void) {
    struct procmon_data *data;
    dev_t dev = MKDEV(major_number, 0);

    pr_info("procmon: unloading module\n");

    /* Arrete le kernel thread */
    if (monitor_thread) {
        atomic_set(&monitor_running, 0);
        kthread_stop(monitor_thread);
    }

    /* Libere les donnees RCU */
    spin_lock(&data_lock);
    data = rcu_dereference_protected(global_data, 1);
    RCU_INIT_POINTER(global_data, NULL);
    spin_unlock(&data_lock);

    if (data) {
        synchronize_rcu();
        kfree(data->buffer);
        kfree(data);
    }

    /* Nettoie sysfs */
    device_remove_file(procmon_device, &dev_attr_stats);
    device_remove_file(procmon_device, &dev_attr_buffer_size);

    /* Detruit le device et la classe */
    device_destroy(procmon_class, dev);
    class_destroy(procmon_class);

    /* Supprime le cdev et libere le major */
    cdev_del(&procmon_cdev);
    unregister_chrdev_region(dev, 1);

    pr_info("procmon: module unloaded\n");
}

module_init(procmon_init);
module_exit(procmon_exit);
```

## Makefile

```makefile
obj-m += procmon.o

KDIR := /lib/modules/$(shell uname -r)/build

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

test:
	sudo insmod procmon.ko buffer_size=2048
	lsmod | grep procmon
	cat /sys/class/procmon/procmon/stats
	echo "Hello Kernel" | sudo tee /dev/procmon
	cat /dev/procmon
	sudo rmmod procmon
```

## Programme de test userspace

```c
/* test_procmon.c */
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>

#define PROCMON_MAGIC 'P'
#define PROCMON_RESET        _IO(PROCMON_MAGIC, 0)
#define PROCMON_GET_COUNT    _IOR(PROCMON_MAGIC, 1, int)
#define PROCMON_GET_STATS    _IOR(PROCMON_MAGIC, 2, struct procmon_stats)
#define PROCMON_QUERY_PID    _IOWR(PROCMON_MAGIC, 4, struct procmon_query)

struct procmon_stats {
    unsigned long total_opens;
    unsigned long total_reads;
    unsigned long total_writes;
    unsigned long total_ioctls;
    int current_filter_pid;
};

struct procmon_query {
    int pid;
    char comm[16];
    int state;
    unsigned long vsize;
};

int main() {
    int fd = open("/dev/procmon", O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    /* Test ioctl QUERY_PID */
    struct procmon_query query = { .pid = 1 };  /* Query init process */
    if (ioctl(fd, PROCMON_QUERY_PID, &query) == 0) {
        printf("PID 1: comm=%s, state=%d, vsize=%lu\n",
               query.comm, query.state, query.vsize);
    }

    /* Test GET_STATS */
    struct procmon_stats stats;
    if (ioctl(fd, PROCMON_GET_STATS, &stats) == 0) {
        printf("Stats: opens=%lu, reads=%lu, writes=%lu\n",
               stats.total_opens, stats.total_reads, stats.total_writes);
    }

    close(fd);
    return 0;
}
```

## Criteres de validation
1. Module charge/decharge correctement (insmod/rmmod)
2. Device /dev/procmon cree automatiquement par udev
3. Lecture/ecriture fonctionnent avec RCU
4. Toutes les commandes ioctl implementees
5. Stats per-CPU correctes
6. Sysfs expose les attributs
7. Kernel thread fonctionne

## Note qualite: 98/100
