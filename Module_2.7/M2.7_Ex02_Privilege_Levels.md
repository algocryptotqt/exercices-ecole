# Ex05: Privilege Levels - Simulateur de Niveaux de Privilege x86

## Concepts couverts
- 2.7.2.b: RAX-RDX, RSI, RDI: GP registers
- 2.7.2.c: RSP, RBP: Stack and base pointer
- 2.7.3.f: DPL: Descriptor privilege level
- 2.7.3.g: RPL: Requested privilege level
- 2.7.3.h: Privilege check: CPL <= DPL
- 2.7.3.i: Mode switching: Via interrupts/syscalls
- 2.7.5.k: iret: Return from interrupt
- 2.7.6.i: CR2: Page fault address
- 2.7.7.d: sysenter/sysexit: Fast path (x86)
- 2.7.7.f: Arguments: In registers
- 2.7.8.d: Where saved: PCB, kernel stack
- 2.7.8.f: switch_to: Linux macro
- 2.7.9.b: Identity mapping: Physical = virtual
- 2.7.9.c: vmalloc: Non-contiguous allocation
- 2.7.9.d: kmalloc: Contiguous allocation

## Description
Implementer un simulateur educatif en Rust qui modelise les niveaux de privilege x86-64, les context switches, et les mecanismes de transition user/kernel. Le simulateur permet de visualiser CPL, DPL, RPL et les verifications de privileges.

## Objectifs pedagogiques
1. Comprendre le modele de protection x86 (rings 0-3)
2. Maitriser les mecanismes de transition user <-> kernel
3. Visualiser le context switch et la sauvegarde des registres
4. Comprendre la difference entre kmalloc et vmalloc

## Structure (Rust 2024)

```rust
//! x86-64 Privilege Level Simulator
//!
//! Simule les niveaux de privilege, context switches et syscalls

use std::collections::HashMap;
use std::fmt;

/// Niveau de privilege (Ring)
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(u8)]
pub enum PrivilegeLevel {
    Ring0 = 0,  // Kernel mode
    Ring1 = 1,  // (Rarement utilise)
    Ring2 = 2,  // (Rarement utilise)
    Ring3 = 3,  // User mode
}

impl fmt::Display for PrivilegeLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PrivilegeLevel::Ring0 => write!(f, "Ring 0 (Kernel)"),
            PrivilegeLevel::Ring1 => write!(f, "Ring 1"),
            PrivilegeLevel::Ring2 => write!(f, "Ring 2"),
            PrivilegeLevel::Ring3 => write!(f, "Ring 3 (User)"),
        }
    }
}

/// Registres generaux x86-64
#[derive(Debug, Clone, Default)]
pub struct GeneralRegisters {
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rsi: u64,  // Source index / arg2
    pub rdi: u64,  // Destination index / arg1
    pub rbp: u64,  // Base pointer
    pub rsp: u64,  // Stack pointer
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
    pub rip: u64,  // Instruction pointer
    pub rflags: u64,
}

/// Registres de controle
#[derive(Debug, Clone, Default)]
pub struct ControlRegisters {
    pub cr0: u64,  // Control register 0 (PE, PG bits)
    pub cr2: u64,  // Page fault linear address
    pub cr3: u64,  // Page directory base (PDBR)
    pub cr4: u64,  // Extensions (PAE, PSE, etc.)
}

impl ControlRegisters {
    /// CR2 contient l'adresse qui a cause un page fault
    pub fn set_page_fault_address(&mut self, addr: u64) {
        self.cr2 = addr;
    }
}

/// Segment selector avec RPL
#[derive(Debug, Clone, Copy)]
pub struct SegmentSelector {
    pub index: u16,          // Index dans GDT/LDT
    pub table_indicator: bool, // false = GDT, true = LDT
    pub rpl: PrivilegeLevel,  // Requested Privilege Level
}

impl SegmentSelector {
    pub fn new(index: u16, rpl: PrivilegeLevel) -> Self {
        Self {
            index,
            table_indicator: false,
            rpl,
        }
    }

    pub fn to_raw(&self) -> u16 {
        (self.index << 3) |
        ((self.table_indicator as u16) << 2) |
        (self.rpl as u16)
    }
}

/// Descripteur de segment (simplifie)
#[derive(Debug, Clone)]
pub struct SegmentDescriptor {
    pub base: u64,
    pub limit: u32,
    pub dpl: PrivilegeLevel,  // Descriptor Privilege Level
    pub is_code: bool,
    pub is_system: bool,
    pub present: bool,
}

impl SegmentDescriptor {
    pub fn kernel_code() -> Self {
        Self {
            base: 0,
            limit: 0xFFFFFFFF,
            dpl: PrivilegeLevel::Ring0,
            is_code: true,
            is_system: false,
            present: true,
        }
    }

    pub fn user_code() -> Self {
        Self {
            base: 0,
            limit: 0xFFFFFFFF,
            dpl: PrivilegeLevel::Ring3,
            is_code: true,
            is_system: false,
            present: true,
        }
    }
}

/// Etat sauvegarde lors d'un context switch (sur kernel stack)
#[derive(Debug, Clone)]
pub struct SavedContext {
    pub regs: GeneralRegisters,
    pub cs: SegmentSelector,
    pub ss: SegmentSelector,
    pub cpl: PrivilegeLevel,
}

/// Process Control Block (PCB)
#[derive(Debug, Clone)]
pub struct ProcessControlBlock {
    pub pid: u32,
    pub name: String,
    pub saved_context: Option<SavedContext>,
    pub kernel_stack: Vec<u64>,  // Kernel stack pour ce processus
    pub user_stack_ptr: u64,
    pub page_table_base: u64,    // CR3 pour ce processus
}

/// Syscall info (convention x86-64)
#[derive(Debug)]
pub struct SyscallInfo {
    pub number: u64,   // Dans RAX
    pub arg1: u64,     // RDI
    pub arg2: u64,     // RSI
    pub arg3: u64,     // RDX
    pub arg4: u64,     // R10
    pub arg5: u64,     // R8
    pub arg6: u64,     // R9
}

/// Allocation memoire kernel
#[derive(Debug)]
pub enum KernelAllocation {
    /// kmalloc: memoire physique contigue
    Kmalloc {
        vaddr: u64,
        paddr: u64,  // Meme adresse avec identity mapping
        size: usize,
    },
    /// vmalloc: memoire virtuelle contigue, physique non-contigue
    Vmalloc {
        vaddr: u64,
        pages: Vec<u64>,  // Pages physiques non-contigues
        size: usize,
    },
}

/// Simulateur de CPU x86-64
pub struct Cpu {
    pub regs: GeneralRegisters,
    pub control: ControlRegisters,

    // Niveau de privilege courant
    pub cpl: PrivilegeLevel,

    // Selecteurs de segment
    pub cs: SegmentSelector,  // Code segment
    pub ss: SegmentSelector,  // Stack segment
    pub ds: SegmentSelector,
    pub es: SegmentSelector,
    pub fs: SegmentSelector,
    pub gs: SegmentSelector,

    // Tables
    pub gdt: Vec<SegmentDescriptor>,
    pub idt: Vec<u64>,  // Interrupt Descriptor Table (simplifie)

    // Processus
    pub current_process: Option<ProcessControlBlock>,
    pub process_table: HashMap<u32, ProcessControlBlock>,

    // Kernel stack
    pub kernel_stack: Vec<u64>,

    // Allocations memoire
    pub allocations: Vec<KernelAllocation>,

    // Stats
    pub context_switch_count: u64,
    pub syscall_count: u64,
}

impl Cpu {
    pub fn new() -> Self {
        let mut cpu = Self {
            regs: GeneralRegisters::default(),
            control: ControlRegisters::default(),
            cpl: PrivilegeLevel::Ring0,
            cs: SegmentSelector::new(1, PrivilegeLevel::Ring0),
            ss: SegmentSelector::new(2, PrivilegeLevel::Ring0),
            ds: SegmentSelector::new(3, PrivilegeLevel::Ring3),
            es: SegmentSelector::new(3, PrivilegeLevel::Ring3),
            fs: SegmentSelector::new(0, PrivilegeLevel::Ring3),
            gs: SegmentSelector::new(0, PrivilegeLevel::Ring3),
            gdt: Vec::new(),
            idt: vec![0; 256],
            current_process: None,
            process_table: HashMap::new(),
            kernel_stack: vec![0; 4096],
            allocations: Vec::new(),
            context_switch_count: 0,
            syscall_count: 0,
        };

        // Setup GDT
        cpu.gdt.push(SegmentDescriptor::kernel_code());  // 0: null
        cpu.gdt.push(SegmentDescriptor::kernel_code());  // 1: kernel code
        cpu.gdt.push(SegmentDescriptor::kernel_code());  // 2: kernel data
        cpu.gdt.push(SegmentDescriptor::user_code());    // 3: user code
        cpu.gdt.push(SegmentDescriptor::user_code());    // 4: user data

        cpu
    }

    /// Verification de privilege: CPL <= DPL
    ///
    /// Pour acceder a un segment, le CPL courant doit etre
    /// inferieur ou egal au DPL du descripteur cible.
    pub fn check_privilege(&self, selector: &SegmentSelector) -> Result<(), String> {
        let descriptor = self.gdt.get(selector.index as usize)
            .ok_or("Invalid segment selector")?;

        // Verification CPL <= DPL
        if (self.cpl as u8) > (descriptor.dpl as u8) {
            return Err(format!(
                "Privilege violation: CPL={} > DPL={}",
                self.cpl as u8, descriptor.dpl as u8
            ));
        }

        // Verification RPL <= DPL
        if (selector.rpl as u8) > (descriptor.dpl as u8) {
            return Err(format!(
                "RPL violation: RPL={} > DPL={}",
                selector.rpl as u8, descriptor.dpl as u8
            ));
        }

        Ok(())
    }

    /// Simule un syscall (instruction SYSCALL)
    ///
    /// Convention x86-64 Linux:
    /// - RAX: syscall number
    /// - RDI, RSI, RDX, R10, R8, R9: arguments
    /// - Return value in RAX
    pub fn syscall(&mut self) -> Result<SyscallInfo, String> {
        println!("\n=== SYSCALL ===");
        println!("Before: CPL = {}", self.cpl);

        // Sauvegarde RIP dans RCX (convention syscall)
        self.regs.rcx = self.regs.rip;
        // Sauvegarde RFLAGS dans R11
        self.regs.r11 = self.regs.rflags;

        let info = SyscallInfo {
            number: self.regs.rax,
            arg1: self.regs.rdi,
            arg2: self.regs.rsi,
            arg3: self.regs.rdx,
            arg4: self.regs.r10,
            arg5: self.regs.r8,
            arg6: self.regs.r9,
        };

        // Transition vers Ring 0
        self.cpl = PrivilegeLevel::Ring0;
        self.cs = SegmentSelector::new(1, PrivilegeLevel::Ring0);
        self.ss = SegmentSelector::new(2, PrivilegeLevel::Ring0);

        // Switch vers kernel stack
        let user_rsp = self.regs.rsp;
        self.regs.rsp = self.kernel_stack.len() as u64 * 8;  // Top of kernel stack

        println!("After: CPL = {}", self.cpl);
        println!("Syscall #{}: args = ({}, {}, {})",
                 info.number, info.arg1, info.arg2, info.arg3);
        println!("User RSP saved: 0x{:x}", user_rsp);

        self.syscall_count += 1;
        Ok(info)
    }

    /// Simule SYSRET (retour de syscall)
    pub fn sysret(&mut self) {
        println!("\n=== SYSRET ===");

        // Restaure RIP depuis RCX
        self.regs.rip = self.regs.rcx;
        // Restaure RFLAGS depuis R11
        self.regs.rflags = self.regs.r11;

        // Transition vers Ring 3
        self.cpl = PrivilegeLevel::Ring3;
        self.cs = SegmentSelector::new(3, PrivilegeLevel::Ring3);
        self.ss = SegmentSelector::new(4, PrivilegeLevel::Ring3);

        println!("Returned to user mode: CPL = {}", self.cpl);
    }

    /// Simule IRET (retour d'interruption)
    ///
    /// Pop depuis la stack: RIP, CS, RFLAGS, RSP, SS
    pub fn iret(&mut self) {
        println!("\n=== IRET ===");

        // Simule le pop de la stack
        // En realite, on pop: RIP, CS, RFLAGS, RSP, SS

        self.cpl = PrivilegeLevel::Ring3;  // Retour en user mode
        println!("IRET: returning to {}", self.cpl);
    }

    /// Context switch entre deux processus
    pub fn context_switch(&mut self, next_pid: u32) -> Result<(), String> {
        println!("\n=== CONTEXT SWITCH ===");

        // Sauvegarde le contexte du processus courant
        if let Some(ref mut current) = self.current_process {
            println!("Saving context of PID {}", current.pid);

            let saved = SavedContext {
                regs: self.regs.clone(),
                cs: self.cs,
                ss: self.ss,
                cpl: self.cpl,
            };
            current.saved_context = Some(saved);

            // Sauvegarde dans la process table
            self.process_table.insert(current.pid, current.clone());
        }

        // Restaure le contexte du prochain processus
        let next = self.process_table.get(&next_pid)
            .ok_or(format!("Process {} not found", next_pid))?
            .clone();

        println!("Restoring context of PID {} ({})", next.pid, next.name);

        if let Some(ref saved) = next.saved_context {
            self.regs = saved.regs.clone();
            self.cs = saved.cs;
            self.ss = saved.ss;
            self.cpl = saved.cpl;
        }

        // Change CR3 (page table base)
        self.control.cr3 = next.page_table_base;
        println!("CR3 = 0x{:x} (new page table)", self.control.cr3);

        self.current_process = Some(next);
        self.context_switch_count += 1;

        println!("Context switch complete");
        Ok(())
    }

    /// Simule kmalloc (allocation physique contigue)
    pub fn kmalloc(&mut self, size: usize) -> KernelAllocation {
        // Identity mapping: vaddr = paddr
        let addr = 0xFFFF_8000_0000_0000 + (self.allocations.len() as u64 * 0x1000);

        let alloc = KernelAllocation::Kmalloc {
            vaddr: addr,
            paddr: addr,  // Identity mapping
            size,
        };

        println!("kmalloc({}) = 0x{:x} (contiguous, identity mapped)", size, addr);
        self.allocations.push(alloc.clone());
        alloc
    }

    /// Simule vmalloc (allocation virtuelle contigue, physique non-contigue)
    pub fn vmalloc(&mut self, size: usize) -> KernelAllocation {
        let num_pages = (size + 4095) / 4096;
        let vaddr = 0xFFFF_C900_0000_0000 + (self.allocations.len() as u64 * 0x10000);

        // Pages physiques potentiellement non-contigues
        let pages: Vec<u64> = (0..num_pages)
            .map(|i| 0x1000_0000 + (i as u64 * 0x5000))  // Non-contiguous!
            .collect();

        let alloc = KernelAllocation::Vmalloc {
            vaddr,
            pages: pages.clone(),
            size,
        };

        println!("vmalloc({}) = 0x{:x}", size, vaddr);
        println!("  Physical pages (non-contiguous): {:x?}", pages);
        self.allocations.push(alloc.clone());
        alloc
    }

    /// Simule un page fault
    pub fn page_fault(&mut self, address: u64, is_write: bool) {
        println!("\n=== PAGE FAULT ===");

        // CR2 contient l'adresse fautive
        self.control.set_page_fault_address(address);

        println!("Fault address (CR2): 0x{:x}", self.control.cr2);
        println!("Fault type: {}", if is_write { "Write" } else { "Read" });

        // En realite, le kernel handle le fault
        // (demand paging, copy-on-write, etc.)
    }

    /// Affiche l'etat du CPU
    pub fn print_state(&self) {
        println!("\n=== CPU STATE ===");
        println!("CPL: {}", self.cpl);
        println!("CS: index={}, RPL={:?}", self.cs.index, self.cs.rpl);
        println!("SS: index={}, RPL={:?}", self.ss.index, self.ss.rpl);
        println!("\nGeneral Registers:");
        println!("  RAX=0x{:016x}  RBX=0x{:016x}", self.regs.rax, self.regs.rbx);
        println!("  RCX=0x{:016x}  RDX=0x{:016x}", self.regs.rcx, self.regs.rdx);
        println!("  RSI=0x{:016x}  RDI=0x{:016x}", self.regs.rsi, self.regs.rdi);
        println!("  RSP=0x{:016x}  RBP=0x{:016x}", self.regs.rsp, self.regs.rbp);
        println!("  RIP=0x{:016x}", self.regs.rip);
        println!("\nControl Registers:");
        println!("  CR0=0x{:x}  CR2=0x{:x}  CR3=0x{:x}  CR4=0x{:x}",
                 self.control.cr0, self.control.cr2,
                 self.control.cr3, self.control.cr4);
        println!("\nStats:");
        println!("  Context switches: {}", self.context_switch_count);
        println!("  Syscalls: {}", self.syscall_count);
    }
}

fn main() {
    println!("=== x86-64 Privilege Level Simulator ===\n");

    let mut cpu = Cpu::new();

    // Create some processes
    let p1 = ProcessControlBlock {
        pid: 1,
        name: "init".to_string(),
        saved_context: None,
        kernel_stack: vec![0; 1024],
        user_stack_ptr: 0x7FFF_FFFF_0000,
        page_table_base: 0x0010_0000,
    };

    let p2 = ProcessControlBlock {
        pid: 2,
        name: "shell".to_string(),
        saved_context: None,
        kernel_stack: vec![0; 1024],
        user_stack_ptr: 0x7FFF_FFFE_0000,
        page_table_base: 0x0020_0000,
    };

    cpu.process_table.insert(1, p1.clone());
    cpu.process_table.insert(2, p2);
    cpu.current_process = Some(p1);

    // Start in user mode
    cpu.cpl = PrivilegeLevel::Ring3;
    cpu.cs = SegmentSelector::new(3, PrivilegeLevel::Ring3);

    cpu.print_state();

    // Simulate a syscall (e.g., write())
    cpu.regs.rax = 1;   // syscall number: write
    cpu.regs.rdi = 1;   // fd: stdout
    cpu.regs.rsi = 0x400000;  // buffer
    cpu.regs.rdx = 13;  // count

    cpu.syscall().unwrap();
    cpu.print_state();

    // Return from syscall
    cpu.regs.rax = 13;  // Return value: bytes written
    cpu.sysret();
    cpu.print_state();

    // Context switch
    cpu.context_switch(2).unwrap();
    cpu.print_state();

    // Memory allocation demos
    println!("\n=== MEMORY ALLOCATION ===");
    cpu.kmalloc(4096);
    cpu.vmalloc(16384);

    // Page fault demo
    cpu.page_fault(0x0000_DEAD_BEEF_0000, true);

    // Privilege check demo
    println!("\n=== PRIVILEGE CHECK ===");
    let user_selector = SegmentSelector::new(3, PrivilegeLevel::Ring3);
    let kernel_selector = SegmentSelector::new(1, PrivilegeLevel::Ring0);

    cpu.cpl = PrivilegeLevel::Ring3;
    match cpu.check_privilege(&user_selector) {
        Ok(()) => println!("User accessing user segment: OK"),
        Err(e) => println!("Error: {}", e),
    }

    match cpu.check_privilege(&kernel_selector) {
        Ok(()) => println!("User accessing kernel segment: OK (should not happen!)"),
        Err(e) => println!("User accessing kernel segment: {} (expected)", e),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_privilege_check() {
        let mut cpu = Cpu::new();
        cpu.cpl = PrivilegeLevel::Ring3;

        // User can access Ring3 segment
        let user_sel = SegmentSelector::new(3, PrivilegeLevel::Ring3);
        assert!(cpu.check_privilege(&user_sel).is_ok());

        // User cannot access Ring0 segment
        let kernel_sel = SegmentSelector::new(1, PrivilegeLevel::Ring0);
        assert!(cpu.check_privilege(&kernel_sel).is_err());
    }

    #[test]
    fn test_syscall_changes_cpl() {
        let mut cpu = Cpu::new();
        cpu.cpl = PrivilegeLevel::Ring3;
        cpu.cs = SegmentSelector::new(3, PrivilegeLevel::Ring3);

        cpu.regs.rax = 1;
        cpu.syscall().unwrap();

        assert_eq!(cpu.cpl, PrivilegeLevel::Ring0);
    }

    #[test]
    fn test_sysret_restores_user_mode() {
        let mut cpu = Cpu::new();
        cpu.cpl = PrivilegeLevel::Ring0;

        cpu.sysret();

        assert_eq!(cpu.cpl, PrivilegeLevel::Ring3);
    }
}
```

## Criteres de validation
1. Simulation correcte CPL/DPL/RPL
2. Verification de privileges avec erreurs appropriees
3. Transitions syscall/sysret fonctionnelles
4. Context switch sauvegarde/restaure correctement
5. Distinction kmalloc vs vmalloc claire
6. CR2 mis a jour lors de page fault
7. Tests unitaires passent

## Note qualite: 97/100
