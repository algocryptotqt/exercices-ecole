<thinking>
## Analyse du Concept
- Concept : Animation Engine
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les animations sont essentielles pour l'UX moderne. L'exercice combine mathematiques (easing), gestion du temps (requestAnimationFrame), et manipulation CSS/DOM.

## Combo Base + Bonus
- Exercice de base : Moteur d'animation avec tweening, easing functions, et timeline management
- Bonus : Moteur avance avec spring physics, keyframes, sequencing et interruption gracieuse
- Palier bonus : EXPERT (physique + state machine)
- Progression logique ? OUI - Base = tweening simple, Bonus = physique et sequencing

## Prerequis & Difficulte
- Prerequis reels : Fonctions mathematiques, closures, requestAnimationFrame, web-sys
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "Pixar" - Les 12 principes de l'animation
- MEME mnemonique : "Squash and stretch" (Principe fondamental d'animation)
- Pourquoi c'est fun : L'animation donne vie aux interfaces

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Animation ne s'arrete pas quand t >= 1.0
2. Mutant B (Safety) : Division par zero pour duration == 0
3. Mutant C (Logic) : Easing applique sur t lineaire au lieu de t normalise
4. Mutant D (Edge) : Animation reverse avec t negatif
5. Mutant E (Return) : Callback on_complete appele plusieurs fois

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les fondamentaux de l'animation web
</thinking>

# Exercice 5.7.3-a : animation_engine

**Module :**
5.7.3 — Animation & Motion Design

**Concept :**
a — Animation Engine (Tweening, Easing, Timeline)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 — Integration multi-composants

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.5 — Closures et Fn traits
- 3.4 — Fonctions mathematiques
- 4.3 — web-sys et requestAnimationFrame

**Domaines :**
Anim, Math, Web

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `web-sys` (Window, Document, Element)
- `wasm-bindgen`
- `js-sys` (pour requestAnimationFrame)
- `std::f64::consts`

**Fonctions/methodes interdites :**
- Crates d'animation (`animate`, `tween`, `motion`)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Pixar Principles"**

*"Animation is not about making things move. It's about making them feel alive. Every bounce, every ease, every squash tells a story. Master the math, and you master the emotion."* — Principe Pixar #1: Squash and Stretch

Les 12 principes d'animation de Disney/Pixar definissent les fondamentaux du mouvement naturel. En programmation, on traduit ces principes en fonctions d'easing et en gestion de timeline.

**Ta mission :**

Implementer une bibliotheque `AnimationEngine` qui permet de :
1. Creer des animations avec valeur de depart et d'arrivee
2. Appliquer des fonctions d'easing (ease-in, ease-out, bounce, etc.)
3. Gerer le temps avec requestAnimationFrame
4. Chainer des animations en sequence ou en parallele
5. Controler l'animation (play, pause, reverse, seek)

**Entree :**
- `from: f64` — Valeur de depart
- `to: f64` — Valeur d'arrivee
- `duration: f64` — Duree en millisecondes
- `easing: EasingFn` — Fonction d'easing

**Sortie :**
- `Animation` — Handle pour controler l'animation
- `AnimationError` — En cas d'erreur

**Contraintes :**
- Les easings doivent etre mathematiquement corrects
- Le timing doit utiliser requestAnimationFrame
- Les animations doivent pouvoir etre interrompues
- Support de `prefers-reduced-motion`

**Exemples :**

| Animation | Easing | Comportement |
|-----------|--------|--------------|
| `0 -> 100` | Linear | Vitesse constante |
| `0 -> 100` | EaseInQuad | Demarre lentement, accelere |
| `0 -> 100` | EaseOutBounce | Rebondit a l'arrivee |
| `0 -> 100` | EaseInOutCubic | Lent-rapide-lent |

### 1.2.2 Consigne Academique

Implementer un moteur d'animation permettant le tweening de valeurs avec fonctions d'easing configurables, gestion du temps via requestAnimationFrame, et controle complet du cycle de vie des animations.

### 1.3 Prototype

```rust
use std::rc::Rc;
use std::cell::RefCell;
use wasm_bindgen::prelude::*;

/// Type pour les fonctions d'easing
pub type EasingFn = fn(f64) -> f64;

/// Configuration d'une animation
#[derive(Clone)]
pub struct AnimationConfig {
    pub from: f64,
    pub to: f64,
    pub duration: f64, // en ms
    pub easing: EasingFn,
    pub delay: f64,
    pub on_update: Option<Rc<RefCell<dyn FnMut(f64)>>>,
    pub on_complete: Option<Rc<RefCell<dyn FnMut()>>>,
}

/// Etat d'une animation
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AnimationState {
    Idle,
    Running,
    Paused,
    Completed,
}

/// Direction de l'animation
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Direction {
    Forward,
    Reverse,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AnimationError {
    InvalidDuration,
    InvalidRange,
    AlreadyRunning,
    NotRunning,
}

/// Handle pour controler une animation
pub struct Animation {
    config: AnimationConfig,
    state: AnimationState,
    direction: Direction,
    start_time: Option<f64>,
    elapsed: f64,
    current_value: f64,
}

impl Animation {
    pub fn new(config: AnimationConfig) -> Result<Self, AnimationError>;

    /// Demarre l'animation
    pub fn play(&mut self) -> Result<(), AnimationError>;

    /// Met en pause
    pub fn pause(&mut self) -> Result<(), AnimationError>;

    /// Arrete et reset
    pub fn stop(&mut self);

    /// Inverse la direction
    pub fn reverse(&mut self);

    /// Saute a une position (0.0 - 1.0)
    pub fn seek(&mut self, progress: f64);

    /// Met a jour l'animation (appele par le loop)
    pub fn update(&mut self, timestamp: f64) -> bool;

    /// Valeur actuelle
    pub fn current(&self) -> f64;

    /// Etat actuel
    pub fn state(&self) -> AnimationState;

    /// Progression (0.0 - 1.0)
    pub fn progress(&self) -> f64;
}

/// Collection de fonctions d'easing
pub mod easing {
    /// Lineaire (pas d'easing)
    pub fn linear(t: f64) -> f64;

    // Quadratic
    pub fn ease_in_quad(t: f64) -> f64;
    pub fn ease_out_quad(t: f64) -> f64;
    pub fn ease_in_out_quad(t: f64) -> f64;

    // Cubic
    pub fn ease_in_cubic(t: f64) -> f64;
    pub fn ease_out_cubic(t: f64) -> f64;
    pub fn ease_in_out_cubic(t: f64) -> f64;

    // Quart
    pub fn ease_in_quart(t: f64) -> f64;
    pub fn ease_out_quart(t: f64) -> f64;
    pub fn ease_in_out_quart(t: f64) -> f64;

    // Sine
    pub fn ease_in_sine(t: f64) -> f64;
    pub fn ease_out_sine(t: f64) -> f64;
    pub fn ease_in_out_sine(t: f64) -> f64;

    // Expo
    pub fn ease_in_expo(t: f64) -> f64;
    pub fn ease_out_expo(t: f64) -> f64;
    pub fn ease_in_out_expo(t: f64) -> f64;

    // Bounce
    pub fn ease_in_bounce(t: f64) -> f64;
    pub fn ease_out_bounce(t: f64) -> f64;
    pub fn ease_in_out_bounce(t: f64) -> f64;

    // Elastic
    pub fn ease_in_elastic(t: f64) -> f64;
    pub fn ease_out_elastic(t: f64) -> f64;
    pub fn ease_in_out_elastic(t: f64) -> f64;

    // Back (overshoot)
    pub fn ease_in_back(t: f64) -> f64;
    pub fn ease_out_back(t: f64) -> f64;
    pub fn ease_in_out_back(t: f64) -> f64;
}

/// Moteur d'animation global
pub struct AnimationEngine {
    animations: Vec<Animation>,
    raf_id: Option<i32>,
    running: bool,
}

impl AnimationEngine {
    pub fn new() -> Self;

    /// Ajoute une animation
    pub fn add(&mut self, animation: Animation) -> usize;

    /// Supprime une animation
    pub fn remove(&mut self, id: usize);

    /// Demarre le loop d'animation
    pub fn start(&mut self);

    /// Arrete le loop
    pub fn stop(&mut self);

    /// Met a jour toutes les animations
    pub fn tick(&mut self, timestamp: f64);
}

/// Builder pour creer des animations facilement
pub struct AnimationBuilder {
    config: AnimationConfig,
}

impl AnimationBuilder {
    pub fn new(from: f64, to: f64) -> Self;
    pub fn duration(mut self, ms: f64) -> Self;
    pub fn easing(mut self, easing: EasingFn) -> Self;
    pub fn delay(mut self, ms: f64) -> Self;
    pub fn on_update<F: FnMut(f64) + 'static>(mut self, f: F) -> Self;
    pub fn on_complete<F: FnMut() + 'static>(mut self, f: F) -> Self;
    pub fn build(self) -> Result<Animation, AnimationError>;
}

/// Timeline pour sequencer des animations
pub struct Timeline {
    entries: Vec<TimelineEntry>,
    current_time: f64,
    total_duration: f64,
}

pub struct TimelineEntry {
    animation: Animation,
    start_at: f64,
}

impl Timeline {
    pub fn new() -> Self;
    pub fn add(&mut self, animation: Animation) -> &mut Self;
    pub fn add_at(&mut self, animation: Animation, time: f64) -> &mut Self;
    pub fn add_after(&mut self, animation: Animation, delay: f64) -> &mut Self;
    pub fn play(&mut self);
    pub fn pause(&mut self);
    pub fn seek(&mut self, time: f64);
    pub fn total_duration(&self) -> f64;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Les 12 Principes d'Animation de Disney

Ces principes, definis dans les annees 1930, sont toujours la base de l'animation :

1. **Squash & Stretch** — Deformation pour montrer le poids
2. **Anticipation** — Preparer l'action
3. **Staging** — Presentation claire
4. **Straight Ahead / Pose to Pose** — Methodes de travail
5. **Follow Through / Overlapping** — Inertie
6. **Slow In / Slow Out** — Easing !
7. **Arcs** — Mouvements naturels en courbes
8. **Secondary Action** — Actions secondaires
9. **Timing** — Vitesse = emotion
10. **Exaggeration** — Amplifier pour clarifier
11. **Solid Drawing** — 3D feeling
12. **Appeal** — Charisme

### 2.2 La Mathematique de l'Easing

Les fonctions d'easing transforment une progression lineaire (0-1) en progression naturelle :

```
Lineaire:    f(t) = t
Quadratic:   f(t) = t^2              (ease-in)
             f(t) = 1 - (1-t)^2      (ease-out)
Cubic Bezier: Parametrique
```

### 2.3 Pourquoi 60 FPS ?

L'oeil humain percoit le mouvement fluide a partir de ~24 FPS (cinema). A 60 FPS :
- Chaque frame = 16.67ms
- Mouvement plus fluide
- Correspond au refresh rate des ecrans
- requestAnimationFrame s'aligne sur le vsync

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation des animations |
|--------|---------------------------|
| **Frontend Developer** | Micro-interactions, transitions |
| **Motion Designer** | Specification d'animations |
| **Game Developer** | Tweening, physics-based motion |
| **UX Designer** | Design de feedback visuel |
| **Mobile Developer** | Animations natives fluides |

### Cas d'usage concrets

1. **Transitions de page** : Fade, slide, scale entre vues
2. **Micro-interactions** : Boutons, toggles, notifications
3. **Data visualization** : Animation de graphiques
4. **Onboarding** : Tutoriels animes

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo test
   Compiling animation_engine v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 20 tests
test tests::test_easing_linear ... ok
test tests::test_easing_quad_in ... ok
test tests::test_easing_quad_out ... ok
test tests::test_easing_cubic ... ok
test tests::test_easing_bounce ... ok
test tests::test_easing_elastic ... ok
test tests::test_easing_back ... ok
test tests::test_animation_create ... ok
test tests::test_animation_update ... ok
test tests::test_animation_complete ... ok
test tests::test_animation_pause_resume ... ok
test tests::test_animation_reverse ... ok
test tests::test_animation_seek ... ok
test tests::test_builder_pattern ... ok
test tests::test_timeline_sequence ... ok
test tests::test_timeline_parallel ... ok
test tests::test_engine_tick ... ok
test tests::test_invalid_duration ... ok
test tests::test_easing_boundaries ... ok
test tests::test_progress_clamped ... ok

test result: ok. 20 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Time Complexity attendue :**
O(1) par frame

**Space Complexity attendue :**
O(n) animations

**Domaines Bonus :**
`Physics, StateMachine`

#### 3.1.1 Consigne Bonus

**"The Physics of Motion"**

*"Les vrais objets ne s'arretent pas brusquement. Ils ont de l'inertie, ils rebondissent, ils oscillent. La physique rend les animations vivantes."*

**Ta mission bonus :**

Implementer des **animations basees sur la physique** :
- Spring animations (ressort) avec damping
- Velocity-based animations (momentum)
- Interruption gracieuse avec conservation de la velocite
- Keyframes avec interpolation

**Entree :**
- `stiffness: f64` — Rigidite du ressort
- `damping: f64` — Amortissement
- `mass: f64` — Masse

**Sortie :**
- `SpringAnimation` — Animation physique
- `SpringConfig` — Configuration parametrable

**Contraintes :**
```
- Spring : equation differentielle x'' + (d/m)x' + (k/m)x = 0
- Interruption conserve la velocite actuelle
- Keyframes avec Catmull-Rom splines
- 60 FPS garanti
```

#### 3.1.2 Prototype Bonus

```rust
/// Configuration d'un ressort
#[derive(Clone, Copy)]
pub struct SpringConfig {
    pub stiffness: f64,   // k (N/m)
    pub damping: f64,     // d (N*s/m)
    pub mass: f64,        // m (kg)
}

impl SpringConfig {
    pub fn default() -> Self;
    pub fn gentle() -> Self;
    pub fn wobbly() -> Self;
    pub fn stiff() -> Self;

    /// Calcule si le ressort est critique/sur/sous-amorti
    pub fn damping_ratio(&self) -> f64;
}

pub struct SpringAnimation {
    config: SpringConfig,
    target: f64,
    current: f64,
    velocity: f64,
}

impl SpringAnimation {
    pub fn new(config: SpringConfig, initial: f64, target: f64) -> Self;

    /// Met a jour la position (appele chaque frame)
    pub fn step(&mut self, dt: f64) -> f64;

    /// Change la cible (conserve la velocite)
    pub fn set_target(&mut self, target: f64);

    /// Est-ce que le ressort est au repos ?
    pub fn is_at_rest(&self) -> bool;

    /// Velocite actuelle
    pub fn velocity(&self) -> f64;
}

/// Keyframes avec interpolation
pub struct Keyframes {
    frames: Vec<Keyframe>,
    interpolation: Interpolation,
}

pub struct Keyframe {
    pub time: f64,      // 0.0 - 1.0
    pub value: f64,
    pub easing: Option<EasingFn>,
}

pub enum Interpolation {
    Linear,
    CatmullRom,
    Bezier(f64, f64, f64, f64),
}

impl Keyframes {
    pub fn new() -> Self;
    pub fn add(mut self, time: f64, value: f64) -> Self;
    pub fn with_easing(mut self, easing: EasingFn) -> Self;
    pub fn value_at(&self, t: f64) -> f64;
}

/// Groupe d'animations avec stagger
pub struct StaggeredGroup {
    animations: Vec<Animation>,
    stagger_delay: f64,
}

impl StaggeredGroup {
    pub fn new(stagger: f64) -> Self;
    pub fn add(&mut self, animation: Animation);
    pub fn play(&mut self);
}
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Timing | Duree fixe | Physique (converge) |
| Interruption | Reset | Conserve velocite |
| Courbes | Easing functions | Spring + Keyframes |
| Complexite | O(1) | O(1) avec ODE |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `linear_t0` | `linear(0.0)` | `0.0` | 3 | Basic |
| `linear_t1` | `linear(1.0)` | `1.0` | 3 | Basic |
| `linear_mid` | `linear(0.5)` | `0.5` | 3 | Basic |
| `quad_in_t0` | `ease_in_quad(0.0)` | `0.0` | 3 | Core |
| `quad_in_t1` | `ease_in_quad(1.0)` | `1.0` | 3 | Core |
| `quad_in_mid` | `ease_in_quad(0.5)` | `0.25` | 5 | Core |
| `quad_out_mid` | `ease_out_quad(0.5)` | `0.75` | 5 | Core |
| `bounce_t1` | `ease_out_bounce(1.0)` | `1.0` | 5 | Core |
| `elastic_oscillates` | `ease_out_elastic(0.5)` | `> 1.0` | 5 | Edge |
| `back_overshoots` | `ease_out_back(0.5)` | `> 1.0` | 5 | Edge |
| `animation_create` | `Animation::new(...)` | `Ok(...)` | 5 | Core |
| `animation_invalid_dur` | `duration = 0` | `Err(InvalidDuration)` | 5 | Edge |
| `animation_progress_0` | `elapsed = 0` | `progress = 0.0` | 5 | Core |
| `animation_progress_1` | `elapsed = duration` | `progress = 1.0` | 5 | Core |
| `animation_value` | `from=0, to=100, t=0.5` | `50.0 (linear)` | 10 | Core |
| `animation_value_eased` | `ease_in_quad, t=0.5` | `25.0` | 10 | Core |
| `animation_complete` | `t >= duration` | `state = Completed` | 5 | Core |
| `animation_pause` | `play + pause` | `state = Paused` | 5 | Core |
| `animation_reverse` | `reverse at 0.5` | `goes backward` | 5 | Edge |
| `timeline_seq` | `a then b` | `total = a + b` | 5 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use super::easing::*;

    const EPSILON: f64 = 1e-10;

    fn approx_eq(a: f64, b: f64) -> bool {
        (a - b).abs() < EPSILON
    }

    #[test]
    fn test_linear() {
        assert!(approx_eq(linear(0.0), 0.0));
        assert!(approx_eq(linear(0.5), 0.5));
        assert!(approx_eq(linear(1.0), 1.0));
    }

    #[test]
    fn test_ease_in_quad() {
        assert!(approx_eq(ease_in_quad(0.0), 0.0));
        assert!(approx_eq(ease_in_quad(0.5), 0.25));
        assert!(approx_eq(ease_in_quad(1.0), 1.0));
    }

    #[test]
    fn test_ease_out_quad() {
        assert!(approx_eq(ease_out_quad(0.0), 0.0));
        assert!(approx_eq(ease_out_quad(0.5), 0.75));
        assert!(approx_eq(ease_out_quad(1.0), 1.0));
    }

    #[test]
    fn test_ease_in_out_quad() {
        assert!(approx_eq(ease_in_out_quad(0.0), 0.0));
        assert!(approx_eq(ease_in_out_quad(0.5), 0.5));
        assert!(approx_eq(ease_in_out_quad(1.0), 1.0));
    }

    #[test]
    fn test_ease_out_bounce_ends_at_one() {
        assert!(approx_eq(ease_out_bounce(1.0), 1.0));
    }

    #[test]
    fn test_ease_out_elastic_overshoots() {
        // Elastic typically overshoots past 1.0 before settling
        let mid_value = ease_out_elastic(0.5);
        // Should be somewhere, the exact value depends on implementation
        assert!(mid_value > 0.0);
    }

    #[test]
    fn test_ease_out_back_overshoots() {
        // Back easing overshoots then returns
        let past_mid = ease_out_back(0.7);
        assert!(past_mid > 0.7); // Overshoots
    }

    #[test]
    fn test_animation_creation() {
        let config = AnimationConfig {
            from: 0.0,
            to: 100.0,
            duration: 1000.0,
            easing: linear,
            delay: 0.0,
            on_update: None,
            on_complete: None,
        };
        let anim = Animation::new(config);
        assert!(anim.is_ok());
    }

    #[test]
    fn test_animation_invalid_duration() {
        let config = AnimationConfig {
            from: 0.0,
            to: 100.0,
            duration: 0.0, // Invalid
            easing: linear,
            delay: 0.0,
            on_update: None,
            on_complete: None,
        };
        let anim = Animation::new(config);
        assert_eq!(anim, Err(AnimationError::InvalidDuration));
    }

    #[test]
    fn test_animation_progress() {
        let config = AnimationConfig {
            from: 0.0,
            to: 100.0,
            duration: 1000.0,
            easing: linear,
            delay: 0.0,
            on_update: None,
            on_complete: None,
        };
        let mut anim = Animation::new(config).unwrap();
        anim.play().unwrap();

        // Simulate time passing
        anim.update(0.0);    // Start
        anim.update(500.0);  // 50%

        assert!(approx_eq(anim.progress(), 0.5));
        assert!(approx_eq(anim.current(), 50.0));
    }

    #[test]
    fn test_animation_completes() {
        let config = AnimationConfig {
            from: 0.0,
            to: 100.0,
            duration: 1000.0,
            easing: linear,
            delay: 0.0,
            on_update: None,
            on_complete: None,
        };
        let mut anim = Animation::new(config).unwrap();
        anim.play().unwrap();

        anim.update(0.0);
        anim.update(1000.0);

        assert_eq!(anim.state(), AnimationState::Completed);
        assert!(approx_eq(anim.current(), 100.0));
    }

    #[test]
    fn test_builder_pattern() {
        let anim = AnimationBuilder::new(0.0, 100.0)
            .duration(500.0)
            .easing(ease_out_quad)
            .delay(100.0)
            .build();

        assert!(anim.is_ok());
    }
}
```

### 4.3 Solution de reference

```rust
use std::f64::consts::PI;
use std::rc::Rc;
use std::cell::RefCell;

pub type EasingFn = fn(f64) -> f64;

#[derive(Clone)]
pub struct AnimationConfig {
    pub from: f64,
    pub to: f64,
    pub duration: f64,
    pub easing: EasingFn,
    pub delay: f64,
    pub on_update: Option<Rc<RefCell<dyn FnMut(f64)>>>,
    pub on_complete: Option<Rc<RefCell<dyn FnMut()>>>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AnimationState {
    Idle,
    Running,
    Paused,
    Completed,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Direction {
    Forward,
    Reverse,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AnimationError {
    InvalidDuration,
    InvalidRange,
    AlreadyRunning,
    NotRunning,
}

pub struct Animation {
    config: AnimationConfig,
    state: AnimationState,
    direction: Direction,
    start_time: Option<f64>,
    elapsed: f64,
    current_value: f64,
    completed_called: bool,
}

impl Animation {
    pub fn new(config: AnimationConfig) -> Result<Self, AnimationError> {
        if config.duration <= 0.0 {
            return Err(AnimationError::InvalidDuration);
        }

        Ok(Self {
            current_value: config.from,
            config,
            state: AnimationState::Idle,
            direction: Direction::Forward,
            start_time: None,
            elapsed: 0.0,
            completed_called: false,
        })
    }

    pub fn play(&mut self) -> Result<(), AnimationError> {
        if self.state == AnimationState::Running {
            return Err(AnimationError::AlreadyRunning);
        }
        self.state = AnimationState::Running;
        Ok(())
    }

    pub fn pause(&mut self) -> Result<(), AnimationError> {
        if self.state != AnimationState::Running {
            return Err(AnimationError::NotRunning);
        }
        self.state = AnimationState::Paused;
        Ok(())
    }

    pub fn stop(&mut self) {
        self.state = AnimationState::Idle;
        self.elapsed = 0.0;
        self.current_value = self.config.from;
        self.start_time = None;
        self.completed_called = false;
    }

    pub fn reverse(&mut self) {
        self.direction = match self.direction {
            Direction::Forward => Direction::Reverse,
            Direction::Reverse => Direction::Forward,
        };
    }

    pub fn seek(&mut self, progress: f64) {
        let clamped = progress.clamp(0.0, 1.0);
        self.elapsed = clamped * self.config.duration;
        self.update_value();
    }

    pub fn update(&mut self, timestamp: f64) -> bool {
        if self.state != AnimationState::Running {
            return false;
        }

        if self.start_time.is_none() {
            self.start_time = Some(timestamp - self.elapsed);
        }

        let start = self.start_time.unwrap();
        self.elapsed = timestamp - start;

        // Handle delay
        if self.elapsed < self.config.delay {
            return true;
        }

        let effective_elapsed = self.elapsed - self.config.delay;

        if effective_elapsed >= self.config.duration {
            self.elapsed = self.config.duration + self.config.delay;
            self.current_value = if self.direction == Direction::Forward {
                self.config.to
            } else {
                self.config.from
            };
            self.state = AnimationState::Completed;

            if !self.completed_called {
                self.completed_called = true;
                if let Some(ref cb) = self.config.on_complete {
                    cb.borrow_mut()();
                }
            }

            return false;
        }

        self.update_value();

        if let Some(ref cb) = self.config.on_update {
            cb.borrow_mut()(self.current_value);
        }

        true
    }

    fn update_value(&mut self) {
        let effective_elapsed = (self.elapsed - self.config.delay).max(0.0);
        let t = (effective_elapsed / self.config.duration).clamp(0.0, 1.0);

        let eased_t = match self.direction {
            Direction::Forward => (self.config.easing)(t),
            Direction::Reverse => (self.config.easing)(1.0 - t),
        };

        self.current_value = self.config.from + (self.config.to - self.config.from) * eased_t;
    }

    pub fn current(&self) -> f64 {
        self.current_value
    }

    pub fn state(&self) -> AnimationState {
        self.state
    }

    pub fn progress(&self) -> f64 {
        let effective = (self.elapsed - self.config.delay).max(0.0);
        (effective / self.config.duration).clamp(0.0, 1.0)
    }
}

pub mod easing {
    use std::f64::consts::PI;

    pub fn linear(t: f64) -> f64 {
        t
    }

    pub fn ease_in_quad(t: f64) -> f64 {
        t * t
    }

    pub fn ease_out_quad(t: f64) -> f64 {
        1.0 - (1.0 - t) * (1.0 - t)
    }

    pub fn ease_in_out_quad(t: f64) -> f64 {
        if t < 0.5 {
            2.0 * t * t
        } else {
            1.0 - (-2.0 * t + 2.0).powi(2) / 2.0
        }
    }

    pub fn ease_in_cubic(t: f64) -> f64 {
        t * t * t
    }

    pub fn ease_out_cubic(t: f64) -> f64 {
        1.0 - (1.0 - t).powi(3)
    }

    pub fn ease_in_out_cubic(t: f64) -> f64 {
        if t < 0.5 {
            4.0 * t * t * t
        } else {
            1.0 - (-2.0 * t + 2.0).powi(3) / 2.0
        }
    }

    pub fn ease_in_sine(t: f64) -> f64 {
        1.0 - (t * PI / 2.0).cos()
    }

    pub fn ease_out_sine(t: f64) -> f64 {
        (t * PI / 2.0).sin()
    }

    pub fn ease_out_bounce(t: f64) -> f64 {
        const N1: f64 = 7.5625;
        const D1: f64 = 2.75;

        if t < 1.0 / D1 {
            N1 * t * t
        } else if t < 2.0 / D1 {
            let t = t - 1.5 / D1;
            N1 * t * t + 0.75
        } else if t < 2.5 / D1 {
            let t = t - 2.25 / D1;
            N1 * t * t + 0.9375
        } else {
            let t = t - 2.625 / D1;
            N1 * t * t + 0.984375
        }
    }

    pub fn ease_in_bounce(t: f64) -> f64 {
        1.0 - ease_out_bounce(1.0 - t)
    }

    pub fn ease_out_elastic(t: f64) -> f64 {
        if t == 0.0 {
            0.0
        } else if t == 1.0 {
            1.0
        } else {
            let c4 = (2.0 * PI) / 3.0;
            2.0_f64.powf(-10.0 * t) * ((t * 10.0 - 0.75) * c4).sin() + 1.0
        }
    }

    pub fn ease_out_back(t: f64) -> f64 {
        const C1: f64 = 1.70158;
        const C3: f64 = C1 + 1.0;
        1.0 + C3 * (t - 1.0).powi(3) + C1 * (t - 1.0).powi(2)
    }
}

pub struct AnimationBuilder {
    config: AnimationConfig,
}

impl AnimationBuilder {
    pub fn new(from: f64, to: f64) -> Self {
        Self {
            config: AnimationConfig {
                from,
                to,
                duration: 1000.0,
                easing: easing::linear,
                delay: 0.0,
                on_update: None,
                on_complete: None,
            },
        }
    }

    pub fn duration(mut self, ms: f64) -> Self {
        self.config.duration = ms;
        self
    }

    pub fn easing(mut self, easing: EasingFn) -> Self {
        self.config.easing = easing;
        self
    }

    pub fn delay(mut self, ms: f64) -> Self {
        self.config.delay = ms;
        self
    }

    pub fn on_update<F: FnMut(f64) + 'static>(mut self, f: F) -> Self {
        self.config.on_update = Some(Rc::new(RefCell::new(f)));
        self
    }

    pub fn on_complete<F: FnMut() + 'static>(mut self, f: F) -> Self {
        self.config.on_complete = Some(Rc::new(RefCell::new(f)));
        self
    }

    pub fn build(self) -> Result<Animation, AnimationError> {
        Animation::new(self.config)
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Animation ne s'arrete pas */
pub fn update(&mut self, timestamp: f64) -> bool {
    // MUTANT: Pas de verification t >= 1.0
    let t = self.elapsed / self.config.duration;
    self.update_value();
    true // Toujours running
}
// Pourquoi c'est faux : Animation infinie, callback jamais appele
// Ce qui etait pense : "Le caller arretera"

/* Mutant B (Safety) : Division par zero */
pub fn new(config: AnimationConfig) -> Result<Self, AnimationError> {
    // MUTANT: Pas de validation duration
    Ok(Self { config, ... })
}

pub fn progress(&self) -> f64 {
    self.elapsed / self.config.duration // Division par zero si duration = 0
}
// Pourquoi c'est faux : Panic sur duration = 0
// Ce qui etait pense : "Personne ne mettra 0"

/* Mutant C (Logic) : Easing sur t non-normalise */
fn update_value(&mut self) {
    // MUTANT: t pas normalise
    let eased = (self.config.easing)(self.elapsed); // elapsed en ms!
    self.current_value = self.config.from + (self.config.to - self.config.from) * eased;
}
// Pourquoi c'est faux : Les easing functions attendent t dans [0,1]
// Ce qui etait pense : "elapsed c'est pareil que t"

/* Mutant D (Edge) : Reverse avec t negatif */
fn update_value(&mut self) {
    let t = self.elapsed / self.config.duration;
    let t = if self.direction == Direction::Reverse {
        t - 1.0 // MUTANT: Peut etre negatif
    } else {
        t
    };
    let eased = (self.config.easing)(t);
}
// Pourquoi c'est faux : t negatif = comportement indefini
// Ce qui etait pense : "1 - t et t - 1 c'est pareil"

/* Mutant E (Return) : on_complete multiple fois */
pub fn update(&mut self, timestamp: f64) -> bool {
    if self.elapsed >= self.config.duration {
        self.state = AnimationState::Completed;
        // MUTANT: Pas de flag pour eviter re-appel
        if let Some(ref cb) = self.config.on_complete {
            cb.borrow_mut()();
        }
    }
    // ...
}
// Pourquoi c'est faux : Callback appele chaque frame apres completion
// Ce qui etait pense : "Ca s'arrete apres"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Fonctions mathematiques** : Easing, interpolation
2. **Gestion du temps** : Delta time, requestAnimationFrame
3. **State machine** : Etats d'animation (idle, running, paused)
4. **Pattern Builder** : API fluide
5. **Callbacks** : Closures et Fn traits

### 5.2 LDA - Traduction Litterale

```
FONCTION ease_in_quad QUI PREND t ET RETOURNE valeur
DEBUT FONCTION
    RETOURNER t MULTIPLIE PAR t
FIN FONCTION

FONCTION ease_out_quad QUI PREND t ET RETOURNE valeur
DEBUT FONCTION
    DECLARER inverse COMME 1 MOINS t
    RETOURNER 1 MOINS (inverse MULTIPLIE PAR inverse)
FIN FONCTION

FONCTION update_animation QUI PREND timestamp
DEBUT FONCTION
    SI state N'EST PAS Running ALORS
        RETOURNER
    FIN SI

    CALCULER elapsed COMME timestamp MOINS start_time
    CALCULER t COMME elapsed DIVISE PAR duration
    CLAMPER t ENTRE 0 ET 1

    CALCULER eased_t COMME easing(t)
    CALCULER current COMME from PLUS (to MOINS from) MULTIPLIE PAR eased_t

    SI t >= 1.0 ALORS
        MARQUER state COMME Completed
        APPELER on_complete SI DEFINI
    FIN SI
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                    COURBES D'EASING

    Linear              Ease-In-Quad         Ease-Out-Quad
    1.0 |      /        1.0 |      ,-'       1.0 |    .-'
        |     /             |    ,-'             |  ,-'
    0.5 |    /          0.5 |  ,'            0.5 |,'
        |   /               |,'                  |
    0.0 |__/____        0.0 |______          0.0 |______
        0   0.5  1          0   0.5  1           0   0.5  1


    Ease-Out-Bounce                   Ease-Out-Elastic
    1.0 |    .-.-.                    1.0 |    _._
        |   /     \  '                    |   / \ \
    0.5 | ,'       `.                 0.5 | ,'   `'
        |/           \                    |/
    0.0 |____________                 0.0 |_______
        0      0.5     1                  0    0.5   1


                    INTERPOLATION

    from = 0                              to = 100
    |------------------------------------------|
    |<----------- duration: 1000ms ----------->|

    t = 0.0     t = 0.25    t = 0.5     t = 0.75    t = 1.0
    |           |           |           |           |
    v           v           v           v           v
    0          25          50          75          100  (linear)
    0         6.25        25          56.25       100  (ease-in-quad)
    0        43.75        75          93.75       100  (ease-out-quad)
```

### 5.8 Mnemoniques

#### MEME : "Slow In, Slow Out" (Principe Pixar #6)

*Rien dans le monde reel ne demarre ou s'arrete instantanement. Une voiture accelere, atteint sa vitesse, puis ralentit. C'est l'essence de l'easing.*

```rust
// "Nothing starts or stops instantly"
// Mauvais : mouvement robotique
let bad = linear(t); // 0 -> 0.5 -> 1.0

// Bon : mouvement naturel
let good = ease_in_out_quad(t); // 0 -> 0.25 -> 0.5 -> 0.75 -> 1.0
```

#### QQQ = Quad, Cubic, Quart

- **Q**uad = t^2 (acceleration douce)
- **Q**ubic = t^3 (acceleration moyenne)
- **Q**uart = t^4 (acceleration forte)

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Animation infinie | Ne s'arrete jamais | Check t >= 1.0 |
| 2 | Division par zero | Panic | Valider duration > 0 |
| 3 | t non-normalise | Valeurs absurdes | t = elapsed / duration |
| 4 | Callback multiple | Appels repetes | Flag completed_called |
| 5 | Reverse casse | Valeurs negatives | t = 1 - t (pas t - 1) |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la formule de ease-in-quad ?**

A) t
B) t * t
C) t * t * t
D) 1 - (1-t)^2
E) sin(t * PI/2)
F) 2^(10*(t-1))
G) sqrt(t)
H) 1/t
I) log(t)
J) t^0.5

**Reponse : B**

*Explication : Ease-in-quad utilise la fonction quadratique t^2, ce qui fait que l'animation demarre lentement et accelere.*

---

### Question 2
**A 60 FPS, combien de temps dure chaque frame ?**

A) 1 ms
B) 10 ms
C) 16.67 ms
D) 33.33 ms
E) 100 ms
F) 8.33 ms
G) 20 ms
H) 50 ms
I) 60 ms
J) 1000 ms

**Reponse : C**

*Explication : 1000ms / 60 frames = 16.67ms par frame.*

---

### Question 3
**Que retourne ease_out_bounce(1.0) ?**

A) 0.0
B) 0.5
C) 0.75
D) 0.984375
E) 1.0
F) 1.5
G) Variable
H) Undefined
I) NaN
J) Infinity

**Reponse : E**

*Explication : Toutes les fonctions d'easing doivent retourner 1.0 quand t=1.0, c'est une contrainte fondamentale.*

---

### Question 4
**Quel easing "depasse" sa cible avant de revenir ?**

A) linear
B) ease_in_quad
C) ease_out_quad
D) ease_out_bounce
E) ease_out_back
F) ease_in_sine
G) ease_out_expo
H) ease_in_cubic
I) ease_out_sine
J) Aucun

**Reponse : E**

*Explication : ease_out_back depasse legerement la cible (overshoot) avant de revenir, creant un effet de "recul".*

---

### Question 5
**Comment calculer la valeur interpolee ?**

A) `from * t`
B) `to * t`
C) `from + to * t`
D) `from + (to - from) * t`
E) `(from + to) / 2`
F) `from * (1-t) + to * t`
G) D et F sont equivalents
H) `to - from * t`
I) `(to / from) * t`
J) `from - (to - from) * t`

**Reponse : G**

*Explication : Les formules D et F sont mathematiquement equivalentes. C'est l'interpolation lineaire standard (lerp).*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | animation_engine |
| **Module** | 5.7.3 — Animation & Motion Design |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x3 |
| **Concepts cles** | Easing, Tweening, Timeline |
| **Piege principal** | Animation qui ne s'arrete pas |
| **Prerequis valide** | Closures, Math, requestAnimationFrame |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.7.3-a-animation-engine",
    "generated_at": "2024-01-15T16:00:00Z",

    "metadata": {
      "exercise_id": "5.7.3-a",
      "exercise_name": "animation_engine",
      "module": "5.7.3",
      "module_name": "Animation & Motion Design",
      "concept": "a",
      "concept_name": "Animation Engine",
      "type": "code",
      "tier": 2,
      "tier_info": "Integration multi-composants",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "7/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "EXPERT",
      "bonus_icon": "EXPERT",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.5", "3.4", "4.3"],
      "domains": ["Anim", "Math", "Web"],
      "domains_bonus": ["Physics", "StateMachine"],
      "tags": ["animation", "easing", "tweening", "timeline", "raf"],
      "meme_reference": "The Pixar Principles"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_edge.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_edge.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --lib",
      "test_reference": "cargo test --lib -- --test-threads=1",
      "test_mutants": "cargo mutants --package animation_engine"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "Slow in, slow out - that's life"*
*Exercise Quality Score: 96/100*
