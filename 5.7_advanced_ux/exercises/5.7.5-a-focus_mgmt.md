<thinking>
## Analyse du Concept
- Concept : Focus Management
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La gestion du focus est fondamentale pour l'accessibilite web. L'exercice combine DOM manipulation, patterns d'accessibilite et gestion d'etat.

## Combo Base + Bonus
- Exercice de base : Gestionnaire de focus avec historique, trap, et navigation programmatique
- Bonus : Implementation d'un systeme de roving tabindex pour composants complexes (grilles, arbres)
- Palier bonus : Avance (complexite algorithmique + gestion d'etat complexe)
- Progression logique ? OUI - Base = gestion lineaire, Bonus = navigation 2D

## Prerequis & Difficulte
- Prerequis reels : DOM APIs, patterns ARIA, gestion d'etat, closures
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Legend of Zelda" - Le focus comme le curseur de selection dans les menus du jeu
- MEME mnémotechnique : "It's dangerous to go alone! Take this focus." (parodie de la celebre replique)
- Pourquoi c'est fun : Les menus de Zelda sont un excellent exemple de navigation clavier intuitive

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Focus trap ne boucle pas correctement aux extremites
2. Mutant B (Safety) : Pas de verification que l'element est focusable avant focus()
3. Mutant C (Logic) : Historique de focus non mis a jour lors de restore
4. Mutant D (Edge) : Elements caches (display:none) inclus dans les focusables
5. Mutant E (Return) : get_focusable_elements retourne les elements dans le mauvais ordre DOM

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les fondamentaux de la gestion du focus web
</thinking>

# Exercice 5.7.5-a : focus_manager

**Module :**
5.7.5 — ARIA & Focus Management

**Concept :**
a — Focus Management (historique, trap, navigation programmatique)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.3 — Traits (Clone, Default)
- 5.7.4 — WCAG & Accessibility fundamentals
- 5.7.5.k-n — Focus management concepts

**Domaines :**
A11y, DOM, UX

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S1 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::{VecDeque, HashSet}`
- `web-sys` (feature "Element", "Document", "HtmlElement", "NodeList")
- `wasm-bindgen`

**Fonctions/methodes interdites :**
- Crates externes de focus management
- `unsafe` blocks
- `eval()` ou manipulation de string HTML

### 1.2 Consigne

**CONTEXTE : "The Legend of Focus"**

*"It's dangerous to go alone! Take this focus."* — Dans les menus de The Legend of Zelda, le curseur de selection se deplace de maniere fluide entre les options. Un bon gestionnaire de focus fait la meme chose pour le web : il guide l'utilisateur a travers l'interface sans jamais le perdre dans le vide.

Dans les applications web accessibles, la gestion du focus est cruciale. Un utilisateur de clavier ou de lecteur d'ecran depend entierement du focus pour naviguer. Un focus mal gere, c'est comme un menu de jeu ou le curseur disparait : frustrant et bloquant.

**Ta mission :**

Implementer un `FocusManager` qui permet de :
1. Sauvegarder et restaurer le focus (historique LIFO)
2. Activer un "focus trap" dans un conteneur (le focus ne peut pas sortir)
3. Naviguer programmatiquement entre elements focusables
4. Detecter tous les elements focusables d'un conteneur
5. Gerer les tabindex dynamiquement

**Entree :**
- `container_id: &str` — ID du conteneur DOM
- `element_id: &str` — ID de l'element cible

**Sortie :**
- `FocusManager` — Structure gerant le focus
- `FocusError` — En cas d'erreur (element non trouve, non focusable)

**Contraintes :**
- Les elements avec `display: none` ou `visibility: hidden` ne sont pas focusables
- Les elements `disabled` ne sont pas focusables
- `tabindex="-1"` rend un element focusable programmatiquement mais pas via Tab
- Le focus trap doit boucler : dernier -> premier et premier -> dernier
- L'historique doit supporter plusieurs niveaux (modals imbriques)

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `manager.save_focus()` | Sauvegarde l'element actif | Push dans l'historique |
| `manager.restore_focus()` | `Ok(())` | Pop et focus sur l'element sauvegarde |
| `manager.trap_focus("modal")` | `Ok(())` | Active le trap dans #modal |
| `manager.focus_next()` | `Ok(())` | Focus sur l'element focusable suivant |

### 1.2.2 Consigne Academique

Implementer une structure `FocusManager` gerant le focus dans une application web. La structure doit permettre la sauvegarde/restauration du focus, le piegeage du focus dans un conteneur, et la navigation programmatique entre elements focusables selon l'ordre DOM.

### 1.3 Prototype

```rust
use std::collections::VecDeque;
use wasm_bindgen::prelude::*;

/// Selecteur CSS pour les elements focusables
pub const FOCUSABLE_SELECTOR: &str =
    "a[href], button:not([disabled]), input:not([disabled]), \
     select:not([disabled]), textarea:not([disabled]), \
     [tabindex]:not([tabindex=\"-1\"]), [contenteditable]";

/// Selecteur incluant tabindex=-1 (focusables programmatiquement)
pub const PROGRAMMATIC_FOCUSABLE_SELECTOR: &str =
    "a[href], button:not([disabled]), input:not([disabled]), \
     select:not([disabled]), textarea:not([disabled]), \
     [tabindex], [contenteditable]";

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FocusError {
    ElementNotFound(String),
    ElementNotFocusable(String),
    NoFocusHistory,
    NoTrapActive,
    ContainerEmpty,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TabIndex {
    /// Element dans le flux normal de tabulation (0)
    InFlow,
    /// Element focusable programmatiquement seulement (-1)
    Programmatic,
    /// Position explicite (>0, deconseille)
    Explicit(i32),
}

impl TabIndex {
    pub fn as_i32(&self) -> i32 {
        match self {
            TabIndex::InFlow => 0,
            TabIndex::Programmatic => -1,
            TabIndex::Explicit(n) => *n,
        }
    }

    pub fn from_i32(value: i32) -> Self {
        match value {
            0 => TabIndex::InFlow,
            -1 => TabIndex::Programmatic,
            n => TabIndex::Explicit(n),
        }
    }
}

/// Gestionnaire de focus accessible
pub struct FocusManager {
    /// Historique des elements focuses (LIFO)
    focus_history: VecDeque<String>,
    /// ID du conteneur de trap actif
    trap_container: Option<String>,
    /// Elements focusables dans le trap
    trap_elements: Vec<String>,
    /// Index actuel dans le trap
    trap_index: usize,
}

impl FocusManager {
    /// Cree un nouveau gestionnaire de focus
    pub fn new() -> Self;

    /// Sauvegarde le focus actuel dans l'historique
    pub fn save_focus(&mut self) -> Result<(), FocusError>;

    /// Restaure le dernier focus sauvegarde
    pub fn restore_focus(&mut self) -> Result<(), FocusError>;

    /// Donne le focus a un element par son ID
    pub fn focus_element(&mut self, element_id: &str) -> Result<(), FocusError>;

    /// Active le focus trap dans un conteneur
    pub fn trap_focus(&mut self, container_id: &str) -> Result<(), FocusError>;

    /// Desactive le focus trap
    pub fn release_trap(&mut self) -> Result<(), FocusError>;

    /// Deplace le focus vers l'element suivant (dans le trap si actif)
    pub fn focus_next(&mut self) -> Result<(), FocusError>;

    /// Deplace le focus vers l'element precedent
    pub fn focus_previous(&mut self) -> Result<(), FocusError>;

    /// Deplace le focus au premier element focusable
    pub fn focus_first(&mut self) -> Result<(), FocusError>;

    /// Deplace le focus au dernier element focusable
    pub fn focus_last(&mut self) -> Result<(), FocusError>;

    /// Retourne les IDs des elements focusables dans un conteneur
    pub fn get_focusable_elements(container_id: &str) -> Result<Vec<String>, FocusError>;

    /// Verifie si un element est focusable
    pub fn is_focusable(element_id: &str) -> Result<bool, FocusError>;

    /// Verifie si un element est visible
    pub fn is_visible(element_id: &str) -> Result<bool, FocusError>;

    /// Definit le tabindex d'un element
    pub fn set_tabindex(element_id: &str, tabindex: TabIndex) -> Result<(), FocusError>;

    /// Obtient le tabindex d'un element
    pub fn get_tabindex(element_id: &str) -> Result<TabIndex, FocusError>;

    /// Retourne l'ID de l'element actuellement focus
    pub fn get_active_element() -> Option<String>;

    /// Verifie si le trap est actif
    pub fn is_trap_active(&self) -> bool;

    /// Profondeur de l'historique de focus
    pub fn history_depth(&self) -> usize;
}

impl Default for FocusManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Utilitaires pour focus management
pub mod utils {
    use super::*;

    /// Genere un ID unique pour elements dynamiques
    pub fn generate_focus_id(prefix: &str) -> String;

    /// Trouve le premier element focusable dans un conteneur
    pub fn find_first_focusable(container_id: &str) -> Option<String>;

    /// Trouve le dernier element focusable dans un conteneur
    pub fn find_last_focusable(container_id: &str) -> Option<String>;

    /// Calcule la distance de tabulation entre deux elements
    pub fn tab_distance(from_id: &str, to_id: &str) -> Result<i32, FocusError>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Focus Web

Le concept de "focus" dans les interfaces graphiques remonte aux annees 1970 avec les premiers systemes de fenetrage. Sur le web, le focus a ete formalise avec HTML 2.0 (1995) qui introduisait les formulaires. L'attribut `tabindex` est apparu dans HTML 4.0 (1997) pour controler l'ordre de tabulation.

### 2.2 Le Focus Ring : Ami ou Ennemi ?

Le fameux "outline" bleu autour des elements focuses est souvent supprime par les developpeurs pour des raisons esthetiques (`outline: none`). C'est une erreur d'accessibilite majeure ! WCAG 2.1 exige que le focus soit visible (critere 2.4.7). La solution moderne : `:focus-visible` qui n'affiche l'outline que pour la navigation clavier.

```css
/* Mauvais */
*:focus { outline: none; }

/* Bon */
*:focus-visible { outline: 2px solid #007bff; }
```

### 2.3 Focus Trap : Pourquoi ?

Un modal accessible DOIT avoir un focus trap. Sans lui, un utilisateur de lecteur d'ecran peut "sortir" du modal et interagir avec le contenu derriere, causant confusion et erreurs. Le focus trap est une prison doree : on ne peut sortir que par les portes prevues (bouton Fermer, Escape).

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation du Focus Management |
|--------|--------------------------------|
| **Frontend Developer** | Implementation de modals, menus, composants custom |
| **UX Engineer** | Design de flux de navigation accessibles |
| **Accessibility Specialist** | Audit WCAG, remediation des problemes de focus |
| **Design System Engineer** | Creation de composants accessibles reutilisables |
| **QA Engineer** | Tests automatises d'accessibilite clavier |

### Cas d'usage concrets

1. **Modal Dialog** : Trap focus, restore au close
2. **Mega Menu** : Navigation fleches, Escape pour fermer
3. **Carousel** : Focus sur les controles, pas les slides caches
4. **Autocomplete** : Focus sur l'input, navigation dans les suggestions
5. **Toast/Notification** : Focus temporaire pour annonce, puis restore

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling focus_manager v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 15 tests
test tests::test_new_manager ... ok
test tests::test_save_restore_focus ... ok
test tests::test_restore_empty_history ... ok
test tests::test_trap_focus ... ok
test tests::test_trap_navigation_forward ... ok
test tests::test_trap_navigation_backward ... ok
test tests::test_trap_loop_forward ... ok
test tests::test_trap_loop_backward ... ok
test tests::test_release_trap ... ok
test tests::test_get_focusable_elements ... ok
test tests::test_is_focusable ... ok
test tests::test_tabindex_conversion ... ok
test tests::test_nested_traps ... ok
test tests::test_skip_hidden_elements ... ok
test tests::test_skip_disabled_elements ... ok

test result: ok. 15 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) pour navigation, O(1) pour acces direct

**Space Complexity attendue :**
O(n*m) pour grille n x m

**Domaines Bonus :**
`Algo, A11y`

#### 3.1.1 Consigne Bonus

**"The Master Sword of Focus"**

*Les vrais heros ne se contentent pas de navigation lineaire.* Dans des composants complexes comme les grilles de donnees ou les arbres, la navigation 2D avec les 4 fleches directionnelles est essentielle.

**Ta mission bonus :**

Implementer un systeme de **Roving Tabindex** pour composants complexes :
- Navigation 2D dans une grille (fleches)
- Un seul element avec `tabindex="0"`, les autres a `-1`
- Support des arbres hierarchiques (expand/collapse)
- Home/End pour aller au debut/fin de ligne
- Ctrl+Home/End pour debut/fin de grille

**Entree :**
- `grid: &Grid` — Structure representant la grille
- `direction: Direction` — Direction de navigation

**Sortie :**
- `Result<Position, NavigationError>` — Nouvelle position ou erreur

**Contraintes :**
```
- Un seul tabindex=0 dans le composant a tout moment
- Les cellules disabled sont sautees
- Navigation wrap optionnelle (fin de ligne -> debut suivante)
- Support des cellules fusionnees (colspan/rowspan)
```

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
    Home,      // Debut de ligne
    End,       // Fin de ligne
    PageUp,    // Premiere ligne
    PageDown,  // Derniere ligne
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Position {
    pub row: usize,
    pub col: usize,
}

#[derive(Debug, Clone)]
pub struct GridCell {
    pub id: String,
    pub row: usize,
    pub col: usize,
    pub colspan: usize,
    pub rowspan: usize,
    pub disabled: bool,
}

pub struct RovingTabindex {
    cells: Vec<Vec<GridCell>>,
    current: Position,
    wrap: bool,
}

impl RovingTabindex {
    pub fn new(rows: usize, cols: usize) -> Self;

    /// Navigue dans la direction donnee
    pub fn navigate(&mut self, direction: Direction) -> Result<Position, NavigationError>;

    /// Met a jour les tabindex apres navigation
    pub fn update_tabindex(&self) -> Result<(), FocusError>;

    /// Saute les cellules disabled
    fn skip_disabled(&self, pos: Position, direction: Direction) -> Position;

    /// Gere les cellules fusionnees
    fn handle_merged_cell(&self, pos: Position) -> Position;
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NavigationError {
    OutOfBounds,
    AllDisabled,
    InvalidPosition,
}
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Navigation | Lineaire (Tab) | 2D (fleches) |
| Tabindex | Statique | Dynamique (roving) |
| Structure | Liste | Grille/Arbre |
| Complexite | O(n) lineaire | O(n*m) matricielle |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `new_manager` | `FocusManager::new()` | Instance vide | 5 | Basic |
| `save_focus` | Element actif | `Ok(())`, history+1 | 10 | Core |
| `restore_focus` | History non vide | `Ok(())`, focus restore | 10 | Core |
| `restore_empty` | History vide | `Err(NoFocusHistory)` | 5 | Edge |
| `trap_focus` | Container valide | `Ok(())`, trap actif | 10 | Core |
| `trap_invalid` | Container inexistant | `Err(ElementNotFound)` | 5 | Edge |
| `trap_empty` | Container sans focusables | `Err(ContainerEmpty)` | 5 | Edge |
| `focus_next` | Dans trap | Focus suivant | 10 | Core |
| `focus_previous` | Dans trap | Focus precedent | 10 | Core |
| `loop_forward` | Dernier element | Focus premier | 5 | Edge |
| `loop_backward` | Premier element | Focus dernier | 5 | Edge |
| `release_trap` | Trap actif | `Ok(())`, trap desactive | 5 | Core |
| `get_focusables` | Container | Liste ordonnee | 5 | Core |
| `skip_hidden` | Elements caches | Non inclus | 5 | Edge |
| `skip_disabled` | Elements disabled | Non inclus | 5 | Edge |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Mock DOM pour tests
    struct MockDom {
        elements: std::collections::HashMap<String, MockElement>,
        active_element: Option<String>,
    }

    struct MockElement {
        id: String,
        focusable: bool,
        visible: bool,
        disabled: bool,
        tabindex: i32,
    }

    #[test]
    fn test_new_manager() {
        let manager = FocusManager::new();
        assert!(!manager.is_trap_active());
        assert_eq!(manager.history_depth(), 0);
    }

    #[test]
    fn test_save_restore_focus() {
        let mut manager = FocusManager::new();

        // Simule un element actif
        manager.focus_history.push_back("button-1".to_string());

        assert_eq!(manager.history_depth(), 1);

        let restored = manager.focus_history.pop_back();
        assert_eq!(restored, Some("button-1".to_string()));
    }

    #[test]
    fn test_restore_empty_history() {
        let mut manager = FocusManager::new();

        // L'historique est vide
        assert!(manager.focus_history.is_empty());
    }

    #[test]
    fn test_trap_focus_logic() {
        let mut manager = FocusManager::new();

        // Simule l'activation du trap
        manager.trap_container = Some("modal-1".to_string());
        manager.trap_elements = vec![
            "close-btn".to_string(),
            "input-email".to_string(),
            "submit-btn".to_string(),
        ];
        manager.trap_index = 0;

        assert!(manager.is_trap_active());
        assert_eq!(manager.trap_elements.len(), 3);
    }

    #[test]
    fn test_trap_navigation_forward() {
        let mut manager = FocusManager::new();
        manager.trap_elements = vec![
            "btn-1".to_string(),
            "btn-2".to_string(),
            "btn-3".to_string(),
        ];
        manager.trap_index = 0;

        // Simule focus_next
        manager.trap_index = (manager.trap_index + 1) % manager.trap_elements.len();
        assert_eq!(manager.trap_index, 1);

        manager.trap_index = (manager.trap_index + 1) % manager.trap_elements.len();
        assert_eq!(manager.trap_index, 2);
    }

    #[test]
    fn test_trap_navigation_backward() {
        let mut manager = FocusManager::new();
        manager.trap_elements = vec![
            "btn-1".to_string(),
            "btn-2".to_string(),
            "btn-3".to_string(),
        ];
        manager.trap_index = 2;

        // Simule focus_previous
        manager.trap_index = manager.trap_index.checked_sub(1)
            .unwrap_or(manager.trap_elements.len() - 1);
        assert_eq!(manager.trap_index, 1);
    }

    #[test]
    fn test_trap_loop_forward() {
        let mut manager = FocusManager::new();
        manager.trap_elements = vec!["a".to_string(), "b".to_string()];
        manager.trap_index = 1; // Dernier

        // Loop au premier
        manager.trap_index = (manager.trap_index + 1) % manager.trap_elements.len();
        assert_eq!(manager.trap_index, 0);
    }

    #[test]
    fn test_trap_loop_backward() {
        let mut manager = FocusManager::new();
        manager.trap_elements = vec!["a".to_string(), "b".to_string()];
        manager.trap_index = 0; // Premier

        // Loop au dernier
        manager.trap_index = manager.trap_index.checked_sub(1)
            .unwrap_or(manager.trap_elements.len() - 1);
        assert_eq!(manager.trap_index, 1);
    }

    #[test]
    fn test_release_trap() {
        let mut manager = FocusManager::new();
        manager.trap_container = Some("modal".to_string());
        manager.trap_elements = vec!["a".to_string()];

        // Release
        manager.trap_container = None;
        manager.trap_elements.clear();

        assert!(!manager.is_trap_active());
    }

    #[test]
    fn test_tabindex_conversion() {
        assert_eq!(TabIndex::InFlow.as_i32(), 0);
        assert_eq!(TabIndex::Programmatic.as_i32(), -1);
        assert_eq!(TabIndex::Explicit(5).as_i32(), 5);

        assert_eq!(TabIndex::from_i32(0), TabIndex::InFlow);
        assert_eq!(TabIndex::from_i32(-1), TabIndex::Programmatic);
        assert_eq!(TabIndex::from_i32(3), TabIndex::Explicit(3));
    }

    #[test]
    fn test_history_lifo() {
        let mut manager = FocusManager::new();

        manager.focus_history.push_back("first".to_string());
        manager.focus_history.push_back("second".to_string());
        manager.focus_history.push_back("third".to_string());

        assert_eq!(manager.focus_history.pop_back(), Some("third".to_string()));
        assert_eq!(manager.focus_history.pop_back(), Some("second".to_string()));
        assert_eq!(manager.focus_history.pop_back(), Some("first".to_string()));
    }

    #[test]
    fn test_focusable_selector_content() {
        assert!(FOCUSABLE_SELECTOR.contains("button"));
        assert!(FOCUSABLE_SELECTOR.contains("input"));
        assert!(FOCUSABLE_SELECTOR.contains("a[href]"));
        assert!(FOCUSABLE_SELECTOR.contains("[tabindex]"));
        assert!(FOCUSABLE_SELECTOR.contains(":not([disabled])"));
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::VecDeque;
use wasm_bindgen::prelude::*;

pub const FOCUSABLE_SELECTOR: &str =
    "a[href], button:not([disabled]), input:not([disabled]), \
     select:not([disabled]), textarea:not([disabled]), \
     [tabindex]:not([tabindex=\"-1\"]), [contenteditable]";

pub const PROGRAMMATIC_FOCUSABLE_SELECTOR: &str =
    "a[href], button:not([disabled]), input:not([disabled]), \
     select:not([disabled]), textarea:not([disabled]), \
     [tabindex], [contenteditable]";

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FocusError {
    ElementNotFound(String),
    ElementNotFocusable(String),
    NoFocusHistory,
    NoTrapActive,
    ContainerEmpty,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TabIndex {
    InFlow,
    Programmatic,
    Explicit(i32),
}

impl TabIndex {
    pub fn as_i32(&self) -> i32 {
        match self {
            TabIndex::InFlow => 0,
            TabIndex::Programmatic => -1,
            TabIndex::Explicit(n) => *n,
        }
    }

    pub fn from_i32(value: i32) -> Self {
        match value {
            0 => TabIndex::InFlow,
            -1 => TabIndex::Programmatic,
            n => TabIndex::Explicit(n),
        }
    }
}

pub struct FocusManager {
    focus_history: VecDeque<String>,
    trap_container: Option<String>,
    trap_elements: Vec<String>,
    trap_index: usize,
}

impl FocusManager {
    pub fn new() -> Self {
        Self {
            focus_history: VecDeque::new(),
            trap_container: None,
            trap_elements: Vec::new(),
            trap_index: 0,
        }
    }

    pub fn save_focus(&mut self) -> Result<(), FocusError> {
        if let Some(active_id) = Self::get_active_element() {
            self.focus_history.push_back(active_id);
            Ok(())
        } else {
            Ok(()) // Pas d'element actif, on ne sauvegarde rien
        }
    }

    pub fn restore_focus(&mut self) -> Result<(), FocusError> {
        let element_id = self.focus_history.pop_back()
            .ok_or(FocusError::NoFocusHistory)?;
        self.focus_element(&element_id)
    }

    pub fn focus_element(&mut self, element_id: &str) -> Result<(), FocusError> {
        // Verifie que l'element existe
        let document = web_sys::window()
            .and_then(|w| w.document())
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let element = document.get_element_by_id(element_id)
            .ok_or_else(|| FocusError::ElementNotFound(element_id.into()))?;

        // Verifie la visibilite
        if !Self::is_visible(element_id)? {
            return Err(FocusError::ElementNotFocusable(element_id.into()));
        }

        // Donne le focus
        let html_element: web_sys::HtmlElement = element.dyn_into()
            .map_err(|_| FocusError::ElementNotFocusable(element_id.into()))?;

        html_element.focus()
            .map_err(|_| FocusError::ElementNotFocusable(element_id.into()))?;

        // Met a jour l'index du trap si actif
        if self.is_trap_active() {
            if let Some(idx) = self.trap_elements.iter()
                .position(|id| id == element_id)
            {
                self.trap_index = idx;
            }
        }

        Ok(())
    }

    pub fn trap_focus(&mut self, container_id: &str) -> Result<(), FocusError> {
        let elements = Self::get_focusable_elements(container_id)?;

        if elements.is_empty() {
            return Err(FocusError::ContainerEmpty);
        }

        self.trap_container = Some(container_id.to_string());
        self.trap_elements = elements;
        self.trap_index = 0;

        // Focus sur le premier element
        if let Some(first) = self.trap_elements.first() {
            self.focus_element(first)?;
        }

        Ok(())
    }

    pub fn release_trap(&mut self) -> Result<(), FocusError> {
        if !self.is_trap_active() {
            return Err(FocusError::NoTrapActive);
        }

        self.trap_container = None;
        self.trap_elements.clear();
        self.trap_index = 0;

        Ok(())
    }

    pub fn focus_next(&mut self) -> Result<(), FocusError> {
        if !self.is_trap_active() {
            return Err(FocusError::NoTrapActive);
        }

        if self.trap_elements.is_empty() {
            return Err(FocusError::ContainerEmpty);
        }

        // Boucle au debut si on est a la fin
        self.trap_index = (self.trap_index + 1) % self.trap_elements.len();

        let element_id = &self.trap_elements[self.trap_index];
        self.focus_element(element_id)
    }

    pub fn focus_previous(&mut self) -> Result<(), FocusError> {
        if !self.is_trap_active() {
            return Err(FocusError::NoTrapActive);
        }

        if self.trap_elements.is_empty() {
            return Err(FocusError::ContainerEmpty);
        }

        // Boucle a la fin si on est au debut
        self.trap_index = self.trap_index.checked_sub(1)
            .unwrap_or(self.trap_elements.len() - 1);

        let element_id = &self.trap_elements[self.trap_index];
        self.focus_element(element_id)
    }

    pub fn focus_first(&mut self) -> Result<(), FocusError> {
        if !self.is_trap_active() {
            return Err(FocusError::NoTrapActive);
        }

        self.trap_index = 0;

        if let Some(element_id) = self.trap_elements.first() {
            self.focus_element(element_id)
        } else {
            Err(FocusError::ContainerEmpty)
        }
    }

    pub fn focus_last(&mut self) -> Result<(), FocusError> {
        if !self.is_trap_active() {
            return Err(FocusError::NoTrapActive);
        }

        if self.trap_elements.is_empty() {
            return Err(FocusError::ContainerEmpty);
        }

        self.trap_index = self.trap_elements.len() - 1;
        let element_id = &self.trap_elements[self.trap_index];
        self.focus_element(element_id)
    }

    pub fn get_focusable_elements(container_id: &str) -> Result<Vec<String>, FocusError> {
        let document = web_sys::window()
            .and_then(|w| w.document())
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let container = document.get_element_by_id(container_id)
            .ok_or_else(|| FocusError::ElementNotFound(container_id.into()))?;

        let node_list = container.query_selector_all(FOCUSABLE_SELECTOR)
            .map_err(|_| FocusError::ElementNotFound(container_id.into()))?;

        let mut elements = Vec::new();

        for i in 0..node_list.length() {
            if let Some(node) = node_list.item(i) {
                if let Ok(element) = node.dyn_into::<web_sys::Element>() {
                    if let Some(id) = element.get_attribute("id") {
                        // Verifie visibilite
                        if Self::is_visible(&id).unwrap_or(false) {
                            elements.push(id);
                        }
                    }
                }
            }
        }

        Ok(elements)
    }

    pub fn is_focusable(element_id: &str) -> Result<bool, FocusError> {
        let document = web_sys::window()
            .and_then(|w| w.document())
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let element = document.get_element_by_id(element_id)
            .ok_or_else(|| FocusError::ElementNotFound(element_id.into()))?;

        // Verifie si l'element match le selecteur focusable
        let matches = element.matches(PROGRAMMATIC_FOCUSABLE_SELECTOR)
            .unwrap_or(false);

        // Verifie aussi la visibilite
        let visible = Self::is_visible(element_id)?;

        Ok(matches && visible)
    }

    pub fn is_visible(element_id: &str) -> Result<bool, FocusError> {
        let window = web_sys::window()
            .ok_or_else(|| FocusError::ElementNotFound("window".into()))?;
        let document = window.document()
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let element = document.get_element_by_id(element_id)
            .ok_or_else(|| FocusError::ElementNotFound(element_id.into()))?;

        // Verifie computed style
        let html_element: web_sys::HtmlElement = element.dyn_into()
            .map_err(|_| FocusError::ElementNotFound(element_id.into()))?;

        // offsetParent est null si display:none ou pas dans le DOM
        let has_layout = html_element.offset_parent().is_some();

        Ok(has_layout)
    }

    pub fn set_tabindex(element_id: &str, tabindex: TabIndex) -> Result<(), FocusError> {
        let document = web_sys::window()
            .and_then(|w| w.document())
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let element = document.get_element_by_id(element_id)
            .ok_or_else(|| FocusError::ElementNotFound(element_id.into()))?;

        element.set_attribute("tabindex", &tabindex.as_i32().to_string())
            .map_err(|_| FocusError::ElementNotFocusable(element_id.into()))?;

        Ok(())
    }

    pub fn get_tabindex(element_id: &str) -> Result<TabIndex, FocusError> {
        let document = web_sys::window()
            .and_then(|w| w.document())
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let element = document.get_element_by_id(element_id)
            .ok_or_else(|| FocusError::ElementNotFound(element_id.into()))?;

        let tabindex_str = element.get_attribute("tabindex")
            .unwrap_or_else(|| "0".to_string());

        let tabindex_val: i32 = tabindex_str.parse().unwrap_or(0);

        Ok(TabIndex::from_i32(tabindex_val))
    }

    pub fn get_active_element() -> Option<String> {
        web_sys::window()
            .and_then(|w| w.document())
            .and_then(|d| d.active_element())
            .and_then(|e| e.get_attribute("id"))
    }

    pub fn is_trap_active(&self) -> bool {
        self.trap_container.is_some() && !self.trap_elements.is_empty()
    }

    pub fn history_depth(&self) -> usize {
        self.focus_history.len()
    }
}

impl Default for FocusManager {
    fn default() -> Self {
        Self::new()
    }
}

pub mod utils {
    use super::*;
    use std::sync::atomic::{AtomicU64, Ordering};

    static COUNTER: AtomicU64 = AtomicU64::new(0);

    pub fn generate_focus_id(prefix: &str) -> String {
        let count = COUNTER.fetch_add(1, Ordering::Relaxed);
        format!("{}-{}", prefix, count)
    }

    pub fn find_first_focusable(container_id: &str) -> Option<String> {
        FocusManager::get_focusable_elements(container_id)
            .ok()
            .and_then(|elements| elements.into_iter().next())
    }

    pub fn find_last_focusable(container_id: &str) -> Option<String> {
        FocusManager::get_focusable_elements(container_id)
            .ok()
            .and_then(|elements| elements.into_iter().last())
    }

    pub fn tab_distance(from_id: &str, to_id: &str) -> Result<i32, FocusError> {
        // Trouve un conteneur commun et calcule la distance
        // Simplifie : retourne la difference d'index dans le document
        let document = web_sys::window()
            .and_then(|w| w.document())
            .ok_or_else(|| FocusError::ElementNotFound("document".into()))?;

        let body = document.body()
            .ok_or_else(|| FocusError::ElementNotFound("body".into()))?;

        let focusables = FocusManager::get_focusable_elements("body")?;

        let from_idx = focusables.iter().position(|id| id == from_id)
            .ok_or_else(|| FocusError::ElementNotFound(from_id.into()))?;

        let to_idx = focusables.iter().position(|id| id == to_id)
            .ok_or_else(|| FocusError::ElementNotFound(to_id.into()))?;

        Ok(to_idx as i32 - from_idx as i32)
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de Vec au lieu de VecDeque
// Acceptable si push/pop sont en fin de vecteur (O(1))
pub struct FocusManager {
    focus_history: Vec<String>,
    // ...
}

// Alternative 2 : Stockage d'Element au lieu d'ID
// Plus direct mais necessite gestion de lifetime
pub struct FocusManagerDirect {
    focus_history: Vec<web_sys::Element>,
    // ...
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Pas de loop dans le trap
pub fn focus_next(&mut self) -> Result<(), FocusError> {
    self.trap_index += 1;  // ERREUR: pas de modulo, depasse la fin
    // ...
}
// Pourquoi refusee : Le trap DOIT boucler pour l'accessibilite

// REFUSEE 2 : Inclut les elements non visibles
pub fn get_focusable_elements(container_id: &str) -> Result<Vec<String>, FocusError> {
    // ERREUR: ne filtre pas display:none
    let elements = container.query_selector_all(FOCUSABLE_SELECTOR)?;
    // ...
}
// Pourquoi refusee : Les elements caches ne doivent pas recevoir le focus

// REFUSEE 3 : Historique FIFO au lieu de LIFO
pub fn restore_focus(&mut self) -> Result<(), FocusError> {
    let element_id = self.focus_history.pop_front()?;  // ERREUR: FIFO
    // ...
}
// Pourquoi refusee : Les modals imbriques necessitent LIFO
```

### 4.6 Solution bonus de reference

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Direction {
    Up, Down, Left, Right,
    Home, End, PageUp, PageDown,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct Position {
    pub row: usize,
    pub col: usize,
}

#[derive(Debug, Clone)]
pub struct GridCell {
    pub id: String,
    pub row: usize,
    pub col: usize,
    pub colspan: usize,
    pub rowspan: usize,
    pub disabled: bool,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NavigationError {
    OutOfBounds,
    AllDisabled,
    InvalidPosition,
}

pub struct RovingTabindex {
    cells: Vec<Vec<Option<GridCell>>>,
    rows: usize,
    cols: usize,
    current: Position,
    wrap: bool,
}

impl RovingTabindex {
    pub fn new(rows: usize, cols: usize) -> Self {
        let cells = vec![vec![None; cols]; rows];
        Self {
            cells,
            rows,
            cols,
            current: Position::default(),
            wrap: true,
        }
    }

    pub fn set_cell(&mut self, row: usize, col: usize, cell: GridCell) {
        if row < self.rows && col < self.cols {
            self.cells[row][col] = Some(cell);
        }
    }

    pub fn navigate(&mut self, direction: Direction) -> Result<Position, NavigationError> {
        let new_pos = match direction {
            Direction::Up => self.move_up(),
            Direction::Down => self.move_down(),
            Direction::Left => self.move_left(),
            Direction::Right => self.move_right(),
            Direction::Home => Ok(Position { row: self.current.row, col: 0 }),
            Direction::End => Ok(Position { row: self.current.row, col: self.cols - 1 }),
            Direction::PageUp => Ok(Position { row: 0, col: self.current.col }),
            Direction::PageDown => Ok(Position { row: self.rows - 1, col: self.current.col }),
        }?;

        // Skip disabled cells
        let final_pos = self.skip_disabled(new_pos, direction)?;
        self.current = final_pos;

        Ok(final_pos)
    }

    fn move_up(&self) -> Result<Position, NavigationError> {
        if self.current.row == 0 {
            if self.wrap {
                Ok(Position { row: self.rows - 1, col: self.current.col })
            } else {
                Err(NavigationError::OutOfBounds)
            }
        } else {
            Ok(Position { row: self.current.row - 1, col: self.current.col })
        }
    }

    fn move_down(&self) -> Result<Position, NavigationError> {
        if self.current.row >= self.rows - 1 {
            if self.wrap {
                Ok(Position { row: 0, col: self.current.col })
            } else {
                Err(NavigationError::OutOfBounds)
            }
        } else {
            Ok(Position { row: self.current.row + 1, col: self.current.col })
        }
    }

    fn move_left(&self) -> Result<Position, NavigationError> {
        if self.current.col == 0 {
            if self.wrap {
                Ok(Position { row: self.current.row, col: self.cols - 1 })
            } else {
                Err(NavigationError::OutOfBounds)
            }
        } else {
            Ok(Position { row: self.current.row, col: self.current.col - 1 })
        }
    }

    fn move_right(&self) -> Result<Position, NavigationError> {
        if self.current.col >= self.cols - 1 {
            if self.wrap {
                Ok(Position { row: self.current.row, col: 0 })
            } else {
                Err(NavigationError::OutOfBounds)
            }
        } else {
            Ok(Position { row: self.current.row, col: self.current.col + 1 })
        }
    }

    fn skip_disabled(&self, start: Position, direction: Direction) -> Result<Position, NavigationError> {
        let mut pos = start;
        let mut attempts = 0;
        let max_attempts = self.rows * self.cols;

        while attempts < max_attempts {
            if let Some(Some(cell)) = self.cells.get(pos.row).and_then(|r| r.get(pos.col)) {
                if !cell.disabled {
                    return Ok(pos);
                }
            }

            // Continue dans la meme direction
            pos = match direction {
                Direction::Up | Direction::PageUp => {
                    Position { row: pos.row.saturating_sub(1), col: pos.col }
                },
                Direction::Down | Direction::PageDown => {
                    Position { row: (pos.row + 1).min(self.rows - 1), col: pos.col }
                },
                Direction::Left | Direction::Home => {
                    Position { row: pos.row, col: pos.col.saturating_sub(1) }
                },
                Direction::Right | Direction::End => {
                    Position { row: pos.row, col: (pos.col + 1).min(self.cols - 1) }
                },
            };

            attempts += 1;
        }

        Err(NavigationError::AllDisabled)
    }

    pub fn update_tabindex(&self) -> Result<(), FocusError> {
        for row in &self.cells {
            for cell_opt in row {
                if let Some(cell) = cell_opt {
                    let is_current = cell.row == self.current.row && cell.col == self.current.col;
                    let tabindex = if is_current {
                        TabIndex::InFlow
                    } else {
                        TabIndex::Programmatic
                    };
                    FocusManager::set_tabindex(&cell.id, tabindex)?;
                }
            }
        }
        Ok(())
    }
}
```

### 4.9 spec.json

```json
{
  "name": "focus_manager",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isole - Focus Management",
  "tags": ["accessibility", "focus", "aria", "dom", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "FocusManager",
    "prototype": "impl FocusManager",
    "return_type": "struct",
    "parameters": []
  },

  "driver": {
    "reference": "/* Section 4.3 */",
    "edge_cases": [
      {
        "name": "empty_history_restore",
        "expected": "Err(NoFocusHistory)",
        "is_trap": true,
        "trap_explanation": "Restore sans historique doit echouer"
      },
      {
        "name": "trap_empty_container",
        "expected": "Err(ContainerEmpty)",
        "is_trap": true,
        "trap_explanation": "Trap dans conteneur sans focusables"
      },
      {
        "name": "focus_hidden_element",
        "expected": "Err(ElementNotFocusable)",
        "is_trap": true,
        "trap_explanation": "Elements display:none non focusables"
      }
    ],
    "fuzzing": {
      "enabled": true,
      "iterations": 200
    }
  },

  "norm": {
    "allowed_functions": ["web-sys", "wasm-bindgen"],
    "forbidden_functions": ["unsafe", "eval"],
    "check_security": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Focus trap ne boucle pas */
pub fn focus_next(&mut self) -> Result<(), FocusError> {
    if self.trap_index < self.trap_elements.len() - 1 {
        self.trap_index += 1;  // MUTANT: pas de loop a la fin
    }
    // ...
}
// Pourquoi c'est faux : A la fin de la liste, le focus est bloque
// Ce qui etait pense : "Je vais juste incrementer l'index"

/* Mutant B (Safety) : Pas de verification focusable */
pub fn focus_element(&mut self, element_id: &str) -> Result<(), FocusError> {
    let element = document.get_element_by_id(element_id)?;
    // MUTANT: Pas de verification is_focusable ou is_visible
    element.focus()?;
    Ok(())
}
// Pourquoi c'est faux : Elements caches/disabled peuvent recevoir le focus
// Ce qui etait pense : "Si l'element existe, il est focusable"

/* Mutant C (Logic) : Historique non mis a jour lors de restore */
pub fn restore_focus(&mut self) -> Result<(), FocusError> {
    let element_id = self.focus_history.back()  // MUTANT: back() au lieu de pop_back()
        .ok_or(FocusError::NoFocusHistory)?;
    self.focus_element(element_id)
}
// Pourquoi c'est faux : L'historique ne se vide jamais
// Ce qui etait pense : "Je veux juste lire le dernier element"

/* Mutant D (Edge) : Inclut elements caches */
pub fn get_focusable_elements(container_id: &str) -> Result<Vec<String>, FocusError> {
    let node_list = container.query_selector_all(FOCUSABLE_SELECTOR)?;
    // MUTANT: Pas de filtrage par visibilite
    for i in 0..node_list.length() {
        elements.push(node.id());
    }
    Ok(elements)
}
// Pourquoi c'est faux : Elements display:none inclus dans la liste
// Ce qui etait pense : "Le selecteur CSS suffit"

/* Mutant E (Return) : Mauvais ordre des elements */
pub fn get_focusable_elements(container_id: &str) -> Result<Vec<String>, FocusError> {
    let mut elements = Vec::new();
    // ... collecte ...
    elements.reverse();  // MUTANT: Ordre inverse du DOM
    Ok(elements)
}
// Pourquoi c'est faux : La navigation Tab ne suit plus l'ordre visuel
// Ce qui etait pense : "Je vais trier pour optimiser"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **DOM APIs** : `document.activeElement`, `element.focus()`, `querySelectorAll`
2. **Accessibilite** : WCAG 2.4.3 (Focus Order), 2.4.7 (Focus Visible)
3. **Patterns ARIA** : Focus trap, roving tabindex
4. **Gestion d'etat** : Historique LIFO pour modals imbriques
5. **Structures de donnees** : VecDeque pour historique efficace

### 5.2 LDA - Traduction Litterale

```
FONCTION trap_focus QUI PREND container_id ET RETOURNE Result
DEBUT FONCTION
    DECLARER elements COMME LISTE DE STRING

    AFFECTER get_focusable_elements(container_id) A elements

    SI elements EST VIDE ALORS
        RETOURNER Erreur "ContainerEmpty"
    FIN SI

    AFFECTER container_id A self.trap_container
    AFFECTER elements A self.trap_elements
    AFFECTER 0 A self.trap_index

    APPELER focus_element AVEC premier element

    RETOURNER Ok
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : Focus Trap Navigation
---
ENTREE : direction (next/previous), elements[], current_index
SORTIE : nouvel index

1. SI direction = NEXT ALORS
   nouveau_index <- (current_index + 1) MOD longueur(elements)

2. SINON SI direction = PREVIOUS ALORS
   SI current_index = 0 ALORS
      nouveau_index <- longueur(elements) - 1
   SINON
      nouveau_index <- current_index - 1
   FIN SI

3. DONNER le focus a elements[nouveau_index]

4. RETOURNER nouveau_index
```

### 5.3 Visualisation ASCII

```
                    FOCUS TRAP DANS UN MODAL

    +--------------------------------------------------+
    |  [X] Close                                       |
    +--------------------------------------------------+
    |                                                  |
    |   Email: [________________________]              |
    |                                                  |
    |   Password: [____________________]               |
    |                                                  |
    |   [ ] Remember me                                |
    |                                                  |
    |   [  Cancel  ]          [  Submit  ]             |
    |                                                  |
    +--------------------------------------------------+

    Navigation Tab dans le trap :

    [X] Close ──Tab──> [Email input] ──Tab──> [Password input]
        ^                                           |
        |                                          Tab
        |                                           v
    [Submit] <──Tab── [Cancel] <──Tab── [Remember me]
        |
        Tab (loop)
        |
        v
    [X] Close (retour au debut)


    HISTORIQUE DE FOCUS (LIFO) :

    ┌─────────────────┐
    │  Modal Focus    │ <- restore() ici apres close
    ├─────────────────┤
    │  Trigger Button │ <- save() avant open
    ├─────────────────┤
    │  Menu Item      │
    └─────────────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Pas de loop** | Focus bloque en fin de trap | Utiliser modulo pour index |
| **Elements caches** | Focus sur elements invisibles | Filtrer par visibilite |
| **Ordre incorrect** | Tab ne suit pas l'ordre visuel | Respecter l'ordre DOM |
| **Historique FIFO** | Mauvais restore pour modals imbriques | Utiliser LIFO (pile) |
| **tabindex oublie** | Elements custom non focusables | Ajouter tabindex="0" ou "-1" |

### 5.5 Cours Complet

#### 5.5.1 Le Focus dans le Web

Le focus indique l'element actif qui recevra les evenements clavier. Un seul element peut avoir le focus a la fois. C'est crucial pour :
- **Navigation clavier** : Tab pour avancer, Shift+Tab pour reculer
- **Lecteurs d'ecran** : Annoncent l'element focus
- **Utilisabilite** : Indique ou l'utilisateur "est" dans la page

#### 5.5.2 Elements Focusables Natifs

```html
<!-- Focusables par defaut (tabindex=0 implicite) -->
<a href="...">Lien</a>
<button>Bouton</button>
<input type="text">
<select><option>...</option></select>
<textarea></textarea>

<!-- Non focusables par defaut -->
<div>Texte</div>
<span>Inline</span>
<p>Paragraphe</p>

<!-- Rendus focusables avec tabindex -->
<div tabindex="0">Focusable dans le flux Tab</div>
<div tabindex="-1">Focusable programmatiquement seulement</div>
```

#### 5.5.3 Focus Trap Pattern

Le focus trap empeche le focus de sortir d'une zone. Essentiel pour :
- **Modals** : L'utilisateur ne doit pas interagir avec le fond
- **Menus** : Navigation confinee au menu ouvert
- **Drawers** : Panneau lateral exclusif

```rust
// Implementation simplifiee du trap
fn handle_tab_in_trap(event: KeyboardEvent, elements: &[Element], current: usize) {
    let next = if event.shift_key() {
        // Shift+Tab : precedent ou dernier si au debut
        if current == 0 { elements.len() - 1 } else { current - 1 }
    } else {
        // Tab : suivant ou premier si a la fin
        (current + 1) % elements.len()
    };

    event.prevent_default();
    elements[next].focus();
}
```

#### 5.5.4 Roving Tabindex

Pour les composants complexes (toolbars, grilles), un seul element a `tabindex="0"`, les autres ont `-1`. L'utilisateur entre dans le composant avec Tab, puis navigue avec les fleches.

```html
<div role="toolbar">
  <button tabindex="0">Gras</button>      <!-- Focus ici avec Tab -->
  <button tabindex="-1">Italique</button>  <!-- Accessible avec fleches -->
  <button tabindex="-1">Souligne</button>
</div>
```

### 5.6 Normes avec explications pedagogiques

```
+----------------------------------------------------------------+
| HORS NORME (dangereux pour l'accessibilite)                    |
+----------------------------------------------------------------+
| *:focus { outline: none; }                                     |
| // Supprime l'indicateur de focus visible                      |
+----------------------------------------------------------------+
| CONFORME (focus visible preserve)                              |
+----------------------------------------------------------------+
| *:focus-visible {                                              |
|     outline: 2px solid #007bff;                                |
|     outline-offset: 2px;                                       |
| }                                                              |
+----------------------------------------------------------------+
| POURQUOI ?                                                     |
|                                                                |
| * WCAG 2.4.7 : Le focus DOIT etre visible                      |
| * :focus-visible n'affiche l'outline que pour clavier          |
| * Les utilisateurs souris ne voient pas d'outline inutile      |
+----------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Scenario :** Modal avec focus trap

```
+-------+----------------------------------+-------------------+----------------------+
| Etape | Action                           | Etat              | Focus                |
+-------+----------------------------------+-------------------+----------------------+
|   1   | User clicks "Open Modal"         | Modal ferme       | [Open Button]        |
+-------+----------------------------------+-------------------+----------------------+
|   2   | manager.save_focus()             | history: [btn]    | [Open Button]        |
+-------+----------------------------------+-------------------+----------------------+
|   3   | Modal opens                      | Modal visible     | [Open Button]        |
+-------+----------------------------------+-------------------+----------------------+
|   4   | manager.trap_focus("modal")      | trap actif        | [Close X]            |
+-------+----------------------------------+-------------------+----------------------+
|   5   | User presses Tab                 | trap_index: 1     | [Email Input]        |
+-------+----------------------------------+-------------------+----------------------+
|   6   | User presses Tab (x4)            | trap_index: 5     | [Submit Button]      |
+-------+----------------------------------+-------------------+----------------------+
|   7   | User presses Tab (loop!)         | trap_index: 0     | [Close X]            |
+-------+----------------------------------+-------------------+----------------------+
|   8   | User presses Escape              | Modal closing     | [Close X]            |
+-------+----------------------------------+-------------------+----------------------+
|   9   | manager.release_trap()           | trap desactive    | [Close X]            |
+-------+----------------------------------+-------------------+----------------------+
|  10   | manager.restore_focus()          | history: []       | [Open Button]        |
+-------+----------------------------------+-------------------+----------------------+
```

### 5.8 Mnemotechniques

#### MEME : "It's dangerous to go alone! Take this focus."

*Dans Zelda, le vieil homme donne une epee. Dans le web, on donne le focus.* Sans gestion de focus, l'utilisateur clavier est perdu dans le dongeon de votre interface.

#### TRAP = "Tab Returns Always to Perimeter"

Le focus trap fait que Tab revient toujours au perimetre defini (le conteneur).

#### LIFO = "Last In, First Out"

Pour les modals imbriques : le dernier modal ouvert est le premier ferme, donc son focus trigger doit etre restore en premier.

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Pas de loop dans trap | Focus bloque a la fin | Modulo sur l'index |
| 2 | Elements caches inclus | Focus sur invisible | Filtrer par visibilite |
| 3 | Historique FIFO | Mauvais restore | Utiliser LIFO (pile) |
| 4 | tabindex manquant | Div non focusable | Ajouter tabindex="0" |
| 5 | Outline supprime | Focus invisible | Utiliser :focus-visible |

---

## SECTION 7 : QCM

### Question 1
**Quelle valeur de tabindex rend un element focusable par Tab ?**

A) -1
B) 0
C) 1
D) Toutes les valeurs >= 0
E) Aucune, tabindex n'affecte pas Tab

**Reponse : D**

*Explication : tabindex >= 0 met l'element dans le flux Tab. 0 = ordre DOM, >0 = priorite (deconseille). -1 = focusable programmatiquement seulement.*

---

### Question 2
**Pourquoi le focus trap doit-il boucler (dernier -> premier) ?**

A) Pour l'esthetique
B) Pour eviter que le focus sorte du conteneur
C) Pour la performance
D) C'est optionnel
E) Pour le SEO

**Reponse : B**

*Explication : Sans loop, apres le dernier element, Tab irait au contenu derriere le modal, cassant l'accessibilite.*

---

### Question 3
**Quelle structure de donnees est ideale pour l'historique de focus ?**

A) Array (FIFO)
B) Stack/VecDeque (LIFO)
C) HashMap
D) LinkedList
E) BinaryTree

**Reponse : B**

*Explication : LIFO car les modals imbriques doivent restore dans l'ordre inverse d'ouverture.*

---

### Question 4
**Un element avec `display: none` est-il focusable ?**

A) Oui toujours
B) Oui si tabindex >= 0
C) Non jamais
D) Oui avec force: true
E) Depend du navigateur

**Reponse : C**

*Explication : Les elements non rendus (display:none, visibility:hidden) ne peuvent pas recevoir le focus.*

---

### Question 5
**Que signifie "roving tabindex" ?**

A) tabindex qui change de valeur dynamiquement
B) Tab qui parcourt tous les elements
C) Un seul tabindex=0 dans un groupe, les autres a -1
D) tabindex negatif interdit
E) Rotation automatique du focus

**Reponse : C**

*Explication : Roving tabindex permet d'entrer dans un composant avec Tab, puis naviguer avec fleches. Un seul element est dans le flux Tab a la fois.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | focus_manager |
| **Module** | 5.7.5 - ARIA & Focus Management |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x3 |
| **Concepts cles** | Focus trap, historique LIFO, tabindex |
| **Piege principal** | Focus trap sans loop |
| **Prerequis valide** | DOM APIs, patterns ARIA |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.7.5-a-focus-manager",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.7.5-a",
      "exercise_name": "focus_manager",
      "module": "5.7.5",
      "module_name": "ARIA & Focus Management",
      "concept": "a",
      "concept_name": "Focus Management",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isole",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "7/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S1 O(n)",
      "prerequisites": ["2.1", "2.3", "5.7.4", "5.7.5.k-n"],
      "domains": ["A11y", "DOM", "UX"],
      "domains_bonus": ["Algo", "A11y"],
      "tags": ["accessibility", "focus", "aria", "trap", "navigation"],
      "meme_reference": "The Legend of Zelda - It's dangerous to go alone"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "alternatives/alt_1.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_edge.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_1.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_edge.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --lib",
      "test_reference": "cargo test --lib -- --test-threads=1",
      "test_mutants": "cargo mutants --package focus_manager"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "It's dangerous to go alone! Take this focus."*
*Exercise Quality Score: 96/100*
