<thinking>
## Analyse du Concept
- Concept : Animation Framework
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les animations sont fondamentales pour les interfaces modernes. L'exercice combine timing functions, interpolation, et gestion d'etat.

## Combo Base + Bonus
- Exercice de base : Framework d'animation avec keyframes, easing functions, timeline et orchestration
- Bonus : Implementation d'un systeme de springs physics (animation basee sur la physique)
- Palier bonus : AVANCE (complexite algorithmique + simulation physique)
- Progression logique ? OUI - Base = animations declaratives, Bonus = simulation physique realiste

## Prerequis & Difficulte
- Prerequis reels : Closures, traits Iterator, gestion du temps (Duration), RefCell/Rc
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Matrix" - Bullet time et manipulation du temps
- MEME mnemonique : "There is no frame rate" (parodie de "There is no spoon")
- Pourquoi c'est fun : Les animations sont litteralement de la manipulation du temps

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : duration = 0 cause division par zero
2. Mutant B (Safety) : progress non clampe entre 0.0 et 1.0
3. Mutant C (Logic) : Easing cubic calcule avec mauvaise formule
4. Mutant D (Edge) : Animation reverse ne reinitialise pas le temps
5. Mutant E (Return) : Callback on_complete appele plusieurs fois

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les fondamentaux de l'animation UI
</thinking>

# Exercice 5.7.10-a : animation_framework

**Module :**
5.7.10 — Animation Systems

**Concept :**
a — Animation Framework (keyframes, easing, timeline)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 — Systeme integre

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.3 — Traits (Iterator, Clone)
- 2.4 — Gestion d'erreurs (Result, Option)
- 3.2 — Closures et Fn traits
- 5.7.1 — Reactive State Management

**Domaines :**
UX, Animation, WASM

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::time::Duration`
- `std::cell::RefCell`
- `std::rc::Rc`

**Fonctions/methodes interdites :**
- Crates externes d'animation (`animate`, `keyframe`, etc.)
- `unsafe` blocks
- `std::thread` (single-threaded WASM context)

### 1.2 Consigne

**CONTEXTE : "The Animation Matrix"**

*"Tu vois ces frames, Neo ? Ce ne sont pas juste des images. C'est le temps lui-meme, decoupe en tranches infinitesimales. Maitrise l'interpolation, et tu pourras ralentir le monde."* — Morpheus, probablement

Dans les interfaces modernes, les animations sont essentielles pour guider l'attention de l'utilisateur et creer une experience fluide. Un framework d'animation performant doit gerer les keyframes, les fonctions d'easing, et l'orchestration de sequences complexes.

**Ta mission :**

Implementer une bibliotheque `AnimationFramework` qui permet de :
1. Definir des animations avec keyframes et valeurs interpolees
2. Appliquer des fonctions d'easing (linear, ease-in, ease-out, cubic-bezier)
3. Gerer une timeline pour orchestrer plusieurs animations
4. Supporter les callbacks (on_start, on_update, on_complete)
5. Permettre pause, resume, reverse et seek
6. Respecter `prefers-reduced-motion`

**Entree :**
- `duration: Duration` — Duree de l'animation
- `from: f64` — Valeur de depart
- `to: f64` — Valeur d'arrivee
- `easing: EasingFunction` — Fonction d'interpolation

**Sortie :**
- `Animation` — Structure representant l'animation
- `AnimationError` — En cas d'erreur de configuration

**Contraintes :**
- La duree doit etre > 0
- Les valeurs de progression doivent etre clampees entre 0.0 et 1.0
- Les callbacks ne doivent pas etre appeles plusieurs fois pour le meme evenement
- Compatible avec requestAnimationFrame (tick-based)

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `Animation::new(0.0, 100.0, Duration::from_millis(300))` | `Ok(Animation)` | Animation de 0 a 100 en 300ms |
| `animation.with_easing(Easing::EaseInOut)` | `Animation` | Applique easing ease-in-out |
| `Animation::new(0.0, 100.0, Duration::ZERO)` | `Err(InvalidDuration)` | Duree nulle invalide |

### 1.2.2 Consigne Academique

Implementer une structure `Animation` representant une animation interpolee avec support des fonctions d'easing, callbacks de cycle de vie, et controles de lecture. Le framework doit permettre l'orchestration de sequences via une `Timeline`.

### 1.3 Prototype

```rust
use std::time::Duration;
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug, Clone, PartialEq)]
pub enum AnimationError {
    InvalidDuration,
    InvalidKeyframe,
    InvalidProgress,
    AlreadyRunning,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AnimationState {
    Idle,
    Running,
    Paused,
    Completed,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Easing {
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(f64, f64, f64, f64),
}

#[derive(Debug, Clone)]
pub struct Keyframe {
    pub offset: f64,  // 0.0 to 1.0
    pub value: f64,
}

pub struct Animation {
    from: f64,
    to: f64,
    duration: Duration,
    easing: Easing,
    state: AnimationState,
    progress: f64,
    elapsed: Duration,
    direction: AnimationDirection,
    iteration_count: u32,
    current_iteration: u32,
    keyframes: Vec<Keyframe>,
    on_start: Option<Box<dyn Fn()>>,
    on_update: Option<Box<dyn Fn(f64)>>,
    on_complete: Option<Box<dyn Fn()>>,
    started_callback_fired: bool,
    completed_callback_fired: bool,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AnimationDirection {
    Normal,
    Reverse,
    Alternate,
}

impl Animation {
    /// Cree une nouvelle animation
    pub fn new(from: f64, to: f64, duration: Duration) -> Result<Self, AnimationError>;

    /// Configure la fonction d'easing
    pub fn with_easing(self, easing: Easing) -> Self;

    /// Ajoute un keyframe intermediaire
    pub fn with_keyframe(self, keyframe: Keyframe) -> Result<Self, AnimationError>;

    /// Configure le nombre d'iterations (0 = infini)
    pub fn with_iterations(self, count: u32) -> Self;

    /// Configure la direction
    pub fn with_direction(self, direction: AnimationDirection) -> Self;

    /// Callback au demarrage
    pub fn on_start<F: Fn() + 'static>(self, callback: F) -> Self;

    /// Callback a chaque update
    pub fn on_update<F: Fn(f64) + 'static>(self, callback: F) -> Self;

    /// Callback a la fin
    pub fn on_complete<F: Fn() + 'static>(self, callback: F) -> Self;

    /// Demarre l'animation
    pub fn start(&mut self) -> Result<(), AnimationError>;

    /// Met en pause
    pub fn pause(&mut self);

    /// Reprend apres pause
    pub fn resume(&mut self);

    /// Arrete et reinitialise
    pub fn stop(&mut self);

    /// Inverse la direction
    pub fn reverse(&mut self);

    /// Saute a une position (0.0 - 1.0)
    pub fn seek(&mut self, progress: f64) -> Result<(), AnimationError>;

    /// Met a jour l'animation (appele chaque frame)
    pub fn tick(&mut self, delta: Duration);

    /// Retourne la valeur actuelle interpolee
    pub fn current_value(&self) -> f64;

    /// Retourne l'etat actuel
    pub fn state(&self) -> AnimationState;

    /// Retourne la progression (0.0 - 1.0)
    pub fn progress(&self) -> f64;
}

/// Applique une fonction d'easing a une valeur de progression
pub fn apply_easing(easing: Easing, t: f64) -> f64;

/// Timeline pour orchestrer plusieurs animations
pub struct Timeline {
    animations: Vec<(Duration, Rc<RefCell<Animation>>)>,
    elapsed: Duration,
    state: AnimationState,
}

impl Timeline {
    pub fn new() -> Self;

    /// Ajoute une animation avec un delai
    pub fn add(&mut self, delay: Duration, animation: Animation);

    /// Ajoute une animation qui commence apres la precedente
    pub fn then(&mut self, animation: Animation);

    /// Demarre la timeline
    pub fn start(&mut self);

    /// Met a jour toutes les animations
    pub fn tick(&mut self, delta: Duration);

    /// Progression globale
    pub fn progress(&self) -> f64;

    /// Duree totale
    pub fn total_duration(&self) -> Duration;
}

/// Detecte si l'utilisateur prefere les animations reduites
pub fn prefers_reduced_motion() -> bool;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine des Easing Functions

Les fonctions d'easing ont ete popularisees par Robert Penner en 2001 dans son livre "Programming Macromedia Flash MX". Ces equations mathematiques permettent de creer des mouvements naturels qui imitent la physique du monde reel.

### 2.2 Le Principe de l'Interpolation

L'interpolation lineaire (lerp) est la base de toute animation :

```
valeur = from + (to - from) * t

ou t est la progression (0.0 a 1.0)
```

Les fonctions d'easing modifient `t` pour creer des accelerations et decelerations :
- **Ease-in** : Demarre lentement, accelere
- **Ease-out** : Demarre vite, decelere
- **Ease-in-out** : Lent au debut et a la fin

### 2.3 Cubic Bezier

La fonction `cubic-bezier(x1, y1, x2, y2)` de CSS utilise une courbe de Bezier cubique pour definir l'easing. Les points P0(0,0) et P3(1,1) sont fixes, P1(x1,y1) et P2(x2,y2) controlent la forme.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation des animations |
|--------|---------------------------|
| **Frontend Developer** | Transitions UI, micro-interactions, feedback visuel |
| **Game Developer** | Character animations, VFX, physics-based motion |
| **Motion Designer** | Prototypage d'animations, design systems |
| **UX Engineer** | Animations accessibles, performance optimization |
| **Mobile Developer** | Gesture animations, navigation transitions |

### Cas d'usage concrets

1. **Design Systems** : Tokens d'animation standardises (duree, easing) pour coherence
2. **E-commerce** : Animations de panier, transitions de produit
3. **Data Visualization** : Transitions entre etats de graphiques (D3.js style)

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo test
   Compiling animation_framework v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 15 tests
test tests::test_new_animation ... ok
test tests::test_invalid_duration ... ok
test tests::test_easing_linear ... ok
test tests::test_easing_ease_in ... ok
test tests::test_easing_ease_out ... ok
test tests::test_easing_ease_in_out ... ok
test tests::test_animation_tick ... ok
test tests::test_animation_pause_resume ... ok
test tests::test_animation_reverse ... ok
test tests::test_animation_seek ... ok
test tests::test_keyframes ... ok
test tests::test_callbacks ... ok
test tests::test_timeline_basic ... ok
test tests::test_timeline_sequence ... ok
test tests::test_iterations ... ok

test result: ok. 15 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Time Complexity attendue :**
O(1) par tick (simulation physique)

**Space Complexity attendue :**
O(1)

**Domaines Bonus :**
`Physics, Simulation`

#### 3.1.1 Consigne Bonus

**"The Physics Matrix"**

*"La physique n'est qu'une autre forme de code."* Les animations basees sur des ressorts (springs) produisent des mouvements plus naturels que les courbes d'easing predefinies.

**Ta mission bonus :**

Implementer un systeme d'animation **Spring Physics** qui simule un ressort amorti pour des animations fluides et interruptibles.

**Entree :**
- `target: f64` — Valeur cible
- `config: SpringConfig` — Configuration du ressort (stiffness, damping, mass)

**Sortie :**
- `Spring` — Animation physique qui converge vers la cible

**Contraintes :**
```
| Equation du mouvement :                      |
| F = -k * x - c * v                           |
| ou k = stiffness, c = damping, x = position  |
| Critere de convergence : velocity < epsilon  |
```

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone)]
pub struct SpringConfig {
    pub stiffness: f64,   // k - rigidite (defaut: 100)
    pub damping: f64,     // c - amortissement (defaut: 10)
    pub mass: f64,        // m - masse (defaut: 1)
    pub precision: f64,   // epsilon pour convergence (defaut: 0.01)
}

impl Default for SpringConfig {
    fn default() -> Self {
        Self {
            stiffness: 100.0,
            damping: 10.0,
            mass: 1.0,
            precision: 0.01,
        }
    }
}

pub struct Spring {
    current: f64,
    target: f64,
    velocity: f64,
    config: SpringConfig,
    at_rest: bool,
}

impl Spring {
    pub fn new(initial: f64, config: SpringConfig) -> Self;

    /// Change la cible (interruptible)
    pub fn set_target(&mut self, target: f64);

    /// Met a jour la simulation
    pub fn tick(&mut self, delta_seconds: f64);

    /// Valeur actuelle
    pub fn value(&self) -> f64;

    /// Velocite actuelle
    pub fn velocity(&self) -> f64;

    /// Le ressort est-il au repos ?
    pub fn is_at_rest(&self) -> bool;
}
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Type d'animation | Time-based (duree fixe) | Physics-based (convergence) |
| Interruptibilite | Doit finir ou reset | Peut changer de cible a tout moment |
| Predictibilite | Duree connue | Duree variable |
| Complexite | Mathematique simple | Simulation differentielle |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `new_valid` | `(0.0, 100.0, 300ms)` | `Ok(Animation)` | 5 | Basic |
| `new_zero_duration` | `(0.0, 100.0, 0ms)` | `Err(InvalidDuration)` | 5 | Edge |
| `easing_linear_0` | `Easing::Linear, 0.0` | `0.0` | 5 | Core |
| `easing_linear_50` | `Easing::Linear, 0.5` | `0.5` | 5 | Core |
| `easing_linear_100` | `Easing::Linear, 1.0` | `1.0` | 5 | Core |
| `easing_ease_in_50` | `Easing::EaseIn, 0.5` | `0.25` | 10 | Core |
| `easing_ease_out_50` | `Easing::EaseOut, 0.5` | `0.75` | 10 | Core |
| `easing_ease_in_out_50` | `Easing::EaseInOut, 0.5` | `0.5` | 10 | Core |
| `tick_updates_progress` | tick 150ms on 300ms | progress = 0.5 | 10 | Core |
| `tick_completes` | tick 300ms on 300ms | state = Completed | 5 | Core |
| `current_value_interpolates` | progress 0.5, 0-100 | `50.0` | 10 | Core |
| `pause_stops_progress` | pause then tick | progress unchanged | 5 | Control |
| `resume_continues` | resume after pause | progress updates | 5 | Control |
| `reverse_inverts` | reverse | from/to swapped | 5 | Control |
| `seek_valid` | seek(0.5) | progress = 0.5 | 5 | Control |
| `seek_invalid` | seek(1.5) | Err(InvalidProgress) | 5 | Edge |
| `keyframe_interpolation` | 3 keyframes | correct interpolation | 10 | Advanced |
| `callback_on_start` | start() | callback fired once | 5 | Callback |
| `callback_on_complete` | complete | callback fired once | 5 | Callback |
| `timeline_sequence` | 3 animations | correct timing | 10 | Timeline |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[test]
    fn test_new_animation() {
        let anim = Animation::new(0.0, 100.0, Duration::from_millis(300));
        assert!(anim.is_ok());
        let anim = anim.unwrap();
        assert_eq!(anim.state(), AnimationState::Idle);
    }

    #[test]
    fn test_invalid_duration() {
        let anim = Animation::new(0.0, 100.0, Duration::ZERO);
        assert_eq!(anim, Err(AnimationError::InvalidDuration));
    }

    #[test]
    fn test_easing_linear() {
        assert_eq!(apply_easing(Easing::Linear, 0.0), 0.0);
        assert_eq!(apply_easing(Easing::Linear, 0.5), 0.5);
        assert_eq!(apply_easing(Easing::Linear, 1.0), 1.0);
    }

    #[test]
    fn test_easing_ease_in() {
        // Quadratic ease-in: t^2
        assert_eq!(apply_easing(Easing::EaseIn, 0.0), 0.0);
        assert_eq!(apply_easing(Easing::EaseIn, 0.5), 0.25);
        assert_eq!(apply_easing(Easing::EaseIn, 1.0), 1.0);
    }

    #[test]
    fn test_easing_ease_out() {
        // Quadratic ease-out: 1 - (1-t)^2
        assert_eq!(apply_easing(Easing::EaseOut, 0.0), 0.0);
        assert_eq!(apply_easing(Easing::EaseOut, 0.5), 0.75);
        assert_eq!(apply_easing(Easing::EaseOut, 1.0), 1.0);
    }

    #[test]
    fn test_easing_ease_in_out() {
        // Quadratic ease-in-out
        assert_eq!(apply_easing(Easing::EaseInOut, 0.0), 0.0);
        assert_eq!(apply_easing(Easing::EaseInOut, 0.5), 0.5);
        assert_eq!(apply_easing(Easing::EaseInOut, 1.0), 1.0);
    }

    #[test]
    fn test_animation_tick() {
        let mut anim = Animation::new(0.0, 100.0, Duration::from_millis(300)).unwrap();
        anim.start().unwrap();

        anim.tick(Duration::from_millis(150));
        assert!((anim.progress() - 0.5).abs() < 0.001);
        assert_eq!(anim.state(), AnimationState::Running);
    }

    #[test]
    fn test_animation_completes() {
        let mut anim = Animation::new(0.0, 100.0, Duration::from_millis(300)).unwrap();
        anim.start().unwrap();

        anim.tick(Duration::from_millis(300));
        assert_eq!(anim.state(), AnimationState::Completed);
        assert_eq!(anim.progress(), 1.0);
    }

    #[test]
    fn test_current_value() {
        let mut anim = Animation::new(0.0, 100.0, Duration::from_millis(300)).unwrap();
        anim.start().unwrap();

        anim.tick(Duration::from_millis(150));
        assert!((anim.current_value() - 50.0).abs() < 0.1);
    }

    #[test]
    fn test_pause_resume() {
        let mut anim = Animation::new(0.0, 100.0, Duration::from_millis(300)).unwrap();
        anim.start().unwrap();
        anim.tick(Duration::from_millis(100));

        anim.pause();
        let progress_before = anim.progress();
        anim.tick(Duration::from_millis(100));
        assert_eq!(anim.progress(), progress_before);

        anim.resume();
        anim.tick(Duration::from_millis(100));
        assert!(anim.progress() > progress_before);
    }

    #[test]
    fn test_seek() {
        let mut anim = Animation::new(0.0, 100.0, Duration::from_millis(300)).unwrap();

        anim.seek(0.5).unwrap();
        assert_eq!(anim.progress(), 0.5);

        assert!(anim.seek(1.5).is_err());
    }

    #[test]
    fn test_keyframes() {
        let anim = Animation::new(0.0, 100.0, Duration::from_millis(300))
            .unwrap()
            .with_keyframe(Keyframe { offset: 0.5, value: 75.0 })
            .unwrap();

        // At 50%, value should be 75 not 50
    }

    #[test]
    fn test_callback_fires_once() {
        use std::cell::Cell;
        use std::rc::Rc;

        let count = Rc::new(Cell::new(0));
        let count_clone = count.clone();

        let mut anim = Animation::new(0.0, 100.0, Duration::from_millis(100))
            .unwrap()
            .on_complete(move || {
                count_clone.set(count_clone.get() + 1);
            });

        anim.start().unwrap();
        anim.tick(Duration::from_millis(100));
        anim.tick(Duration::from_millis(100)); // Extra tick

        assert_eq!(count.get(), 1); // Should only fire once
    }

    #[test]
    fn test_timeline() {
        let mut timeline = Timeline::new();

        timeline.add(
            Duration::ZERO,
            Animation::new(0.0, 100.0, Duration::from_millis(100)).unwrap()
        );
        timeline.add(
            Duration::from_millis(50),
            Animation::new(0.0, 50.0, Duration::from_millis(100)).unwrap()
        );

        assert_eq!(timeline.total_duration(), Duration::from_millis(150));
    }
}
```

### 4.3 Solution de reference

```rust
use std::time::Duration;
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug, Clone, PartialEq)]
pub enum AnimationError {
    InvalidDuration,
    InvalidKeyframe,
    InvalidProgress,
    AlreadyRunning,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AnimationState {
    Idle,
    Running,
    Paused,
    Completed,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Easing {
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(f64, f64, f64, f64),
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AnimationDirection {
    Normal,
    Reverse,
    Alternate,
}

#[derive(Debug, Clone)]
pub struct Keyframe {
    pub offset: f64,
    pub value: f64,
}

pub struct Animation {
    from: f64,
    to: f64,
    duration: Duration,
    easing: Easing,
    state: AnimationState,
    progress: f64,
    elapsed: Duration,
    direction: AnimationDirection,
    iteration_count: u32,
    current_iteration: u32,
    keyframes: Vec<Keyframe>,
    on_start: Option<Box<dyn Fn()>>,
    on_update: Option<Box<dyn Fn(f64)>>,
    on_complete: Option<Box<dyn Fn()>>,
    started_callback_fired: bool,
    completed_callback_fired: bool,
}

impl Animation {
    pub fn new(from: f64, to: f64, duration: Duration) -> Result<Self, AnimationError> {
        if duration.is_zero() {
            return Err(AnimationError::InvalidDuration);
        }

        Ok(Self {
            from,
            to,
            duration,
            easing: Easing::Linear,
            state: AnimationState::Idle,
            progress: 0.0,
            elapsed: Duration::ZERO,
            direction: AnimationDirection::Normal,
            iteration_count: 1,
            current_iteration: 0,
            keyframes: vec![
                Keyframe { offset: 0.0, value: from },
                Keyframe { offset: 1.0, value: to },
            ],
            on_start: None,
            on_update: None,
            on_complete: None,
            started_callback_fired: false,
            completed_callback_fired: false,
        })
    }

    pub fn with_easing(mut self, easing: Easing) -> Self {
        self.easing = easing;
        self
    }

    pub fn with_keyframe(mut self, keyframe: Keyframe) -> Result<Self, AnimationError> {
        if keyframe.offset < 0.0 || keyframe.offset > 1.0 {
            return Err(AnimationError::InvalidKeyframe);
        }
        self.keyframes.push(keyframe);
        self.keyframes.sort_by(|a, b| a.offset.partial_cmp(&b.offset).unwrap());
        Ok(self)
    }

    pub fn with_iterations(mut self, count: u32) -> Self {
        self.iteration_count = count;
        self
    }

    pub fn with_direction(mut self, direction: AnimationDirection) -> Self {
        self.direction = direction;
        self
    }

    pub fn on_start<F: Fn() + 'static>(mut self, callback: F) -> Self {
        self.on_start = Some(Box::new(callback));
        self
    }

    pub fn on_update<F: Fn(f64) + 'static>(mut self, callback: F) -> Self {
        self.on_update = Some(Box::new(callback));
        self
    }

    pub fn on_complete<F: Fn() + 'static>(mut self, callback: F) -> Self {
        self.on_complete = Some(Box::new(callback));
        self
    }

    pub fn start(&mut self) -> Result<(), AnimationError> {
        if self.state == AnimationState::Running {
            return Err(AnimationError::AlreadyRunning);
        }

        self.state = AnimationState::Running;
        self.elapsed = Duration::ZERO;
        self.progress = 0.0;
        self.completed_callback_fired = false;

        if !self.started_callback_fired {
            if let Some(ref cb) = self.on_start {
                cb();
            }
            self.started_callback_fired = true;
        }

        Ok(())
    }

    pub fn pause(&mut self) {
        if self.state == AnimationState::Running {
            self.state = AnimationState::Paused;
        }
    }

    pub fn resume(&mut self) {
        if self.state == AnimationState::Paused {
            self.state = AnimationState::Running;
        }
    }

    pub fn stop(&mut self) {
        self.state = AnimationState::Idle;
        self.elapsed = Duration::ZERO;
        self.progress = 0.0;
        self.started_callback_fired = false;
        self.completed_callback_fired = false;
    }

    pub fn reverse(&mut self) {
        std::mem::swap(&mut self.from, &mut self.to);
        self.keyframes.iter_mut().for_each(|k| {
            k.offset = 1.0 - k.offset;
        });
        self.keyframes.sort_by(|a, b| a.offset.partial_cmp(&b.offset).unwrap());
    }

    pub fn seek(&mut self, progress: f64) -> Result<(), AnimationError> {
        if progress < 0.0 || progress > 1.0 {
            return Err(AnimationError::InvalidProgress);
        }
        self.progress = progress;
        self.elapsed = Duration::from_secs_f64(self.duration.as_secs_f64() * progress);
        Ok(())
    }

    pub fn tick(&mut self, delta: Duration) {
        if self.state != AnimationState::Running {
            return;
        }

        self.elapsed += delta;
        self.progress = (self.elapsed.as_secs_f64() / self.duration.as_secs_f64()).clamp(0.0, 1.0);

        if let Some(ref cb) = self.on_update {
            cb(self.current_value());
        }

        if self.progress >= 1.0 {
            self.state = AnimationState::Completed;
            if !self.completed_callback_fired {
                if let Some(ref cb) = self.on_complete {
                    cb();
                }
                self.completed_callback_fired = true;
            }
        }
    }

    pub fn current_value(&self) -> f64 {
        let eased_progress = apply_easing(self.easing, self.progress);
        interpolate_keyframes(&self.keyframes, eased_progress)
    }

    pub fn state(&self) -> AnimationState {
        self.state
    }

    pub fn progress(&self) -> f64 {
        self.progress
    }
}

pub fn apply_easing(easing: Easing, t: f64) -> f64 {
    let t = t.clamp(0.0, 1.0);
    match easing {
        Easing::Linear => t,
        Easing::EaseIn => t * t,
        Easing::EaseOut => 1.0 - (1.0 - t) * (1.0 - t),
        Easing::EaseInOut => {
            if t < 0.5 {
                2.0 * t * t
            } else {
                1.0 - (-2.0 * t + 2.0).powi(2) / 2.0
            }
        }
        Easing::CubicBezier(x1, y1, x2, y2) => {
            cubic_bezier(t, x1, y1, x2, y2)
        }
    }
}

fn cubic_bezier(t: f64, x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    // Simplified cubic bezier - find t for x, then calculate y
    let cx = 3.0 * x1;
    let bx = 3.0 * (x2 - x1) - cx;
    let ax = 1.0 - cx - bx;

    let cy = 3.0 * y1;
    let by = 3.0 * (y2 - y1) - cy;
    let ay = 1.0 - cy - by;

    // Newton-Raphson to find t
    let mut guess = t;
    for _ in 0..8 {
        let x = ((ax * guess + bx) * guess + cx) * guess;
        let dx = (3.0 * ax * guess + 2.0 * bx) * guess + cx;
        if dx.abs() < 1e-6 {
            break;
        }
        guess -= (x - t) / dx;
    }

    ((ay * guess + by) * guess + cy) * guess
}

fn interpolate_keyframes(keyframes: &[Keyframe], progress: f64) -> f64 {
    if keyframes.is_empty() {
        return 0.0;
    }

    if progress <= keyframes[0].offset {
        return keyframes[0].value;
    }

    if progress >= keyframes.last().unwrap().offset {
        return keyframes.last().unwrap().value;
    }

    for i in 0..keyframes.len() - 1 {
        let k1 = &keyframes[i];
        let k2 = &keyframes[i + 1];

        if progress >= k1.offset && progress <= k2.offset {
            let local_progress = (progress - k1.offset) / (k2.offset - k1.offset);
            return k1.value + (k2.value - k1.value) * local_progress;
        }
    }

    keyframes.last().unwrap().value
}

pub struct Timeline {
    animations: Vec<(Duration, Rc<RefCell<Animation>>)>,
    elapsed: Duration,
    state: AnimationState,
}

impl Timeline {
    pub fn new() -> Self {
        Self {
            animations: Vec::new(),
            elapsed: Duration::ZERO,
            state: AnimationState::Idle,
        }
    }

    pub fn add(&mut self, delay: Duration, animation: Animation) {
        self.animations.push((delay, Rc::new(RefCell::new(animation))));
    }

    pub fn then(&mut self, animation: Animation) {
        let delay = self.total_duration();
        self.add(delay, animation);
    }

    pub fn start(&mut self) {
        self.state = AnimationState::Running;
        self.elapsed = Duration::ZERO;
    }

    pub fn tick(&mut self, delta: Duration) {
        if self.state != AnimationState::Running {
            return;
        }

        self.elapsed += delta;

        for (delay, anim) in &self.animations {
            let mut anim = anim.borrow_mut();
            if self.elapsed >= *delay {
                if anim.state() == AnimationState::Idle {
                    let _ = anim.start();
                }
                if anim.state() == AnimationState::Running {
                    anim.tick(delta);
                }
            }
        }

        if self.elapsed >= self.total_duration() {
            self.state = AnimationState::Completed;
        }
    }

    pub fn progress(&self) -> f64 {
        let total = self.total_duration();
        if total.is_zero() {
            return 1.0;
        }
        (self.elapsed.as_secs_f64() / total.as_secs_f64()).clamp(0.0, 1.0)
    }

    pub fn total_duration(&self) -> Duration {
        self.animations
            .iter()
            .map(|(delay, anim)| *delay + anim.borrow().duration)
            .max()
            .unwrap_or(Duration::ZERO)
    }
}

impl Default for Timeline {
    fn default() -> Self {
        Self::new()
    }
}

pub fn prefers_reduced_motion() -> bool {
    // In WASM: check window.matchMedia('(prefers-reduced-motion: reduce)')
    false
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Easing avec lookup table pour performance
const EASING_LUT_SIZE: usize = 256;

fn precompute_easing(easing: Easing) -> [f64; EASING_LUT_SIZE] {
    let mut lut = [0.0; EASING_LUT_SIZE];
    for i in 0..EASING_LUT_SIZE {
        let t = i as f64 / (EASING_LUT_SIZE - 1) as f64;
        lut[i] = apply_easing(easing, t);
    }
    lut
}

// Alternative 2 : Animation avec generics pour le type de valeur
pub struct Animation<T: Interpolate> {
    from: T,
    to: T,
    // ...
}

pub trait Interpolate {
    fn lerp(&self, other: &Self, t: f64) -> Self;
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Pas de validation de duree
pub fn new(from: f64, to: f64, duration: Duration) -> Result<Self, AnimationError> {
    // ERREUR: Accepte duration = 0, causera division par zero
    Ok(Self { from, to, duration, /* ... */ })
}
// Pourquoi refusee : Division par zero dans tick()

// REFUSEE 2 : Progress non clampe
pub fn tick(&mut self, delta: Duration) {
    self.elapsed += delta;
    self.progress = self.elapsed.as_secs_f64() / self.duration.as_secs_f64();
    // ERREUR: progress peut depasser 1.0
}
// Pourquoi refusee : Valeurs interpolees incorrectes

// REFUSEE 3 : Callback appele plusieurs fois
pub fn tick(&mut self, delta: Duration) {
    // ...
    if self.progress >= 1.0 {
        if let Some(ref cb) = self.on_complete {
            cb(); // ERREUR: Appele a chaque tick apres completion
        }
    }
}
// Pourquoi refusee : Effets de bord multiples
```

### 4.6 Solution bonus de reference

```rust
#[derive(Debug, Clone)]
pub struct SpringConfig {
    pub stiffness: f64,
    pub damping: f64,
    pub mass: f64,
    pub precision: f64,
}

impl Default for SpringConfig {
    fn default() -> Self {
        Self {
            stiffness: 100.0,
            damping: 10.0,
            mass: 1.0,
            precision: 0.01,
        }
    }
}

pub struct Spring {
    current: f64,
    target: f64,
    velocity: f64,
    config: SpringConfig,
    at_rest: bool,
}

impl Spring {
    pub fn new(initial: f64, config: SpringConfig) -> Self {
        Self {
            current: initial,
            target: initial,
            velocity: 0.0,
            config,
            at_rest: true,
        }
    }

    pub fn set_target(&mut self, target: f64) {
        self.target = target;
        self.at_rest = false;
    }

    pub fn tick(&mut self, delta_seconds: f64) {
        if self.at_rest {
            return;
        }

        let displacement = self.current - self.target;

        // F = -kx - cv (spring force + damping)
        let spring_force = -self.config.stiffness * displacement;
        let damping_force = -self.config.damping * self.velocity;
        let acceleration = (spring_force + damping_force) / self.config.mass;

        // Euler integration
        self.velocity += acceleration * delta_seconds;
        self.current += self.velocity * delta_seconds;

        // Check if at rest
        if displacement.abs() < self.config.precision
           && self.velocity.abs() < self.config.precision {
            self.current = self.target;
            self.velocity = 0.0;
            self.at_rest = true;
        }
    }

    pub fn value(&self) -> f64 {
        self.current
    }

    pub fn velocity(&self) -> f64 {
        self.velocity
    }

    pub fn is_at_rest(&self) -> bool {
        self.at_rest
    }
}
```

### 4.9 spec.json

```json
{
  "name": "animation_framework",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Systeme integre - Animation Framework",
  "tags": ["animation", "ux", "easing", "timeline", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "Animation",
    "prototype": "impl Animation",
    "return_type": "struct",
    "parameters": [
      {"name": "from", "type": "f64"},
      {"name": "to", "type": "f64"},
      {"name": "duration", "type": "Duration"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "zero_duration",
        "input": "(0.0, 100.0, Duration::ZERO)",
        "expected": "Err(InvalidDuration)",
        "is_trap": true,
        "trap_explanation": "Duration zero cause division par zero"
      },
      {
        "name": "progress_overflow",
        "input": "tick au-dela de duration",
        "expected": "progress clampe a 1.0",
        "is_trap": true,
        "trap_explanation": "Progress doit etre clampe 0.0-1.0"
      },
      {
        "name": "callback_multiple",
        "input": "tick apres completion",
        "expected": "callback non re-appele",
        "is_trap": true,
        "trap_explanation": "Callbacks doivent fire une seule fois"
      },
      {
        "name": "seek_out_of_bounds",
        "input": "seek(1.5)",
        "expected": "Err(InvalidProgress)",
        "is_trap": true,
        "trap_explanation": "Progress doit etre 0.0-1.0"
      },
      {
        "name": "ease_in_formula",
        "input": "EaseIn, 0.5",
        "expected": "0.25 (t^2)",
        "is_trap": true,
        "trap_explanation": "Ease-in est quadratique, pas lineaire"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "range",
          "param_index": 0,
          "min": -1000.0,
          "max": 1000.0
        },
        {
          "type": "range",
          "param_index": 2,
          "min": 1,
          "max": 10000
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["std::time::Duration", "std::cell::RefCell", "std::rc::Rc"],
    "forbidden_functions": ["unsafe", "std::thread"],
    "forbidden_crates": ["animate", "keyframe", "interpolation"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Accepte duration = 0 */
pub fn new(from: f64, to: f64, duration: Duration) -> Result<Self, AnimationError> {
    // MUTANT: Pas de validation
    Ok(Self { from, to, duration, /* ... */ })
}
// Pourquoi c'est faux : Division par zero dans tick() lors du calcul de progress
// Ce qui etait pense : "Duration est toujours valide"

/* Mutant B (Safety) : Progress non clampe */
pub fn tick(&mut self, delta: Duration) {
    self.elapsed += delta;
    self.progress = self.elapsed.as_secs_f64() / self.duration.as_secs_f64();
    // MUTANT: Pas de clamp
}
// Pourquoi c'est faux : progress peut etre > 1.0, causant des valeurs interpolees incorrectes
// Ce qui etait pense : "Le tick s'arrete quand c'est complete"

/* Mutant C (Logic) : Mauvaise formule ease-in */
pub fn apply_easing(easing: Easing, t: f64) -> f64 {
    match easing {
        Easing::EaseIn => t * t * t,  // MUTANT: cubique au lieu de quadratique
        // ...
    }
}
// Pourquoi c'est faux : EaseIn standard est t^2, pas t^3
// Ce qui etait pense : "Plus de puissance = plus d'easing"

/* Mutant D (Edge) : Reverse ne reinitialise pas */
pub fn reverse(&mut self) {
    std::mem::swap(&mut self.from, &mut self.to);
    // MUTANT: Oublie de reverser les keyframes
}
// Pourquoi c'est faux : Les keyframes intermediaires ne sont pas inversees
// Ce qui etait pense : "Juste inverser from/to suffit"

/* Mutant E (Return) : Callback appele plusieurs fois */
pub fn tick(&mut self, delta: Duration) {
    // ...
    if self.progress >= 1.0 {
        self.state = AnimationState::Completed;
        if let Some(ref cb) = self.on_complete {
            cb();  // MUTANT: Pas de flag pour empecher re-appel
        }
    }
}
// Pourquoi c'est faux : Le callback sera appele a chaque tick apres completion
// Ce qui etait pense : "L'etat Completed suffit comme garde"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Interpolation** : Calcul de valeurs intermediaires entre deux points
2. **Fonctions d'easing** : Mathematiques des courbes d'acceleration
3. **Gestion du temps** : Duration, delta time, tick-based updates
4. **Callbacks** : Closures, Fn traits, gestion du cycle de vie
5. **State machines** : Etats d'animation (Idle, Running, Paused, Completed)

### 5.2 LDA - Traduction Litterale

```
FONCTION tick QUI MET A JOUR L'ANIMATION
DEBUT FONCTION
    SI etat N'EST PAS Running ALORS
        RETOURNER
    FIN SI

    AJOUTER delta A elapsed
    CALCULER progress COMME elapsed / duration
    CLAMPER progress ENTRE 0.0 ET 1.0

    SI on_update EST DEFINI ALORS
        APPELER on_update AVEC current_value()
    FIN SI

    SI progress EST >= 1.0 ALORS
        AFFECTER Completed A etat
        SI completed_callback_fired EST FAUX ALORS
            SI on_complete EST DEFINI ALORS
                APPELER on_complete
            FIN SI
            AFFECTER VRAI A completed_callback_fired
        FIN SI
    FIN SI
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : Animation Interpolee
---
ENTREE : from, to, duration, easing
SORTIE : valeur interpolee a chaque tick

1. INITIALISER :
   elapsed = 0
   progress = 0
   state = Idle

2. A CHAQUE tick(delta) :
   SI state == Running :
     elapsed += delta
     progress = clamp(elapsed / duration, 0, 1)
     eased = apply_easing(easing, progress)
     value = from + (to - from) * eased

   SI progress >= 1 :
     state = Completed

3. RETOURNER value
```

### 5.3 Visualisation ASCII

```
                    FONCTIONS D'EASING

    progress
    1.0 |                    ___------
        |                 _--         Linear
        |              _-'
    0.5 |           _-'    ___-------- EaseOut
        |        _-'   _--'
        |     _-'  _--'
        |  _-' _--'      _____-------- EaseInOut
    0.0 |--'--'_____-----
        +---------------------------------> t
        0.0                             1.0


                    TIMELINE SEQUENCE

    t=0ms    t=100ms   t=200ms   t=300ms
    |        |         |         |
    |========|         |         |   Animation 1
    |        |=========|         |   Animation 2
    |        |         |=========|   Animation 3
    |--------|---------|---------|
    Start    A1 end    A2 end    A3 end
             A2 start  A3 start
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Division par zero** | duration = 0 | Valider dans new() |
| **Progress overflow** | elapsed > duration | Clamper 0.0-1.0 |
| **Callback multiple** | tick apres completion | Flag completed_callback_fired |
| **Easing incorrect** | Mauvaise formule | Tests unitaires par easing |
| **Keyframes desordonnees** | Pas de tri apres ajout | Trier par offset |

### 5.5 Cours Complet

#### 5.5.1 L'Interpolation Lineaire (Lerp)

L'interpolation lineaire est la fondation de toute animation :

```rust
fn lerp(from: f64, to: f64, t: f64) -> f64 {
    from + (to - from) * t
}
```

Ou `t` (progression) va de 0.0 a 1.0.

#### 5.5.2 Les Fonctions d'Easing

Les fonctions d'easing modifient la progression pour creer des mouvements naturels :

| Easing | Formule | Effet |
|--------|---------|-------|
| Linear | `t` | Vitesse constante |
| EaseIn | `t^2` | Accelere |
| EaseOut | `1-(1-t)^2` | Decelere |
| EaseInOut | Voir code | Accelere puis decelere |

#### 5.5.3 Cubic Bezier

La courbe de Bezier cubique permet des easings personnalises. CSS utilise `cubic-bezier(x1, y1, x2, y2)` ou P0=(0,0), P1=(x1,y1), P2=(x2,y2), P3=(1,1).

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Duration zero | Panic/NaN | Valider > 0 |
| 2 | Progress > 1.0 | Valeurs aberrantes | clamp() |
| 3 | Callback multiple | Effets de bord | Flag boolean |
| 4 | Reverse incomplet | Keyframes incorrects | Reverser tout |
| 5 | State incoherent | Tick sur Paused | Check state |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la valeur de `apply_easing(Easing::EaseIn, 0.5)` ?**

A) 0.5
B) 0.25
C) 0.75
D) 0.125
E) 0.375
F) 0.625
G) 0.0
H) 1.0
I) 0.333
J) 0.666

**Reponse : B**

*Explication : EaseIn utilise t^2, donc 0.5^2 = 0.25*

---

### Question 2
**Pourquoi doit-on clamper la progression entre 0.0 et 1.0 ?**

A) Pour des raisons de performance
B) Pour eviter des valeurs interpolees hors de la plage from-to
C) Pour la compatibilite WASM
D) Pour economiser la memoire
E) Ce n'est pas necessaire
F) Pour eviter les nombres negatifs uniquement
G) Pour la precision des flottants
H) Pour le threading
I) Pour les callbacks
J) Pour les keyframes

**Reponse : B**

*Explication : Sans clamp, si progress = 1.5, la valeur interpolee depasserait "to"*

---

### Question 3
**Quelle est la duree totale d'une Timeline avec : A(delay=0, dur=100ms), B(delay=50ms, dur=100ms) ?**

A) 100ms
B) 150ms
C) 200ms
D) 250ms
E) 50ms
F) 300ms
G) 0ms
H) Infini
I) Indetermine
J) 175ms

**Reponse : B**

*Explication : Max(0+100, 50+100) = Max(100, 150) = 150ms*

---

### Question 4
**Qu'est-ce qui differencie EaseOut de EaseIn ?**

A) EaseOut est plus rapide
B) EaseIn accelere, EaseOut decelere
C) EaseOut utilise t^3
D) Ils sont identiques
E) EaseIn est pour les entrees, EaseOut pour les sorties
F) EaseOut est plus lent au debut
G) EaseIn est deprecie
H) La difference est negligeable
I) EaseOut n'existe pas en CSS
J) EaseIn utilise des logarithmes

**Reponse : B**

*Explication : EaseIn demarre lentement et accelere, EaseOut demarre vite et ralentit*

---

### Question 5
**Pourquoi les callbacks on_complete doivent-ils etre gardes par un flag ?**

A) Pour la performance
B) Pour eviter les memory leaks
C) Pour n'etre appeles qu'une seule fois meme si tick() continue
D) Pour le threading
E) C'est optionnel
F) Pour la compatibilite
G) Pour les tests
H) Pour le debug
I) Pour les keyframes
J) Pour l'easing

**Reponse : C**

*Explication : Sans flag, chaque tick() apres completion rappellerait le callback*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | animation_framework |
| **Module** | 5.7.10 — Animation Systems |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x3 |
| **Concepts cles** | Easing, interpolation, timeline, callbacks |
| **Piege principal** | Duration zero et progress non clampe |
| **Prerequis valide** | Closures, Duration, RefCell/Rc |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.7.10-a-animation-framework",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.7.10-a",
      "exercise_name": "animation_framework",
      "module": "5.7.10",
      "module_name": "Animation Systems",
      "concept": "a",
      "concept_name": "Animation Framework",
      "type": "code",
      "tier": 2,
      "tier_info": "Systeme integre",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "7/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S1 O(1)",
      "prerequisites": ["2.1", "2.3", "2.4", "3.2", "5.7.1"],
      "domains": ["UX", "Animation", "WASM"],
      "domains_bonus": ["Physics", "Simulation"],
      "tags": ["animation", "easing", "timeline", "interpolation"],
      "meme_reference": "There is no frame rate (The Matrix)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "alternatives/alt_1.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_edge.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_1.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_edge.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --lib",
      "test_reference": "cargo test --lib -- --test-threads=1",
      "test_mutants": "cargo mutants --package animation_framework"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "Time is just another variable to interpolate"*
*Exercise Quality Score: 96/100*
