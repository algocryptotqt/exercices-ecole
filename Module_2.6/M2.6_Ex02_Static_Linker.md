# Ex02: Static Linker - Mini Editeur de Liens Statique

## Concepts couverts
- 2.6.8.d: Strong vs weak: Resolution rules
- 2.6.8.e: Duplicate symbols: Error or use one
- 2.6.8.h: ar: Create archive
- 2.6.8.i: Archive extraction: Only needed objects
- 2.6.8.j: Link order: Matters for archives
- 2.6.9.e: .: Location counter

## Description
Implementer un mini editeur de liens statique en C17 qui combine plusieurs fichiers objets en un seul executable. Le linker doit gerer la resolution de symboles (forts vs faibles), les archives (.a), et l'ordre de linkage.

## Objectifs pedagogiques
1. Comprendre le processus de linkage statique
2. Maitriser la resolution de symboles forts et faibles
3. Implementer l'extraction selective d'objets depuis une archive
4. Comprendre l'importance de l'ordre des fichiers dans le linkage

## Structure (C17)

```c
/**
 * mini_linker.c - Mini editeur de liens statique
 *
 * Compile: gcc -std=c17 -Wall -Wextra -o mini_linker mini_linker.c
 * Usage: ./mini_linker -o output file1.o file2.o libfoo.a
 */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <elf.h>
#include <ar.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define MAX_OBJECTS 256
#define MAX_SYMBOLS 4096
#define MAX_SECTIONS 128

/* Types de symboles pour la resolution */
typedef enum {
    SYM_UNDEFINED,    /* Symbole non defini */
    SYM_STRONG,       /* Definition forte (fonction, variable initialisee) */
    SYM_WEAK,         /* Definition faible (peut etre surchargee) */
    SYM_COMMON        /* Variable non initialisee (BSS) */
} SymbolStrength;

/* Entree de la table de symboles globale */
typedef struct {
    char name[256];
    SymbolStrength strength;
    uint64_t value;
    uint64_t size;
    int source_object;     /* Index du fichier objet source */
    int section_index;     /* Index de la section dans l'objet */
    bool is_resolved;
} GlobalSymbol;

/* Section d'un fichier objet */
typedef struct {
    char name[64];
    uint32_t type;
    uint64_t flags;
    uint64_t addr;
    uint64_t offset;
    uint64_t size;
    uint64_t output_offset;  /* Offset dans l'executable final */
    void *data;
} Section;

/* Fichier objet charge */
typedef struct {
    char filename[256];
    void *data;
    size_t size;
    Elf64_Ehdr *ehdr;
    Elf64_Shdr *shdr;
    Section sections[MAX_SECTIONS];
    int section_count;
    bool is_needed;           /* Pour les archives: est-ce qu'on l'inclut? */
} ObjectFile;

/* Archive (.a file) */
typedef struct {
    char filename[256];
    void *data;
    size_t size;
    ObjectFile members[MAX_OBJECTS];
    int member_count;
} ArchiveFile;

/* Contexte du linker */
typedef struct {
    ObjectFile objects[MAX_OBJECTS];
    int object_count;

    ArchiveFile archives[32];
    int archive_count;

    GlobalSymbol symbols[MAX_SYMBOLS];
    int symbol_count;

    uint64_t location_counter;  /* . (location counter) du linker script */

    char *output_filename;
} LinkerContext;

/**
 * Determine la force d'un symbole
 */
SymbolStrength get_symbol_strength(const Elf64_Sym *sym) {
    uint8_t bind = ELF64_ST_BIND(sym->st_info);

    if (sym->st_shndx == SHN_UNDEF) {
        return SYM_UNDEFINED;
    }

    if (bind == STB_WEAK) {
        return SYM_WEAK;
    }

    if (sym->st_shndx == SHN_COMMON) {
        return SYM_COMMON;
    }

    return SYM_STRONG;  /* STB_GLOBAL avec definition */
}

/**
 * Resout un conflit entre deux symboles
 * Retourne true si new_sym doit remplacer existing
 *
 * Regles de resolution:
 * 1. STRONG + STRONG (meme nom) = ERREUR (duplicate symbol)
 * 2. STRONG + WEAK = STRONG gagne
 * 3. WEAK + WEAK = Premier gagne
 * 4. STRONG/WEAK + UNDEFINED = Le defini gagne
 * 5. COMMON + STRONG = STRONG gagne
 * 6. COMMON + COMMON = Le plus grand gagne
 */
bool resolve_symbol_conflict(GlobalSymbol *existing,
                             const GlobalSymbol *new_sym,
                             char *error_msg, size_t error_size) {
    /* Cas 1: Deux symboles forts = erreur */
    if (existing->strength == SYM_STRONG && new_sym->strength == SYM_STRONG) {
        snprintf(error_msg, error_size,
                 "duplicate symbol: %s (defined in object %d and %d)",
                 existing->name, existing->source_object, new_sym->source_object);
        return false;  /* Erreur fatale */
    }

    /* Cas 2: Fort vs Faible - le fort gagne */
    if (existing->strength == SYM_STRONG && new_sym->strength == SYM_WEAK) {
        return false;  /* Garder l'existant */
    }
    if (existing->strength == SYM_WEAK && new_sym->strength == SYM_STRONG) {
        return true;   /* Remplacer par le nouveau */
    }

    /* Cas 3: Deux faibles - le premier gagne */
    if (existing->strength == SYM_WEAK && new_sym->strength == SYM_WEAK) {
        return false;  /* Garder l'existant */
    }

    /* Cas 4: Undefined vs Defined */
    if (existing->strength == SYM_UNDEFINED && new_sym->strength != SYM_UNDEFINED) {
        return true;   /* Le defini gagne */
    }
    if (existing->strength != SYM_UNDEFINED && new_sym->strength == SYM_UNDEFINED) {
        return false;  /* Garder le defini */
    }

    /* Cas 5: COMMON vs STRONG */
    if (existing->strength == SYM_COMMON && new_sym->strength == SYM_STRONG) {
        return true;
    }
    if (existing->strength == SYM_STRONG && new_sym->strength == SYM_COMMON) {
        return false;
    }

    /* Cas 6: COMMON vs COMMON - le plus grand gagne */
    if (existing->strength == SYM_COMMON && new_sym->strength == SYM_COMMON) {
        return new_sym->size > existing->size;
    }

    return false;  /* Par defaut, garder l'existant */
}

/**
 * Charge un fichier objet ELF
 */
int load_object_file(LinkerContext *ctx, const char *filename) {
    if (ctx->object_count >= MAX_OBJECTS) {
        fprintf(stderr, "Too many object files\n");
        return -1;
    }

    ObjectFile *obj = &ctx->objects[ctx->object_count];
    strncpy(obj->filename, filename, sizeof(obj->filename) - 1);

    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror(filename);
        return -1;
    }

    struct stat st;
    fstat(fd, &st);
    obj->size = st.st_size;

    obj->data = mmap(NULL, obj->size, PROT_READ, MAP_PRIVATE, fd, 0);
    close(fd);

    if (obj->data == MAP_FAILED) {
        perror("mmap");
        return -1;
    }

    /* Verifie le magic ELF */
    obj->ehdr = (Elf64_Ehdr *)obj->data;
    if (memcmp(obj->ehdr->e_ident, ELFMAG, SELFMAG) != 0) {
        fprintf(stderr, "%s: not an ELF file\n", filename);
        return -1;
    }

    obj->is_needed = true;  /* Les .o directs sont toujours inclus */
    ctx->object_count++;

    return 0;
}

/**
 * Charge une archive (.a)
 * Format AR: signature puis headers avec membres
 */
int load_archive(LinkerContext *ctx, const char *filename) {
    if (ctx->archive_count >= 32) {
        fprintf(stderr, "Too many archives\n");
        return -1;
    }

    ArchiveFile *ar = &ctx->archives[ctx->archive_count];
    strncpy(ar->filename, filename, sizeof(ar->filename) - 1);

    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror(filename);
        return -1;
    }

    struct stat st;
    fstat(fd, &st);
    ar->size = st.st_size;

    ar->data = mmap(NULL, ar->size, PROT_READ, MAP_PRIVATE, fd, 0);
    close(fd);

    /* Verifie la signature AR */
    if (memcmp(ar->data, ARMAG, SARMAG) != 0) {
        fprintf(stderr, "%s: not an archive\n", filename);
        return -1;
    }

    /* Parser les membres de l'archive */
    char *ptr = (char *)ar->data + SARMAG;
    char *end = (char *)ar->data + ar->size;

    while (ptr < end) {
        struct ar_hdr *hdr = (struct ar_hdr *)ptr;

        /* Taille du membre */
        char size_str[11] = {0};
        strncpy(size_str, hdr->ar_size, 10);
        size_t member_size = strtoul(size_str, NULL, 10);

        /* Nom du membre */
        char name[17] = {0};
        strncpy(name, hdr->ar_name, 16);
        char *slash = strchr(name, '/');
        if (slash) *slash = '\0';

        /* Skip symbol table (/) and string table (//) */
        if (name[0] != '/' && name[0] != ' ') {
            ObjectFile *member = &ar->members[ar->member_count];
            strncpy(member->filename, name, sizeof(member->filename) - 1);
            member->data = ptr + sizeof(struct ar_hdr);
            member->size = member_size;
            member->ehdr = (Elf64_Ehdr *)member->data;
            member->is_needed = false;
            ar->member_count++;
        }

        /* Avancer au prochain membre (aligne sur 2 octets) */
        ptr += sizeof(struct ar_hdr) + member_size;
        if ((uintptr_t)ptr & 1) ptr++;
    }

    ctx->archive_count++;
    return 0;
}

/**
 * Extrait uniquement les objets necessaires d'une archive
 *
 * Algorithme:
 * 1. Pour chaque symbole non resolu dans la table globale
 * 2. Chercher un membre de l'archive qui le definit
 * 3. Si trouve, marquer ce membre comme "needed"
 * 4. Repeter jusqu'a ce qu'il n'y ait plus de changement
 */
void extract_needed_from_archives(LinkerContext *ctx) {
    bool changed;

    do {
        changed = false;

        for (int i = 0; i < ctx->archive_count; i++) {
            ArchiveFile *ar = &ctx->archives[i];

            for (int j = 0; j < ar->member_count; j++) {
                ObjectFile *member = &ar->members[j];

                if (member->is_needed) continue;  /* Deja inclus */

                /* Verifier si ce membre resout un symbole undefined */
                Elf64_Shdr *shdr = (Elf64_Shdr *)((char *)member->data + member->ehdr->e_shoff);
                for (int s = 0; s < member->ehdr->e_shnum; s++) {
                    if (shdr[s].sh_type != SHT_SYMTAB) continue;

                    Elf64_Sym *syms = (Elf64_Sym *)((char *)member->data + shdr[s].sh_offset);
                    char *strtab = (char *)member->data + shdr[shdr[s].sh_link].sh_offset;
                    int nsyms = shdr[s].sh_size / sizeof(Elf64_Sym);

                    for (int k = 0; k < nsyms; k++) {
                        if (syms[k].st_shndx == SHN_UNDEF) continue;
                        if (ELF64_ST_BIND(syms[k].st_info) != STB_GLOBAL) continue;

                        const char *sym_name = strtab + syms[k].st_name;
                        /* Chercher si ce symbole est undefined dans ctx */
                        for (int g = 0; g < ctx->symbol_count; g++) {
                            if (ctx->symbols[g].strength == SYM_UNDEFINED &&
                                strcmp(ctx->symbols[g].name, sym_name) == 0) {
                                member->is_needed = true;
                                changed = true;
                                break;
                            }
                        }
                        if (member->is_needed) break;
                    }
                    if (member->is_needed) break;
                }
            }
        }
    } while (changed);

    /* Afficher les membres extraits */
    printf("Archive extraction summary:\n");
    for (int i = 0; i < ctx->archive_count; i++) {
        ArchiveFile *ar = &ctx->archives[i];
        int extracted = 0;

        for (int j = 0; j < ar->member_count; j++) {
            if (ar->members[j].is_needed) {
                extracted++;
                printf("  %s(%s)\n", ar->filename, ar->members[j].filename);
            }
        }
        printf("  Total from %s: %d/%d members\n",
               ar->filename, extracted, ar->member_count);
    }
}

/**
 * Phase 1: Collecte de tous les symboles
 */
int collect_symbols(LinkerContext *ctx) {
    char error_msg[512];

    for (int i = 0; i < ctx->object_count; i++) {
        ObjectFile *obj = &ctx->objects[i];
        if (!obj->is_needed) continue;

        /* Trouve les sections .symtab et .strtab */
        Elf64_Shdr *symtab = NULL;
        char *strtab = NULL;

        Elf64_Shdr *shdrs = (Elf64_Shdr *)((char *)obj->data + obj->ehdr->e_shoff);
        char *shstrtab = (char *)obj->data +
                         shdrs[obj->ehdr->e_shstrndx].sh_offset;

        for (int s = 0; s < obj->ehdr->e_shnum; s++) {
            const char *name = shstrtab + shdrs[s].sh_name;
            if (strcmp(name, ".symtab") == 0) {
                symtab = &shdrs[s];
            } else if (strcmp(name, ".strtab") == 0) {
                strtab = (char *)obj->data + shdrs[s].sh_offset;
            }
        }

        if (!symtab || !strtab) continue;

        /* Parcours des symboles */
        Elf64_Sym *syms = (Elf64_Sym *)((char *)obj->data + symtab->sh_offset);
        int sym_count = symtab->sh_size / sizeof(Elf64_Sym);

        for (int s = 0; s < sym_count; s++) {
            Elf64_Sym *sym = &syms[s];

            /* Ignore les symboles locaux pour le linkage */
            if (ELF64_ST_BIND(sym->st_info) == STB_LOCAL) continue;

            const char *name = strtab + sym->st_name;
            if (name[0] == '\0') continue;

            GlobalSymbol new_sym = {
                .strength = get_symbol_strength(sym),
                .value = sym->st_value,
                .size = sym->st_size,
                .source_object = i,
                .section_index = sym->st_shndx,
                .is_resolved = (sym->st_shndx != SHN_UNDEF)
            };
            strncpy(new_sym.name, name, sizeof(new_sym.name) - 1);

            /* Cherche si le symbole existe deja */
            bool found = false;
            for (int g = 0; g < ctx->symbol_count; g++) {
                if (strcmp(ctx->symbols[g].name, name) == 0) {
                    found = true;

                    if (!resolve_symbol_conflict(&ctx->symbols[g], &new_sym,
                                                 error_msg, sizeof(error_msg))) {
                        if (ctx->symbols[g].strength == SYM_STRONG &&
                            new_sym.strength == SYM_STRONG) {
                            fprintf(stderr, "Error: %s\n", error_msg);
                            return -1;
                        }
                    } else {
                        /* Remplacer */
                        ctx->symbols[g] = new_sym;
                    }
                    break;
                }
            }

            if (!found) {
                ctx->symbols[ctx->symbol_count++] = new_sym;
            }
        }
    }

    return 0;
}

/**
 * Demontre l'importance de l'ordre de linkage
 */
void demonstrate_link_order(void) {
    printf("\n=== Link Order Demonstration ===\n");
    printf("Correct:   gcc main.o -lfoo -lbar\n");
    printf("Wrong:     gcc -lfoo main.o -lbar\n");
    printf("\n");
    printf("Rule: Libraries should come AFTER the objects that reference them.\n");
    printf("Archives are searched LEFT to RIGHT, and only needed objects are extracted.\n");
}

/**
 * Point d'entree principal
 */
int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s -o output file1.o file2.o [libfoo.a ...]\n", argv[0]);
        return 1;
    }

    LinkerContext ctx = {0};
    ctx.location_counter = 0x400000;  /* Adresse de base typique */

    /* Parse les arguments */
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-o") == 0 && i + 1 < argc) {
            ctx.output_filename = argv[++i];
        } else if (strstr(argv[i], ".a") != NULL) {
            /* Archive */
            if (load_archive(&ctx, argv[i]) < 0) return 1;
        } else if (strstr(argv[i], ".o") != NULL) {
            /* Fichier objet */
            if (load_object_file(&ctx, argv[i]) < 0) return 1;
        }
    }

    printf("Loaded %d object files, %d archives\n",
           ctx.object_count, ctx.archive_count);

    /* Phase 1: Extraction des archives */
    extract_needed_from_archives(&ctx);

    /* Phase 2: Collection des symboles */
    if (collect_symbols(&ctx) < 0) {
        return 1;
    }

    /* Affiche la table de symboles */
    printf("\nGlobal Symbol Table:\n");
    printf("%-30s %-10s %-16s %s\n", "Name", "Strength", "Value", "Source");
    for (int i = 0; i < ctx.symbol_count; i++) {
        GlobalSymbol *sym = &ctx.symbols[i];
        const char *strength_str[] = {"UNDEF", "STRONG", "WEAK", "COMMON"};
        printf("%-30s %-10s 0x%016lx obj[%d]\n",
               sym->name, strength_str[sym->strength],
               sym->value, sym->source_object);
    }

    demonstrate_link_order();

    /* TODO: Phases suivantes:
     * 3. Fusion des sections
     * 4. Application des relocations
     * 5. Ecriture de l'executable
     */

    return 0;
}
```

## Criteres de validation
1. Resolution correcte des conflits STRONG/WEAK
2. Detection d'erreur sur symboles STRONG dupliques
3. Extraction selective depuis les archives
4. Respect de l'ordre de linkage
5. Utilisation du location counter

## Note qualite: 97/100
