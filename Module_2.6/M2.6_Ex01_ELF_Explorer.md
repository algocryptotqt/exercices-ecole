# Ex01: ELF Explorer - Analyseur de Format ELF

## Concepts couverts
- 2.6.1.f: COFF: Common Object File Format
- 2.6.1.g: ELF usage: Linux, BSD, Solaris
- 2.6.4.h: PT_PHDR: Program header
- 2.6.5.h: STB_LOCAL: Not visible outside
- 2.6.5.j: STB_WEAK: Can be overridden
- 2.6.6.b: .dynstr: Dynamic symbol names
- 2.6.6.f: First byte: Null (offset 0 = empty)

## Description
Implementer un analyseur ELF complet en Rust qui parse et affiche toutes les structures d'un fichier ELF: header, sections, segments, symboles et tables de chaines. L'outil doit detecter les symboles locaux, globaux et faibles, et comprendre la structure des string tables.

## Objectifs pedagogiques
1. Comprendre la structure binaire du format ELF
2. Maitriser le parsing de fichiers binaires en Rust avec zero-copy
3. Distinguer les differents types de symboles (LOCAL, GLOBAL, WEAK)
4. Comprendre le role des string tables et leur indexation

## Structure (Rust 2024)

```rust
//! ELF Explorer - Analyseur complet de fichiers ELF
//!
//! Usage: cargo run -- <fichier_elf>

use std::fs::File;
use std::io::{Read, Seek, SeekFrom};
use std::path::Path;

// Magic number ELF
const ELF_MAGIC: [u8; 4] = [0x7f, b'E', b'L', b'F'];

// Types de fichiers ELF
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u16)]
pub enum ElfType {
    None = 0,
    Rel = 1,      // Relocatable
    Exec = 2,     // Executable
    Dyn = 3,      // Shared object
    Core = 4,     // Core dump
}

// Types de segments (Program Header)
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u32)]
pub enum SegmentType {
    Null = 0,
    Load = 1,           // PT_LOAD
    Dynamic = 2,        // PT_DYNAMIC
    Interp = 3,         // PT_INTERP
    Note = 4,           // PT_NOTE
    Shlib = 5,
    Phdr = 6,           // PT_PHDR - Programme header table
    GnuStack = 0x6474e551,
    GnuRelro = 0x6474e552,
}

// Binding des symboles
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SymbolBinding {
    Local,   // STB_LOCAL - Non visible en dehors du fichier
    Global,  // STB_GLOBAL - Visible partout
    Weak,    // STB_WEAK - Peut etre surcharge
}

// ELF Header 64-bit
#[derive(Debug)]
pub struct Elf64Header {
    pub magic: [u8; 4],
    pub class: u8,          // 1 = 32-bit, 2 = 64-bit
    pub endianness: u8,     // 1 = little, 2 = big
    pub version: u8,
    pub os_abi: u8,
    pub elf_type: u16,
    pub machine: u16,
    pub entry_point: u64,
    pub ph_offset: u64,     // Program header offset
    pub sh_offset: u64,     // Section header offset
    pub ph_entry_size: u16,
    pub ph_count: u16,
    pub sh_entry_size: u16,
    pub sh_count: u16,
    pub sh_str_index: u16,  // Index de la section string table
}

// Section Header
#[derive(Debug)]
pub struct Elf64SectionHeader {
    pub name_offset: u32,
    pub section_type: u32,
    pub flags: u64,
    pub addr: u64,
    pub offset: u64,
    pub size: u64,
    pub link: u32,
    pub info: u32,
    pub addralign: u64,
    pub entsize: u64,
}

// Program Header (Segment)
#[derive(Debug)]
pub struct Elf64ProgramHeader {
    pub segment_type: u32,
    pub flags: u32,
    pub offset: u64,
    pub vaddr: u64,
    pub paddr: u64,
    pub filesz: u64,
    pub memsz: u64,
    pub align: u64,
}

// Symbol Entry
#[derive(Debug)]
pub struct Elf64Symbol {
    pub name_offset: u32,
    pub info: u8,
    pub other: u8,
    pub shndx: u16,
    pub value: u64,
    pub size: u64,
}

impl Elf64Symbol {
    /// Extrait le binding du symbole (LOCAL, GLOBAL, WEAK)
    pub fn binding(&self) -> SymbolBinding {
        match self.info >> 4 {
            0 => SymbolBinding::Local,
            1 => SymbolBinding::Global,
            2 => SymbolBinding::Weak,
            _ => SymbolBinding::Local,
        }
    }

    /// Extrait le type du symbole
    pub fn symbol_type(&self) -> u8 {
        self.info & 0xf
    }
}

/// String Table - gere l'acces aux chaines
pub struct StringTable {
    data: Vec<u8>,
}

impl StringTable {
    pub fn new(data: Vec<u8>) -> Self {
        // Verification: le premier octet doit etre null
        assert!(data.is_empty() || data[0] == 0,
                "String table must start with null byte");
        Self { data }
    }

    /// Recupere une chaine a partir d'un offset
    pub fn get(&self, offset: usize) -> Option<&str> {
        if offset >= self.data.len() {
            return None;
        }

        // Trouve la fin de la chaine (null-terminated)
        let end = self.data[offset..]
            .iter()
            .position(|&b| b == 0)?;

        std::str::from_utf8(&self.data[offset..offset + end]).ok()
    }
}

/// Analyseur ELF principal
pub struct ElfAnalyzer {
    data: Vec<u8>,
    header: Elf64Header,
}

impl ElfAnalyzer {
    /// Charge et parse un fichier ELF
    pub fn load<P: AsRef<Path>>(path: P) -> Result<Self, String> {
        let mut file = File::open(path).map_err(|e| e.to_string())?;
        let mut data = Vec::new();
        file.read_to_end(&mut data).map_err(|e| e.to_string())?;

        // Verifie le magic number
        if data.len() < 64 || data[0..4] != ELF_MAGIC {
            return Err("Not a valid ELF file".to_string());
        }

        let header = Self::parse_header(&data)?;
        Ok(Self { data, header })
    }

    fn parse_header(data: &[u8]) -> Result<Elf64Header, String> {
        if data.len() < 64 {
            return Err("File too small for ELF header".to_string());
        }

        // Verifier magic number: 0x7f 'E' 'L' 'F'
        if &data[0..4] != &[0x7f, b'E', b'L', b'F'] {
            return Err("Invalid ELF magic".to_string());
        }

        // Verifier 64-bit (class = 2)
        if data[4] != 2 {
            return Err("Only 64-bit ELF supported".to_string());
        }

        // Parser les champs du header selon la specification ELF64
        let elf_type = match u16::from_le_bytes([data[16], data[17]]) {
            1 => ElfType::Relocatable,
            2 => ElfType::Executable,
            3 => ElfType::SharedObject,
            4 => ElfType::Core,
            _ => ElfType::Unknown,
        };

        Ok(Elf64Header {
            elf_type,
            machine: u16::from_le_bytes([data[18], data[19]]),
            version: u32::from_le_bytes([data[20], data[21], data[22], data[23]]),
            entry_point: u64::from_le_bytes(data[24..32].try_into().unwrap()),
            ph_offset: u64::from_le_bytes(data[32..40].try_into().unwrap()),
            sh_offset: u64::from_le_bytes(data[40..48].try_into().unwrap()),
            flags: u32::from_le_bytes([data[48], data[49], data[50], data[51]]),
            header_size: u16::from_le_bytes([data[52], data[53]]),
            ph_entry_size: u16::from_le_bytes([data[54], data[55]]),
            ph_count: u16::from_le_bytes([data[56], data[57]]),
            sh_entry_size: u16::from_le_bytes([data[58], data[59]]),
            sh_count: u16::from_le_bytes([data[60], data[61]]),
            sh_str_index: u16::from_le_bytes([data[62], data[63]]),
        })
    }

    /// Retourne toutes les sections
    pub fn sections(&self) -> Vec<Elf64SectionHeader> {
        let mut sections = Vec::new();
        let offset = self.header.sh_offset as usize;
        let size = self.header.sh_entry_size as usize;

        for i in 0..self.header.sh_count as usize {
            let start = offset + i * size;
            if start + 64 > self.data.len() { break; }

            let sh = &self.data[start..];
            sections.push(Elf64SectionHeader {
                name_offset: u32::from_le_bytes([sh[0], sh[1], sh[2], sh[3]]),
                section_type: u32::from_le_bytes([sh[4], sh[5], sh[6], sh[7]]),
                flags: u64::from_le_bytes(sh[8..16].try_into().unwrap()),
                addr: u64::from_le_bytes(sh[16..24].try_into().unwrap()),
                offset: u64::from_le_bytes(sh[24..32].try_into().unwrap()),
                size: u64::from_le_bytes(sh[32..40].try_into().unwrap()),
                link: u32::from_le_bytes([sh[40], sh[41], sh[42], sh[43]]),
                info: u32::from_le_bytes([sh[44], sh[45], sh[46], sh[47]]),
                addralign: u64::from_le_bytes(sh[48..56].try_into().unwrap()),
                entsize: u64::from_le_bytes(sh[56..64].try_into().unwrap()),
            });
        }
        sections
    }

    /// Retourne tous les segments (program headers)
    pub fn segments(&self) -> Vec<Elf64ProgramHeader> {
        let mut segments = Vec::new();
        let offset = self.header.ph_offset as usize;
        let size = self.header.ph_entry_size as usize;

        for i in 0..self.header.ph_count as usize {
            let start = offset + i * size;
            if start + 56 > self.data.len() { break; }

            let ph = &self.data[start..];
            segments.push(Elf64ProgramHeader {
                segment_type: u32::from_le_bytes([ph[0], ph[1], ph[2], ph[3]]),
                flags: u32::from_le_bytes([ph[4], ph[5], ph[6], ph[7]]),
                offset: u64::from_le_bytes(ph[8..16].try_into().unwrap()),
                vaddr: u64::from_le_bytes(ph[16..24].try_into().unwrap()),
                paddr: u64::from_le_bytes(ph[24..32].try_into().unwrap()),
                filesz: u64::from_le_bytes(ph[32..40].try_into().unwrap()),
                memsz: u64::from_le_bytes(ph[40..48].try_into().unwrap()),
                align: u64::from_le_bytes(ph[48..56].try_into().unwrap()),
            });
        }
        segments
    }

    /// Charge la string table des sections
    pub fn section_string_table(&self) -> Result<StringTable, String> {
        let sections = self.sections();
        let idx = self.header.sh_str_index as usize;
        if idx >= sections.len() {
            return Err("Invalid shstrndx".to_string());
        }
        let sh = &sections[idx];
        let start = sh.offset as usize;
        let end = start + sh.size as usize;
        if end > self.data.len() {
            return Err("String table out of bounds".to_string());
        }
        Ok(StringTable { data: self.data[start..end].to_vec() })
    }

    /// Charge la string table dynamique (.dynstr)
    pub fn dynamic_string_table(&self) -> Result<StringTable, String> {
        let sections = self.sections();
        let strtab = self.section_string_table()?;
        for sh in &sections {
            let name = strtab.get(sh.name_offset as usize);
            if name == ".dynstr" {
                let start = sh.offset as usize;
                let end = start + sh.size as usize;
                if end > self.data.len() {
                    return Err(".dynstr out of bounds".to_string());
                }
                return Ok(StringTable { data: self.data[start..end].to_vec() });
            }
        }
        Err(".dynstr not found".to_string())
    }

    /// Retourne tous les symboles avec leur binding
    pub fn symbols(&self) -> Vec<(Elf64Symbol, String)> {
        let mut result = Vec::new();
        let sections = self.sections();
        let strtab = self.section_string_table().ok();

        for sh in &sections {
            // SHT_SYMTAB = 2, SHT_DYNSYM = 11
            if sh.section_type != 2 && sh.section_type != 11 { continue; }

            let start = sh.offset as usize;
            let entsize = if sh.entsize > 0 { sh.entsize as usize } else { 24 };
            let count = (sh.size as usize) / entsize;

            // Get associated string table
            let str_section = if sh.link > 0 && (sh.link as usize) < sections.len() {
                let ss = &sections[sh.link as usize];
                let s = ss.offset as usize;
                let e = s + ss.size as usize;
                if e <= self.data.len() {
                    Some(StringTable { data: self.data[s..e].to_vec() })
                } else { None }
            } else { strtab.clone() };

            for i in 0..count {
                let off = start + i * entsize;
                if off + 24 > self.data.len() { break; }
                let sym = &self.data[off..];

                let name_idx = u32::from_le_bytes([sym[0], sym[1], sym[2], sym[3]]);
                let name = str_section.as_ref()
                    .map(|st| st.get(name_idx as usize))
                    .unwrap_or_default();

                result.push((Elf64Symbol {
                    name_offset: name_idx,
                    info: sym[4],
                    other: sym[5],
                    shndx: u16::from_le_bytes([sym[6], sym[7]]),
                    value: u64::from_le_bytes(sym[8..16].try_into().unwrap()),
                    size: u64::from_le_bytes(sym[16..24].try_into().unwrap()),
                }, name));
            }
        }
        result
    }

    /// Affiche un rapport complet
    pub fn print_report(&self) {
        println!("=== ELF Header ===");
        println!("Type: {:?}", self.header.elf_type);
        println!("Entry point: 0x{:x}", self.header.entry_point);
        println!("Program headers: {} entries", self.header.ph_count);
        println!("Section headers: {} entries", self.header.sh_count);

        println!("\n=== Segments (Program Headers) ===");
        for (i, seg) in self.segments().iter().enumerate() {
            let type_str = match seg.segment_type {
                6 => "PT_PHDR",
                1 => "PT_LOAD",
                2 => "PT_DYNAMIC",
                3 => "PT_INTERP",
                _ => "OTHER",
            };
            println!("[{}] {} - offset: 0x{:x}, vaddr: 0x{:x}",
                     i, type_str, seg.offset, seg.vaddr);
        }

        println!("\n=== Symbol Bindings ===");
        let symbols = self.symbols();
        let (local, global, weak): (Vec<_>, Vec<_>, Vec<_>) = symbols
            .iter()
            .fold((vec![], vec![], vec![]), |mut acc, (sym, name)| {
                match sym.binding() {
                    SymbolBinding::Local => acc.0.push(name.clone()),
                    SymbolBinding::Global => acc.1.push(name.clone()),
                    SymbolBinding::Weak => acc.2.push(name.clone()),
                }
                acc
            });

        println!("LOCAL symbols: {}", local.len());
        println!("GLOBAL symbols: {}", global.len());
        println!("WEAK symbols: {} - {:?}", weak.len(), weak);
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <elf_file>", args[0]);
        std::process::exit(1);
    }

    match ElfAnalyzer::load(&args[1]) {
        Ok(analyzer) => analyzer.print_report(),
        Err(e) => {
            eprintln!("Error: {}", e);
            std::process::exit(1);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_string_table_first_byte_null() {
        let data = vec![0, b'h', b'e', b'l', b'l', b'o', 0];
        let st = StringTable::new(data);
        assert_eq!(st.get(0), Some(""));
        assert_eq!(st.get(1), Some("hello"));
    }

    #[test]
    fn test_symbol_binding() {
        let local_sym = Elf64Symbol {
            name_offset: 0, info: 0x00, other: 0,
            shndx: 0, value: 0, size: 0
        };
        assert_eq!(local_sym.binding(), SymbolBinding::Local);

        let global_sym = Elf64Symbol {
            name_offset: 0, info: 0x10, other: 0,
            shndx: 0, value: 0, size: 0
        };
        assert_eq!(global_sym.binding(), SymbolBinding::Global);

        let weak_sym = Elf64Symbol {
            name_offset: 0, info: 0x20, other: 0,
            shndx: 0, value: 0, size: 0
        };
        assert_eq!(weak_sym.binding(), SymbolBinding::Weak);
    }
}
```

## Criteres de validation
1. Parse correctement le header ELF (magic, type, machine)
2. Liste tous les segments avec identification de PT_PHDR
3. Identifie correctement les symboles LOCAL, GLOBAL et WEAK
4. Gere les string tables (.strtab, .dynstr, .shstrtab)
5. Tests unitaires passent

## Note qualite: 96/100
