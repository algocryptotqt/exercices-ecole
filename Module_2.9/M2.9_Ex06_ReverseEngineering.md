# Ex06: ReverseEngineering - Analyse Binaire et Debugging Avance

## Concepts couverts
- 2.9.28.a: GDB - GNU Debugger
- 2.9.28.c: GDB examine - x/10x $rsp
- 2.9.28.d: pwndbg - GDB enhancement
- 2.9.28.e: GEF - GDB enhancement
- 2.9.28.f: peda - GDB enhancement
- 2.9.28.j: radare2 - Reverse engineering
- 2.9.29.a: Conditional breakpoints - break if condition
- 2.9.29.d: GDB scripting - Python API
- 2.9.29.h: Core dump analysis - gdb program core
- 2.9.30.c: Disassembly - Code to assembly
- 2.9.30.e: Control flow graph - Visual representation
- 2.9.30.h: Imports/exports - External dependencies
- 2.9.31.e: Function identification - Recognize patterns
- 2.9.31.f: Data structure recovery - Structs from usage
- 2.9.31.g: Algorithm analysis - Understand logic
- 2.9.31.h: Anti-reversing - Obfuscation

## Description
Construire un framework de reverse engineering et d'analyse binaire en Rust 2024, incluant un desassembleur simplifie, un analyseur de structures, et un moteur de scripts pour l'automatisation du debugging. L'exercice simule les fonctionnalites de GDB, radare2 et Ghidra.

## Objectifs pedagogiques
1. Comprendre le desassemblage x86-64
2. Maitriser l'analyse de flux de controle
3. Identifier les patterns de fonctions et structures
4. Automatiser l'analyse avec des scripts
5. Detecter les techniques d'anti-reversing

## Structure (Rust 2024)

```rust
// src/lib.rs

pub mod disasm;
pub mod analysis;
pub mod debugger;
pub mod patterns;
pub mod antireverse;

use std::collections::{HashMap, HashSet, BTreeMap};

// ============================================
// PARTIE 1: Desassembleur x86-64 Simplifie
// ============================================

pub mod disasm {
    use super::*;

    #[derive(Clone, Debug)]
    pub enum Operand {
        Register(Register),
        Immediate(i64),
        Memory { base: Option<Register>, index: Option<Register>, scale: u8, disp: i64 },
        RipRelative(i64),
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    pub enum Register {
        RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP,
        R8, R9, R10, R11, R12, R13, R14, R15,
        RIP,
        // 32-bit
        EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP,
        // 8-bit
        AL, BL, CL, DL,
    }

    impl Register {
        pub fn size(&self) -> u8 {
            match self {
                Self::RAX | Self::RBX | Self::RCX | Self::RDX |
                Self::RSI | Self::RDI | Self::RSP | Self::RBP |
                Self::R8 | Self::R9 | Self::R10 | Self::R11 |
                Self::R12 | Self::R13 | Self::R14 | Self::R15 |
                Self::RIP => 8,
                Self::EAX | Self::EBX | Self::ECX | Self::EDX |
                Self::ESI | Self::EDI | Self::ESP | Self::EBP => 4,
                Self::AL | Self::BL | Self::CL | Self::DL => 1,
            }
        }
    }

    #[derive(Clone, Debug)]
    pub enum Instruction {
        // Data movement
        Mov { dest: Operand, src: Operand },
        Push { src: Operand },
        Pop { dest: Operand },
        Lea { dest: Operand, src: Operand },
        Xchg { op1: Operand, op2: Operand },

        // Arithmetic
        Add { dest: Operand, src: Operand },
        Sub { dest: Operand, src: Operand },
        Imul { dest: Operand, src: Operand },
        Xor { dest: Operand, src: Operand },
        And { dest: Operand, src: Operand },
        Or { dest: Operand, src: Operand },
        Shl { dest: Operand, count: Operand },
        Shr { dest: Operand, count: Operand },

        // Compare/Test
        Cmp { op1: Operand, op2: Operand },
        Test { op1: Operand, op2: Operand },

        // Control flow
        Jmp { target: Operand },
        Je { target: i64 },
        Jne { target: i64 },
        Jl { target: i64 },
        Jle { target: i64 },
        Jg { target: i64 },
        Jge { target: i64 },
        Call { target: Operand },
        Ret,
        Leave,

        // System
        Syscall,
        Int { vector: u8 },
        Nop,

        // Unknown/Invalid
        Unknown { bytes: Vec<u8> },
    }

    #[derive(Clone, Debug)]
    pub struct DisassembledInstruction {
        pub address: u64,
        pub bytes: Vec<u8>,
        pub instruction: Instruction,
        pub mnemonic: String,
        pub operands_str: String,
    }

    impl DisassembledInstruction {
        pub fn is_call(&self) -> bool {
            matches!(self.instruction, Instruction::Call { .. })
        }

        pub fn is_jump(&self) -> bool {
            matches!(self.instruction,
                Instruction::Jmp { .. } |
                Instruction::Je { .. } |
                Instruction::Jne { .. } |
                Instruction::Jl { .. } |
                Instruction::Jle { .. } |
                Instruction::Jg { .. } |
                Instruction::Jge { .. }
            )
        }

        pub fn is_ret(&self) -> bool {
            matches!(self.instruction, Instruction::Ret)
        }

        pub fn get_branch_target(&self) -> Option<u64> {
            match &self.instruction {
                Instruction::Jmp { target } => {
                    if let Operand::Immediate(imm) = target {
                        Some(*imm as u64)
                    } else {
                        None
                    }
                }
                Instruction::Je { target } |
                Instruction::Jne { target } |
                Instruction::Jl { target } |
                Instruction::Jle { target } |
                Instruction::Jg { target } |
                Instruction::Jge { target } => {
                    Some((self.address as i64 + self.bytes.len() as i64 + target) as u64)
                }
                Instruction::Call { target } => {
                    if let Operand::RipRelative(offset) = target {
                        Some((self.address as i64 + self.bytes.len() as i64 + offset) as u64)
                    } else {
                        None
                    }
                }
                _ => None,
            }
        }
    }

    pub struct Disassembler {
        code: Vec<u8>,
        base_address: u64,
    }

    impl Disassembler {
        pub fn new(code: Vec<u8>, base_address: u64) -> Self {
            Disassembler { code, base_address }
        }

        /// Desassembler a partir d'une adresse
        pub fn disassemble_at(&self, addr: u64, max_instructions: usize) -> Vec<DisassembledInstruction> {
            let mut result = Vec::new();
            let offset = (addr - self.base_address) as usize;

            let mut pos = offset;
            while pos < self.code.len() && result.len() < max_instructions {
                if let Some(instr) = self.decode_instruction(pos) {
                    pos += instr.bytes.len();
                    result.push(instr);
                } else {
                    break;
                }
            }

            result
        }

        /// Decoder une instruction (simplifie)
        fn decode_instruction(&self, offset: usize) -> Option<DisassembledInstruction> {
            if offset >= self.code.len() {
                return None;
            }

            let addr = self.base_address + offset as u64;
            let code = &self.code[offset..];

            // Decoder simplifie (patterns communs)
            let (instr, bytes, mnemonic, operands_str) = match code.get(0)? {
                // push rbp
                0x55 => (
                    Instruction::Push { src: Operand::Register(Register::RBP) },
                    vec![0x55],
                    "push".to_string(),
                    "rbp".to_string(),
                ),

                // pop rbp
                0x5d => (
                    Instruction::Pop { dest: Operand::Register(Register::RBP) },
                    vec![0x5d],
                    "pop".to_string(),
                    "rbp".to_string(),
                ),

                // ret
                0xc3 => (
                    Instruction::Ret,
                    vec![0xc3],
                    "ret".to_string(),
                    String::new(),
                ),

                // leave
                0xc9 => (
                    Instruction::Leave,
                    vec![0xc9],
                    "leave".to_string(),
                    String::new(),
                ),

                // nop
                0x90 => (
                    Instruction::Nop,
                    vec![0x90],
                    "nop".to_string(),
                    String::new(),
                ),

                // syscall (0x0f 0x05)
                0x0f if code.get(1) == Some(&0x05) => (
                    Instruction::Syscall,
                    vec![0x0f, 0x05],
                    "syscall".to_string(),
                    String::new(),
                ),

                // REX.W prefix
                0x48 => self.decode_rex_w(code, addr)?,

                // call rel32
                0xe8 if code.len() >= 5 => {
                    let rel = i32::from_le_bytes([code[1], code[2], code[3], code[4]]) as i64;
                    (
                        Instruction::Call { target: Operand::RipRelative(rel) },
                        code[..5].to_vec(),
                        "call".to_string(),
                        format!("0x{:x}", addr as i64 + 5 + rel),
                    )
                }

                // jmp rel32
                0xe9 if code.len() >= 5 => {
                    let rel = i32::from_le_bytes([code[1], code[2], code[3], code[4]]) as i64;
                    (
                        Instruction::Jmp { target: Operand::Immediate(addr as i64 + 5 + rel) },
                        code[..5].to_vec(),
                        "jmp".to_string(),
                        format!("0x{:x}", addr as i64 + 5 + rel),
                    )
                }

                // jmp rel8
                0xeb if code.len() >= 2 => {
                    let rel = code[1] as i8 as i64;
                    (
                        Instruction::Jmp { target: Operand::Immediate(addr as i64 + 2 + rel) },
                        code[..2].to_vec(),
                        "jmp".to_string(),
                        format!("0x{:x}", addr as i64 + 2 + rel),
                    )
                }

                // Conditional jumps (0x74 = je, 0x75 = jne, etc.)
                0x74 if code.len() >= 2 => {
                    let rel = code[1] as i8 as i64;
                    (
                        Instruction::Je { target: rel },
                        code[..2].to_vec(),
                        "je".to_string(),
                        format!("0x{:x}", addr as i64 + 2 + rel),
                    )
                }
                0x75 if code.len() >= 2 => {
                    let rel = code[1] as i8 as i64;
                    (
                        Instruction::Jne { target: rel },
                        code[..2].to_vec(),
                        "jne".to_string(),
                        format!("0x{:x}", addr as i64 + 2 + rel),
                    )
                }

                _ => {
                    // Unknown instruction
                    (
                        Instruction::Unknown { bytes: vec![code[0]] },
                        vec![code[0]],
                        ".byte".to_string(),
                        format!("0x{:02x}", code[0]),
                    )
                }
            };

            Some(DisassembledInstruction {
                address: addr,
                bytes,
                instruction: instr,
                mnemonic,
                operands_str,
            })
        }

        fn decode_rex_w(&self, code: &[u8], addr: u64) -> Option<(Instruction, Vec<u8>, String, String)> {
            if code.len() < 2 {
                return None;
            }

            match code[1] {
                // mov rbp, rsp
                0x89 if code.len() >= 3 && code[2] == 0xe5 => Some((
                    Instruction::Mov {
                        dest: Operand::Register(Register::RBP),
                        src: Operand::Register(Register::RSP),
                    },
                    code[..3].to_vec(),
                    "mov".to_string(),
                    "rbp, rsp".to_string(),
                )),

                // sub rsp, imm8
                0x83 if code.len() >= 4 && code[2] == 0xec => Some((
                    Instruction::Sub {
                        dest: Operand::Register(Register::RSP),
                        src: Operand::Immediate(code[3] as i64),
                    },
                    code[..4].to_vec(),
                    "sub".to_string(),
                    format!("rsp, 0x{:x}", code[3]),
                )),

                // xor rdi, rdi
                0x31 if code.len() >= 3 && code[2] == 0xff => Some((
                    Instruction::Xor {
                        dest: Operand::Register(Register::RDI),
                        src: Operand::Register(Register::RDI),
                    },
                    code[..3].to_vec(),
                    "xor".to_string(),
                    "rdi, rdi".to_string(),
                )),

                _ => Some((
                    Instruction::Unknown { bytes: code[..2].to_vec() },
                    code[..2].to_vec(),
                    ".byte".to_string(),
                    format!("0x{:02x}, 0x{:02x}", code[0], code[1]),
                )),
            }
        }

        /// Afficher le desassemblage (style objdump)
        pub fn dump(&self, start: u64, count: usize) {
            let instructions = self.disassemble_at(start, count);

            for instr in instructions {
                let bytes_str: String = instr.bytes.iter()
                    .map(|b| format!("{:02x}", b))
                    .collect::<Vec<_>>()
                    .join(" ");

                println!("{:016x}: {:24} {} {}",
                    instr.address,
                    bytes_str,
                    instr.mnemonic,
                    instr.operands_str
                );
            }
        }
    }
}

// ============================================
// PARTIE 2: Control Flow Graph
// ============================================

pub mod analysis {
    use super::*;
    use super::disasm::*;

    #[derive(Clone, Debug)]
    pub struct BasicBlock {
        pub start_addr: u64,
        pub end_addr: u64,
        pub instructions: Vec<DisassembledInstruction>,
        pub successors: Vec<u64>,  // Adresses des blocs suivants
        pub predecessors: Vec<u64>,
    }

    pub struct ControlFlowGraph {
        pub blocks: BTreeMap<u64, BasicBlock>,
        pub entry_point: u64,
    }

    impl ControlFlowGraph {
        /// Construire le CFG a partir du code
        pub fn build(disasm: &Disassembler, entry: u64) -> Self {
            let mut cfg = ControlFlowGraph {
                blocks: BTreeMap::new(),
                entry_point: entry,
            };

            let mut work_list: Vec<u64> = vec![entry];
            let mut visited: HashSet<u64> = HashSet::new();

            while let Some(addr) = work_list.pop() {
                if visited.contains(&addr) {
                    continue;
                }
                visited.insert(addr);

                // Desassembler jusqu'a un terminateur de bloc
                let instructions = disasm.disassemble_at(addr, 100);
                if instructions.is_empty() {
                    continue;
                }

                let mut block = BasicBlock {
                    start_addr: addr,
                    end_addr: addr,
                    instructions: Vec::new(),
                    successors: Vec::new(),
                    predecessors: Vec::new(),
                };

                for instr in instructions {
                    block.end_addr = instr.address + instr.bytes.len() as u64;
                    block.instructions.push(instr.clone());

                    if instr.is_ret() {
                        // Fin de fonction
                        break;
                    } else if instr.is_jump() {
                        // Saut inconditionnel ou conditionnel
                        if let Some(target) = instr.get_branch_target() {
                            block.successors.push(target);
                            work_list.push(target);
                        }

                        // Pour les sauts conditionnels, le fall-through aussi
                        if !matches!(instr.instruction, Instruction::Jmp { .. }) {
                            let fall_through = instr.address + instr.bytes.len() as u64;
                            block.successors.push(fall_through);
                            work_list.push(fall_through);
                        }
                        break;
                    } else if instr.is_call() {
                        // Apres un call, continue normalement
                        // (sauf si noreturn)
                    }
                }

                cfg.blocks.insert(addr, block);
            }

            // Calculer les predecesseurs
            let block_addrs: Vec<u64> = cfg.blocks.keys().copied().collect();
            for addr in &block_addrs {
                let successors = cfg.blocks[addr].successors.clone();
                for succ in successors {
                    if let Some(succ_block) = cfg.blocks.get_mut(&succ) {
                        succ_block.predecessors.push(*addr);
                    }
                }
            }

            cfg
        }

        /// Afficher le CFG en ASCII
        pub fn dump(&self) {
            println!("=== Control Flow Graph ===");
            println!("Entry point: 0x{:x}", self.entry_point);
            println!();

            for (addr, block) in &self.blocks {
                println!("Block 0x{:x} - 0x{:x}:", addr, block.end_addr);
                println!("  Predecessors: {:?}", block.predecessors.iter()
                    .map(|a| format!("0x{:x}", a))
                    .collect::<Vec<_>>());

                for instr in &block.instructions {
                    println!("    0x{:x}: {} {}",
                        instr.address, instr.mnemonic, instr.operands_str);
                }

                println!("  Successors: {:?}", block.successors.iter()
                    .map(|a| format!("0x{:x}", a))
                    .collect::<Vec<_>>());
                println!();
            }
        }

        /// Exporter en format DOT (Graphviz)
        pub fn to_dot(&self) -> String {
            let mut dot = String::from("digraph CFG {\n");
            dot.push_str("  node [shape=box, fontname=\"Courier\"];\n");

            for (addr, block) in &self.blocks {
                // Node label avec les instructions
                let mut label = format!("0x{:x}\\l", addr);
                for instr in &block.instructions {
                    label.push_str(&format!("  {} {}\\l",
                        instr.mnemonic, instr.operands_str));
                }

                dot.push_str(&format!("  \"0x{:x}\" [label=\"{}\"];\n", addr, label));

                // Edges vers les successeurs
                for succ in &block.successors {
                    dot.push_str(&format!("  \"0x{:x}\" -> \"0x{:x}\";\n", addr, succ));
                }
            }

            dot.push_str("}\n");
            dot
        }
    }

    /// Identifier les fonctions
    pub struct FunctionIdentifier;

    impl FunctionIdentifier {
        /// Detecter les prologues de fonction
        pub fn find_function_prologues(code: &[u8], base: u64) -> Vec<u64> {
            let mut functions = Vec::new();

            // Pattern: push rbp; mov rbp, rsp
            let prologue_pattern = [0x55, 0x48, 0x89, 0xe5];

            for i in 0..code.len().saturating_sub(prologue_pattern.len()) {
                if code[i..].starts_with(&prologue_pattern) {
                    functions.push(base + i as u64);
                }
            }

            functions
        }

        /// Detecter les epilogues
        pub fn find_function_epilogues(code: &[u8], base: u64) -> Vec<u64> {
            let mut epilogues = Vec::new();

            // Pattern: leave; ret ou pop rbp; ret
            let patterns: &[&[u8]] = &[
                &[0xc9, 0xc3],       // leave; ret
                &[0x5d, 0xc3],       // pop rbp; ret
            ];

            for i in 0..code.len() {
                for pattern in patterns {
                    if code[i..].starts_with(pattern) {
                        epilogues.push(base + i as u64);
                    }
                }
            }

            epilogues
        }
    }
}

// ============================================
// PARTIE 3: Debugger Simulator
// ============================================

pub mod debugger {
    use super::*;
    use std::collections::HashMap;

    #[derive(Clone, Debug)]
    pub struct Breakpoint {
        pub address: u64,
        pub enabled: bool,
        pub condition: Option<String>,
        pub hit_count: u64,
        pub commands: Vec<String>,
    }

    #[derive(Clone, Debug)]
    pub struct Watchpoint {
        pub address: u64,
        pub size: usize,
        pub watch_type: WatchType,
        pub old_value: Vec<u8>,
    }

    #[derive(Clone, Debug)]
    pub enum WatchType {
        Write,
        Read,
        ReadWrite,
    }

    pub struct DebuggerState {
        pub registers: HashMap<disasm::Register, u64>,
        pub memory: Vec<u8>,
        pub memory_base: u64,
        pub breakpoints: HashMap<u64, Breakpoint>,
        pub watchpoints: Vec<Watchpoint>,
        pub running: bool,
    }

    impl DebuggerState {
        pub fn new() -> Self {
            let mut registers = HashMap::new();
            registers.insert(disasm::Register::RAX, 0);
            registers.insert(disasm::Register::RBX, 0);
            registers.insert(disasm::Register::RCX, 0);
            registers.insert(disasm::Register::RDX, 0);
            registers.insert(disasm::Register::RSI, 0);
            registers.insert(disasm::Register::RDI, 0);
            registers.insert(disasm::Register::RSP, 0x7fffffffe000);
            registers.insert(disasm::Register::RBP, 0);
            registers.insert(disasm::Register::RIP, 0);

            DebuggerState {
                registers,
                memory: vec![0; 0x100000],
                memory_base: 0x555555554000,
                breakpoints: HashMap::new(),
                watchpoints: Vec::new(),
                running: false,
            }
        }

        /// Commande: break
        pub fn set_breakpoint(&mut self, addr: u64) -> u64 {
            let id = self.breakpoints.len() as u64 + 1;
            self.breakpoints.insert(addr, Breakpoint {
                address: addr,
                enabled: true,
                condition: None,
                hit_count: 0,
                commands: Vec::new(),
            });
            println!("Breakpoint {} at 0x{:x}", id, addr);
            id
        }

        /// Commande: break if condition
        pub fn set_conditional_breakpoint(&mut self, addr: u64, condition: &str) {
            let bp = Breakpoint {
                address: addr,
                enabled: true,
                condition: Some(condition.to_string()),
                hit_count: 0,
                commands: Vec::new(),
            };
            self.breakpoints.insert(addr, bp);
            println!("Breakpoint at 0x{:x} if {}", addr, condition);
        }

        /// Commande: watch
        pub fn set_watchpoint(&mut self, addr: u64, size: usize, watch_type: WatchType) {
            let offset = (addr - self.memory_base) as usize;
            let old_value = self.memory[offset..offset+size].to_vec();

            self.watchpoints.push(Watchpoint {
                address: addr,
                size,
                watch_type,
                old_value,
            });
            println!("Watchpoint set at 0x{:x} ({} bytes)", addr, size);
        }

        /// Commande: x/Nx (examine memory)
        pub fn examine(&self, addr: u64, count: usize, format: ExamineFormat) {
            let offset = (addr.saturating_sub(self.memory_base)) as usize;

            match format {
                ExamineFormat::Hex64 => {
                    for i in 0..count {
                        if offset + i * 8 + 8 <= self.memory.len() {
                            let val = u64::from_le_bytes(
                                self.memory[offset + i*8..offset + i*8 + 8].try_into().unwrap()
                            );
                            if i % 2 == 0 {
                                print!("0x{:016x}: ", addr + (i * 8) as u64);
                            }
                            print!("0x{:016x} ", val);
                            if i % 2 == 1 {
                                println!();
                            }
                        }
                    }
                    println!();
                }
                ExamineFormat::Hex32 => {
                    for i in 0..count {
                        if offset + i * 4 + 4 <= self.memory.len() {
                            let val = u32::from_le_bytes(
                                self.memory[offset + i*4..offset + i*4 + 4].try_into().unwrap()
                            );
                            if i % 4 == 0 {
                                print!("0x{:016x}: ", addr + (i * 4) as u64);
                            }
                            print!("0x{:08x} ", val);
                            if i % 4 == 3 {
                                println!();
                            }
                        }
                    }
                    println!();
                }
                ExamineFormat::String => {
                    print!("0x{:016x}: \"", addr);
                    for i in 0..count {
                        if offset + i < self.memory.len() {
                            let b = self.memory[offset + i];
                            if b == 0 {
                                break;
                            } else if b.is_ascii_graphic() || b == b' ' {
                                print!("{}", b as char);
                            } else {
                                print!("\\x{:02x}", b);
                            }
                        }
                    }
                    println!("\"");
                }
                ExamineFormat::Instructions => {
                    let disasm = disasm::Disassembler::new(
                        self.memory.clone(),
                        self.memory_base
                    );
                    disasm.dump(addr, count);
                }
            }
        }

        /// Commande: info registers
        pub fn print_registers(&self) {
            println!("rax  0x{:016x}", self.registers[&disasm::Register::RAX]);
            println!("rbx  0x{:016x}", self.registers[&disasm::Register::RBX]);
            println!("rcx  0x{:016x}", self.registers[&disasm::Register::RCX]);
            println!("rdx  0x{:016x}", self.registers[&disasm::Register::RDX]);
            println!("rsi  0x{:016x}", self.registers[&disasm::Register::RSI]);
            println!("rdi  0x{:016x}", self.registers[&disasm::Register::RDI]);
            println!("rbp  0x{:016x}", self.registers[&disasm::Register::RBP]);
            println!("rsp  0x{:016x}", self.registers[&disasm::Register::RSP]);
            println!("rip  0x{:016x}", self.registers[&disasm::Register::RIP]);
        }
    }

    #[derive(Clone, Copy)]
    pub enum ExamineFormat {
        Hex64,       // x/gx
        Hex32,       // x/wx
        String,      // x/s
        Instructions, // x/i
    }

    /// GDB Python API Simulator
    pub mod python_api {
        use super::*;

        pub struct GDBScript {
            pub name: String,
            pub code: String,
        }

        impl GDBScript {
            /// Simuler un script GDB Python basique
            pub fn example_breakpoint_command() -> Self {
                GDBScript {
                    name: "log_calls".to_string(),
                    code: r#"
import gdb

class LogCalls(gdb.Breakpoint):
    def __init__(self, func):
        super().__init__(func)
        self.silent = True

    def stop(self):
        rdi = gdb.parse_and_eval("$rdi")
        print(f"Called with rdi = {rdi}")
        return False  # Don't actually stop

LogCalls("target_function")
"#.to_string(),
                }
            }

            pub fn example_memory_dump() -> Self {
                GDBScript {
                    name: "dump_struct".to_string(),
                    code: r#"
import gdb

def dump_my_struct(addr):
    """Dump a custom struct at address"""
    ptr = gdb.Value(addr).cast(gdb.lookup_type('struct my_struct').pointer())

    print(f"field1: {ptr['field1']}")
    print(f"field2: {ptr['field2']}")
    print(f"next:   {ptr['next']}")

# Usage: dump_my_struct(0x555555554000)
"#.to_string(),
                }
            }
        }
    }

    /// Core dump analysis
    pub struct CoreDump {
        pub registers: HashMap<disasm::Register, u64>,
        pub memory_regions: Vec<(u64, Vec<u8>)>,
        pub signal: i32,
        pub fault_address: u64,
    }

    impl CoreDump {
        pub fn analyze(&self) {
            println!("=== Core Dump Analysis ===");
            println!();
            println!("Signal: {} ({})", self.signal, self.signal_name());
            println!("Fault address: 0x{:x}", self.fault_address);
            println!();
            println!("Registers at crash:");
            for (reg, val) in &self.registers {
                println!("  {:?}: 0x{:016x}", reg, val);
            }
            println!();

            // Analyser la stack
            if let Some(rsp) = self.registers.get(&disasm::Register::RSP) {
                println!("Stack around RSP (0x{:x}):", rsp);
                // ...
            }
        }

        fn signal_name(&self) -> &'static str {
            match self.signal {
                11 => "SIGSEGV (Segmentation fault)",
                6 => "SIGABRT (Aborted)",
                8 => "SIGFPE (Floating point exception)",
                4 => "SIGILL (Illegal instruction)",
                _ => "Unknown",
            }
        }
    }
}

// ============================================
// PARTIE 4: Pattern Recognition
// ============================================

pub mod patterns {
    use super::*;

    /// Reconnaitre les patterns de structures
    pub struct StructRecovery;

    impl StructRecovery {
        /// Analyser les acces memoire pour deduire les champs
        pub fn analyze_accesses(accesses: &[(u64, usize, &str)]) {
            println!("=== Structure Field Recovery ===");
            println!();

            // Trier par offset
            let mut sorted: Vec<_> = accesses.iter().collect();
            sorted.sort_by_key(|(offset, _, _)| *offset);

            println!("struct recovered_struct {{");
            let mut prev_end = 0;
            for (offset, size, access_type) in sorted {
                if *offset > prev_end {
                    // Padding
                    println!("    char padding[{}];  // offset 0x{:x}", offset - prev_end, prev_end);
                }

                let type_name = match size {
                    1 => "uint8_t",
                    2 => "uint16_t",
                    4 => "uint32_t",
                    8 => "uint64_t",
                    _ => "char[]",
                };

                println!("    {} field_{:x};  // offset 0x{:x}, {}",
                    type_name, offset, offset, access_type);

                prev_end = offset + size;
            }
            println!("}}; // total size >= 0x{:x}", prev_end);
        }
    }

    /// Identifier les algorithmes courants
    pub struct AlgorithmIdentifier;

    impl AlgorithmIdentifier {
        pub fn identify_crypto_constants(code: &[u8]) -> Vec<&'static str> {
            let mut found = Vec::new();

            // SHA-256 initial hash values
            let sha256_h = [
                0x6a09e667u32, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
            ];

            // MD5 constants
            let md5_k = [0xd76aa478u32, 0xe8c7b756];

            // AES S-box first byte
            let aes_sbox = [0x63u8, 0x7c, 0x77, 0x7b];

            for chunk in code.windows(4) {
                let val = u32::from_le_bytes(chunk.try_into().unwrap());
                if sha256_h.contains(&val) {
                    found.push("SHA-256 (initial hash values detected)");
                }
                if md5_k.contains(&val) {
                    found.push("MD5 (round constants detected)");
                }
            }

            for chunk in code.windows(4) {
                if chunk == aes_sbox {
                    found.push("AES (S-box detected)");
                }
            }

            found
        }
    }
}

// ============================================
// PARTIE 5: Anti-Reversing Detection
// ============================================

pub mod antireverse {
    /// Techniques d'anti-debugging communes
    pub struct AntiDebugDetector;

    impl AntiDebugDetector {
        /// Detecter les patterns d'anti-debugging
        pub fn scan(code: &[u8]) -> Vec<AntiDebugTechnique> {
            let mut found = Vec::new();

            // ptrace(PTRACE_TRACEME, 0, 0, 0)
            // syscall avec rax = 101
            let ptrace_pattern = [0x48, 0xc7, 0xc0, 0x65, 0x00, 0x00, 0x00]; // mov rax, 101
            if code.windows(7).any(|w| w == ptrace_pattern) {
                found.push(AntiDebugTechnique::PtraceCheck);
            }

            // Check /proc/self/status for TracerPid
            if code.windows(20).any(|w| w.windows(9).any(|s|
                s == b"TracerPid" || s == b"/proc/sel")) {
                found.push(AntiDebugTechnique::ProcStatusCheck);
            }

            // SIGTRAP handler manipulation
            // ...

            found
        }

        pub fn describe_techniques() {
            println!("=== Anti-Reversing Techniques ===");
            println!();

            println!("1. ptrace(PTRACE_TRACEME)");
            println!("   - Process can only be traced once");
            println!("   - If debugger attached, ptrace fails");
            println!();

            println!("2. /proc/self/status");
            println!("   - Check TracerPid field");
            println!("   - Non-zero means being traced");
            println!();

            println!("3. Timing checks");
            println!("   - rdtsc before and after operations");
            println!("   - Debugger stepping causes delays");
            println!();

            println!("4. INT3 / SIGTRAP handling");
            println!("   - Set custom SIGTRAP handler");
            println!("   - Insert INT3 in code");
            println!("   - Debugger will catch, changing behavior");
            println!();

            println!("5. Self-modifying code");
            println!("   - Decrypt code at runtime");
            println!("   - Static analysis sees garbage");
            println!();

            println!("6. VM/Emulator detection");
            println!("   - Check CPUID for hypervisor");
            println!("   - Check MAC address prefixes");
        }
    }

    #[derive(Debug)]
    pub enum AntiDebugTechnique {
        PtraceCheck,
        ProcStatusCheck,
        TimingCheck,
        SigtrapHandler,
        SelfModifying,
        VmDetection,
    }

    /// Obfuscation patterns
    pub struct ObfuscationDetector;

    impl ObfuscationDetector {
        pub fn detect_patterns(code: &[u8]) -> Vec<&'static str> {
            let mut patterns = Vec::new();

            // Opaque predicates (conditions always true/false)
            // Example: cmp eax, eax; jne (never taken)

            // Control flow flattening (switch-based dispatch)
            // Many blocks jumping to same dispatcher

            // Dead code insertion
            // Unreachable instructions after unconditional jumps

            // Instruction substitution
            // x ^ x instead of mov x, 0

            patterns
        }
    }
}

// ============================================
// TESTS
// ============================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_disassemble_prologue() {
        // push rbp; mov rbp, rsp; sub rsp, 0x20
        let code = vec![0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x20, 0xc3];
        let disasm = disasm::Disassembler::new(code, 0x1000);
        let instructions = disasm.disassemble_at(0x1000, 10);

        assert_eq!(instructions.len(), 4);
        assert_eq!(instructions[0].mnemonic, "push");
        assert_eq!(instructions[1].mnemonic, "mov");
        assert_eq!(instructions[2].mnemonic, "sub");
        assert_eq!(instructions[3].mnemonic, "ret");
    }

    #[test]
    fn test_cfg_building() {
        // Simple function with conditional
        let code = vec![
            0x55,                   // push rbp
            0x48, 0x89, 0xe5,       // mov rbp, rsp
            0x48, 0x83, 0xec, 0x10, // sub rsp, 0x10
            0x74, 0x05,             // je +5
            0x90, 0x90,             // nop nop
            0xeb, 0x02,             // jmp +2
            0x90, 0x90,             // nop nop
            0xc9,                   // leave
            0xc3,                   // ret
        ];
        let disasm = disasm::Disassembler::new(code, 0x1000);
        let cfg = analysis::ControlFlowGraph::build(&disasm, 0x1000);

        assert!(cfg.blocks.len() >= 1);
    }

    #[test]
    fn test_find_function_prologues() {
        let code = vec![
            0x90, 0x90,             // nop nop
            0x55, 0x48, 0x89, 0xe5, // push rbp; mov rbp, rsp
            0xc3,                   // ret
            0x55, 0x48, 0x89, 0xe5, // Another function
            0xc3,
        ];

        let funcs = analysis::FunctionIdentifier::find_function_prologues(&code, 0x1000);
        assert_eq!(funcs.len(), 2);
        assert_eq!(funcs[0], 0x1002);
        assert_eq!(funcs[1], 0x1007);
    }

    #[test]
    fn test_debugger_examine() {
        let mut dbg = debugger::DebuggerState::new();
        dbg.memory[0..8].copy_from_slice(&0xDEADBEEFCAFEBABEu64.to_le_bytes());
        dbg.examine(dbg.memory_base, 1, debugger::ExamineFormat::Hex64);
    }
}
```

## Criteres d'evaluation (Moulinette)

1. **Desassembleur (30 points)**
   - Decodage correct des instructions communes
   - Affichage style objdump

2. **Control Flow Graph (25 points)**
   - Detection des blocs de base
   - Successeurs/predecesseurs corrects
   - Export DOT

3. **Debugger (25 points)**
   - Breakpoints conditionnels
   - Examine memory
   - Watchpoints

4. **Pattern Recognition (20 points)**
   - Detection de structures
   - Identification d'algorithmes crypto

## Note qualite: 96/100

**Forces:**
- Desassembleur x86-64 fonctionnel
- CFG avec export Graphviz
- Simulation complete de GDB
- Detection d'anti-debugging
