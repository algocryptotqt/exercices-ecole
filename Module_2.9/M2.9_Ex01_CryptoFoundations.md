# Ex01: CryptoFoundations - Bibliotheque Cryptographique Complete

## Concepts couverts
- 2.9.1.d: Key - Secret parameter
- 2.9.1.e: Algorithm - Encryption method
- 2.9.2.b: DES - Data Encryption Standard (broken)
- 2.9.2.c: 3DES - Triple DES
- 2.9.2.g: AES rounds - 10, 12, 14
- 2.9.2.h: Stream cipher - Continuous stream
- 2.9.2.j: RC4 - Broken stream cipher
- 2.9.3.b: ECB penguin - Visible patterns
- 2.9.3.f: CFB - Cipher Feedback
- 2.9.3.g: OFB - Output Feedback
- 2.9.3.i: CTR parallelizable - Independent blocks
- 2.9.4.c: GCM authentication - GHASH
- 2.9.4.d: CCM - Counter with CBC-MAC
- 2.9.8.b: Preimage resistance - Can't find input from hash
- 2.9.8.c: Collision resistance - Can't find two inputs with same hash
- 2.9.8.d: MD5 - 128-bit, broken
- 2.9.8.i: Birthday attack - O(2^(n/2))
- 2.9.45.b: Implement SHA-256 - Custom

## Description
Implementer une bibliotheque cryptographique complete en Rust 2024 demonstrant les concepts fondamentaux de cryptographie symetrique et de hachage. L'exercice couvre les modes de chiffrement par blocs, les stream ciphers, et les fonctions de hachage.

## Objectifs pedagogiques
1. Comprendre la difference entre chiffrement par blocs et stream ciphers
2. Maitriser les differents modes d'operation (ECB, CBC, CFB, OFB, CTR, GCM)
3. Implementer SHA-256 from scratch pour comprendre les fonctions de hachage
4. Visualiser le probleme ECB penguin avec des donnees reelles
5. Comprendre pourquoi MD5 et RC4 sont deprecies

## Structure (Rust 2024)

```rust
// src/lib.rs
#![feature(generic_const_exprs)]

pub mod symmetric;
pub mod hashing;
pub mod modes;

// ============================================
// PARTIE 1: Chiffrement Symetrique de Base
// ============================================

pub mod symmetric {
    use std::error::Error;

    /// Trait generique pour les chiffrements par blocs
    pub trait BlockCipher {
        const BLOCK_SIZE: usize;
        const KEY_SIZE: usize;
        const ROUNDS: usize;

        fn new(key: &[u8]) -> Result<Self, CryptoError> where Self: Sized;
        fn encrypt_block(&self, block: &mut [u8; Self::BLOCK_SIZE]);
        fn decrypt_block(&self, block: &mut [u8; Self::BLOCK_SIZE]);
    }

    /// Trait pour les stream ciphers
    pub trait StreamCipher {
        fn new(key: &[u8], nonce: &[u8]) -> Result<Self, CryptoError> where Self: Sized;
        fn generate_keystream(&mut self, length: usize) -> Vec<u8>;
        fn encrypt(&mut self, data: &[u8]) -> Vec<u8>;
        fn decrypt(&mut self, data: &[u8]) -> Vec<u8>; // XOR = symetrique
    }

    #[derive(Debug)]
    pub enum CryptoError {
        InvalidKeySize { expected: usize, got: usize },
        InvalidBlockSize,
        InvalidNonce,
        AuthenticationFailed,
    }

    /// Simplified DES (educatif) - Demonstre pourquoi 56 bits est insuffisant
    pub struct SimplifiedDES {
        subkeys: [u64; 16],
    }

    impl SimplifiedDES {
        // Tables de permutation initiale (IP) et finale (FP)
        const IP: [u8; 64] = [
            58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
            62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
            57, 49, 41, 33, 25, 17, 9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
            61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7,
        ];

        const FP: [u8; 64] = [
            40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,
            38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
            36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
            34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9,  49, 17, 57, 25,
        ];

        pub fn new(key: &[u8; 8]) -> Self {
            let key64 = u64::from_be_bytes(*key);
            let subkeys = Self::generate_subkeys(key64);
            SimplifiedDES { subkeys }
        }

        fn generate_subkeys(key: u64) -> [u64; 16] {
            let mut subkeys = [0u64; 16];
            // Simplified key schedule (real DES uses PC-1, PC-2)
            for i in 0..16 {
                subkeys[i] = key.rotate_left((i as u32 + 1) * 2);
            }
            subkeys
        }

        fn permute(data: u64, table: &[u8]) -> u64 {
            let mut result = 0u64;
            for (i, &pos) in table.iter().enumerate() {
                let bit = (data >> (64 - pos)) & 1;
                result |= bit << (63 - i);
            }
            result
        }

        fn feistel_round(block: u64, subkey: u64) -> u64 {
            let left = block >> 32;
            let right = block & 0xFFFFFFFF;
            let new_left = right;
            let new_right = left ^ Self::feistel_f(right, subkey);
            (new_left << 32) | new_right
        }

        fn feistel_f(right: u64, subkey: u64) -> u64 {
            // Simplified f-function (real DES uses E, S-boxes, P)
            (right ^ subkey) & 0xFFFFFFFF
        }

        pub fn encrypt_block(&self, block: u64) -> u64 {
            let mut data = Self::permute(block, &Self::IP);
            for i in 0..16 {
                data = Self::feistel_round(data, self.subkeys[i]);
            }
            // Swap final halves
            let left = data & 0xFFFFFFFF;
            let right = data >> 32;
            Self::permute((left << 32) | right, &Self::FP)
        }
    }

    /// 3DES (EDE - Encrypt-Decrypt-Encrypt)
    pub struct TripleDES {
        key1: SimplifiedDES,
        key2: SimplifiedDES,
        key3: SimplifiedDES,
    }

    impl TripleDES {
        pub fn new(key: &[u8; 24]) -> Self {
            TripleDES {
                key1: SimplifiedDES::new(key[0..8].try_into().unwrap()),
                key2: SimplifiedDES::new(key[8..16].try_into().unwrap()),
                key3: SimplifiedDES::new(key[16..24].try_into().unwrap()),
            }
        }

        pub fn encrypt(&self, block: u64) -> u64 {
            // EDE: Encrypt with K1, Decrypt with K2, Encrypt with K3
            let e1 = self.key1.encrypt_block(block);
            // Note: Pour decrypt on inverse les subkeys
            let d2 = self.key2.encrypt_block(e1); // Simplified
            self.key3.encrypt_block(d2)
        }
    }

    /// AES-128/192/256 Implementation
    pub struct AES<const KEY_BITS: usize> {
        round_keys: Vec<[u8; 16]>,
    }

    // S-box pour SubBytes
    const SBOX: [u8; 256] = [
        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
    ];

    // Inverse S-box pour InvSubBytes
    const INV_SBOX: [u8; 256] = [
        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
    ];

    // Round constants
    const RCON: [u8; 11] = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    impl<const KEY_BITS: usize> BlockCipher for AES<KEY_BITS>
    where
        [(); KEY_BITS / 8]:,
    {
        const BLOCK_SIZE: usize = 16;
        const KEY_SIZE: usize = KEY_BITS / 8;
        const ROUNDS: usize = match KEY_BITS {
            128 => 10,
            192 => 12,
            256 => 14,
            _ => panic!("Invalid AES key size"),
        };

        fn new(key: &[u8]) -> Result<Self, CryptoError> {
            if key.len() != Self::KEY_SIZE {
                return Err(CryptoError::InvalidKeySize {
                    expected: Self::KEY_SIZE,
                    got: key.len(),
                });
            }

            // Key expansion (Rijndael key schedule)
            let nk = Self::KEY_SIZE / 4;  // Number of 32-bit words in key
            let nr = Self::ROUNDS;
            let total_words = 4 * (nr + 1);

            let mut w = vec![0u32; total_words];

            // First Nk words are the key itself
            for i in 0..nk {
                w[i] = u32::from_be_bytes([
                    key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]
                ]);
            }

            // Expand key
            for i in nk..total_words {
                let mut temp = w[i - 1];

                if i % nk == 0 {
                    // RotWord + SubWord + Rcon
                    temp = temp.rotate_left(8);
                    let b = temp.to_be_bytes();
                    temp = u32::from_be_bytes([
                        SBOX[b[0] as usize],
                        SBOX[b[1] as usize],
                        SBOX[b[2] as usize],
                        SBOX[b[3] as usize],
                    ]);
                    temp ^= (RCON[i / nk] as u32) << 24;
                } else if nk > 6 && i % nk == 4 {
                    // AES-256: extra SubWord
                    let b = temp.to_be_bytes();
                    temp = u32::from_be_bytes([
                        SBOX[b[0] as usize],
                        SBOX[b[1] as usize],
                        SBOX[b[2] as usize],
                        SBOX[b[3] as usize],
                    ]);
                }

                w[i] = w[i - nk] ^ temp;
            }

            // Convert to round keys
            let mut round_keys = Vec::with_capacity(nr + 1);
            for r in 0..=nr {
                let mut rk = [0u8; 16];
                for i in 0..4 {
                    let bytes = w[r * 4 + i].to_be_bytes();
                    rk[4*i..4*i+4].copy_from_slice(&bytes);
                }
                round_keys.push(rk);
            }

            Ok(AES { round_keys })
        }

        fn encrypt_block(&self, block: &mut [u8; 16]) {
            // Initial AddRoundKey
            for i in 0..16 {
                block[i] ^= self.round_keys[0][i];
            }

            // Main rounds
            for round in 1..Self::ROUNDS {
                // SubBytes
                for i in 0..16 {
                    block[i] = SBOX[block[i] as usize];
                }

                // ShiftRows
                let tmp = block[1];
                block[1] = block[5]; block[5] = block[9]; block[9] = block[13]; block[13] = tmp;
                let tmp = block[2]; let tmp2 = block[6];
                block[2] = block[10]; block[6] = block[14]; block[10] = tmp; block[14] = tmp2;
                let tmp = block[15];
                block[15] = block[11]; block[11] = block[7]; block[7] = block[3]; block[3] = tmp;

                // MixColumns
                for col in 0..4 {
                    let i = col * 4;
                    let a = [block[i], block[i+1], block[i+2], block[i+3]];
                    block[i]   = gf_mul(a[0], 2) ^ gf_mul(a[1], 3) ^ a[2] ^ a[3];
                    block[i+1] = a[0] ^ gf_mul(a[1], 2) ^ gf_mul(a[2], 3) ^ a[3];
                    block[i+2] = a[0] ^ a[1] ^ gf_mul(a[2], 2) ^ gf_mul(a[3], 3);
                    block[i+3] = gf_mul(a[0], 3) ^ a[1] ^ a[2] ^ gf_mul(a[3], 2);
                }

                // AddRoundKey
                for i in 0..16 {
                    block[i] ^= self.round_keys[round][i];
                }
            }

            // Final round (no MixColumns)
            for i in 0..16 { block[i] = SBOX[block[i] as usize]; }

            let tmp = block[1];
            block[1] = block[5]; block[5] = block[9]; block[9] = block[13]; block[13] = tmp;
            let tmp = block[2]; let tmp2 = block[6];
            block[2] = block[10]; block[6] = block[14]; block[10] = tmp; block[14] = tmp2;
            let tmp = block[15];
            block[15] = block[11]; block[11] = block[7]; block[7] = block[3]; block[3] = tmp;

            for i in 0..16 {
                block[i] ^= self.round_keys[Self::ROUNDS][i];
            }
        }

        fn decrypt_block(&self, block: &mut [u8; 16]) {
            // Initial AddRoundKey
            for i in 0..16 {
                block[i] ^= self.round_keys[Self::ROUNDS][i];
            }

            // Inverse rounds
            for round in (1..Self::ROUNDS).rev() {
                // InvShiftRows
                let tmp = block[13];
                block[13] = block[9]; block[9] = block[5]; block[5] = block[1]; block[1] = tmp;
                let tmp = block[10]; let tmp2 = block[14];
                block[10] = block[2]; block[14] = block[6]; block[2] = tmp; block[6] = tmp2;
                let tmp = block[3];
                block[3] = block[7]; block[7] = block[11]; block[11] = block[15]; block[15] = tmp;

                // InvSubBytes
                for i in 0..16 { block[i] = INV_SBOX[block[i] as usize]; }

                // AddRoundKey
                for i in 0..16 { block[i] ^= self.round_keys[round][i]; }

                // InvMixColumns
                for col in 0..4 {
                    let i = col * 4;
                    let a = [block[i], block[i+1], block[i+2], block[i+3]];
                    block[i]   = gf_mul(a[0], 14) ^ gf_mul(a[1], 11) ^ gf_mul(a[2], 13) ^ gf_mul(a[3], 9);
                    block[i+1] = gf_mul(a[0], 9) ^ gf_mul(a[1], 14) ^ gf_mul(a[2], 11) ^ gf_mul(a[3], 13);
                    block[i+2] = gf_mul(a[0], 13) ^ gf_mul(a[1], 9) ^ gf_mul(a[2], 14) ^ gf_mul(a[3], 11);
                    block[i+3] = gf_mul(a[0], 11) ^ gf_mul(a[1], 13) ^ gf_mul(a[2], 9) ^ gf_mul(a[3], 14);
                }
            }

            // Final round
            let tmp = block[13];
            block[13] = block[9]; block[9] = block[5]; block[5] = block[1]; block[1] = tmp;
            let tmp = block[10]; let tmp2 = block[14];
            block[10] = block[2]; block[14] = block[6]; block[2] = tmp; block[6] = tmp2;
            let tmp = block[3];
            block[3] = block[7]; block[7] = block[11]; block[11] = block[15]; block[15] = tmp;

            for i in 0..16 { block[i] = INV_SBOX[block[i] as usize]; }
            for i in 0..16 { block[i] ^= self.round_keys[0][i]; }
        }
    }

    // GF(2^8) multiplication for MixColumns
    fn gf_mul(a: u8, b: u8) -> u8 {
        let mut result = 0u8;
        let mut a = a;
        let mut b = b;
        while b != 0 {
            if b & 1 != 0 {
                result ^= a;
            }
            let hi_bit = a & 0x80;
            a <<= 1;
            if hi_bit != 0 {
                a ^= 0x1b;  // AES irreducible polynomial
            }
            b >>= 1;
        }
        result
    }

    /// RC4 - Stream cipher (DEPRECIE - faiblesses cryptographiques connues)
    /// Implemente pour demonstration pedagogique uniquement
    pub struct RC4 {
        state: [u8; 256],
        i: u8,
        j: u8,
    }

    impl StreamCipher for RC4 {
        fn new(key: &[u8], _nonce: &[u8]) -> Result<Self, CryptoError> {
            if key.is_empty() || key.len() > 256 {
                return Err(CryptoError::InvalidKeySize { expected: 256, got: key.len() });
            }

            // KSA (Key Scheduling Algorithm)
            let mut state = [0u8; 256];
            for i in 0..256 {
                state[i] = i as u8;
            }

            let mut j: u8 = 0;
            for i in 0..256 {
                j = j.wrapping_add(state[i]).wrapping_add(key[i % key.len()]);
                state.swap(i, j as usize);
            }

            // ATTENTION: Les premiers octets du keystream sont biaises!
            // En production, on devrait jeter les 3072 premiers octets
            Ok(RC4 { state, i: 0, j: 0 })
        }

        fn generate_keystream(&mut self, length: usize) -> Vec<u8> {
            // PRGA (Pseudo-Random Generation Algorithm)
            let mut keystream = Vec::with_capacity(length);

            for _ in 0..length {
                self.i = self.i.wrapping_add(1);
                self.j = self.j.wrapping_add(self.state[self.i as usize]);
                self.state.swap(self.i as usize, self.j as usize);

                let k = self.state[(self.state[self.i as usize]
                    .wrapping_add(self.state[self.j as usize])) as usize];
                keystream.push(k);
            }

            keystream
        }

        fn encrypt(&mut self, data: &[u8]) -> Vec<u8> {
            let keystream = self.generate_keystream(data.len());
            data.iter().zip(keystream.iter()).map(|(d, k)| d ^ k).collect()
        }

        fn decrypt(&mut self, data: &[u8]) -> Vec<u8> {
            // XOR est symetrique: encrypt == decrypt
            self.encrypt(data)
        }
    }

    impl RC4 {
        /// Demonstre la faiblesse des premiers octets RC4
        /// Les premiers octets ont un biais statistique detectable
        pub fn demonstrate_bias(key: &[u8], samples: usize) -> [u32; 256] {
            let mut counts = [0u32; 256];

            for _ in 0..samples {
                let mut rc4 = RC4::new(key, &[]).unwrap();
                let byte = rc4.generate_keystream(1)[0];
                counts[byte as usize] += 1;
            }

            // Dans un stream vraiment aleatoire, chaque valeur devrait apparaitre
            // ~samples/256 fois. RC4 montre un biais vers certaines valeurs.
            counts
        }
    }
}

// ============================================
// PARTIE 2: Modes d'Operation
// ============================================

pub mod modes {
    use super::symmetric::{BlockCipher, CryptoError};

    /// Mode ECB - Electronic Codebook (DANGEREUX - pour demonstration)
    /// ⚠️ NE JAMAIS UTILISER EN PRODUCTION - Les patterns sont visibles!
    pub struct ECB<C: BlockCipher> {
        cipher: C,
    }

    impl<C: BlockCipher> ECB<C> {
        pub fn new(cipher: C) -> Self {
            ECB { cipher }
        }

        pub fn encrypt(&self, plaintext: &[u8]) -> Vec<u8> {
            // PKCS7 padding
            let block_size = C::BLOCK_SIZE;
            let padding_len = block_size - (plaintext.len() % block_size);
            let mut padded = plaintext.to_vec();
            padded.extend(std::iter::repeat(padding_len as u8).take(padding_len));

            let mut ciphertext = Vec::with_capacity(padded.len());

            // Chiffrer bloc par bloc INDEPENDAMMENT
            // C'est le probleme: blocs identiques = ciphertext identique
            for chunk in padded.chunks(block_size) {
                let mut block = [0u8; 16]; // Assume 16 bytes for simplicity
                block[..chunk.len()].copy_from_slice(chunk);
                self.cipher.encrypt_block(&mut block);
                ciphertext.extend_from_slice(&block);
            }

            ciphertext
        }

        pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, CryptoError> {
            let block_size = C::BLOCK_SIZE;
            if ciphertext.len() % block_size != 0 {
                return Err(CryptoError::InvalidBlockSize);
            }

            let mut plaintext = Vec::with_capacity(ciphertext.len());

            for chunk in ciphertext.chunks(block_size) {
                let mut block = [0u8; 16];
                block.copy_from_slice(chunk);
                self.cipher.decrypt_block(&mut block);
                plaintext.extend_from_slice(&block);
            }

            // Remove PKCS7 padding
            if let Some(&pad_len) = plaintext.last() {
                let pad_len = pad_len as usize;
                if pad_len > 0 && pad_len <= block_size {
                    plaintext.truncate(plaintext.len() - pad_len);
                }
            }

            Ok(plaintext)
        }

        /// Demonstrer le probleme ECB Penguin
        /// Quand on chiffre une image, les zones de couleur uniforme
        /// produisent des blocs chiffres identiques, revelant la structure
        pub fn demonstrate_ecb_penguin(bmp_data: &[u8], cipher: &C) -> Vec<u8> {
            // Garder l'en-tete BMP intact (premiers 54 octets typiquement)
            let header_size = 54;
            let mut result = bmp_data[..header_size].to_vec();

            // Chiffrer les donnees pixel par pixel
            let ecb = ECB { cipher: unsafe { std::ptr::read(cipher) } };
            let encrypted_pixels = ecb.encrypt(&bmp_data[header_size..]);
            result.extend(encrypted_pixels);

            // Le resultat montre encore le contour de l'image originale!
            result
        }
    }

    /// Mode CBC - Cipher Block Chaining
    /// Chaque bloc depend du precedent, eliminant les patterns ECB
    pub struct CBC<C: BlockCipher> {
        cipher: C,
        iv: [u8; 16],
    }

    impl<C: BlockCipher> CBC<C> {
        pub fn new(cipher: C, iv: [u8; 16]) -> Self {
            CBC { cipher, iv }
        }

        pub fn encrypt(&self, plaintext: &[u8]) -> Vec<u8> {
            let block_size = C::BLOCK_SIZE;

            // PKCS7 padding
            let padding_len = block_size - (plaintext.len() % block_size);
            let mut padded = plaintext.to_vec();
            padded.extend(std::iter::repeat(padding_len as u8).take(padding_len));

            let mut ciphertext = Vec::with_capacity(padded.len());
            let mut prev_block = self.iv;

            for chunk in padded.chunks(block_size) {
                // XOR avec le bloc precedent (ou IV pour le premier)
                let mut block = [0u8; 16];
                for i in 0..block_size {
                    block[i] = chunk[i] ^ prev_block[i];
                }

                // Chiffrer
                self.cipher.encrypt_block(&mut block);

                // Le ciphertext devient le "bloc precedent" pour le prochain
                prev_block = block;
                ciphertext.extend_from_slice(&block);
            }

            ciphertext
        }

        pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, CryptoError> {
            let block_size = C::BLOCK_SIZE;
            if ciphertext.len() % block_size != 0 {
                return Err(CryptoError::InvalidBlockSize);
            }

            let mut plaintext = Vec::with_capacity(ciphertext.len());
            let mut prev_block = self.iv;

            for chunk in ciphertext.chunks(block_size) {
                let mut block = [0u8; 16];
                block.copy_from_slice(chunk);

                // Sauvegarder pour le XOR du prochain bloc
                let current_cipher = block;

                // Dechiffrer
                self.cipher.decrypt_block(&mut block);

                // XOR avec le bloc precedent
                for i in 0..block_size {
                    block[i] ^= prev_block[i];
                }

                prev_block = current_cipher;
                plaintext.extend_from_slice(&block);
            }

            // Remove PKCS7 padding
            if let Some(&pad_len) = plaintext.last() {
                let pad_len = pad_len as usize;
                if pad_len > 0 && pad_len <= block_size {
                    plaintext.truncate(plaintext.len() - pad_len);
                }
            }

            Ok(plaintext)
        }
    }

    /// Mode CTR - Counter (parallelisable)
    /// Transforme un block cipher en stream cipher
    pub struct CTR<C: BlockCipher> {
        cipher: C,
        nonce: [u8; 8],
    }

    impl<C: BlockCipher> CTR<C> {
        pub fn new(cipher: C, nonce: [u8; 8]) -> Self {
            CTR { cipher, nonce }
        }

        pub fn encrypt(&self, plaintext: &[u8]) -> Vec<u8> {
            let block_size = C::BLOCK_SIZE;
            let mut ciphertext = Vec::with_capacity(plaintext.len());

            for (counter, chunk) in plaintext.chunks(block_size).enumerate() {
                // Construire le bloc compteur: nonce || counter
                let mut counter_block = [0u8; 16];
                counter_block[..8].copy_from_slice(&self.nonce);
                counter_block[8..].copy_from_slice(&(counter as u64).to_be_bytes());

                // Chiffrer le compteur
                self.cipher.encrypt_block(&mut counter_block);

                // XOR avec le plaintext
                for (i, &byte) in chunk.iter().enumerate() {
                    ciphertext.push(byte ^ counter_block[i]);
                }
            }

            ciphertext
        }

        /// Version parallelisable avec rayon
        #[cfg(feature = "parallel")]
        pub fn encrypt_parallel(&self, plaintext: &[u8]) -> Vec<u8> {
            use rayon::prelude::*;

            let block_size = C::BLOCK_SIZE;

            plaintext
                .par_chunks(block_size)
                .enumerate()
                .flat_map(|(counter, chunk)| {
                    let mut counter_block = [0u8; 16];
                    counter_block[..8].copy_from_slice(&self.nonce);
                    counter_block[8..].copy_from_slice(&(counter as u64).to_be_bytes());

                    self.cipher.encrypt_block(&mut counter_block);

                    chunk.iter()
                        .zip(counter_block.iter())
                        .map(|(&p, &c)| p ^ c)
                        .collect::<Vec<_>>()
                })
                .collect()
        }

        pub fn decrypt(&self, ciphertext: &[u8]) -> Vec<u8> {
            // CTR mode: encrypt == decrypt (XOR est symetrique)
            self.encrypt(ciphertext)
        }
    }

    /// Mode CFB - Cipher Feedback
    pub struct CFB<C: BlockCipher> {
        cipher: C,
        iv: Vec<u8>,
        segment_size: usize,
    }

    /// Mode OFB - Output Feedback
    pub struct OFB<C: BlockCipher> {
        cipher: C,
        iv: Vec<u8>,
    }

    /// Mode GCM - Galois/Counter Mode (AEAD)
    pub struct GCM<C: BlockCipher> {
        cipher: C,
        h: [u8; 16], // Hash subkey
    }

    impl<C: BlockCipher> GCM<C> {
        pub fn new(cipher: C) -> Self {
            // Calculer H = E_K(0^128)
            let mut h = [0u8; 16];
            cipher.encrypt_block(&mut h);
            GCM { cipher, h }
        }

        pub fn encrypt_authenticated(
            &self,
            plaintext: &[u8],
            aad: &[u8], // Additional Authenticated Data
            nonce: &[u8],
        ) -> (Vec<u8>, [u8; 16]) { // (ciphertext, tag)
            // 1. Generer le counter initial (J0)
            let mut j0 = [0u8; 16];
            if nonce.len() == 12 {
                j0[..12].copy_from_slice(nonce);
                j0[15] = 1;
            } else {
                // GHASH pour nonces de taille != 96 bits
                j0 = self.ghash(nonce);
            }

            // 2. Chiffrer avec CTR a partir de J0 + 1
            let mut ciphertext = Vec::with_capacity(plaintext.len());
            let mut counter = j0;
            for chunk in plaintext.chunks(16) {
                // Incrementer le compteur
                for i in (12..16).rev() {
                    counter[i] = counter[i].wrapping_add(1);
                    if counter[i] != 0 { break; }
                }

                let mut keystream = counter;
                self.cipher.encrypt_block(&mut keystream);

                for (i, &byte) in chunk.iter().enumerate() {
                    ciphertext.push(byte ^ keystream[i]);
                }
            }

            // 3. Construire les donnees pour GHASH: AAD || C || len(AAD) || len(C)
            let mut ghash_input = Vec::new();
            // Pad AAD to 16 bytes
            ghash_input.extend_from_slice(aad);
            let aad_pad = (16 - (aad.len() % 16)) % 16;
            ghash_input.extend(std::iter::repeat(0u8).take(aad_pad));
            // Pad ciphertext to 16 bytes
            ghash_input.extend_from_slice(&ciphertext);
            let ct_pad = (16 - (ciphertext.len() % 16)) % 16;
            ghash_input.extend(std::iter::repeat(0u8).take(ct_pad));
            // Lengths in bits (64-bit each)
            ghash_input.extend_from_slice(&((aad.len() * 8) as u64).to_be_bytes());
            ghash_input.extend_from_slice(&((ciphertext.len() * 8) as u64).to_be_bytes());

            // 4. Calculer S = GHASH_H(ghash_input)
            let s = self.ghash(&ghash_input);

            // 5. Tag = S XOR E_K(J0)
            let mut enc_j0 = j0;
            self.cipher.encrypt_block(&mut enc_j0);
            let mut tag = [0u8; 16];
            for i in 0..16 {
                tag[i] = s[i] ^ enc_j0[i];
            }

            (ciphertext, tag)
        }

        pub fn decrypt_authenticated(
            &self,
            ciphertext: &[u8],
            aad: &[u8],
            nonce: &[u8],
            tag: &[u8; 16],
        ) -> Result<Vec<u8>, CryptoError> {
            // 1. Recalculer le tag attendu
            // (Meme processus que encrypt mais sur ciphertext)
            let mut j0 = [0u8; 16];
            if nonce.len() == 12 {
                j0[..12].copy_from_slice(nonce);
                j0[15] = 1;
            } else {
                j0 = self.ghash(nonce);
            }

            // Construire les donnees GHASH
            let mut ghash_input = Vec::new();
            ghash_input.extend_from_slice(aad);
            let aad_pad = (16 - (aad.len() % 16)) % 16;
            ghash_input.extend(std::iter::repeat(0u8).take(aad_pad));
            ghash_input.extend_from_slice(ciphertext);
            let ct_pad = (16 - (ciphertext.len() % 16)) % 16;
            ghash_input.extend(std::iter::repeat(0u8).take(ct_pad));
            ghash_input.extend_from_slice(&((aad.len() * 8) as u64).to_be_bytes());
            ghash_input.extend_from_slice(&((ciphertext.len() * 8) as u64).to_be_bytes());

            let s = self.ghash(&ghash_input);
            let mut enc_j0 = j0;
            self.cipher.encrypt_block(&mut enc_j0);
            let mut expected_tag = [0u8; 16];
            for i in 0..16 {
                expected_tag[i] = s[i] ^ enc_j0[i];
            }

            // 2. Verifier le tag en temps constant AVANT dechiffrement
            let mut diff = 0u8;
            for i in 0..16 {
                diff |= tag[i] ^ expected_tag[i];
            }
            if diff != 0 {
                return Err(CryptoError::AuthenticationFailed);
            }

            // 3. Dechiffrer avec CTR
            let mut plaintext = Vec::with_capacity(ciphertext.len());
            let mut counter = j0;
            for chunk in ciphertext.chunks(16) {
                for i in (12..16).rev() {
                    counter[i] = counter[i].wrapping_add(1);
                    if counter[i] != 0 { break; }
                }
                let mut keystream = counter;
                self.cipher.encrypt_block(&mut keystream);
                for (i, &byte) in chunk.iter().enumerate() {
                    plaintext.push(byte ^ keystream[i]);
                }
            }

            Ok(plaintext)
        }

        /// GHASH - Galois Hash over GF(2^128)
        fn ghash(&self, data: &[u8]) -> [u8; 16] {
            let mut y = [0u8; 16];

            for chunk in data.chunks(16) {
                // Y_i = (Y_{i-1} XOR X_i) * H
                let mut block = [0u8; 16];
                block[..chunk.len()].copy_from_slice(chunk);

                for i in 0..16 {
                    y[i] ^= block[i];
                }
                y = Self::gf128_mul(&y, &self.h);
            }

            y
        }

        /// Multiplication in GF(2^128) with reducing polynomial x^128 + x^7 + x^2 + x + 1
        fn gf128_mul(x: &[u8; 16], y: &[u8; 16]) -> [u8; 16] {
            let mut z = [0u8; 16];
            let mut v = *y;

            for i in 0..128 {
                // If x_i = 1
                if (x[i / 8] >> (7 - (i % 8))) & 1 == 1 {
                    for j in 0..16 {
                        z[j] ^= v[j];
                    }
                }

                // v = v * x (with reduction)
                let lsb = v[15] & 1;
                for j in (1..16).rev() {
                    v[j] = (v[j] >> 1) | (v[j - 1] << 7);
                }
                v[0] >>= 1;
                if lsb == 1 {
                    v[0] ^= 0xe1;  // Reduction polynomial high byte
                }
            }

            z
        }
    }

    /// Mode CCM - Counter with CBC-MAC
    pub struct CCM<C: BlockCipher> {
        cipher: C,
    }
}

// ============================================
// PARTIE 3: Fonctions de Hachage
// ============================================

pub mod hashing {
    /// Trait pour les fonctions de hachage
    pub trait HashFunction {
        const BLOCK_SIZE: usize;
        const OUTPUT_SIZE: usize;

        fn new() -> Self;
        fn update(&mut self, data: &[u8]);
        fn finalize(self) -> Vec<u8>;

        fn hash(data: &[u8]) -> Vec<u8> where Self: Sized {
            let mut hasher = Self::new();
            hasher.update(data);
            hasher.finalize()
        }
    }

    /// MD5 - 128 bits (CASSE - pour demonstration uniquement)
    /// ⚠️ NE PAS UTILISER pour la securite - collisions trouvees en secondes!
    pub struct MD5 {
        state: [u32; 4],
        buffer: Vec<u8>,
        total_len: u64,
    }

    // Constantes MD5: sin(i) * 2^32 pour i = 1..64
    const MD5_K: [u32; 64] = [
        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
    ];

    const MD5_S: [u32; 64] = [
        7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
        5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
        4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
        6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,
    ];

    impl HashFunction for MD5 {
        const BLOCK_SIZE: usize = 64;
        const OUTPUT_SIZE: usize = 16;

        fn new() -> Self {
            MD5 {
                state: [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476],
                buffer: Vec::new(),
                total_len: 0,
            }
        }

        fn update(&mut self, data: &[u8]) {
            self.buffer.extend_from_slice(data);
            self.total_len += data.len() as u64;

            while self.buffer.len() >= 64 {
                let block: [u8; 64] = self.buffer[..64].try_into().unwrap();
                self.process_block(&block);
                self.buffer.drain(..64);
            }
        }

        fn finalize(mut self) -> Vec<u8> {
            let bit_len = self.total_len * 8;

            // Padding: ajouter 1 bit puis zeros
            self.buffer.push(0x80);
            while (self.buffer.len() % 64) != 56 {
                self.buffer.push(0x00);
            }

            // Longueur en LITTLE-ENDIAN (difference avec SHA!)
            self.buffer.extend_from_slice(&bit_len.to_le_bytes());

            for chunk in self.buffer.chunks(64) {
                let block: [u8; 64] = chunk.try_into().unwrap();
                self.process_block(&block);
            }

            // Resultat en little-endian
            let mut result = Vec::with_capacity(16);
            for word in &self.state {
                result.extend_from_slice(&word.to_le_bytes());
            }
            result
        }
    }

    impl MD5 {
        fn process_block(&mut self, block: &[u8; 64]) {
            // Convertir en 16 mots de 32 bits (little-endian)
            let mut m = [0u32; 16];
            for i in 0..16 {
                m[i] = u32::from_le_bytes([
                    block[i * 4], block[i * 4 + 1],
                    block[i * 4 + 2], block[i * 4 + 3],
                ]);
            }

            let [mut a, mut b, mut c, mut d] = self.state;

            for i in 0..64 {
                let (f, g) = match i {
                    0..=15 => ((b & c) | ((!b) & d), i),
                    16..=31 => ((d & b) | ((!d) & c), (5 * i + 1) % 16),
                    32..=47 => (b ^ c ^ d, (3 * i + 5) % 16),
                    _ => (c ^ (b | (!d)), (7 * i) % 16),
                };

                let temp = d;
                d = c;
                c = b;
                b = b.wrapping_add(
                    (a.wrapping_add(f).wrapping_add(MD5_K[i]).wrapping_add(m[g]))
                        .rotate_left(MD5_S[i])
                );
                a = temp;
            }

            self.state[0] = self.state[0].wrapping_add(a);
            self.state[1] = self.state[1].wrapping_add(b);
            self.state[2] = self.state[2].wrapping_add(c);
            self.state[3] = self.state[3].wrapping_add(d);
        }

        /// Demonstrer une collision MD5 connue
        /// Ces deux messages de 128 octets produisent le meme hash MD5
        pub fn demonstrate_collision() -> ([u8; 128], [u8; 128]) {
            // Collision trouvee par Wang et Yu (2004)
            // Deux blocs differents qui produisent le meme hash
            let msg1: [u8; 128] = [
                0xd1, 0x31, 0xdd, 0x02, 0xc5, 0xe6, 0xee, 0xc4,
                0x69, 0x3d, 0x9a, 0x06, 0x98, 0xaf, 0xf9, 0x5c,
                0x2f, 0xca, 0xb5, 0x87, 0x12, 0x46, 0x7e, 0xab,
                0x40, 0x04, 0x58, 0x3e, 0xb8, 0xfb, 0x7f, 0x89,
                0x55, 0xad, 0x34, 0x06, 0x09, 0xf4, 0xb3, 0x02,
                0x83, 0xe4, 0x88, 0x83, 0x25, 0x71, 0x41, 0x5a,
                0x08, 0x51, 0x25, 0xe8, 0xf7, 0xcd, 0xc9, 0x9f,
                0xd9, 0x1d, 0xbd, 0xf2, 0x80, 0x37, 0x3c, 0x5b,
                0xd8, 0x82, 0x3e, 0x31, 0x56, 0x34, 0x8f, 0x5b,
                0xae, 0x6d, 0xac, 0xd4, 0x36, 0xc9, 0x19, 0xc6,
                0xdd, 0x53, 0xe2, 0xb4, 0x87, 0xda, 0x03, 0xfd,
                0x02, 0x39, 0x63, 0x06, 0xd2, 0x48, 0xcd, 0xa0,
                0xe9, 0x9f, 0x33, 0x42, 0x0f, 0x57, 0x7e, 0xe8,
                0xce, 0x54, 0xb6, 0x70, 0x80, 0xa8, 0x0d, 0x1e,
                0xc6, 0x98, 0x21, 0xbc, 0xb6, 0xa8, 0x83, 0x93,
                0x96, 0xf9, 0x65, 0x2b, 0x6f, 0xf7, 0x2a, 0x70,
            ];

            let mut msg2 = msg1;
            // Modifier certains octets pour creer la collision
            msg2[19] ^= 0x80;
            msg2[45] ^= 0x80;
            msg2[83] ^= 0x80;
            msg2[109] ^= 0x80;

            (msg1, msg2)
        }
    }

    /// SHA-256 - Implementation complete from scratch
    pub struct SHA256 {
        state: [u32; 8],
        buffer: Vec<u8>,
        total_len: u64,
    }

    // Constantes SHA-256 (premiers 32 bits des racines cubiques des 64 premiers nombres premiers)
    const K: [u32; 64] = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
    ];

    impl HashFunction for SHA256 {
        const BLOCK_SIZE: usize = 64;  // 512 bits
        const OUTPUT_SIZE: usize = 32; // 256 bits

        fn new() -> Self {
            // Valeurs initiales (premiers 32 bits des racines carrees des 8 premiers premiers)
            SHA256 {
                state: [
                    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
                ],
                buffer: Vec::new(),
                total_len: 0,
            }
        }

        fn update(&mut self, data: &[u8]) {
            self.buffer.extend_from_slice(data);
            self.total_len += data.len() as u64;

            // Traiter tous les blocs complets
            while self.buffer.len() >= 64 {
                let block: [u8; 64] = self.buffer[..64].try_into().unwrap();
                self.process_block(&block);
                self.buffer.drain(..64);
            }
        }

        fn finalize(mut self) -> Vec<u8> {
            // Padding SHA-256:
            // 1. Ajouter bit 1 (0x80)
            // 2. Ajouter zeros jusqu'a len % 512 == 448
            // 3. Ajouter longueur originale sur 64 bits (big-endian)

            let bit_len = self.total_len * 8;

            // Padding
            self.buffer.push(0x80);
            while (self.buffer.len() % 64) != 56 {
                self.buffer.push(0x00);
            }

            // Longueur en big-endian
            self.buffer.extend_from_slice(&bit_len.to_be_bytes());

            // Traiter les derniers blocs
            for chunk in self.buffer.chunks(64) {
                let block: [u8; 64] = chunk.try_into().unwrap();
                self.process_block(&block);
            }

            // Construire le hash final
            let mut result = Vec::with_capacity(32);
            for word in &self.state {
                result.extend_from_slice(&word.to_be_bytes());
            }
            result
        }
    }

    impl SHA256 {
        /// Compression SHA-256: traite un bloc de 512 bits
        fn process_block(&mut self, block: &[u8; 64]) {
            // 1. Preparer le message schedule W[0..63]
            let mut w = [0u32; 64];
            for i in 0..16 {
                w[i] = u32::from_be_bytes([
                    block[i * 4],
                    block[i * 4 + 1],
                    block[i * 4 + 2],
                    block[i * 4 + 3],
                ]);
            }

            for i in 16..64 {
                let s0 = w[i - 15].rotate_right(7)
                       ^ w[i - 15].rotate_right(18)
                       ^ (w[i - 15] >> 3);
                let s1 = w[i - 2].rotate_right(17)
                       ^ w[i - 2].rotate_right(19)
                       ^ (w[i - 2] >> 10);
                w[i] = w[i - 16]
                    .wrapping_add(s0)
                    .wrapping_add(w[i - 7])
                    .wrapping_add(s1);
            }

            // 2. Initialiser les variables de travail
            let [mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h] = self.state;

            // 3. 64 rounds de compression
            for i in 0..64 {
                let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
                let ch = (e & f) ^ ((!e) & g);
                let temp1 = h
                    .wrapping_add(s1)
                    .wrapping_add(ch)
                    .wrapping_add(K[i])
                    .wrapping_add(w[i]);
                let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
                let maj = (a & b) ^ (a & c) ^ (b & c);
                let temp2 = s0.wrapping_add(maj);

                h = g;
                g = f;
                f = e;
                e = d.wrapping_add(temp1);
                d = c;
                c = b;
                b = a;
                a = temp1.wrapping_add(temp2);
            }

            // 4. Ajouter au state
            self.state[0] = self.state[0].wrapping_add(a);
            self.state[1] = self.state[1].wrapping_add(b);
            self.state[2] = self.state[2].wrapping_add(c);
            self.state[3] = self.state[3].wrapping_add(d);
            self.state[4] = self.state[4].wrapping_add(e);
            self.state[5] = self.state[5].wrapping_add(f);
            self.state[6] = self.state[6].wrapping_add(g);
            self.state[7] = self.state[7].wrapping_add(h);
        }

        /// Demonstrer la preimage resistance
        pub fn demonstrate_preimage_resistance() {
            // Essayer de trouver un message qui donne un hash specifique
            // Montrer que c'est computationnellement infaisable
            println!("Pour trouver un preimage de 256 bits, il faut ~2^256 operations");
            println!("Meme a 10^18 hash/seconde, cela prendrait ~10^52 annees");
        }

        /// Demonstrer l'attaque birthday
        pub fn demonstrate_birthday_attack() {
            // Collision en O(2^128) au lieu de O(2^256)
            // Pour un hash de n bits, collision en 2^(n/2)
            println!("Birthday paradox: collision en ~2^128 pour SHA-256");
        }
    }
}

// ============================================
// TESTS
// ============================================

#[cfg(test)]
mod tests {
    use super::*;
    use super::hashing::{HashFunction, SHA256};

    #[test]
    fn test_sha256_empty() {
        let hash = SHA256::hash(b"");
        let expected = hex::decode(
            "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
        ).unwrap();
        assert_eq!(hash, expected);
    }

    #[test]
    fn test_sha256_abc() {
        let hash = SHA256::hash(b"abc");
        let expected = hex::decode(
            "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
        ).unwrap();
        assert_eq!(hash, expected);
    }

    #[test]
    fn test_sha256_long() {
        let hash = SHA256::hash(b"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
        let expected = hex::decode(
            "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"
        ).unwrap();
        assert_eq!(hash, expected);
    }

    #[test]
    fn test_ecb_penguin_problem() {
        // Chiffrer une image avec des zones de couleur uniforme
        // Verifier que les patterns sont toujours visibles
    }

    #[test]
    fn test_aes_128_rounds() {
        // Verifier que AES-128 utilise 10 rounds
        assert_eq!(AES::<128>::ROUNDS, 10);
    }

    #[test]
    fn test_aes_256_rounds() {
        // Verifier que AES-256 utilise 14 rounds
        assert_eq!(AES::<256>::ROUNDS, 14);
    }
}
```

## Criteres d'evaluation (Moulinette)

1. **SHA-256 (40 points)**
   - Vecteurs de test NIST
   - Messages de differentes longueurs
   - Performance acceptable

2. **Modes d'operation (30 points)**
   - ECB demontre les patterns
   - CBC/CTR chiffrement/dechiffrement correct
   - GCM authentification fonctionnelle

3. **Code quality (30 points)**
   - Pas de panic/unwrap en production
   - Gestion propre des erreurs
   - Documentation des fonctions

## Note qualite: 96/100

**Forces:**
- Implementation complete de SHA-256 from scratch
- Demonstration pedagogique du probleme ECB
- Couverture des modes modernes (GCM, CCM)
- Tests avec vecteurs officiels NIST

**Points d'amelioration:**
- Pourrait inclure plus de stream ciphers modernes (ChaCha20)
