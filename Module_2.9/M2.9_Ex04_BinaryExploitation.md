# Ex04: BinaryExploitation - Vulnerabilites Memoire et Exploitation

## Concepts couverts
- 2.9.16.c: Overwrite return - Control execution
- 2.9.16.f: Finding offset - Pattern generation
- 2.9.17.b: Free list - Linked list of free chunks
- 2.9.17.f: Metadata corruption - Overwrite size/pointers
- 2.9.17.h: Unlink attack - Classic technique
- 2.9.18.c: LIFO - Last freed, first allocated
- 2.9.18.d: No security checks - Originally
- 2.9.19.b: LIFO - Singly-linked
- 2.9.19.c: No coalescing - Speed optimization
- 2.9.19.e: Fastbin attack - Corrupt fd pointer
- 2.9.19.f: Size check - Must match bin
- 2.9.19.g: Fake chunk - Create at target
- 2.9.19.h: malloc_hook - Common target
- 2.9.20.b: Top chunk - Wilderness
- 2.9.20.d: House of Spirit - Free fake chunk
- 2.9.20.e: Stack fake chunk - Allocate on stack
- 2.9.20.g: House of Orange - Unsorted bin attack
- 2.9.20.h: House of Einherjar - Off-by-null
- 2.9.26.b: %x - Leak stack
- 2.9.26.c: %s - Read string at address
- 2.9.26.d: %n - Write to address
- 2.9.26.e: Direct parameter - %7$x
- 2.9.26.f: Write arbitrary - Build value with %n
- 2.9.26.g: Write-what-where - Full control
- 2.9.27.c: Unsigned wraparound - Defined, still dangerous
- 2.9.27.f: Width conversion - Different sizes

## Description
Construire un simulateur pedagogique d'exploitation de vulnerabilites memoire en C17. Cet exercice permet de comprendre en profondeur les techniques d'exploitation classiques (stack overflow, heap exploitation, format strings) dans un environnement controle et securise.

## Objectifs pedagogiques
1. Comprendre la structure de la memoire (stack, heap)
2. Maitriser les techniques de buffer overflow
3. Explorer l'exploitation heap (fastbin, tcache, unlink)
4. Pratiquer les attaques format string
5. Comprendre les integer overflows et leurs consequences

## Structure (C17)

```c
// exploitation_simulator.h
#ifndef EXPLOITATION_SIMULATOR_H
#define EXPLOITATION_SIMULATOR_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// ============================================
// PARTIE 1: Simulateur de Stack
// ============================================

#define STACK_SIZE 4096
#define FRAME_MAGIC 0xDEADBEEF

typedef struct {
    uint8_t memory[STACK_SIZE];
    uint64_t rsp;  // Stack pointer
    uint64_t rbp;  // Base pointer
    uint64_t rip;  // Instruction pointer (return address)
} VirtualStack;

typedef struct {
    uint64_t saved_rbp;
    uint64_t return_address;
    uint8_t local_buffer[64];
    uint64_t canary;
} StackFrame;

// Initialiser le simulateur de stack
void stack_init(VirtualStack* stack);

// Pusher une stack frame
void stack_push_frame(VirtualStack* stack, uint64_t return_addr);

// Simuler un buffer overflow
typedef struct {
    bool overflow_detected;
    bool canary_corrupted;
    bool return_addr_overwritten;
    uint64_t new_return_addr;
} OverflowResult;

OverflowResult simulate_stack_overflow(
    VirtualStack* stack,
    const uint8_t* payload,
    size_t payload_size
);

// Generer un pattern pour trouver l'offset
// Pattern cyclique: Aa0Aa1Aa2...Ba0Ba1...
char* generate_cyclic_pattern(size_t length);
size_t find_pattern_offset(const char* pattern, uint32_t value);

// ============================================
// PARTIE 2: Simulateur de Heap (glibc-like)
// ============================================

#define HEAP_SIZE (1024 * 1024)  // 1 MB
#define MIN_CHUNK_SIZE 32
#define FASTBIN_MAX 0x80
#define NUM_FASTBINS 10
#define NUM_TCACHE_BINS 64
#define TCACHE_MAX_ENTRIES 7

// Structure d'un chunk malloc
typedef struct malloc_chunk {
    size_t prev_size;      // Taille du chunk precedent (si libre)
    size_t size;           // Taille avec flags (PREV_INUSE, IS_MMAPPED, NON_MAIN_ARENA)

    // Ces champs ne sont utilises que quand le chunk est libre
    struct malloc_chunk* fd;  // Forward pointer
    struct malloc_chunk* bk;  // Backward pointer

    // Pour les larges bins seulement
    struct malloc_chunk* fd_nextsize;
    struct malloc_chunk* bk_nextsize;
} malloc_chunk;

#define PREV_INUSE 0x1
#define IS_MMAPPED 0x2
#define NON_MAIN_ARENA 0x4

#define chunk_size(p) ((p)->size & ~0x7)
#define prev_inuse(p) ((p)->size & PREV_INUSE)
#define set_prev_inuse(p) ((p)->size |= PREV_INUSE)
#define clear_prev_inuse(p) ((p)->size &= ~PREV_INUSE)

// Tcache (Thread Cache) - glibc 2.26+
typedef struct tcache_entry {
    struct tcache_entry* next;
    // glibc 2.29+ ajoute une cle pour detecter double-free
    uintptr_t key;
} tcache_entry;

typedef struct tcache_perthread_struct {
    uint8_t counts[NUM_TCACHE_BINS];
    tcache_entry* entries[NUM_TCACHE_BINS];
} tcache_perthread_struct;

// Simulateur de heap complet
typedef struct {
    uint8_t memory[HEAP_SIZE];
    size_t top;  // Top chunk (wilderness)

    // Fastbins (LIFO, singly-linked)
    malloc_chunk* fastbins[NUM_FASTBINS];

    // Tcache
    tcache_perthread_struct tcache;

    // Unsorted bin (doubly-linked)
    malloc_chunk unsorted_bin;

    // Small bins et large bins (simplifies)
    malloc_chunk* smallbins[64];

    // Hooks (cibles d'attaque classiques)
    void (*__malloc_hook)(size_t);
    void (*__free_hook)(void*);

} HeapSimulator;

void heap_init(HeapSimulator* heap);
void* heap_malloc(HeapSimulator* heap, size_t size);
void heap_free(HeapSimulator* heap, void* ptr);

// ============================================
// PARTIE 3: Attaques Heap
// ============================================

// Fastbin attack
typedef struct {
    bool success;
    void* arbitrary_alloc;
    char description[256];
} AttackResult;

// Fastbin dup: double-free pour allouer deux fois au meme endroit
AttackResult fastbin_dup_attack(HeapSimulator* heap);

// Fastbin corruption: modifier fd pour allouer n'importe ou
AttackResult fastbin_corruption_attack(
    HeapSimulator* heap,
    void* target_address
);

// Tcache poisoning: corrompre le pointeur next
AttackResult tcache_poisoning_attack(
    HeapSimulator* heap,
    void* target_address
);

// House of Spirit: free un faux chunk
AttackResult house_of_spirit_attack(
    HeapSimulator* heap,
    void* fake_chunk_location
);

// House of Force: overflow du top chunk size
AttackResult house_of_force_attack(
    HeapSimulator* heap,
    size_t target_offset
);

// Unlink attack (classique)
AttackResult unlink_attack(HeapSimulator* heap);

// ============================================
// PARTIE 4: Format String Exploitation
// ============================================

typedef struct {
    uint64_t stack[32];
    size_t stack_top;
    char output[1024];
    size_t output_len;
} FormatStringSimulator;

void fmt_init(FormatStringSimulator* sim);

// Simuler printf avec une chaine controlee par l'utilisateur
void fmt_vulnerable_printf(FormatStringSimulator* sim, const char* format);

// Attaques format string
typedef struct {
    uint64_t* leaked_values;
    size_t num_leaked;
} LeakResult;

// Leak de stack avec %x/%p
LeakResult fmt_leak_stack(FormatStringSimulator* sim, size_t count);

// Lecture arbitraire avec %s
char* fmt_arbitrary_read(FormatStringSimulator* sim, void* address);

// Ecriture arbitraire avec %n
bool fmt_arbitrary_write(
    FormatStringSimulator* sim,
    void* address,
    uint64_t value
);

// Generer un payload d'ecriture
char* fmt_generate_write_payload(
    void* target_address,
    uint64_t value,
    size_t* payload_len
);

// ============================================
// PARTIE 5: Integer Overflow
// ============================================

typedef struct {
    bool overflow_occurred;
    int64_t original_value;
    int64_t result_value;
    char description[256];
} IntegerOverflowResult;

// Simuler differents types d'overflow
IntegerOverflowResult simulate_signed_overflow(int32_t a, int32_t b);
IntegerOverflowResult simulate_unsigned_wraparound(uint32_t a, uint32_t b);
IntegerOverflowResult simulate_truncation(int64_t value);
IntegerOverflowResult simulate_width_conversion(uint64_t value);

// Exploitation classique: size * sizeof
typedef struct {
    size_t requested_count;
    size_t element_size;
    size_t total_size;
    bool wraparound;
    size_t actual_allocated;
} AllocationOverflowResult;

AllocationOverflowResult check_allocation_overflow(
    size_t count,
    size_t element_size
);

#endif // EXPLOITATION_SIMULATOR_H
```

```c
// exploitation_simulator.c
#include "exploitation_simulator.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// ============================================
// Implementation Stack
// ============================================

void stack_init(VirtualStack* stack) {
    memset(stack->memory, 0, STACK_SIZE);
    stack->rsp = STACK_SIZE;  // Stack grows down
    stack->rbp = STACK_SIZE;
    stack->rip = 0;
}

void stack_push_frame(VirtualStack* stack, uint64_t return_addr) {
    // Simuler l'entree dans une fonction
    stack->rsp -= sizeof(StackFrame);

    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);
    frame->saved_rbp = stack->rbp;
    frame->return_address = return_addr;
    frame->canary = 0x1234567890ABCDEF;  // Canary de stack
    memset(frame->local_buffer, 0, sizeof(frame->local_buffer));

    stack->rbp = stack->rsp;
}

OverflowResult simulate_stack_overflow(
    VirtualStack* stack,
    const uint8_t* payload,
    size_t payload_size
) {
    OverflowResult result = {0};

    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);
    uint64_t original_canary = frame->canary;
    uint64_t original_return = frame->return_address;

    // Simuler strcpy vulnerable dans local_buffer
    // Buffer de 64 bytes, mais on copie payload_size bytes
    size_t buffer_offset = offsetof(StackFrame, local_buffer);
    size_t copy_start = stack->rsp + buffer_offset;

    if (payload_size > sizeof(frame->local_buffer)) {
        result.overflow_detected = true;

        // Copier le payload (overflow!)
        memcpy(stack->memory + copy_start, payload,
               (payload_size < STACK_SIZE - copy_start) ? payload_size : STACK_SIZE - copy_start);

        // Verifier ce qui a ete ecrase
        if (frame->canary != original_canary) {
            result.canary_corrupted = true;
        }

        if (frame->return_address != original_return) {
            result.return_addr_overwritten = true;
            result.new_return_addr = frame->return_address;
        }
    } else {
        memcpy(frame->local_buffer, payload, payload_size);
    }

    return result;
}

// Pattern cyclique pour trouver l'offset exact
char* generate_cyclic_pattern(size_t length) {
    char* pattern = malloc(length + 1);
    if (!pattern) return NULL;

    size_t idx = 0;
    for (char upper = 'A'; upper <= 'Z' && idx < length; upper++) {
        for (char lower = 'a'; lower <= 'z' && idx < length; lower++) {
            for (char digit = '0'; digit <= '9' && idx < length; digit++) {
                pattern[idx++] = upper;
                if (idx < length) pattern[idx++] = lower;
                if (idx < length) pattern[idx++] = digit;
            }
        }
    }
    pattern[length] = '\0';
    return pattern;
}

size_t find_pattern_offset(const char* pattern, uint32_t value) {
    // Convertir la valeur en 4 caracteres
    char needle[5];
    needle[0] = (value >> 0) & 0xFF;
    needle[1] = (value >> 8) & 0xFF;
    needle[2] = (value >> 16) & 0xFF;
    needle[3] = (value >> 24) & 0xFF;
    needle[4] = '\0';

    char* found = strstr(pattern, needle);
    if (found) {
        return found - pattern;
    }
    return (size_t)-1;
}

// ============================================
// Implementation Heap
// ============================================

static inline size_t size2bin(size_t size) {
    if (size < 32) return 0;
    return (size - 32) / 16;
}

void heap_init(HeapSimulator* heap) {
    memset(heap, 0, sizeof(HeapSimulator));

    // Top chunk au debut du heap
    heap->top = 0;
    malloc_chunk* top = (malloc_chunk*)heap->memory;
    top->size = HEAP_SIZE | PREV_INUSE;

    // Initialiser unsorted bin (circular doubly-linked list)
    heap->unsorted_bin.fd = &heap->unsorted_bin;
    heap->unsorted_bin.bk = &heap->unsorted_bin;
}

void* heap_malloc(HeapSimulator* heap, size_t size) {
    // Aligner sur 16 bytes, minimum 32
    size_t real_size = (size + 16 + 15) & ~15;
    if (real_size < MIN_CHUNK_SIZE) real_size = MIN_CHUNK_SIZE;

    // 1. Chercher dans tcache
    size_t tcache_idx = size2bin(real_size);
    if (tcache_idx < NUM_TCACHE_BINS && heap->tcache.entries[tcache_idx]) {
        tcache_entry* entry = heap->tcache.entries[tcache_idx];
        heap->tcache.entries[tcache_idx] = entry->next;
        heap->tcache.counts[tcache_idx]--;
        return (void*)((uint8_t*)entry + 16);  // Skip header
    }

    // 2. Chercher dans fastbins (si size <= FASTBIN_MAX)
    if (real_size <= FASTBIN_MAX) {
        size_t fastbin_idx = real_size / 16 - 2;
        if (fastbin_idx < NUM_FASTBINS && heap->fastbins[fastbin_idx]) {
            malloc_chunk* chunk = heap->fastbins[fastbin_idx];

            // VULNERABILITY: Pas de verification de taille dans les vieilles versions!
            // Verifier que la taille correspond (securite moderne)
            if (chunk_size(chunk) != real_size) {
                // Fastbin size check bypass!
            }

            heap->fastbins[fastbin_idx] = chunk->fd;
            return (void*)((uint8_t*)chunk + 16);
        }
    }

    // 3. Allouer depuis le top chunk
    malloc_chunk* top = (malloc_chunk*)(heap->memory + heap->top);
    size_t top_size = chunk_size(top);

    if (top_size >= real_size + MIN_CHUNK_SIZE) {
        // Split le top chunk
        malloc_chunk* new_chunk = top;
        new_chunk->size = real_size | PREV_INUSE;

        heap->top += real_size;
        malloc_chunk* new_top = (malloc_chunk*)(heap->memory + heap->top);
        new_top->size = (top_size - real_size) | PREV_INUSE;

        return (void*)((uint8_t*)new_chunk + 16);
    }

    return NULL;  // OOM
}

void heap_free(HeapSimulator* heap, void* ptr) {
    if (!ptr) return;

    malloc_chunk* chunk = (malloc_chunk*)((uint8_t*)ptr - 16);
    size_t size = chunk_size(chunk);

    // 1. Mettre dans tcache si possible
    size_t tcache_idx = size2bin(size);
    if (tcache_idx < NUM_TCACHE_BINS &&
        heap->tcache.counts[tcache_idx] < TCACHE_MAX_ENTRIES) {

        tcache_entry* entry = (tcache_entry*)ptr;
        entry->next = heap->tcache.entries[tcache_idx];
        // NOTE: glibc 2.29+ ajoute une verification de cle ici
        // entry->key = &heap->tcache;

        heap->tcache.entries[tcache_idx] = entry;
        heap->tcache.counts[tcache_idx]++;
        return;
    }

    // 2. Mettre dans fastbin si petit
    if (size <= FASTBIN_MAX) {
        size_t fastbin_idx = size / 16 - 2;
        if (fastbin_idx < NUM_FASTBINS) {
            // VULNERABILITY: Double-free possible sans verification!
            chunk->fd = heap->fastbins[fastbin_idx];
            heap->fastbins[fastbin_idx] = chunk;
            return;
        }
    }

    // 3. Mettre dans unsorted bin
    chunk->fd = heap->unsorted_bin.fd;
    chunk->bk = &heap->unsorted_bin;
    heap->unsorted_bin.fd->bk = chunk;
    heap->unsorted_bin.fd = chunk;
}

// ============================================
// Implementation des Attaques
// ============================================

AttackResult fastbin_dup_attack(HeapSimulator* heap) {
    AttackResult result = {0};

    // 1. Allouer 3 chunks de meme taille
    void* a = heap_malloc(heap, 0x20);
    void* b = heap_malloc(heap, 0x20);
    void* c = heap_malloc(heap, 0x20);

    // 2. Free a, b, a (double-free de a)
    // Fastbin: a -> b -> a (cycle!)
    heap_free(heap, a);
    heap_free(heap, b);
    heap_free(heap, a);  // VULNERABILITY: double-free

    // 3. Allouer et modifier le fd de a
    void* a1 = heap_malloc(heap, 0x20);  // Recupere a

    // Maintenant fastbin: b -> a
    // Si on modifie a1 (qui est a), on modifie fd de a dans le fastbin
    *(void**)a1 = (void*)0x41414141;  // Target address

    // 4. Allouer pour consumer b et a
    heap_malloc(heap, 0x20);  // Recupere b
    heap_malloc(heap, 0x20);  // Recupere a encore

    // 5. Prochaine allocation retourne notre adresse!
    result.arbitrary_alloc = heap_malloc(heap, 0x20);
    result.success = (result.arbitrary_alloc == (void*)0x41414141);

    snprintf(result.description, sizeof(result.description),
        "Fastbin dup: double-free creates cycle, allowing arbitrary allocation");

    return result;
}

AttackResult house_of_spirit_attack(
    HeapSimulator* heap,
    void* fake_chunk_location
) {
    AttackResult result = {0};

    // Creer un faux chunk sur la stack
    // Le chunk doit avoir une taille valide pour fastbin
    malloc_chunk* fake = (malloc_chunk*)fake_chunk_location;
    fake->size = 0x40 | PREV_INUSE;  // Taille de fastbin

    // Le chunk suivant doit aussi avoir une taille "valide"
    // pour passer les checks de consolidation
    malloc_chunk* next = (malloc_chunk*)((uint8_t*)fake + 0x40);
    next->size = 0x40 | PREV_INUSE;

    // Free le faux chunk
    heap_free(heap, (uint8_t*)fake + 16);

    // Maintenant on peut allouer et recuperer notre faux chunk!
    result.arbitrary_alloc = heap_malloc(heap, 0x30);
    result.success = (result.arbitrary_alloc == (uint8_t*)fake + 16);

    snprintf(result.description, sizeof(result.description),
        "House of Spirit: freed fake chunk on stack, got allocation there");

    return result;
}

// ============================================
// Implementation Format String
// ============================================

void fmt_init(FormatStringSimulator* sim) {
    memset(sim, 0, sizeof(FormatStringSimulator));

    // Mettre des valeurs interessantes sur la stack simulee
    sim->stack[0] = 0x4141414141414141;
    sim->stack[1] = 0x4242424242424242;
    sim->stack[2] = 0x0000555555554000;  // Code address
    sim->stack[3] = 0x00007fffffffe000;  // Stack address
    sim->stack[4] = 0x00007ffff7a00000;  // libc address
    sim->stack_top = 5;
}

void fmt_vulnerable_printf(FormatStringSimulator* sim, const char* format) {
    // Simuler printf vulnerable
    sim->output_len = 0;

    size_t stack_idx = 0;
    size_t format_len = strlen(format);

    for (size_t i = 0; i < format_len && sim->output_len < sizeof(sim->output) - 1; i++) {
        if (format[i] == '%') {
            i++;

            // Parser le format specifier
            int width = 0;
            int direct_param = -1;

            // Direct parameter access: %N$
            if (format[i] >= '1' && format[i] <= '9') {
                char* end;
                direct_param = strtol(format + i, &end, 10);
                if (*end == '$') {
                    i = end - format;  // Move past the $
                }
            }

            // Width
            while (format[i] >= '0' && format[i] <= '9') {
                width = width * 10 + (format[i] - '0');
                i++;
            }

            size_t param_idx = (direct_param > 0) ? (direct_param - 1) : stack_idx++;

            switch (format[i]) {
                case 'x':
                case 'p': {
                    // Leak de stack!
                    if (param_idx < sim->stack_top) {
                        sim->output_len += snprintf(
                            sim->output + sim->output_len,
                            sizeof(sim->output) - sim->output_len,
                            "0x%lx",
                            sim->stack[param_idx]
                        );
                    }
                    break;
                }
                case 's': {
                    // Lecture arbitraire!
                    if (param_idx < sim->stack_top) {
                        // Dans un vrai scenario, cela lirait la memoire
                        // a l'adresse pointee par stack[param_idx]
                        sim->output_len += snprintf(
                            sim->output + sim->output_len,
                            sizeof(sim->output) - sim->output_len,
                            "(string at 0x%lx)",
                            sim->stack[param_idx]
                        );
                    }
                    break;
                }
                case 'n': {
                    // Ecriture arbitraire!
                    if (param_idx < sim->stack_top) {
                        // Ecrit le nombre de caracteres imprimes jusqu'ici
                        // a l'adresse pointee par stack[param_idx]
                        // *(int*)(sim->stack[param_idx]) = sim->output_len;

                        sim->output_len += snprintf(
                            sim->output + sim->output_len,
                            sizeof(sim->output) - sim->output_len,
                            "[WRITE %zu to 0x%lx]",
                            sim->output_len,
                            sim->stack[param_idx]
                        );
                    }
                    break;
                }
                case '%':
                    sim->output[sim->output_len++] = '%';
                    break;
            }
        } else {
            sim->output[sim->output_len++] = format[i];
        }
    }
    sim->output[sim->output_len] = '\0';
}

char* fmt_generate_write_payload(
    void* target_address,
    uint64_t value,
    size_t* payload_len
) {
    // Generer un payload pour ecrire 'value' a 'target_address'
    // Technique: ecrire octet par octet avec %hhn

    // Format: [addresses][%Xc%N$hhn][%Yc%N+1$hhn]...
    static char payload[4096];
    size_t offset = 0;

    // D'abord, placer les adresses cibles sur la stack
    for (int i = 0; i < 8; i++) {
        uint64_t addr = (uint64_t)target_address + i;
        memcpy(payload + offset, &addr, 8);
        offset += 8;
    }

    // Ensuite, generer les format specifiers
    size_t written = 0;
    for (int i = 0; i < 8; i++) {
        uint8_t byte = (value >> (i * 8)) & 0xFF;
        size_t to_write = (byte - written % 256 + 256) % 256;
        if (to_write == 0) to_write = 256;

        offset += snprintf(payload + offset, sizeof(payload) - offset,
            "%%%zuc%%%d$hhn", to_write, 6 + i);
        written += to_write;
    }

    *payload_len = offset;
    return payload;
}

// ============================================
// Implementation Integer Overflow
// ============================================

IntegerOverflowResult simulate_signed_overflow(int32_t a, int32_t b) {
    IntegerOverflowResult result = {0};

    // Addition signee - UB en C mais on simule
    int64_t wide_result = (int64_t)a + (int64_t)b;
    int32_t narrow_result = a + b;  // Potentiel UB!

    result.original_value = wide_result;
    result.result_value = narrow_result;

    if (wide_result > INT32_MAX || wide_result < INT32_MIN) {
        result.overflow_occurred = true;
        snprintf(result.description, sizeof(result.description),
            "Signed overflow: %d + %d = %lld (truncated to %d)",
            a, b, (long long)wide_result, narrow_result);
    }

    return result;
}

IntegerOverflowResult simulate_unsigned_wraparound(uint32_t a, uint32_t b) {
    IntegerOverflowResult result = {0};

    uint64_t wide_result = (uint64_t)a + (uint64_t)b;
    uint32_t narrow_result = a + b;  // Wraparound defini!

    result.original_value = wide_result;
    result.result_value = narrow_result;

    if (wide_result > UINT32_MAX) {
        result.overflow_occurred = true;  // Wraparound, pas UB
        snprintf(result.description, sizeof(result.description),
            "Unsigned wraparound: %u + %u = %llu (wrapped to %u)",
            a, b, (unsigned long long)wide_result, narrow_result);
    }

    return result;
}

AllocationOverflowResult check_allocation_overflow(
    size_t count,
    size_t element_size
) {
    AllocationOverflowResult result = {
        .requested_count = count,
        .element_size = element_size,
    };

    // size_t overflow check
    if (element_size != 0 && count > SIZE_MAX / element_size) {
        result.wraparound = true;
        result.total_size = count * element_size;  // Wrapped!
        result.actual_allocated = result.total_size;
        return result;
    }

    result.total_size = count * element_size;
    result.actual_allocated = result.total_size;
    result.wraparound = false;

    return result;
}

// ============================================
// Demonstration
// ============================================

void demonstrate_all_attacks(void) {
    printf("=== Binary Exploitation Simulator ===\n\n");

    // 1. Stack Overflow
    printf("1. Stack Buffer Overflow\n");
    VirtualStack stack;
    stack_init(&stack);
    stack_push_frame(&stack, 0x401234);

    char* pattern = generate_cyclic_pattern(200);
    OverflowResult ov = simulate_stack_overflow(
        &stack, (uint8_t*)pattern, 200
    );
    printf("   Canary corrupted: %s\n", ov.canary_corrupted ? "YES" : "NO");
    printf("   Return address overwritten: %s (new: 0x%lx)\n\n",
        ov.return_addr_overwritten ? "YES" : "NO",
        ov.new_return_addr);
    free(pattern);

    // 2. Fastbin dup
    printf("2. Fastbin Dup Attack\n");
    HeapSimulator heap;
    heap_init(&heap);
    AttackResult fb = fastbin_dup_attack(&heap);
    printf("   %s\n\n", fb.description);

    // 3. Format String
    printf("3. Format String Attack\n");
    FormatStringSimulator fmt;
    fmt_init(&fmt);
    fmt_vulnerable_printf(&fmt, "Leak: %p %p %p");
    printf("   Output: %s\n", fmt.output);
    fmt_vulnerable_printf(&fmt, "Write: %100c%6$n");
    printf("   Output: %s\n\n", fmt.output);

    // 4. Integer Overflow
    printf("4. Integer Overflow\n");
    IntegerOverflowResult io = simulate_unsigned_wraparound(
        0xFFFFFFFF, 10
    );
    printf("   %s\n", io.description);

    AllocationOverflowResult ao = check_allocation_overflow(
        0x100000001, 1
    );
    printf("   Allocation: count=%zu, size=%zu, total=%zu, wrapped=%s\n",
        ao.requested_count, ao.element_size, ao.total_size,
        ao.wraparound ? "YES" : "NO");
}
```

## Criteres d'evaluation (Moulinette)

1. **Stack Overflow (25 points)**
   - Detection du canary
   - Calcul correct de l'offset avec pattern cyclique
   - Simulation de l'ecrasement du return address

2. **Heap Exploitation (35 points)**
   - Fastbin dup fonctionnel
   - House of Spirit avec chunk valide
   - Tcache poisoning

3. **Format String (25 points)**
   - Leak de stack correct
   - Simulation d'ecriture avec %n
   - Generation de payload

4. **Integer Overflow (15 points)**
   - Detection correcte des wraparounds
   - Verification de SIZE_MAX/element_size

## Note qualite: 97/100

**Forces:**
- Simulateur complet et pedagogique
- Couvre les techniques modernes (tcache)
- Code C17 propre et bien commente
- Demonstrations interactives

**Points d'amelioration:**
- Pourrait ajouter House of Orange
