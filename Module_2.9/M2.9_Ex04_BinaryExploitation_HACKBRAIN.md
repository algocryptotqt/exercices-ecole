# Exercice 2.9.4-synth : prison_break_simulator

**Module :**
2.9 â€” Exploitation de Binaires et Vulnerabilites Memoire

**Concept :**
synth â€” Stack Overflow, Heap Exploitation, Format String, Integer Overflow

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
complet

**Tiers :**
3 â€” Synthese (concepts 2.9.16 + 2.9.17 + 2.9.18 + 2.9.19 + 2.9.20 + 2.9.26 + 2.9.27)

**Langage :**
C17 / ASM x86_64

**Prerequis :**
- Gestion memoire avancee (malloc, free, heap internals)
- Architecture x86_64 (registres, calling conventions)
- Pointeurs et arithmetique des pointeurs
- Representation binaire et hexadecimale
- Structures de donnees (listes chainees)

**Domaines :**
Mem, CPU, ASM, Crypto, Struct

**Duree estimee :**
480 min (8h)

**XP Base :**
500

**Complexite :**
T8 O(n) x S7 O(n)

---

## SECTION 2.4.1 : ANALOGIE PRISON BREAK â€” L'Evasion Parfaite

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   ğŸ”“ PRISON BREAK : L'ANATOMIE D'UNE EVASION NUMERIQUE                     â”‚
â”‚                                                                             â”‚
â”‚   Imagine que la memoire d'un programme est une PRISON DE HAUTE SECURITE.  â”‚
â”‚   Ton objectif : t'evader en exploitant les failles du systeme.            â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Le Mapping Parfait : Prison â†” Exploitation Binaire

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  PRISON BREAK                    â”‚  EXPLOITATION BINAIRE                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸ° LES MURS DE LA CELLULE       â”‚  ğŸ“¦ BUFFER (zone memoire limitee)         â•‘
â•‘  Ta cellule a des dimensions     â”‚  Un buffer a une taille fixe.             â•‘
â•‘  fixes. Tu ne peux pas           â”‚  Tu ne devrais pas pouvoir ecrire         â•‘
â•‘  normalement en sortir.          â”‚  au-dela de ses limites.                  â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  â›ï¸ CREUSER UN TUNNEL            â”‚  ğŸ’¥ BUFFER OVERFLOW                       â•‘
â•‘  Tu creuses SOUS les murs,       â”‚  Tu ecris AU-DELA du buffer,              â•‘
â•‘  depassant les limites           â”‚  ecrasant la memoire adjacente            â•‘
â•‘  supposees de ta cellule.        â”‚  (saved RBP, return address).             â•‘
â•‘                                  â”‚                                           â•‘
â•‘  "Si le mur fait 3m, je creuse   â”‚  "Si le buffer fait 64 bytes,             â•‘
â•‘   a 4m de profondeur."           â”‚   j'ecris 80 bytes."                      â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸš¨ L'ALARME SILENCIEUSE         â”‚  ğŸ¤ STACK CANARY                          â•‘
â•‘  Un fil invisible tendu dans     â”‚  Une valeur secrete placee avant          â•‘
â•‘  le tunnel. Si tu le touches,    â”‚  l'adresse de retour. Si elle change,     â•‘
â•‘  l'alarme se declenche.          â”‚  le programme detecte l'attaque.          â•‘
â•‘                                  â”‚                                           â•‘
â•‘  SOLUTION: Decouvrir ou se       â”‚  SOLUTION: Leaker le canary puis          â•‘
â•‘  trouve le fil et l'enjamber.    â”‚  le reecrire avec sa vraie valeur.        â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸ‘® GARDES QUI CHANGENT          â”‚  ğŸ² ASLR (Address Space Layout            â•‘
â•‘      DE POSITION                 â”‚       Randomization)                      â•‘
â•‘  Les gardes patrouillent de      â”‚  Les adresses memoire changent            â•‘
â•‘  facon aleatoire. Impossible     â”‚  a chaque execution. Impossible           â•‘
â•‘  de predire ou ils seront.       â”‚  de coder en dur une adresse.             â•‘
â•‘                                  â”‚                                           â•‘
â•‘  SOLUTION: Observer les          â”‚  SOLUTION: Leaker une adresse             â•‘
â•‘  patterns, trouver un timing.    â”‚  et calculer les autres relativement.     â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸ”§ UTILISER LES OUTILS          â”‚  â›“ï¸ ROP (Return-Oriented Programming)     â•‘
â•‘     DE LA PRISON                 â”‚                                           â•‘
â•‘  Tu n'as pas de pioche, mais     â”‚  Tu n'as pas de shellcode executable,     â•‘
â•‘  tu peux utiliser les outils     â”‚  mais tu peux enchainer des GADGETS       â•‘
â•‘  du gardien contre lui.          â”‚  (morceaux de code existants) pour        â•‘
â•‘                                  â”‚  construire ton attaque.                  â•‘
â•‘                                  â”‚                                           â•‘
â•‘  "La cle du gardien peut         â”‚  "pop rdi; ret" + "system@plt"            â•‘
â•‘   ouvrir MA cellule aussi."      â”‚   = execution de commande arbitraire      â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸ“œ LE PLAN D'EVASION            â”‚  ğŸ’‰ SHELLCODE                             â•‘
â•‘  Instructions detaillees         â”‚  Code machine injecte qui sera            â•‘
â•‘  ecrites sur du papier,          â”‚  execute par le processeur.               â•‘
â•‘  a suivre etape par etape.       â”‚  Chaque byte = une instruction.           â•‘
â•‘                                  â”‚                                           â•‘
â•‘  "1. Creuser a 22h               â”‚  "\x48\x31\xff"  # xor rdi, rdi           â•‘
â•‘   2. Sortir par le tuyau         â”‚  "\x48\x31\xf6"  # xor rsi, rsi           â•‘
â•‘   3. Courir vers le nord"        â”‚  "\x0f\x05"      # syscall                â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸ—£ï¸ MESSAGES CODES               â”‚  ğŸ“ FORMAT STRING ATTACK                  â•‘
â•‘  Tu utilises le systeme de       â”‚  Tu abuses de printf() pour               â•‘
â•‘  communication de la prison      â”‚  LIRE (%x, %s) ou ECRIRE (%n)             â•‘
â•‘  pour envoyer/recevoir des       â”‚  la memoire arbitrairement.               â•‘
â•‘  infos secretes.                 â”‚                                           â•‘
â•‘                                  â”‚                                           â•‘
â•‘  "Le message dit 'PAIN' mais     â”‚  printf(user_input) au lieu de            â•‘
â•‘   signifie 'Plan A Initie'."     â”‚  printf("%s", user_input)                 â•‘
â•‘                                  â”‚                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                  â”‚                                           â•‘
â•‘  ğŸ RATIONS MANIPULEES           â”‚  ğŸ”¢ INTEGER OVERFLOW                      â•‘
â•‘  Tu demandes "4 milliards + 1"   â”‚  Quand un entier depasse sa limite,       â•‘
â•‘  rations. Le compteur revient    â”‚  il "wraparound" a 0 ou negatif.          â•‘
â•‘  a 0, et tu recois TOUTES        â”‚  size_t overflow = allocation minuscule   â•‘
â•‘  les rations restantes.          â”‚  mais acces a toute la memoire.           â•‘
â•‘                                  â”‚                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### La Stack Frame : Ta Cellule de Prison

```
                    HAUTE ADRESSE (fond de la cellule)
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚        Arguments (argc, argv)   â”‚ â† Ce que tu recois
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚       RETURN ADDRESS ğŸ¯         â”‚ â† LA CIBLE ULTIME
                    â”‚   (ou tu retournes apres)       â”‚   (ou aller apres evasion)
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚        Saved RBP ğŸ“             â”‚ â† Le fil d'Ariane
                    â”‚   (base de la frame precedente) â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚        CANARY ğŸ¤                â”‚ â† L'ALARME SILENCIEUSE
                    â”‚   (valeur secrete anti-overflow)â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           RSP â†’    â”‚     local_buffer[64] ğŸ“¦        â”‚ â† TA CELLULE
                    â”‚   (ou tu es "enferme")          â”‚   (buffer vulnerable)
                    â”‚                                 â”‚
                    â”‚   â†‘ Direction de l'overflow â†‘   â”‚
                    â”‚   Tu "creuses" vers le haut     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    BASSE ADRESSE (entree de la cellule)

    EVASION REUSSIE:
    1. Remplir local_buffer (creuser le tunnel)
    2. Ecraser le canary avec sa vraie valeur (enjamber l'alarme)
    3. Ecraser saved_rbp (optionnel)
    4. Ecraser return_address avec l'adresse cible (sortir de prison!)
```

### Heap Exploitation : La Cour de Recreation

```
    LE HEAP : LA COUR OU LES PRISONNIERS CIRCULENT

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         HEAP MEMORY                            â”‚
    â”‚                                                                â”‚
    â”‚  TCACHE (File d'attente rapide - LIFO)                        â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”                               â”‚
    â”‚  â”‚Chunk â”‚â”€â”€â†’â”‚Chunk â”‚â”€â”€â†’â”‚Chunk â”‚â”€â”€â†’ NULL                       â”‚
    â”‚  â”‚  A   â”‚   â”‚  B   â”‚   â”‚  C   â”‚                               â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜                               â”‚
    â”‚  â†‘                                                             â”‚
    â”‚  entries[idx]                                                  â”‚
    â”‚                                                                â”‚
    â”‚  FASTBIN (File simple - LIFO, pas de coalescing)              â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”                                          â”‚
    â”‚  â”‚Chunk â”‚â”€â”€â†’â”‚Chunk â”‚â”€â”€â†’ NULL                                  â”‚
    â”‚  â”‚  D   â”‚   â”‚  E   â”‚                                          â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
    â”‚                                                                â”‚
    â”‚  TOP CHUNK (Wilderness - le reste de la cour)                 â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
    â”‚  â”‚                                            â”‚               â”‚
    â”‚  â”‚     Espace non alloue (wilderness)         â”‚               â”‚
    â”‚  â”‚                                            â”‚               â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ATTAQUE FASTBIN DUP (Le Double-Agent):

    1. free(A)  â†’ Fastbin: A â†’ NULL
    2. free(B)  â†’ Fastbin: B â†’ A â†’ NULL
    3. free(A)  â†’ Fastbin: A â†’ B â†’ A (CYCLE!)  â† Double-free!

    4. malloc() retourne A, on ecrit une fausse adresse
    5. malloc() retourne B
    6. malloc() retourne A (encore!)
    7. malloc() retourne... NOTRE ADRESSE CIBLE!

    C'est comme donner un faux badge a un prisonnier qui peut
    maintenant acceder a n'importe quelle zone de la prison.
```

---

## SECTION 2.4.2 : ENONCE ACADEMIQUE

### Description Technique

Cet exercice consiste a implementer un **simulateur pedagogique d'exploitation de vulnerabilites memoire**. Le simulateur permet de comprendre et experimenter en environnement controle les techniques d'exploitation classiques :

1. **Stack Buffer Overflow** : Debordement de buffer sur la pile pour ecraser l'adresse de retour
2. **Heap Exploitation** : Manipulation des structures internes de l'allocateur (fastbin, tcache)
3. **Format String Attack** : Exploitation de printf() pour lire/ecrire la memoire
4. **Integer Overflow** : Exploitation des depassements d'entiers pour causer des comportements inattendus

Le code C17 fourni implemente :
- Un simulateur de stack avec detection de canary et overwrite
- Un simulateur de heap compatible glibc (fastbin, tcache, unsorted bin)
- Un simulateur de format string avec %x, %s, %n
- Des fonctions de detection d'integer overflow

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`exploitation_simulator.c` et `exploitation_simulator.h`

**Fonctions autorisees :**
- `malloc`, `free`, `realloc`
- `memset`, `memcpy`, `memmove`
- `strlen`, `strcpy`, `strncpy`, `strstr`
- `snprintf`, `printf`
- `strtol`, `strtoul`

**Fonctions interdites :**
- `system`, `exec*`, `popen` (securite)
- `gets` (deprecated et dangereuse)
- Toute fonction d'assembleur inline non documentee

### 1.2 Consigne

**PRISON BREAK : Simulateur d'Evasion Numerique**

Tu es un chercheur en securite qui doit former la prochaine generation de "red teamers". Pour cela, tu dois creer un **simulateur pedagogique** qui permet de comprendre les techniques d'exploitation sans risquer de compromettre de vrais systemes.

**Ta mission :**

Implementer un ensemble de modules simulant :

1. **Module Stack** : Simuler une stack avec frames, canary, et overflow
2. **Module Heap** : Simuler un allocateur glibc-like (fastbin, tcache)
3. **Module Format String** : Simuler printf vulnerable
4. **Module Integer** : Detecter et simuler les overflows

**Entree :**
- Structures simulant la memoire (VirtualStack, HeapSimulator, FormatStringSimulator)
- Payloads d'attaque a tester

**Sortie :**
- Resultats d'exploitation (succes/echec)
- Informations sur ce qui a ete corrompu
- Visualisation de l'etat memoire

**Contraintes :**
- Le simulateur doit etre SECURISE (pas d'exploitation reelle)
- Chaque attaque doit etre documentee dans le code
- Les verifications de securite doivent etre explicites
- Code C17 strict avec `-Wall -Wextra -Werror -std=c17`

**Exemples :**

| Fonction | Input | Output | Explication |
|----------|-------|--------|-------------|
| `simulate_stack_overflow()` | payload 80 bytes, buffer 64 | `{overflow: true, canary_corrupted: true, ret_overwritten: true}` | Overflow detecte |
| `find_pattern_offset()` | pattern, 0x41306141 | 0 | Offset trouve au debut |
| `fastbin_dup_attack()` | heap simulator | `{success: true, arbitrary_alloc: 0x41414141}` | Double-free reussi |
| `fmt_leak_stack()` | "%p %p %p" | Adresses de la stack | Leak reussi |

### 1.3 Prototype

```c
// ============================================
// PARTIE 1: Simulateur de Stack
// ============================================

typedef struct {
    uint8_t memory[STACK_SIZE];
    uint64_t rsp;
    uint64_t rbp;
    uint64_t rip;
} VirtualStack;

typedef struct {
    bool overflow_detected;
    bool canary_corrupted;
    bool return_addr_overwritten;
    uint64_t new_return_addr;
} OverflowResult;

void stack_init(VirtualStack* stack);
void stack_push_frame(VirtualStack* stack, uint64_t return_addr);
OverflowResult simulate_stack_overflow(VirtualStack* stack, const uint8_t* payload, size_t payload_size);
char* generate_cyclic_pattern(size_t length);
size_t find_pattern_offset(const char* pattern, uint32_t value);

// ============================================
// PARTIE 2: Simulateur de Heap
// ============================================

typedef struct {
    uint8_t memory[HEAP_SIZE];
    size_t top;
    malloc_chunk* fastbins[NUM_FASTBINS];
    tcache_perthread_struct tcache;
    malloc_chunk unsorted_bin;
    void (*__malloc_hook)(size_t);
    void (*__free_hook)(void*);
} HeapSimulator;

void heap_init(HeapSimulator* heap);
void* heap_malloc(HeapSimulator* heap, size_t size);
void heap_free(HeapSimulator* heap, void* ptr);

// ============================================
// PARTIE 3: Attaques Heap
// ============================================

typedef struct {
    bool success;
    void* arbitrary_alloc;
    char description[256];
} AttackResult;

AttackResult fastbin_dup_attack(HeapSimulator* heap);
AttackResult tcache_poisoning_attack(HeapSimulator* heap, void* target_address);
AttackResult house_of_spirit_attack(HeapSimulator* heap, void* fake_chunk_location);

// ============================================
// PARTIE 4: Format String
// ============================================

typedef struct {
    uint64_t stack[32];
    size_t stack_top;
    char output[1024];
    size_t output_len;
} FormatStringSimulator;

void fmt_init(FormatStringSimulator* sim);
void fmt_vulnerable_printf(FormatStringSimulator* sim, const char* format);
char* fmt_generate_write_payload(void* target_address, uint64_t value, size_t* payload_len);

// ============================================
// PARTIE 5: Integer Overflow
// ============================================

typedef struct {
    bool overflow_occurred;
    int64_t original_value;
    int64_t result_value;
    char description[256];
} IntegerOverflowResult;

IntegerOverflowResult simulate_signed_overflow(int32_t a, int32_t b);
IntegerOverflowResult simulate_unsigned_wraparound(uint32_t a, uint32_t b);
AllocationOverflowResult check_allocation_overflow(size_t count, size_t element_size);
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### Histoire : Le Morris Worm (1988)

Le **Morris Worm** fut le premier ver informatique a se propager sur Internet. Robert Tappan Morris, etudiant a Cornell, exploita un **buffer overflow dans fingerd** (service finger de BSD) pour executer du code arbitraire sur des machines distantes.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2 NOVEMBRE 1988 - LE JOUR OU INTERNET A FAILLI MOURIR          â”‚
â”‚                                                                 â”‚
â”‚  â€¢ 6000 machines infectees (10% d'Internet!)                    â”‚
â”‚  â€¢ Cout estime : 10-100 millions de dollars                     â”‚
â”‚  â€¢ Premiere condamnation sous le Computer Fraud Act             â”‚
â”‚  â€¢ Creation du CERT (Computer Emergency Response Team)          â”‚
â”‚                                                                 â”‚
â”‚  Le code exploitait gets() qui ne verifie pas la taille:        â”‚
â”‚                                                                 â”‚
â”‚  char buffer[512];                                              â”‚
â”‚  gets(buffer);  // VULNERABLE! Pas de limite de taille          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Anecdote : Pwn2Own et les Zero-Days

Chaque annee, le concours **Pwn2Own** offre des centaines de milliers de dollars pour des exploits de navigateurs et systemes d'exploitation. En 2021, un chercheur a gagne 200,000$ pour une chaine d'exploits Safari comprenant... un integer overflow et un heap overflow.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers utilisant ces concepts

| Metier | Cas d'usage | Techniques |
|--------|-------------|------------|
| **Pentester / Red Teamer** | Tests d'intrusion, audits securite | Toutes les techniques de l'exercice |
| **Vulnerability Researcher** | Decouverte de 0-days | Fuzzing, reverse engineering, exploitation |
| **Exploit Developer** | Ecriture d'exploits (ethique) | ROP chains, heap feng shui, shellcoding |
| **Malware Analyst** | Analyse de malwares | Comprendre les techniques pour les detecter |
| **Security Engineer** | Securisation de code | Connaitre les attaques pour s'en proteger |

### Exemples concrets

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HEARTBLEED (CVE-2014-0160) - Buffer Over-read                  â”‚
â”‚                                                                 â”‚
â”‚  â€¢ Vulnrabilite dans OpenSSL                                    â”‚
â”‚  â€¢ Permettait de lire 64KB de memoire serveur                   â”‚
â”‚  â€¢ Exposait cles privees, mots de passe, sessions               â”‚
â”‚  â€¢ 17% des serveurs HTTPS mondiaux vulnerables                  â”‚
â”‚                                                                 â”‚
â”‚  Technique: Le client envoie un "heartbeat" avec une taille     â”‚
â”‚  declaree superieure aux donnees reelles. Le serveur repond     â”‚
â”‚  avec la taille declaree, leakant sa memoire.                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SUDO CVE-2021-3156 (Baron Samedit) - Heap Overflow             â”‚
â”‚                                                                 â”‚
â”‚  â€¢ Vulnrabilite dans sudo presente depuis 2011                  â”‚
â”‚  â€¢ Permettait l'escalade de privileges vers root                â”‚
â”‚  â€¢ Affectait pratiquement tous les systemes Linux/Unix          â”‚
â”‚                                                                 â”‚
â”‚  Technique: Heap-based buffer overflow declenche par des        â”‚
â”‚  backslashes mal geres dans les arguments de sudoedit.          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
exploitation_simulator.c  exploitation_simulator.h  main.c

$ gcc -Wall -Wextra -Werror -std=c17 exploitation_simulator.c main.c -o exploit_sim

$ ./exploit_sim
=== Binary Exploitation Simulator ===

1. Stack Buffer Overflow
   Canary corrupted: YES
   Return address overwritten: YES (new: 0x41416d41)
   Offset found: 72 bytes

2. Fastbin Dup Attack
   Fastbin dup: double-free creates cycle, allowing arbitrary allocation
   Arbitrary allocation at: 0x41414141

3. Format String Attack
   Leak: 0x4141414141414141 0x4242424242424242 0x555555554000
   Write: [WRITE 100 to 0x7fffffffe000]

4. Integer Overflow
   Unsigned wraparound: 4294967295 + 10 = 4294967305 (wrapped to 9)
   Allocation: count=4294967297, size=1, total=1, wrapped=YES

All tests completed!
```

---

## SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
ğŸ§  (15/10)

**Recompense :**
XP x6

**Time Complexity attendue :**
O(n) pour la generation de ROP chain

**Space Complexity attendue :**
O(n) pour le stockage des gadgets

**Domaines Bonus :**
`ASM`, `Crypto`, `CPU`

### 3.1.1 Consigne Bonus

**PRISON BREAK NIVEAU 2 : L'Evasion de Haute Securite**

Les gardiens ont renforce la securite. ASLR est active, DEP/NX empeche l'execution de shellcode, et des canaries protegent chaque frame. Tu dois maintenant implementer :

1. **ROP Chain Generator** : Construire automatiquement des chaines ROP
2. **ASLR Bypass** : Leaker des adresses pour calculer la base
3. **Stack Pivot** : Changer RSP pour controler la stack

**Ta mission :**

Implementer un module `rop_chain_builder` qui :
- Parse un binaire pour extraire les gadgets
- Construit une chaine pour appeler `system("/bin/sh")`
- Gere le stack pivot si necessaire

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Gadgets disponibles seulement     â”‚
â”‚  dans le binaire cible             â”‚
â”‚  Pas de shellcode (NX actif)       â”‚
â”‚  ASLR actif (adresses relatives)   â”‚
â”‚  Canary a bypasser                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemples :**

| Appel | Retour | Explication |
|-------|--------|-------------|
| `find_gadget(binary, "pop rdi; ret")` | `0x401234` | Adresse du gadget |
| `build_rop_chain(gadgets, "/bin/sh")` | `[gadget1, binsh_addr, system_addr]` | Chaine complete |

### 3.1.2 Prototype Bonus

```c
typedef struct {
    uint64_t address;
    char* instructions;
    size_t size;
} RopGadget;

typedef struct {
    RopGadget* gadgets;
    size_t count;
    uint64_t base_address;
} GadgetCache;

GadgetCache* find_all_gadgets(const uint8_t* binary, size_t size);
uint64_t find_gadget(GadgetCache* cache, const char* pattern);
uint64_t* build_rop_chain(GadgetCache* cache, const char* command, size_t* chain_len);
bool execute_rop_chain(VirtualStack* stack, uint64_t* chain, size_t len);
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Protection | Canary seul | ASLR + DEP + Canary |
| Technique | Overflow simple | ROP chain complete |
| Cible | Return address | system("/bin/sh") |
| Complexite | O(1) payload | O(n) chain building |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points | Trap |
|------|-------------|--------|------|
| `test_stack_init` | Initialisation correcte | 5 | Non |
| `test_stack_overflow_canary` | Detection canary corrompu | 15 | Oui |
| `test_stack_overflow_ret` | Detection ret address ecrasee | 15 | Oui |
| `test_cyclic_pattern` | Generation pattern cyclique | 10 | Non |
| `test_find_offset` | Trouve offset exact | 10 | Oui |
| `test_heap_init` | Init heap simulator | 5 | Non |
| `test_heap_malloc_free` | Allocation/liberation | 10 | Non |
| `test_fastbin_dup` | Double-free detection | 15 | Oui |
| `test_tcache_poisoning` | Tcache attack | 15 | Oui |
| `test_fmt_leak` | Format string leak | 15 | Oui |
| `test_fmt_write` | Format string write | 15 | Oui |
| `test_integer_overflow` | Detection overflow | 10 | Oui |
| `test_allocation_wrap` | Wraparound allocation | 10 | Oui |
| **TOTAL** | | **150** | |

### 4.2 main.c de test

```c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "exploitation_simulator.h"

void test_stack_overflow(void) {
    printf("=== Test Stack Overflow ===\n");

    VirtualStack stack;
    stack_init(&stack);
    stack_push_frame(&stack, 0x401234);

    // Payload de 80 bytes pour overflow un buffer de 64
    uint8_t payload[80];
    memset(payload, 'A', 80);

    OverflowResult result = simulate_stack_overflow(&stack, payload, 80);

    assert(result.overflow_detected == true);
    printf("  Overflow detected: PASS\n");

    assert(result.canary_corrupted == true);
    printf("  Canary corrupted: PASS\n");

    assert(result.return_addr_overwritten == true);
    printf("  Return address overwritten: PASS\n");

    printf("  New return address: 0x%lx\n", result.new_return_addr);
}

void test_cyclic_pattern(void) {
    printf("\n=== Test Cyclic Pattern ===\n");

    char* pattern = generate_cyclic_pattern(100);
    assert(pattern != NULL);
    printf("  Pattern (first 20): %.20s\n", pattern);

    // "Aa0A" en little-endian = 0x41306141
    size_t offset = find_pattern_offset(pattern, 0x41306141);
    assert(offset == 0);
    printf("  Offset for 0x41306141: %zu (expected 0): PASS\n", offset);

    free(pattern);
}

void test_fastbin_dup(void) {
    printf("\n=== Test Fastbin Dup ===\n");

    HeapSimulator heap;
    heap_init(&heap);

    AttackResult result = fastbin_dup_attack(&heap);
    printf("  %s\n", result.description);
    printf("  Success: %s\n", result.success ? "PASS" : "FAIL");
}

void test_format_string(void) {
    printf("\n=== Test Format String ===\n");

    FormatStringSimulator fmt;
    fmt_init(&fmt);

    // Test leak
    fmt_vulnerable_printf(&fmt, "%p %p %p");
    printf("  Leak output: %s\n", fmt.output);

    // Test write
    fmt_vulnerable_printf(&fmt, "%100c%6$n");
    printf("  Write output: %s\n", fmt.output);
}

void test_integer_overflow(void) {
    printf("\n=== Test Integer Overflow ===\n");

    IntegerOverflowResult result = simulate_unsigned_wraparound(0xFFFFFFFF, 10);
    printf("  %s\n", result.description);
    assert(result.overflow_occurred == true);
    printf("  Wraparound detected: PASS\n");

    AllocationOverflowResult alloc = check_allocation_overflow(0x100000001, 1);
    printf("  Allocation wraparound: %s\n", alloc.wraparound ? "PASS" : "FAIL");
}

int main(void) {
    printf("=== Binary Exploitation Simulator Tests ===\n\n");

    test_stack_overflow();
    test_cyclic_pattern();
    test_fastbin_dup();
    test_format_string();
    test_integer_overflow();

    printf("\n=== All tests completed! ===\n");
    return 0;
}
```

### 4.3 Solution de reference

```c
// Voir le fichier source complet dans M2.9_Ex04_BinaryExploitation.md
// La solution de reference est l'implementation complete fournie

void stack_init(VirtualStack* stack) {
    if (stack == NULL)
        return;
    memset(stack->memory, 0, STACK_SIZE);
    stack->rsp = STACK_SIZE;
    stack->rbp = STACK_SIZE;
    stack->rip = 0;
}

void stack_push_frame(VirtualStack* stack, uint64_t return_addr) {
    if (stack == NULL)
        return;
    stack->rsp -= sizeof(StackFrame);
    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);
    frame->saved_rbp = stack->rbp;
    frame->return_address = return_addr;
    frame->canary = 0x1234567890ABCDEF;
    memset(frame->local_buffer, 0, sizeof(frame->local_buffer));
    stack->rbp = stack->rsp;
}

OverflowResult simulate_stack_overflow(
    VirtualStack* stack,
    const uint8_t* payload,
    size_t payload_size
) {
    OverflowResult result = {0};

    if (stack == NULL || payload == NULL)
        return result;

    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);
    uint64_t original_canary = frame->canary;
    uint64_t original_return = frame->return_address;

    size_t buffer_offset = offsetof(StackFrame, local_buffer);
    size_t copy_start = stack->rsp + buffer_offset;

    if (payload_size > sizeof(frame->local_buffer)) {
        result.overflow_detected = true;
        size_t max_copy = STACK_SIZE - copy_start;
        memcpy(stack->memory + copy_start, payload,
               (payload_size < max_copy) ? payload_size : max_copy);

        if (frame->canary != original_canary)
            result.canary_corrupted = true;

        if (frame->return_address != original_return) {
            result.return_addr_overwritten = true;
            result.new_return_addr = frame->return_address;
        }
    } else {
        memcpy(frame->local_buffer, payload, payload_size);
    }

    return result;
}

char* generate_cyclic_pattern(size_t length) {
    char* pattern = malloc(length + 1);
    if (pattern == NULL)
        return NULL;

    size_t idx = 0;
    for (char upper = 'A'; upper <= 'Z' && idx < length; upper++) {
        for (char lower = 'a'; lower <= 'z' && idx < length; lower++) {
            for (char digit = '0'; digit <= '9' && idx < length; digit++) {
                pattern[idx++] = upper;
                if (idx < length) pattern[idx++] = lower;
                if (idx < length) pattern[idx++] = digit;
            }
        }
    }
    pattern[length] = '\0';
    return pattern;
}

size_t find_pattern_offset(const char* pattern, uint32_t value) {
    if (pattern == NULL)
        return (size_t)-1;

    char needle[5];
    needle[0] = (value >> 0) & 0xFF;
    needle[1] = (value >> 8) & 0xFF;
    needle[2] = (value >> 16) & 0xFF;
    needle[3] = (value >> 24) & 0xFF;
    needle[4] = '\0';

    char* found = strstr(pattern, needle);
    if (found)
        return found - pattern;
    return (size_t)-1;
}
```

### 4.4 Solutions alternatives acceptees

```c
// Alternative 1: Utiliser des macros pour les offsets
#define CANARY_OFFSET (sizeof(uint64_t) * 2)
#define RET_OFFSET (sizeof(uint64_t))

// Alternative 2: Generer pattern avec rotation XOR
char* generate_cyclic_pattern_xor(size_t length) {
    char* pattern = malloc(length + 1);
    if (!pattern) return NULL;

    for (size_t i = 0; i < length; i++) {
        pattern[i] = 'A' + ((i ^ (i >> 4)) % 26);
    }
    pattern[length] = '\0';
    return pattern;
}
```

### 4.5 Solutions refusees (avec explications)

```c
// REFUSE 1: Pas de verification NULL
void stack_init_bad(VirtualStack* stack) {
    memset(stack->memory, 0, STACK_SIZE);  // CRASH si stack == NULL
    stack->rsp = STACK_SIZE;
}
// Pourquoi: Segfault sur pointeur NULL

// REFUSE 2: Buffer overflow non detecte
OverflowResult simulate_overflow_bad(VirtualStack* stack, const uint8_t* p, size_t s) {
    OverflowResult result = {0};
    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);
    memcpy(frame->local_buffer, p, s);  // Pas de verification de taille!
    return result;
}
// Pourquoi: Ne detecte pas l'overflow

// REFUSE 3: Pattern non unique
char* generate_pattern_bad(size_t length) {
    char* p = malloc(length + 1);
    memset(p, 'A', length);  // Pas de pattern unique!
    p[length] = '\0';
    return p;
}
// Pourquoi: Impossible de trouver l'offset avec un pattern non unique
```

### 4.6 Solution bonus de reference

```c
// ROP Chain Generator
typedef struct {
    uint64_t address;
    char instructions[64];
    size_t size;
} RopGadget;

typedef struct {
    RopGadget* gadgets;
    size_t count;
    size_t capacity;
    uint64_t base_address;
} GadgetCache;

// Patterns de gadgets communs
static const char* GADGET_PATTERNS[] = {
    "pop rdi; ret",
    "pop rsi; ret",
    "pop rdx; ret",
    "pop rax; ret",
    "syscall; ret",
    "ret",
    NULL
};

GadgetCache* find_all_gadgets(const uint8_t* binary, size_t size) {
    if (binary == NULL || size == 0)
        return NULL;

    GadgetCache* cache = malloc(sizeof(GadgetCache));
    if (!cache) return NULL;

    cache->capacity = 256;
    cache->gadgets = malloc(sizeof(RopGadget) * cache->capacity);
    cache->count = 0;
    cache->base_address = 0x400000;  // Adresse de base typique

    // Recherche des gadgets "ret" (0xC3)
    for (size_t i = 0; i < size; i++) {
        if (binary[i] == 0xC3) {  // ret
            // Verifier les bytes precedents pour des gadgets utiles
            // pop rdi = 0x5F, pop rsi = 0x5E, pop rdx = 0x5A
            if (i > 0 && binary[i-1] == 0x5F) {
                RopGadget* g = &cache->gadgets[cache->count++];
                g->address = cache->base_address + i - 1;
                strcpy(g->instructions, "pop rdi; ret");
                g->size = 2;
            }
            // ... autres gadgets
        }
    }

    return cache;
}

uint64_t find_gadget(GadgetCache* cache, const char* pattern) {
    if (cache == NULL || pattern == NULL)
        return 0;

    for (size_t i = 0; i < cache->count; i++) {
        if (strcmp(cache->gadgets[i].instructions, pattern) == 0)
            return cache->gadgets[i].address;
    }
    return 0;
}

uint64_t* build_rop_chain(GadgetCache* cache, const char* command, size_t* chain_len) {
    if (cache == NULL || command == NULL || chain_len == NULL)
        return NULL;

    // Chaine minimale pour system(command):
    // pop rdi; ret
    // &command
    // system@plt

    uint64_t pop_rdi = find_gadget(cache, "pop rdi; ret");
    if (pop_rdi == 0) return NULL;

    uint64_t* chain = malloc(sizeof(uint64_t) * 8);
    if (!chain) return NULL;

    size_t idx = 0;
    chain[idx++] = pop_rdi;
    chain[idx++] = (uint64_t)command;  // En realite, adresse dans le binaire
    chain[idx++] = 0x401050;  // system@plt (exemple)

    *chain_len = idx;
    return chain;
}
```

### 4.7 Solutions alternatives bonus

```c
// Alternative: Utiliser une table de hash pour les gadgets
typedef struct {
    uint64_t hash;
    uint64_t address;
} GadgetHashEntry;

uint64_t hash_gadget(const char* pattern) {
    uint64_t h = 5381;
    while (*pattern)
        h = ((h << 5) + h) + *pattern++;
    return h;
}
```

### 4.8 Solutions refusees bonus

```c
// REFUSE: Gadget hardcode sans recherche
uint64_t* build_chain_bad(void) {
    uint64_t* chain = malloc(24);
    chain[0] = 0x401234;  // Adresse hardcodee - ne marche pas avec ASLR!
    chain[1] = 0x402000;
    chain[2] = 0x401050;
    return chain;
}
// Pourquoi: Les adresses changent avec ASLR
```

### 4.9 spec.json

```json
{
  "name": "prison_break_simulator",
  "language": "c",
  "version": "c17",
  "type": "complet",
  "tier": 3,
  "tier_info": "Synthese (concepts 2.9.16-2.9.27)",
  "tags": ["exploitation", "security", "memory", "heap", "stack", "format-string"],
  "passing_score": 70,

  "function": {
    "name": "simulate_stack_overflow",
    "prototype": "OverflowResult simulate_stack_overflow(VirtualStack* stack, const uint8_t* payload, size_t payload_size)",
    "return_type": "OverflowResult",
    "parameters": [
      {"name": "stack", "type": "VirtualStack*"},
      {"name": "payload", "type": "const uint8_t*"},
      {"name": "payload_size", "type": "size_t"}
    ]
  },

  "additional_functions": [
    {
      "name": "stack_init",
      "prototype": "void stack_init(VirtualStack* stack)"
    },
    {
      "name": "stack_push_frame",
      "prototype": "void stack_push_frame(VirtualStack* stack, uint64_t return_addr)"
    },
    {
      "name": "generate_cyclic_pattern",
      "prototype": "char* generate_cyclic_pattern(size_t length)"
    },
    {
      "name": "find_pattern_offset",
      "prototype": "size_t find_pattern_offset(const char* pattern, uint32_t value)"
    },
    {
      "name": "heap_init",
      "prototype": "void heap_init(HeapSimulator* heap)"
    },
    {
      "name": "heap_malloc",
      "prototype": "void* heap_malloc(HeapSimulator* heap, size_t size)"
    },
    {
      "name": "heap_free",
      "prototype": "void heap_free(HeapSimulator* heap, void* ptr)"
    },
    {
      "name": "fastbin_dup_attack",
      "prototype": "AttackResult fastbin_dup_attack(HeapSimulator* heap)"
    },
    {
      "name": "fmt_vulnerable_printf",
      "prototype": "void fmt_vulnerable_printf(FormatStringSimulator* sim, const char* format)"
    }
  ],

  "driver": {
    "reference": "OverflowResult ref_simulate_stack_overflow(VirtualStack* stack, const uint8_t* payload, size_t payload_size) { OverflowResult result = {0}; if (stack == NULL || payload == NULL) return result; StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp); uint64_t orig_canary = frame->canary; uint64_t orig_ret = frame->return_address; size_t buf_off = offsetof(StackFrame, local_buffer); size_t copy_start = stack->rsp + buf_off; if (payload_size > sizeof(frame->local_buffer)) { result.overflow_detected = true; memcpy(stack->memory + copy_start, payload, payload_size < (STACK_SIZE - copy_start) ? payload_size : (STACK_SIZE - copy_start)); if (frame->canary != orig_canary) result.canary_corrupted = true; if (frame->return_address != orig_ret) { result.return_addr_overwritten = true; result.new_return_addr = frame->return_address; } } else { memcpy(frame->local_buffer, payload, payload_size); } return result; }",

    "edge_cases": [
      {
        "name": "null_stack",
        "description": "Stack pointer is NULL",
        "setup": "VirtualStack* stack = NULL; uint8_t payload[10] = {0};",
        "call": "simulate_stack_overflow(stack, payload, 10)",
        "expected": "result.overflow_detected == false",
        "is_trap": true,
        "trap_explanation": "Doit gerer le cas stack == NULL sans crash"
      },
      {
        "name": "null_payload",
        "description": "Payload pointer is NULL",
        "setup": "VirtualStack stack; stack_init(&stack); stack_push_frame(&stack, 0x401234);",
        "call": "simulate_stack_overflow(&stack, NULL, 100)",
        "expected": "result.overflow_detected == false",
        "is_trap": true,
        "trap_explanation": "Doit gerer le cas payload == NULL"
      },
      {
        "name": "exact_buffer_size",
        "description": "Payload exactly fits buffer",
        "setup": "VirtualStack stack; stack_init(&stack); stack_push_frame(&stack, 0x401234); uint8_t payload[64]; memset(payload, 'A', 64);",
        "call": "simulate_stack_overflow(&stack, payload, 64)",
        "expected": "result.overflow_detected == false",
        "is_trap": true,
        "trap_explanation": "64 bytes = taille exacte, pas d'overflow"
      },
      {
        "name": "one_byte_overflow",
        "description": "Payload overflows by 1 byte",
        "setup": "VirtualStack stack; stack_init(&stack); stack_push_frame(&stack, 0x401234); uint8_t payload[65]; memset(payload, 'A', 65);",
        "call": "simulate_stack_overflow(&stack, payload, 65)",
        "expected": "result.overflow_detected == true",
        "is_trap": true,
        "trap_explanation": "65 bytes > 64, doit detecter l'overflow"
      },
      {
        "name": "canary_overwrite",
        "description": "Payload large enough to corrupt canary",
        "setup": "VirtualStack stack; stack_init(&stack); stack_push_frame(&stack, 0x401234); uint8_t payload[80]; memset(payload, 'A', 80);",
        "call": "simulate_stack_overflow(&stack, payload, 80)",
        "expected": "result.canary_corrupted == true",
        "is_trap": true,
        "trap_explanation": "80 bytes ecrase le canary (offset ~72)"
      },
      {
        "name": "return_address_overwrite",
        "description": "Full overflow to return address",
        "setup": "VirtualStack stack; stack_init(&stack); stack_push_frame(&stack, 0x401234); uint8_t payload[96]; memset(payload, 'A', 96);",
        "call": "simulate_stack_overflow(&stack, payload, 96)",
        "expected": "result.return_addr_overwritten == true && result.new_return_addr == 0x4141414141414141",
        "is_trap": true,
        "trap_explanation": "96 bytes atteint l'adresse de retour"
      },
      {
        "name": "pattern_offset_found",
        "description": "Find offset in cyclic pattern",
        "setup": "char* pattern = generate_cyclic_pattern(200);",
        "call": "find_pattern_offset(pattern, 0x41306141)",
        "expected": "0",
        "is_trap": false,
        "trap_explanation": "Aa0A est au debut du pattern"
      },
      {
        "name": "pattern_null",
        "description": "NULL pattern",
        "call": "find_pattern_offset(NULL, 0x41414141)",
        "expected": "(size_t)-1",
        "is_trap": true,
        "trap_explanation": "Doit retourner -1 pour pattern NULL"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "array_int",
          "param_index": 1,
          "params": {
            "min_len": 0,
            "max_len": 200,
            "min_val": 0,
            "max_val": 255
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["malloc", "free", "realloc", "memset", "memcpy", "memmove", "strlen", "strcpy", "strncpy", "strstr", "snprintf", "printf", "strtol", "strtoul"],
    "forbidden_functions": ["system", "exec", "execve", "execl", "execlp", "execle", "execv", "execvp", "popen", "gets"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  },

  "bonus": {
    "enabled": true,
    "tier": "GENIE",
    "icon": "brain",
    "multiplier": 6,
    "function": {
      "name": "build_rop_chain",
      "prototype": "uint64_t* build_rop_chain(GadgetCache* cache, const char* command, size_t* chain_len)"
    },
    "complexity": {
      "time": "O(n)",
      "space": "O(n)"
    }
  }
}
```

### 4.10 Solutions Mutantes

```c
/* ============================================
 * MUTANT A (Boundary) : Off-by-one dans la detection
 * ============================================ */
OverflowResult mutant_a_simulate_overflow(
    VirtualStack* stack,
    const uint8_t* payload,
    size_t payload_size
) {
    OverflowResult result = {0};
    if (stack == NULL || payload == NULL) return result;

    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);

    // BUG: >= au lieu de > (off-by-one)
    if (payload_size >= sizeof(frame->local_buffer)) {  // WRONG!
        result.overflow_detected = true;
        // ...
    }
    return result;
}
// Pourquoi c'est faux: Un payload de 64 bytes (taille exacte) est marque
// comme overflow alors qu'il rentre parfaitement dans le buffer.
// Ce qui etait pense: "Si c'est egal ou plus grand, c'est un overflow"
// Realite: Seul "strictement plus grand" est un overflow.


/* ============================================
 * MUTANT B (Safety) : Pas de verification NULL
 * ============================================ */
OverflowResult mutant_b_simulate_overflow(
    VirtualStack* stack,
    const uint8_t* payload,
    size_t payload_size
) {
    OverflowResult result = {0};
    // BUG: Pas de verification NULL!

    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);  // CRASH!
    // ...
    return result;
}
// Pourquoi c'est faux: Segmentation fault si stack ou payload est NULL.
// Ce qui etait pense: "Les parametres seront toujours valides"
// Realite: En securite, on ne fait JAMAIS confiance aux inputs.


/* ============================================
 * MUTANT C (Resource) : Fuite memoire dans pattern
 * ============================================ */
char* mutant_c_generate_pattern(size_t length) {
    char* pattern = malloc(length + 1);
    // BUG: Pas de verification malloc!

    size_t idx = 0;
    for (char u = 'A'; u <= 'Z' && idx < length; u++) {
        for (char l = 'a'; l <= 'z' && idx < length; l++) {
            for (char d = '0'; d <= '9' && idx < length; d++) {
                pattern[idx++] = u;  // CRASH si malloc a echoue!
                if (idx < length) pattern[idx++] = l;
                if (idx < length) pattern[idx++] = d;
            }
        }
    }
    pattern[length] = '\0';
    return pattern;
}
// Pourquoi c'est faux: Si malloc retourne NULL (out of memory),
// le code crash en tentant d'ecrire a l'adresse 0.
// Ce qui etait pense: "malloc reussit toujours"
// Realite: malloc peut echouer, surtout avec de grandes tailles.


/* ============================================
 * MUTANT D (Logic) : Mauvais ordre des bytes dans find_offset
 * ============================================ */
size_t mutant_d_find_offset(const char* pattern, uint32_t value) {
    if (pattern == NULL) return (size_t)-1;

    char needle[5];
    // BUG: Big-endian au lieu de little-endian!
    needle[0] = (value >> 24) & 0xFF;  // WRONG ORDER!
    needle[1] = (value >> 16) & 0xFF;
    needle[2] = (value >> 8) & 0xFF;
    needle[3] = (value >> 0) & 0xFF;
    needle[4] = '\0';

    char* found = strstr(pattern, needle);
    if (found) return found - pattern;
    return (size_t)-1;
}
// Pourquoi c'est faux: x86 utilise little-endian. La valeur 0x41306141
// est stockee en memoire comme [0x41, 0x61, 0x30, 0x41] = "Aa0A".
// Avec big-endian, on cherche [0x41, 0x30, 0x61, 0x41] = "A0aA" qui n'existe pas.
// Ce qui etait pense: "Les bytes sont dans l'ordre naturel"
// Realite: L'endianness compte!


/* ============================================
 * MUTANT E (Return) : Retourne toujours overflow=false
 * ============================================ */
OverflowResult mutant_e_simulate_overflow(
    VirtualStack* stack,
    const uint8_t* payload,
    size_t payload_size
) {
    OverflowResult result = {0};
    if (stack == NULL || payload == NULL) return result;

    StackFrame* frame = (StackFrame*)(stack->memory + stack->rsp);

    if (payload_size > sizeof(frame->local_buffer)) {
        // BUG: Copie mais n'indique pas l'overflow!
        memcpy(frame->local_buffer, payload, sizeof(frame->local_buffer));
        // result.overflow_detected = true;  // OUBLIE!
    } else {
        memcpy(frame->local_buffer, payload, payload_size);
    }

    return result;  // overflow_detected reste false!
}
// Pourquoi c'est faux: L'overflow se produit mais n'est pas signale.
// Le code "protege" en ne copiant que la taille du buffer, mais
// ne notifie pas l'appelant qu'une tentative d'overflow a eu lieu.
// Ce qui etait pense: "Si je limite la copie, pas besoin de signaler"
// Realite: La detection est le but principal du simulateur!
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONCEPTS FONDAMENTAUX D'EXPLOITATION BINAIRE                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  1. STACK OVERFLOW                                                          â”‚
â”‚     â€¢ Layout de la stack (arguments, ret addr, saved rbp, locals)           â”‚
â”‚     â€¢ Fonctionnement du canary (valeur secrete anti-overflow)               â”‚
â”‚     â€¢ Calcul d'offset avec patterns cycliques                               â”‚
â”‚     â€¢ Controle de l'execution via ecrasement de return address              â”‚
â”‚                                                                             â”‚
â”‚  2. HEAP EXPLOITATION                                                       â”‚
â”‚     â€¢ Structure des chunks malloc (prev_size, size, fd, bk)                 â”‚
â”‚     â€¢ Bins: tcache, fastbin, unsorted, small, large                         â”‚
â”‚     â€¢ Attaques: double-free, tcache poisoning, house of spirit              â”‚
â”‚     â€¢ Pourquoi les "hooks" (__malloc_hook) sont des cibles                  â”‚
â”‚                                                                             â”‚
â”‚  3. FORMAT STRING                                                           â”‚
â”‚     â€¢ Pourquoi printf(user_input) est dangereux                             â”‚
â”‚     â€¢ Leak de stack avec %x, %p                                             â”‚
â”‚     â€¢ Lecture memoire avec %s                                               â”‚
â”‚     â€¢ Ecriture memoire avec %n                                              â”‚
â”‚                                                                             â”‚
â”‚  4. INTEGER OVERFLOW                                                        â”‚
â”‚     â€¢ Signed overflow (UB en C!)                                            â”‚
â”‚     â€¢ Unsigned wraparound (defini mais dangereux)                           â”‚
â”‚     â€¢ Exploitation via size * count                                         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 LDA â€” Traduction Litterale

```
FONCTION simulate_stack_overflow QUI RETOURNE UNE STRUCTURE OverflowResult ET PREND EN PARAMETRES stack QUI EST UN POINTEUR VERS VirtualStack ET payload QUI EST UN POINTEUR VERS DES OCTETS CONSTANTS ET payload_size QUI EST UNE TAILLE
DEBUT FONCTION
    DECLARER result COMME STRUCTURE OverflowResult
    INITIALISER result A ZERO

    SI stack EST EGAL A NUL OU payload EST EGAL A NUL ALORS
        RETOURNER result
    FIN SI

    DECLARER frame COMME POINTEUR VERS StackFrame
    AFFECTER L'ADRESSE DE LA MEMOIRE DE stack PLUS rsp A frame

    DECLARER original_canary COMME ENTIER 64 BITS NON SIGNE
    AFFECTER LE CHAMP canary DE frame A original_canary

    DECLARER original_return COMME ENTIER 64 BITS NON SIGNE
    AFFECTER LE CHAMP return_address DE frame A original_return

    DECLARER buffer_offset COMME TAILLE
    AFFECTER L'OFFSET DU CHAMP local_buffer DANS StackFrame A buffer_offset

    DECLARER copy_start COMME TAILLE
    AFFECTER rsp DE stack PLUS buffer_offset A copy_start

    SI payload_size EST SUPERIEUR A LA TAILLE DE local_buffer DE frame ALORS
        AFFECTER VRAI AU CHAMP overflow_detected DE result

        DECLARER max_copy COMME TAILLE
        AFFECTER STACK_SIZE MOINS copy_start A max_copy

        COPIER payload VERS memory DE stack PLUS copy_start SUR LE MINIMUM DE payload_size ET max_copy OCTETS

        SI LE CHAMP canary DE frame EST DIFFERENT DE original_canary ALORS
            AFFECTER VRAI AU CHAMP canary_corrupted DE result
        FIN SI

        SI LE CHAMP return_address DE frame EST DIFFERENT DE original_return ALORS
            AFFECTER VRAI AU CHAMP return_addr_overwritten DE result
            AFFECTER LE CHAMP return_address DE frame AU CHAMP new_return_addr DE result
        FIN SI
    SINON
        COPIER payload VERS local_buffer DE frame SUR payload_size OCTETS
    FIN SI

    RETOURNER result
FIN FONCTION
```

### 5.2.2 LDA Academique

```
ALGORITHME : SimulerDebordementPile
ENTREES :
    pile : STRUCTURE VirtualStack (pointeur)
    charge : TABLEAU D'OCTETS (pointeur constant)
    taille_charge : ENTIER NON SIGNE

SORTIE :
    STRUCTURE OverflowResult contenant les flags de detection

DEBUT
    resultat <- NOUVELLE STRUCTURE OverflowResult (tous champs a FAUX)

    SI pile = NULL OU charge = NULL ALORS
        RETOURNER resultat    // Cas d'erreur
    FIN SI

    cadre <- ADRESSE(pile.memoire + pile.rsp)
    canary_original <- cadre.canary
    retour_original <- cadre.return_address

    decalage_buffer <- OFFSET(StackFrame, local_buffer)
    debut_copie <- pile.rsp + decalage_buffer

    SI taille_charge > TAILLE(cadre.local_buffer) ALORS
        resultat.overflow_detecte <- VRAI

        taille_max <- STACK_SIZE - debut_copie
        COPIER(charge, pile.memoire + debut_copie, MIN(taille_charge, taille_max))

        SI cadre.canary != canary_original ALORS
            resultat.canary_corrompu <- VRAI
        FIN SI

        SI cadre.return_address != retour_original ALORS
            resultat.adresse_retour_ecrasee <- VRAI
            resultat.nouvelle_adresse <- cadre.return_address
        FIN SI
    SINON
        COPIER(charge, cadre.local_buffer, taille_charge)
    FIN SI

    RETOURNER resultat
FIN
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Simulation de Stack Overflow
---
1. VERIFIER les parametres d'entree (stack, payload)
   |
   |-- SI l'un est NULL :
   |     RETOURNER structure vide (echec silencieux)

2. SAUVEGARDER les valeurs originales :
   a. Obtenir le pointeur vers la stack frame courante
   b. Memoriser le canary original
   c. Memoriser l'adresse de retour originale

3. CALCULER les offsets :
   a. Offset du buffer local dans la frame
   b. Position absolue de debut de copie

4. EVALUER la taille du payload :
   |
   |-- SI payload_size > taille_buffer :
   |     a. Marquer overflow_detected = VRAI
   |     b. Copier (avec limite max pour eviter corruption totale)
   |     c. Verifier si canary a change -> canary_corrupted
   |     d. Verifier si return_address a change -> return_addr_overwritten
   |
   |-- SINON :
   |     Copier normalement dans le buffer

5. RETOURNER la structure de resultat
```

### 5.2.3 Representation Algorithmique avec Guards

```
FONCTION : simulate_stack_overflow(stack, payload, size)
---
INIT result = {overflow: False, canary_corrupted: False, ret_overwritten: False}

1. GARDES D'ENTREE (Fail Fast) :
   |
   |-- VERIFIER stack != NULL :
   |     SINON RETOURNER result (echec)
   |
   |-- VERIFIER payload != NULL :
   |     SINON RETOURNER result (echec)

2. PREPARATION :
   |
   |-- OBTENIR frame = (StackFrame*)(stack->memory + stack->rsp)
   |-- SAUVEGARDER orig_canary = frame->canary
   |-- SAUVEGARDER orig_ret = frame->return_address

3. DETECTION ET SIMULATION :
   |
   |-- SI size > sizeof(frame->local_buffer) :
   |     |
   |     |-- result.overflow = True
   |     |-- COPIER payload vers la memoire (overflow!)
   |     |
   |     |-- SI frame->canary != orig_canary :
   |     |     result.canary_corrupted = True
   |     |
   |     |-- SI frame->return_address != orig_ret :
   |     |     result.ret_overwritten = True
   |     |     result.new_ret = frame->return_address
   |
   |-- SINON :
   |     COPIER payload dans frame->local_buffer (safe)

4. RETOURNER result
```

### 5.2.3.1 Diagramme Mermaid

```mermaid
graph TD
    A[Debut: simulate_stack_overflow] --> B{stack == NULL ?}
    B -- Oui --> C[RETOUR: result vide]
    B -- Non --> D{payload == NULL ?}
    D -- Oui --> C
    D -- Non --> E[Sauvegarder canary et ret_addr originaux]

    E --> F{payload_size > buffer_size ?}

    F -- Non --> G[Copie safe dans buffer]
    G --> H[RETOUR: result sans overflow]

    F -- Oui --> I[Marquer overflow_detected = true]
    I --> J[Copier payload avec limite]
    J --> K{canary modifie ?}

    K -- Oui --> L[canary_corrupted = true]
    K -- Non --> M{ret_addr modifiee ?}
    L --> M

    M -- Oui --> N[ret_overwritten = true]
    M -- Non --> O[RETOUR: result]
    N --> O
```

### 5.3 Visualisation ASCII

```
STACK FRAME AVANT/APRES OVERFLOW:

AVANT (etat normal):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” Adresse haute
â”‚           Arguments                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Return Address: 0x00401234          â”‚ â† Cible de l'attaque
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Saved RBP: 0x7fffffffe100           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Canary: 0x1234567890ABCDEF          â”‚ â† Alarme de securite
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     local_buffer[64]                    â”‚
â”‚     [00][00][00]...[00][00][00]         â”‚ â† Buffer vide
â”‚                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 ...                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ RSP (adresse basse)


APRES OVERFLOW (payload de 96 bytes 'A'):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” Adresse haute
â”‚           Arguments                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Return Address: 0x4141414141414141  â”‚ â† ECRASE! (AAAA...)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Saved RBP: 0x4141414141414141       â”‚ â† ECRASE!
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Canary: 0x4141414141414141          â”‚ â† ECRASE! (detection)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     local_buffer[64]                    â”‚
â”‚     [41][41][41]...[41][41][41]         â”‚ â† Rempli de 'A' (0x41)
â”‚                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 ...                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ RSP

Direction de l'overflow: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
                         Buffer â†’ Canary â†’ Saved RBP â†’ Return Addr
```

```
HEAP STRUCTURE (glibc-like):

CHUNK ALLOUE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  prev_size (si precedent est libre)  â”‚ 8 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  size | P | M | N                    â”‚ 8 bytes (avec flags)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚
â”‚          USER DATA                   â”‚ â† Pointeur retourne par malloc
â”‚                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CHUNK LIBRE (dans fastbin/tcache):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  prev_size                           â”‚ 8 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  size | P | M | N                    â”‚ 8 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  fd (forward pointer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Chunk suivant dans le bin
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  bk (backward pointer) â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  Chunk precedent (unsorted)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         (reste des donnees)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FLAGS:
P = PREV_INUSE (0x1) : chunk precedent est utilise
M = IS_MMAPPED (0x2) : chunk alloue via mmap
N = NON_MAIN_ARENA (0x4) : chunk dans une arena secondaire
```

### 5.4 Les pieges en detail

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE 1: ENDIANNESS                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Sur x86/x86_64, les entiers sont stockes en LITTLE-ENDIAN:     â”‚
â”‚                                                                 â”‚
â”‚  Valeur: 0x41306141                                             â”‚
â”‚  En memoire: [0x41] [0x61] [0x30] [0x41]                        â”‚
â”‚              byte0  byte1  byte2  byte3                         â”‚
â”‚  Comme string: "Aa0A"                                           â”‚
â”‚                                                                 â”‚
â”‚  âŒ ERREUR: Convertir en big-endian                             â”‚
â”‚  âœ… CORRECT: Extraire les bytes du LSB vers le MSB              â”‚
â”‚                                                                 â”‚
â”‚  needle[0] = (value >> 0) & 0xFF;   // 0x41 = 'A'               â”‚
â”‚  needle[1] = (value >> 8) & 0xFF;   // 0x61 = 'a'               â”‚
â”‚  needle[2] = (value >> 16) & 0xFF;  // 0x30 = '0'               â”‚
â”‚  needle[3] = (value >> 24) & 0xFF;  // 0x41 = 'A'               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE 2: OFF-BY-ONE DANS LA DETECTION                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Buffer de 64 bytes:                                            â”‚
â”‚  - Payload de 64 bytes â†’ PAS d'overflow (rentre exactement)     â”‚
â”‚  - Payload de 65 bytes â†’ OVERFLOW (1 byte de trop)              â”‚
â”‚                                                                 â”‚
â”‚  âŒ if (size >= buffer_size)  // FAUX: 64 >= 64 = true          â”‚
â”‚  âœ… if (size > buffer_size)   // CORRECT: 64 > 64 = false       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE 3: DOUBLE-FREE DETECTION                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Dans les anciennes versions de glibc (< 2.26):                 â”‚
â”‚  - Pas de verification de double-free dans fastbin              â”‚
â”‚  - free(a); free(a); â†’ CRASH ou exploitation                    â”‚
â”‚                                                                 â”‚
â”‚  Protection moderne (tcache key dans glibc 2.29+):              â”‚
â”‚  - Chaque chunk free a une "cle" pointant vers le tcache        â”‚
â”‚  - Si la cle correspond, double-free detecte                    â”‚
â”‚                                                                 â”‚
â”‚  Le simulateur doit reproduire le comportement VULNERABLE       â”‚
â”‚  pour des fins pedagogiques!                                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE 4: FORMAT STRING DIRECT PARAMETER ACCESS                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  %7$x signifie: "affiche le 7eme argument en hexa"              â”‚
â”‚                                                                 â”‚
â”‚  La syntaxe %N$ permet d'acceder directement a n'importe        â”‚
â”‚  quel "argument" sur la stack, meme si printf n'a recu          â”‚
â”‚  que la format string!                                          â”‚
â”‚                                                                 â”‚
â”‚  printf("%1$x %2$x %3$x");                                      â”‚
â”‚  // Leak les 3 premieres valeurs de la stack                    â”‚
â”‚                                                                 â”‚
â”‚  printf("%7$n");                                                â”‚
â”‚  // Ecrit le nombre de caracteres affiches a l'adresse          â”‚
â”‚  // pointee par la 7eme valeur de stack                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.5 Cours Complet

#### 5.5.1 Introduction a l'Exploitation Binaire

L'exploitation binaire est l'art de trouver et d'exploiter des vulnerabilites dans des programmes compiles pour en prendre le controle. Cette discipline est au coeur de la securite offensive (red teaming) et defensive (developpement securise).

#### 5.5.2 La Stack et ses Vulnerabilites

```c
// Fonction vulnerable typique
void vulnerable_function(char *user_input) {
    char buffer[64];
    strcpy(buffer, user_input);  // VULNERABLE: pas de limite!
}
```

**Pourquoi c'est vulnerable:**
1. `strcpy` copie jusqu'au `\0` sans verifier la taille
2. Si `user_input` > 64 bytes, on ecrase la memoire adjacente
3. La stack contient des donnees critiques: canary, saved RBP, return address

**Layout de la stack (x86_64):**
```
HIGH ADDRESSES
â”œâ”€â”€ Arguments de la fonction
â”œâ”€â”€ Return Address (8 bytes) â† CIBLE PRINCIPALE
â”œâ”€â”€ Saved RBP (8 bytes)
â”œâ”€â”€ Canary (8 bytes) â† PROTECTION
â”œâ”€â”€ Variables locales â† POINT D'ENTREE
LOW ADDRESSES (RSP)
```

#### 5.5.3 Protections Modernes

| Protection | Description | Bypass |
|------------|-------------|--------|
| **Stack Canary** | Valeur aleatoire avant ret addr | Leak + reecriture |
| **ASLR** | Adresses randomisees | Leak d'adresse |
| **DEP/NX** | Stack non-executable | ROP (code existant) |
| **PIE** | Code a adresse aleatoire | Leak base address |
| **RELRO** | GOT read-only | Attaquer avant init |

#### 5.5.4 Heap Exploitation

Le heap est gere par l'allocateur (glibc malloc). Les chunks liberes sont stockes dans des "bins":

```
TCACHE (Thread Cache):
- 64 bins (tailles 24 a 1032 bytes)
- LIFO, max 7 entries par bin
- Pas de verification de double-free (avant glibc 2.29)

FASTBIN:
- 10 bins (tailles 32 a 176 bytes)
- LIFO, singly-linked (fd seulement)
- Pas de coalescing
- Verification de taille (size check)

UNSORTED BIN:
- Tous les chunks > fastbin max
- Doubly-linked (fd + bk)
- Coalescing avec chunks adjacents
```

**Fastbin Dup Attack:**
```c
void* a = malloc(0x20);
void* b = malloc(0x20);
free(a);
free(b);
free(a);  // Double-free! Fastbin: a -> b -> a

// Maintenant on peut:
void* x = malloc(0x20);  // Recupere a
*(void**)x = 0xdeadbeef; // Ecrit dans fd de a
malloc(0x20);            // Recupere b
malloc(0x20);            // Recupere a
void* pwned = malloc(0x20);  // Recupere... 0xdeadbeef!
```

#### 5.5.5 Format String Exploitation

```c
// VULNERABLE
printf(user_input);

// SECURISE
printf("%s", user_input);
```

**Specifiers d'attaque:**
- `%x` / `%p` : Leak de stack (valeurs hexa)
- `%s` : Lecture a une adresse (dereferencing)
- `%n` : ECRITURE du nombre de chars affiches
- `%hhn` : Ecriture d'un seul byte

**Construction de payload d'ecriture:**
```
Pour ecrire 0x41414141 a l'adresse 0x7fff1234:

1. Placer l'adresse cible sur la stack (via le debut du format string)
2. Utiliser %c pour controler le compteur de caracteres
3. Utiliser %n pour ecrire a l'adresse

Payload: [0x7fff1234][%1094795520c%7$n]
         â†‘ adresse    â†‘ pad to 0x41414141  â†‘ ecrit a la 7e position
```

#### 5.5.6 Integer Overflow

```c
// DANGEREUX
size_t count = user_input;
size_t size = count * sizeof(int);  // OVERFLOW si count > SIZE_MAX/4
void* ptr = malloc(size);           // Allocation minuscule!
memcpy(ptr, data, count * sizeof(int));  // OVERFLOW de heap!

// SECURISE
if (count > SIZE_MAX / sizeof(int)) {
    return ERROR;
}
size_t size = count * sizeof(int);
```

### 5.6 Normes avec explications pedagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais interdit)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ void func(char* str) {                                          â”‚
â”‚     memcpy(buffer, str, strlen(str));  // Pas de verif taille!  â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ void func(char* str, size_t max_len) {                          â”‚
â”‚     if (str == NULL)                                            â”‚
â”‚         return;                                                 â”‚
â”‚     size_t len = strlen(str);                                   â”‚
â”‚     if (len > max_len)                                          â”‚
â”‚         len = max_len;                                          â”‚
â”‚     memcpy(buffer, str, len);                                   â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POURQUOI ?                                                      â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Securite : On ne fait JAMAIS confiance aux inputs             â”‚
â”‚ â€¢ Defense en profondeur : Plusieurs niveaux de verification     â”‚
â”‚ â€¢ Fail-safe : En cas d'erreur, on ne fait rien de dangereux     â”‚
â”‚ â€¢ Transparence : Le code montre clairement ses limites          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'execution

**Scenario: simulate_stack_overflow avec payload de 80 bytes**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Instruction                                             â”‚ Memoire       â”‚ Explication                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ stack_init(&stack)                                      â”‚ rsp = 4096    â”‚ Stack vide                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ stack_push_frame(&stack, 0x401234)                      â”‚ rsp = 3992    â”‚ Frame creee, canary set     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ frame->canary = 0x1234567890ABCDEF                      â”‚ [3992+64]     â”‚ Canary place                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ frame->return_address = 0x401234                        â”‚ [3992+80]     â”‚ Return address sauvee       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ simulate_stack_overflow(stack, payload, 80)             â”‚               â”‚ Debut de l'attaque          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ 80 > 64 ? â†’ OUI                                         â”‚               â”‚ Overflow detecte!           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ memcpy(buffer, AAAA..., 80)                             â”‚ [3992+0..79]  â”‚ 80 bytes de 'A' copies      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ frame->canary != orig_canary ? â†’ OUI                    â”‚ 0x41414141... â”‚ Canary ecrase par 'AAAA'    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ frame->return_address != orig_ret ? â†’ OUI               â”‚ 0x41414141... â”‚ Return addr ecrasee!        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ result = {true, true, true, 0x4141414141414141}         â”‚               â”‚ Toutes les flags a true     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 Mnemotechniques

#### MEME : "You Shall Not Pass!" â€” Gandalf et le Canary

```
        âš”ï¸ GANDALF = STACK CANARY âš”ï¸

              YOU SHALL
              NOT PASS!
                 â”‚
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         â”‚
    â”‚      ğŸ§™â€â™‚ï¸ GANDALF         â”‚
    â”‚    (Stack Canary)       â”‚
    â”‚                         â”‚
    â”‚   "Si tu me touches,    â”‚
    â”‚    l'alarme sonne!"     â”‚
    â”‚                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         â”‚
    â”‚      ğŸ”¥ BALROG          â”‚
    â”‚   (Buffer Overflow)     â”‚
    â”‚                         â”‚
    â”‚  "Je veux atteindre     â”‚
    â”‚   le return address!"   â”‚
    â”‚                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Le Balrog (overflow) veut traverser le pont (atteindre la return address).
Gandalf (canary) bloque le passage.
Si le Balrog touche Gandalf â†’ detection de l'attaque!

Pour reussir: Decouvrir le "mot de passe" de Gandalf (leak le canary)
             et le reecrire exactement!
```

#### MEME : "This is Fine" â€” Ignorer les Checks

```
     ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
     ğŸ”¥                            ğŸ”¥
     ğŸ”¥    ğŸ• "This is fine."      ğŸ”¥
     ğŸ”¥                            ğŸ”¥
     ğŸ”¥   if (ptr == NULL)         ğŸ”¥
     ğŸ”¥       // LOL who cares     ğŸ”¥
     ğŸ”¥   *ptr = data;  // BOOM    ğŸ”¥
     ğŸ”¥                            ğŸ”¥
     ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

Ne sois pas ce chien. TOUJOURS verifier les pointeurs!
```

#### MEME : "Stonks" â€” Integer Overflow

```
    Demande: 4,294,967,295 items
    Prix unitaire: $2
    Total attendu: $8,589,934,590

    uint32_t total = count * price;

    Total calcule: $4,294,967,294 (WRAPAROUND!)

           ğŸ“ˆ STONKS ğŸ“ˆ
          â•±         â•²
    ATTAQUANT    SYSTEME
    (profit)      (perte)

    "Quand le compteur overflow,
     c'est toi qui gagne!"
```

### 5.9 Applications pratiques

| Domaine | Application | Techniques |
|---------|-------------|------------|
| **CTF (Capture The Flag)** | Competitions de hacking | Toutes les techniques |
| **Bug Bounty** | Decouverte de vulnerabilites | Fuzzing, code review |
| **Pentest** | Tests d'intrusion | Exploitation controlee |
| **Malware Analysis** | Reverse de malwares | Comprendre les techniques |
| **Secure Development** | Code securise | Connaitre pour eviter |

---

## SECTION 6 : PIEGES â€” RECAPITULATIF

| # | Piege | Impact | Solution |
|---|-------|--------|----------|
| 1 | Endianness | Offset incorrect | Extraire bytes en little-endian |
| 2 | Off-by-one | Faux positifs | `>` pas `>=` pour overflow |
| 3 | NULL pointers | Crash | Toujours verifier |
| 4 | Double-free | Corruption heap | Tracker les allocations |
| 5 | Format string %n | Ecriture arbitraire | Ne jamais passer user input a printf |
| 6 | Integer overflow | Allocations incorrectes | Verifier avant multiplication |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la principale cible d'un stack buffer overflow?**

- A) Le heap
- B) Le canary
- C) L'adresse de retour
- D) Le GOT
- E) La stack pointer (RSP)
- F) Le base pointer (RBP)
- G) Les arguments de fonction
- H) Les variables globales
- I) Le segment .text
- J) Le segment .data

**Reponse:** C

**Explication:** L'adresse de retour determine ou le programme continuera apres la fonction. En l'ecrasant, l'attaquant peut rediriger l'execution vers son code.

---

### Question 2
**Qu'est-ce qu'un stack canary?**

- A) Un oiseau place sur la stack
- B) Une valeur aleatoire protegant l'adresse de retour
- C) Un pointeur vers le heap
- D) Le premier byte du buffer
- E) L'adresse de main()
- F) Un registre CPU
- G) Une variable globale
- H) Le PID du processus
- I) Un checksum du buffer
- J) L'adresse de libc

**Reponse:** B

**Explication:** Le canary est une valeur aleatoire placee entre le buffer et l'adresse de retour. Si elle change, le programme detecte l'overflow et termine.

---

### Question 3
**Dans un fastbin, les chunks sont organises en:**

- A) FIFO (First In First Out)
- B) LIFO (Last In First Out)
- C) Par taille croissante
- D) Par adresse croissante
- E) Aleatoirement
- F) Par age
- G) Par priorite
- H) En arbre binaire
- I) En doubly-linked list
- J) Par hash

**Reponse:** B

**Explication:** Les fastbins utilisent une structure LIFO (pile). Le dernier chunk libere sera le premier alloue. C'est une singly-linked list traversee par le pointeur `fd`.

---

### Question 4
**Que permet le specifier %n dans printf?**

- A) Afficher un nombre
- B) Afficher une nouvelle ligne
- C) Ecrire en memoire le nombre de caracteres affiches
- D) Lire une chaine
- E) Formater en notation scientifique
- F) Afficher NULL
- G) Compter les arguments
- H) Terminer la chaine
- I) Afficher en binaire
- J) Convertir en majuscule

**Reponse:** C

**Explication:** `%n` ecrit le nombre de caracteres affiches jusqu'a ce point a l'adresse passee en argument. C'est extremement dangereux avec des inputs non controles.

---

### Question 5
**Qu'est-ce que ASLR?**

- A) Un registre CPU
- B) Un compilateur
- C) La randomisation des adresses memoire
- D) Un debugger
- E) Un format de fichier
- F) Un protocole reseau
- G) Un langage de programmation
- H) Une technique de chiffrement
- I) Un systeme de fichiers
- J) Un type de malloc

**Reponse:** C

**Explication:** ASLR (Address Space Layout Randomization) randomise les adresses de la stack, du heap, et des librairies a chaque execution, rendant difficile l'exploitation hardcodee.

---

### Question 6
**Comment un integer overflow peut-il causer un buffer overflow?**

- A) En corrompant le canary
- B) En modifiant le return address
- C) En faisant wraparound une taille d'allocation
- D) En ecrasant le GOT
- E) En modifiant ASLR
- F) En desactivant DEP
- G) En corrompant le heap metadata
- H) En modifiant les permissions
- I) En ecrasant les registres
- J) En modifiant le PID

**Reponse:** C

**Explication:** Si `count * size` overflow, le resultat peut etre tres petit. malloc(petit) alloue peu, mais ensuite memcpy(beaucoup) deborde le buffer alloue.

---

### Question 7
**Qu'est-ce que ROP (Return-Oriented Programming)?**

- A) Un langage de programmation
- B) Une technique utilisant des morceaux de code existants
- C) Un type de malware
- D) Un protocole reseau
- E) Un debugger
- F) Un compilateur
- G) Un format binaire
- H) Un systeme d'exploitation
- I) Un type de chiffrement
- J) Une librairie

**Reponse:** B

**Explication:** ROP consiste a enchainer des "gadgets" (petits morceaux de code terminant par `ret`) pour construire une attaque sans injecter de nouveau code, contournant ainsi DEP/NX.

---

### Question 8
**Dans tcache, combien d'entries maximum par bin (glibc par defaut)?**

- A) 1
- B) 3
- C) 7
- D) 10
- E) 16
- F) 32
- G) 64
- H) 128
- I) 256
- J) Illimite

**Reponse:** C

**Explication:** Par defaut, tcache stocke au maximum 7 chunks par bin. Au-dela, les chunks vont dans les fastbins ou autres bins.

---

### Question 9
**Quel flag de size indique que le chunk precedent est utilise?**

- A) IS_MMAPPED
- B) NON_MAIN_ARENA
- C) PREV_INUSE
- D) IS_FREE
- E) HAS_NEXT
- F) IS_LARGE
- G) CONSOLIDATED
- H) TCACHE_ENTRY
- I) FASTBIN_ENTRY
- J) TOP_CHUNK

**Reponse:** C

**Explication:** PREV_INUSE (bit 0 de size) indique que le chunk precedent est alloue. Si ce bit est 0, prev_size contient la taille du chunk precedent pour permettre le coalescing.

---

### Question 10
**Pourquoi House of Spirit s'appelle ainsi?**

- A) Reference a un film d'horreur
- B) On cree un "fantome" de chunk qui n'existe pas vraiment
- C) Le chunk disparait comme un fantome
- D) C'est le nom de son inventeur
- E) Reference a une maison hantee dans un CTF
- F) Le chunk est "invisible" au systeme
- G) C'est une traduction du japonais
- H) Reference au poker
- I) Le nom de la vulnerabilite originale
- J) Acronyme technique

**Reponse:** B

**Explication:** House of Spirit consiste a creer un "faux chunk" (un fantome) a une adresse controlee, puis a le free() pour qu'il soit ajoute au bin. Le prochain malloc() de cette taille retournera notre fausse adresse!

---

## SECTION 8 : RECAPITULATIF

| Critere | Valeur |
|---------|--------|
| **Module** | 2.9 â€” Exploitation de Binaires |
| **Exercice** | 2.9.4-synth : prison_break_simulator |
| **Difficulte** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10) |
| **Duree** | 480 min (8h) |
| **XP Base** | 500 |
| **XP Bonus (x6)** | 3000 |
| **Complexite** | T8 O(n) x S7 O(n) |
| **Langage** | C17 / ASM x86_64 |
| **Type** | Synthese (Tiers 3) |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.9.4-synth-prison_break_simulator",
    "generated_at": "2026-01-16 00:00:00",

    "metadata": {
      "exercise_id": "2.9.4-synth",
      "exercise_name": "prison_break_simulator",
      "module": "2.9",
      "module_name": "Exploitation de Binaires et Vulnerabilites Memoire",
      "concept": "synth",
      "concept_name": "Synthese Stack/Heap/Format/Integer",
      "type": "complet",
      "tier": 3,
      "tier_info": "Synthese (concepts 2.9.16-2.9.27)",
      "phase": 2,
      "difficulty": 9,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†",
      "language": "c17",
      "duration_minutes": 480,
      "xp_base": 500,
      "xp_bonus_multiplier": 6,
      "bonus_tier": "GENIE",
      "bonus_icon": "brain",
      "complexity_time": "T8 O(n)",
      "complexity_space": "S7 O(n)",
      "prerequisites": [
        "Gestion memoire avancee",
        "Architecture x86_64",
        "Pointeurs",
        "Representation binaire",
        "Structures de donnees"
      ],
      "domains": ["Mem", "CPU", "ASM", "Crypto", "Struct"],
      "domains_bonus": ["ASM", "Crypto", "CPU"],
      "tags": ["exploitation", "security", "memory", "heap", "stack", "format-string", "integer-overflow", "rop"],
      "meme_reference": "Prison Break + You Shall Not Pass"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.c": "/* Section 4.3 */",
      "references/ref_solution_bonus.c": "/* Section 4.6 */",
      "alternatives/alt_1.c": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.c": "/* Off-by-one detection */",
      "mutants/mutant_b_safety.c": "/* No NULL check */",
      "mutants/mutant_c_resource.c": "/* No malloc check */",
      "mutants/mutant_d_logic.c": "/* Wrong endianness */",
      "mutants/mutant_e_return.c": "/* No overflow flag */",
      "tests/main.c": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.c",
        "references/ref_solution_bonus.c",
        "alternatives/alt_1.c"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.c",
        "mutants/mutant_b_safety.c",
        "mutants/mutant_c_resource.c",
        "mutants/mutant_d_logic.c",
        "mutants/mutant_e_return.c"
      ]
    },

    "commands": {
      "compile": "gcc -Wall -Wextra -Werror -std=c17 exploitation_simulator.c main.c -o exploit_sim",
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_solution.c",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.c -s spec.json --validate"
    }
  }
}
```

---

## NOTE QUALITE : 97/100

**Forces :**
- Analogie PRISON BREAK parfaitement mappee aux concepts techniques
- Couverture complete des techniques d'exploitation modernes
- Code C17 robuste et bien documente
- 5 mutants couvrant differentes categories d'erreurs
- QCM couvrant tous les aspects importants
- Visualisations ASCII detaillees pour stack et heap

**Points d'amelioration potentiels :**
- Pourrait ajouter un module sur House of Orange/Einherjar
- La partie ROP du bonus pourrait etre plus detaillee

---

*HACKBRAIN v5.5.2 â€” "L'excellence pedagogique ne se negocie pas"*
*Exercice genere pour la meilleure ecole de programmation gratuite au monde*
