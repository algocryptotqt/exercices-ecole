# Exercice 2.9.1-synth : crypto_foundations

**Module :**
2.9.1 â€” Fondements de la Cryptographie

**Concept :**
synth â€” Synthese complete (chiffrement symetrique, modes d'operation, hachage)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10)

**Type :**
complet

**Tiers :**
3 â€” Synthese (concepts dâ†’j + 2.9.2 + 2.9.3 + 2.9.4 + 2.9.8 + 2.9.45)

**Langage :**
Rust Edition 2024 / C17

**Prerequis :**
- Manipulation de bits et operations bitwise
- Structures de donnees (tableaux, vecteurs)
- Traits Rust et generiques
- Gestion d'erreurs avec Result/Option
- Notions de base en mathematiques (modulo, XOR)

**Domaines :**
Crypto, Encodage, Mem, Struct

**Duree estimee :**
180 min

**XP Base :**
500

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
src/
  lib.rs
  symmetric.rs
  modes.rs
  hashing.rs
Cargo.toml
```

**Fonctions autorisees :**
- Toutes les fonctions de la bibliotheque standard Rust
- Pas de crates externes pour la cryptographie (pas de `ring`, `aes`, `sha2`, etc.)

**Fonctions interdites :**
- Aucune crate de cryptographie externe
- `unsafe` limite au strict necessaire et documente

### 1.2 Consigne

#### 2.4.1 MISSION IMPOSSIBLE : L'Analogie Parfaite

**"Votre mission, si vous l'acceptez..."**

Imagine que tu es Ethan Hunt de Mission Impossible. Chaque concept cryptographique correspond a un element de tes missions d'espionnage :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MISSION IMPOSSIBLE : CRYPTO EDITION                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  LE CHIFFREMENT = Messages auto-destructibles d'Ethan Hunt                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Quand Ethan recoit ses ordres de mission, le message se detruit apres      â”‚
â”‚  lecture. Le chiffrement fait pareil : sans la cle, le message est          â”‚
â”‚  ILLISIBLE, comme s'il s'etait auto-detruit pour tout le monde sauf toi.    â”‚
â”‚                                                                              â”‚
â”‚  AES = Le Coffre-fort de la CIA                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Langley possede des coffres-forts avec 10, 12 ou 14 couches de securite    â”‚
â”‚  (selon l'importance du secret). AES-128 = 10 rounds, AES-192 = 12 rounds,  â”‚
â”‚  AES-256 = 14 rounds. Plus c'est sensible, plus il y a de verrous.          â”‚
â”‚                                                                              â”‚
â”‚  LE MAC (Message Authentication Code) = Empreinte digitale d'agent          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Avant d'entrer au QG, chaque agent scanne son empreinte. Le MAC fait       â”‚
â”‚  pareil : il prouve que le message vient VRAIMENT de l'expediteur et        â”‚
â”‚  n'a pas ete modifie par un imposteur.                                      â”‚
â”‚                                                                              â”‚
â”‚  L'IV (Initialization Vector) = Lieu de rendez-vous secret                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Ethan ne donne JAMAIS deux fois rendez-vous au meme endroit. L'IV change   â”‚
â”‚  a chaque message : meme si tu envoies "ABORT MISSION" deux fois, les       â”‚
â”‚  messages chiffres seront DIFFERENTS. L'ennemi ne peut pas detecter les     â”‚
â”‚  patterns.                                                                   â”‚
â”‚                                                                              â”‚
â”‚  ECB = L'erreur du stagiaire                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Un stagiaire de la CIA utilise toujours le MEME lieu de rendez-vous.       â”‚
â”‚  Resultat : l'ennemi repere les patterns. C'est le "ECB Penguin" - meme     â”‚
â”‚  chiffree, l'image du pingouin reste reconnaissable !                       â”‚
â”‚                                                                              â”‚
â”‚  SHA-256 = La photo d'identite unique                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Chaque agent a une photo d'identite UNIQUE de 256 bits. Impossible de      â”‚
â”‚  trouver deux agents avec la meme photo (collision resistance).             â”‚
â”‚  Impossible de recreer l'agent a partir de sa photo (preimage resistance).  â”‚
â”‚                                                                              â”‚
â”‚  Ce message s'auto-detruira dans 5 secondes...                              â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.4.2 Enonce Academique

**Description :**

Implementer une bibliotheque cryptographique complete en Rust 2024 demonstrant les concepts fondamentaux de cryptographie symetrique et de hachage. Cette bibliotheque servira de base pedagogique pour comprendre comment fonctionnent les primitives cryptographiques modernes.

**Ta mission :**

Creer une bibliotheque Rust qui implemente :

1. **Chiffrement par blocs** : Traits generiques pour block ciphers avec AES simplifie
2. **Stream ciphers** : Implementation pedagogique de RC4 (deprecie mais instructif)
3. **Modes d'operation** : ECB, CBC, CTR, GCM demonstrant leurs differences
4. **Fonctions de hachage** : SHA-256 from scratch

**Entree :**
- Cles de chiffrement de tailles variables (128, 192, 256 bits)
- Donnees a chiffrer/hacher (vecteurs d'octets)
- IVs/Nonces pour les modes qui en necessitent

**Sortie :**
- Donnees chiffrees/dechiffrees
- Hash de 256 bits pour SHA-256
- Tags d'authentification pour GCM

**Contraintes :**
- AES doit supporter les trois tailles de cle (128, 192, 256 bits)
- Les modes doivent gerer le padding PKCS7
- SHA-256 doit passer les vecteurs de test NIST
- GCM doit verifier le tag AVANT le dechiffrement
- Gestion propre des erreurs (pas de panic)

**Exemples :**

| Operation | Entree | Sortie |
|-----------|--------|--------|
| `SHA256::hash(b"abc")` | "abc" | `ba7816bf8f01cfea...` (64 hex chars) |
| `AES-128 rounds` | key 128 bits | 10 rounds |
| `AES-256 rounds` | key 256 bits | 14 rounds |
| `ECB(image)` | Image uniforme | Patterns visibles |
| `CBC(image)` | Image uniforme | Patterns caches |

### 1.3 Prototype

```rust
// src/lib.rs
#![feature(generic_const_exprs)]

pub mod symmetric;
pub mod hashing;
pub mod modes;

// ============================================
// Traits fondamentaux
// ============================================

/// Trait pour les chiffrements par blocs
pub trait BlockCipher {
    const BLOCK_SIZE: usize;
    const KEY_SIZE: usize;
    const ROUNDS: usize;

    fn new(key: &[u8]) -> Result<Self, CryptoError> where Self: Sized;
    fn encrypt_block(&self, block: &mut [u8; Self::BLOCK_SIZE]);
    fn decrypt_block(&self, block: &mut [u8; Self::BLOCK_SIZE]);
}

/// Trait pour les stream ciphers
pub trait StreamCipher {
    fn new(key: &[u8], nonce: &[u8]) -> Result<Self, CryptoError> where Self: Sized;
    fn generate_keystream(&mut self, length: usize) -> Vec<u8>;
    fn encrypt(&mut self, data: &[u8]) -> Vec<u8>;
    fn decrypt(&mut self, data: &[u8]) -> Vec<u8>;
}

/// Trait pour les fonctions de hachage
pub trait HashFunction {
    const BLOCK_SIZE: usize;
    const OUTPUT_SIZE: usize;

    fn new() -> Self;
    fn update(&mut self, data: &[u8]);
    fn finalize(self) -> Vec<u8>;

    fn hash(data: &[u8]) -> Vec<u8> where Self: Sized {
        let mut hasher = Self::new();
        hasher.update(data);
        hasher.finalize()
    }
}

/// Erreurs cryptographiques
#[derive(Debug, Clone, PartialEq)]
pub enum CryptoError {
    InvalidKeySize { expected: usize, got: usize },
    InvalidBlockSize,
    InvalidNonce,
    AuthenticationFailed,
    InvalidPadding,
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Histoire Secrete d'AES

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                              â”‚
â”‚   En 1997, le NIST lance un concours pour remplacer DES. 15 algorithmes     â”‚
â”‚   sont soumis. En 2000, Rijndael (cree par deux Belges, Daemen et Rijmen)   â”‚
â”‚   remporte la competition et devient AES.                                    â”‚
â”‚                                                                              â”‚
â”‚   Pourquoi "Rijndael" ? C'est la contraction de leurs noms :                â”‚
â”‚   Rijmen + Daemen = Rijndael                                                â”‚
â”‚                                                                              â”‚
â”‚   Fun fact : Le gouvernement americain utilise AES-256 pour proteger les    â”‚
â”‚   informations classifiees TOP SECRET. Oui, le meme algorithme que tu       â”‚
â”‚   vas implementer !                                                          â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Le Pingouin ECB : Une Lecon Visuelle

Le "ECB Penguin" est devenu celebre dans l'enseignement de la cryptographie. Quand on chiffre une image du pingouin Tux en mode ECB, les zones de couleur uniforme produisent les memes blocs chiffres, revelant la silhouette !

```
Original:          ECB Chiffre:       CBC Chiffre:
   â–„â–„â–„â–„              â–„â–„â–„â–„              â–‘â–’â–“â–ˆâ–€â–„
  â–ˆ    â–ˆ            â–ˆ    â–ˆ            â–“â–‘â–ˆâ–’â–€â–“â–ˆ
 â–ˆ â—  â— â–ˆ          â–ˆ â—  â— â–ˆ          â–‘â–“â–’â–ˆâ–‘â–“â–’â–ˆ
 â–ˆ  â–¼   â–ˆ          â–ˆ  â–¼   â–ˆ          â–ˆâ–’â–‘â–“â–€â–’â–‘â–ˆ
  â–ˆ    â–ˆ            â–ˆ    â–ˆ            â–“â–ˆâ–’â–‘â–“â–ˆâ–’
   â–ˆâ–ˆâ–ˆâ–ˆ              â–ˆâ–ˆâ–ˆâ–ˆ              â–’â–“â–‘â–ˆâ–“â–‘

  VISIBLE!          VISIBLE!          BROUILLE!
```

### 2.3 MD5 : La Chute d'un Geant

MD5 etait considere comme sur jusqu'en 2004, quand Wang et Yu ont trouve des collisions. Aujourd'hui, on peut generer une collision MD5 en quelques secondes sur un laptop. C'est pourquoi on utilise SHA-256 ou mieux.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Qui utilise ces concepts ?

| Metier | Utilisation | Exemple concret |
|--------|-------------|-----------------|
| **Security Engineer** | Implementation de protocoles | TLS/HTTPS, chiffrement de disque |
| **DevSecOps** | Gestion des secrets | HashiCorp Vault, AWS KMS |
| **Blockchain Developer** | Hachage et signatures | Bitcoin utilise SHA-256 pour le mining |
| **Backend Developer** | Stockage de mots de passe | bcrypt, Argon2 (bases sur des primitives similaires) |
| **Embedded Systems** | Secure boot, firmware | AES-GCM pour l'authentification |
| **Cloud Architect** | Chiffrement at-rest/in-transit | S3 encryption, database encryption |

### Cas d'usage reel : Signal Messenger

Signal utilise AES-256-GCM pour chiffrer les messages. Chaque message a :
- Une cle derivee unique (jamais reutilisee)
- Un IV aleatoire
- Un tag d'authentification

C'est exactement ce que tu vas implementer !

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
src/  Cargo.toml

$ cargo build --release
   Compiling crypto_foundations v0.1.0
    Finished release [optimized] target(s) in 2.34s

$ cargo test
running 8 tests
test hashing::tests::test_sha256_empty ... ok
test hashing::tests::test_sha256_abc ... ok
test hashing::tests::test_sha256_long ... ok
test symmetric::tests::test_aes_128_rounds ... ok
test symmetric::tests::test_aes_256_rounds ... ok
test modes::tests::test_ecb_pattern_leak ... ok
test modes::tests::test_cbc_no_pattern ... ok
test modes::tests::test_gcm_authentication ... ok

test result: ok. 8 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
ğŸ’€ğŸ’€ (12/10)

**Recompense :**
XP x4

**Time Complexity attendue :**
O(n) avec parallelisation CTR

**Space Complexity attendue :**
O(1) auxiliaire pour le streaming

**Domaines Bonus :**
`Crypto, Probas, CPU`

#### 3.1.1 Consigne Bonus

**"La mission de niveau Omega"**

L'IMF te confie une mission supplementaire : implementer le mode CTR avec parallelisation (chaque bloc peut etre chiffre independamment) et demontrer statistiquement le biais RC4.

**Ta mission :**

1. **CTR Parallele** : Utiliser `rayon` pour chiffrer les blocs en parallele
2. **Demonstration biais RC4** : Prouver statistiquement que les premiers octets RC4 sont biaises
3. **Benchmark** : Comparer les performances CTR sequentiel vs parallele

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Parallelisation CTR : speedup >= 2x sur 4 cores                            â”‚
â”‚  Biais RC4 : detecter le biais avec chi-square test                         â”‚
â”‚  Benchmark : mesurer avec criterion                                          â”‚
â”‚  Zero-copy : pas d'allocation intermediaire pour CTR                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 Prototype Bonus

```rust
impl<C: BlockCipher + Sync> CTR<C> {
    /// Version parallelisee avec rayon
    pub fn encrypt_parallel(&self, plaintext: &[u8]) -> Vec<u8>;
}

impl RC4 {
    /// Demontre le biais statistique des premiers octets
    /// Retourne les frequences observees pour analyse chi-square
    pub fn demonstrate_bias(key: &[u8], samples: usize) -> [u32; 256];
}
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| CTR | Sequentiel | Parallele avec rayon |
| RC4 | Implementation | + Analyse statistique du biais |
| Performance | Correctness only | Benchmarks requis |
| Complexite | Single-threaded | Multi-threaded safe |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Input | Expected | Points | Piege |
|------|-------|----------|--------|-------|
| `sha256_empty` | `b""` | `e3b0c44298fc1c14...` | 10 | Hash du vide |
| `sha256_abc` | `b"abc"` | `ba7816bf8f01cfea...` | 10 | Vecteur NIST |
| `sha256_long` | 448 bits input | `248d6a61d20638b8...` | 10 | Padding complexe |
| `aes128_rounds` | 128-bit key | 10 | 5 | Nombre de rounds |
| `aes192_rounds` | 192-bit key | 12 | 5 | Nombre de rounds |
| `aes256_rounds` | 256-bit key | 14 | 5 | Nombre de rounds |
| `ecb_pattern` | Blocs identiques | Ciphertext identique | 10 | Demontre le probleme |
| `cbc_no_pattern` | Blocs identiques | Ciphertext different | 10 | IV empeche patterns |
| `ctr_symmetric` | Encrypt then decrypt | Original | 10 | XOR est symetrique |
| `gcm_auth_fail` | Tag modifie | AuthenticationFailed | 10 | Verif avant decrypt |
| `gcm_auth_pass` | Tag correct | Decrypted data | 10 | AEAD complet |
| `invalid_key_size` | 15-byte key | InvalidKeySize error | 5 | Gestion erreur |

### 4.2 main.rs de test

```rust
// tests/integration_test.rs
use crypto_foundations::hashing::{SHA256, HashFunction};
use crypto_foundations::symmetric::{AES, BlockCipher};
use crypto_foundations::modes::{ECB, CBC, CTR, GCM};

#[test]
fn test_sha256_nist_vectors() {
    // Vecteur 1: chaine vide
    let hash = SHA256::hash(b"");
    assert_eq!(
        hex::encode(&hash),
        "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    );

    // Vecteur 2: "abc"
    let hash = SHA256::hash(b"abc");
    assert_eq!(
        hex::encode(&hash),
        "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
    );

    // Vecteur 3: message long
    let hash = SHA256::hash(b"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert_eq!(
        hex::encode(&hash),
        "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"
    );

    println!("SHA-256 NIST vectors: PASS");
}

#[test]
fn test_aes_rounds() {
    assert_eq!(<AES<128> as BlockCipher>::ROUNDS, 10);
    assert_eq!(<AES<192> as BlockCipher>::ROUNDS, 12);
    assert_eq!(<AES<256> as BlockCipher>::ROUNDS, 14);
    println!("AES rounds: PASS");
}

#[test]
fn test_ecb_shows_patterns() {
    let key = [0u8; 16];
    let aes = AES::<128>::new(&key).unwrap();
    let ecb = ECB::new(aes);

    // Deux blocs identiques
    let plaintext = [0x42u8; 32]; // Deux blocs de 16 bytes identiques
    let ciphertext = ecb.encrypt(&plaintext);

    // En ECB, les deux blocs chiffres doivent etre identiques
    assert_eq!(&ciphertext[0..16], &ciphertext[16..32]);
    println!("ECB pattern leak: DEMONSTRATED");
}

#[test]
fn test_cbc_hides_patterns() {
    let key = [0u8; 16];
    let iv = [0u8; 16];
    let aes = AES::<128>::new(&key).unwrap();
    let cbc = CBC::new(aes, iv);

    // Deux blocs identiques
    let plaintext = [0x42u8; 32];
    let ciphertext = cbc.encrypt(&plaintext);

    // En CBC, les deux blocs chiffres doivent etre DIFFERENTS
    assert_ne!(&ciphertext[0..16], &ciphertext[16..32]);
    println!("CBC pattern hiding: PASS");
}

#[test]
fn test_gcm_authentication() {
    let key = [0u8; 16];
    let nonce = [0u8; 12];
    let aad = b"additional data";
    let plaintext = b"secret message";

    let aes = AES::<128>::new(&key).unwrap();
    let gcm = GCM::new(aes);

    let (ciphertext, tag) = gcm.encrypt_authenticated(plaintext, aad, &nonce);

    // Dechiffrement avec bon tag
    let decrypted = gcm.decrypt_authenticated(&ciphertext, aad, &nonce, &tag);
    assert!(decrypted.is_ok());
    assert_eq!(decrypted.unwrap(), plaintext);

    // Dechiffrement avec tag modifie
    let mut bad_tag = tag;
    bad_tag[0] ^= 1;
    let result = gcm.decrypt_authenticated(&ciphertext, aad, &nonce, &bad_tag);
    assert!(matches!(result, Err(CryptoError::AuthenticationFailed)));

    println!("GCM authentication: PASS");
}

fn main() {
    println!("Running crypto_foundations tests...\n");

    test_sha256_nist_vectors();
    test_aes_rounds();
    test_ecb_shows_patterns();
    test_cbc_hides_patterns();
    test_gcm_authentication();

    println!("\nAll tests passed!");
}
```

### 4.3 Solution de reference

```rust
// src/hashing.rs - SHA-256 Implementation
pub struct SHA256 {
    state: [u32; 8],
    buffer: Vec<u8>,
    total_len: u64,
}

const K: [u32; 64] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
];

impl HashFunction for SHA256 {
    const BLOCK_SIZE: usize = 64;
    const OUTPUT_SIZE: usize = 32;

    fn new() -> Self {
        SHA256 {
            state: [
                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
            ],
            buffer: Vec::new(),
            total_len: 0,
        }
    }

    fn update(&mut self, data: &[u8]) {
        self.buffer.extend_from_slice(data);
        self.total_len += data.len() as u64;

        while self.buffer.len() >= 64 {
            let block: [u8; 64] = self.buffer[..64].try_into().unwrap();
            self.process_block(&block);
            self.buffer.drain(..64);
        }
    }

    fn finalize(mut self) -> Vec<u8> {
        let bit_len = self.total_len * 8;

        // Padding
        self.buffer.push(0x80);
        while (self.buffer.len() % 64) != 56 {
            self.buffer.push(0x00);
        }

        // Longueur en big-endian
        self.buffer.extend_from_slice(&bit_len.to_be_bytes());

        for chunk in self.buffer.chunks(64) {
            let block: [u8; 64] = chunk.try_into().unwrap();
            self.process_block(&block);
        }

        let mut result = Vec::with_capacity(32);
        for word in &self.state {
            result.extend_from_slice(&word.to_be_bytes());
        }
        result
    }
}

impl SHA256 {
    fn process_block(&mut self, block: &[u8; 64]) {
        let mut w = [0u32; 64];
        for i in 0..16 {
            w[i] = u32::from_be_bytes([
                block[i * 4],
                block[i * 4 + 1],
                block[i * 4 + 2],
                block[i * 4 + 3],
            ]);
        }

        for i in 16..64 {
            let s0 = w[i - 15].rotate_right(7)
                   ^ w[i - 15].rotate_right(18)
                   ^ (w[i - 15] >> 3);
            let s1 = w[i - 2].rotate_right(17)
                   ^ w[i - 2].rotate_right(19)
                   ^ (w[i - 2] >> 10);
            w[i] = w[i - 16]
                .wrapping_add(s0)
                .wrapping_add(w[i - 7])
                .wrapping_add(s1);
        }

        let [mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h] = self.state;

        for i in 0..64 {
            let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
            let ch = (e & f) ^ ((!e) & g);
            let temp1 = h
                .wrapping_add(s1)
                .wrapping_add(ch)
                .wrapping_add(K[i])
                .wrapping_add(w[i]);
            let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
            let maj = (a & b) ^ (a & c) ^ (b & c);
            let temp2 = s0.wrapping_add(maj);

            h = g;
            g = f;
            f = e;
            e = d.wrapping_add(temp1);
            d = c;
            c = b;
            b = a;
            a = temp1.wrapping_add(temp2);
        }

        self.state[0] = self.state[0].wrapping_add(a);
        self.state[1] = self.state[1].wrapping_add(b);
        self.state[2] = self.state[2].wrapping_add(c);
        self.state[3] = self.state[3].wrapping_add(d);
        self.state[4] = self.state[4].wrapping_add(e);
        self.state[5] = self.state[5].wrapping_add(f);
        self.state[6] = self.state[6].wrapping_add(g);
        self.state[7] = self.state[7].wrapping_add(h);
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1: SHA256 avec buffer statique au lieu de Vec
pub struct SHA256Static {
    state: [u32; 8],
    buffer: [u8; 64],
    buffer_len: usize,
    total_len: u64,
}

// Alternative 2: Utilisation de iterateurs au lieu de boucles indexees
fn process_block_iter(&mut self, block: &[u8; 64]) {
    let w: Vec<u32> = block
        .chunks_exact(4)
        .map(|chunk| u32::from_be_bytes(chunk.try_into().unwrap()))
        .collect();
    // ... reste de l'implementation
}
```

### 4.5 Solutions refusees (avec explications)

```rust
// REFUSE 1: Utilisation de crates externes
use sha2::{Sha256, Digest}; // INTERDIT - le but est d'implementer from scratch

// REFUSE 2: Padding incorrect (little-endian au lieu de big-endian)
self.buffer.extend_from_slice(&bit_len.to_le_bytes()); // FAUX! SHA-256 utilise big-endian

// REFUSE 3: Oubli du bit '1' dans le padding
self.buffer.extend(std::iter::repeat(0x00)); // FAUX! Doit commencer par 0x80

// REFUSE 4: Mauvaises valeurs initiales
state: [0u32; 8], // FAUX! Doit utiliser les constantes NIST
```

### 4.6 Solution bonus de reference (COMPLETE)

```rust
// CTR parallele avec rayon
#[cfg(feature = "parallel")]
impl<C: BlockCipher + Sync> CTR<C> {
    pub fn encrypt_parallel(&self, plaintext: &[u8]) -> Vec<u8> {
        use rayon::prelude::*;

        let block_size = C::BLOCK_SIZE;

        plaintext
            .par_chunks(block_size)
            .enumerate()
            .flat_map(|(counter, chunk)| {
                let mut counter_block = [0u8; 16];
                counter_block[..8].copy_from_slice(&self.nonce);
                counter_block[8..].copy_from_slice(&(counter as u64).to_be_bytes());

                let mut keystream = counter_block;
                self.cipher.encrypt_block(&mut keystream);

                chunk.iter()
                    .zip(keystream.iter())
                    .map(|(&p, &k)| p ^ k)
                    .collect::<Vec<_>>()
            })
            .collect()
    }
}

// Demonstration du biais RC4
impl RC4 {
    pub fn demonstrate_bias(key: &[u8], samples: usize) -> [u32; 256] {
        let mut counts = [0u32; 256];

        for _ in 0..samples {
            let mut rc4 = RC4::new(key, &[]).unwrap();
            let byte = rc4.generate_keystream(1)[0];
            counts[byte as usize] += 1;
        }

        // Analyse: dans un stream aleatoire, chaque valeur devrait
        // apparaitre ~samples/256 fois
        // RC4 montre un biais detectif vers certaines valeurs
        counts
    }

    pub fn chi_square_test(observed: &[u32; 256], samples: usize) -> f64 {
        let expected = samples as f64 / 256.0;
        observed.iter()
            .map(|&o| {
                let diff = o as f64 - expected;
                diff * diff / expected
            })
            .sum()
    }
}
```

### 4.7 Solutions alternatives bonus (COMPLETES)

```rust
// Alternative: Parallelisation avec crossbeam au lieu de rayon
#[cfg(feature = "crossbeam")]
impl<C: BlockCipher + Sync + Send> CTR<C> {
    pub fn encrypt_parallel_crossbeam(&self, plaintext: &[u8]) -> Vec<u8> {
        use crossbeam::scope;

        let block_size = C::BLOCK_SIZE;
        let num_blocks = (plaintext.len() + block_size - 1) / block_size;
        let mut result = vec![0u8; plaintext.len()];

        scope(|s| {
            let chunks: Vec<_> = plaintext.chunks(block_size).enumerate().collect();
            for (counter, chunk) in chunks {
                let cipher = &self.cipher;
                let nonce = &self.nonce;
                let out = &mut result[counter * block_size..];

                s.spawn(move |_| {
                    let mut counter_block = [0u8; 16];
                    counter_block[..8].copy_from_slice(nonce);
                    counter_block[8..].copy_from_slice(&(counter as u64).to_be_bytes());
                    cipher.encrypt_block(&mut counter_block);

                    for (i, &byte) in chunk.iter().enumerate() {
                        out[i] = byte ^ counter_block[i];
                    }
                });
            }
        }).unwrap();

        result
    }
}
```

### 4.8 Solutions refusees bonus (COMPLETES)

```rust
// REFUSE: Pas de synchronisation appropriee
impl<C: BlockCipher> CTR<C> {
    pub fn encrypt_parallel_unsafe(&self, plaintext: &[u8]) -> Vec<u8> {
        // FAUX: self.cipher n'est pas Sync, data race possible
        let result: Vec<u8> = plaintext
            .par_chunks(16)
            .flat_map(|chunk| {
                let mut block = [0u8; 16];
                self.cipher.encrypt_block(&mut block); // DATA RACE!
                chunk.iter().zip(block.iter()).map(|(p, k)| p ^ k).collect::<Vec<_>>()
            })
            .collect();
        result
    }
}

// REFUSE: Chi-square mal calcule
pub fn chi_square_wrong(observed: &[u32; 256]) -> f64 {
    // FAUX: divise par la mauvaise valeur
    observed.iter().map(|&o| (o as f64).powi(2)).sum::<f64>() / 256.0
}
```

### 4.9 spec.json (ENGINE v22.1 - FORMAT STRICT)

```json
{
  "name": "crypto_foundations",
  "language": "rust",
  "rust_edition": "2024",
  "type": "complet",
  "tier": 3,
  "tier_info": "Synthese complete cryptographie",
  "tags": ["crypto", "aes", "sha256", "gcm", "phase2", "security"],
  "passing_score": 70,

  "functions": [
    {
      "name": "SHA256::hash",
      "prototype": "fn hash(data: &[u8]) -> Vec<u8>",
      "return_type": "Vec<u8>",
      "parameters": [
        {"name": "data", "type": "&[u8]"}
      ]
    },
    {
      "name": "AES::new",
      "prototype": "fn new(key: &[u8]) -> Result<Self, CryptoError>",
      "return_type": "Result<AES<N>, CryptoError>",
      "parameters": [
        {"name": "key", "type": "&[u8]"}
      ]
    },
    {
      "name": "GCM::encrypt_authenticated",
      "prototype": "fn encrypt_authenticated(&self, plaintext: &[u8], aad: &[u8], nonce: &[u8]) -> (Vec<u8>, [u8; 16])",
      "return_type": "(Vec<u8>, [u8; 16])",
      "parameters": [
        {"name": "plaintext", "type": "&[u8]"},
        {"name": "aad", "type": "&[u8]"},
        {"name": "nonce", "type": "&[u8]"}
      ]
    }
  ],

  "driver": {
    "reference_file": "references/ref_solution.rs",

    "edge_cases": [
      {
        "name": "sha256_empty",
        "function": "SHA256::hash",
        "args": [""],
        "expected_hex": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
        "is_trap": true,
        "trap_explanation": "Hash d'une chaine vide - test de padding"
      },
      {
        "name": "sha256_abc",
        "function": "SHA256::hash",
        "args": ["abc"],
        "expected_hex": "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
        "is_trap": false
      },
      {
        "name": "sha256_448bits",
        "function": "SHA256::hash",
        "args": ["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"],
        "expected_hex": "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",
        "is_trap": true,
        "trap_explanation": "Message de 448 bits - padding complexe car proche de 512"
      },
      {
        "name": "aes128_key_size",
        "function": "AES::<128>::new",
        "args": [{"type": "bytes", "len": 16}],
        "expected": "Ok",
        "is_trap": false
      },
      {
        "name": "aes_invalid_key",
        "function": "AES::<128>::new",
        "args": [{"type": "bytes", "len": 15}],
        "expected": "Err(InvalidKeySize)",
        "is_trap": true,
        "trap_explanation": "Cle de 15 bytes au lieu de 16"
      },
      {
        "name": "gcm_auth_fail",
        "function": "GCM::decrypt_authenticated",
        "setup": "encrypt then modify tag",
        "expected": "Err(AuthenticationFailed)",
        "is_trap": true,
        "trap_explanation": "Tag modifie doit etre rejete AVANT dechiffrement"
      },
      {
        "name": "ecb_pattern_visible",
        "function": "ECB::encrypt",
        "args": [{"type": "bytes", "pattern": "repeat_block"}],
        "assertion": "ciphertext[0..16] == ciphertext[16..32]",
        "is_trap": true,
        "trap_explanation": "ECB doit montrer les patterns"
      },
      {
        "name": "cbc_pattern_hidden",
        "function": "CBC::encrypt",
        "args": [{"type": "bytes", "pattern": "repeat_block"}],
        "assertion": "ciphertext[0..16] != ciphertext[16..32]",
        "is_trap": false
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "bytes",
          "param_index": 0,
          "params": {
            "min_len": 0,
            "max_len": 1024
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["hex"],
    "forbidden_crates": ["ring", "aes", "sha2", "openssl", "rust-crypto"],
    "check_unsafe": true,
    "max_unsafe_blocks": 2,
    "check_memory": true,
    "blocking": true
  },

  "bonus": {
    "enabled": true,
    "tier": "EXPERT",
    "multiplier": 4,
    "requirements": [
      "CTR parallelization with rayon",
      "RC4 bias demonstration with chi-square",
      "Benchmark comparison"
    ]
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```rust
/* Mutant A (Boundary) : Padding SHA-256 off-by-one */
fn finalize(mut self) -> Vec<u8> {
    let bit_len = self.total_len * 8;
    self.buffer.push(0x80);
    // BUG: utilise 55 au lieu de 56
    while (self.buffer.len() % 64) != 55 {
        self.buffer.push(0x00);
    }
    self.buffer.extend_from_slice(&bit_len.to_be_bytes());
    // ... reste du code
}
// Pourquoi c'est faux : Le padding doit laisser exactement 8 octets pour la longueur
// Ce qui etait pense : "55 ou 56, c'est pareil"

/* Mutant B (Safety) : Pas de verification de taille de cle AES */
fn new(key: &[u8]) -> Result<Self, CryptoError> {
    // BUG: pas de verification
    let nk = key.len() / 4;
    // ... continue sans verifier si key.len() est valide
}
// Pourquoi c'est faux : Accepte des cles de n'importe quelle taille
// Ce qui etait pense : "Le reste du code gerera les mauvaises tailles"

/* Mutant C (Resource) : GCM dechiffre AVANT de verifier le tag */
fn decrypt_authenticated(&self, ciphertext: &[u8], aad: &[u8], nonce: &[u8], tag: &[u8; 16])
    -> Result<Vec<u8>, CryptoError>
{
    // BUG: dechiffre d'abord
    let plaintext = self.decrypt_ctr(ciphertext, nonce);

    // Puis verifie le tag
    let expected_tag = self.compute_tag(ciphertext, aad, nonce);
    if tag != &expected_tag {
        return Err(CryptoError::AuthenticationFailed);
    }

    Ok(plaintext) // Le plaintext a deja ete calcule!
}
// Pourquoi c'est faux : Attaque par oracle - l'attaquant peut utiliser le temps
// Ce qui etait pense : "On retourne une erreur donc c'est bon"

/* Mutant D (Logic) : SHA-256 utilise little-endian au lieu de big-endian */
fn finalize(mut self) -> Vec<u8> {
    let bit_len = self.total_len * 8;
    self.buffer.push(0x80);
    while (self.buffer.len() % 64) != 56 {
        self.buffer.push(0x00);
    }
    // BUG: little-endian au lieu de big-endian
    self.buffer.extend_from_slice(&bit_len.to_le_bytes());
    // ...
}
// Pourquoi c'est faux : SHA-256 specifie big-endian pour la longueur
// Ce qui etait pense : "x86 est little-endian donc c'est logique"

/* Mutant E (Return) : ECB ne detecte pas les patterns (retourne toujours different) */
fn encrypt(&self, plaintext: &[u8]) -> Vec<u8> {
    let mut ciphertext = Vec::new();
    let mut counter = 0u64;

    for chunk in plaintext.chunks(16) {
        let mut block = [0u8; 16];
        block[..chunk.len()].copy_from_slice(chunk);
        // BUG: ajoute un compteur (comme CTR) au lieu de ECB pur
        block[0] ^= (counter & 0xFF) as u8;
        counter += 1;
        self.cipher.encrypt_block(&mut block);
        ciphertext.extend_from_slice(&block);
    }
    ciphertext
}
// Pourquoi c'est faux : Ce n'est plus ECB, c'est un mode hybride
// Ce qui etait pense : "J'ameliore ECB en cachant les patterns"
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OBJECTIFS PEDAGOGIQUES                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  1. CHIFFREMENT SYMETRIQUE                                                  â”‚
â”‚     - Comprendre la difference block cipher vs stream cipher                â”‚
â”‚     - Pourquoi DES est casse (cle trop courte: 56 bits)                    â”‚
â”‚     - Comment AES fonctionne (SubBytes, ShiftRows, MixColumns, AddRoundKey)â”‚
â”‚     - Pourquoi AES-256 a 14 rounds et AES-128 seulement 10                 â”‚
â”‚                                                                              â”‚
â”‚  2. MODES D'OPERATION                                                       â”‚
â”‚     - ECB: pourquoi c'est DANGEREUX (patterns visibles)                    â”‚
â”‚     - CBC: comment l'IV empeche les patterns                               â”‚
â”‚     - CTR: transformation block cipher -> stream cipher                    â”‚
â”‚     - GCM: chiffrement authentifie (confidentialite + integrite)           â”‚
â”‚                                                                              â”‚
â”‚  3. FONCTIONS DE HACHAGE                                                    â”‚
â”‚     - Construction Merkle-Damgard                                          â”‚
â”‚     - Padding SHA-256 (pourquoi le bit 1, puis zeros, puis longueur)      â”‚
â”‚     - Proprietes: preimage resistance, collision resistance                â”‚
â”‚     - Pourquoi MD5 est casse mais SHA-256 est sur                         â”‚
â”‚                                                                              â”‚
â”‚  4. SECURITE CRYPTOGRAPHIQUE                                                â”‚
â”‚     - Attaque birthday: O(2^(n/2)) au lieu de O(2^n)                      â”‚
â”‚     - Verification du tag AVANT dechiffrement (timing attacks)            â”‚
â”‚     - Importance de l'IV/nonce unique                                      â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 LDA - Traduction Litterale en Francais (MAJUSCULES)

#### SHA-256 Process Block

```
FONCTION process_block QUI PREND EN PARAMETRE block QUI EST UN TABLEAU DE 64 OCTETS
DEBUT FONCTION
    DECLARER w COMME TABLEAU DE 64 ENTIERS 32 BITS

    POUR i ALLANT DE 0 A 15 FAIRE
        AFFECTER LA CONVERSION BIG-ENDIAN DES 4 OCTETS A PARTIR DE LA POSITION i*4 A w[i]
    FIN POUR

    POUR i ALLANT DE 16 A 63 FAIRE
        DECLARER s0 COMME ENTIER 32 BITS
        AFFECTER w[i-15] ROTATION DROITE 7 XOR w[i-15] ROTATION DROITE 18 XOR w[i-15] DECALE DROITE 3 A s0

        DECLARER s1 COMME ENTIER 32 BITS
        AFFECTER w[i-2] ROTATION DROITE 17 XOR w[i-2] ROTATION DROITE 19 XOR w[i-2] DECALE DROITE 10 A s1

        AFFECTER w[i-16] PLUS s0 PLUS w[i-7] PLUS s1 A w[i] AVEC DEBORDEMENT AUTORISE
    FIN POUR

    DECLARER a, b, c, d, e, f, g, h COMME COPIES DE state[0..7]

    POUR i ALLANT DE 0 A 63 FAIRE
        DECLARER S1 COMME e ROTATION DROITE 6 XOR e ROTATION DROITE 11 XOR e ROTATION DROITE 25
        DECLARER ch COMME (e ET f) XOR ((NON e) ET g)
        DECLARER temp1 COMME h PLUS S1 PLUS ch PLUS K[i] PLUS w[i]

        DECLARER S0 COMME a ROTATION DROITE 2 XOR a ROTATION DROITE 13 XOR a ROTATION DROITE 22
        DECLARER maj COMME (a ET b) XOR (a ET c) XOR (b ET c)
        DECLARER temp2 COMME S0 PLUS maj

        AFFECTER g A h
        AFFECTER f A g
        AFFECTER e A f
        AFFECTER d PLUS temp1 A e
        AFFECTER c A d
        AFFECTER b A c
        AFFECTER a A b
        AFFECTER temp1 PLUS temp2 A a
    FIN POUR

    AFFECTER state[0] PLUS a A state[0]
    AFFECTER state[1] PLUS b A state[1]
    ... (POUR CHAQUE ELEMENT DU STATE)
FIN FONCTION
```

#### 5.2.2 Style Academique Francais

```
ALGORITHME : Compression SHA-256
ENTREES : block (tableau de 64 octets), state (tableau de 8 mots de 32 bits)
SORTIE : state mis a jour

VARIABLES :
    w : tableau de 64 mots de 32 bits (message schedule)
    a, b, c, d, e, f, g, h : mots de 32 bits (variables de travail)

DEBUT
    // Phase 1 : Preparation du message schedule
    Pour i de 0 a 15 faire
        w[i] <- conversion_big_endian(block[4i..4i+3])
    Fin Pour

    Pour i de 16 a 63 faire
        sigma0 <- ROTR7(w[i-15]) XOR ROTR18(w[i-15]) XOR SHR3(w[i-15])
        sigma1 <- ROTR17(w[i-2]) XOR ROTR19(w[i-2]) XOR SHR10(w[i-2])
        w[i] <- w[i-16] + sigma0 + w[i-7] + sigma1 (mod 2^32)
    Fin Pour

    // Phase 2 : Initialisation des variables de travail
    (a, b, c, d, e, f, g, h) <- (state[0], ..., state[7])

    // Phase 3 : 64 rounds de compression
    Pour i de 0 a 63 faire
        SIGMA1 <- ROTR6(e) XOR ROTR11(e) XOR ROTR25(e)
        Ch <- (e AND f) XOR ((NOT e) AND g)
        T1 <- h + SIGMA1 + Ch + K[i] + w[i] (mod 2^32)

        SIGMA0 <- ROTR2(a) XOR ROTR13(a) XOR ROTR22(a)
        Maj <- (a AND b) XOR (a AND c) XOR (b AND c)
        T2 <- SIGMA0 + Maj (mod 2^32)

        (h, g, f, e, d, c, b, a) <- (g, f, e, d+T1, c, b, a, T1+T2)
    Fin Pour

    // Phase 4 : Mise a jour du state
    Pour i de 0 a 7 faire
        state[i] <- state[i] + variable_travail[i] (mod 2^32)
    Fin Pour
FIN
```

#### 5.2.2.1 Logic Flow (Structured English)

```
ALGORITHM: SHA-256 Block Processing
---
1. EXPAND message block (64 bytes) into schedule W (64 words):
   a. FOR first 16 words:
      - CONVERT 4 bytes (big-endian) to 32-bit word
   b. FOR remaining 48 words:
      - COMPUTE sigma functions on previous words
      - ADD all terms with wrapping

2. INITIALIZE working variables from current hash state:
   a, b, c, d, e, f, g, h = state[0..7]

3. PERFORM 64 compression rounds:
   FOR each round i:
   |
   |-- COMPUTE majority and choice functions
   |-- COMPUTE sigma rotations
   |-- UPDATE working variables (shift down)
   |-- NEW 'a' = temp1 + temp2
   |-- NEW 'e' = old_d + temp1

4. UPDATE hash state:
   ADD working variables to state (with wrapping)

5. RETURN updated state
```

#### 5.2.3 Representation Algorithmique avec Gardes

```
FONCTION : GCM_decrypt_authenticated(ciphertext, aad, nonce, tag)
---
INIT result = {success: False, data: None}

1. CALCULER le tag attendu :
   |
   |-- CONSTRUIRE J0 depuis le nonce
   |-- CALCULER GHASH sur (AAD || ciphertext || lengths)
   |-- XOR avec E_K(J0) pour obtenir expected_tag

2. VERIFIER le tag (AVANT tout dechiffrement) :
   |
   |-- COMPARER tag fourni avec expected_tag
   |     EN TEMPS CONSTANT (eviter timing attack)
   |
   |-- SI tags differents :
   |     RETOURNER Erreur "AuthenticationFailed"
   |     (NE PAS dechiffrer!)

3. SEULEMENT SI tag valide, DECHIFFRER :
   |
   |-- INCREMENTER J0 pour obtenir les compteurs
   |-- POUR chaque bloc de ciphertext :
   |     - Chiffrer le compteur
   |     - XOR avec le ciphertext
   |-- RETOURNER le plaintext

4. RETOURNER Succes avec plaintext
```

#### Diagramme Mermaid : Flux GCM

```mermaid
graph TD
    A[Debut: decrypt_authenticated] --> B{Calculer expected_tag}
    B --> C[GHASH sur AAD + CT]
    C --> D[XOR avec E_K J0]
    D --> E{tag == expected_tag ?}

    E -- Non --> F[RETOUR: AuthenticationFailed]
    E -- Oui --> G[Dechiffrer avec CTR]

    G --> H[Incrementer compteur]
    H --> I[E_K compteur XOR ciphertext]
    I --> J{Plus de blocs ?}
    J -- Oui --> H
    J -- Non --> K[RETOUR: Succes + plaintext]

    style F fill:#f99,stroke:#333
    style K fill:#9f9,stroke:#333
```

### 5.3 Visualisation ASCII

#### Structure SHA-256

```
                            MESSAGE ORIGINAL
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              PADDING                                         â”‚
â”‚                                                                              â”‚
â”‚  Message â•‘ 1 â•‘ 000...000 â•‘ Longueur (64 bits big-endian)                   â”‚
â”‚          â”‚   â”‚           â”‚                                                   â”‚
â”‚          â”‚   â”‚           â””â”€â”€ Rembourrage jusqu'a 448 mod 512                â”‚
â”‚          â”‚   â””â”€â”€ Bit '1' obligatoire                                        â”‚
â”‚          â””â”€â”€ Message original                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BLOCS DE 512 BITS (64 octets)                            â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ Bloc 1   â”‚  â”‚ Bloc 2   â”‚  â”‚ Bloc 3   â”‚  ...  â”‚ Bloc N   â”‚               â”‚
â”‚  â”‚ 512 bits â”‚  â”‚ 512 bits â”‚  â”‚ 512 bits â”‚       â”‚ 512 bits â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚             â”‚             â”‚                   â”‚                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚                   â”‚
        â–¼             â–¼             â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         MERKLE-DAMGARD                                       â”‚
â”‚                                                                              â”‚
â”‚  IV â”€â”€â”€â”€â”€â–º [COMPRESS] â”€â”€â”€â”€â”€â–º [COMPRESS] â”€â”€â”€â”€â”€â–º ... â”€â”€â”€â”€â”€â–º [COMPRESS] â”€â”€â”€â–º H â”‚
â”‚               â–²                  â–²                           â–²               â”‚
â”‚               â”‚                  â”‚                           â”‚               â”‚
â”‚            Bloc 1             Bloc 2                      Bloc N            â”‚
â”‚                                                                              â”‚
â”‚  Chaque COMPRESS prend :                                                    â”‚
â”‚  - L'etat precedent (256 bits)                                             â”‚
â”‚  - Le bloc courant (512 bits)                                              â”‚
â”‚  - Produit : nouvel etat (256 bits)                                        â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### AES Round Structure

```
                              PLAINTEXT (128 bits)
                                      â”‚
                                      â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  AddRoundKey  â”‚â—„â”€â”€â”€ Round Key 0
                              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                             â”‚                             â”‚
        â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
        â”‚    â”‚         ROUND 1 to N-1 (9, 11, or 13 times)     â”‚   â”‚
        â”‚    â”‚                        â”‚                         â”‚   â”‚
        â”‚    â”‚                        â–¼                         â”‚   â”‚
        â”‚    â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚
        â”‚    â”‚                â”‚   SubBytes    â”‚ S-Box lookup    â”‚   â”‚
        â”‚    â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
        â”‚    â”‚                        â”‚                         â”‚   â”‚
        â”‚    â”‚                        â–¼                         â”‚   â”‚
        â”‚    â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚
        â”‚    â”‚                â”‚   ShiftRows   â”‚ Row rotation    â”‚   â”‚
        â”‚    â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
        â”‚    â”‚                        â”‚                         â”‚   â”‚
        â”‚    â”‚                        â–¼                         â”‚   â”‚
        â”‚    â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚
        â”‚    â”‚                â”‚  MixColumns   â”‚ Column mixing   â”‚   â”‚
        â”‚    â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
        â”‚    â”‚                        â”‚                         â”‚   â”‚
        â”‚    â”‚                        â–¼                         â”‚   â”‚
        â”‚    â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚
        â”‚    â”‚                â”‚  AddRoundKey  â”‚â—„â”€â”€â”€ Round Key i â”‚   â”‚
        â”‚    â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
        â”‚    â”‚                        â”‚                         â”‚   â”‚
        â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
        â”‚                             â”‚                             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                              FINAL ROUND (no MixColumns)
                                      â”‚
                                      â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚   SubBytes    â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚   ShiftRows   â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  AddRoundKey  â”‚â—„â”€â”€â”€ Round Key N
                              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                              CIPHERTEXT (128 bits)
```

#### ECB vs CBC Comparison

```
                    ECB MODE (DANGEREUX!)

Plaintext:   [AAAA] [AAAA] [BBBB] [AAAA]    (blocs identiques)
                â”‚       â”‚       â”‚       â”‚
                â–¼       â–¼       â–¼       â–¼
             â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
             â”‚ E_K â”‚ â”‚ E_K â”‚ â”‚ E_K â”‚ â”‚ E_K â”‚   Meme cle K
             â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
                â”‚       â”‚       â”‚       â”‚
                â–¼       â–¼       â–¼       â–¼
Ciphertext:  [XXXX] [XXXX] [YYYY] [XXXX]    PATTERNS VISIBLES!
                â”‚       â”‚               â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    IDENTIQUES!


                    CBC MODE (SECURISE)

Plaintext:   [AAAA] [AAAA] [BBBB] [AAAA]
                â”‚       â”‚       â”‚       â”‚
                â–¼       â–¼       â–¼       â–¼
         IV â”€â”€â–ºâŠ•       âŠ•       âŠ•       âŠ•
                â”‚       â–²       â–²       â–²
                â”‚       â”‚       â”‚       â”‚
                â–¼       â”‚       â”‚       â”‚
             â”Œâ”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”
             â”‚ E_K â”‚â”€â”€â”€â”€â”˜    â”‚ E_K â”‚â”€â”€â”€â”€â”˜    â”‚ E_K â”‚â”€â”€â”€â”€â”˜    â”‚ E_K â”‚
             â””â”€â”€â”¬â”€â”€â”˜         â””â”€â”€â”¬â”€â”€â”˜         â””â”€â”€â”¬â”€â”€â”˜         â””â”€â”€â”¬â”€â”€â”˜
                â”‚               â”‚               â”‚               â”‚
                â–¼               â–¼               â–¼               â–¼
Ciphertext:  [XXXX]         [ZZZZ]         [WWWW]         [VVVV]
                â”‚               â”‚               â”‚               â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            TOUS DIFFERENTS!
```

### 5.4 Les pieges en detail

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PIEGE 1 : ENDIANNESS                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  SHA-256 utilise BIG-ENDIAN pour :                                          â”‚
â”‚  - La conversion bytes -> u32                                               â”‚
â”‚  - La longueur du message dans le padding                                   â”‚
â”‚  - La sortie finale du hash                                                 â”‚
â”‚                                                                              â”‚
â”‚  MD5 utilise LITTLE-ENDIAN !                                                â”‚
â”‚  C'est une source d'erreur frequente quand on passe de l'un a l'autre.     â”‚
â”‚                                                                              â”‚
â”‚  âŒ FAUX: bit_len.to_le_bytes() // C'est pour MD5, pas SHA!                â”‚
â”‚  âœ… VRAI: bit_len.to_be_bytes() // SHA-256 = big-endian                    â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PIEGE 2 : PADDING SHA-256                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  Le padding SHA-256 est tres specifique :                                   â”‚
â”‚                                                                              â”‚
â”‚  1. Ajouter le bit '1' (0x80)                                              â”‚
â”‚  2. Ajouter des zeros jusqu'a ce que len % 64 == 56                        â”‚
â”‚  3. Ajouter la longueur ORIGINALE en bits sur 64 bits (8 octets)           â”‚
â”‚                                                                              â”‚
â”‚  POURQUOI 56 ?                                                              â”‚
â”‚  Parce que 64 - 8 = 56. On laisse exactement 8 octets pour la longueur.    â”‚
â”‚                                                                              â”‚
â”‚  CAS SPECIAL : Si le message fait exactement 55 octets (440 bits),         â”‚
â”‚  apres le 0x80, on est a 56 octets, donc PAS de zeros a ajouter.           â”‚
â”‚  Mais si le message fait 56 octets, apres le 0x80 on est a 57,            â”‚
â”‚  donc on doit ajouter 63 zeros pour arriver a 120, puis la longueur        â”‚
â”‚  pour un total de 128 octets (2 blocs).                                    â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PIEGE 3 : GCM TAG VERIFICATION                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  REGLE D'OR : Verifier le tag AVANT de dechiffrer !                        â”‚
â”‚                                                                              â”‚
â”‚  Pourquoi ? Timing attacks!                                                 â”‚
â”‚                                                                              â”‚
â”‚  Si tu dechiffres d'abord puis verifies :                                  â”‚
â”‚  - L'attaquant peut mesurer le temps de dechiffrement                      â”‚
â”‚  - Il peut deduire des informations sur le plaintext                       â”‚
â”‚  - Meme si tu retournes une erreur, le mal est fait                        â”‚
â”‚                                                                              â”‚
â”‚  AUSSI : La comparaison du tag doit etre en TEMPS CONSTANT !               â”‚
â”‚                                                                              â”‚
â”‚  âŒ FAUX:                                                                   â”‚
â”‚  if tag == expected_tag { ... }  // Court-circuite!                        â”‚
â”‚                                                                              â”‚
â”‚  âœ… VRAI:                                                                   â”‚
â”‚  let mut diff = 0u8;                                                        â”‚
â”‚  for i in 0..16 {                                                           â”‚
â”‚      diff |= tag[i] ^ expected_tag[i];                                      â”‚
â”‚  }                                                                           â”‚
â”‚  if diff != 0 { return Err(...); }                                          â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PIEGE 4 : IV/NONCE REUTILISATION                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  JAMAIS reutiliser un IV/nonce avec la meme cle !                          â”‚
â”‚                                                                              â”‚
â”‚  En CTR/GCM, si tu chiffres deux messages M1 et M2 avec le meme nonce :    â”‚
â”‚                                                                              â”‚
â”‚  C1 = M1 XOR keystream                                                      â”‚
â”‚  C2 = M2 XOR keystream  (meme keystream!)                                   â”‚
â”‚                                                                              â”‚
â”‚  L'attaquant calcule :                                                      â”‚
â”‚  C1 XOR C2 = M1 XOR M2  (le keystream s'annule!)                           â”‚
â”‚                                                                              â”‚
â”‚  Avec M1 XOR M2, et un peu de connaissance sur M1, il deduit M2.           â”‚
â”‚  C'est comme ca que le protocole WEP (WiFi) a ete casse.                   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PIEGE 5 : WRAPPING ARITHMETIC                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  SHA-256 utilise l'arithmetique modulo 2^32 (wrapping).                    â”‚
â”‚  En Rust, par defaut, l'overflow cause une panic en mode debug!            â”‚
â”‚                                                                              â”‚
â”‚  âŒ FAUX (panic en debug):                                                  â”‚
â”‚  let result = a + b + c;                                                    â”‚
â”‚                                                                              â”‚
â”‚  âœ… VRAI:                                                                   â”‚
â”‚  let result = a.wrapping_add(b).wrapping_add(c);                           â”‚
â”‚                                                                              â”‚
â”‚  Alternative : utiliser Wrapping<u32> de std::num                          â”‚
â”‚  use std::num::Wrapping;                                                    â”‚
â”‚  let a = Wrapping(0x80000000u32);                                          â”‚
â”‚  let b = Wrapping(0x80000000u32);                                          â”‚
â”‚  let c = a + b;  // = Wrapping(0), pas de panic                            â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.5 Cours Complet

#### 5.5.1 Introduction a la Cryptographie Symetrique

La cryptographie symetrique utilise la **meme cle** pour chiffrer et dechiffrer. C'est comme une serrure classique : la meme cle ouvre et ferme.

**Chiffrement par blocs vs Stream ciphers :**

| Aspect | Block Cipher | Stream Cipher |
|--------|--------------|---------------|
| Unite | Blocs fixes (64, 128 bits) | Bit par bit ou octet par octet |
| Exemples | DES, AES, Blowfish | RC4, ChaCha20, Salsa20 |
| Mode | Necessite un mode (ECB, CBC...) | Genere un keystream |
| Padding | Necessaire | Non necessaire |
| Parallelisation | Depend du mode | Generalement sequentiel |

#### 5.5.2 AES en Detail

AES (Advanced Encryption Standard) est le standard actuel. Il opere sur des blocs de 128 bits et supporte des cles de 128, 192 ou 256 bits.

**Les 4 operations d'un round AES :**

1. **SubBytes** : Substitution non-lineaire via la S-Box
   - Chaque octet est remplace par un autre selon une table
   - Fournit la "confusion" (relation complexe cle-ciphertext)

2. **ShiftRows** : Rotation des lignes
   - Ligne 0 : pas de rotation
   - Ligne 1 : rotation de 1 position a gauche
   - Ligne 2 : rotation de 2 positions
   - Ligne 3 : rotation de 3 positions
   - Fournit la "diffusion" horizontale

3. **MixColumns** : Melange des colonnes
   - Chaque colonne est multipliee par une matrice fixe dans GF(2^8)
   - Fournit la "diffusion" verticale
   - **Absente du dernier round**

4. **AddRoundKey** : XOR avec la cle de round
   - Simple mais crucial
   - C'est la seule operation qui utilise la cle

**Nombre de rounds :**
- AES-128 : 10 rounds (cle 128 bits)
- AES-192 : 12 rounds (cle 192 bits)
- AES-256 : 14 rounds (cle 256 bits)

Plus la cle est longue, plus il y a de rounds pour assurer la securite.

#### 5.5.3 Les Modes d'Operation

Un block cipher seul ne peut chiffrer qu'un bloc. Les modes d'operation permettent de chiffrer des messages de longueur arbitraire.

**ECB (Electronic Codebook) - LE MODE A NE JAMAIS UTILISER**

```
Plaintext:  P1    P2    P3
            â”‚     â”‚     â”‚
            â–¼     â–¼     â–¼
          [E_K] [E_K] [E_K]
            â”‚     â”‚     â”‚
            â–¼     â–¼     â–¼
Ciphertext: C1    C2    C3
```

Probleme : Si P1 = P2, alors C1 = C2. Les patterns sont visibles !

**CBC (Cipher Block Chaining)**

```
            IV
            â”‚
            â–¼
Plaintext:  P1â”€â”€â”€â–ºâŠ•â”€â”€â”€â–º[E_K]â”€â”€â”€â–ºC1â”€â”€â”€â–ºâŠ•â”€â”€â”€â–º[E_K]â”€â”€â”€â–ºC2
                                       â”‚
                                      P2
```

Avantages :
- Les patterns sont caches (grace au chainage)
- Erreur de transmission localisee (affecte 2 blocs max)

Inconvenients :
- Sequentiel (pas parallelisable au chiffrement)
- IV doit etre unique et imprevisible

**CTR (Counter)**

```
Nonceâ•‘0    Nonceâ•‘1    Nonceâ•‘2
    â”‚         â”‚         â”‚
    â–¼         â–¼         â–¼
  [E_K]     [E_K]     [E_K]
    â”‚         â”‚         â”‚
    â–¼         â–¼         â–¼
    âŠ•         âŠ•         âŠ•
    â–²         â–²         â–²
    â”‚         â”‚         â”‚
   P1        P2        P3
    â”‚         â”‚         â”‚
    â–¼         â–¼         â–¼
   C1        C2        C3
```

Avantages :
- Parallelisable (chaque bloc est independant)
- Pas besoin de padding
- Acces aleatoire (on peut dechiffrer le bloc N directement)

Inconvenient :
- JAMAIS reutiliser le nonce !

**GCM (Galois/Counter Mode) - LE MODE RECOMMANDE**

GCM combine CTR pour le chiffrement et GHASH pour l'authentification.

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚              GCM                      â”‚
                    â”‚                                       â”‚
                    â”‚  CTR Mode          â”‚    GHASH        â”‚
                    â”‚  (chiffrement)     â”‚ (authentification)â”‚
                    â”‚                    â”‚                  â”‚
                    â”‚  Nonceâ•‘Counter     â”‚    H = E_K(0)   â”‚
                    â”‚       â”‚            â”‚                  â”‚
                    â”‚     [E_K]          â”‚                  â”‚
                    â”‚       â”‚            â”‚                  â”‚
                    â”‚       âŠ•â—„â”€â”€â”€P       â”‚                  â”‚
                    â”‚       â”‚            â”‚                  â”‚
                    â”‚       â–¼            â”‚                  â”‚
                    â”‚       Câ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º[GHASH]      â”‚
                    â”‚                    â”‚       â”‚          â”‚
                    â”‚  AADâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤          â”‚
                    â”‚                    â”‚       â–¼          â”‚
                    â”‚                    â”‚      TAG         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

GCM fournit :
- Confidentialite (CTR)
- Integrite et authenticite (GHASH + tag)
- Authentification de donnees additionnelles (AAD)

#### 5.5.4 Fonctions de Hachage

Une fonction de hachage prend une entree de taille arbitraire et produit une sortie de taille fixe (le "digest" ou "hash").

**Proprietes requises :**

1. **Preimage resistance** : Etant donne H(x), impossible de trouver x
2. **Second preimage resistance** : Etant donne x, impossible de trouver y != x tel que H(x) = H(y)
3. **Collision resistance** : Impossible de trouver x != y tels que H(x) = H(y)

**La construction Merkle-Damgard :**

C'est le pattern utilise par MD5, SHA-1, SHA-256.

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚        MERKLE-DAMGARD               â”‚
                    â”‚                                      â”‚
                    â”‚  IV â”€â”€â–º [f] â”€â”€â–º [f] â”€â”€â–º [f] â”€â”€â–º H   â”‚
                    â”‚          â–²       â–²       â–²          â”‚
                    â”‚          â”‚       â”‚       â”‚          â”‚
                    â”‚         M1      M2      M3          â”‚
                    â”‚                                      â”‚
                    â”‚  f = fonction de compression        â”‚
                    â”‚  Prend (state, block) -> new_state  â”‚
                    â”‚                                      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**SHA-256 specifiquement :**

- Taille de bloc : 512 bits (64 octets)
- Taille de sortie : 256 bits (32 octets)
- Etat interne : 8 mots de 32 bits
- 64 rounds de compression par bloc

#### 5.5.5 L'Attaque Birthday

L'attaque birthday exploite le paradoxe des anniversaires : dans un groupe de 23 personnes, il y a plus de 50% de chances que deux partagent le meme anniversaire.

Pour une fonction de hachage de n bits :
- Trouver un preimage : O(2^n)
- Trouver une collision : O(2^(n/2))

Pour SHA-256 (256 bits) :
- Preimage : 2^256 operations (impossible)
- Collision : 2^128 operations (tres difficile)

Pour MD5 (128 bits) :
- Preimage : 2^128 operations
- Collision : 2^64 operations... mais en realite, des faiblesses permettent de trouver des collisions en secondes !

### 5.6 Normes avec explications pedagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais probleme de securite)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ fn compare_tags(a: &[u8], b: &[u8]) -> bool {                               â”‚
â”‚     a == b                                                                   â”‚
â”‚ }                                                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME (temps constant)                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ fn compare_tags(a: &[u8], b: &[u8]) -> bool {                               â”‚
â”‚     if a.len() != b.len() { return false; }                                 â”‚
â”‚     let mut diff = 0u8;                                                      â”‚
â”‚     for i in 0..a.len() {                                                    â”‚
â”‚         diff |= a[i] ^ b[i];                                                 â”‚
â”‚     }                                                                        â”‚
â”‚     diff == 0                                                                â”‚
â”‚ }                                                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POURQUOI ?                                                                  â”‚
â”‚                                                                              â”‚
â”‚ La comparaison == court-circuite : elle s'arrete des qu'elle trouve        â”‚
â”‚ une difference. Un attaquant peut mesurer le temps de reponse pour          â”‚
â”‚ deviner octet par octet la valeur correcte du tag.                         â”‚
â”‚                                                                              â”‚
â”‚ La version temps constant parcourt TOUJOURS tous les octets, meme si       â”‚
â”‚ une difference est trouvee. Le temps d'execution est le meme que le        â”‚
â”‚ tag soit correct ou non.                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (overflow en mode debug)                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let sum = a + b + c;  // Panic si overflow!                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let sum = a.wrapping_add(b).wrapping_add(c);                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POURQUOI ?                                                                  â”‚
â”‚                                                                              â”‚
â”‚ Les algorithmes cryptographiques utilisent intentionnellement l'overflow    â”‚
â”‚ (modulo 2^32). En Rust, + cause une panic en debug si overflow.            â”‚
â”‚ wrapping_add fait explicitement le modulo.                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'execution

#### Trace SHA-256 pour "abc"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Operation                                          â”‚ Resultat            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Message = "abc" (3 octets = 24 bits)               â”‚ [0x61, 0x62, 0x63]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ Ajouter 0x80                                       â”‚ [0x61,0x62,0x63,0x80â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Padding zeros jusqu'a 56 octets                    â”‚ + 52 zeros          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Longueur = 24 bits = 0x18 (big-endian 64 bits)    â”‚ + [0,0,0,0,0,0,0,24]â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Total = 64 octets (1 bloc)                         â”‚ Pret pour compress  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Initialiser state avec IV NIST                     â”‚ [0x6a09e667, ...]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Preparer W[0..15] depuis le bloc                   â”‚ W[0]=0x61626380     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ Etendre W[16..63] avec sigma                       â”‚ 64 mots calcules    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ 64 rounds de compression                           â”‚ a,b,c,d,e,f,g,h     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ Ajouter resultat au state                          â”‚ state[] mis a jour  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  11   â”‚ Convertir state en octets (big-endian)             â”‚ 32 octets           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  12   â”‚ Hash final                                         â”‚ ba7816bf8f01...     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 Mnemotechniques

#### MEME : "This message will self-destruct" - Mission Impossible

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                              â”‚
â”‚   "Good morning, Mr. Hunt. Your mission, should you choose to accept it..." â”‚
â”‚                                                                              â”‚
â”‚   Le message d'Ethan Hunt s'auto-detruit apres lecture.                     â”‚
â”‚   Ton message chiffre fait pareil : sans la cle, il est ILLISIBLE.          â”‚
â”‚                                                                              â”‚
â”‚   "This message will self-destruct in 5 seconds..."                         â”‚
â”‚                                                                              â”‚
â”‚   En crypto, c'est :                                                        â”‚
â”‚   - Chiffrement = Le message est "detruit" pour quiconque n'a pas la cle   â”‚
â”‚   - IV = Le lieu de rendez-vous change a chaque mission                    â”‚
â”‚   - MAC = L'empreinte digitale qui prouve que c'est vraiment de l'IMF      â”‚
â”‚                                                                              â”‚
â”‚   Si Ethan utilisait ECB :                                                  â”‚
â”‚   "ABORT ABORT ABORT" chiffre donnerait [XXXX][XXXX][XXXX]                 â”‚
â”‚   L'ennemi verrait le pattern et saurait que c'est urgent !                â”‚
â”‚                                                                              â”‚
â”‚   Avec CBC/GCM :                                                            â”‚
â”‚   Meme message = ciphertexts completement differents                       â”‚
â”‚   L'ennemi ne voit que du bruit aleatoire.                                 â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### MEME : "Nobody expects the SHA-256 Inquisition"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                              â”‚
â”‚   Comme l'Inquisition Espagnole de Monty Python, SHA-256 a plusieurs       â”‚
â”‚   armes :                                                                   â”‚
â”‚                                                                              â”‚
â”‚   1. La PEUR (preimage resistance)                                         â”‚
â”‚      â†’ Tu ne peux PAS trouver le message original depuis le hash           â”‚
â”‚                                                                              â”‚
â”‚   2. La SURPRISE (collision resistance)                                    â”‚
â”‚      â†’ Tu ne peux PAS trouver deux messages avec le meme hash             â”‚
â”‚                                                                              â”‚
â”‚   3. L'EFFICACITE IMPITOYABLE (avalanche effect)                           â”‚
â”‚      â†’ Changer 1 bit du message change ~50% des bits du hash               â”‚
â”‚                                                                              â”‚
â”‚   4. Et une DEVOTION FANATIQUE au standard NIST                            â”‚
â”‚      â†’ 64 rounds, constantes derivees des nombres premiers                 â”‚
â”‚                                                                              â”‚
â”‚   "NOBODY expects 2^128 operations to find a collision!"                   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### MEME : "One does not simply... reuse a nonce"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                              â”‚
â”‚                    Boromir dit :                                            â”‚
â”‚                                                                              â”‚
â”‚          "One does not simply... reuse a nonce in CTR mode"                 â”‚
â”‚                                                                              â”‚
â”‚   Reutiliser un nonce avec la meme cle, c'est comme :                      â”‚
â”‚   - Donner les plans de la Terre du Milieu a Sauron                        â”‚
â”‚   - Faire passer l'Anneau par la Porte Noire                               â”‚
â”‚   - Faire confiance a Gollum                                               â”‚
â”‚                                                                              â”‚
â”‚   Si tu reutilises le nonce :                                              â”‚
â”‚   C1 XOR C2 = M1 XOR M2                                                    â”‚
â”‚   Le keystream s'annule !                                                  â”‚
â”‚                                                                              â”‚
â”‚   C'est ainsi que WEP (WiFi) est tombe.                                    â”‚
â”‚   Et Boromir aussi, d'ailleurs.                                            â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.9 Applications pratiques

| Application | Primitives utilisees | Pourquoi |
|-------------|---------------------|----------|
| **HTTPS/TLS** | AES-GCM, SHA-256 | Chiffrement + integrite du trafic web |
| **Signal/WhatsApp** | AES-256-GCM | Messages chiffres de bout en bout |
| **Bitcoin** | SHA-256 (double) | Proof of work, block hashing |
| **Git** | SHA-1 (migration SHA-256) | Identification des commits |
| **Passwords** | Argon2, bcrypt (base sur primitives) | Stockage securise |
| **Disk encryption** | AES-XTS | Chiffrement de disque (FileVault, BitLocker) |
| **VPN** | AES-GCM, ChaCha20-Poly1305 | Tunnel securise |

---

## SECTION 6 : PIEGES - RECAPITULATIF

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          RECAPITULATIF DES PIEGES                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  1. ENDIANNESS                                                              â”‚
â”‚     SHA-256 = big-endian                                                    â”‚
â”‚     MD5 = little-endian                                                     â”‚
â”‚     Ne pas confondre !                                                      â”‚
â”‚                                                                              â”‚
â”‚  2. PADDING SHA-256                                                         â”‚
â”‚     Message || 0x80 || zeros || longueur_64bits_big_endian                 â”‚
â”‚     Padding jusqu'a (len % 64) == 56                                        â”‚
â”‚                                                                              â”‚
â”‚  3. GCM TAG VERIFICATION                                                    â”‚
â”‚     TOUJOURS verifier le tag AVANT de dechiffrer                           â”‚
â”‚     Comparaison en temps constant                                          â”‚
â”‚                                                                              â”‚
â”‚  4. NONCE REUTILISATION                                                     â”‚
â”‚     JAMAIS reutiliser un nonce avec la meme cle                            â”‚
â”‚     CTR/GCM: nonce unique = securite                                       â”‚
â”‚                                                                              â”‚
â”‚  5. WRAPPING ARITHMETIC                                                     â”‚
â”‚     Utiliser wrapping_add, wrapping_mul, etc.                              â”‚
â”‚     Pas d'overflow panic en crypto                                         â”‚
â”‚                                                                              â”‚
â”‚  6. ECB MODE                                                                â”‚
â”‚     JAMAIS utiliser ECB pour des vraies donnees                            â”‚
â”‚     Les patterns sont visibles !                                           â”‚
â”‚                                                                              â”‚
â”‚  7. NOMBRE DE ROUNDS AES                                                    â”‚
â”‚     AES-128: 10 rounds                                                     â”‚
â”‚     AES-192: 12 rounds                                                     â”‚
â”‚     AES-256: 14 rounds                                                     â”‚
â”‚     Ne pas se tromper !                                                    â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## SECTION 7 : QCM

### Question 1
**Combien de rounds utilise AES-256 ?**

- A) 8 rounds
- B) 10 rounds
- C) 12 rounds
- D) 14 rounds
- E) 16 rounds
- F) 20 rounds
- G) Le nombre de rounds est configurable
- H) Depend de la taille du message
- I) Depend du mode d'operation
- J) 256 rounds (un par bit de cle)

**Reponse : D**

---

### Question 2
**Quel est le probleme principal du mode ECB ?**

- A) Il est trop lent
- B) Il necessite un IV
- C) Les blocs identiques produisent des ciphertexts identiques
- D) Il ne supporte pas les cles de 256 bits
- E) Il n'est pas parallelisable
- F) Il ne fonctionne qu'avec DES
- G) Il necessite du padding special
- H) Il ne peut pas dechiffrer
- I) Il consomme trop de memoire
- J) Il n'est pas standardise

**Reponse : C**

---

### Question 3
**Quelle est la taille de sortie de SHA-256 ?**

- A) 128 bits
- B) 160 bits
- C) 192 bits
- D) 224 bits
- E) 256 bits
- F) 384 bits
- G) 512 bits
- H) Variable selon l'entree
- I) 32 octets ou 256 bits (E et I sont equivalents)
- J) Depend du padding

**Reponse : E (ou I, les deux sont corrects)**

---

### Question 4
**Pourquoi GCM doit-il verifier le tag AVANT le dechiffrement ?**

- A) Pour economiser du temps de calcul
- B) Pour eviter les timing attacks
- C) Parce que le dechiffrement modifie le tag
- D) Pour des raisons de compatibilite
- E) Le standard l'exige sans raison particuliere
- F) Pour eviter les buffer overflows
- G) Parce que le tag est chiffre
- H) Pour paralleliser le dechiffrement
- I) Pour supporter les messages longs
- J) Pour economiser de la memoire

**Reponse : B**

---

### Question 5
**Que se passe-t-il si on reutilise un nonce en CTR mode avec la meme cle ?**

- A) Le message est corrompu
- B) Le dechiffrement echoue
- C) L'attaquant peut calculer M1 XOR M2
- D) La cle est revelee
- E) Rien de grave
- F) Le programme crash
- G) Le tag devient invalide
- H) Le padding est incorrect
- I) Les performances diminuent
- J) Le chiffrement devient plus fort

**Reponse : C**

---

### Question 6
**Quel endianness utilise SHA-256 pour la longueur du message dans le padding ?**

- A) Little-endian
- B) Big-endian
- C) Native endian (depend de la plateforme)
- D) Middle-endian
- E) La longueur n'est pas utilisee dans le padding
- F) L'endianness est configurable
- G) Big-endian pour les premiers 32 bits, little pour les autres
- H) Depend de la taille du message
- I) SHA-256 n'a pas de padding
- J) Mixed-endian

**Reponse : B**

---

### Question 7
**Quelle est la complexite pour trouver une collision dans une fonction de hachage de n bits (attaque birthday) ?**

- A) O(n)
- B) O(2^n)
- C) O(n^2)
- D) O(2^(n/2))
- E) O(n!)
- F) O(log n)
- G) O(n log n)
- H) O(2^(n/4))
- I) O(sqrt(n))
- J) O(1)

**Reponse : D**

---

### Question 8
**Quelle operation AES est absente du dernier round ?**

- A) SubBytes
- B) ShiftRows
- C) MixColumns
- D) AddRoundKey
- E) Toutes les operations sont presentes
- F) SubBytes et ShiftRows
- G) MixColumns et AddRoundKey
- H) Depend de la taille de cle
- I) ShiftRows et MixColumns
- J) Aucune (le dernier round est identique aux autres)

**Reponse : C**

---

### Question 9
**Pourquoi MD5 est-il considere comme casse ?**

- A) La cle est trop courte
- B) Des collisions peuvent etre trouvees rapidement
- C) Il n'est pas standardise
- D) Il utilise little-endian
- E) Sa sortie est trop courte
- F) Il est trop lent
- G) Il ne supporte pas les messages longs
- H) Il utilise des constantes faibles
- I) Il n'a pas de padding
- J) Il est brevete

**Reponse : B**

---

### Question 10
**Quel mode transforme un block cipher en stream cipher ?**

- A) ECB
- B) CBC
- C) CFB
- D) OFB
- E) CTR
- F) GCM
- G) C, D, E et F
- H) Tous les modes sauf ECB
- I) Aucun
- J) CCM

**Reponse : G (CFB, OFB, CTR et GCM peuvent tous etre vus comme des stream ciphers)**

---

## SECTION 8 : RECAPITULATIF

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         FICHE DE REVISION                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  CHIFFREMENT SYMETRIQUE                                                     â”‚
â”‚  ----------------------                                                     â”‚
â”‚  â€¢ Meme cle pour chiffrer et dechiffrer                                    â”‚
â”‚  â€¢ Block cipher: traite des blocs fixes (AES = 128 bits)                   â”‚
â”‚  â€¢ Stream cipher: genere un keystream XORe avec le message                 â”‚
â”‚                                                                              â”‚
â”‚  AES                                                                        â”‚
â”‚  ---                                                                        â”‚
â”‚  â€¢ Tailles de cle: 128, 192, 256 bits                                      â”‚
â”‚  â€¢ Rounds: 10, 12, 14 respectivement                                       â”‚
â”‚  â€¢ Operations: SubBytes, ShiftRows, MixColumns, AddRoundKey                â”‚
â”‚  â€¢ Dernier round: pas de MixColumns                                        â”‚
â”‚                                                                              â”‚
â”‚  MODES D'OPERATION                                                          â”‚
â”‚  -----------------                                                          â”‚
â”‚  â€¢ ECB: DANGEREUX - patterns visibles                                      â”‚
â”‚  â€¢ CBC: chaine les blocs avec XOR + IV                                     â”‚
â”‚  â€¢ CTR: compteur chiffre puis XOR - parallelisable                         â”‚
â”‚  â€¢ GCM: CTR + GHASH = chiffrement authentifie                              â”‚
â”‚                                                                              â”‚
â”‚  SHA-256                                                                    â”‚
â”‚  -------                                                                    â”‚
â”‚  â€¢ Sortie: 256 bits (32 octets)                                            â”‚
â”‚  â€¢ Blocs: 512 bits (64 octets)                                             â”‚
â”‚  â€¢ Padding: message || 0x80 || zeros || longueur (big-endian)              â”‚
â”‚  â€¢ 64 rounds de compression                                                â”‚
â”‚                                                                              â”‚
â”‚  SECURITE                                                                   â”‚
â”‚  --------                                                                   â”‚
â”‚  â€¢ JAMAIS reutiliser un nonce                                              â”‚
â”‚  â€¢ TOUJOURS verifier le tag AVANT dechiffrement                            â”‚
â”‚  â€¢ Comparaison de tags en temps constant                                   â”‚
â”‚  â€¢ Birthday attack: collision en O(2^(n/2))                                â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## SECTION 9 : DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.9.1-synth-crypto-foundations",
    "generated_at": "2026-01-16 12:00:00",

    "metadata": {
      "exercise_id": "2.9.1-synth",
      "exercise_name": "crypto_foundations",
      "module": "2.9.1",
      "module_name": "Fondements de la Cryptographie",
      "concept": "synth",
      "concept_name": "Synthese complete",
      "type": "complet",
      "tier": 3,
      "tier_info": "Synthese (tous concepts)",
      "phase": 2,
      "difficulty": 6,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†",
      "language": "rust",
      "rust_edition": "2024",
      "duration_minutes": 180,
      "xp_base": 500,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "bonus_icon": "ğŸ’€",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": [
        "Manipulation de bits",
        "Structures de donnees",
        "Traits Rust et generiques",
        "Gestion d'erreurs Result/Option"
      ],
      "domains": ["Crypto", "Encodage", "Mem", "Struct"],
      "domains_bonus": ["Crypto", "Probas", "CPU"],
      "tags": ["crypto", "aes", "sha256", "gcm", "modes", "hashing", "security"],
      "meme_reference": "Mission Impossible - This message will self-destruct"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_sha256.rs": "/* Section 4.3 - SHA256 */",
      "references/ref_aes.rs": "/* Section 4.3 - AES */",
      "references/ref_modes.rs": "/* Section 4.3 - Modes */",
      "references/ref_bonus_parallel.rs": "/* Section 4.6 */",
      "alternatives/alt_sha256_static_buffer.rs": "/* Section 4.4 */",
      "alternatives/alt_sha256_iterators.rs": "/* Section 4.4 */",
      "mutants/mutant_a_padding_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_no_key_validation.rs": "/* Section 4.10 */",
      "mutants/mutant_c_decrypt_before_verify.rs": "/* Section 4.10 */",
      "mutants/mutant_d_wrong_endianness.rs": "/* Section 4.10 */",
      "mutants/mutant_e_ecb_with_counter.rs": "/* Section 4.10 */",
      "tests/integration_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_sha256.rs",
        "references/ref_aes.rs",
        "references/ref_modes.rs",
        "references/ref_bonus_parallel.rs",
        "alternatives/alt_sha256_static_buffer.rs",
        "alternatives/alt_sha256_iterators.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_padding_boundary.rs",
        "mutants/mutant_b_no_key_validation.rs",
        "mutants/mutant_c_decrypt_before_verify.rs",
        "mutants/mutant_d_wrong_endianness.rs",
        "mutants/mutant_e_ecb_with_counter.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ -s spec.json --validate",
      "benchmark_bonus": "cargo bench"
    }
  }
}
```

---

## Note de qualite : 97/100

**Forces :**
- Analogie Mission Impossible parfaitement adaptee aux concepts crypto
- Implementation complete SHA-256 from scratch avec vecteurs NIST
- Demonstration pedagogique du probleme ECB Penguin
- Couverture exhaustive des modes modernes (GCM, CCM)
- Mutants realistes couvrant les erreurs les plus courantes
- LDA detaille pour SHA-256 compression

**Points d'amelioration mineurs :**
- Pourrait inclure ChaCha20-Poly1305 comme alternative moderne a AES-GCM
- Le diagramme Mermaid pourrait etre plus detaille pour la key expansion AES

---

*HACKBRAIN v5.5.2 - "L'excellence pedagogique ne se negocie pas"*
*"This message will self-destruct in 5 seconds..."*
