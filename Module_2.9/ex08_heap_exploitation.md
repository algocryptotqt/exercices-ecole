# ex08: Heap Exploitation Basics

**Module**: 2.9 - Computer Security
**Difficulte**: Expert
**Duree**: 6h
**Score qualite**: 98/100

## Concepts Couverts

### 2.9.17: Heap Exploitation (8 concepts)
| Ref | Concept | Application |
|-----|---------|-------------|
| a | Heap structure | Chunks, metadata |
| b | Free list | Linked list of free chunks |
| c | Chunk metadata | Size, prev_size, fd, bk |
| d | Bins | Fastbins, smallbins, largebins, unsorted |
| e | Heap overflow | Overwrite adjacent chunk |
| f | Metadata corruption | Overwrite size/pointers |
| g | Arbitrary write | Via corrupted pointers |
| h | Unlink attack | Classic technique |

---

## Sujet

Comprendre la structure du heap glibc et les techniques d'exploitation basiques.

### Structures

```c
// Simplified glibc malloc chunk (64-bit)
typedef struct malloc_chunk {
    size_t prev_size;            // Size of previous chunk (if free)
    size_t size;                 // Size of this chunk + flags
    struct malloc_chunk *fd;     // Forward pointer (if free)
    struct malloc_chunk *bk;     // Backward pointer (if free)
    // Additional pointers for large bins
    struct malloc_chunk *fd_nextsize;
    struct malloc_chunk *bk_nextsize;
} malloc_chunk_t;

// Chunk size flags (low 3 bits)
#define PREV_INUSE      0x1     // Previous chunk is in use
#define IS_MMAPPED      0x2     // Chunk obtained via mmap
#define NON_MAIN_ARENA  0x4     // Not from main arena

// Bin types
typedef enum {
    BIN_FASTBIN,        // <= 0x80, LIFO, no coalescing
    BIN_SMALLBIN,       // < 512 (32-bit) or 1024 (64-bit)
    BIN_LARGEBIN,       // >= small threshold
    BIN_UNSORTED,       // Recently freed, not yet sorted
    BIN_TCACHE          // Thread-local cache (glibc 2.26+)
} bin_type_t;

// Heap state for analysis
typedef struct {
    void *heap_base;
    void *heap_end;
    size_t total_size;
    int num_chunks;
    int num_free;
} heap_info_t;
```

### API

```c
// Heap visualization
void dump_chunk(void *ptr);
void dump_heap(void);
void dump_bins(void);
void dump_tcache(void);

// Chunk manipulation (educational)
size_t get_chunk_size(void *ptr);
bool is_chunk_free(void *ptr);
void *get_next_chunk(void *ptr);
void *get_prev_chunk(void *ptr);

// Exploitation helpers
void corrupt_chunk_size(void *ptr, size_t new_size);
void corrupt_fd_pointer(void *ptr, void *target);
void demonstrate_unlink(void);
```

---

## Exemple

```c
#include "heap_exploitation.h"

int main(void) {
    // 2.9.17: Heap Exploitation
    printf("=== Heap Exploitation (glibc malloc) ===\n\n");

    // Heap overview
    printf("Heap Memory:\n");
    printf("  Dynamic allocation: malloc(), free(), realloc()\n");
    printf("  Managed by glibc malloc (ptmalloc2)\n");
    printf("  Grows via brk() or mmap()\n");
    printf("\n  Why attack the heap?\n");
    printf("  - Stack protections (canaries) don't protect heap\n");
    printf("  - Heap contains function pointers, vtables\n");
    printf("  - Corruption can lead to arbitrary write\n");

    // Chunk structure
    printf("\n\nMalloc Chunk Structure (64-bit glibc):\n");
    printf("  +-----------------------+\n");
    printf("  | prev_size (8 bytes)   | <- Only valid if prev chunk free\n");
    printf("  +-----------------------+\n");
    printf("  | size | flags (8 bytes)| <- Chunk size + 3 flag bits\n");
    printf("  +-----------------------+\n");
    printf("  | User data...          | <- Returned by malloc()\n");
    printf("  | (or fd/bk if free)    |\n");
    printf("  +-----------------------+\n");

    printf("\n  Size field flags (low 3 bits):\n");
    printf("    bit 0 (PREV_INUSE):     Previous chunk is allocated\n");
    printf("    bit 1 (IS_MMAPPED):     Chunk from mmap (not heap)\n");
    printf("    bit 2 (NON_MAIN_ARENA): From non-main arena (threads)\n");

    printf("\n  Example: size = 0x91\n");
    printf("    Real size = 0x90 (144 bytes)\n");
    printf("    PREV_INUSE = 1 (prev chunk in use)\n");

    // Demonstrate chunk structure
    printf("\n\nChunk Demonstration:\n");
    void *p1 = malloc(0x80);  // 128 bytes user data
    void *p2 = malloc(0x80);

    printf("  p1 = malloc(0x80) at %p\n", p1);
    printf("  p2 = malloc(0x80) at %p\n", p2);

    dump_chunk(p1);
    dump_chunk(p2);

    // Free list concept
    printf("\n\nFree Lists:\n");
    printf("  When chunks are freed, added to free lists\n");
    printf("  malloc() searches free lists before extending heap\n");
    printf("  Different lists for different size ranges\n");

    // Bins explanation
    printf("\n\nBin Types (glibc):\n");

    printf("\n  1. FASTBINS:\n");
    printf("     Size: 0x20 - 0x80 (64-bit) step 0x10\n");
    printf("     LIFO: Last freed = first allocated\n");
    printf("     Singly-linked (fd pointer only)\n");
    printf("     NO COALESCING with neighbors\n");
    printf("     Speed optimization for small allocs\n");

    printf("\n  2. TCACHE (Thread Cache, glibc 2.26+):\n");
    printf("     Per-thread cache, even faster than fastbins\n");
    printf("     7 chunks per size (default)\n");
    printf("     Size: 0x20 - 0x410\n");
    printf("     LIFO, singly-linked\n");
    printf("     Checked BEFORE bins\n");

    printf("\n  3. UNSORTED BIN:\n");
    printf("     Holding area for recently freed chunks\n");
    printf("     Chunks sorted into small/large bins lazily\n");
    printf("     Doubly-linked (fd and bk)\n");

    printf("\n  4. SMALLBINS:\n");
    printf("     Size < 0x400 (1024 bytes, 64-bit)\n");
    printf("     62 bins, each for specific size\n");
    printf("     FIFO: First freed = first allocated\n");
    printf("     Doubly-linked\n");

    printf("\n  5. LARGEBINS:\n");
    printf("     Size >= 0x400\n");
    printf("     Sorted by size within bins\n");
    printf("     fd_nextsize/bk_nextsize for size ordering\n");

    // Free demonstration
    printf("\n\nFree Operation:\n");
    free(p1);
    printf("  free(p1)\n");
    dump_tcache();  // Shows p1 in tcache

    free(p2);
    printf("  free(p2)\n");
    dump_tcache();  // Shows p2 then p1

    // Heap overflow
    printf("\n\n=== Heap Overflow Attack ===\n\n");

    printf("Heap Overflow:\n");
    printf("  Writing beyond allocated chunk boundary\n");
    printf("  Corrupts NEXT chunk's metadata\n");

    printf("\n  Memory layout:\n");
    printf("  +-------------------+-------------------+\n");
    printf("  | Chunk A (alloc)   | Chunk B (alloc)   |\n");
    printf("  | [prev][size][data]| [prev][size][data]|\n");
    printf("  +-------------------+-------------------+\n");
    printf("  If we overflow A's data:\n");
    printf("  - Can overwrite B's prev_size and size\n");
    printf("  - Can overwrite B's fd/bk if B is free\n");

    // Metadata corruption
    printf("\n\nMetadata Corruption:\n");

    printf("\n  1. SIZE FIELD CORRUPTION:\n");
    printf("     Change chunk size to overlap with other chunks\n");
    printf("     'Overlapping chunks' attack\n");
    printf("     Can read/write other objects!\n");

    printf("\n     Example:\n");
    printf("     A = malloc(0x100)  // size = 0x110\n");
    printf("     B = malloc(0x100)  // size = 0x110\n");
    printf("     C = malloc(0x100)  // size = 0x110\n");
    printf("     // Overflow A to change B's size to 0x220\n");
    printf("     free(B)            // Free 'enlarged' B\n");
    printf("     D = malloc(0x200)  // Gets B, overlaps C!\n");

    printf("\n  2. FD/BK POINTER CORRUPTION:\n");
    printf("     Overwrite forward/backward pointers\n");
    printf("     Next malloc returns attacker-controlled address!\n");

    // Arbitrary write
    printf("\n\nArbitrary Write Primitive:\n");
    printf("  Goal: Write attacker value to attacker address\n");
    printf("  Methods:\n");
    printf("    - Corrupt fd to point to target\n");
    printf("    - malloc() returns target address\n");
    printf("    - Write to 'allocated' target\n");

    // Unlink attack
    printf("\n\n=== Classic Unlink Attack ===\n\n");

    printf("Unlink Macro (old glibc):\n");
    printf("  When coalescing free chunks:\n");
    printf("  FD = P->fd\n");
    printf("  BK = P->bk\n");
    printf("  FD->bk = BK    // Write BK to FD+0x18\n");
    printf("  BK->fd = FD    // Write FD to BK+0x10\n");

    printf("\n  Exploitation:\n");
    printf("  If we control fd and bk:\n");
    printf("    fd = target_addr - 0x18\n");
    printf("    bk = value_to_write\n");
    printf("  Then unlink writes:\n");
    printf("    *(target_addr) = value_to_write\n");
    printf("  -> ARBITRARY WRITE!\n");

    printf("\n  Modern mitigation:\n");
    printf("  if (FD->bk != P || BK->fd != P)\n");
    printf("      abort();  // Corrupted double-linked list\n");
    printf("  This check prevents classic unlink.\n");

    // Demonstration
    printf("\n\nDemonstration (Simplified):\n");

    // Allocate chunks
    char *chunk_a = malloc(0x88);  // 0x90 with header
    char *chunk_b = malloc(0x88);
    char *chunk_c = malloc(0x88);

    printf("  A at %p, B at %p, C at %p\n", chunk_a, chunk_b, chunk_c);

    // Simulate overflow from A into B's header
    printf("\n  Simulating overflow A -> B header:\n");

    // Get B's chunk header
    size_t *b_size = (size_t*)(chunk_b - 8);  // size field
    printf("  Original B size: 0x%lx\n", *b_size);

    // In real attack, overflow would do this:
    // memset(chunk_a, 'A', 0x88 + 0x10);  // Overflow into B

    printf("\n  Exploitation steps:\n");
    printf("  1. Overflow A to corrupt B's size/fd/bk\n");
    printf("  2. Set up fake chunk structure\n");
    printf("  3. Free B to trigger unlink/coalesce\n");
    printf("  4. Achieve arbitrary write\n");

    // Common heap targets
    printf("\n\nCommon Exploitation Targets:\n");
    printf("  - __malloc_hook:  Called on malloc()\n");
    printf("  - __free_hook:    Called on free()\n");
    printf("  - __realloc_hook: Called on realloc()\n");
    printf("  - GOT entries:    Function pointers\n");
    printf("  - vtables:        C++ virtual functions\n");
    printf("  - return address: On stack (need address)\n");

    printf("\n  Note: __malloc_hook etc. removed in glibc 2.34!\n");
    printf("        Modern attacks use other targets.\n");

    // Cleanup
    free(chunk_a);
    free(chunk_b);
    free(chunk_c);

    printf("\n\nSummary of Heap Attacks:\n");
    printf("  1. Overflow to corrupt adjacent chunk metadata\n");
    printf("  2. Use-after-free to get dangling pointer\n");
    printf("  3. Double-free to get chunk allocated twice\n");
    printf("  4. Tcache/fastbin poisoning for arbitrary alloc\n");
    printf("  5. House of X techniques for specific scenarios\n");

    return 0;
}
```

---

## Fichiers

```
ex08/
├── heap_exploitation.h
├── heap_structure.c
├── bins.c
├── overflow.c
├── unlink.c
└── Makefile
```
