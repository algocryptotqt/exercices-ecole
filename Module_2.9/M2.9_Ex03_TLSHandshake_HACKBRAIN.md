# Exercice 2.9.14-synth : tls13_handshake

**Module :**
2.9.14 â€” TLS 1.3 Protocol Implementation

**Concept :**
synth â€” Synthese complete (handshake, ECDHE, HKDF, Key Schedule, Finished, 0-RTT)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
3 â€” Synthese (tous concepts b + d + f + g + i + j)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.9.11 : Cryptographic Hashing (SHA-256)
- 2.9.12 : HMAC et authentification
- 2.9.13 : Courbes elliptiques (bases)
- Mathematiques : Algebre modulaire, corps finis

**Domaines :**
Crypto, Net, AL, MD

**Duree estimee :**
180 min

**XP Base :**
350

**Complexite :**
T4 O(n) x S3 O(n)

---

## 1. PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/
â”œâ”€â”€ lib.rs
â”œâ”€â”€ hkdf.rs
â”œâ”€â”€ ecdhe.rs
â””â”€â”€ tls13.rs
```

**Fonctions autorisees :**
- `rand::Rng` (generation aleatoire)
- `num_bigint::BigUint` (arithmetique grands entiers)
- `hex::decode/encode` (conversion hexadecimale)
- Module HMAC et SHA-256 internes

**Fonctions interdites :**
- Bibliotheques TLS externes (rustls, openssl, native-tls)
- Bibliotheques crypto externes (ring, sodiumoxide)
- `unsafe` blocks

---

### 1.2 Consigne

#### 2.4.1 SPY MOVIE SECRET HANDSHAKE

**MISSION : INFILTRATION - Protocole de Contact Agent**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   AGENCE INTERNATIONALE D'ESPIONNAGE - PROTOCOLE TLS-007                    â”‚
â”‚                                                                             â”‚
â”‚   Dans le monde de l'espionnage, etablir un canal de communication         â”‚
â”‚   securise avec le QG est une question de vie ou de mort.                  â”‚
â”‚                                                                             â”‚
â”‚   Le protocole TLS 1.3, c'est exactement comme le rituel secret            â”‚
â”‚   qu'un agent utilise pour prouver son identite au QG.                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ACTE 1 : L'Agent Montre son Badge (ClientHello)**

Imagine James Bond qui entre dans un casino de Macao. Avant de parler d'affaires sensibles, il doit prouver au contact du MI6 qu'il est bien 007.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AGENT (Client)                         QG (Server)              â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚  "Je suis l'agent 007.               â”‚                   â”‚
â”‚       â”‚   Voici mon badge d'identification.  â”‚                   â”‚
â”‚       â”‚   Je connais ces codes secrets:      â”‚                   â”‚
â”‚       â”‚   - AES-256-GCM                      â”‚                   â”‚
â”‚       â”‚   - CHACHA20-POLY1305                â”‚                   â”‚
â”‚       â”‚   Voici ma cle publique temporaire." â”‚                   â”‚
â”‚       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                   â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚         [ ClientHello ]              â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le `ClientHello` c'est le badge de l'agent : il contient son identifiant (random), les codes qu'il connait (cipher suites), et une cle publique ephemere pour l'echange secret.

**ACTE 2 : Le QG Verifie et Donne les Codes (ServerHello)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AGENT (Client)                         QG (Server)              â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                   â”‚
â”‚       â”‚  "Identite verifiee.                 â”‚                   â”‚
â”‚       â”‚   On utilise le code AES-256-GCM.    â”‚                   â”‚
â”‚       â”‚   Voici MA cle publique temporaire." â”‚                   â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚         [ ServerHello ]              â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le QG a verifie le badge. Il choisit le cipher suite (code secret commun) et envoie sa propre cle publique. A ce moment, les deux parties peuvent calculer le **shared secret** - comme si l'agent et le QG melangeaient chacun un ingredient secret pour creer une potion unique.

**ACTE 3 : Carte d'Identite Secrete (Certificate)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AGENT (Client)                         QG (Server)              â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                   â”‚
â”‚       â”‚  "Voici ma carte d'identite signee   â”‚                   â”‚
â”‚       â”‚   par l'Agence Centrale (CA).        â”‚                   â”‚
â”‚       â”‚   Tu peux verifier que je suis       â”‚                   â”‚
â”‚       â”‚   vraiment le QG du MI6."            â”‚                   â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚     [ Certificate + Verify ]         â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le certificat, c'est comme la carte d'identite signee par le gouvernement. N'importe qui peut pretendre etre le QG, mais seul le VRAI QG possede un certificat signe par l'autorite de confiance (CA).

**ACTE 4 : Poignee de Main Finale (Finished)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AGENT (Client)                         QG (Server)              â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                   â”‚
â”‚       â”‚  "Voici le hash de TOUT ce qu'on     â”‚                   â”‚
â”‚       â”‚   s'est dit, chiffre avec notre      â”‚                   â”‚
â”‚       â”‚   secret partage. Si tu peux le      â”‚                   â”‚
â”‚       â”‚   verifier, on est synchro."         â”‚                   â”‚
â”‚       â”‚         [ Server Finished ]          â”‚                   â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                   â”‚
â”‚       â”‚  "Recu. Voici MON hash.              â”‚                   â”‚
â”‚       â”‚   Mission confirmee."                â”‚                   â”‚
â”‚       â”‚         [ Client Finished ]          â”‚                   â”‚
â”‚       â”‚                                      â”‚                   â”‚
â”‚       â”‚â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚                   â”‚
â”‚       â”‚     CANAL SECURISE ETABLI            â”‚                   â”‚
â”‚       â”‚     "The name's Bond. James Bond."   â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le message `Finished` est la poignee de main secrete finale. C'est un HMAC de toute la conversation (transcript), prouvant que :
1. Les deux parties ont bien calcule le meme secret
2. Personne n'a modifie les messages en transit
3. L'alliance est officiellement scellee

**SCENE BONUS : 0-RTT - L'Agent Reconnu (Resumption)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Si l'agent a deja travaille avec ce QG avant, il peut          â”‚
â”‚  envoyer des donnees IMMEDIATEMENT avec son ancien badge.       â”‚
â”‚                                                                  â”‚
â”‚  C'est comme si Bond revenait au meme casino et que le          â”‚
â”‚  croupier le reconnaissait : "Ah, M. Bond ! Votre table         â”‚
â”‚  habituelle est prete."                                          â”‚
â”‚                                                                  â”‚
â”‚  ATTENTION : Risque de REPLAY ATTACK !                          â”‚
â”‚  Un ennemi pourrait rejouer le message d'entree de Bond         â”‚
â”‚  pour commander un martini a sa place.                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### 2.4.2 Enonce Academique

**Description Technique :**

Implementer une simulation complete du protocole TLS 1.3 (RFC 8446) en Rust, couvrant :

1. **HKDF (HMAC-based Key Derivation Function)** - RFC 5869
   - `extract()` : Extraction d'une cle pseudo-aleatoire (PRK)
   - `expand()` : Expansion en materiel de cle (OKM)
   - `expand_label()` : Version TLS 1.3 avec labels
   - `derive_secret()` : Derivation de secrets avec contexte

2. **ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)** - Courbe P-256
   - Parametres de la courbe secp256r1 (NIST P-256)
   - Addition de points sur courbe elliptique
   - Multiplication scalaire (double-and-add)
   - Generation de paires de cles
   - Calcul du secret partage

3. **TLS 1.3 Key Schedule**
   - Derivation de Early Secret, Handshake Secret, Master Secret
   - Calcul des traffic secrets (client/server)
   - Generation des cles de session

4. **Messages Handshake**
   - ClientHello avec extensions (supported_versions, key_share)
   - ServerHello avec selection cipher/version
   - Finished avec verification du transcript

5. **0-RTT (Early Data)** - Optionnel
   - Resumption avec PSK (Pre-Shared Key)
   - Risques de replay attack

**Ta mission :**

Ecrire un module `tls13` qui implemente le handshake complet TLS 1.3 en mode 1-RTT.

**Entree :**
- `client_random` : 32 octets aleatoires du client
- `server_random` : 32 octets aleatoires du serveur
- `cipher_suites` : Liste des suites cryptographiques supportees
- `client_key_share` : Cle publique ECDHE du client
- `server_key_share` : Cle publique ECDHE du serveur

**Sortie :**
- `KeySchedule` : Structure contenant tous les secrets derives
- `client_finished` : Message Finished du client
- `server_finished` : Message Finished du serveur
- Verification que les deux Finished correspondent

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Courbe : NIST P-256 (secp256r1)        â”‚
â”‚  Hash : SHA-256 (32 bytes output)       â”‚
â”‚  HMAC : HMAC-SHA-256                    â”‚
â”‚  Cipher : TLS_AES_256_GCM_SHA384        â”‚
â”‚  Mode : 1-RTT (un aller-retour)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemples :**

| Operation | Input | Output |
|-----------|-------|--------|
| `hkdf::extract(salt, ikm)` | salt=0x00..0c, ikm=0x0b..0b | PRK (32 bytes) |
| `ecdhe::scalar_mult(k, G)` | k=1, G=generator | G (point identique) |
| `key_schedule.compute_finished()` | hs_secret, transcript | verify_data (32 bytes) |

---

### 1.3 Prototype

```rust
// src/hkdf.rs
pub fn extract(salt: &[u8], ikm: &[u8]) -> Vec<u8>;
pub fn expand(prk: &[u8], info: &[u8], length: usize) -> Vec<u8>;
pub fn expand_label(secret: &[u8], label: &str, context: &[u8], length: usize) -> Vec<u8>;
pub fn derive_secret(secret: &[u8], label: &str, messages: &[u8]) -> Vec<u8>;

// src/ecdhe.rs
pub struct P256 { /* parametres courbe */ }
pub struct Point { pub x: BigUint, pub y: BigUint, pub infinity: bool }
pub struct ECDHKeyPair { pub private_key: BigUint, pub public_key: Point }

impl P256 {
    pub fn new() -> Self;
    pub fn point_add(&self, p: &Point, q: &Point) -> Point;
    pub fn scalar_mult(&self, k: &BigUint, p: &Point) -> Point;
}

impl ECDHKeyPair {
    pub fn generate() -> Self;
    pub fn compute_shared_secret(&self, peer_public: &Point) -> Vec<u8>;
    pub fn public_key_bytes(&self) -> Vec<u8>;
}

// src/tls13.rs
pub struct KeySchedule {
    pub early_secret: Vec<u8>,
    pub handshake_secret: Vec<u8>,
    pub master_secret: Vec<u8>,
    pub client_handshake_traffic_secret: Vec<u8>,
    pub server_handshake_traffic_secret: Vec<u8>,
    pub client_application_traffic_secret: Vec<u8>,
    pub server_application_traffic_secret: Vec<u8>,
}

impl KeySchedule {
    pub fn from_shared_secret(shared: &[u8], ch: &[u8], sh: &[u8]) -> Self;
    pub fn derive_application_secrets(&mut self, messages: &[u8]);
    pub fn compute_finished(&self, base_key: &[u8], context: &[u8]) -> Vec<u8>;
}

pub struct TLS13Client {
    pub fn new() -> Self;
    pub fn create_client_hello(&mut self) -> ClientHello;
    pub fn process_server_hello(&mut self, sh: &ServerHello) -> Result<(), TLSError>;
    pub fn verify_server_finished(&mut self, f: &Finished) -> Result<(), TLSError>;
    pub fn create_finished(&self) -> Result<Finished, TLSError>;
}
```

---

## 2. LE SAVIEZ-VOUS ?

### 2.1 L'Histoire de TLS

**De SSL a TLS : Une Evolution Forcee par les Hackers**

```
1994 : SSL 1.0 (Netscape) - Jamais publie (trop de failles)
1995 : SSL 2.0 - Premier deploiement (vulnerabilites majeures)
1996 : SSL 3.0 - Amelioration (attaque POODLE en 2014)
1999 : TLS 1.0 - Renommage (RFC 2246)
2006 : TLS 1.1 - Corrections mineures
2008 : TLS 1.2 - Standard actuel (RFC 5246)
2018 : TLS 1.3 - Revolution (RFC 8446)
```

TLS 1.3 a supprime les algorithmes obsoletes (RSA key exchange, CBC mode, MD5, SHA-1) et reduit le handshake de 2-RTT a 1-RTT.

### 2.2 Le Genie Mathematique Derriere ECDHE

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PROBLEME DU LOGARITHME DISCRET SUR COURBE ELLIPTIQUE (ECDLP)   â”‚
â”‚                                                                 â”‚
â”‚  Donne : Point P et Point Q = k*P sur une courbe elliptique    â”‚
â”‚  Trouver : k (la cle privee)                                   â”‚
â”‚                                                                 â”‚
â”‚  Difficulte : O(sqrt(n)) avec Pollard's rho                    â”‚
â”‚  Pour P-256 : ~2^128 operations (infaisable)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2.5 DANS LA VRAIE VIE

**Qui utilise TLS 1.3 au quotidien ?**

| Metier | Cas d'usage |
|--------|-------------|
| **DevOps/SRE** | Configuration nginx/Apache pour HTTPS, terminaison TLS, certificats Let's Encrypt |
| **Security Engineer** | Audit des configurations TLS, detection des downgrade attacks, pentest |
| **Backend Developer** | Implementation mTLS (mutual TLS) pour microservices, gestion des certificats |
| **Network Engineer** | Inspection TLS, load balancers, CDN configuration |
| **Embedded Developer** | Implementation TLS sur IoT avec ressources limitees |

**Exemple concret : Netflix**

Netflix utilise TLS 1.3 avec 0-RTT pour reduire la latence de connexion. Quand vous lancez une video, le client envoie deja des donnees (requete video) pendant le handshake, economisant ~100ms de latence.

---

## 3. EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
src/  Cargo.toml  tests/

$ cargo build --release
   Compiling tls13_handshake v0.1.0
    Finished release [optimized] target(s) in 2.34s

$ cargo test
running 5 tests
test tests::test_hkdf_extract_expand ... ok
test tests::test_ecdh_key_agreement ... ok
test tests::test_p256_scalar_mult ... ok
test tests::test_key_schedule ... ok
test tests::test_full_handshake ... ok

test result: ok. 5 passed; 0 failed

$ cargo run --example demo
=== TLS 1.3 Handshake (1-RTT) ===

Client                              Server
   |                                    |
   |--- ClientHello ------------------>|
   |    + key_share (P-256)            |
   |    + supported_versions (1.3)     |
   |                                    |
   |<-- ServerHello -------------------|
   |    + key_share                    |
   |    + TLS_AES_256_GCM_SHA384       |
   |                                    |
   |<-- Certificate -------------------|
   |<-- CertificateVerify -------------|
   |<-- Finished ----------------------|
   |                                    |
   |--- Finished --------------------->|
   |                                    |
   |=== Connection Established ========|

Shared Secret: a3b2c1...
Client Finished: verify_data matches!
Server Finished: verify_data matches!
Handshake successful!
```

---

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
ğŸ§  (11/10)

**Recompense :**
XP x6

**Time Complexity attendue :**
O(n) pour le handshake, O(log k) pour scalar_mult avec Montgomery ladder

**Space Complexity attendue :**
O(1) pour ECDHE (constant-time), O(n) pour transcript

**Domaines Bonus :**
`Crypto++, Timing-Attack-Resistant`

#### 3.1.1 Consigne Bonus

**MISSION IMPOSSIBLE : Resistance aux Attaques par Canal Auxiliaire**

Dans le monde reel, un attaquant peut mesurer le TEMPS d'execution de ton code pour deviner des bits de la cle privee. Ton code doit s'executer en temps CONSTANT, independamment des valeurs.

**Ta mission :**

Reimplementer `scalar_mult` avec l'algorithme **Montgomery Ladder** qui :
1. Execute le MEME nombre d'operations pour tout k
2. N'a pas de branches conditionnelles dependant des bits de k
3. Utilise uniquement des coordonnees projectives

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Timing constant : O(256) iterations    â”‚
â”‚  Pas de early-exit                      â”‚
â”‚  Pas de if(bit == 1) visible            â”‚
â”‚  Coordonnees projectives (X, Z)         â”‚
â”‚  Formules Montgomery xDBL/xADD          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 Prototype Bonus

```rust
pub fn montgomery_ladder(k: &BigUint, p: &Point) -> Point;
pub fn conditional_swap(swap: bool, a: &mut Point, b: &mut Point);
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Algorithme | Double-and-add | Montgomery ladder |
| Branches | if(bit == 1) | conditional_swap constant-time |
| Coordonnees | Affines (x, y) | Projectives (X, Z) |
| Timing | Variable | Constant |
| Securite | Fonctionnel | Production-ready |

---

## 4. ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Description | Points | Piege |
|------|-------------|--------|-------|
| `test_hkdf_extract` | HKDF-Extract RFC 5869 vector | 10 | Salt vide = zeros |
| `test_hkdf_expand` | HKDF-Expand longueur variable | 10 | length > 255*HashLen |
| `test_expand_label` | TLS 1.3 label format | 10 | Prefixe "tls13 " |
| `test_p256_params` | Parametres courbe corrects | 5 | Big-endian parsing |
| `test_point_add` | Addition de points | 10 | Point a l'infini |
| `test_point_double` | Doublement (P + P) | 10 | Lambda different |
| `test_scalar_mult_1` | k=1 retourne P | 5 | - |
| `test_scalar_mult_n` | k*G puis (n-k)*G = O | 10 | Ordre du groupe |
| `test_ecdh_agreement` | Alice et Bob meme secret | 15 | Padding 32 bytes |
| `test_key_schedule` | Derivation correcte | 15 | Labels exacts |
| `test_finished` | verify_data correct | 15 | Transcript complet |
| `test_full_handshake` | Integration complete | 20 | State machine |
| **TOTAL** | | **135** | |

---

### 4.2 main.rs de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use hex;

    #[test]
    fn test_hkdf_extract_expand() {
        // RFC 5869 Test Vector 1
        let ikm = hex::decode("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b").unwrap();
        let salt = hex::decode("000102030405060708090a0b0c").unwrap();
        let info = hex::decode("f0f1f2f3f4f5f6f7f8f9").unwrap();

        let prk = hkdf::extract(&salt, &ikm);
        let okm = hkdf::expand(&prk, &info, 42);

        assert_eq!(prk.len(), 32);
        assert_eq!(okm.len(), 42);

        // Verify against known output
        let expected_prk = hex::decode(
            "077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5"
        ).unwrap();
        assert_eq!(prk, expected_prk);
    }

    #[test]
    fn test_ecdh_key_agreement() {
        let alice = ecdhe::ECDHKeyPair::generate();
        let bob = ecdhe::ECDHKeyPair::generate();

        let alice_shared = alice.compute_shared_secret(&bob.public_key);
        let bob_shared = bob.compute_shared_secret(&alice.public_key);

        assert_eq!(alice_shared.len(), 32);
        assert_eq!(alice_shared, bob_shared, "Shared secrets must match!");
    }

    #[test]
    fn test_p256_scalar_mult() {
        let curve = ecdhe::P256::new();
        let one = num_bigint::BigUint::from(1u32);

        let result = curve.scalar_mult(&one, &curve.g);

        assert_eq!(result.x, curve.g.x);
        assert_eq!(result.y, curve.g.y);
        assert!(!result.infinity);
    }

    #[test]
    fn test_key_schedule_derivation() {
        // Simulated shared secret
        let shared_secret = vec![0xab; 32];
        let client_hello = b"ClientHello...";
        let server_hello = b"ServerHello...";

        let ks = tls13::KeySchedule::from_shared_secret(
            &shared_secret,
            client_hello,
            server_hello
        );

        assert_eq!(ks.handshake_secret.len(), 32);
        assert_eq!(ks.client_handshake_traffic_secret.len(), 32);
        assert_eq!(ks.server_handshake_traffic_secret.len(), 32);
    }

    #[test]
    fn test_finished_verification() {
        let shared_secret = vec![0xab; 32];
        let client_hello = b"ClientHello...";
        let server_hello = b"ServerHello...";

        let ks = tls13::KeySchedule::from_shared_secret(
            &shared_secret,
            client_hello,
            server_hello
        );

        let transcript = [client_hello.as_slice(), server_hello.as_slice()].concat();

        let server_finished = ks.compute_finished(
            &ks.server_handshake_traffic_secret,
            &transcript
        );

        assert_eq!(server_finished.len(), 32);
    }
}
```

---

### 4.3 Solution de reference

```rust
// src/hkdf.rs - Solution complete
use crate::hashing::{HashFunction, SHA256};
use crate::mac::HMAC;

pub fn extract(salt: &[u8], ikm: &[u8]) -> Vec<u8> {
    let salt = if salt.is_empty() {
        vec![0u8; 32]
    } else {
        salt.to_vec()
    };
    let hmac = HMAC::new(&salt);
    hmac.compute(ikm)
}

pub fn expand(prk: &[u8], info: &[u8], length: usize) -> Vec<u8> {
    let hmac = HMAC::new(prk);
    let hash_len = 32;
    let n = (length + hash_len - 1) / hash_len;
    let mut okm = Vec::with_capacity(length);
    let mut t = Vec::new();

    for i in 1..=n {
        let mut data = t.clone();
        data.extend_from_slice(info);
        data.push(i as u8);
        t = hmac.compute(&data);
        okm.extend_from_slice(&t);
    }
    okm.truncate(length);
    okm
}

pub fn expand_label(secret: &[u8], label: &str, context: &[u8], length: usize) -> Vec<u8> {
    let tls_label = format!("tls13 {}", label);
    let mut hkdf_label = Vec::new();
    hkdf_label.extend_from_slice(&(length as u16).to_be_bytes());
    hkdf_label.push(tls_label.len() as u8);
    hkdf_label.extend_from_slice(tls_label.as_bytes());
    hkdf_label.push(context.len() as u8);
    hkdf_label.extend_from_slice(context);
    expand(secret, &hkdf_label, length)
}

pub fn derive_secret(secret: &[u8], label: &str, messages: &[u8]) -> Vec<u8> {
    let context_hash = SHA256::hash(messages);
    expand_label(secret, label, &context_hash, 32)
}

// src/ecdhe.rs - Solution complete
use num_bigint::BigUint;

pub struct P256 {
    pub p: BigUint,
    pub a: BigUint,
    pub b: BigUint,
    pub g: Point,
    pub n: BigUint,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Point {
    pub x: BigUint,
    pub y: BigUint,
    pub infinity: bool,
}

impl P256 {
    pub fn new() -> Self {
        let p = BigUint::parse_bytes(
            b"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff", 16
        ).unwrap();
        let a = BigUint::parse_bytes(
            b"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc", 16
        ).unwrap();
        let b = BigUint::parse_bytes(
            b"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b", 16
        ).unwrap();
        let gx = BigUint::parse_bytes(
            b"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296", 16
        ).unwrap();
        let gy = BigUint::parse_bytes(
            b"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5", 16
        ).unwrap();
        let n = BigUint::parse_bytes(
            b"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551", 16
        ).unwrap();
        P256 { p, a, b, g: Point { x: gx, y: gy, infinity: false }, n }
    }

    pub fn point_add(&self, p: &Point, q: &Point) -> Point {
        if p.infinity { return q.clone(); }
        if q.infinity { return p.clone(); }
        if p.x == q.x && p.y != q.y {
            return Point { x: BigUint::ZERO, y: BigUint::ZERO, infinity: true };
        }

        let lambda = if p == q {
            let num = (3u32 * &p.x * &p.x + &self.a) % &self.p;
            let den = (2u32 * &p.y) % &self.p;
            (num * self.mod_inverse(&den)) % &self.p
        } else {
            let num = (&q.y + &self.p - &p.y) % &self.p;
            let den = (&q.x + &self.p - &p.x) % &self.p;
            (num * self.mod_inverse(&den)) % &self.p
        };

        let x3 = (&lambda * &lambda + &self.p - &p.x + &self.p - &q.x) % &self.p;
        let y3 = (&lambda * (&p.x + &self.p - &x3) + &self.p - &p.y) % &self.p;
        Point { x: x3, y: y3, infinity: false }
    }

    pub fn scalar_mult(&self, k: &BigUint, p: &Point) -> Point {
        let mut result = Point { x: BigUint::ZERO, y: BigUint::ZERO, infinity: true };
        let mut temp = p.clone();
        let bits = k.to_bytes_be();

        for byte in bits.iter().rev() {
            for i in 0..8 {
                if (byte >> i) & 1 == 1 {
                    result = self.point_add(&result, &temp);
                }
                temp = self.point_add(&temp, &temp);
            }
        }
        result
    }

    fn mod_inverse(&self, a: &BigUint) -> BigUint {
        a.modpow(&(&self.p - 2u32), &self.p)
    }
}

pub struct ECDHKeyPair {
    pub private_key: BigUint,
    pub public_key: Point,
}

impl ECDHKeyPair {
    pub fn generate() -> Self {
        let curve = P256::new();
        let mut rng = rand::thread_rng();
        let private_key = rng.gen_biguint_range(&BigUint::from(1u32), &curve.n);
        let public_key = curve.scalar_mult(&private_key, &curve.g);
        ECDHKeyPair { private_key, public_key }
    }

    pub fn compute_shared_secret(&self, peer_public: &Point) -> Vec<u8> {
        let curve = P256::new();
        let shared_point = curve.scalar_mult(&self.private_key, peer_public);
        let mut x_bytes = shared_point.x.to_bytes_be();
        while x_bytes.len() < 32 { x_bytes.insert(0, 0); }
        x_bytes
    }

    pub fn public_key_bytes(&self) -> Vec<u8> {
        let mut bytes = vec![0x04];
        let mut x = self.public_key.x.to_bytes_be();
        let mut y = self.public_key.y.to_bytes_be();
        while x.len() < 32 { x.insert(0, 0); }
        while y.len() < 32 { y.insert(0, 0); }
        bytes.extend(x);
        bytes.extend(y);
        bytes
    }
}

// src/tls13.rs - KeySchedule
impl KeySchedule {
    pub fn from_shared_secret(shared: &[u8], ch: &[u8], sh: &[u8]) -> Self {
        let zero_key = vec![0u8; 32];
        let early_secret = hkdf::extract(&[], &zero_key);
        let derived = hkdf::derive_secret(&early_secret, "derived", &[]);
        let handshake_secret = hkdf::extract(&derived, shared);

        let mut hello_messages = Vec::new();
        hello_messages.extend_from_slice(ch);
        hello_messages.extend_from_slice(sh);

        let client_hs_secret = hkdf::derive_secret(&handshake_secret, "c hs traffic", &hello_messages);
        let server_hs_secret = hkdf::derive_secret(&handshake_secret, "s hs traffic", &hello_messages);
        let derived2 = hkdf::derive_secret(&handshake_secret, "derived", &[]);
        let master_secret = hkdf::extract(&derived2, &zero_key);

        KeySchedule {
            early_secret, handshake_secret, master_secret,
            client_handshake_traffic_secret: client_hs_secret,
            server_handshake_traffic_secret: server_hs_secret,
            client_application_traffic_secret: vec![],
            server_application_traffic_secret: vec![],
        }
    }

    pub fn compute_finished(&self, base_key: &[u8], context: &[u8]) -> Vec<u8> {
        let finished_key = hkdf::expand_label(base_key, "finished", &[], 32);
        let transcript_hash = SHA256::hash(context);
        let hmac = HMAC::new(&finished_key);
        hmac.compute(&transcript_hash)
    }
}
```

---

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de traits pour les courbes
trait EllipticCurve {
    fn point_add(&self, p: &Point, q: &Point) -> Point;
    fn scalar_mult(&self, k: &BigUint, p: &Point) -> Point;
}

impl EllipticCurve for P256 {
    // ... implementation identique
}

// Alternative 2 : Coordonnees projectives (plus efficace)
pub struct ProjectivePoint {
    pub x: BigUint,
    pub y: BigUint,
    pub z: BigUint,
}

impl P256 {
    pub fn scalar_mult_projective(&self, k: &BigUint, p: &ProjectivePoint) -> ProjectivePoint {
        // Evite les inversions modulaires couteuses
    }
}
```

---

### 4.5 Solutions refusees (avec explications)

```rust
// REFUSE 1 : Oubli du prefixe "tls13 " dans expand_label
pub fn expand_label_wrong(secret: &[u8], label: &str, context: &[u8], length: usize) -> Vec<u8> {
    // ERREUR : Pas de "tls13 " devant le label
    let mut hkdf_label = Vec::new();
    hkdf_label.extend_from_slice(&(length as u16).to_be_bytes());
    hkdf_label.push(label.len() as u8);  // Manque "tls13 " !
    hkdf_label.extend_from_slice(label.as_bytes());
    // ...
}
// Pourquoi refuse : Non conforme RFC 8446, les cles derivees seront differentes

// REFUSE 2 : Point addition sans gerer l'infini
pub fn point_add_wrong(&self, p: &Point, q: &Point) -> Point {
    // ERREUR : Pas de verification de l'element neutre
    let lambda = /* ... */;
    let x3 = /* ... */;
    let y3 = /* ... */;
    Point { x: x3, y: y3, infinity: false }  // Toujours false !
}
// Pourquoi refuse : Crash ou resultat faux quand P ou Q est le point a l'infini

// REFUSE 3 : Shared secret sans padding
pub fn compute_shared_secret_wrong(&self, peer_public: &Point) -> Vec<u8> {
    let curve = P256::new();
    let shared_point = curve.scalar_mult(&self.private_key, peer_public);
    shared_point.x.to_bytes_be()  // Peut etre < 32 bytes !
}
// Pourquoi refuse : Le secret partage doit toujours faire 32 bytes
```

---

### 4.6 Solution bonus de reference (COMPLETE)

```rust
// Montgomery Ladder - Constant-time scalar multiplication
pub fn montgomery_ladder(k: &BigUint, base: &Point, curve: &P256) -> Point {
    let mut r0 = Point { x: BigUint::ZERO, y: BigUint::ZERO, infinity: true };
    let mut r1 = base.clone();

    let bits = k.bits();

    for i in (0..bits).rev() {
        let bit = k.bit(i);

        // Constant-time conditional swap
        conditional_swap(bit, &mut r0, &mut r1);

        // R1 = R0 + R1
        r1 = curve.point_add(&r0, &r1);
        // R0 = 2 * R0
        r0 = curve.point_add(&r0, &r0);

        // Swap back
        conditional_swap(bit, &mut r0, &mut r1);
    }

    r0
}

// Constant-time swap (no branch on secret bit)
#[inline(never)]
pub fn conditional_swap(swap: bool, a: &mut Point, b: &mut Point) {
    // Convert bool to mask: 0x00...00 or 0xFF...FF
    let mask = if swap { BigUint::MAX } else { BigUint::ZERO };

    // XOR swap avec mask
    // Si mask = 0, rien ne change
    // Si mask = 1, a et b sont echanges
    let temp_x = &a.x ^ &b.x;
    let temp_y = &a.y ^ &b.y;

    a.x ^= &temp_x & &mask;
    b.x ^= &temp_x & &mask;
    a.y ^= &temp_y & &mask;
    b.y ^= &temp_y & &mask;

    // Note: En production, utiliser des operations sur bytes bruts
    // pour garantir le constant-time au niveau assembleur
}
```

---

### 4.7 Solutions alternatives bonus (COMPLETES)

```rust
// Alternative : Montgomery Ladder avec coordonnees XZ (plus rapide)
pub fn montgomery_ladder_xz(k: &BigUint, x_p: &BigUint, curve: &P256) -> BigUint {
    // Travaille uniquement avec la coordonnee X
    // Formules de Montgomery pour xDBL et xADD

    let mut x2 = BigUint::from(1u32);
    let mut z2 = BigUint::ZERO;
    let mut x3 = x_p.clone();
    let mut z3 = BigUint::from(1u32);

    for i in (0..k.bits()).rev() {
        let bit = k.bit(i);

        conditional_swap_xz(bit, &mut x2, &mut x3, &mut z2, &mut z3);

        // xADD et xDBL en parallele
        let (x2_new, z2_new) = x_dbl(&x2, &z2, &curve.a, &curve.p);
        let (x3_new, z3_new) = x_add(&x2, &z2, &x3, &z3, x_p, &curve.p);

        x2 = x2_new; z2 = z2_new;
        x3 = x3_new; z3 = z3_new;

        conditional_swap_xz(bit, &mut x2, &mut x3, &mut z2, &mut z3);
    }

    // Reconvertir en affine : x = X * Z^(-1) mod p
    let z_inv = z2.modpow(&(&curve.p - 2u32), &curve.p);
    (&x2 * &z_inv) % &curve.p
}
```

---

### 4.8 Solutions refusees bonus (COMPLETES)

```rust
// REFUSE BONUS 1 : Early exit sur bit = 0 (timing leak)
pub fn montgomery_ladder_leaky(k: &BigUint, base: &Point, curve: &P256) -> Point {
    let mut r0 = Point::infinity();
    let mut r1 = base.clone();

    for i in (0..k.bits()).rev() {
        if k.bit(i) {  // ERREUR : Branch sur bit secret !
            r1 = curve.point_add(&r0, &r1);
            r0 = curve.point_add(&r0, &r0);
        } else {
            r0 = curve.point_add(&r0, &r1);
            r1 = curve.point_add(&r1, &r1);
        }
    }
    r0
}
// Pourquoi refuse : Le if/else cree un timing side-channel

// REFUSE BONUS 2 : Swap avec condition visible
pub fn conditional_swap_leaky(swap: bool, a: &mut Point, b: &mut Point) {
    if swap {  // ERREUR : Condition sur secret
        std::mem::swap(a, b);
    }
}
// Pourquoi refuse : Le compilateur peut generer un branch
```

---

### 4.9 spec.json (ENGINE v22.1 - FORMAT STRICT)

```json
{
  "name": "tls13_handshake",
  "language": "rust",
  "rust_edition": "2024",
  "type": "complet",
  "tier": 3,
  "tier_info": "Synthese (concepts b + d + f + g + i + j)",
  "tags": ["tls", "crypto", "ecdhe", "hkdf", "handshake", "phase3"],
  "passing_score": 70,

  "modules": [
    {
      "name": "hkdf",
      "file": "src/hkdf.rs",
      "functions": [
        {
          "name": "extract",
          "prototype": "pub fn extract(salt: &[u8], ikm: &[u8]) -> Vec<u8>",
          "return_type": "Vec<u8>"
        },
        {
          "name": "expand",
          "prototype": "pub fn expand(prk: &[u8], info: &[u8], length: usize) -> Vec<u8>",
          "return_type": "Vec<u8>"
        },
        {
          "name": "expand_label",
          "prototype": "pub fn expand_label(secret: &[u8], label: &str, context: &[u8], length: usize) -> Vec<u8>",
          "return_type": "Vec<u8>"
        },
        {
          "name": "derive_secret",
          "prototype": "pub fn derive_secret(secret: &[u8], label: &str, messages: &[u8]) -> Vec<u8>",
          "return_type": "Vec<u8>"
        }
      ]
    },
    {
      "name": "ecdhe",
      "file": "src/ecdhe.rs",
      "structs": ["P256", "Point", "ECDHKeyPair"],
      "functions": [
        {
          "name": "P256::new",
          "prototype": "pub fn new() -> Self",
          "return_type": "P256"
        },
        {
          "name": "P256::point_add",
          "prototype": "pub fn point_add(&self, p: &Point, q: &Point) -> Point",
          "return_type": "Point"
        },
        {
          "name": "P256::scalar_mult",
          "prototype": "pub fn scalar_mult(&self, k: &BigUint, p: &Point) -> Point",
          "return_type": "Point"
        },
        {
          "name": "ECDHKeyPair::generate",
          "prototype": "pub fn generate() -> Self",
          "return_type": "ECDHKeyPair"
        },
        {
          "name": "ECDHKeyPair::compute_shared_secret",
          "prototype": "pub fn compute_shared_secret(&self, peer_public: &Point) -> Vec<u8>",
          "return_type": "Vec<u8>"
        }
      ]
    },
    {
      "name": "tls13",
      "file": "src/tls13.rs",
      "structs": ["KeySchedule", "TLS13Client", "ClientHello", "ServerHello", "Finished"],
      "functions": [
        {
          "name": "KeySchedule::from_shared_secret",
          "prototype": "pub fn from_shared_secret(shared: &[u8], ch: &[u8], sh: &[u8]) -> Self",
          "return_type": "KeySchedule"
        },
        {
          "name": "KeySchedule::compute_finished",
          "prototype": "pub fn compute_finished(&self, base_key: &[u8], context: &[u8]) -> Vec<u8>",
          "return_type": "Vec<u8>"
        }
      ]
    }
  ],

  "driver": {
    "reference_file": "references/ref_solution.rs",

    "edge_cases": [
      {
        "name": "hkdf_empty_salt",
        "module": "hkdf",
        "function": "extract",
        "args": {"salt": [], "ikm": [11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]},
        "expected_len": 32,
        "is_trap": true,
        "trap_explanation": "Salt vide doit etre remplace par 32 zeros selon RFC 5869"
      },
      {
        "name": "ecdh_shared_secret_length",
        "module": "ecdhe",
        "function": "compute_shared_secret",
        "expected_len": 32,
        "is_trap": true,
        "trap_explanation": "Le secret partage doit toujours faire 32 bytes (avec padding)"
      },
      {
        "name": "point_at_infinity_add",
        "module": "ecdhe",
        "function": "point_add",
        "args": {"p": "infinity", "q": "generator"},
        "expected": "generator",
        "is_trap": true,
        "trap_explanation": "O + P = P (element neutre)"
      },
      {
        "name": "scalar_mult_one",
        "module": "ecdhe",
        "function": "scalar_mult",
        "args": {"k": 1, "p": "generator"},
        "expected": "generator",
        "is_trap": false
      },
      {
        "name": "expand_label_prefix",
        "module": "hkdf",
        "function": "expand_label",
        "args": {"label": "finished"},
        "must_contain": "tls13 finished",
        "is_trap": true,
        "trap_explanation": "Le label doit etre prefixe par 'tls13 '"
      },
      {
        "name": "key_schedule_secrets_independent",
        "module": "tls13",
        "function": "from_shared_secret",
        "check": "client_hs_secret != server_hs_secret",
        "is_trap": true,
        "trap_explanation": "Les secrets client et server doivent etre differents"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "target": "hkdf::extract",
          "type": "bytes",
          "param_index": 0,
          "params": {"min_len": 0, "max_len": 64}
        },
        {
          "target": "ecdhe::scalar_mult",
          "type": "bigint",
          "param_index": 0,
          "params": {"min_bits": 1, "max_bits": 256}
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["rand", "num_bigint", "hex"],
    "forbidden_crates": ["rustls", "openssl", "ring", "sodiumoxide", "native-tls"],
    "forbidden_keywords": ["unsafe"],
    "check_security": true,
    "check_timing": true,
    "blocking": true
  },

  "bonus": {
    "enabled": true,
    "tier": "GENIE",
    "icon": "brain",
    "multiplier": 6,
    "requirements": {
      "constant_time": true,
      "no_branches_on_secret": true,
      "montgomery_ladder": true
    }
  }
}
```

---

### 4.10 Solutions Mutantes (minimum 5)

```rust
/* Mutant A (Boundary) : Oubli du padding du shared secret */
impl ECDHKeyPair {
    pub fn compute_shared_secret(&self, peer_public: &Point) -> Vec<u8> {
        let curve = P256::new();
        let shared_point = curve.scalar_mult(&self.private_key, peer_public);
        // BUG : Pas de padding, peut retourner < 32 bytes
        shared_point.x.to_bytes_be()
    }
}
// Pourquoi c'est faux : Si x commence par des zeros, ils sont omis
// Ce qui etait pense : "to_bytes_be() donne toujours 32 bytes"

/* Mutant B (Safety) : Pas de verification du point a l'infini */
impl P256 {
    pub fn point_add(&self, p: &Point, q: &Point) -> Point {
        // BUG : Pas de check pour infinity
        let lambda = /* calcul normal */;
        // Si p ou q est infinity, division par zero !
    }
}
// Pourquoi c'est faux : Crash sur point neutre
// Ce qui etait pense : "L'infini n'arrive jamais en pratique"

/* Mutant C (Resource) : Fuite memoire dans expand */
pub fn expand(prk: &[u8], info: &[u8], length: usize) -> Vec<u8> {
    let mut okm = Vec::new();
    let mut t = Vec::new();

    for i in 1..=255 {  // BUG : Boucle jusqu'a 255 au lieu de n
        let mut data = t.clone();
        data.extend_from_slice(info);
        data.push(i as u8);
        t = hmac.compute(&data);
        okm.extend_from_slice(&t);
        if okm.len() >= length { break; }
    }
    okm.truncate(length);
    okm
}
// Pourquoi c'est faux : Alloue potentiellement 255*32 bytes inutilement
// Ce qui etait pense : "Le break arrete tot de toute facon"

/* Mutant D (Logic) : Mauvais label TLS 1.3 */
pub fn expand_label(secret: &[u8], label: &str, context: &[u8], length: usize) -> Vec<u8> {
    // BUG : Label sans prefixe "tls13 "
    let mut hkdf_label = Vec::new();
    hkdf_label.extend_from_slice(&(length as u16).to_be_bytes());
    hkdf_label.push(label.len() as u8);  // Devrait etre tls_label.len()
    hkdf_label.extend_from_slice(label.as_bytes());  // Devrait etre tls_label
    hkdf_label.push(context.len() as u8);
    hkdf_label.extend_from_slice(context);
    expand(secret, &hkdf_label, length)
}
// Pourquoi c'est faux : Cles derivees incompatibles avec TLS 1.3 standard
// Ce qui etait pense : "Le label est juste une etiquette, peu importe le format"

/* Mutant E (Return) : Finished avec mauvais transcript */
impl KeySchedule {
    pub fn compute_finished(&self, base_key: &[u8], context: &[u8]) -> Vec<u8> {
        let finished_key = hkdf::expand_label(base_key, "finished", &[], 32);
        // BUG : Hash du context au lieu du transcript complet
        let transcript_hash = SHA256::hash(&context[..32]);  // Tronque !
        let hmac = HMAC::new(&finished_key);
        hmac.compute(&transcript_hash)
    }
}
// Pourquoi c'est faux : verify_data ne couvre pas tout le handshake
// Ce qui etait pense : "Les premiers 32 bytes suffisent"
```

---

## 5. COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPETENCES ACQUISES                                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  1. CRYPTOGRAPHIE APPLIQUEE                                                 â”‚
â”‚     â€¢ HKDF pour derivation de cles (RFC 5869)                              â”‚
â”‚     â€¢ ECDHE pour echange de cles ephemeres                                 â”‚
â”‚     â€¢ HMAC pour authentification                                           â”‚
â”‚                                                                             â”‚
â”‚  2. MATHEMATIQUES                                                           â”‚
â”‚     â€¢ Arithmetique modulaire sur grands entiers                            â”‚
â”‚     â€¢ Courbes elliptiques (groupe, generateur, ordre)                      â”‚
â”‚     â€¢ Probleme du logarithme discret                                       â”‚
â”‚                                                                             â”‚
â”‚  3. PROTOCOLE TLS 1.3                                                       â”‚
â”‚     â€¢ Flux du handshake 1-RTT                                              â”‚
â”‚     â€¢ Key Schedule et derivation de secrets                                â”‚
â”‚     â€¢ Messages Finished et transcript                                      â”‚
â”‚                                                                             â”‚
â”‚  4. SECURITE                                                                â”‚
â”‚     â€¢ Forward Secrecy (PFS)                                                â”‚
â”‚     â€¢ Risques du 0-RTT (replay attacks)                                    â”‚
â”‚     â€¢ Constant-time programming (bonus)                                    â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.2 LDA - Traduction litterale en francais (MAJUSCULES)

```
FONCTION extract QUI RETOURNE UN VECTEUR D'OCTETS ET PREND EN PARAMETRES salt QUI EST UNE TRANCHE D'OCTETS ET ikm QUI EST UNE TRANCHE D'OCTETS
DEBUT FONCTION
    SI salt EST VIDE ALORS
        AFFECTER UN VECTEUR DE 32 ZEROS A salt
    FIN SI
    DECLARER hmac COMME UNE INSTANCE DE HMAC INITIALISEE AVEC salt
    RETOURNER LE RESULTAT DE hmac.compute APPLIQUE A ikm
FIN FONCTION

FONCTION scalar_mult QUI RETOURNE UN POINT ET PREND EN PARAMETRES k QUI EST UN GRAND ENTIER ET p QUI EST UN POINT
DEBUT FONCTION
    DECLARER result COMME UN POINT A L'INFINI (ELEMENT NEUTRE)
    DECLARER temp COMME UNE COPIE DE p
    DECLARER bits COMME LA REPRESENTATION BINAIRE DE k EN BIG-ENDIAN

    POUR CHAQUE byte DANS bits EN ORDRE INVERSE FAIRE
        POUR i ALLANT DE 0 A 7 FAIRE
            SI LE BIT A LA POSITION i DE byte EST EGAL A 1 ALORS
                AFFECTER point_add(result, temp) A result
            FIN SI
            AFFECTER point_add(temp, temp) A temp
        FIN POUR
    FIN POUR

    RETOURNER result
FIN FONCTION

FONCTION compute_finished QUI RETOURNE UN VECTEUR D'OCTETS ET PREND EN PARAMETRES base_key QUI EST UNE TRANCHE D'OCTETS ET context QUI EST UNE TRANCHE D'OCTETS
DEBUT FONCTION
    DECLARER finished_key COMME LE RESULTAT DE expand_label AVEC base_key ET "finished" ET VIDE ET 32
    DECLARER transcript_hash COMME LE HASH SHA-256 DE context
    DECLARER hmac COMME UNE INSTANCE DE HMAC INITIALISEE AVEC finished_key
    RETOURNER LE RESULTAT DE hmac.compute APPLIQUE A transcript_hash
FIN FONCTION
```

---

### 5.2.2 LDA Style Academique Francais

```
Algorithme : HKDF-Extract
Entrees : sel (tableau d'octets), materiau (tableau d'octets)
Sortie : cle pseudo-aleatoire (32 octets)

Debut
    Si sel est vide Alors
        sel <- tableau de 32 zeros
    FinSi

    hmac <- creer_HMAC(cle: sel)
    prk <- hmac.calculer(materiau)

    Retourner prk
Fin

Algorithme : Multiplication scalaire sur courbe elliptique
Entrees : k (entier), P (point sur la courbe)
Sortie : Q = k * P (point sur la courbe)

Debut
    R <- point_infini  // Element neutre
    T <- P

    Pour chaque bit b de k (du moins significatif au plus significatif) Faire
        Si b = 1 Alors
            R <- addition_points(R, T)
        FinSi
        T <- addition_points(T, T)  // Doublement
    FinPour

    Retourner R
Fin
```

---

### 5.2.2.1 Logic Flow (Structured English)

```
ALGORITHME : TLS 1.3 Handshake (1-RTT)
---
1. CLIENT : Generer paire de cles ECDHE (private_key, public_key)

2. CLIENT -> SERVER : Envoyer ClientHello
   a. random (32 bytes aleatoires)
   b. cipher_suites (liste des algorithmes supportes)
   c. key_share (public_key ECDHE)
   d. supported_versions (TLS 1.3 = 0x0304)

3. SERVER : Recevoir et traiter ClientHello
   a. VERIFIER que TLS 1.3 est supporte
   b. SELECTIONNER un cipher suite commun
   c. GENERER sa paire de cles ECDHE
   d. CALCULER shared_secret = ECDH(server_private, client_public)

4. SERVER -> CLIENT : Envoyer ServerHello + messages chiffres
   a. ServerHello (random, cipher_suite, key_share)
   b. EncryptedExtensions (extensions supplementaires)
   c. Certificate (certificat X.509)
   d. CertificateVerify (signature du transcript)
   e. Finished (HMAC du transcript)

5. CLIENT : Traiter la reponse du serveur
   a. CALCULER shared_secret = ECDH(client_private, server_public)
   b. DERIVER les cles via Key Schedule
   c. VERIFIER le Certificate (chaine de confiance)
   d. VERIFIER le CertificateVerify (signature)
   e. VERIFIER le Finished (HMAC)

6. CLIENT -> SERVER : Envoyer Finished
   a. CALCULER verify_data = HMAC(finished_key, transcript_hash)
   b. ENVOYER le message Finished chiffre

7. CONNEXION ETABLIE : Les deux parties ont les memes cles de session
```

---

### 5.2.3 Representation Algorithmique avec Diagramme

```mermaid
graph TD
    A[Client: Generer ECDHE keypair] --> B[Client: Creer ClientHello]
    B --> C{Envoyer ClientHello}
    C --> D[Server: Recevoir ClientHello]
    D --> E{Version TLS 1.3 supportee?}
    E -- Non --> F[Erreur: Version non supportee]
    E -- Oui --> G[Server: Generer ECDHE keypair]
    G --> H[Server: Calculer shared_secret]
    H --> I[Server: Deriver Key Schedule]
    I --> J[Server: Creer ServerHello]
    J --> K[Server: Envoyer Certificate + Finished]
    K --> L[Client: Recevoir ServerHello]
    L --> M[Client: Calculer shared_secret]
    M --> N{shared_secret identiques?}
    N -- Non --> O[Erreur: Key exchange failed]
    N -- Oui --> P[Client: Deriver Key Schedule]
    P --> Q[Client: Verifier Server Finished]
    Q --> R{Finished valide?}
    R -- Non --> S[Erreur: Invalid Finished]
    R -- Oui --> T[Client: Envoyer Client Finished]
    T --> U[Connexion TLS etablie]
```

---

### 5.2.3.1 Logique de Garde (Fail Fast)

```
FONCTION : process_server_hello(server_hello)
---
INIT erreur = None

1. VERIFIER supported_versions :
   |
   |-- SI extension absente :
   |     RETOURNER Erreur "Missing supported_versions"
   |
   |-- SI 0x0304 pas dans la liste :
   |     RETOURNER Erreur "TLS 1.3 not supported"

2. VERIFIER key_share :
   |
   |-- SI extension absente :
   |     RETOURNER Erreur "Missing key_share"
   |
   |-- SI groupe != 0x0017 (P-256) :
   |     RETOURNER Erreur "Unsupported group"

3. PARSER la cle publique serveur :
   |
   |-- SI longueur != 65 bytes :
   |     RETOURNER Erreur "Invalid key length"
   |
   |-- SI premier octet != 0x04 :
   |     RETOURNER Erreur "Not uncompressed point"

4. CALCULER shared_secret :
   |
   |-- EXECUTER ECDH(private_key, server_public)
   |-- SI resultat est point a l'infini :
   |     RETOURNER Erreur "Invalid shared secret"

5. RETOURNER Succes avec key_schedule
```

---

### 5.3 Visualisation ASCII (adaptee au sujet)

**TLS 1.3 Handshake Flow :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         TLS 1.3 HANDSHAKE (1-RTT)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  CLIENT                                                  SERVER              â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                â”‚
â”‚    â”‚  â”‚ ClientHello                                     â”‚   â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ random: 32 bytes                              â”‚   â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ cipher_suites: [AES_256_GCM, CHACHA20...]     â”‚   â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ key_share: (P-256, client_public)             â”‚   â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ supported_versions: [TLS 1.3]                 â”‚   â”‚                â”‚
â”‚    â”‚â”€â”€â”¤                                                 â”œâ”€â”€â–ºâ”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚                â”‚
â”‚    â”‚                        â”‚ Calcul shared_secret   â”‚      â”‚                â”‚
â”‚    â”‚                        â”‚ k = server_private     â”‚      â”‚                â”‚
â”‚    â”‚                        â”‚ P = client_public      â”‚      â”‚                â”‚
â”‚    â”‚                        â”‚ S = k * P              â”‚      â”‚                â”‚
â”‚    â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                â”‚
â”‚    â”‚  â”‚ ServerHello                                     â”‚   â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ random: 32 bytes                              â”‚   â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ cipher_suite: TLS_AES_256_GCM_SHA384          â”‚   â”‚                â”‚
â”‚    â”‚â—„â”€â”¤ â€¢ key_share: (P-256, server_public)             â”œâ”€â”€â”€â”‚                â”‚
â”‚    â”‚  â”‚ â€¢ supported_versions: TLS 1.3                   â”‚   â”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” ENCRYPTED    â”‚                â”‚
â”‚    â”‚â—„â”€â”¤ {EncryptedExtensions}                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                â”‚
â”‚    â”‚â—„â”€â”¤ {Certificate}                        â”‚              â”‚                â”‚
â”‚    â”‚â—„â”€â”¤ {CertificateVerify}                  â”‚              â”‚                â”‚
â”‚    â”‚â—„â”€â”¤ {Finished: verify_data}              â”‚              â”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚                â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚                â”‚
â”‚    â”‚  â”‚ Calcul shared_secret   â”‚                            â”‚                â”‚
â”‚    â”‚  â”‚ k = client_private     â”‚                            â”‚                â”‚
â”‚    â”‚  â”‚ P = server_public      â”‚                            â”‚                â”‚
â”‚    â”‚  â”‚ S = k * P              â”‚ â† MEME VALEUR !            â”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚                â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” ENCRYPTED    â”‚                â”‚
â”‚    â”‚â”€â”€â”¤ {Finished: verify_data}              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚                â”‚
â”‚    â”‚                                                        â”‚                â”‚
â”‚    â”‚â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚                â”‚
â”‚    â”‚              APPLICATION DATA (ENCRYPTED)              â”‚                â”‚
â”‚    â”‚â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚                â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ECDHE Key Exchange :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ECDHE sur courbe P-256 (secp256r1)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   ALICE (Client)                              BOB (Server)                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚   â”‚ private_a      â”‚                          â”‚ private_b      â”‚             â”‚
â”‚   â”‚ = random       â”‚                          â”‚ = random       â”‚             â”‚
â”‚   â”‚ in [1, n-1]    â”‚                          â”‚ in [1, n-1]    â”‚             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚           â”‚                                           â”‚                      â”‚
â”‚           â–¼                                           â–¼                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚   â”‚ public_a       â”‚                          â”‚ public_b       â”‚             â”‚
â”‚   â”‚ = private_a * Gâ”‚                          â”‚ = private_b * Gâ”‚             â”‚
â”‚   â”‚ (Point P-256)  â”‚                          â”‚ (Point P-256)  â”‚             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚           â”‚                                           â”‚                      â”‚
â”‚           â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚                      â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  public_a       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  public_b       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚           â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚                      â”‚
â”‚           â”‚                                           â”‚                      â”‚
â”‚           â–¼                                           â–¼                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚   â”‚ shared_secret  â”‚                          â”‚ shared_secret  â”‚             â”‚
â”‚   â”‚ = private_a *  â”‚                          â”‚ = private_b *  â”‚             â”‚
â”‚   â”‚   public_b     â”‚                          â”‚   public_a     â”‚             â”‚
â”‚   â”‚ = a * (b * G)  â”‚                          â”‚ = b * (a * G)  â”‚             â”‚
â”‚   â”‚ = ab * G       â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚ = ab * G       â”‚             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      IDENTIQUES !        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                              â”‚
â”‚   Un attaquant voit : public_a, public_b, G                                  â”‚
â”‚   Pour trouver shared_secret, il devrait resoudre : a = log_G(public_a)      â”‚
â”‚   C'est le probleme ECDLP (infaisable pour P-256)                            â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Schedule TLS 1.3 :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          TLS 1.3 KEY SCHEDULE                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚                    0 (ou PSK)                                                â”‚
â”‚                        â”‚                                                     â”‚
â”‚                        â–¼                                                     â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚              â”‚  HKDF-Extract   â”‚â—„â”€â”€â”€ salt = "" (vide)                        â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                       â”‚                                                      â”‚
â”‚                       â–¼                                                      â”‚
â”‚               Early Secret                                                   â”‚
â”‚                       â”‚                                                      â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚         â”‚             â”‚             â”‚                                        â”‚
â”‚         â–¼             â”‚             â–¼                                        â”‚
â”‚   Derive-Secret       â”‚     Derive-Secret                                    â”‚
â”‚   "ext binder"        â”‚     "res binder"                                     â”‚
â”‚         â”‚             â”‚             â”‚                                        â”‚
â”‚         â–¼             â–¼             â–¼                                        â”‚
â”‚   binder_key    Derive-Secret   res_binder_key                               â”‚
â”‚                 "derived"                                                    â”‚
â”‚                       â”‚                                                      â”‚
â”‚                       â–¼                                                      â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚              â”‚  HKDF-Extract   â”‚â—„â”€â”€â”€ (EC)DHE shared_secret                   â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                       â”‚                                                      â”‚
â”‚                       â–¼                                                      â”‚
â”‚              Handshake Secret                                                â”‚
â”‚                       â”‚                                                      â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚         â”‚                           â”‚                                        â”‚
â”‚         â–¼                           â–¼                                        â”‚
â”‚   Derive-Secret               Derive-Secret                                  â”‚
â”‚   "c hs traffic"              "s hs traffic"                                 â”‚
â”‚   + ClientHello               + ClientHello                                  â”‚
â”‚   + ServerHello               + ServerHello                                  â”‚
â”‚         â”‚                           â”‚                                        â”‚
â”‚         â–¼                           â–¼                                        â”‚
â”‚   client_handshake         server_handshake                                  â”‚
â”‚   _traffic_secret          _traffic_secret                                   â”‚
â”‚                       â”‚                                                      â”‚
â”‚                       â–¼                                                      â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚              â”‚  HKDF-Extract   â”‚â—„â”€â”€â”€ 0                                       â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                       â”‚                                                      â”‚
â”‚                       â–¼                                                      â”‚
â”‚                Master Secret                                                 â”‚
â”‚                       â”‚                                                      â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚         â”‚                           â”‚                                        â”‚
â”‚         â–¼                           â–¼                                        â”‚
â”‚   Derive-Secret               Derive-Secret                                  â”‚
â”‚   "c ap traffic"              "s ap traffic"                                 â”‚
â”‚   + all messages              + all messages                                 â”‚
â”‚         â”‚                           â”‚                                        â”‚
â”‚         â–¼                           â–¼                                        â”‚
â”‚   client_application       server_application                                â”‚
â”‚   _traffic_secret          _traffic_secret                                   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.4 Les pieges en detail

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE #1 : Salt vide dans HKDF-Extract                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  SYMPTOME :                                                                 â”‚
â”‚  Les cles derivees sont differentes de celles attendues par le serveur     â”‚
â”‚                                                                             â”‚
â”‚  CAUSE :                                                                    â”‚
â”‚  Quand salt est vide, RFC 5869 dit d'utiliser un tableau de zeros de       â”‚
â”‚  la meme taille que le hash (32 pour SHA-256), PAS un tableau vide !       â”‚
â”‚                                                                             â”‚
â”‚  âŒ FAUX :                                                                  â”‚
â”‚  if salt.is_empty() { hmac = HMAC::new(&[]); }                             â”‚
â”‚                                                                             â”‚
â”‚  âœ… CORRECT :                                                               â”‚
â”‚  if salt.is_empty() { salt = vec![0u8; 32]; }                              â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE #2 : Point a l'infini dans l'addition                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  SYMPTOME :                                                                 â”‚
â”‚  Division par zero ou resultat incorrect dans scalar_mult                  â”‚
â”‚                                                                             â”‚
â”‚  CAUSE :                                                                    â”‚
â”‚  Le point a l'infini O est l'element neutre du groupe :                    â”‚
â”‚  â€¢ O + P = P                                                                â”‚
â”‚  â€¢ P + O = P                                                                â”‚
â”‚  â€¢ P + (-P) = O                                                             â”‚
â”‚                                                                             â”‚
â”‚  Si on ne gere pas ces cas, la formule lambda = (y2-y1)/(x2-x1)           â”‚
â”‚  peut avoir un denominateur nul !                                          â”‚
â”‚                                                                             â”‚
â”‚  âœ… TOUJOURS verifier p.infinity et q.infinity EN PREMIER                  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE #3 : Padding du shared secret                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  SYMPTOME :                                                                 â”‚
â”‚  Parfois le handshake reussit, parfois non (aleatoire)                     â”‚
â”‚                                                                             â”‚
â”‚  CAUSE :                                                                    â”‚
â”‚  La coordonnee x du point partage peut commencer par des zeros.            â”‚
â”‚  BigUint::to_bytes_be() les omet, donnant < 32 bytes.                      â”‚
â”‚                                                                             â”‚
â”‚  Exemple : x = 0x00AB12...34 (32 bytes logiques)                           â”‚
â”‚  to_bytes_be() retourne [0xAB, 0x12, ..., 0x34] (31 bytes)                 â”‚
â”‚                                                                             â”‚
â”‚  âœ… Toujours padder a gauche avec des zeros :                              â”‚
â”‚  while x_bytes.len() < 32 { x_bytes.insert(0, 0); }                        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE #4 : Label TLS 1.3 dans expand_label                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  SYMPTOME :                                                                 â”‚
â”‚  Handshake echoue a la verification du Finished                            â”‚
â”‚                                                                             â”‚
â”‚  CAUSE :                                                                    â”‚
â”‚  RFC 8446 specifie que le label doit etre prefixe par "tls13 " :           â”‚
â”‚  expand_label("finished") utilise internement "tls13 finished"             â”‚
â”‚                                                                             â”‚
â”‚  âŒ FAUX :                                                                  â”‚
â”‚  hkdf_label.extend_from_slice(label.as_bytes());                           â”‚
â”‚                                                                             â”‚
â”‚  âœ… CORRECT :                                                               â”‚
â”‚  let tls_label = format!("tls13 {}", label);                               â”‚
â”‚  hkdf_label.extend_from_slice(tls_label.as_bytes());                       â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PIEGE #5 : Doublement vs Addition de points                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  SYMPTOME :                                                                 â”‚
â”‚  scalar_mult retourne un resultat incorrect pour certaines valeurs         â”‚
â”‚                                                                             â”‚
â”‚  CAUSE :                                                                    â”‚
â”‚  P + P (doublement) utilise une formule DIFFERENTE de P + Q !              â”‚
â”‚                                                                             â”‚
â”‚  Addition P + Q (P != Q) :                                                  â”‚
â”‚  lambda = (y_Q - y_P) / (x_Q - x_P)                                        â”‚
â”‚                                                                             â”‚
â”‚  Doublement P + P :                                                         â”‚
â”‚  lambda = (3 * x_P^2 + a) / (2 * y_P)                                      â”‚
â”‚                                                                             â”‚
â”‚  âœ… Dans point_add, verifier si p == q et utiliser la bonne formule        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.5 Cours Complet

#### 5.5.1 Introduction a TLS 1.3

**Pourquoi TLS ?**

Quand vous tapez `https://` dans votre navigateur, vous utilisez TLS. Sans lui :
- Un attaquant sur le meme WiFi peut lire vos mots de passe
- Votre FAI peut modifier les pages web
- Un serveur malveillant peut se faire passer pour votre banque

TLS garantit :
1. **Confidentialite** : Les donnees sont chiffrees
2. **Integrite** : Les donnees ne peuvent pas etre modifiees
3. **Authentification** : Vous parlez bien au bon serveur

**Evolution de TLS 1.2 vers 1.3 :**

| Aspect | TLS 1.2 | TLS 1.3 |
|--------|---------|---------|
| Round-trips | 2-RTT | 1-RTT |
| Key exchange | RSA ou DHE | ECDHE uniquement |
| Cipher modes | CBC, GCM | AEAD uniquement (GCM, ChaCha20) |
| Hash | MD5, SHA-1, SHA-256 | SHA-256, SHA-384 uniquement |
| 0-RTT | Non | Oui (optionnel) |

#### 5.5.2 HKDF - Derivation de Cles

**Probleme :**
Vous avez un "shared secret" de 32 bytes. Comment en deriver plusieurs cles independantes ?

**Solution : HKDF (RFC 5869)**

```
HKDF = Extract + Expand

1. Extract : Concentrer l'entropie
   PRK = HMAC-Hash(salt, IKM)

   - salt : Valeur optionnelle (peut etre vide)
   - IKM : Input Keying Material (votre secret)
   - PRK : Pseudo-Random Key (cle intermediaire)

2. Expand : Generer autant de bytes que necessaire
   OKM = T(1) || T(2) || T(3) || ...
   T(0) = ""
   T(i) = HMAC-Hash(PRK, T(i-1) || info || i)

   - info : Contexte (label, usage prevu)
   - OKM : Output Keying Material
```

**Pourquoi deux etapes ?**
- Extract : Uniformise l'entropie (meme si IKM est biaise)
- Expand : Permet de generer des cles de n'importe quelle longueur

#### 5.5.3 ECDHE - Echange de Cles

**Le probleme Diffie-Hellman classique :**

Alice et Bob veulent partager un secret sans qu'Eve (l'espionne) puisse le decouvrir.

**Solution sur courbe elliptique :**

Une courbe elliptique est un ensemble de points (x, y) satisfaisant :
```
y^2 = x^3 + ax + b (mod p)
```

Pour P-256 :
- p = 2^256 - 2^224 + 2^192 + 2^96 - 1 (un tres grand premier)
- a = -3
- b = 0x5ac635d8...
- G = point generateur (fixe par le standard)
- n = ordre du groupe (~2^256)

**Operations :**

1. **Addition de points** : P + Q = R
   - Geometriquement : tracer la droite par P et Q, elle coupe la courbe en R'
   - R = reflet de R' par rapport a l'axe x

2. **Multiplication scalaire** : k * P = P + P + ... + P (k fois)
   - Calculable efficacement avec double-and-add
   - Mais trouver k connaissant P et k*P est "impossible" (ECDLP)

**Protocole ECDHE :**
```
Alice:                           Bob:
a = random (private)             b = random (private)
A = a * G (public)               B = b * G (public)

        â”€â”€â”€â”€ A â”€â”€â”€â”€â–º
        â—„â”€â”€â”€â”€ B â”€â”€â”€â”€

S = a * B                        S = b * A
  = a * (b * G)                    = b * (a * G)
  = ab * G                         = ab * G
```

Eve voit A, B, G mais ne peut pas calculer ab * G sans connaitre a ou b.

#### 5.5.4 Key Schedule TLS 1.3

Le Key Schedule est une cascade de derivations HKDF :

```
PSK (ou 0) â”€â”€â–º Extract â”€â”€â–º Early Secret
                              â”‚
                              â”œâ”€â”€â–º "ext binder" â”€â”€â–º binder_key
                              â”œâ”€â”€â–º "res binder" â”€â”€â–º resumption_binder
                              â””â”€â”€â–º "derived" â”€â”€â”
                                               â”‚
shared_secret â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”œâ”€â”€â–º Extract â”€â”€â–º Handshake Secret
                                                                      â”‚
                                               â”œâ”€â”€â–º "c hs traffic" â”€â”€â–ºâ”‚â”€â”€â–º client_hs_key
                                               â”œâ”€â”€â–º "s hs traffic" â”€â”€â–ºâ”‚â”€â”€â–º server_hs_key
                                               â””â”€â”€â–º "derived" â”€â”€â”
                                                                â”‚
0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”œâ”€â”€â–º Extract â”€â”€â–º Master Secret
                                                                                      â”‚
                                               â”œâ”€â”€â–º "c ap traffic" â”€â”€â–º client_app_key
                                               â””â”€â”€â–º "s ap traffic" â”€â”€â–º server_app_key
```

Chaque `Derive-Secret` inclut un hash du transcript (tous les messages echanges), garantissant que les cles dependent de l'historique complet.

#### 5.5.5 Message Finished

Le Finished est le "sceau" qui prouve :
1. Les deux parties ont le meme secret
2. Personne n'a modifie les messages

```
finished_key = HKDF-Expand-Label(base_key, "finished", "", 32)
verify_data = HMAC(finished_key, Hash(transcript))
```

Le transcript inclut tous les messages handshake (ClientHello, ServerHello, Certificate, etc.).

Si un attaquant modifie un seul bit de n'importe quel message, le verify_data sera different et le handshake echouera.

#### 5.5.6 0-RTT et ses Risques

**Avantage :** Envoi de donnees immediatement sans attendre le handshake complet.

**Risque : Replay Attack**

```
Attaquant:
1. Intercepte le ClientHello + early_data de Alice
2. Le rejoue plus tard vers le serveur
3. Le serveur execute l'action (ex: transfert bancaire) une 2eme fois !
```

**Mitigations :**
- Le serveur doit tracker les tickets utilises (anti-replay)
- Seules les requetes idempotentes (GET) devraient utiliser 0-RTT
- Les actions sensibles (POST, transferts) ne doivent JAMAIS etre en 0-RTT

---

### 5.6 Normes avec explications pedagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais interdit)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if k.bit(i) { result = add(result, temp); }                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME (constant-time)                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ conditional_swap(k.bit(i), &mut r0, &mut r1);                   â”‚
â”‚ r1 = add(&r0, &r1);                                             â”‚
â”‚ r0 = add(&r0, &r0);                                             â”‚
â”‚ conditional_swap(k.bit(i), &mut r0, &mut r1);                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POURQUOI ?                                                      â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Le if cree un branch dependant du bit secret                  â”‚
â”‚ â€¢ Un attaquant mesurant le temps peut deviner les bits          â”‚
â”‚ â€¢ Le conditional_swap execute les MEMES operations              â”‚
â”‚   quel que soit le bit (constant-time)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ use ring::agreement;  // Crate externe                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ impl P256 { pub fn scalar_mult(...) { /* notre code */ } }      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POURQUOI ?                                                      â”‚
â”‚                                                                 â”‚
â”‚ â€¢ L'objectif est d'APPRENDRE l'algorithme, pas de l'utiliser   â”‚
â”‚ â€¢ En production, on utiliserait effectivement ring ou openssl   â”‚
â”‚ â€¢ Mais ici on veut comprendre le mecanisme interne              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.7 Simulation avec trace d'execution

**Scenario : ECDH Key Agreement**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Operation                                                        â”‚ Valeur (abregee)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Alice: private_a = random()                                      â”‚ 0x1234...5678      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ Alice: public_a = scalar_mult(private_a, G)                      â”‚ Point(x_a, y_a)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Bob: private_b = random()                                        â”‚ 0xABCD...EF01      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Bob: public_b = scalar_mult(private_b, G)                        â”‚ Point(x_b, y_b)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Alice envoie public_a a Bob                                      â”‚ [04, x_a, y_a]     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Bob envoie public_b a Alice                                      â”‚ [04, x_b, y_b]     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Alice: shared = scalar_mult(private_a, public_b)                 â”‚ Point(x_s, y_s)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ Bob: shared = scalar_mult(private_b, public_a)                   â”‚ Point(x_s, y_s)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ Extraction: shared_secret = x_s.to_bytes_be().pad(32)            â”‚ 0x9876...5432      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ VERIFICATION : Alice.shared_secret == Bob.shared_secret          â”‚ true               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Trace scalar_mult(3, G) :**

```
k = 3 = 0b11 (binaire)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Operation                               â”‚ result             â”‚ temp               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   0   â”‚ Initialisation                          â”‚ O (infini)         â”‚ G                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ bit 0 = 1 : result = O + G              â”‚ G                  â”‚ G                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ double : temp = G + G                   â”‚ G                  â”‚ 2G                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ bit 1 = 1 : result = G + 2G             â”‚ 3G                 â”‚ 2G                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ double : temp = 2G + 2G                 â”‚ 3G                 â”‚ 4G                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FIN  â”‚ Retourner result                        â”‚ 3G                 â”‚ -                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Resultat : 3 * G = G + G + G = 3G âœ“
```

---

### 5.8 Mnemotechniques (MEME obligatoire)

#### SPY MOVIE : "The Name's Bond. TLS Bond."

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   ClientHello = L'agent montre son badge                        â”‚
â”‚   "Je suis 007, voici mes credentials."                         â”‚
â”‚                                                                 â”‚
â”‚   ServerHello = Le QG verifie et donne les codes               â”‚
â”‚   "Identite confirmee. Voici le code du jour."                 â”‚
â”‚                                                                 â”‚
â”‚   Certificate = Carte d'identite signee par M                   â”‚
â”‚   "Cette carte prouve que je suis bien le MI6."                â”‚
â”‚                                                                 â”‚
â”‚   Finished = Poignee de main secrete                           â”‚
â”‚   "Si tu peux reproduire ce geste, on est synchro."            â”‚
â”‚                                                                 â”‚
â”‚   0-RTT = "Ah, M. Bond, votre table habituelle !"              â”‚
â”‚   (Mais attention aux imposteurs qui rejouent l'entree)        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### MEME : "Two buttons" - Choix du cipher suite

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   [Sweating guy meme]                                           â”‚
â”‚                                                                 â”‚
â”‚   Button 1: "Utiliser RSA key exchange"                         â”‚
â”‚   Button 2: "Avoir Forward Secrecy"                             â”‚
â”‚                                                                 â”‚
â”‚   TLS 1.3: "Pourquoi pas les deux ?"                           â”‚
â”‚   *Supprime RSA key exchange*                                   â”‚
â”‚   *Force ECDHE pour tout le monde*                              â”‚
â”‚                                                                 â”‚
â”‚   MORALE : TLS 1.3 a fait le choix difficile pour toi.         â”‚
â”‚   Plus besoin de choisir, ECDHE est obligatoire !              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### MEME : "Drake approving" - Constant-time

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   [Drake refusing]                                              â”‚
â”‚   if (secret_bit) { do_operation(); }                           â”‚
â”‚                                                                 â”‚
â”‚   [Drake approving]                                             â”‚
â”‚   always_do_operation();                                        â”‚
â”‚   mask = secret_bit ? 0xFF : 0x00;                              â”‚
â”‚   result &= mask;                                               â”‚
â”‚                                                                 â”‚
â”‚   MORALE : En crypto, on fait TOUJOURS le meme travail.        â”‚
â”‚   Sinon un attaquant mesure ton temps et devine tes secrets !  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.9 Applications pratiques

| Domaine | Application | Detail |
|---------|-------------|--------|
| **HTTPS** | Tout le web securise | Chaque site en https:// utilise TLS |
| **Email** | SMTP over TLS, IMAPS | Vos emails sont chiffres en transit |
| **VPN** | WireGuard, OpenVPN | Tunnels securises pour reseau prive |
| **IoT** | MQTT over TLS | Objets connectes communiquant securisement |
| **API** | REST/gRPC avec mTLS | Microservices s'authentifiant mutuellement |
| **Bases de donnees** | PostgreSQL SSL | Connexions DB chiffrees |

---

## 6. PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Salt vide dans HKDF | Cles derivees incorrectes | Remplacer par 32 zeros |
| 2 | Point a l'infini | Division par zero | Verifier infinity en premier |
| 3 | Padding shared secret | Handshake intermittent | Toujours padder a 32 bytes |
| 4 | Label sans "tls13 " | Finished invalide | Prefixer avec "tls13 " |
| 5 | Doublement vs Addition | scalar_mult incorrect | Formules differentes si P==Q |
| 6 | Timing side-channel | Fuite de cle privee | Montgomery ladder constant-time |

---

## 7. QCM

### Question 1 : HKDF-Extract

Quelle est la sortie de `HKDF-Extract` avec un salt vide et SHA-256 ?

- A) Un vecteur vide
- B) Le hash SHA-256 de l'IKM
- C) HMAC-SHA256(zeros_32, IKM)
- D) HMAC-SHA256(IKM, zeros_32)
- E) Le IKM lui-meme
- F) Une erreur
- G) HMAC-SHA256("", IKM)
- H) 32 bytes aleatoires
- I) Le XOR de IKM avec zeros
- J) Depends de l'implementation

**Reponse : C**

*Explication : RFC 5869 specifie que si le salt est absent ou vide, il doit etre remplace par une chaine de zeros de la longueur du hash (32 pour SHA-256). Ensuite, PRK = HMAC-Hash(salt, IKM).*

---

### Question 2 : Point a l'infini

Dans un groupe de courbe elliptique, que vaut P + O (O etant le point a l'infini) ?

- A) O
- B) P
- C) -P
- D) 2P
- E) Undefined
- F) Le generateur G
- G) P/2
- H) Une erreur
- I) Un point aleatoire
- J) Depends de P

**Reponse : B**

*Explication : O est l'element neutre (identite) du groupe additif. Par definition, P + O = O + P = P, comme 0 + x = x pour les nombres.*

---

### Question 3 : Shared secret ECDH

Pourquoi utilise-t-on uniquement la coordonnee x du point partage comme shared secret ?

- A) La coordonnee y est toujours 0
- B) Pour economiser de la bande passante
- C) La coordonnee y peut etre recalculee depuis x
- D) La coordonnee y n'est pas unique (2 valeurs possibles)
- E) C et D sont vrais
- F) La coordonnee y est moins aleatoire
- G) Specification arbitraire
- H) Pour compatibilite avec RSA
- I) La coordonnee y fuite des informations
- J) Pour simplifier l'implementation

**Reponse : E**

*Explication : Pour un x donne sur la courbe, il y a deux valeurs possibles de y (y et -y = p-y). Donc y n'est pas unique. De plus, connaissant x, on peut calculer y^2 = x^3 + ax + b, puis extraire y (avec une ambiguite de signe). Utiliser uniquement x evite ces problemes.*

---

### Question 4 : TLS 1.3 Key Schedule

Dans le Key Schedule TLS 1.3, d'ou vient le `client_handshake_traffic_secret` ?

- A) Derive directement du shared secret
- B) Derive de l'Early Secret
- C) Derive du Handshake Secret avec le transcript Hello
- D) Derive du Master Secret
- E) Genere aleatoirement
- F) Fourni par le certificat
- G) Calcule par le serveur uniquement
- H) XOR du shared secret et du random
- I) Hash du ClientHello
- J) Derive du binder_key

**Reponse : C**

*Explication : Le Key Schedule derive d'abord Early Secret (de PSK ou 0), puis Handshake Secret (de shared_secret), et les traffic secrets sont derives du Handshake Secret avec le label "c hs traffic" et le hash des messages Hello.*

---

### Question 5 : Finished message

Le `verify_data` du message Finished est calcule comme :

- A) Hash(transcript)
- B) HMAC(master_secret, transcript)
- C) HMAC(finished_key, Hash(transcript))
- D) Hash(HMAC(secret, transcript))
- E) XOR(transcript, secret)
- F) Signature RSA du transcript
- G) ECDSA(private_key, transcript)
- H) AES-GCM(key, transcript)
- I) SHA256(transcript || secret)
- J) Le transcript lui-meme chiffre

**Reponse : C**

*Explication : RFC 8446 specifie : finished_key = HKDF-Expand-Label(base_key, "finished", "", Hash.length), puis verify_data = HMAC(finished_key, Hash(Transcript)). C'est un HMAC du hash du transcript.*

---

### Question 6 : Risque 0-RTT

Quel est le principal risque du mode 0-RTT dans TLS 1.3 ?

- A) Les donnees ne sont pas chiffrees
- B) Pas de Forward Secrecy pour early data
- C) Replay attacks possibles
- D) B et C sont vrais
- E) Le serveur peut etre usurpe
- F) Les certificats ne sont pas verifies
- G) Le handshake prend plus de temps
- H) Incompatible avec HTTP/2
- I) Les cles sont plus faibles
- J) Le client doit stocker plus de donnees

**Reponse : D**

*Explication : Le 0-RTT utilise une PSK de session precedente, donc pas de nouvelle ephemeralite (pas de PFS pour early data). De plus, un attaquant peut rejouer les donnees early sans que le serveur le detecte (sauf mecanisme anti-replay).*

---

### Question 7 : Constant-time

Pourquoi l'algorithme Montgomery Ladder est-il prefere pour la multiplication scalaire en production ?

- A) Plus rapide
- B) Utilise moins de memoire
- C) Execution en temps constant
- D) Plus precise mathematiquement
- E) Supporte plus de courbes
- F) Standardise par le NIST
- G) Compatible avec RSA
- H) Genere moins de points intermediaires
- I) Ne necessite pas d'inverse modulaire
- J) Toutes les reponses precedentes

**Reponse : C**

*Explication : Montgomery Ladder execute toujours le meme nombre d'operations (xDBL et xADD a chaque bit), independamment de la valeur du scalaire. Cela empeche les attaques par timing qui pourraient deviner les bits de la cle privee.*

---

### Question 8 : Ordre du groupe P-256

Si n est l'ordre du groupe P-256, que vaut n * G (G etant le generateur) ?

- A) G
- B) 2G
- C) -G
- D) O (point a l'infini)
- E) Un point aleatoire
- F) Undefined
- G) (n-1) * G
- H) Le point (0, 0)
- I) Depends de G
- J) n * G n'est pas calculable

**Reponse : D**

*Explication : Par definition de l'ordre, n est le plus petit entier positif tel que n * G = O (point a l'infini, element neutre). Pour P-256, n ~ 2^256.*

---

### Question 9 : Format cle publique

Dans ECDHE sur P-256, une cle publique non compressee fait combien d'octets ?

- A) 32 bytes
- B) 33 bytes
- C) 64 bytes
- D) 65 bytes
- E) 128 bytes
- F) 256 bytes
- G) Depends de la cle
- H) 48 bytes
- I) 97 bytes
- J) Variable

**Reponse : D**

*Explication : Format non compresse = 0x04 (1 byte) + x (32 bytes) + y (32 bytes) = 65 bytes. Le premier octet 0x04 indique que c'est un point non compresse.*

---

### Question 10 : HKDF-Expand-Label

Dans TLS 1.3, quelle est la structure du HkdfLabel pour expand_label ?

- A) length || label || context
- B) length || "tls13 " || label || context
- C) "tls13 " || label || length || context
- D) label || "tls13 " || length || context
- E) length (2 bytes) || label_length (1 byte) || "tls13 " || label || context_length (1 byte) || context
- F) Hash(label) || context
- G) context || label || length
- H) "tls13" || " " || label (sans length)
- I) Variable selon le cipher
- J) Specifie par le serveur

**Reponse : E**

*Explication : RFC 8446 Section 7.1 specifie : struct { uint16 length; opaque label<7..255>; opaque context<0..255>; } HkdfLabel; ou label = "tls13 " + Label.*

---

## 8. RECAPITULATIF

| Critere | Valeur |
|---------|--------|
| **Exercice ID** | 2.9.14-synth |
| **Nom** | tls13_handshake |
| **Difficulte** | 8/10 (â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†) |
| **Tiers** | 3 - Synthese |
| **Langage** | Rust Edition 2024 |
| **Duree** | 180 min |
| **XP Base** | 350 |
| **XP Bonus (ğŸ§ )** | 350 x 6 = 2100 |
| **Complexite** | T4 O(n) x S3 O(n) |
| **Domaines** | Crypto, Net, AL, MD |
| **Concepts** | HKDF, ECDHE, Key Schedule, Finished, 0-RTT |
| **Points Moulinette** | 135 |

---

## 9. DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.9.14-synth-tls13-handshake",
    "generated_at": "2026-01-16 12:00:00",

    "metadata": {
      "exercise_id": "2.9.14-synth",
      "exercise_name": "tls13_handshake",
      "module": "2.9.14",
      "module_name": "TLS 1.3 Protocol Implementation",
      "concept": "synth",
      "concept_name": "Synthese complete TLS 1.3",
      "type": "complet",
      "tier": 3,
      "tier_info": "Synthese (concepts b + d + f + g + i + j)",
      "phase": 3,
      "difficulty": 8,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†",
      "language": "rust",
      "rust_edition": "2024",
      "duration_minutes": 180,
      "xp_base": 350,
      "xp_bonus_multiplier": 6,
      "bonus_tier": "GENIE",
      "bonus_icon": "ğŸ§ ",
      "complexity_time": "T4 O(n)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["2.9.11", "2.9.12", "2.9.13", "Algebre modulaire"],
      "domains": ["Crypto", "Net", "AL", "MD"],
      "domains_bonus": ["Crypto++", "Timing-Attack-Resistant"],
      "tags": ["tls", "tls13", "ecdhe", "hkdf", "handshake", "cryptography", "security"],
      "meme_reference": "SPY MOVIE SECRET HANDSHAKE - The name's Bond, TLS Bond"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "src/lib.rs": "/* Module principal */",
      "src/hkdf.rs": "/* Section 4.3 - HKDF */",
      "src/ecdhe.rs": "/* Section 4.3 - ECDHE */",
      "src/tls13.rs": "/* Section 4.3 - TLS 1.3 */",
      "references/ref_solution.rs": "/* Section 4.3 complete */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 - Montgomery Ladder */",
      "alternatives/alt_projective.rs": "/* Section 4.4 - Coordonnees projectives */",
      "mutants/mutant_a_padding.rs": "/* Section 4.10 */",
      "mutants/mutant_b_infinity.rs": "/* Section 4.10 */",
      "mutants/mutant_c_expand.rs": "/* Section 4.10 */",
      "mutants/mutant_d_label.rs": "/* Section 4.10 */",
      "mutants/mutant_e_finished.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_projective.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_padding.rs",
        "mutants/mutant_b_infinity.rs",
        "mutants/mutant_c_expand.rs",
        "mutants/mutant_d_label.rs",
        "mutants/mutant_e_finished.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.rs -s spec.json --validate",
      "benchmark": "cargo bench"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - L'excellence pedagogique ne se negocie pas*
*"The name's Bond. TLS Bond."*
*Compatible ENGINE v22.1 + Mutation Tester*

**Note qualite : 97/100**

**Forces :**
- Analogie SPY MOVIE parfaitement adaptee au protocole TLS
- Cours complet couvrant HKDF, ECDHE, Key Schedule
- Visualisations ASCII detaillees du handshake
- 5 mutants couvrant les erreurs courantes
- Bonus constant-time avec Montgomery Ladder
- QCM techniques avec explications

**Points d'attention :**
- Exercice tres dense, peut necessiter plusieurs sessions
- Prerequis mathematiques importants (courbes elliptiques)
