# Ex03: ClassicSync - Classic Synchronization Problems

## Concepts couverts
- 2.4.13.c (Consumers: Remove items)
- 2.4.16.c (Mutual exclusion: Resource exclusive)
- 2.4.16.f (Circular wait: Chain of waiting)
- 2.4.16.g (Resource allocation graph: Visualization)
- 2.4.17.a (Deny mutual exclusion: Share when possible)
- 2.4.17.b (Deny hold and wait: Request all at once)
- 2.4.17.c (Allow preemption: Take resources)
- 2.4.17.d (Deny circular wait: Lock ordering)
- 2.4.17.g (Practical approach: Ordering + timeouts)
- 2.4.18.c (Banker's algorithm: Check safety)
- 2.4.18.g (Need: Max - Allocation)
- 2.4.18.h (Safety algorithm: Find safe sequence)
- 2.4.18.i (Request algorithm: Check before grant)
- 2.4.19.a (Detection algorithm: Find cycles)
- 2.4.19.b (When to detect: Periodically or on wait)
- 2.4.19.c (Recovery: terminate: Kill deadlocked)
- 2.4.19.d (Kill all: Drastic)
- 2.4.19.e (Kill one by one: Until resolved)
- 2.4.19.f (Recovery: preempt: Take resources)
- 2.4.19.g (Rollback: Checkpoint and restore)
- 2.4.19.h (Victim selection: Minimize cost)

## Description
Implementer les problemes classiques de synchronisation (Producer-Consumer, Readers-Writers, Dining Philosophers) avec plusieurs solutions, plus un detecteur de deadlock et l'algorithme du banquier.

## Objectifs pedagogiques
1. Resoudre les problemes classiques avec differentes approches
2. Implementer l'algorithme du banquier
3. Detecter les deadlocks via detection de cycles
4. Comprendre les strategies de recovery
5. Comparer les performances des differentes solutions

## Structure (Rust 2024)

```rust
// src/lib.rs
use std::sync::{Arc, Mutex, Condvar, RwLock};
use std::collections::{HashMap, HashSet, VecDeque};
use std::thread;
use std::time::Duration;

// ============================================================
// Producer-Consumer
// ============================================================

pub struct BoundedBuffer<T> {
    buffer: Mutex<VecDeque<T>>,
    capacity: usize,
    not_empty: Condvar,
    not_full: Condvar,
    // Statistiques
    produced: Mutex<u64>,
    consumed: Mutex<u64>,
}

impl<T> BoundedBuffer<T> {
    pub fn new(capacity: usize) -> Self {
        todo!("Initialiser le buffer borne")
    }

    /// Ajouter un element (bloque si plein)
    pub fn produce(&self, item: T) {
        todo!("Attendre si plein, ajouter, signaler not_empty")
    }

    /// Ajouter avec timeout
    pub fn produce_timeout(&self, item: T, timeout: Duration) -> bool {
        todo!("Retourne false si timeout")
    }

    /// Retirer un element (bloque si vide)
    pub fn consume(&self) -> T {
        todo!("Attendre si vide, retirer, signaler not_full")
    }

    /// Retirer avec timeout
    pub fn consume_timeout(&self, timeout: Duration) -> Option<T> {
        todo!("Retourne None si timeout")
    }

    pub fn len(&self) -> usize {
        todo!()
    }

    pub fn stats(&self) -> (u64, u64) {
        todo!("Retourne (produced, consumed)")
    }
}

// Version avec semaphores
pub struct SemaphoreBuffer<T> {
    buffer: Mutex<VecDeque<T>>,
    empty_slots: std::sync::Semaphore,  // Note: std n'a pas de semaphore, utiliser parking_lot
    filled_slots: std::sync::Semaphore,
    mutex: Mutex<()>,
}

// ============================================================
// Readers-Writers
// ============================================================

pub enum RWPreference {
    ReadersFirst,
    WritersFirst,
    Fair,
}

pub struct ReadersWriters<T> {
    data: RwLock<T>,
    preference: RWPreference,
    // Pour readers-first
    readers_count: Mutex<i32>,
    resource_mutex: Mutex<()>,
    // Pour writers-first
    writers_waiting: Mutex<i32>,
    // Statistiques
    read_count: Mutex<u64>,
    write_count: Mutex<u64>,
}

impl<T> ReadersWriters<T> {
    pub fn new(data: T, preference: RWPreference) -> Self {
        todo!("Initialiser selon la preference")
    }

    /// Lire (acces partage)
    pub fn read<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&T) -> R,
    {
        todo!("Implementer selon la preference")
    }

    /// Ecrire (acces exclusif)
    pub fn write<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&mut T) -> R,
    {
        todo!("Implementer selon la preference")
    }

    pub fn stats(&self) -> (u64, u64) {
        todo!("Retourne (reads, writes)")
    }
}

// ============================================================
// Dining Philosophers
// ============================================================

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PhilosopherState {
    Thinking,
    Hungry,
    Eating,
}

pub trait DiningPhilosophers {
    fn new(num_philosophers: usize) -> Self;
    fn think(&self, philosopher_id: usize);
    fn eat(&self, philosopher_id: usize);
    fn get_state(&self, philosopher_id: usize) -> PhilosopherState;
    fn stats(&self) -> Vec<(u64, u64)>;  // (times_eaten, times_thought) par philosophe
}

/// Solution 1: Resource Ordering (toujours prendre la fourchette de numero inferieur d'abord)
pub struct OrderedPhilosophers {
    forks: Vec<Mutex<()>>,
    states: Vec<Mutex<PhilosopherState>>,
    num: usize,
}

impl DiningPhilosophers for OrderedPhilosophers {
    fn new(num_philosophers: usize) -> Self {
        todo!("Creer les fourchettes")
    }

    fn think(&self, philosopher_id: usize) {
        todo!()
    }

    fn eat(&self, philosopher_id: usize) {
        todo!("Prendre les fourchettes dans l'ordre croissant")
    }

    fn get_state(&self, philosopher_id: usize) -> PhilosopherState {
        todo!()
    }

    fn stats(&self) -> Vec<(u64, u64)> {
        todo!()
    }
}

/// Solution 2: Central Waiter (mutex central)
pub struct WaiterPhilosophers {
    forks: Vec<Mutex<()>>,
    waiter: Mutex<()>,
    states: Vec<Mutex<PhilosopherState>>,
    num: usize,
}

impl DiningPhilosophers for WaiterPhilosophers {
    fn new(num_philosophers: usize) -> Self {
        todo!()
    }

    fn think(&self, philosopher_id: usize) {
        todo!()
    }

    fn eat(&self, philosopher_id: usize) {
        todo!("Demander au waiter avant de prendre les fourchettes")
    }

    fn get_state(&self, philosopher_id: usize) -> PhilosopherState {
        todo!()
    }

    fn stats(&self) -> Vec<(u64, u64)> {
        todo!()
    }
}

/// Solution 3: Chandy/Misra (fourchettes dirty/clean)
pub struct ChandyMisraPhilosophers {
    // Chaque fourchette a un etat (clean/dirty) et un proprietaire
    forks: Vec<Mutex<ForkState>>,
    request_channels: Vec<(Mutex<bool>, Condvar)>,  // Signale une requete
    states: Vec<Mutex<PhilosopherState>>,
    num: usize,
}

#[derive(Clone, Copy)]
struct ForkState {
    owner: usize,
    dirty: bool,
}

// ============================================================
// Banker's Algorithm
// ============================================================

pub struct BankersAlgorithm {
    num_processes: usize,
    num_resources: usize,
    available: Vec<i32>,
    maximum: Vec<Vec<i32>>,
    allocation: Vec<Vec<i32>>,
    need: Vec<Vec<i32>>,
}

impl BankersAlgorithm {
    pub fn new(num_processes: usize, num_resources: usize, available: Vec<i32>) -> Self {
        todo!("Initialiser avec 0 allocations")
    }

    /// Declarer le maximum de ressources qu'un processus peut demander
    pub fn declare_max(&mut self, process: usize, max: Vec<i32>) {
        todo!("Mettre a jour maximum et need")
    }

    /// Verifier si l'etat courant est safe
    pub fn is_safe(&self) -> bool {
        todo!("Algorithme de safety")
    }

    /// Trouver une sequence safe (si existe)
    pub fn find_safe_sequence(&self) -> Option<Vec<usize>> {
        todo!("Retourner l'ordre d'execution safe")
    }

    /// Demander des ressources (retourne true si accorde)
    pub fn request(&mut self, process: usize, request: Vec<i32>) -> bool {
        todo!("Verifier si safe avant d'accorder")
    }

    /// Liberer des ressources
    pub fn release(&mut self, process: usize, release: Vec<i32>) {
        todo!("Mettre a jour allocation et available")
    }

    /// Obtenir le besoin restant d'un processus
    pub fn get_need(&self, process: usize) -> &Vec<i32> {
        &self.need[process]
    }
}

// ============================================================
// Deadlock Detection
// ============================================================

pub struct DeadlockDetector {
    // Graphe d'allocation de ressources
    // Processus -> Ressources detenues
    holds: HashMap<usize, HashSet<usize>>,
    // Processus -> Ressources demandees
    waits_for: HashMap<usize, HashSet<usize>>,
    // Ressource -> Processus qui la detient
    held_by: HashMap<usize, usize>,
}

impl DeadlockDetector {
    pub fn new() -> Self {
        DeadlockDetector {
            holds: HashMap::new(),
            waits_for: HashMap::new(),
            held_by: HashMap::new(),
        }
    }

    /// Enregistrer qu'un processus detient une ressource
    pub fn acquire(&mut self, process: usize, resource: usize) {
        todo!("Mettre a jour holds et held_by")
    }

    /// Enregistrer qu'un processus libere une ressource
    pub fn release(&mut self, process: usize, resource: usize) {
        todo!("Mettre a jour holds et held_by")
    }

    /// Enregistrer qu'un processus attend une ressource
    pub fn wait_for(&mut self, process: usize, resource: usize) {
        todo!("Ajouter a waits_for")
    }

    /// Detecter les deadlocks (cycles dans le graphe)
    pub fn detect_deadlock(&self) -> Option<Vec<usize>> {
        todo!("DFS pour trouver un cycle")
    }

    /// Suggerer des victimes pour la recovery
    pub fn suggest_victims(&self, deadlocked: &[usize]) -> Vec<usize> {
        todo!("Choisir les victimes selon un critere")
    }
}

// ============================================================
// Tests et benchmarks
// ============================================================

pub fn benchmark_producer_consumer(
    num_producers: usize,
    num_consumers: usize,
    items_per_producer: usize,
    buffer_size: usize,
) -> BenchmarkResult {
    todo!("Mesurer throughput et latence")
}

pub fn benchmark_readers_writers(
    num_readers: usize,
    num_writers: usize,
    iterations: usize,
    preference: RWPreference,
) -> BenchmarkResult {
    todo!("Mesurer avec differentes preferences")
}

#[derive(Debug)]
pub struct BenchmarkResult {
    pub throughput_ops_per_sec: f64,
    pub avg_latency_us: f64,
    pub fairness_index: f64,  // 0-1, 1 = parfaitement fair
}
```

## Tests Automatises

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_bounded_buffer() {
        let buffer = Arc::new(BoundedBuffer::<i32>::new(5));

        let producer = {
            let buf = Arc::clone(&buffer);
            thread::spawn(move || {
                for i in 0..10 {
                    buf.produce(i);
                }
            })
        };

        let consumer = {
            let buf = Arc::clone(&buffer);
            thread::spawn(move || {
                let mut sum = 0;
                for _ in 0..10 {
                    sum += buf.consume();
                }
                sum
            })
        };

        producer.join().unwrap();
        let sum = consumer.join().unwrap();
        assert_eq!(sum, 45);  // 0+1+...+9
    }

    #[test]
    fn test_readers_writers_readers_first() {
        let rw = Arc::new(ReadersWriters::new(0, RWPreference::ReadersFirst));

        let readers: Vec<_> = (0..5)
            .map(|_| {
                let rw = Arc::clone(&rw);
                thread::spawn(move || {
                    for _ in 0..100 {
                        rw.read(|val| {
                            let _ = *val;
                        });
                    }
                })
            })
            .collect();

        let writers: Vec<_> = (0..2)
            .map(|_| {
                let rw = Arc::clone(&rw);
                thread::spawn(move || {
                    for _ in 0..50 {
                        rw.write(|val| {
                            *val += 1;
                        });
                    }
                })
            })
            .collect();

        for r in readers {
            r.join().unwrap();
        }
        for w in writers {
            w.join().unwrap();
        }

        let final_val = rw.read(|val| *val);
        assert_eq!(final_val, 100);  // 2 writers * 50 increments
    }

    #[test]
    fn test_philosophers_no_deadlock() {
        let philosophers = Arc::new(OrderedPhilosophers::new(5));
        let num_meals = 100;

        let handles: Vec<_> = (0..5)
            .map(|id| {
                let phil = Arc::clone(&philosophers);
                thread::spawn(move || {
                    for _ in 0..num_meals {
                        phil.think(id);
                        thread::sleep(Duration::from_micros(10));
                        phil.eat(id);
                        thread::sleep(Duration::from_micros(10));
                    }
                })
            })
            .collect();

        for h in handles {
            h.join().unwrap();
        }

        // Verifier que tous ont mange
        let stats = philosophers.stats();
        for (eaten, _) in stats {
            assert_eq!(eaten, num_meals as u64);
        }
    }

    #[test]
    fn test_bankers_safety() {
        let mut banker = BankersAlgorithm::new(5, 3, vec![10, 5, 7]);

        // Declarer les maximums
        banker.declare_max(0, vec![7, 5, 3]);
        banker.declare_max(1, vec![3, 2, 2]);
        banker.declare_max(2, vec![9, 0, 2]);
        banker.declare_max(3, vec![2, 2, 2]);
        banker.declare_max(4, vec![4, 3, 3]);

        // Allocations initiales
        assert!(banker.request(0, vec![0, 1, 0]));
        assert!(banker.request(1, vec![2, 0, 0]));
        assert!(banker.request(2, vec![3, 0, 2]));
        assert!(banker.request(3, vec![2, 1, 1]));
        assert!(banker.request(4, vec![0, 0, 2]));

        // Verifier que l'etat est safe
        assert!(banker.is_safe());

        // Trouver une sequence safe
        let seq = banker.find_safe_sequence();
        assert!(seq.is_some());
        println!("Safe sequence: {:?}", seq.unwrap());
    }

    #[test]
    fn test_bankers_unsafe_request() {
        let mut banker = BankersAlgorithm::new(2, 1, vec![1]);

        banker.declare_max(0, vec![2]);
        banker.declare_max(1, vec![2]);

        // Premiere allocation OK
        assert!(banker.request(0, vec![1]));

        // Deuxieme allocation mettrait dans un etat unsafe
        // (les deux processus auraient besoin de 1 de plus, mais il n'y en a plus)
        assert!(!banker.request(1, vec![1]));
    }

    #[test]
    fn test_deadlock_detection() {
        let mut detector = DeadlockDetector::new();

        // Creer un deadlock: P0 holds R0, waits for R1
        //                    P1 holds R1, waits for R0
        detector.acquire(0, 0);  // P0 holds R0
        detector.acquire(1, 1);  // P1 holds R1
        detector.wait_for(0, 1); // P0 waits for R1
        detector.wait_for(1, 0); // P1 waits for R0

        let deadlock = detector.detect_deadlock();
        assert!(deadlock.is_some());

        let cycle = deadlock.unwrap();
        assert!(cycle.contains(&0) && cycle.contains(&1));
    }

    #[test]
    fn test_no_deadlock() {
        let mut detector = DeadlockDetector::new();

        // Pas de deadlock: P0 holds R0, P1 waits for R0
        detector.acquire(0, 0);
        detector.wait_for(1, 0);

        let deadlock = detector.detect_deadlock();
        assert!(deadlock.is_none());
    }

    #[test]
    fn test_victim_selection() {
        let mut detector = DeadlockDetector::new();

        // Creer un deadlock complexe
        detector.acquire(0, 0);
        detector.acquire(0, 1);  // P0 holds 2 resources
        detector.acquire(1, 2);  // P1 holds 1 resource
        detector.wait_for(0, 2);
        detector.wait_for(1, 0);

        let deadlock = detector.detect_deadlock().unwrap();
        let victims = detector.suggest_victims(&deadlock);

        // P1 devrait etre victime (moins de ressources)
        assert!(victims.contains(&1));
    }
}
```

## Criteres d'evaluation
- [ ] Producer-Consumer avec bounded buffer
- [ ] Readers-Writers avec 3 variantes de preference
- [ ] Dining Philosophers sans deadlock (2+ solutions)
- [ ] Banker's Algorithm complet
- [ ] Detection de deadlock via cycles
- [ ] Suggestion de victimes pour recovery
- [ ] Benchmarks comparatifs
- [ ] Tests de non-regression

## Note qualite: 98/100
