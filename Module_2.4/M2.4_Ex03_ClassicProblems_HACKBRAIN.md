<thinking>
## Analyse du Concept
- Concept : Classic Synchronization Problems (Producer-Consumer, Readers-Writers, Dining Philosophers)
- Phase demandee : 2
- Adapte ? OUI - Problemes fondamentaux de synchronisation couvrant tous les patterns classiques

## Combo Base + Bonus
- Exercice de base : Implementation des 3 problemes classiques + Banker's Algorithm + Deadlock Detection
- Bonus : Implementation Chandy/Misra pour philosophes + Adaptive Priority RW Lock
- Palier bonus : ğŸ”¥ Avance
- Progression logique ? OUI - Base couvre les solutions standards, bonus ajoute des algorithmes avances

## Prerequis & Difficulte
- Prerequis reels : ex00 (Thread Fundamentals), ex01 (Mutex), ex02 (Semaphores/Condvar)
- Difficulte estimee : 7/10
- Coherent avec phase ? OUI

## Aspect Fun/Culture
- Contexte choisi : RESTAURANT KITCHEN - La Cuisine de Ratatouille
- MEME mnÃ©motechnique : "Anyone can cook" de Ratatouille
- Pourquoi c'est fun :
  - Producteur = Cuisiniers (Remy) qui preparent les plats
  - Consommateur = Serveurs (Alfredo) qui emportent les plats
  - Condition Variable = La cloche de service (DING!)
  - Buffer borne = Le passe-plats (nombre limite de places)
  - Lecteurs-Redacteurs = Consultation vs Modification de la recette
  - Philosophes = Les critiques gastronomiques a table (Ego)
  - Fourchettes = Ustensiles partages entre convives
  - Banker = Gusteau's inventory management
  - Deadlock = Tout le monde attend que quelqu'un libere un ustensile

## Scenarios d'Echec (5 mutants)
1. Mutant A (Boundary) : Buffer overflow - produce sans verifier si plein
2. Mutant B (Safety) : Spurious wakeup - pas de while autour de wait
3. Mutant C (Resource) : Writers starvation dans Readers-First
4. Mutant D (Logic) : Deadlock philosophes - tous prennent fourchette gauche
5. Mutant E (Return) : Banker unsafe - accorde sans verifier safe state

## Verdict
VALIDE - Analogie restaurant parfaite pour tous les problemes classiques
Score: 97/100
</thinking>

---

# Exercice 2.4.3 : la_brigade_de_cuisine

**Module :**
2.4.3 â€” Classic Synchronization Problems

**Concept :**
c, f, g, a-i â€” Producer-Consumer, Readers-Writers, Dining Philosophers, Banker's Algorithm, Deadlock Detection (45 concepts)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
3 â€” Synthese (2.4.13 a 2.4.19)

**Langage :**
Rust (Edition 2024)

**Prerequis :**
- ex00 (Thread Fundamentals)
- ex01 (Mutex & Race Conditions)
- ex02 (Semaphores & Condition Variables)

**Domaines :**
Process, Mem, Struct

**Duree estimee :**
480 min (8h)

**XP Base :**
600

**Complexite :**
T3 O(n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
ex03/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ producer_consumer.rs
â”‚   â”œâ”€â”€ readers_writers.rs
â”‚   â”œâ”€â”€ dining_philosophers.rs
â”‚   â”œâ”€â”€ bankers.rs
â”‚   â””â”€â”€ deadlock_detector.rs
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration_tests.rs
â””â”€â”€ Cargo.toml
```

**Fonctions autorisees :**
- std::sync::{Arc, Mutex, RwLock, Condvar}
- std::collections::{HashMap, HashSet, VecDeque}
- std::thread
- std::time::{Duration, Instant}

**Fonctions interdites :**
- parking_lot (pour cet exercice, on utilise std::sync)
- crossbeam channels (on implementera notre propre buffer)
- unsafe blocks (sauf pour bonus avance)

### 1.2 Consigne

**ğŸ³ LA BRIGADE DE CUISINE : "Anyone Can Cook!"**

Bienvenue dans la cuisine de **Gusteau's**, le restaurant du film **Ratatouille**! Tu vas implementer les systemes de coordination qui font tourner une vraie brigade de cuisine.

Dans une cuisine professionnelle :
- Les **CUISINIERS** (Remy) preparent les plats et les posent sur le **passe-plats**
- Les **SERVEURS** (Alfredo) recuperent les plats pour les apporter en salle
- La **CLOCHE** (DING!) signale qu'un plat est pret ou qu'une place s'est liberee
- Les **CRITIQUES** (Ego) consultent ou modifient les recettes
- Les **CONVIVES** partagent les couverts a table

**C'est exactement les problemes classiques de synchronisation :**

| Cuisine | Synchronisation |
|---------|-----------------|
| Cuisiniers â†’ Passe-plats â†’ Serveurs | Producer-Consumer |
| Consultation vs Modification recette | Readers-Writers |
| Critiques partageant les couverts | Dining Philosophers |
| Gestion des stocks Gusteau's | Banker's Algorithm |
| Blocage en cuisine | Deadlock Detection |

**Ta mission :**

Implementer une suite complete de primitives de synchronisation inspirees de la cuisine de Ratatouille.

**Entree :**
- `PlateBuffer<T>` : Le passe-plats borne (Producer-Consumer)
- `RecipeBook<T>` : Le livre de recettes (Readers-Writers)
- `DiningTable` : La table des critiques (Dining Philosophers)
- `InventoryBanker` : Le gestionnaire de stocks (Banker's Algorithm)
- `KitchenInspector` : Le detecteur de blocages (Deadlock Detection)

**Sortie :**
- Systemes fonctionnels sans deadlock ni starvation
- Statistiques de performance (throughput, latence, fairness)

**Contraintes :**
- Buffer borne doit bloquer si plein/vide
- Readers-Writers doit supporter 3 politiques (ReadersFirst, WritersFirst, Fair)
- Philosophes ne doivent JAMAIS deadlock
- Banker doit TOUJOURS maintenir un etat safe
- Detector doit trouver les cycles dans le graphe d'allocation

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `plate_buffer.serve_dish(Ratatouille)` | bloque si 5 plats | Buffer plein, attend place |
| `plate_buffer.pickup_dish()` | `Some(Ratatouille)` | Serveur recupere le plat |
| `recipe_book.read(\|r\| r.clone())` | `Recipe` | Lecture partagee OK |
| `recipe_book.write(\|r\| r.add_spice())` | `()` | Ecriture exclusive |
| `table.think(ego_id)` | `()` | Critique reflechit |
| `table.eat(ego_id)` | `()` | Critique mange (prend 2 fourchettes) |
| `banker.request(chef, ingredients)` | `true/false` | Accorde si reste safe |
| `inspector.detect_deadlock()` | `Some(cycle)` | Trouve le blocage |

### 1.2.2 Consigne Academique

Implementer les problemes classiques de synchronisation :

1. **Producer-Consumer** avec buffer borne et condition variables
2. **Readers-Writers** avec trois politiques de priorite
3. **Dining Philosophers** avec au moins deux solutions (ordering, waiter)
4. **Banker's Algorithm** pour evitement de deadlock
5. **Deadlock Detection** par detection de cycles dans le graphe d'allocation

### 1.3 Prototypes

```rust
// src/lib.rs
pub mod producer_consumer;
pub mod readers_writers;
pub mod dining_philosophers;
pub mod bankers;
pub mod deadlock_detector;

pub use producer_consumer::*;
pub use readers_writers::*;
pub use dining_philosophers::*;
pub use bankers::*;
pub use deadlock_detector::*;
```

```rust
// src/producer_consumer.rs
use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;
use std::time::Duration;

/// Le Passe-Plats de Gusteau's - Buffer borne thread-safe
/// Remy pose les plats, Alfredo les recupere
pub struct PlateBuffer<T> {
    buffer: Mutex<VecDeque<T>>,
    capacity: usize,
    not_empty: Condvar,    // DING! Un plat est pret!
    not_full: Condvar,     // DING! Une place s'est liberee!
    stats: Mutex<BufferStats>,
}

#[derive(Default, Clone)]
pub struct BufferStats {
    pub dishes_served: u64,      // Plats poses par Remy
    pub dishes_picked: u64,      // Plats recuperes par Alfredo
    pub waits_full: u64,         // Fois ou Remy a attendu (buffer plein)
    pub waits_empty: u64,        // Fois ou Alfredo a attendu (buffer vide)
}

impl<T> PlateBuffer<T> {
    /// Creer un passe-plats avec N places
    pub fn new(capacity: usize) -> Self {
        todo!("Initialiser le buffer borne")
    }

    /// Remy pose un plat (bloque si plein)
    pub fn serve_dish(&self, dish: T) {
        todo!("Attendre si plein, poser, signaler not_empty")
    }

    /// Remy pose un plat avec timeout
    pub fn serve_dish_timeout(&self, dish: T, timeout: Duration) -> Result<(), T> {
        todo!("Retourne Err(dish) si timeout")
    }

    /// Alfredo recupere un plat (bloque si vide)
    pub fn pickup_dish(&self) -> T {
        todo!("Attendre si vide, recuperer, signaler not_full")
    }

    /// Alfredo recupere un plat avec timeout
    pub fn pickup_dish_timeout(&self, timeout: Duration) -> Option<T> {
        todo!("Retourne None si timeout")
    }

    /// Nombre de plats actuellement sur le passe
    pub fn dishes_waiting(&self) -> usize {
        todo!()
    }

    /// Statistiques du service
    pub fn stats(&self) -> BufferStats {
        todo!()
    }
}
```

```rust
// src/readers_writers.rs
use std::sync::{Arc, Mutex, Condvar, RwLock};

/// Politique de priorite pour le livre de recettes
#[derive(Clone, Copy, Debug)]
pub enum RecipePolicy {
    ChefsFirst,      // Les cuisiniers (readers) ont priorite
    CriticsFirst,    // Les critiques (writers) ont priorite
    FairService,     // Ordre d'arrivee (fair)
}

/// Le Livre de Recettes de Gusteau - Readers-Writers Lock
/// Plusieurs cuisiniers peuvent lire, mais un seul critique peut modifier
pub struct RecipeBook<T> {
    recipe: RwLock<T>,
    policy: RecipePolicy,
    // Pour ChefsFirst/CriticsFirst
    readers_count: Mutex<i32>,
    writers_waiting: Mutex<i32>,
    resource: Mutex<()>,
    can_read: Condvar,
    can_write: Condvar,
    // Stats
    stats: Mutex<RecipeStats>,
}

#[derive(Default, Clone)]
pub struct RecipeStats {
    pub consultations: u64,   // Lectures
    pub modifications: u64,   // Ecritures
    pub readers_blocked: u64, // Fois ou lecteurs ont attendu
    pub writers_blocked: u64, // Fois ou ecrivains ont attendu
}

impl<T> RecipeBook<T> {
    /// Creer un livre de recettes avec une politique
    pub fn new(recipe: T, policy: RecipePolicy) -> Self {
        todo!("Initialiser selon la politique")
    }

    /// Consulter la recette (acces partage)
    pub fn consult<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&T) -> R,
    {
        todo!("Implementer selon la politique")
    }

    /// Modifier la recette (acces exclusif)
    pub fn modify<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&mut T) -> R,
    {
        todo!("Implementer selon la politique")
    }

    /// Statistiques d'acces
    pub fn stats(&self) -> RecipeStats {
        todo!()
    }
}
```

```rust
// src/dining_philosophers.rs
use std::sync::{Arc, Mutex, Condvar};
use std::time::Duration;

/// Etat d'un critique gastronomique
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CriticState {
    Thinking,   // Reflechit a son article
    Hungry,     // Veut manger
    Eating,     // Mange (a les 2 fourchettes)
}

/// Trait pour les differentes solutions
pub trait DiningTable: Send + Sync {
    fn new(num_critics: usize) -> Self where Self: Sized;
    fn think(&self, critic_id: usize);
    fn eat(&self, critic_id: usize);
    fn get_state(&self, critic_id: usize) -> CriticState;
    fn stats(&self) -> Vec<CriticStats>;
}

#[derive(Default, Clone)]
pub struct CriticStats {
    pub meals_eaten: u64,
    pub time_thinking: Duration,
    pub time_waiting: Duration,
    pub time_eating: Duration,
}

/// Solution 1: Resource Ordering (La Regle d'Ego)
/// "Toujours prendre la fourchette de numero inferieur d'abord"
pub struct OrderedDining {
    forks: Vec<Mutex<()>>,
    states: Vec<Mutex<CriticState>>,
    stats: Vec<Mutex<CriticStats>>,
    num_critics: usize,
}

impl DiningTable for OrderedDining {
    fn new(num_critics: usize) -> Self {
        todo!("Creer les fourchettes")
    }

    fn think(&self, critic_id: usize) {
        todo!("Passer en mode Thinking")
    }

    fn eat(&self, critic_id: usize) {
        todo!("Prendre fourchettes dans l'ordre croissant, manger, liberer")
    }

    fn get_state(&self, critic_id: usize) -> CriticState {
        todo!()
    }

    fn stats(&self) -> Vec<CriticStats> {
        todo!()
    }
}

/// Solution 2: Central Waiter (Le Maitre d'Hotel)
/// "Demander la permission au maitre d'hotel avant de manger"
pub struct WaiterDining {
    forks: Vec<Mutex<()>>,
    waiter: Mutex<()>,        // Le maitre d'hotel
    states: Vec<Mutex<CriticState>>,
    stats: Vec<Mutex<CriticStats>>,
    num_critics: usize,
}

impl DiningTable for WaiterDining {
    fn new(num_critics: usize) -> Self {
        todo!()
    }

    fn think(&self, critic_id: usize) {
        todo!()
    }

    fn eat(&self, critic_id: usize) {
        todo!("Demander au maitre d'hotel avant de prendre les fourchettes")
    }

    fn get_state(&self, critic_id: usize) -> CriticState {
        todo!()
    }

    fn stats(&self) -> Vec<CriticStats> {
        todo!()
    }
}
```

```rust
// src/bankers.rs
use std::collections::HashMap;

/// L'Inventaire de Gusteau - Banker's Algorithm
/// Gere les stocks pour eviter les penuries (deadlocks)
pub struct InventoryBanker {
    num_chefs: usize,           // Nombre de cuisiniers
    num_ingredients: usize,     // Types d'ingredients
    available: Vec<i32>,        // Stock disponible
    maximum: Vec<Vec<i32>>,     // Max que chaque chef peut demander
    allocation: Vec<Vec<i32>>,  // Ce que chaque chef detient
    need: Vec<Vec<i32>>,        // Ce dont chaque chef a encore besoin
}

impl InventoryBanker {
    /// Creer un gestionnaire de stocks
    pub fn new(num_chefs: usize, num_ingredients: usize, available: Vec<i32>) -> Self {
        todo!("Initialiser avec 0 allocations")
    }

    /// Chef declare ses besoins maximum
    pub fn declare_menu(&mut self, chef: usize, max_ingredients: Vec<i32>) {
        todo!("Mettre a jour maximum et need")
    }

    /// Verifier si l'etat courant est safe (pas de famine possible)
    pub fn is_safe(&self) -> bool {
        todo!("Algorithme de safety - tous les chefs peuvent finir")
    }

    /// Trouver un ordre de service safe
    pub fn find_safe_sequence(&self) -> Option<Vec<usize>> {
        todo!("Retourner l'ordre dans lequel les chefs peuvent etre servis")
    }

    /// Chef demande des ingredients
    pub fn request_ingredients(&mut self, chef: usize, request: Vec<i32>) -> bool {
        todo!("Verifier si l'accord maintient l'etat safe")
    }

    /// Chef libere des ingredients
    pub fn release_ingredients(&mut self, chef: usize, release: Vec<i32>) {
        todo!("Mettre a jour allocation et available")
    }

    /// Besoins restants d'un chef
    pub fn remaining_needs(&self, chef: usize) -> &Vec<i32> {
        &self.need[chef]
    }
}
```

```rust
// src/deadlock_detector.rs
use std::collections::{HashMap, HashSet};

/// L'Inspecteur de Cuisine - Deadlock Detector
/// Detecte les blocages dans l'allocation des ressources
pub struct KitchenInspector {
    // Chef -> Ustensiles detenus
    holds: HashMap<usize, HashSet<usize>>,
    // Chef -> Ustensiles demandes
    waits_for: HashMap<usize, HashSet<usize>>,
    // Ustensile -> Chef qui le detient
    held_by: HashMap<usize, usize>,
}

impl KitchenInspector {
    pub fn new() -> Self {
        KitchenInspector {
            holds: HashMap::new(),
            waits_for: HashMap::new(),
            held_by: HashMap::new(),
        }
    }

    /// Chef prend un ustensile
    pub fn acquire(&mut self, chef: usize, utensil: usize) {
        todo!("Mettre a jour holds et held_by")
    }

    /// Chef libere un ustensile
    pub fn release(&mut self, chef: usize, utensil: usize) {
        todo!("Mettre a jour holds et held_by")
    }

    /// Chef attend un ustensile
    pub fn wait_for(&mut self, chef: usize, utensil: usize) {
        todo!("Ajouter a waits_for")
    }

    /// Detecter un deadlock (cycle dans le graphe)
    pub fn detect_deadlock(&self) -> Option<Vec<usize>> {
        todo!("DFS pour trouver un cycle")
    }

    /// Suggerer des victimes pour debloquer
    pub fn suggest_victims(&self, deadlocked: &[usize]) -> Vec<usize> {
        todo!("Choisir les chefs a interrompre selon un critere")
    }
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 La metaphore parfaite

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RATATOUILLE                          â”‚   SYNCHRONISATION                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Remy prepare les plats               â”‚   Producer thread                   â”‚
â”‚  Alfredo emporte les plats            â”‚   Consumer thread                   â”‚
â”‚  Passe-plats (5 places)               â”‚   Bounded buffer                    â”‚
â”‚  DING! Plat pret!                     â”‚   Condvar signal (not_empty)        â”‚
â”‚  DING! Place libre!                   â”‚   Condvar signal (not_full)         â”‚
â”‚  Consultation recette                 â”‚   Read lock                         â”‚
â”‚  Modification recette                 â”‚   Write lock                        â”‚
â”‚  Critiques a table                    â”‚   Dining Philosophers               â”‚
â”‚  Fourchettes partagees                â”‚   Shared resources                  â”‚
â”‚  Stocks de la cuisine                 â”‚   Resource allocation               â”‚
â”‚  "Anyone can cook!"                   â”‚   Thread-safe by design             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Pourquoi ces problemes sont "classiques"

Ces problemes ont ete formules dans les annees 1960-70 par **Dijkstra** (Philosophes), **Courtois** (Lecteurs-Ecrivains) et d'autres pionniers. Ils capturent les patterns fondamentaux de toute concurrence :

| Probleme | Pattern | Applications Reelles |
|----------|---------|---------------------|
| Producer-Consumer | Pipeline | Message queues, IO buffers, Web servers |
| Readers-Writers | Acces partage/exclusif | Databases, Caches, Config files |
| Dining Philosophers | Ressources circulaires | Network protocols, Resource pools |
| Banker's Algorithm | Evitement deadlock | OS scheduling, Transaction systems |

### 2.3 La Cloche de Service = Condition Variable

```c
// Sans condition variable (BUSY WAITING - HORRIBLE!)
while (buffer_is_full()) {
    // Boucle infinie qui gaspille le CPU!
    // C'est comme si Remy regardait le passe sans arret
}

// Avec condition variable (ELEGANT!)
while (buffer_is_full()) {
    wait(&not_full);  // Remy dort jusqu'au DING!
}
// Reveil = place liberee
```

### 2.5 DANS LA VRAIE VIE

| Metier | Usage |
|--------|-------|
| **Backend Developer** | Message queues (RabbitMQ, Kafka) = Producer-Consumer |
| **Database Engineer** | Row-level locking = Readers-Writers |
| **Game Developer** | Resource pools = Dining Philosophers pattern |
| **OS Developer** | Process scheduler = Banker's Algorithm |
| **SRE/DevOps** | Deadlock detection dans les systemes distribues |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
src/  tests/  Cargo.toml

$ cargo build
   Compiling la_brigade_de_cuisine v0.1.0
    Finished dev [unoptimized + debuginfo] target(s)

$ cargo test
running 15 tests
test test_plate_buffer_basic ... ok
test test_plate_buffer_concurrent ... ok
test test_recipe_book_readers_first ... ok
test test_recipe_book_writers_first ... ok
test test_recipe_book_fair ... ok
test test_dining_ordered_no_deadlock ... ok
test test_dining_waiter_no_deadlock ... ok
test test_banker_safety ... ok
test test_banker_unsafe_reject ... ok
test test_deadlock_detection ... ok
test test_no_deadlock ... ok
test test_victim_selection ... ok
test bench_producer_consumer ... ok
test bench_readers_writers ... ok
test bench_philosophers ... ok

test result: ok. 15 passed; 0 failed

$ cargo run --example kitchen_demo
=== GUSTEAU'S KITCHEN: LA BRIGADE ===

--- PASSE-PLATS DEMO ---
Remy pose: Ratatouille
Remy pose: Bouillabaisse
Remy pose: Creme Brulee
[Buffer: 3/5 plats]
Alfredo recupere: Ratatouille
Alfredo recupere: Bouillabaisse
[Buffer: 1/5 plats]

--- LIVRE DE RECETTES (ChefsFirst) ---
5 cuisiniers consultent simultanement... OK
1 critique modifie pendant consultation... bloque jusqu'a fin lectures
Modification terminee!

--- TABLE DES CRITIQUES (OrderedDining) ---
5 critiques, 100 repas chacun
Tous ont mange sans deadlock!
Statistiques d'equite: Gini = 0.02 (tres fair)

--- INVENTAIRE BANKER ---
Etat initial: [10 oeufs, 5 beurre, 7 farine]
Chef 0 demande [3, 2, 1]... ACCORDE (reste safe)
Chef 1 demande [5, 3, 3]... REFUSE (deviendrait unsafe)
Sequence safe trouvee: [2, 0, 3, 1, 4]

--- INSPECTEUR DEADLOCK ---
Simulation de deadlock...
Chef 0 prend couteau, veut fourchette
Chef 1 prend fourchette, veut couteau
DEADLOCK DETECTE! Cycle: [0, 1]
Victime suggeree: Chef 1 (moins de ressources)

=== SERVICE TERMINE ===
"In many ways, the work of a critic is easy..."
```

### 3.1 ğŸ”¥ BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) pour Chandy-Misra messaging

**Domaines Bonus :**
`Struct, Algo`

#### 3.1.1 Consigne Bonus

**ğŸ³ CHANDY-MISRA : LA FOURCHETTE PROPRE/SALE**

L'algorithme de Chandy-Misra est une solution distribuee elegante aux philosophes dineurs. Chaque fourchette peut etre "propre" ou "sale" :

- Une fourchette **sale** doit etre nettoyee et passee si demandee
- Une fourchette **propre** peut etre gardee
- Apres avoir mange, les fourchettes deviennent **sales**

```rust
pub struct ChandyMisraDining {
    forks: Vec<Mutex<ForkState>>,
    request_channels: Vec<(Mutex<bool>, Condvar)>,
    states: Vec<Mutex<CriticState>>,
    num_critics: usize,
}

#[derive(Clone, Copy)]
struct ForkState {
    owner: usize,
    dirty: bool,
}

impl DiningTable for ChandyMisraDining {
    // Implementation de l'algorithme Chandy-Misra
}
```

**Contraintes :**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Initialisation asymetrique requise     â”‚
â”‚  Pas de deadlock prouve mathematiquementâ”‚
â”‚  Fairness garantie                       â”‚
â”‚  Message passing entre philosophes      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette (Tests)

| Test | Description | Points | Trap |
|------|-------------|--------|------|
| `test_buffer_init` | Init passe-plats | 5 | - |
| `test_buffer_serve_pickup` | Serve/pickup basique | 10 | - |
| `test_buffer_full_blocks` | Bloque si plein | 10 | Spurious wakeup |
| `test_buffer_empty_blocks` | Bloque si vide | 10 | Spurious wakeup |
| `test_buffer_timeout` | Timeout fonctionne | 5 | - |
| `test_recipe_readers_concurrent` | Lectures simultanees | 10 | - |
| `test_recipe_writer_exclusive` | Ecriture exclusive | 10 | - |
| `test_recipe_policy_chefs` | ChefsFirst | 5 | Starvation |
| `test_recipe_policy_critics` | CriticsFirst | 5 | Starvation |
| `test_dining_no_deadlock` | 1000 repas sans deadlock | 15 | Timeout = deadlock |
| `test_dining_fairness` | Distribution equitable | 5 | - |
| `test_banker_safe` | Etat safe | 10 | - |
| `test_banker_unsafe_reject` | Refuse unsafe | 10 | - |
| `test_banker_sequence` | Trouve sequence | 5 | - |
| `test_deadlock_cycle` | Detecte cycle | 10 | - |
| `test_deadlock_no_false_positive` | Pas de faux positif | 5 | - |
| `test_victim_selection` | Choisit bonne victime | 5 | - |
| **Total** | | **135** | |

### 4.2 main.rs de test

```rust
use la_brigade_de_cuisine::*;
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("=== GUSTEAU'S KITCHEN: TESTS ===\n");

    // Test Producer-Consumer
    println!("--- PASSE-PLATS ---");
    let buffer: Arc<PlateBuffer<String>> = Arc::new(PlateBuffer::new(5));

    let producer = {
        let buf = Arc::clone(&buffer);
        thread::spawn(move || {
            for dish in ["Ratatouille", "Bouillabaisse", "Creme Brulee"] {
                println!("Remy pose: {}", dish);
                buf.serve_dish(dish.to_string());
            }
        })
    };

    let consumer = {
        let buf = Arc::clone(&buffer);
        thread::spawn(move || {
            for _ in 0..3 {
                let dish = buf.pickup_dish();
                println!("Alfredo recupere: {}", dish);
            }
        })
    };

    producer.join().unwrap();
    consumer.join().unwrap();
    let stats = buffer.stats();
    println!("Plats servis: {}, recuperes: {}", stats.dishes_served, stats.dishes_picked);
    assert_eq!(stats.dishes_served, 3);
    assert_eq!(stats.dishes_picked, 3);

    // Test Readers-Writers
    println!("\n--- LIVRE DE RECETTES ---");
    let book = Arc::new(RecipeBook::new(
        vec!["Ratatouille: aubergine, courgette, tomate".to_string()],
        RecipePolicy::ChefsFirst
    ));

    let readers: Vec<_> = (0..5).map(|i| {
        let b = Arc::clone(&book);
        thread::spawn(move || {
            for _ in 0..100 {
                b.consult(|recipes| {
                    let _ = recipes.len();
                });
            }
            println!("Chef {} a consulte 100 fois", i);
        })
    }).collect();

    let writer = {
        let b = Arc::clone(&book);
        thread::spawn(move || {
            for _ in 0..10 {
                b.modify(|recipes| {
                    recipes.push("Nouvelle recette".to_string());
                });
            }
            println!("Critique a modifie 10 fois");
        })
    };

    for r in readers { r.join().unwrap(); }
    writer.join().unwrap();

    // Test Dining Philosophers
    println!("\n--- TABLE DES CRITIQUES ---");
    let table = Arc::new(OrderedDining::new(5));
    let num_meals = 100;

    let handles: Vec<_> = (0..5).map(|id| {
        let t = Arc::clone(&table);
        thread::spawn(move || {
            for _ in 0..num_meals {
                t.think(id);
                thread::sleep(Duration::from_micros(10));
                t.eat(id);
                thread::sleep(Duration::from_micros(10));
            }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }

    let stats = table.stats();
    for (i, s) in stats.iter().enumerate() {
        println!("Critique {} a mange {} fois", i, s.meals_eaten);
        assert_eq!(s.meals_eaten, num_meals as u64);
    }

    // Test Banker
    println!("\n--- INVENTAIRE BANKER ---");
    let mut banker = InventoryBanker::new(5, 3, vec![10, 5, 7]);

    banker.declare_menu(0, vec![7, 5, 3]);
    banker.declare_menu(1, vec![3, 2, 2]);
    banker.declare_menu(2, vec![9, 0, 2]);
    banker.declare_menu(3, vec![2, 2, 2]);
    banker.declare_menu(4, vec![4, 3, 3]);

    assert!(banker.request_ingredients(0, vec![0, 1, 0]));
    assert!(banker.request_ingredients(1, vec![2, 0, 0]));
    assert!(banker.request_ingredients(2, vec![3, 0, 2]));

    assert!(banker.is_safe());
    let seq = banker.find_safe_sequence();
    println!("Sequence safe: {:?}", seq);
    assert!(seq.is_some());

    // Test Deadlock Detection
    println!("\n--- INSPECTEUR DEADLOCK ---");
    let mut inspector = KitchenInspector::new();

    inspector.acquire(0, 0);
    inspector.acquire(1, 1);
    inspector.wait_for(0, 1);
    inspector.wait_for(1, 0);

    let deadlock = inspector.detect_deadlock();
    println!("Deadlock detecte: {:?}", deadlock);
    assert!(deadlock.is_some());

    let victims = inspector.suggest_victims(&deadlock.unwrap());
    println!("Victimes suggerees: {:?}", victims);

    println!("\n=== TOUS LES TESTS PASSENT! ===");
    println!("\"Anyone can cook!\" - Gusteau");
}
```

### 4.3 Solution de reference

```rust
// src/producer_consumer.rs - Solution de reference
use std::sync::{Mutex, Condvar};
use std::collections::VecDeque;
use std::time::Duration;

#[derive(Default, Clone)]
pub struct BufferStats {
    pub dishes_served: u64,
    pub dishes_picked: u64,
    pub waits_full: u64,
    pub waits_empty: u64,
}

pub struct PlateBuffer<T> {
    buffer: Mutex<VecDeque<T>>,
    capacity: usize,
    not_empty: Condvar,
    not_full: Condvar,
    stats: Mutex<BufferStats>,
}

impl<T> PlateBuffer<T> {
    pub fn new(capacity: usize) -> Self {
        PlateBuffer {
            buffer: Mutex::new(VecDeque::with_capacity(capacity)),
            capacity,
            not_empty: Condvar::new(),
            not_full: Condvar::new(),
            stats: Mutex::new(BufferStats::default()),
        }
    }

    pub fn serve_dish(&self, dish: T) {
        let mut buffer = self.buffer.lock().unwrap();

        // Attendre tant que le buffer est plein (WHILE pour spurious wakeup!)
        while buffer.len() >= self.capacity {
            self.stats.lock().unwrap().waits_full += 1;
            buffer = self.not_full.wait(buffer).unwrap();
        }

        buffer.push_back(dish);
        self.stats.lock().unwrap().dishes_served += 1;

        // DING! Un plat est pret!
        self.not_empty.notify_one();
    }

    pub fn serve_dish_timeout(&self, dish: T, timeout: Duration) -> Result<(), T> {
        let mut buffer = self.buffer.lock().unwrap();

        while buffer.len() >= self.capacity {
            let result = self.not_full.wait_timeout(buffer, timeout).unwrap();
            buffer = result.0;
            if result.1.timed_out() && buffer.len() >= self.capacity {
                return Err(dish);
            }
        }

        buffer.push_back(dish);
        self.stats.lock().unwrap().dishes_served += 1;
        self.not_empty.notify_one();
        Ok(())
    }

    pub fn pickup_dish(&self) -> T {
        let mut buffer = self.buffer.lock().unwrap();

        // Attendre tant que le buffer est vide (WHILE!)
        while buffer.is_empty() {
            self.stats.lock().unwrap().waits_empty += 1;
            buffer = self.not_empty.wait(buffer).unwrap();
        }

        let dish = buffer.pop_front().unwrap();
        self.stats.lock().unwrap().dishes_picked += 1;

        // DING! Une place s'est liberee!
        self.not_full.notify_one();
        dish
    }

    pub fn pickup_dish_timeout(&self, timeout: Duration) -> Option<T> {
        let mut buffer = self.buffer.lock().unwrap();

        while buffer.is_empty() {
            let result = self.not_empty.wait_timeout(buffer, timeout).unwrap();
            buffer = result.0;
            if result.1.timed_out() && buffer.is_empty() {
                return None;
            }
        }

        let dish = buffer.pop_front().unwrap();
        self.stats.lock().unwrap().dishes_picked += 1;
        self.not_full.notify_one();
        Some(dish)
    }

    pub fn dishes_waiting(&self) -> usize {
        self.buffer.lock().unwrap().len()
    }

    pub fn stats(&self) -> BufferStats {
        self.stats.lock().unwrap().clone()
    }
}
```

```rust
// src/dining_philosophers.rs - Solution OrderedDining
use std::sync::Mutex;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CriticState {
    Thinking,
    Hungry,
    Eating,
}

#[derive(Default, Clone)]
pub struct CriticStats {
    pub meals_eaten: u64,
    pub time_thinking: std::time::Duration,
    pub time_waiting: std::time::Duration,
    pub time_eating: std::time::Duration,
}

pub trait DiningTable: Send + Sync {
    fn new(num_critics: usize) -> Self where Self: Sized;
    fn think(&self, critic_id: usize);
    fn eat(&self, critic_id: usize);
    fn get_state(&self, critic_id: usize) -> CriticState;
    fn stats(&self) -> Vec<CriticStats>;
}

pub struct OrderedDining {
    forks: Vec<Mutex<()>>,
    states: Vec<Mutex<CriticState>>,
    stats: Vec<Mutex<CriticStats>>,
    num_critics: usize,
}

impl DiningTable for OrderedDining {
    fn new(num_critics: usize) -> Self {
        OrderedDining {
            forks: (0..num_critics).map(|_| Mutex::new(())).collect(),
            states: (0..num_critics).map(|_| Mutex::new(CriticState::Thinking)).collect(),
            stats: (0..num_critics).map(|_| Mutex::new(CriticStats::default())).collect(),
            num_critics,
        }
    }

    fn think(&self, critic_id: usize) {
        *self.states[critic_id].lock().unwrap() = CriticState::Thinking;
    }

    fn eat(&self, critic_id: usize) {
        *self.states[critic_id].lock().unwrap() = CriticState::Hungry;

        let left = critic_id;
        let right = (critic_id + 1) % self.num_critics;

        // LA REGLE D'EGO: Toujours prendre la fourchette de numero INFERIEUR d'abord!
        // Cela brise l'attente circulaire et previent le deadlock
        let (first, second) = if left < right {
            (left, right)
        } else {
            (right, left)
        };

        let _fork1 = self.forks[first].lock().unwrap();
        let _fork2 = self.forks[second].lock().unwrap();

        *self.states[critic_id].lock().unwrap() = CriticState::Eating;
        self.stats[critic_id].lock().unwrap().meals_eaten += 1;

        // Les fourchettes sont liberees automatiquement (RAII)
    }

    fn get_state(&self, critic_id: usize) -> CriticState {
        *self.states[critic_id].lock().unwrap()
    }

    fn stats(&self) -> Vec<CriticStats> {
        self.stats.iter()
            .map(|s| s.lock().unwrap().clone())
            .collect()
    }
}
```

```rust
// src/bankers.rs - Solution de reference
pub struct InventoryBanker {
    num_chefs: usize,
    num_ingredients: usize,
    available: Vec<i32>,
    maximum: Vec<Vec<i32>>,
    allocation: Vec<Vec<i32>>,
    need: Vec<Vec<i32>>,
}

impl InventoryBanker {
    pub fn new(num_chefs: usize, num_ingredients: usize, available: Vec<i32>) -> Self {
        InventoryBanker {
            num_chefs,
            num_ingredients,
            available,
            maximum: vec![vec![0; num_ingredients]; num_chefs],
            allocation: vec![vec![0; num_ingredients]; num_chefs],
            need: vec![vec![0; num_ingredients]; num_chefs],
        }
    }

    pub fn declare_menu(&mut self, chef: usize, max_ingredients: Vec<i32>) {
        self.maximum[chef] = max_ingredients.clone();
        for i in 0..self.num_ingredients {
            self.need[chef][i] = max_ingredients[i] - self.allocation[chef][i];
        }
    }

    pub fn is_safe(&self) -> bool {
        self.find_safe_sequence().is_some()
    }

    pub fn find_safe_sequence(&self) -> Option<Vec<usize>> {
        let mut work = self.available.clone();
        let mut finish = vec![false; self.num_chefs];
        let mut sequence = Vec::new();

        loop {
            // Trouver un chef qui peut finir avec les ressources disponibles
            let mut found = false;
            for i in 0..self.num_chefs {
                if !finish[i] {
                    // Verifier si need[i] <= work
                    let can_finish = self.need[i].iter()
                        .zip(work.iter())
                        .all(|(need, avail)| need <= avail);

                    if can_finish {
                        // Ce chef peut finir, il libere ses ressources
                        for j in 0..self.num_ingredients {
                            work[j] += self.allocation[i][j];
                        }
                        finish[i] = true;
                        sequence.push(i);
                        found = true;
                    }
                }
            }

            if !found {
                break;
            }
        }

        if finish.iter().all(|&f| f) {
            Some(sequence)
        } else {
            None
        }
    }

    pub fn request_ingredients(&mut self, chef: usize, request: Vec<i32>) -> bool {
        // Verifier request <= need
        for i in 0..self.num_ingredients {
            if request[i] > self.need[chef][i] {
                return false; // Demande plus que declare!
            }
        }

        // Verifier request <= available
        for i in 0..self.num_ingredients {
            if request[i] > self.available[i] {
                return false; // Pas assez de stock
            }
        }

        // Simuler l'allocation
        for i in 0..self.num_ingredients {
            self.available[i] -= request[i];
            self.allocation[chef][i] += request[i];
            self.need[chef][i] -= request[i];
        }

        // Verifier si l'etat reste safe
        if self.is_safe() {
            true
        } else {
            // Rollback - l'allocation rendrait le systeme unsafe
            for i in 0..self.num_ingredients {
                self.available[i] += request[i];
                self.allocation[chef][i] -= request[i];
                self.need[chef][i] += request[i];
            }
            false
        }
    }

    pub fn release_ingredients(&mut self, chef: usize, release: Vec<i32>) {
        for i in 0..self.num_ingredients {
            self.allocation[chef][i] -= release[i];
            self.available[i] += release[i];
        }
    }

    pub fn remaining_needs(&self, chef: usize) -> &Vec<i32> {
        &self.need[chef]
    }
}
```

```rust
// src/deadlock_detector.rs - Solution de reference
use std::collections::{HashMap, HashSet};

pub struct KitchenInspector {
    holds: HashMap<usize, HashSet<usize>>,
    waits_for: HashMap<usize, HashSet<usize>>,
    held_by: HashMap<usize, usize>,
}

impl KitchenInspector {
    pub fn new() -> Self {
        KitchenInspector {
            holds: HashMap::new(),
            waits_for: HashMap::new(),
            held_by: HashMap::new(),
        }
    }

    pub fn acquire(&mut self, chef: usize, utensil: usize) {
        self.holds.entry(chef).or_insert_with(HashSet::new).insert(utensil);
        self.held_by.insert(utensil, chef);
        // Retirer des waits_for si present
        if let Some(waiting) = self.waits_for.get_mut(&chef) {
            waiting.remove(&utensil);
        }
    }

    pub fn release(&mut self, chef: usize, utensil: usize) {
        if let Some(holding) = self.holds.get_mut(&chef) {
            holding.remove(&utensil);
        }
        self.held_by.remove(&utensil);
    }

    pub fn wait_for(&mut self, chef: usize, utensil: usize) {
        self.waits_for.entry(chef).or_insert_with(HashSet::new).insert(utensil);
    }

    pub fn detect_deadlock(&self) -> Option<Vec<usize>> {
        // Construire le graphe Wait-For entre chefs
        // Chef A -> Chef B si A attend une ressource que B detient
        let mut wait_for_graph: HashMap<usize, HashSet<usize>> = HashMap::new();

        for (&chef, utensils) in &self.waits_for {
            for &utensil in utensils {
                if let Some(&holder) = self.held_by.get(&utensil) {
                    if holder != chef {
                        wait_for_graph.entry(chef)
                            .or_insert_with(HashSet::new)
                            .insert(holder);
                    }
                }
            }
        }

        // DFS pour detecter un cycle
        let all_chefs: HashSet<_> = wait_for_graph.keys().cloned().collect();

        for &start in &all_chefs {
            let mut visited = HashSet::new();
            let mut path = Vec::new();

            if self.dfs_cycle(&wait_for_graph, start, &mut visited, &mut path) {
                return Some(path);
            }
        }

        None
    }

    fn dfs_cycle(
        &self,
        graph: &HashMap<usize, HashSet<usize>>,
        node: usize,
        visited: &mut HashSet<usize>,
        path: &mut Vec<usize>,
    ) -> bool {
        if path.contains(&node) {
            // Cycle trouve! Extraire le cycle
            let cycle_start = path.iter().position(|&n| n == node).unwrap();
            *path = path[cycle_start..].to_vec();
            path.push(node);
            return true;
        }

        if visited.contains(&node) {
            return false;
        }

        visited.insert(node);
        path.push(node);

        if let Some(neighbors) = graph.get(&node) {
            for &neighbor in neighbors {
                if self.dfs_cycle(graph, neighbor, visited, path) {
                    return true;
                }
            }
        }

        path.pop();
        false
    }

    pub fn suggest_victims(&self, deadlocked: &[usize]) -> Vec<usize> {
        // Choisir les chefs qui detiennent le moins de ressources
        let mut chef_resources: Vec<(usize, usize)> = deadlocked.iter()
            .map(|&chef| {
                let count = self.holds.get(&chef).map(|s| s.len()).unwrap_or(0);
                (chef, count)
            })
            .collect();

        chef_resources.sort_by_key(|&(_, count)| count);

        // Retourner le chef avec le moins de ressources
        vec![chef_resources[0].0]
    }
}

impl Default for KitchenInspector {
    fn default() -> Self {
        Self::new()
    }
}
```

### 4.9 spec.json

```json
{
  "name": "la_brigade_de_cuisine",
  "language": "rust",
  "type": "complet",
  "tier": 3,
  "tier_info": "Synthese (2.4.13-2.4.19)",
  "tags": ["concurrency", "synchronization", "producer-consumer", "readers-writers", "philosophers", "deadlock", "phase2"],
  "passing_score": 70,

  "function": {
    "name": "PlateBuffer::serve_dish",
    "prototype": "pub fn serve_dish(&self, dish: T)",
    "return_type": "()",
    "parameters": [
      {"name": "self", "type": "&PlateBuffer<T>"},
      {"name": "dish", "type": "T"}
    ]
  },

  "driver": {
    "reference": "impl<T> PlateBuffer<T> { pub fn serve_dish(&self, dish: T) { let mut buffer = self.buffer.lock().unwrap(); while buffer.len() >= self.capacity { buffer = self.not_full.wait(buffer).unwrap(); } buffer.push_back(dish); self.not_empty.notify_one(); } }",

    "edge_cases": [
      {
        "name": "buffer_empty",
        "args": ["empty_buffer", "dish"],
        "expected": "inserted",
        "is_trap": false
      },
      {
        "name": "buffer_full_blocks",
        "args": ["full_buffer", "dish"],
        "expected": "blocks_until_space",
        "is_trap": true,
        "trap_explanation": "Doit bloquer, pas retourner immediatement"
      },
      {
        "name": "spurious_wakeup",
        "args": ["buffer", "dish"],
        "expected": "while_not_if",
        "is_trap": true,
        "trap_explanation": "WHILE (pas IF) autour de wait pour gerer spurious wakeup"
      },
      {
        "name": "concurrent_producers",
        "args": ["buffer", "many_dishes"],
        "expected": "all_inserted_no_loss",
        "is_trap": true,
        "trap_explanation": "Pas de perte de donnees avec plusieurs producteurs"
      }
    ]
  },

  "norm": {
    "allowed_functions": ["std::sync::Mutex", "std::sync::Condvar", "std::sync::RwLock", "std::sync::Arc", "std::collections::VecDeque", "std::collections::HashMap", "std::collections::HashSet", "std::thread", "std::time::Duration"],
    "forbidden_functions": ["parking_lot", "crossbeam", "unsafe"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Buffer overflow - IF au lieu de WHILE */
pub fn serve_dish_mutant_a(&self, dish: T) {
    let mut buffer = self.buffer.lock().unwrap();

    // ERREUR: IF au lieu de WHILE!
    if buffer.len() >= self.capacity {
        buffer = self.not_full.wait(buffer).unwrap();
    }
    // PROBLEME: Spurious wakeup = on continue meme si toujours plein!

    buffer.push_back(dish);
    self.not_empty.notify_one();
}
// Pourquoi c'est faux: Les spurious wakeups peuvent reveiller sans que la condition soit vraie
// Ce qui etait pense: "Un seul wait suffit pour attendre"

/* Mutant B (Safety) : Pas de notify = deadlock potentiel */
pub fn serve_dish_mutant_b(&self, dish: T) {
    let mut buffer = self.buffer.lock().unwrap();

    while buffer.len() >= self.capacity {
        buffer = self.not_full.wait(buffer).unwrap();
    }

    buffer.push_back(dish);
    // MANQUE: self.not_empty.notify_one();
    // Les consommateurs ne seront jamais reveilles!
}
// Pourquoi c'est faux: Les consommateurs attendent eternellement
// Ce qui etait pense: "Ils verifieront tout seuls"

/* Mutant C (Resource) : Philosophes sans ordering = deadlock */
pub fn eat_mutant_c(&self, critic_id: usize) {
    let left = critic_id;
    let right = (critic_id + 1) % self.num_critics;

    // ERREUR: Toujours gauche puis droite!
    let _fork1 = self.forks[left].lock().unwrap();
    let _fork2 = self.forks[right].lock().unwrap();
    // DEADLOCK: Tous prennent gauche, attendent droite

    self.stats[critic_id].lock().unwrap().meals_eaten += 1;
}
// Pourquoi c'est faux: Circular wait = deadlock classique des philosophes
// Ce qui etait pense: "Gauche puis droite, c'est logique"

/* Mutant D (Logic) : Banker accorde sans verifier safe */
pub fn request_ingredients_mutant_d(&mut self, chef: usize, request: Vec<i32>) -> bool {
    // Verifier request <= available
    for i in 0..self.num_ingredients {
        if request[i] > self.available[i] {
            return false;
        }
    }

    // ERREUR: Accorde directement sans verifier is_safe()!
    for i in 0..self.num_ingredients {
        self.available[i] -= request[i];
        self.allocation[chef][i] += request[i];
        self.need[chef][i] -= request[i];
    }

    true  // Toujours OK si disponible - FAUX!
}
// Pourquoi c'est faux: Peut mener a un etat unsafe (deadlock potentiel)
// Ce qui etait pense: "Si c'est disponible, on peut le donner"

/* Mutant E (Return) : Detection cycles sans gerer les chemins */
pub fn detect_deadlock_mutant_e(&self) -> Option<Vec<usize>> {
    let mut visited = HashSet::new();

    for &chef in self.waits_for.keys() {
        if visited.contains(&chef) {
            continue;
        }

        // ERREUR: Pas de tracking du chemin, juste visited
        let mut current = chef;
        while let Some(utensils) = self.waits_for.get(&current) {
            for &utensil in utensils {
                if let Some(&holder) = self.held_by.get(&utensil) {
                    if visited.contains(&holder) {
                        // FAUX: visited ne veut pas dire cycle!
                        return Some(vec![chef, holder]);
                    }
                    visited.insert(holder);
                    current = holder;
                    break;
                }
            }
        }
    }
    None
}
// Pourquoi c'est faux: Confond "deja visite" avec "cycle"
// Ce qui etait pense: "Si on revient sur un noeud visite, c'est un cycle"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Ratatouille Analogy | Technical Reality |
|---------|---------------------|-------------------|
| **Producer-Consumer** | Remy â†’ Passe-plats â†’ Alfredo | Thread safety avec buffer borne |
| **Condition Variable** | DING! (cloche service) | Signal/Wait pattern |
| **Spurious Wakeup** | Faux DING! | Toujours WHILE, pas IF |
| **Readers-Writers** | Consulter vs Modifier recette | RwLock pattern |
| **Dining Philosophers** | Critiques & fourchettes | Ressources partagees circulaires |
| **Resource Ordering** | Regle d'Ego | Briser l'attente circulaire |
| **Banker's Algorithm** | Gestion stocks Gusteau | Evitement de deadlock |
| **Safe State** | Tous peuvent finir leur plat | Pas de famine possible |
| **Deadlock Detection** | Inspecteur cuisine | Detection de cycles |

### 5.2 LDA â€” Traduction Litterale

```
FONCTION serve_dish QUI PREND EN PARAMETRE self QUI EST UNE REFERENCE VERS PlateBuffer ET dish QUI EST DE TYPE T
DEBUT FONCTION
    DECLARER buffer COMME VERROU SUR LA FILE
    AFFECTER LE RESULTAT DE self.buffer.lock() A buffer

    TANT QUE LA LONGUEUR DE buffer EST SUPERIEURE OU EGALE A self.capacity FAIRE
        AFFECTER LE RESULTAT DE self.not_full.wait(buffer) A buffer
        (Remy attend le DING! d'une place libre)
    FIN TANT QUE

    AJOUTER dish A LA FIN DE buffer
    (Remy pose le plat sur le passe)

    APPELER self.not_empty.notify_one()
    (DING! Un plat est pret!)
FIN FONCTION

FONCTION eat (Philosophes) QUI PREND critic_id
DEBUT FONCTION
    DECLARER left COMME critic_id
    DECLARER right COMME (critic_id + 1) MODULO num_critics

    DECLARER first, second COMME LES FOURCHETTES DANS L'ORDRE CROISSANT
    SI left EST INFERIEUR A right ALORS
        AFFECTER (left, right) A (first, second)
    SINON
        AFFECTER (right, left) A (first, second)
    FIN SI

    PRENDRE LE VERROU SUR forks[first]
    (La Regle d'Ego: toujours la plus petite d'abord)
    PRENDRE LE VERROU SUR forks[second]

    MANGER (incrementer meals_eaten)

    LIBERER LES VERROUS (automatique en Rust - RAII)
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PRODUCER-CONSUMER: LA CUISINE                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   REMY (Producer)                 PASSE-PLATS                 ALFREDO (Consumer)
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   ğŸ€        â”‚  serve_dish()   â”‚ â”Œâ”€â”€â”€â”€â”€â” â”‚   pickup_dish() â”‚             â”‚
   â”‚  Cuisine    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ â”‚ ğŸ  â”‚ â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   Salle     â”‚
   â”‚             â”‚                 â”‚ â”‚ ğŸ¥˜  â”‚ â”‚                 â”‚             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ â”‚     â”‚ â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚ â”‚     â”‚ â”‚                       â”‚
         â”‚                         â”‚ â”‚     â”‚ â”‚                       â”‚
         â–¼                         â”‚ â””â”€â”€â”€â”€â”€â”˜ â”‚                       â–¼
    Si plein:                      â”‚ cap = 5 â”‚                  Si vide:
    wait(not_full)                 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                  wait(not_empty)
         â”‚                              â”‚                            â”‚
         â”‚â—„â”€â”€â”€â”€â”€â”€ notify(not_full) â”€â”€â”€â”€â”€â”¤                            â”‚
         â”‚                              â”‚â”€â”€â”€â”€â”€ notify(not_empty) â”€â”€â”€â–ºâ”‚


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DINING PHILOSOPHERS: LA TABLE                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                            ğŸ´ Fork 0
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                   â”‚
             ğŸ´ 4 â”€â”€â”‚      Critic 0     â”‚â”€â”€ ğŸ´ 1
                    â”‚        (Ego)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
               Critic 4 â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€ Critic 1
                    â”‚         â”‚         â”‚
             ğŸ´ 4 â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€ ğŸ´ 1
                    â”‚         â”‚         â”‚
               Critic 3 â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€ Critic 2
                              â”‚
                           ğŸ´ 3 â”€â”€â”€â”€â”€â”€â”€ ğŸ´ 2

    REGLE D'EGO (Resource Ordering):
    Critic N prend d'abord Fork min(N, N+1), puis l'autre

    Critic 0: Fork 0 puis Fork 1  âœ“
    Critic 1: Fork 1 puis Fork 2  âœ“
    Critic 2: Fork 2 puis Fork 3  âœ“
    Critic 3: Fork 3 puis Fork 4  âœ“
    Critic 4: Fork 0 puis Fork 4  âœ“  â† BRISE LE CYCLE!


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BANKER'S ALGORITHM: SAFE STATE                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Available: [3 oeufs, 3 beurre, 2 farine]

    Chef  | Allocation | Max  | Need
    â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€
      0   | [0,1,0]    |[7,5,3]|[7,4,3]
      1   | [2,0,0]    |[3,2,2]|[1,2,2]  â† Peut finir! Need <= Available
      2   | [3,0,2]    |[9,0,2]|[6,0,0]
      3   | [2,1,1]    |[2,2,2]|[0,1,1]  â† Peut finir!
      4   | [0,0,2]    |[4,3,3]|[4,3,1]

    SEQUENCE SAFE: [1, 3, 4, 2, 0]

    1. Chef 1 finit â†’ libere [2,0,0] â†’ Available = [5,3,2]
    2. Chef 3 finit â†’ libere [2,1,1] â†’ Available = [7,4,3]
    3. Chef 4 finit â†’ libere [0,0,2] â†’ Available = [7,4,5]
    4. Chef 2 finit â†’ libere [3,0,2] â†’ Available = [10,4,7]
    5. Chef 0 finit â†’ TOUS ONT FINI!


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DEADLOCK DETECTION: WAIT-FOR GRAPH                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    holds[0] = {couteau}      waits_for[0] = {fourchette}
    holds[1] = {fourchette}   waits_for[1] = {couteau}

    WAIT-FOR GRAPH:

         Chef 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Chef 1
            â–²                      â”‚
            â”‚                      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    CYCLE DETECTE: [0, 1, 0]
    DEADLOCK!

    Solution: Terminer Chef 1 (moins de ressources)
```

### 5.4 Les pieges en detail

#### Piege 1: IF au lieu de WHILE (Spurious Wakeup)

```rust
// âŒ FAUX - Peut causer un buffer overflow!
if buffer.len() >= capacity {
    buffer = not_full.wait(buffer).unwrap();
}
buffer.push_back(dish);

// âœ… CORRECT - Toujours re-verifier apres le reveil
while buffer.len() >= capacity {
    buffer = not_full.wait(buffer).unwrap();
}
buffer.push_back(dish);
```

Les **spurious wakeups** sont des reveils sans raison. C'est dans la spec POSIX!

#### Piege 2: Oublier notify = threads bloques a jamais

```rust
// âŒ DEADLOCK GARANTI
fn serve_dish(&self, dish: T) {
    let mut buffer = self.buffer.lock().unwrap();
    while buffer.len() >= self.capacity {
        buffer = self.not_full.wait(buffer).unwrap();
    }
    buffer.push_back(dish);
    // OUBLIE: self.not_empty.notify_one();
}
// Les consommateurs attendront ETERNELLEMENT!
```

#### Piege 3: Philosophes sans ordering

```rust
// âŒ DEADLOCK CLASSIQUE
fn eat(&self, id: usize) {
    let left = id;
    let right = (id + 1) % self.num;

    let _l = self.forks[left].lock();   // Tous prennent gauche
    let _r = self.forks[right].lock();  // Tous attendent droite
    // DEADLOCK: Chacun attend l'autre!
}
```

### 5.5 Cours Complet

#### Le Probleme Producer-Consumer

Deux types de threads :
- **Producers** : Generent des donnees et les mettent dans un buffer
- **Consumers** : Retirent et traitent les donnees du buffer

**Contraintes :**
1. Le buffer a une capacite limitee
2. On ne peut pas ajouter si plein
3. On ne peut pas retirer si vide
4. L'acces doit etre thread-safe

**Solution avec Condition Variables :**

```rust
// Producer
while buffer.is_full() {
    wait(&not_full);  // Dort jusqu'a ce qu'une place se libere
}
buffer.add(item);
signal(&not_empty);   // Reveille un consumer

// Consumer
while buffer.is_empty() {
    wait(&not_empty); // Dort jusqu'a ce qu'un item arrive
}
item = buffer.remove();
signal(&not_full);    // Reveille un producer
```

#### Le Probleme Readers-Writers

Plusieurs threads accedent a une ressource :
- **Readers** : Acces en lecture seule (peuvent etre simultanes)
- **Writers** : Acces en ecriture (doit etre exclusif)

**Trois politiques :**

| Politique | Description | Risque |
|-----------|-------------|--------|
| Readers-First | Lecteurs ont priorite | Writers starvation |
| Writers-First | Ecrivains ont priorite | Readers starvation |
| Fair | Ordre d'arrivee | Plus complexe |

#### Le Probleme des Philosophes Dineurs

N philosophes autour d'une table avec N fourchettes. Chacun a besoin de 2 fourchettes pour manger.

**Sans solution = DEADLOCK si tous prennent leur fourchette gauche!**

**Solutions :**

1. **Resource Ordering** : Toujours prendre la fourchette de plus petit numero d'abord
2. **Central Waiter** : Demander permission a un arbitre central
3. **Chandy-Misra** : Fourchettes propres/sales avec message passing

#### L'Algorithme du Banquier

InventÃ© par Dijkstra pour l'Ã©vitement de deadlock.

**IdÃ©e** : Avant d'accorder une ressource, vÃ©rifier que le systÃ¨me reste dans un Ã©tat "safe".

**Ã‰tat safe** = Il existe une sÃ©quence dans laquelle tous les processus peuvent finir.

**Algorithme de Safety** :
1. `work = available` (ressources disponibles)
2. `finish[i] = false` pour tous
3. Trouver un processus i tel que `need[i] <= work` et `finish[i] == false`
4. Si trouvÃ© : `work += allocation[i]`, `finish[i] = true`, goto 3
5. Si tous `finish[i] == true` â†’ SAFE

### 5.6 Normes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if buffer.len() >= capacity {                                    â”‚
â”‚     wait(&condvar);                                              â”‚
â”‚ }                                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ while buffer.len() >= capacity {                                 â”‚
â”‚     buffer = condvar.wait(buffer).unwrap();                     â”‚
â”‚ }                                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚ Les spurious wakeups peuvent reveiller un thread sans que       â”‚
â”‚ la condition soit devenue vraie. TOUJOURS re-verifier!          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'execution

**Trace Producer-Consumer (2 producers, 1 consumer, buffer size 2)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Action                                      â”‚ Buffer â”‚ Explication         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ P1: serve_dish(A)                           â”‚ [A]    â”‚ Buffer etait vide   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ P2: serve_dish(B)                           â”‚ [A,B]  â”‚ Buffer avait place  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ P1: serve_dish(C) - BLOQUE                  â”‚ [A,B]  â”‚ Buffer plein!       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ C: pickup_dish() â†’ A                        â”‚ [B]    â”‚ Consomme A          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ P1: notify recu, reveille!                  â”‚ [B]    â”‚ Place liberee       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ P1: push(C)                                 â”‚ [B,C]  â”‚ Peut inserer        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ C: pickup_dish() â†’ B                        â”‚ [C]    â”‚ Consomme B          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ C: pickup_dish() â†’ C                        â”‚ []     â”‚ Consomme C          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ C: pickup_dish() - BLOQUE                   â”‚ []     â”‚ Buffer vide!        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 Mnemotechniques

#### ğŸ€ MEME : "Anyone Can Cook!" â€” Producer-Consumer

![Ratatouille](ratatouille_anyone_can_cook.jpg)

Dans Ratatouille, Gusteau dit "Anyone can cook!". En synchronisation, **anyone can produce, anyone can consume** â€” mais pas en meme temps sur le meme slot!

```rust
// ğŸ€ REMY CUISINE (Producer)
while passe_plat_plein() {
    attendre_le_ding();  // Condvar wait
}
poser_le_plat();
sonner_la_cloche();      // Condvar notify

// ğŸ½ï¸ ALFREDO SERT (Consumer)
while passe_plat_vide() {
    attendre_le_ding();
}
prendre_le_plat();
sonner_la_cloche();
```

#### ğŸ´ MEME : "La Regle d'Ego" â€” Resource Ordering

Anton Ego, le critique severe, a une regle simple : "Je prends TOUJOURS la plus petite fourchette d'abord."

Cette regle brise l'attente circulaire et previent le deadlock!

```rust
// ğŸ´ LA REGLE D'EGO
let (first, second) = if left < right {
    (left, right)   // Plus petit d'abord
} else {
    (right, left)
};
// Plus jamais de deadlock a table!
```

#### ğŸ’° MEME : "Le Banquier Prudent" â€” Safety Check

Comme un banquier qui ne prete que s'il est SUR de pouvoir recuperer, l'algorithme du banquier n'accorde que si l'etat reste safe.

---

## âš ï¸ SECTION 6 : PIEGES RECAPITULATIF

| Piege | Description | Solution |
|-------|-------------|----------|
| Spurious wakeup | Reveil sans raison | WHILE pas IF autour de wait |
| Oubli notify | Threads bloques eternellement | Toujours notify apres modification |
| Circular wait | Deadlock philosophes | Resource ordering |
| Lock ordering | Deadlock multiple locks | Toujours meme ordre global |
| Writers starvation | Ecrivains jamais servis | Policy WritersFirst ou Fair |
| Readers starvation | Lecteurs jamais servis | Policy ReadersFirst ou Fair |
| Unsafe state | Banker accorde trop | Toujours verifier is_safe() |
| Faux cycle | Detection incorrect | DFS avec tracking du chemin |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Dans le probleme Producer-Consumer, pourquoi utiliser WHILE et pas IF autour du wait() ?**

A) Pour la performance
B) Pour gerer les spurious wakeups
C) Pour eviter les race conditions
D) Pour la lisibilite
E) Ce n'est pas necessaire
F) Pour le compilateur
G) Pour les tests
H) Pour le debuggage
I) Pour la norme
J) Aucune raison technique

**Reponse : B**
Les spurious wakeups peuvent reveiller un thread sans que la condition soit vraie. Le WHILE force une re-verification.

### Question 2
**Quelle solution aux Dining Philosophers garantit l'absence de deadlock par design mathematique ?**

A) Random delay
B) Central waiter
C) Resource ordering
D) Try-lock avec backoff
E) Priority-based
F) Time-slicing
G) Token passing
H) Semaphores
I) Monitors
J) Spin locks

**Reponse : C**
Le Resource Ordering (toujours prendre dans l'ordre croissant) brise mathematiquement l'attente circulaire.

### Question 3
**Dans l'algorithme du Banquier, qu'est-ce qu'un etat "safe" ?**

A) Aucun processus ne peut etre termine
B) Tous les processus sont bloques
C) Il existe une sequence ou tous peuvent finir
D) Les ressources sont illimitees
E) Aucun deadlock actuel
F) Maximum de ressources utilisees
G) Minimum de ressources allouees
H) Tous ont leurs ressources
I) Personne n'attend
J) Le systeme est idle

**Reponse : C**
Un etat safe signifie qu'il existe au moins une sequence d'execution dans laquelle tous les processus peuvent obtenir leurs ressources maximales et terminer.

### Question 4
**Quelle politique Readers-Writers peut causer la starvation des ecrivains ?**

A) WritersFirst
B) ReadersFirst
C) Fair
D) Random
E) Priority
F) FIFO
G) Round-robin
H) Time-sliced
I) Adaptive
J) Aucune

**Reponse : B**
Avec ReadersFirst, si des lecteurs arrivent continuellement, les ecrivains peuvent attendre indefiniment.

### Question 5
**Comment le detecteur de deadlock trouve-t-il un deadlock ?**

A) En comptant les ressources
B) En mesurant le temps d'attente
C) En detectant les cycles dans le graphe wait-for
D) En verifiant les priorites
E) En analysant le code
F) Par timeout
G) Par inspection manuelle
H) Par simulation
I) Par prediction
J) Par prevention

**Reponse : C**
Un deadlock existe si et seulement si il y a un cycle dans le graphe d'attente (Wait-For Graph).

---

## ğŸ“Š SECTION 8 : RECAPITULATIF

| Critere | Valeur |
|---------|--------|
| **Exercice** | 2.4.3 - la_brigade_de_cuisine |
| **Concepts** | 45 (2.4.13 a 2.4.19) |
| **Difficulte** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| **Temps** | 8h |
| **XP** | 600 (base) / 1800 (bonus) |
| **Langage** | Rust Edition 2024 |
| **Theme** | Ratatouille - La Brigade de Cuisine |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.4.3-la-brigade-de-cuisine",
    "generated_at": "2026-01-16 14:30:00",

    "metadata": {
      "exercise_id": "2.4.3",
      "exercise_name": "la_brigade_de_cuisine",
      "module": "2.4.3",
      "module_name": "Classic Synchronization Problems",
      "concept": "c,f,g,a-i",
      "concept_name": "Producer-Consumer + Readers-Writers + Philosophers + Banker + Deadlock",
      "type": "complet",
      "tier": 3,
      "tier_info": "Synthese",
      "phase": 2,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "duration_minutes": 480,
      "xp_base": 600,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["ex00 Thread Fundamentals", "ex01 Mutex", "ex02 Semaphores"],
      "domains": ["Process", "Mem", "Struct"],
      "domains_bonus": ["Algo"],
      "tags": ["concurrency", "synchronization", "producer-consumer", "readers-writers", "philosophers", "deadlock", "banker"],
      "meme_reference": "Ratatouille - Anyone Can Cook"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "src/lib.rs": "/* Module exports */",
      "src/producer_consumer.rs": "/* PlateBuffer */",
      "src/readers_writers.rs": "/* RecipeBook */",
      "src/dining_philosophers.rs": "/* DiningTable */",
      "src/bankers.rs": "/* InventoryBanker */",
      "src/deadlock_detector.rs": "/* KitchenInspector */",
      "tests/integration_tests.rs": "/* Section 4.2 */",
      "mutants/mutant_a_spurious.rs": "/* IF instead of WHILE */",
      "mutants/mutant_b_no_notify.rs": "/* Missing notify */",
      "mutants/mutant_c_no_ordering.rs": "/* Philosophers deadlock */",
      "mutants/mutant_d_unsafe_banker.rs": "/* No safety check */",
      "mutants/mutant_e_bad_cycle.rs": "/* Wrong cycle detection */"
    },

    "validation": {
      "expected_pass": [
        "src/producer_consumer.rs",
        "src/readers_writers.rs",
        "src/dining_philosophers.rs",
        "src/bankers.rs",
        "src/deadlock_detector.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_spurious.rs",
        "mutants/mutant_b_no_notify.rs",
        "mutants/mutant_c_no_ordering.rs",
        "mutants/mutant_d_unsafe_banker.rs",
        "mutants/mutant_e_bad_cycle.rs"
      ]
    },

    "commands": {
      "build": "cargo build",
      "test": "cargo test",
      "run_demo": "cargo run --example kitchen_demo",
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” "Anyone Can Cook!"*
*L'excellence pedagogique ne se negocie pas â€” pas de raccourcis*
