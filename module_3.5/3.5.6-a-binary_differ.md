# Exercice 3.5.6-a : binary_differ

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî Comparaison et Diff√©renciation de Binaires (Bindiff)

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.5
- Compr√©hension des structures ELF/PE
- Notions de hashing et fingerprinting

**Domaines :**
CPU, ASM, Crypto, Struct

**Dur√©e estim√©e :**
120 min

**XP Base :**
450

**Complexit√© :**
T4 O(n√óm) √ó S3 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`binary_differ.rs`

**Fonctions autoris√©es :**
- `serde_json` pour JSON
- `std::collections::{HashMap, HashSet, BTreeMap}`
- Fonctions de hashing (SHA256, MD5) via impl√©mentation manuelle ou trait

**Fonctions interdites :**
- Biblioth√®ques de bindiff externes
- Acc√®s filesystem direct

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "The Prestige" meets "Sherlock Holmes"

**"Are you watching closely?"** ‚Äî Dans *The Prestige*, deux magiciens s'√©pient et analysent chaque diff√©rence dans leurs tours. Sherlock Holmes d√©tecte les moindres variations entre deux sc√®nes de crime.

Tu es le **Binary Differ** ‚Äî un d√©tective num√©rique. Deux versions d'un m√™me programme te sont pr√©sent√©es. Une mise √† jour de s√©curit√©, une correction de bug, ou... un backdoor ins√©r√© ? Ta mission : identifier chaque diff√©rence et en comprendre la signification.

**"When you have eliminated the impossible, whatever remains, however improbable, must be the truth."**

**Ta mission :**

√âcrire une fonction `binary_differ` qui compare deux binaires et produit un rapport d√©taill√© des diff√©rences.

**Entr√©e :**
- `diff_json` : JSON contenant :
  - `binary_a` : Premier binaire (hex)
  - `binary_b` : Second binaire (hex)
  - `sections_a` : M√©tadonn√©es des sections (A)
  - `sections_b` : M√©tadonn√©es des sections (B)
  - `symbols_a` : Symboles optionnels (A)
  - `symbols_b` : Symboles optionnels (B)
  - `diff_mode` : "structural" | "semantic" | "byte_level"

**Sortie :**
- JSON contenant :
  - `summary` : R√©sum√© des diff√©rences
  - `added_functions` : Fonctions ajout√©es
  - `removed_functions` : Fonctions supprim√©es
  - `modified_functions` : Fonctions modifi√©es avec d√©tails
  - `section_changes` : Changements de sections
  - `similarity_score` : Score de similarit√© (0.0-1.0)
  - `security_implications` : Implications s√©curit√© d√©tect√©es
  - `patch_type` : Type de patch ("bugfix", "feature", "security", "unknown")

#### 1.2.2 Consigne Acad√©mique

Impl√©menter un syst√®me de comparaison de binaires (bindiff) qui analyse deux versions d'un ex√©cutable. Le syst√®me doit identifier les fonctions ajout√©es, supprim√©es et modifi√©es, calculer un score de similarit√©, et d√©tecter les implications potentielles de s√©curit√©.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct SectionInfo {
    pub name: String,
    pub offset: u64,
    pub size: u64,
    pub hash: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SymbolInfo {
    pub name: String,
    pub address: u64,
    pub size: u64,
    pub symbol_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DiffInput {
    pub binary_a: String,
    pub binary_b: String,
    pub sections_a: Vec<SectionInfo>,
    pub sections_b: Vec<SectionInfo>,
    pub symbols_a: Option<Vec<SymbolInfo>>,
    pub symbols_b: Option<Vec<SymbolInfo>>,
    pub diff_mode: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FunctionDiff {
    pub name: String,
    pub change_type: String,
    pub similarity: f64,
    pub details: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DiffResult {
    pub summary: String,
    pub added_functions: Vec<String>,
    pub removed_functions: Vec<String>,
    pub modified_functions: Vec<FunctionDiff>,
    pub section_changes: Vec<String>,
    pub similarity_score: f64,
    pub security_implications: Vec<String>,
    pub patch_type: String,
}

pub fn binary_differ(diff_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 BinDiff est un Outil Crucial en S√©curit√©

- **Patch Tuesday Analysis** : Les chercheurs comparent les binaires avant/apr√®s update Windows
- **1-Day Exploits** : La fen√™tre entre patch et analyse est critique
- **Malware Variants** : Identifier les modifications dans les souches

### 2.2 Algorithmes de Comparaison

| M√©thode | Pr√©cision | Vitesse | Usage |
|---------|-----------|---------|-------|
| Byte diff | Exacte | Rapide | Patches mineurs |
| CFG matching | Haute | Lent | Analyse s√©mantique |
| Hash par bloc | Moyenne | Rapide | Triage initial |
| Instruction normalization | Haute | Moyen | R√©sistant obfuscation |

### 2.3 Outils Professionnels

- **BinDiff** (Google) : Standard de l'industrie
- **Diaphora** : Open source, IDA/Ghidra
- **radiff2** : Int√©gr√© √† radare2
- **DarunGrim** : Sp√©cialis√© Windows

---

## 2.5 DANS LA VRAIE VIE

| M√©tier | Usage du Bindiff |
|--------|------------------|
| **Vuln Researcher** | Analyser patches Microsoft pour trouver 1-days |
| **Malware Analyst** | Comparer variants de malware |
| **Firmware Engineer** | V√©rifier changements entre versions |
| **QA Engineer** | Valider que seuls les changements pr√©vus existent |
| **Threat Intel** | Tracker l'√©volution des APT tools |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
binary_differ.rs  main.rs

$ cargo build --release

$ ./target/release/test
Test 1 (identical): similarity=1.0, patch_type=none ‚Üí OK
Test 2 (bugfix): 1 modified function ‚Üí OK
Test 3 (security): security implications detected ‚Üí OK
Test 4 (feature): 3 added functions ‚Üí OK
Tous les tests passent!
```

### 3.1 üíÄ BONUS EXPERT (OPTIONNEL)

**Difficult√© Bonus :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**R√©compense :**
XP √ó4

**Ta mission bonus :**
Impl√©menter un syst√®me de matching bas√© sur les Control Flow Graphs (CFG). Comparer les fonctions non pas byte-√†-byte mais par leur structure de contr√¥le de flux, r√©sistant aux recompilations avec diff√©rents compilateurs.

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Sc√©nario | Expected | Points |
|------|----------|----------|--------|
| `identical` | Binaires identiques | similarity=1.0, no changes | 10 |
| `one_func_mod` | Une fonction modifi√©e | modified_functions.len()=1 | 15 |
| `added_funcs` | 3 fonctions ajout√©es | added_functions.len()=3 | 15 |
| `removed_funcs` | 2 fonctions supprim√©es | removed_functions.len()=2 | 15 |
| `security_patch` | Patch s√©curit√© (bounds check) | security_implications non-vide | 20 |
| `section_resize` | Section .text agrandie | section_changes d√©tect√© | 10 |
| `stripped_vs_not` | Comparaison stripped/non-stripped | Gestion gracieuse | 15 |

### 4.2 main.rs de test

```rust
use binary_differ::{binary_differ, DiffInput, DiffResult};

fn main() {
    // Test 1: Binaires identiques
    let input1 = r#"{
        "binary_a": "4889e5488b3d",
        "binary_b": "4889e5488b3d",
        "sections_a": [{"name": ".text", "offset": 0, "size": 6, "hash": "abc123"}],
        "sections_b": [{"name": ".text", "offset": 0, "size": 6, "hash": "abc123"}],
        "symbols_a": [{"name": "main", "address": 0, "size": 6, "symbol_type": "FUNC"}],
        "symbols_b": [{"name": "main", "address": 0, "size": 6, "symbol_type": "FUNC"}],
        "diff_mode": "structural"
    }"#;

    let result1 = binary_differ(input1).unwrap();
    let diff1: DiffResult = serde_json::from_str(&result1).unwrap();
    assert!((diff1.similarity_score - 1.0).abs() < 0.01);
    assert!(diff1.modified_functions.is_empty());
    println!("Test 1 (identical): PASS");

    // Test 2: Une fonction modifi√©e
    let input2 = r#"{
        "binary_a": "4889e5488b3d00000000",
        "binary_b": "4889e5488b3d11111111",
        "sections_a": [{"name": ".text", "offset": 0, "size": 10, "hash": "aaa"}],
        "sections_b": [{"name": ".text", "offset": 0, "size": 10, "hash": "bbb"}],
        "symbols_a": [{"name": "check_bounds", "address": 0, "size": 10, "symbol_type": "FUNC"}],
        "symbols_b": [{"name": "check_bounds", "address": 0, "size": 10, "symbol_type": "FUNC"}],
        "diff_mode": "structural"
    }"#;

    let result2 = binary_differ(input2).unwrap();
    let diff2: DiffResult = serde_json::from_str(&result2).unwrap();
    assert_eq!(diff2.modified_functions.len(), 1);
    println!("Test 2 (one_func_mod): PASS");

    // Test 3: Fonctions ajout√©es
    let input3 = r#"{
        "binary_a": "4889e5",
        "binary_b": "4889e54889e54889e5",
        "sections_a": [{"name": ".text", "offset": 0, "size": 3, "hash": "x"}],
        "sections_b": [{"name": ".text", "offset": 0, "size": 9, "hash": "y"}],
        "symbols_a": [{"name": "main", "address": 0, "size": 3, "symbol_type": "FUNC"}],
        "symbols_b": [
            {"name": "main", "address": 0, "size": 3, "symbol_type": "FUNC"},
            {"name": "new_func1", "address": 3, "size": 3, "symbol_type": "FUNC"},
            {"name": "new_func2", "address": 6, "size": 3, "symbol_type": "FUNC"}
        ],
        "diff_mode": "structural"
    }"#;

    let result3 = binary_differ(input3).unwrap();
    let diff3: DiffResult = serde_json::from_str(&result3).unwrap();
    assert_eq!(diff3.added_functions.len(), 2);
    println!("Test 3 (added_funcs): PASS");

    println!("\nTous les tests passent!");
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectionInfo {
    pub name: String,
    pub offset: u64,
    pub size: u64,
    pub hash: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SymbolInfo {
    pub name: String,
    pub address: u64,
    pub size: u64,
    pub symbol_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DiffInput {
    pub binary_a: String,
    pub binary_b: String,
    pub sections_a: Vec<SectionInfo>,
    pub sections_b: Vec<SectionInfo>,
    pub symbols_a: Option<Vec<SymbolInfo>>,
    pub symbols_b: Option<Vec<SymbolInfo>>,
    pub diff_mode: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FunctionDiff {
    pub name: String,
    pub change_type: String,
    pub similarity: f64,
    pub details: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DiffResult {
    pub summary: String,
    pub added_functions: Vec<String>,
    pub removed_functions: Vec<String>,
    pub modified_functions: Vec<FunctionDiff>,
    pub section_changes: Vec<String>,
    pub similarity_score: f64,
    pub security_implications: Vec<String>,
    pub patch_type: String,
}

fn hex_to_bytes(hex: &str) -> Vec<u8> {
    (0..hex.len())
        .step_by(2)
        .filter_map(|i| u8::from_str_radix(&hex[i..i+2], 16).ok())
        .collect()
}

fn simple_hash(data: &[u8]) -> u64 {
    data.iter().fold(0u64, |acc, &b| acc.wrapping_mul(31).wrapping_add(b as u64))
}

fn byte_similarity(a: &[u8], b: &[u8]) -> f64 {
    if a.is_empty() && b.is_empty() {
        return 1.0;
    }
    if a.is_empty() || b.is_empty() {
        return 0.0;
    }

    let matches = a.iter().zip(b.iter()).filter(|(x, y)| x == y).count();
    let max_len = a.len().max(b.len());
    matches as f64 / max_len as f64
}

fn detect_security_keywords(name: &str) -> bool {
    let security_keywords = [
        "check", "bounds", "overflow", "auth", "verify", "validate",
        "encrypt", "decrypt", "hash", "sign", "cert", "password",
        "buffer", "length", "size", "limit", "sanitize", "escape"
    ];
    let name_lower = name.to_lowercase();
    security_keywords.iter().any(|kw| name_lower.contains(kw))
}

pub fn binary_differ(diff_json: &str) -> Result<String, String> {
    let input: DiffInput = serde_json::from_str(diff_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let bytes_a = hex_to_bytes(&input.binary_a);
    let bytes_b = hex_to_bytes(&input.binary_b);

    let mut added_functions = Vec::new();
    let mut removed_functions = Vec::new();
    let mut modified_functions = Vec::new();
    let mut section_changes = Vec::new();
    let mut security_implications = Vec::new();

    // === Analyse des symboles ===
    let symbols_a: HashMap<String, SymbolInfo> = input.symbols_a
        .clone()
        .unwrap_or_default()
        .into_iter()
        .filter(|s| s.symbol_type == "FUNC")
        .map(|s| (s.name.clone(), s))
        .collect();

    let symbols_b: HashMap<String, SymbolInfo> = input.symbols_b
        .clone()
        .unwrap_or_default()
        .into_iter()
        .filter(|s| s.symbol_type == "FUNC")
        .map(|s| (s.name.clone(), s))
        .collect();

    let names_a: HashSet<_> = symbols_a.keys().collect();
    let names_b: HashSet<_> = symbols_b.keys().collect();

    // Fonctions ajout√©es
    for name in names_b.difference(&names_a) {
        added_functions.push((*name).clone());
        if detect_security_keywords(name) {
            security_implications.push(format!("New security-related function: {}", name));
        }
    }

    // Fonctions supprim√©es
    for name in names_a.difference(&names_b) {
        removed_functions.push((*name).clone());
        if detect_security_keywords(name) {
            security_implications.push(format!("Removed security function: {} - potential vulnerability", name));
        }
    }

    // Fonctions modifi√©es
    for name in names_a.intersection(&names_b) {
        let sym_a = &symbols_a[*name];
        let sym_b = &symbols_b[*name];

        // Extraire les bytes de chaque fonction
        let start_a = sym_a.address as usize;
        let end_a = (sym_a.address + sym_a.size) as usize;
        let start_b = sym_b.address as usize;
        let end_b = (sym_b.address + sym_b.size) as usize;

        let func_bytes_a = if end_a <= bytes_a.len() {
            &bytes_a[start_a..end_a]
        } else {
            &[]
        };

        let func_bytes_b = if end_b <= bytes_b.len() {
            &bytes_b[start_b..end_b]
        } else {
            &[]
        };

        let similarity = byte_similarity(func_bytes_a, func_bytes_b);

        if similarity < 1.0 {
            let change_type = if sym_a.size != sym_b.size {
                "size_changed"
            } else {
                "content_changed"
            };

            modified_functions.push(FunctionDiff {
                name: (*name).clone(),
                change_type: change_type.to_string(),
                similarity,
                details: format!(
                    "Size: {} -> {}, Similarity: {:.1}%",
                    sym_a.size, sym_b.size, similarity * 100.0
                ),
            });

            if detect_security_keywords(name) {
                security_implications.push(format!(
                    "Modified security function: {} ({:.1}% similar)",
                    name, similarity * 100.0
                ));
            }
        }
    }

    // === Analyse des sections ===
    let sections_a_map: HashMap<_, _> = input.sections_a.iter()
        .map(|s| (s.name.clone(), s))
        .collect();
    let sections_b_map: HashMap<_, _> = input.sections_b.iter()
        .map(|s| (s.name.clone(), s))
        .collect();

    for (name, sec_a) in &sections_a_map {
        if let Some(sec_b) = sections_b_map.get(name) {
            if sec_a.hash != sec_b.hash {
                section_changes.push(format!(
                    "{}: hash changed, size {} -> {}",
                    name, sec_a.size, sec_b.size
                ));
            } else if sec_a.size != sec_b.size {
                section_changes.push(format!(
                    "{}: size changed {} -> {}",
                    name, sec_a.size, sec_b.size
                ));
            }
        } else {
            section_changes.push(format!("{}: removed", name));
        }
    }

    for name in sections_b_map.keys() {
        if !sections_a_map.contains_key(name) {
            section_changes.push(format!("{}: added", name));
        }
    }

    // === Calcul du score de similarit√© global ===
    let overall_similarity = byte_similarity(&bytes_a, &bytes_b);

    // === D√©termination du type de patch ===
    let patch_type = if added_functions.is_empty()
        && removed_functions.is_empty()
        && modified_functions.is_empty()
    {
        "none".to_string()
    } else if !security_implications.is_empty() {
        "security".to_string()
    } else if !added_functions.is_empty() && modified_functions.is_empty() {
        "feature".to_string()
    } else if modified_functions.len() <= 2 && added_functions.is_empty() {
        "bugfix".to_string()
    } else {
        "unknown".to_string()
    };

    // === G√©n√©ration du r√©sum√© ===
    let summary = format!(
        "Compared binaries: {} bytes vs {} bytes. {} functions added, {} removed, {} modified. Similarity: {:.1}%",
        bytes_a.len(),
        bytes_b.len(),
        added_functions.len(),
        removed_functions.len(),
        modified_functions.len(),
        overall_similarity * 100.0
    );

    let result = DiffResult {
        summary,
        added_functions,
        removed_functions,
        modified_functions,
        section_changes,
        similarity_score: overall_similarity,
        security_implications,
        patch_type,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

### 4.9 spec.json

```json
{
  "name": "binary_differ",
  "language": "rust",
  "type": "complet",
  "tier": 1,
  "tier_info": "Concept isol√©",
  "tags": ["bindiff", "comparison", "reverse-engineering", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "binary_differ",
    "prototype": "pub fn binary_differ(diff_json: &str) -> Result<String, String>",
    "return_type": "Result<String, String>",
    "parameters": [
      {"name": "diff_json", "type": "&str"}
    ]
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A: Ignore les symboles manquants */
pub fn binary_differ_mutant_a(diff_json: &str) -> Result<String, String> {
    // Panic si symbols_a ou symbols_b est None
    let symbols_a = input.symbols_a.unwrap(); // Bug!
}
// Pourquoi c'est faux: Binaires stripped n'ont pas de symboles

/* Mutant B: Similarit√© toujours 100% si m√™me taille */
pub fn binary_differ_mutant_b(diff_json: &str) -> Result<String, String> {
    if bytes_a.len() == bytes_b.len() {
        return Ok(r#"{"similarity_score": 1.0}"#.to_string());
    }
}
// Pourquoi c'est faux: M√™me taille ‚â† m√™me contenu

/* Mutant C: Ignore les security keywords */
pub fn binary_differ_mutant_c(diff_json: &str) -> Result<String, String> {
    // N'analyse pas les implications s√©curit√©
}
// Pourquoi c'est faux: Les patches s√©curit√© sont critiques √† identifier

/* Mutant D: Off-by-one dans extraction bytes */
pub fn binary_differ_mutant_d(diff_json: &str) -> Result<String, String> {
    let func_bytes = &bytes[start..end+1]; // Bug: +1
}
// Pourquoi c'est faux: Lit un byte de trop

/* Mutant E: Confusion added/removed */
pub fn binary_differ_mutant_e(diff_json: &str) -> Result<String, String> {
    // names_a.difference(&names_b) pour added au lieu de removed
}
// Pourquoi c'est faux: Inverse les ajouts et suppressions
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Techniques de bindiff** pour comparer des binaires
2. **Analyse de patches** et leurs implications
3. **D√©tection de changements s√©curit√©**
4. **Matching de fonctions** entre versions
5. **M√©triques de similarit√©**

### 5.3 Visualisation ASCII

```
            COMPARAISON DE DEUX BINAIRES

    BINARY A (v1.0)              BINARY B (v1.1)
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ .text           ‚îÇ          ‚îÇ .text           ‚îÇ
    ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ          ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
    ‚îÇ ‚îÇ main()      ‚îÇ ‚îÇ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ∫ ‚îÇ ‚îÇ main()      ‚îÇ ‚îÇ IDENTIQUE
    ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ          ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ
    ‚îÇ ‚îÇ check()     ‚îÇ ‚îÇ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ∫ ‚îÇ ‚îÇ check()  *  ‚îÇ ‚îÇ MODIFI√â
    ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ          ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ
    ‚îÇ ‚îÇ process()   ‚îÇ ‚îÇ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ∫ ‚îÇ ‚îÇ process()   ‚îÇ ‚îÇ IDENTIQUE
    ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ          ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ
    ‚îÇ ‚îÇ oldFunc()   ‚îÇ ‚îÇ ‚îÄ‚îÄ‚îÄX     ‚îÇ ‚îÇ newFunc()   ‚îÇ ‚îÇ REMOVED/ADDED
    ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ          ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


    ALGORITHME DE MATCHING DE FONCTIONS

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Pour chaque    ‚îÇ
    ‚îÇ fonction A     ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Chercher dans B:                       ‚îÇ
    ‚îÇ 1. M√™me nom exact                      ‚îÇ
    ‚îÇ 2. M√™me hash de contenu                ‚îÇ
    ‚îÇ 3. M√™me structure CFG                  ‚îÇ
    ‚îÇ 4. Similarit√© > seuil                  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ               ‚îÇ
    ‚ñº               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ MATCH  ‚îÇ     ‚îÇ NO MATCH   ‚îÇ
‚îÇ TROUV√â ‚îÇ     ‚îÇ = REMOVED  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ
    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Comparer bytes  ‚îÇ
‚îÇ Si diff√©rent:   ‚îÇ
‚îÇ   ‚Üí MODIFIED    ‚îÇ
‚îÇ Si identique:   ‚îÇ
‚îÇ   ‚Üí UNCHANGED   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üé¨ MEME : "Corporate needs you to find the differences" ‚Äî The Office

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   binary_v1.exe     ‚îÇ  ‚îÇ   binary_v1.1.exe   ‚îÇ
‚îÇ                     ‚îÇ  ‚îÇ                     ‚îÇ
‚îÇ   check_input() {   ‚îÇ  ‚îÇ   check_input() {   ‚îÇ
‚îÇ     ...             ‚îÇ  ‚îÇ     if (len > MAX)  ‚îÇ ‚Üê Spot the diff!
‚îÇ   }                 ‚îÇ  ‚îÇ       return ERR;   ‚îÇ
‚îÇ                     ‚îÇ  ‚îÇ     ...             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Pam: "They're the same picture"
Analyst: "No they're NOT, there's a buffer overflow fix!"
```

---

## üìù SECTION 7 : QCM

### Question 1
**Le bindiff compare principalement :**

A) Les tailles de fichiers uniquement
B) Les structures et contenus des fonctions
C) Les noms de fichiers
D) Les dates de modification

**R√©ponse : B**

### Question 2
**Un patch de s√©curit√© est souvent identifiable par :**

A) L'ajout de nombreuses nouvelles fonctions
B) La modification de fonctions li√©es √† la validation/v√©rification
C) La suppression de toutes les fonctions
D) L'augmentation de la taille du fichier

**R√©ponse : B**

### Question 3
**Quel probl√®me pose la comparaison de binaires stripped ?**

A) Ils sont plus gros
B) Les noms de fonctions sont absents
C) Ils ne s'ex√©cutent pas
D) Ils sont toujours identiques

**R√©ponse : B**

---

## üìä SECTION 8 : R√âCAPITULATIF

| Aspect | D√©tail |
|--------|--------|
| **Concept cl√©** | Comparaison structurelle de binaires |
| **Difficult√©** | 8/10 - Algorithmes de matching |
| **Comp√©tences** | Bindiff, similarit√©, analyse patches |
| **Applications** | Vuln research, patch analysis, malware variants |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.5.6-a-binary-differ",
    "metadata": {
      "exercise_id": "3.5.6-a",
      "exercise_name": "binary_differ",
      "difficulty": 8,
      "xp_base": 450
    }
  }
}
```

---

*Exercice 3.5.6-a ‚Äî Binary Differ*
*"The devil is in the diff."*
*HACKBRAIN v5.5.2*
