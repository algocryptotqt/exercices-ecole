# Exercice 3.5.7-a : ghidra_master

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” MaÃ®trise de Ghidra (NSA's Reverse Engineering Framework)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024 + Ghidra Scripts (Java/Python)

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.6
- Notions de dÃ©sassemblage et dÃ©compilation
- Bases en Java ou Python

**Domaines :**
CPU, ASM, Struct, FS

**DurÃ©e estimÃ©e :**
150 min

**XP Base :**
500

**ComplexitÃ© :**
T4 O(n) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`ghidra_master.rs` + `GhidraAnalyzer.java`

**Fonctions autorisÃ©es :**
- `serde_json` pour JSON
- API Ghidra (FlatProgramAPI, DecompInterface)
- Collections standard

**Fonctions interdites :**
- AccÃ¨s rÃ©seau direct
- Modification de binaires

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Mr. Robot" meets "The Matrix Reloaded"

**"I wanted to save the world."** â€” Dans *Mr. Robot*, Elliot utilise des outils sophistiquÃ©s pour analyser des systÃ¨mes. Dans *The Matrix Reloaded*, le Keymaker connaÃ®t chaque porte et chaque passage.

Tu es le **Ghidra Master** â€” tu connais chaque fonctionnalitÃ© du framework de la NSA. Ghidra est ta porte vers le code machine, le dÃ©compilateur ton traducteur universel. Ta mission : automatiser l'analyse de binaires via scripts Ghidra.

**"Find them. Analyze them. Understand them."**

**Ta mission :**

Partie 1 (Rust): Ã‰crire une fonction `ghidra_project_analyzer` qui parse les exports d'un projet Ghidra et gÃ©nÃ¨re un rapport structurÃ©.

Partie 2 (Java): Ã‰crire un script Ghidra `AnalyzeVulnerabilities.java` qui dÃ©tecte automatiquement des patterns de vulnÃ©rabilitÃ©s.

**EntrÃ©e (Rust) :**
- `ghidra_export_json` : Export JSON d'un projet Ghidra contenant :
  - `functions` : Liste des fonctions avec leur dÃ©compilation
  - `strings` : ChaÃ®nes extraites
  - `imports` : Imports dynamiques
  - `xrefs` : Cross-references

**Sortie (Rust) :**
- JSON contenant :
  - `vuln_candidates` : Fonctions potentiellement vulnÃ©rables
  - `dangerous_calls` : Appels dangereux dÃ©tectÃ©s
  - `crypto_usage` : Utilisation de crypto dÃ©tectÃ©e
  - `string_analysis` : Analyse des strings (URLs, paths, etc.)
  - `call_graph_summary` : RÃ©sumÃ© du graphe d'appels

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct GhidraFunction {
    pub name: String,
    pub address: String,
    pub decompiled: String,
    pub calls: Vec<String>,
    pub called_by: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GhidraExport {
    pub functions: Vec<GhidraFunction>,
    pub strings: Vec<String>,
    pub imports: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VulnCandidate {
    pub function: String,
    pub vuln_type: String,
    pub confidence: f64,
    pub details: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AnalysisResult {
    pub vuln_candidates: Vec<VulnCandidate>,
    pub dangerous_calls: Vec<String>,
    pub crypto_usage: Vec<String>,
    pub string_analysis: HashMap<String, Vec<String>>,
    pub call_graph_summary: String,
}

pub fn ghidra_project_analyzer(ghidra_export_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Ghidra est un Outil de Classe Mondiale

- DÃ©veloppÃ© par la **NSA** et publiÃ© en open source en 2019
- Supporte **50+ architectures** (x86, ARM, MIPS, PowerPC, etc.)
- DÃ©compilateur **gratuit** rivalisant avec IDA Pro ($$$)
- **Scripts extensibles** en Java et Python (Jython)

### 2.2 FonctionnalitÃ©s ClÃ©s

| Feature | Description |
|---------|-------------|
| **Decompiler** | Code C pseudo-code de haute qualitÃ© |
| **PCode** | IR intermÃ©diaire pour analyse |
| **Version Tracking** | Compare versions de binaires |
| **Collaboration** | Serveur multi-utilisateurs |
| **Scripting** | Automatisation Java/Python |
| **Emulator** | Ã‰mulation de code |

---

## 2.5 DANS LA VRAIE VIE

| MÃ©tier | Usage de Ghidra |
|--------|-----------------|
| **Malware Analyst** | Analyse gratuite de samples |
| **Vuln Researcher** | Recherche de bugs dans binaires |
| **Firmware Engineer** | RE de firmware IoT |
| **CTF Player** | RÃ©solution de challenges RE |
| **Government** | Analyse de menaces Ã©tatiques |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
ghidra_master.rs  main.rs  AnalyzeVulnerabilities.java

$ cargo build --release

$ ./target/release/test
Test 1 (detect_strcpy): vuln_candidates contains buffer_overflow â†’ OK
Test 2 (detect_crypto): crypto_usage contains AES â†’ OK
Test 3 (call_graph): call_graph_summary generated â†’ OK
Tous les tests passent!
```

### 3.1 ğŸ§  BONUS GÃ‰NIE (OPTIONNEL)

**DifficultÃ© Bonus :**
ğŸ§  (12/10)

**RÃ©compense :**
XP Ã—6

**Ta mission bonus :**
ImplÃ©menter un systÃ¨me de taint analysis qui trace le flux de donnÃ©es depuis les entrÃ©es utilisateur (stdin, network) jusqu'aux fonctions dangereuses (system, exec, strcpy).

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | ScÃ©nario | Expected | Points |
|------|----------|----------|--------|
| `detect_strcpy` | Fonction avec strcpy | vuln_candidates non-vide | 15 |
| `detect_sprintf` | sprintf sans bounds | dangerous_calls contient sprintf | 15 |
| `detect_crypto` | AES_encrypt appelÃ© | crypto_usage dÃ©tectÃ© | 15 |
| `url_strings` | URLs dans strings | string_analysis["urls"] | 10 |
| `path_strings` | Paths systÃ¨me | string_analysis["paths"] | 10 |
| `call_graph` | Graphe d'appels | call_graph_summary valide | 15 |
| `no_false_positive` | Code sÃ»r | vuln_candidates vide | 20 |

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GhidraFunction {
    pub name: String,
    pub address: String,
    pub decompiled: String,
    pub calls: Vec<String>,
    pub called_by: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GhidraExport {
    pub functions: Vec<GhidraFunction>,
    pub strings: Vec<String>,
    pub imports: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VulnCandidate {
    pub function: String,
    pub vuln_type: String,
    pub confidence: f64,
    pub details: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AnalysisResult {
    pub vuln_candidates: Vec<VulnCandidate>,
    pub dangerous_calls: Vec<String>,
    pub crypto_usage: Vec<String>,
    pub string_analysis: HashMap<String, Vec<String>>,
    pub call_graph_summary: String,
}

const DANGEROUS_FUNCTIONS: &[(&str, &str, f64)] = &[
    ("strcpy", "buffer_overflow", 0.8),
    ("strcat", "buffer_overflow", 0.8),
    ("sprintf", "format_string", 0.7),
    ("gets", "buffer_overflow", 0.95),
    ("scanf", "buffer_overflow", 0.6),
    ("system", "command_injection", 0.5),
    ("exec", "command_injection", 0.5),
    ("popen", "command_injection", 0.5),
    ("memcpy", "buffer_overflow", 0.4),
];

const CRYPTO_FUNCTIONS: &[&str] = &[
    "AES", "DES", "RSA", "SHA", "MD5", "HMAC",
    "encrypt", "decrypt", "hash", "sign", "verify",
    "EVP_", "CRYPTO_", "ssl_", "tls_",
];

pub fn ghidra_project_analyzer(ghidra_export_json: &str) -> Result<String, String> {
    let export: GhidraExport = serde_json::from_str(ghidra_export_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut vuln_candidates = Vec::new();
    let mut dangerous_calls = Vec::new();
    let mut crypto_usage = Vec::new();
    let mut string_analysis: HashMap<String, Vec<String>> = HashMap::new();

    string_analysis.insert("urls".to_string(), Vec::new());
    string_analysis.insert("paths".to_string(), Vec::new());
    string_analysis.insert("credentials".to_string(), Vec::new());

    // === Analyse des fonctions ===
    for func in &export.functions {
        let decompiled_lower = func.decompiled.to_lowercase();

        // DÃ©tection des appels dangereux
        for (dangerous, vuln_type, confidence) in DANGEROUS_FUNCTIONS {
            if decompiled_lower.contains(dangerous) || func.calls.iter().any(|c| c.contains(dangerous)) {
                dangerous_calls.push(format!("{}() in {}", dangerous, func.name));

                vuln_candidates.push(VulnCandidate {
                    function: func.name.clone(),
                    vuln_type: vuln_type.to_string(),
                    confidence: *confidence,
                    details: format!("Uses {}() which is potentially dangerous", dangerous),
                });
            }
        }

        // DÃ©tection crypto
        for crypto in CRYPTO_FUNCTIONS {
            if decompiled_lower.contains(&crypto.to_lowercase())
               || func.calls.iter().any(|c| c.to_lowercase().contains(&crypto.to_lowercase())) {
                crypto_usage.push(format!("{} in {}", crypto, func.name));
            }
        }
    }

    // === Analyse des strings ===
    for s in &export.strings {
        // URLs
        if s.starts_with("http://") || s.starts_with("https://") || s.contains("://") {
            string_analysis.get_mut("urls").unwrap().push(s.clone());
        }

        // Paths
        if s.starts_with("/") || s.contains("\\") || s.starts_with("C:") {
            string_analysis.get_mut("paths").unwrap().push(s.clone());
        }

        // Credentials hints
        let s_lower = s.to_lowercase();
        if s_lower.contains("password") || s_lower.contains("secret")
           || s_lower.contains("api_key") || s_lower.contains("token") {
            string_analysis.get_mut("credentials").unwrap().push(s.clone());
        }
    }

    // === GÃ©nÃ©ration du rÃ©sumÃ© du graphe d'appels ===
    let total_functions = export.functions.len();
    let total_edges: usize = export.functions.iter().map(|f| f.calls.len()).sum();
    let max_callers = export.functions.iter()
        .max_by_key(|f| f.called_by.len())
        .map(|f| (f.name.clone(), f.called_by.len()));

    let call_graph_summary = format!(
        "Call graph: {} functions, {} edges. Most called: {:?}",
        total_functions, total_edges, max_callers
    );

    // DÃ©dupliquer
    dangerous_calls.sort();
    dangerous_calls.dedup();
    crypto_usage.sort();
    crypto_usage.dedup();

    let result = AnalysisResult {
        vuln_candidates,
        dangerous_calls,
        crypto_usage,
        string_analysis,
        call_graph_summary,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

### 4.4 Script Ghidra (Java)

```java
// AnalyzeVulnerabilities.java
// @category Analysis
// @keybinding
// @menupath Analysis.Find Vulnerabilities
// @toolbar

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import java.util.*;

public class AnalyzeVulnerabilities extends GhidraScript {

    private static final String[] DANGEROUS_FUNCS = {
        "strcpy", "strcat", "sprintf", "gets", "scanf",
        "system", "popen", "execve", "memcpy"
    };

    @Override
    public void run() throws Exception {
        println("=== Vulnerability Scanner ===");

        FunctionManager funcMgr = currentProgram.getFunctionManager();
        SymbolTable symTab = currentProgram.getSymbolTable();

        List<String> findings = new ArrayList<>();

        // Iterate over all functions
        FunctionIterator funcIter = funcMgr.getFunctions(true);
        while (funcIter.hasNext()) {
            Function func = funcIter.next();

            // Get called functions
            Set<Function> calledFuncs = func.getCalledFunctions(monitor);

            for (Function called : calledFuncs) {
                String calledName = called.getName();

                for (String dangerous : DANGEROUS_FUNCS) {
                    if (calledName.equals(dangerous)) {
                        String finding = String.format(
                            "[VULN] %s() calls %s() at %s",
                            func.getName(), dangerous, func.getEntryPoint()
                        );
                        findings.add(finding);
                        println(finding);
                    }
                }
            }
        }

        println("\n=== Summary ===");
        println("Total findings: " + findings.size());
    }
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Architecture de Ghidra** et son API
2. **Scripting** pour automatiser l'analyse
3. **DÃ©tection de vulnÃ©rabilitÃ©s** automatisÃ©e
4. **Analyse de graphes d'appels**
5. **Triage de strings** significatives

### 5.3 Visualisation ASCII

```
              ARCHITECTURE GHIDRA

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    GUI                           â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
    â”‚  â”‚ Listing â”‚  â”‚ Decomp  â”‚  â”‚ Graph   â”‚         â”‚
    â”‚  â”‚  View   â”‚  â”‚  View   â”‚  â”‚  View   â”‚         â”‚
    â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚            â”‚            â”‚
            â–¼            â–¼            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              PROGRAM DATABASE                    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
    â”‚  â”‚ Symbols  â”‚  â”‚Functions â”‚  â”‚ Memory   â”‚      â”‚
    â”‚  â”‚ Table    â”‚  â”‚ Manager  â”‚  â”‚ Map      â”‚      â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              ANALYSIS ENGINE                     â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
    â”‚  â”‚Disassem- â”‚  â”‚Decompilerâ”‚  â”‚ PCode    â”‚      â”‚
    â”‚  â”‚  bler    â”‚  â”‚          â”‚  â”‚ Engine   â”‚      â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    WORKFLOW D'ANALYSE AUTOMATISÃ‰E

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Import   â”‚â”€â”€â”€â”€â–ºâ”‚  Auto      â”‚â”€â”€â”€â”€â–ºâ”‚  Script    â”‚
    â”‚   Binary   â”‚     â”‚  Analysis  â”‚     â”‚  Analysis  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                â”‚
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚          â”‚          â”‚
            â–¼          â–¼          â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Find    â”‚ â”‚  Trace   â”‚ â”‚  Export  â”‚
    â”‚  Vulns   â”‚ â”‚  Calls   â”‚ â”‚  Report  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ•µï¸ MEME : "Enhance!" â€” La dÃ©compilation Ghidra

Comme dans les films policiers oÃ¹ ils "amÃ©liorent" une image floue, Ghidra transforme du code machine illisible en C presque lisible.

```
Machine code: 55 48 89 e5 48 83 ec 10 ...
        â†“ ğŸ” ENHANCE! ğŸ”
Decompiled:
int main(int argc, char **argv) {
    printf("Hello World\n");
    return 0;
}
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Ghidra a Ã©tÃ© dÃ©veloppÃ© par :**

A) Microsoft
B) Google
C) NSA
D) Apple

**RÃ©ponse : C**

### Question 2
**Le langage principal pour les scripts Ghidra est :**

A) C++
B) Java
C) Rust
D) Go

**RÃ©ponse : B**

### Question 3
**Le dÃ©compilateur de Ghidra produit :**

A) Du code assembleur
B) Du pseudo-code C
C) Du bytecode Java
D) Du code machine

**RÃ©ponse : B**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Aspect | DÃ©tail |
|--------|--------|
| **Concept clÃ©** | Automatisation d'analyse avec Ghidra |
| **DifficultÃ©** | 8/10 - Scripting + RE |
| **CompÃ©tences** | Ghidra API, dÃ©tection vulns, analyse strings |
| **Applications** | Malware analysis, vuln research, firmware RE |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.5.7-a-ghidra-master",
    "metadata": {
      "exercise_id": "3.5.7-a",
      "exercise_name": "ghidra_master",
      "difficulty": 8,
      "xp_base": 500
    }
  }
}
```

---

*Exercice 3.5.7-a â€” Ghidra Master*
*"The NSA's gift to the world."*
*HACKBRAIN v5.5.2*
