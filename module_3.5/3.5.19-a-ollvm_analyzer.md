# Exercice 3.5.19-a : ollvm_analyzer

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” Analyse et DÃ©sobfuscation OLLVM

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.18
- ComprÃ©hension de LLVM
- Notions de compilation

**Domaines :**
CPU, ASM, Struct, MD

**DurÃ©e estimÃ©e :**
180 min

**XP Base :**
600

**ComplexitÃ© :**
T5 O(n) Ã— S4 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Mr. Robot" meets "Hackers"

**"Control is an illusion."** â€” Dans *Mr. Robot*, Elliot dÃ©mÃªle des systÃ¨mes complexes. Dans *Hackers*, les protagonistes voient Ã  travers le code.

Tu es l'**OLLVM Analyzer** â€” face Ã  toi, du code compilÃ© avec Obfuscator-LLVM, l'obfuscateur open-source le plus utilisÃ©. Bogus Control Flow, Control Flow Flattening, Instruction Substitution â€” OLLVM a tout. Ta mission : identifier les passes d'obfuscation appliquÃ©es et proposer des stratÃ©gies de dÃ©sobfuscation.

**Ta mission :**

Ã‰crire une fonction `analyze_ollvm` qui dÃ©tecte les patterns OLLVM et suggÃ¨re des contre-mesures.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct OLLVMSample {
    pub functions: Vec<OLLVMFunction>,
    pub global_patterns: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OLLVMFunction {
    pub name: String,
    pub basic_blocks: usize,
    pub instructions: Vec<String>,
    pub cfg_edges: Vec<(usize, usize)>,
    pub cyclomatic_complexity: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OLLVMPass {
    pub name: String,             // "bcf", "fla", "sub"
    pub full_name: String,        // "Bogus Control Flow", etc.
    pub confidence: f64,
    pub indicators: Vec<String>,
    pub affected_functions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeobfuscationStrategy {
    pub pass_name: String,
    pub tool_recommendations: Vec<String>,
    pub manual_steps: Vec<String>,
    pub difficulty: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OLLVMReport {
    pub detected_passes: Vec<OLLVMPass>,
    pub strategies: Vec<DeobfuscationStrategy>,
    pub obfuscation_level: String,
    pub estimated_effort: String,
}

pub fn analyze_ollvm(sample_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Passes OLLVM

| Pass | Code | Description |
|------|------|-------------|
| **Bogus Control Flow** | `-bcf` | Ajoute faux blocs avec opaque predicates |
| **Control Flow Flattening** | `-fla` | Transforme en state machine |
| **Instruction Substitution** | `-sub` | Remplace instructions par Ã©quivalents complexes |
| **String Encryption** | `-sobf` | Chiffre les strings statiques |
| **Split Basic Blocks** | `-split` | Fragmente les basic blocks |

### 2.2 Indicateurs OLLVM

```
BOGUS CONTROL FLOW (BCF):
- Opaque predicates : (x * (x + 1)) % 2 == 0
- Blocs "never taken" avec code poubelle
- Conditions toujours vraies/fausses

CONTROL FLOW FLATTENING (FLA):
- Variable "state" ou "switchVar"
- Boucle while(1) avec switch
- Dispatcher centralisÃ©

INSTRUCTION SUBSTITUTION (SUB):
- a + b â†’ a - (-b)
- a ^ b â†’ (a | b) & ~(a & b)
- OpÃ©rations inutilement complexes
```

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Mobile Security** | Apps Android/iOS protÃ©gÃ©es avec OLLVM |
| **Malware Analyst** | Samples compilÃ©s avec OLLVM |
| **Security Researcher** | Ã‰valuer la rÃ©sistance d'OLLVM |
| **CTF Player** | Challenges reverse avec OLLVM |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct OLLVMSample {
    pub functions: Vec<OLLVMFunction>,
    pub global_patterns: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OLLVMFunction {
    pub name: String,
    pub basic_blocks: usize,
    pub instructions: Vec<String>,
    pub cfg_edges: Vec<(usize, usize)>,
    pub cyclomatic_complexity: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OLLVMPass {
    pub name: String,
    pub full_name: String,
    pub confidence: f64,
    pub indicators: Vec<String>,
    pub affected_functions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeobfuscationStrategy {
    pub pass_name: String,
    pub tool_recommendations: Vec<String>,
    pub manual_steps: Vec<String>,
    pub difficulty: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OLLVMReport {
    pub detected_passes: Vec<OLLVMPass>,
    pub strategies: Vec<DeobfuscationStrategy>,
    pub obfuscation_level: String,
    pub estimated_effort: String,
}

// Opaque predicate patterns
const OPAQUE_PATTERNS: &[&str] = &[
    "* (x + 1)) % 2",
    "| (x - 1)",
    "& 0xfffffffe",
    "x ^ x",
];

// Flattening indicators
const FLATTENING_PATTERNS: &[&str] = &[
    "switch",
    "state",
    "switchVar",
    "while (1)",
    "while (true)",
    "for (;;)",
];

// Substitution patterns
const SUBSTITUTION_PATTERNS: &[(&str, &str)] = &[
    ("- (-", "ADD substitution"),
    ("| ~", "XOR substitution"),
    ("& ~(", "XOR/AND substitution"),
    ("<< 0", "NOP substitution"),
    ("+ 0", "NOP substitution"),
    ("^ 0", "NOP substitution"),
];

pub fn analyze_ollvm(sample_json: &str) -> Result<String, String> {
    let sample: OLLVMSample = serde_json::from_str(sample_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut detected_passes = Vec::new();
    let mut strategies = Vec::new();

    // Detect Bogus Control Flow
    if let Some(bcf) = detect_bcf(&sample) {
        strategies.push(bcf_strategy());
        detected_passes.push(bcf);
    }

    // Detect Control Flow Flattening
    if let Some(fla) = detect_fla(&sample) {
        strategies.push(fla_strategy());
        detected_passes.push(fla);
    }

    // Detect Instruction Substitution
    if let Some(sub) = detect_sub(&sample) {
        strategies.push(sub_strategy());
        detected_passes.push(sub);
    }

    // Detect String Encryption
    if let Some(sobf) = detect_string_enc(&sample) {
        strategies.push(sobf_strategy());
        detected_passes.push(sobf);
    }

    // Determine overall obfuscation level
    let level = if detected_passes.len() >= 3 {
        "Heavy (multiple OLLVM passes)"
    } else if detected_passes.len() >= 2 {
        "Moderate (some OLLVM passes)"
    } else if detected_passes.len() == 1 {
        "Light (single OLLVM pass)"
    } else {
        "None detected or unknown obfuscator"
    };

    // Estimate effort
    let effort = estimate_effort(&detected_passes, &sample);

    let report = OLLVMReport {
        detected_passes,
        strategies,
        obfuscation_level: level.to_string(),
        estimated_effort: effort,
    };

    serde_json::to_string_pretty(&report)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn detect_bcf(sample: &OLLVMSample) -> Option<OLLVMPass> {
    let mut indicators = Vec::new();
    let mut affected = Vec::new();

    for func in &sample.functions {
        let code = func.instructions.join(" ").to_lowercase();

        // Check for opaque predicates
        for pattern in OPAQUE_PATTERNS {
            if code.contains(pattern) {
                indicators.push(format!("Opaque predicate: {}", pattern));
            }
        }

        // High BB count with low complexity ratio = BCF
        if func.basic_blocks > 10 && func.cyclomatic_complexity < func.basic_blocks / 2 {
            indicators.push(format!(
                "Suspicious BB/complexity ratio in {}",
                func.name
            ));
            affected.push(func.name.clone());
        }

        // Look for "always true" comparisons
        if code.contains("cmp") && code.contains("0x7fffffff") {
            indicators.push("Suspicious comparison with MAX_INT".to_string());
            affected.push(func.name.clone());
        }
    }

    if !indicators.is_empty() {
        let confidence = (indicators.len() as f64 / 5.0).min(1.0);
        Some(OLLVMPass {
            name: "bcf".to_string(),
            full_name: "Bogus Control Flow".to_string(),
            confidence,
            indicators,
            affected_functions: affected,
        })
    } else {
        None
    }
}

fn detect_fla(sample: &OLLVMSample) -> Option<OLLVMPass> {
    let mut indicators = Vec::new();
    let mut affected = Vec::new();

    for func in &sample.functions {
        let code = func.instructions.join(" ").to_lowercase();

        // Check for flattening patterns
        let mut pattern_count = 0;
        for pattern in FLATTENING_PATTERNS {
            if code.contains(pattern) {
                indicators.push(format!("Pattern found: {}", pattern));
                pattern_count += 1;
            }
        }

        // Check for dispatcher-like structure (one node with many edges)
        let mut edge_counts: HashMap<usize, usize> = HashMap::new();
        for (from, _) in &func.cfg_edges {
            *edge_counts.entry(*from).or_insert(0) += 1;
        }

        let max_edges = edge_counts.values().max().unwrap_or(&0);
        if *max_edges > 5 {
            indicators.push(format!(
                "Dispatcher block with {} edges in {}",
                max_edges, func.name
            ));
            affected.push(func.name.clone());
        }

        if pattern_count >= 2 {
            affected.push(func.name.clone());
        }
    }

    if !indicators.is_empty() {
        let confidence = (indicators.len() as f64 / 4.0).min(1.0);
        Some(OLLVMPass {
            name: "fla".to_string(),
            full_name: "Control Flow Flattening".to_string(),
            confidence,
            indicators,
            affected_functions: affected,
        })
    } else {
        None
    }
}

fn detect_sub(sample: &OLLVMSample) -> Option<OLLVMPass> {
    let mut indicators = Vec::new();
    let mut affected = Vec::new();

    for func in &sample.functions {
        let code = func.instructions.join(" ").to_lowercase();

        for (pattern, description) in SUBSTITUTION_PATTERNS {
            if code.contains(pattern) {
                indicators.push(format!("{}: found '{}'", description, pattern));
                if !affected.contains(&func.name) {
                    affected.push(func.name.clone());
                }
            }
        }

        // Check for unusually long instruction sequences for simple operations
        let instruction_density = func.instructions.len() as f64 / func.basic_blocks.max(1) as f64;
        if instruction_density > 20.0 {
            indicators.push(format!(
                "High instruction density ({:.1}) in {} suggests substitution",
                instruction_density, func.name
            ));
            affected.push(func.name.clone());
        }
    }

    if !indicators.is_empty() {
        let confidence = (indicators.len() as f64 / 6.0).min(1.0);
        Some(OLLVMPass {
            name: "sub".to_string(),
            full_name: "Instruction Substitution".to_string(),
            confidence,
            indicators,
            affected_functions: affected,
        })
    } else {
        None
    }
}

fn detect_string_enc(sample: &OLLVMSample) -> Option<OLLVMPass> {
    let mut indicators = Vec::new();

    for pattern in &sample.global_patterns {
        let lower = pattern.to_lowercase();

        // Look for string decryption functions
        if lower.contains("decrypt") || lower.contains("decode") || lower.contains("deobf") {
            indicators.push(format!("String decryption pattern: {}", pattern));
        }

        // Look for XOR loops on strings
        if lower.contains("xor") && (lower.contains("string") || lower.contains("str")) {
            indicators.push("XOR operation on string data".to_string());
        }
    }

    // Check for runtime string construction
    for func in &sample.functions {
        let code = func.instructions.join(" ");
        if code.contains("mov byte ptr") && code.matches("mov byte ptr").count() > 5 {
            indicators.push(format!("Stack string construction in {}", func.name));
        }
    }

    if !indicators.is_empty() {
        Some(OLLVMPass {
            name: "sobf".to_string(),
            full_name: "String Encryption".to_string(),
            confidence: (indicators.len() as f64 / 3.0).min(1.0),
            indicators,
            affected_functions: vec![],
        })
    } else {
        None
    }
}

fn bcf_strategy() -> DeobfuscationStrategy {
    DeobfuscationStrategy {
        pass_name: "Bogus Control Flow".to_string(),
        tool_recommendations: vec![
            "D-810 (IDA plugin)".to_string(),
            "Triton symbolic execution".to_string(),
            "Miasm for pattern matching".to_string(),
        ],
        manual_steps: vec![
            "1. Identify opaque predicates by analyzing conditions".to_string(),
            "2. Determine if condition is always true/false".to_string(),
            "3. Patch conditional jumps to unconditional".to_string(),
            "4. Remove unreachable basic blocks".to_string(),
        ],
        difficulty: "Medium".to_string(),
    }
}

fn fla_strategy() -> DeobfuscationStrategy {
    DeobfuscationStrategy {
        pass_name: "Control Flow Flattening".to_string(),
        tool_recommendations: vec![
            "deflat.py (Binary Ninja)".to_string(),
            "HexRaysDeob (IDA)".to_string(),
            "Triton for state recovery".to_string(),
        ],
        manual_steps: vec![
            "1. Identify the dispatcher block and state variable".to_string(),
            "2. Trace state transitions to build original CFG".to_string(),
            "3. Remove dispatcher loop".to_string(),
            "4. Connect blocks according to recovered transitions".to_string(),
        ],
        difficulty: "Hard".to_string(),
    }
}

fn sub_strategy() -> DeobfuscationStrategy {
    DeobfuscationStrategy {
        pass_name: "Instruction Substitution".to_string(),
        tool_recommendations: vec![
            "Compiler optimization passes (-O2)".to_string(),
            "Miasm IR simplification".to_string(),
            "Custom pattern matching scripts".to_string(),
        ],
        manual_steps: vec![
            "1. Identify substitution patterns".to_string(),
            "2. Create simplification rules".to_string(),
            "3. Apply peephole optimization".to_string(),
            "4. Verify semantic equivalence".to_string(),
        ],
        difficulty: "Easy".to_string(),
    }
}

fn sobf_strategy() -> DeobfuscationStrategy {
    DeobfuscationStrategy {
        pass_name: "String Encryption".to_string(),
        tool_recommendations: vec![
            "FLOSS (FireEye)".to_string(),
            "Frida for runtime extraction".to_string(),
            "Custom IDAPython scripts".to_string(),
        ],
        manual_steps: vec![
            "1. Find string decryption function".to_string(),
            "2. Identify encryption algorithm (XOR, RC4, etc.)".to_string(),
            "3. Extract key and encrypted strings".to_string(),
            "4. Write decryption script".to_string(),
        ],
        difficulty: "Medium".to_string(),
    }
}

fn estimate_effort(passes: &[OLLVMPass], sample: &OLLVMSample) -> String {
    let mut score = 0;

    for pass in passes {
        score += match pass.name.as_str() {
            "fla" => 3,  // Hardest
            "bcf" => 2,
            "sobf" => 2,
            "sub" => 1,  // Easiest
            _ => 1,
        };
    }

    // Add complexity from function count
    let func_count = sample.functions.len();
    if func_count > 20 {
        score += 2;
    } else if func_count > 10 {
        score += 1;
    }

    match score {
        0..=2 => "Low (hours)".to_string(),
        3..=5 => "Medium (days)".to_string(),
        6..=8 => "High (week+)".to_string(),
        _ => "Very High (significant effort required)".to_string(),
    }
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
              OLLVM OBFUSCATION PIPELINE

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                  SOURCE CODE                         â”‚
    â”‚              int foo(int x) {                        â”‚
    â”‚                  return x + 1;                       â”‚
    â”‚              }                                       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                 LLVM IR (clean)                      â”‚
    â”‚  define i32 @foo(i32 %x) {                          â”‚
    â”‚    %1 = add i32 %x, 1                               â”‚
    â”‚    ret i32 %1                                       â”‚
    â”‚  }                                                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                â”‚                â”‚
            â–¼                â–¼                â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    -bcf      â”‚ â”‚    -fla      â”‚ â”‚    -sub      â”‚
    â”‚  Bogus CF    â”‚ â”‚  Flattening  â”‚ â”‚ Substitution â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                â”‚                â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              OBFUSCATED BINARY                       â”‚
    â”‚                                                      â”‚
    â”‚  foo:                                                â”‚
    â”‚    mov eax, [x*(x+1)%2]  ; opaque predicate         â”‚
    â”‚    test eax, eax                                    â”‚
    â”‚    jz .dead_code                                    â”‚
    â”‚    ...                                              â”‚
    â”‚  .dispatcher:                                       â”‚
    â”‚    switch (state) { ... }   ; flattening           â”‚
    â”‚    ...                                              â”‚
    â”‚    sub eax, -1        ; x + 1 â†’ x - (-1)           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


        FLATTENING TRANSFORMATION

    BEFORE:                      AFTER:

    â”Œâ”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  A  â”‚                     â”‚ DISPATCHER  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”
    â””â”€â”€â”¬â”€â”€â”˜                     â”‚ switch(s)   â”‚         â”‚
       â”‚                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
       â–¼                         â”Œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”          â”‚
    â”Œâ”€â”€â”€â”€â”€â”                      â–¼     â–¼     â–¼          â”‚
    â”‚  B  â”‚â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”      â”‚
    â””â”€â”€â”¬â”€â”€â”˜   â”‚              â”‚s=0:Aâ”‚â”‚s=1:Bâ”‚â”‚s=2:Câ”‚      â”‚
       â”‚      â”‚              â”‚s=1  â”‚â”‚s=2  â”‚â”‚exit â”‚      â”‚
       â–¼      â–¼              â””â”€â”€â”¬â”€â”€â”˜â””â”€â”€â”¬â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜      â”‚
    â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”              â”‚      â”‚               â”‚
    â”‚  C  â”‚â”‚  D  â”‚              â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜
```

### 5.5 Cours Complet : OLLVM

#### Qu'est-ce qu'OLLVM ?

Obfuscator-LLVM est un fork de LLVM qui ajoute des passes d'obfuscation
au compilateur. Open-source et largement utilisÃ©.

#### Les Passes en DÃ©tail

**1. Bogus Control Flow (-bcf)**

Ajoute des branches conditionnelles qui dÃ©pendent d'opaque predicates.
Ces predicates sont des expressions mathÃ©matiques dont le rÃ©sultat
est toujours dÃ©terminÃ© mais difficile Ã  analyser statiquement.

```c
// Opaque predicate : (x * (x + 1)) % 2 == 0
// Toujours VRAI car x ou x+1 est pair

if ((y * (y + 1)) % 2 == 0) {
    real_code();  // Toujours exÃ©cutÃ©
} else {
    dead_code();  // Jamais exÃ©cutÃ©
}
```

**2. Control Flow Flattening (-fla)**

Transforme le CFG en machine Ã  Ã©tats avec un dispatcher central.

**3. Instruction Substitution (-sub)**

Remplace les opÃ©rations simples par des Ã©quivalents complexes.

```
a + b  â†’  a - (-b)
a ^ b  â†’  (a | b) & ~(a & b)
a | b  â†’  (a & ~b) | b
```

---

## ğŸ“ SECTION 7 : QCM

### Q1. OLLVM est basÃ© sur...
A) GCC
B) LLVM
C) MSVC
D) Clang uniquement

**RÃ©ponse : B**

### Q2. L'opaque predicate `x * (x + 1) % 2 == 0` est...
A) Toujours faux
B) Toujours vrai
C) DÃ©pend de x
D) Parfois indÃ©terminÃ©

**RÃ©ponse : B**

### Q3. Le pass `-fla` fait...
A) Ajoute des faux blocs
B) Transforme en state machine
C) Substitue les instructions
D) Chiffre les strings

**RÃ©ponse : B**

### Q4. Pour dÃ©sobfusquer BCF, on doit...
A) Trouver le dispatcher
B) Identifier les opaque predicates
C) DÃ©crypter les strings
D) Simplifier les instructions

**RÃ©ponse : B**

### Q5. FLOSS est un outil pour...
A) Extraire les strings chiffrÃ©es
B) DÃ©flatten le CFG
C) Analyser le CFG
D) Compiler avec OLLVM

**RÃ©ponse : A**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.19-a-ollvm-analyzer",
    "metadata": {
      "exercise_id": "3.5.19-a",
      "difficulty": 9,
      "xp_base": 600
    }
  }
}
```

*Exercice 3.5.19-a â€” OLLVM Analyzer*
*"See through the obfuscation."*
*HACKBRAIN v5.5.2*
