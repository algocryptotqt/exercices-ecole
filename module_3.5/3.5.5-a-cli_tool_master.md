# Exercice 3.5.5-a : cli_tool_master

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” MaÃ®trise des Outils CLI de Reverse Engineering

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.4
- Connaissance des formats binaires (ELF, PE)
- Bases en ligne de commande Unix

**Domaines :**
CPU, ASM, FS, Encodage

**DurÃ©e estimÃ©e :**
100 min

**XP Base :**
350

**ComplexitÃ© :**
T3 O(n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`cli_tool_master.rs`

**Fonctions autorisÃ©es :**
- `serde_json` pour JSON
- `std::collections::HashMap`
- Manipulation de bytes et strings

**Fonctions interdites :**
- ExÃ©cution de commandes systÃ¨me (`std::process::Command`)
- AccÃ¨s filesystem direct

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "The Matrix" meets "Hackers"

**"I know kung fu."** â€” Dans *The Matrix*, Neo tÃ©lÃ©charge instantanÃ©ment des compÃ©tences. Dans *Hackers* (1995), les protagonistes utilisent une panoplie d'outils pour infiltrer les systÃ¨mes.

Tu es le **CLI Tool Master** â€” un virtuose de la ligne de commande. Chaque outil (objdump, readelf, nm, strings, file, xxd) est une arme dans ton arsenal. Ta mission : analyser un binaire et dÃ©terminer quelle combinaison d'outils extrairait l'information demandÃ©e.

**"Hack the planet!"** â€” Mais d'abord, maÃ®trise les outils.

**Ta mission :**

Ã‰crire une fonction `cli_tool_master` qui, Ã©tant donnÃ© une question d'analyse et des mÃ©tadonnÃ©es sur un binaire, retourne la sÃ©quence d'outils CLI optimale pour y rÃ©pondre.

**EntrÃ©e :**
- `query_json` : JSON contenant :
  - `question` : Type de question ("find_main", "list_symbols", "extract_strings", "show_sections", "detect_format", "show_dependencies", "disassemble_function", "hex_dump_section")
  - `binary_info` : Informations sur le binaire
    - `format` : "ELF" | "PE" | "Mach-O"
    - `architecture` : "x86_64" | "x86" | "arm64" | "arm"
    - `is_stripped` : Boolean
    - `is_static` : Boolean
  - `constraints` : Contraintes optionnelles
    - `prefer_minimal` : PrÃ©fÃ©rer moins d'outils
    - `need_human_readable` : Output lisible
    - `target_function` : Nom de fonction cible
    - `target_section` : Nom de section cible

**Sortie :**
- JSON contenant :
  - `tool_chain` : Liste ordonnÃ©e d'outils avec arguments
  - `explanation` : Explication de chaque Ã©tape
  - `alternative_chains` : ChaÃ®nes alternatives
  - `expected_output_format` : Format de sortie attendu
  - `complexity` : ComplexitÃ© de la chaÃ®ne
  - `warnings` : Avertissements potentiels

#### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un systÃ¨me expert qui recommande des outils CLI de reverse engineering en fonction d'une question d'analyse donnÃ©e. Le systÃ¨me doit connaÃ®tre les capacitÃ©s de chaque outil (objdump, readelf, nm, strings, file, xxd, hexdump, ldd, otool) et gÃ©nÃ©rer des pipelines optimaux.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct BinaryInfo {
    pub format: String,
    pub architecture: String,
    pub is_stripped: bool,
    pub is_static: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Constraints {
    pub prefer_minimal: Option<bool>,
    pub need_human_readable: Option<bool>,
    pub target_function: Option<String>,
    pub target_section: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Query {
    pub question: String,
    pub binary_info: BinaryInfo,
    pub constraints: Option<Constraints>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolCommand {
    pub tool: String,
    pub args: Vec<String>,
    pub purpose: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolChainResult {
    pub tool_chain: Vec<ToolCommand>,
    pub explanation: String,
    pub alternative_chains: Vec<Vec<ToolCommand>>,
    pub expected_output_format: String,
    pub complexity: String,
    pub warnings: Vec<String>,
}

pub fn cli_tool_master(query_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Ã‰cosystÃ¨me d'Outils Unix est Incroyablement Riche

| Outil | CrÃ©Ã© | Usage Principal |
|-------|------|-----------------|
| `strings` | 1979 | Extraction de chaÃ®nes ASCII |
| `file` | 1973 | DÃ©tection de type de fichier |
| `nm` | 1970s | Liste des symboles |
| `objdump` | 1990s | DÃ©sassemblage polyvalent |
| `readelf` | 1999 | Analyse ELF spÃ©cifique |

### 2.2 Les Pipelines Unix sont Puissants

```bash
# Trouver toutes les fonctions appelant "malloc"
objdump -d binary | grep -B5 "call.*malloc" | grep "^[0-9a-f]"

# Extraire les strings > 10 caractÃ¨res
strings -n 10 binary | sort -u

# Comparer deux binaires
diff <(objdump -d a.out) <(objdump -d b.out)
```

### 2.3 Chaque Outil a ses Forces

| Outil | Force | Faiblesse |
|-------|-------|-----------|
| `objdump` | Polyvalent | Verbose |
| `readelf` | DÃ©tail ELF | ELF only |
| `nm` | Rapide symboles | Basique |
| `strings` | Simple efficace | Faux positifs |
| `xxd` | Hex dump propre | Manuel |

---

## 2.5 DANS LA VRAIE VIE

| MÃ©tier | Usage des outils CLI |
|--------|---------------------|
| **Malware Analyst** | Triage rapide avec strings/file avant analyse profonde |
| **DevOps** | Diagnostic de binaires dÃ©ployÃ©s avec ldd/nm |
| **Firmware Engineer** | Extraction avec objcopy, analyse avec readelf |
| **CTF Player** | Reconnaissance rapide de challenges |
| **Security Auditor** | VÃ©rification de binaires compilÃ©s |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
cli_tool_master.rs  main.rs

$ cargo build --release

$ ./target/release/test
Test 1 (find_main ELF): objdump -d | grep main â†’ OK
Test 2 (list_symbols): nm -C â†’ OK
Test 3 (extract_strings): strings -n 8 â†’ OK
Test 4 (show_dependencies): ldd â†’ OK
Tous les tests passent!
```

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—3

**Ta mission bonus :**
GÃ©nÃ©rer des one-liners bash complets qui enchaÃ®nent les outils avec pipes, grep, awk, et sed pour rÃ©pondre Ã  des questions complexes comme "Quelles fonctions non-strippÃ©es appellent des fonctions de la libc ?".

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Question | Expected Tool | Points |
|------|----------|---------------|--------|
| `find_main` | Trouver main() | objdump -d + grep | 10 |
| `list_symbols` | Lister symboles | nm -C (ou readelf -s) | 10 |
| `extract_strings` | Extraire strings | strings -n N | 10 |
| `show_sections` | Voir sections | readelf -S (ou objdump -h) | 10 |
| `detect_format` | DÃ©tecter format | file | 10 |
| `show_deps` | DÃ©pendances | ldd (ou otool -L) | 10 |
| `disasm_func` | DÃ©sassembler func | objdump -d + grep/awk | 15 |
| `hex_section` | Hex dump section | objcopy + xxd | 15 |
| `macho_support` | Support Mach-O | otool au lieu de objdump | 10 |

### 4.2 main.rs de test

```rust
use cli_tool_master::{cli_tool_master, Query};

fn main() {
    // Test 1: Trouver main dans un ELF
    let query1 = r#"{
        "question": "find_main",
        "binary_info": {
            "format": "ELF",
            "architecture": "x86_64",
            "is_stripped": false,
            "is_static": false
        },
        "constraints": null
    }"#;

    let result1 = cli_tool_master(query1).unwrap();
    let res1: serde_json::Value = serde_json::from_str(&result1).unwrap();
    assert!(res1["tool_chain"][0]["tool"].as_str().unwrap().contains("objdump")
         || res1["tool_chain"][0]["tool"].as_str().unwrap().contains("nm"));
    println!("Test 1 (find_main ELF): PASS");

    // Test 2: Lister symboles
    let query2 = r#"{
        "question": "list_symbols",
        "binary_info": {
            "format": "ELF",
            "architecture": "x86_64",
            "is_stripped": false,
            "is_static": true
        },
        "constraints": {"need_human_readable": true}
    }"#;

    let result2 = cli_tool_master(query2).unwrap();
    let res2: serde_json::Value = serde_json::from_str(&result2).unwrap();
    let tool = res2["tool_chain"][0]["tool"].as_str().unwrap();
    assert!(tool == "nm" || tool == "readelf");
    println!("Test 2 (list_symbols): PASS");

    // Test 3: Extraire strings
    let query3 = r#"{
        "question": "extract_strings",
        "binary_info": {
            "format": "ELF",
            "architecture": "x86_64",
            "is_stripped": true,
            "is_static": false
        },
        "constraints": null
    }"#;

    let result3 = cli_tool_master(query3).unwrap();
    let res3: serde_json::Value = serde_json::from_str(&result3).unwrap();
    assert_eq!(res3["tool_chain"][0]["tool"], "strings");
    println!("Test 3 (extract_strings): PASS");

    println!("\nTous les tests passent!");
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct BinaryInfo {
    pub format: String,
    pub architecture: String,
    pub is_stripped: bool,
    pub is_static: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Constraints {
    pub prefer_minimal: Option<bool>,
    pub need_human_readable: Option<bool>,
    pub target_function: Option<String>,
    pub target_section: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Query {
    pub question: String,
    pub binary_info: BinaryInfo,
    pub constraints: Option<Constraints>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCommand {
    pub tool: String,
    pub args: Vec<String>,
    pub purpose: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolChainResult {
    pub tool_chain: Vec<ToolCommand>,
    pub explanation: String,
    pub alternative_chains: Vec<Vec<ToolCommand>>,
    pub expected_output_format: String,
    pub complexity: String,
    pub warnings: Vec<String>,
}

pub fn cli_tool_master(query_json: &str) -> Result<String, String> {
    let query: Query = serde_json::from_str(query_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut tool_chain = Vec::new();
    let mut alternatives = Vec::new();
    let mut warnings = Vec::new();
    let mut explanation_parts = Vec::new();
    let mut output_format = String::new();

    let is_macho = query.binary_info.format == "Mach-O";
    let is_pe = query.binary_info.format == "PE";
    let is_elf = query.binary_info.format == "ELF";

    // Avertissements selon le format
    if is_pe {
        warnings.push("PE format: some tools may require Windows or cross-tools".to_string());
    }

    match query.question.as_str() {
        "find_main" => {
            if query.binary_info.is_stripped {
                warnings.push("Binary is stripped: main symbol may not be found".to_string());
                // Alternative: chercher le pattern de prologue
                tool_chain.push(ToolCommand {
                    tool: "objdump".to_string(),
                    args: vec!["-d".to_string(), "binary".to_string()],
                    purpose: "Disassemble to find entry point pattern".to_string(),
                });
                explanation_parts.push("Stripped binary: searching for entry point and call patterns");
            } else {
                if is_macho {
                    tool_chain.push(ToolCommand {
                        tool: "nm".to_string(),
                        args: vec!["-U".to_string(), "binary".to_string()],
                        purpose: "List undefined symbols to find _main".to_string(),
                    });
                } else {
                    tool_chain.push(ToolCommand {
                        tool: "nm".to_string(),
                        args: vec!["binary".to_string()],
                        purpose: "Find main symbol address".to_string(),
                    });
                }
                explanation_parts.push("Using nm to locate main symbol");

                // Alternative avec objdump
                alternatives.push(vec![ToolCommand {
                    tool: "objdump".to_string(),
                    args: vec!["-d".to_string(), "-j".to_string(), ".text".to_string()],
                    purpose: "Disassemble and grep for main".to_string(),
                }]);
            }
            output_format = "address: symbol_name".to_string();
        }

        "list_symbols" => {
            let human_readable = query.constraints
                .as_ref()
                .and_then(|c| c.need_human_readable)
                .unwrap_or(false);

            if is_macho {
                tool_chain.push(ToolCommand {
                    tool: "nm".to_string(),
                    args: vec!["-m".to_string(), "binary".to_string()],
                    purpose: "List Mach-O symbols with type info".to_string(),
                });
            } else if human_readable {
                tool_chain.push(ToolCommand {
                    tool: "nm".to_string(),
                    args: vec!["-C".to_string(), "binary".to_string()],
                    purpose: "List symbols with C++ demangling".to_string(),
                });
            } else {
                tool_chain.push(ToolCommand {
                    tool: "nm".to_string(),
                    args: vec!["binary".to_string()],
                    purpose: "List all symbols".to_string(),
                });
            }

            if is_elf {
                alternatives.push(vec![ToolCommand {
                    tool: "readelf".to_string(),
                    args: vec!["-s".to_string(), "binary".to_string()],
                    purpose: "Detailed ELF symbol table".to_string(),
                }]);
            }

            explanation_parts.push("nm is fastest for symbol listing");
            output_format = "address type name".to_string();
        }

        "extract_strings" => {
            let min_len = 8; // Default minimum length

            tool_chain.push(ToolCommand {
                tool: "strings".to_string(),
                args: vec!["-n".to_string(), min_len.to_string(), "binary".to_string()],
                purpose: format!("Extract printable strings >= {} chars", min_len),
            });

            // Alternative: strings avec encoding
            alternatives.push(vec![ToolCommand {
                tool: "strings".to_string(),
                args: vec!["-e".to_string(), "l".to_string(), "-n".to_string(), "4".to_string()],
                purpose: "Extract UTF-16LE strings (Windows)".to_string(),
            }]);

            explanation_parts.push("strings extracts ASCII/Unicode sequences");
            output_format = "One string per line".to_string();
        }

        "show_sections" => {
            if is_macho {
                tool_chain.push(ToolCommand {
                    tool: "otool".to_string(),
                    args: vec!["-l".to_string(), "binary".to_string()],
                    purpose: "Show Mach-O load commands and sections".to_string(),
                });
            } else if is_elf {
                tool_chain.push(ToolCommand {
                    tool: "readelf".to_string(),
                    args: vec!["-S".to_string(), "binary".to_string()],
                    purpose: "Show ELF section headers".to_string(),
                });

                alternatives.push(vec![ToolCommand {
                    tool: "objdump".to_string(),
                    args: vec!["-h".to_string(), "binary".to_string()],
                    purpose: "Show section headers (portable)".to_string(),
                }]);
            } else {
                tool_chain.push(ToolCommand {
                    tool: "objdump".to_string(),
                    args: vec!["-h".to_string(), "binary".to_string()],
                    purpose: "Show section headers".to_string(),
                });
            }

            explanation_parts.push("Section headers reveal memory layout");
            output_format = "Name Size VMA LMA Offset".to_string();
        }

        "detect_format" => {
            tool_chain.push(ToolCommand {
                tool: "file".to_string(),
                args: vec!["binary".to_string()],
                purpose: "Detect file type and architecture".to_string(),
            });

            explanation_parts.push("file uses magic bytes for detection");
            output_format = "filename: type description".to_string();
        }

        "show_dependencies" => {
            if query.binary_info.is_static {
                warnings.push("Static binary: no dynamic dependencies".to_string());
                tool_chain.push(ToolCommand {
                    tool: "file".to_string(),
                    args: vec!["binary".to_string()],
                    purpose: "Confirm static linking".to_string(),
                });
            } else if is_macho {
                tool_chain.push(ToolCommand {
                    tool: "otool".to_string(),
                    args: vec!["-L".to_string(), "binary".to_string()],
                    purpose: "List shared libraries (Mach-O)".to_string(),
                });
            } else if is_elf {
                tool_chain.push(ToolCommand {
                    tool: "ldd".to_string(),
                    args: vec!["binary".to_string()],
                    purpose: "List dynamic dependencies".to_string(),
                });

                warnings.push("ldd executes the binary - use readelf -d for untrusted binaries".to_string());

                alternatives.push(vec![ToolCommand {
                    tool: "readelf".to_string(),
                    args: vec!["-d".to_string(), "binary".to_string()],
                    purpose: "Show dynamic section (safe)".to_string(),
                }]);
            }

            explanation_parts.push("Dependencies reveal runtime requirements");
            output_format = "library => path (address)".to_string();
        }

        "disassemble_function" => {
            let func_name = query.constraints
                .as_ref()
                .and_then(|c| c.target_function.clone())
                .unwrap_or("main".to_string());

            if is_macho {
                tool_chain.push(ToolCommand {
                    tool: "otool".to_string(),
                    args: vec!["-tV".to_string(), "binary".to_string()],
                    purpose: format!("Disassemble and find {}", func_name),
                });
            } else {
                tool_chain.push(ToolCommand {
                    tool: "objdump".to_string(),
                    args: vec![
                        "-d".to_string(),
                        "--disassemble=".to_string() + &func_name,
                        "binary".to_string()
                    ],
                    purpose: format!("Disassemble function {}", func_name),
                });
            }

            // Alternative: nm + objdump pipeline
            let alt = vec![
                ToolCommand {
                    tool: "nm".to_string(),
                    args: vec!["binary".to_string()],
                    purpose: "Find function address".to_string(),
                },
                ToolCommand {
                    tool: "objdump".to_string(),
                    args: vec!["-d".to_string(), "--start-address=ADDR".to_string()],
                    purpose: "Disassemble from address".to_string(),
                },
            ];
            alternatives.push(alt);

            explanation_parts.push(&format!("Disassembling specific function: {}", func_name));
            output_format = "address: bytes instruction".to_string();
        }

        "hex_dump_section" => {
            let section = query.constraints
                .as_ref()
                .and_then(|c| c.target_section.clone())
                .unwrap_or(".rodata".to_string());

            tool_chain.push(ToolCommand {
                tool: "objcopy".to_string(),
                args: vec![
                    "-O".to_string(), "binary".to_string(),
                    "-j".to_string(), section.clone(),
                    "binary".to_string(), "/dev/stdout".to_string()
                ],
                purpose: format!("Extract section {} as raw bytes", section),
            });
            tool_chain.push(ToolCommand {
                tool: "xxd".to_string(),
                args: vec![],
                purpose: "Convert to hex dump".to_string(),
            });

            alternatives.push(vec![ToolCommand {
                tool: "objdump".to_string(),
                args: vec!["-s".to_string(), "-j".to_string(), section.clone()],
                purpose: format!("Dump section {} contents", section),
            }]);

            explanation_parts.push(&format!("Extracting raw bytes from section {}", section));
            output_format = "offset: hex bytes ASCII".to_string();
        }

        _ => {
            return Err(format!("Unknown question type: {}", query.question));
        }
    }

    // DÃ©terminer la complexitÃ©
    let complexity = match tool_chain.len() {
        1 => "Simple (single tool)".to_string(),
        2 => "Medium (two-tool pipeline)".to_string(),
        _ => "Complex (multi-tool pipeline)".to_string(),
    };

    let result = ToolChainResult {
        tool_chain,
        explanation: explanation_parts.join(". "),
        alternative_chains: alternatives,
        expected_output_format: output_format,
        complexity,
        warnings,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

### 4.9 spec.json

```json
{
  "name": "cli_tool_master",
  "language": "rust",
  "type": "complet",
  "tier": 1,
  "tier_info": "Concept isolÃ©",
  "tags": ["cli", "tools", "reverse-engineering", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "cli_tool_master",
    "prototype": "pub fn cli_tool_master(query_json: &str) -> Result<String, String>",
    "return_type": "Result<String, String>",
    "parameters": [
      {"name": "query_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_cli_tool_master(q: &str) -> Result<String, String> { let query: Query = serde_json::from_str(q)?; let tool = match query.question.as_str() { \"find_main\" | \"list_symbols\" => \"nm\", \"extract_strings\" => \"strings\", \"show_sections\" => if query.binary_info.format == \"ELF\" { \"readelf\" } else { \"objdump\" }, \"detect_format\" => \"file\", \"show_dependencies\" => if query.binary_info.format == \"Mach-O\" { \"otool\" } else { \"ldd\" }, \"disassemble_function\" => \"objdump\", \"hex_dump_section\" => \"xxd\", _ => return Err(\"Unknown\".into()) }; Ok(format!(r#\"{{\"tool_chain\": [{{\"tool\": \"{}\"}}]}}\"#, tool)) }",

    "edge_cases": [
      {
        "name": "elf_symbols",
        "args": ["{\"question\":\"list_symbols\",\"binary_info\":{\"format\":\"ELF\",\"architecture\":\"x86_64\",\"is_stripped\":false,\"is_static\":false},\"constraints\":null}"],
        "expected_contains": "nm",
        "is_trap": false
      },
      {
        "name": "macho_deps",
        "args": ["{\"question\":\"show_dependencies\",\"binary_info\":{\"format\":\"Mach-O\",\"architecture\":\"arm64\",\"is_stripped\":false,\"is_static\":false},\"constraints\":null}"],
        "expected_contains": "otool",
        "is_trap": false
      },
      {
        "name": "stripped_warning",
        "args": ["{\"question\":\"find_main\",\"binary_info\":{\"format\":\"ELF\",\"architecture\":\"x86_64\",\"is_stripped\":true,\"is_static\":false},\"constraints\":null}"],
        "expected_contains": "warning",
        "is_trap": true,
        "trap_explanation": "Should warn about stripped binary"
      }
    ]
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A: Ignore le format Mach-O */
pub fn cli_tool_master_mutant_a(query_json: &str) -> Result<String, String> {
    // Utilise toujours ldd mÃªme pour Mach-O
    // ldd n'existe pas sur macOS
}
// Pourquoi c'est faux: ldd ne fonctionne pas sur Mach-O

/* Mutant B: Pas d'avertissement pour ldd */
pub fn cli_tool_master_mutant_b(query_json: &str) -> Result<String, String> {
    // Recommande ldd sans avertir du danger
    // ldd EXÃ‰CUTE le binaire analysÃ©!
}
// Pourquoi c'est faux: ldd exÃ©cute le binaire, dangereux pour malware

/* Mutant C: Ignore is_stripped */
pub fn cli_tool_master_mutant_c(query_json: &str) -> Result<String, String> {
    // Ne prÃ©vient pas que nm ne trouvera pas main
}
// Pourquoi c'est faux: nm ne peut pas trouver les symboles strippÃ©s

/* Mutant D: Mauvais outil pour section dump */
pub fn cli_tool_master_mutant_d(query_json: &str) -> Result<String, String> {
    // Utilise cat au lieu de objcopy+xxd
}
// Pourquoi c'est faux: cat ne peut pas extraire une section spÃ©cifique

/* Mutant E: Pas d'alternatives */
pub fn cli_tool_master_mutant_e(query_json: &str) -> Result<String, String> {
    // Ne propose jamais d'alternatives
    // L'utilisateur n'a pas de plan B
}
// Pourquoi c'est faux: Toujours proposer des alternatives
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Arsenal d'outils CLI** pour le reverse engineering
2. **Choix d'outil** selon le format binaire
3. **Pipelines Unix** pour analyses complexes
4. **DiffÃ©rences plateforme** (Linux vs macOS vs Windows)
5. **SÃ©curitÃ©** dans l'utilisation des outils

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION cli_tool_master QUI RETOURNE UN RÃ‰SULTAT CONTENANT UNE CHAÃNE OU UNE ERREUR
DÃ‰BUT FONCTION
    PARSER LA REQUÃŠTE JSON

    SELON LE TYPE DE QUESTION FAIRE
        CAS "find_main":
            SI LE BINAIRE EST STRIPPÃ‰ ALORS
                AJOUTER UN AVERTISSEMENT
                UTILISER objdump AVEC -d
            SINON
                UTILISER nm POUR TROUVER LE SYMBOLE
            FIN SI

        CAS "list_symbols":
            SI FORMAT EST MACH-O ALORS
                UTILISER nm AVEC -m
            SINON SI BESOIN LISIBLE ALORS
                UTILISER nm AVEC -C (demangle)
            SINON
                UTILISER nm SIMPLE
            FIN SI

        CAS "show_dependencies":
            SI BINAIRE EST STATIQUE ALORS
                AVERTIR "Pas de dÃ©pendances dynamiques"
            SINON SI FORMAT EST MACH-O ALORS
                UTILISER otool AVEC -L
            SINON
                UTILISER ldd (avec avertissement sÃ©curitÃ©)
            FIN SI
    FIN SELON

    RETOURNER LA CHAÃNE D'OUTILS SÃ‰RIALISÃ‰E
FIN FONCTION
```

### 5.3 Visualisation ASCII â€” Arbre de DÃ©cision des Outils

```
                    QUEL OUTIL UTILISER ?

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    QUESTION                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚               â”‚               â”‚
            â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ SYMBOLES  â”‚   â”‚  FORMAT   â”‚   â”‚  CONTENU  â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â”‚               â”‚               â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”         â”‚         â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
    â”‚           â”‚         â”‚         â”‚           â”‚
    â–¼           â–¼         â–¼         â–¼           â–¼
 â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
 â”‚ nm  â”‚    â”‚read-â”‚   â”‚file â”‚   â”‚stri-â”‚    â”‚xxd  â”‚
 â”‚     â”‚    â”‚elf  â”‚   â”‚     â”‚   â”‚ngs  â”‚    â”‚     â”‚
 â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜


         CHOIX SELON LE FORMAT BINAIRE

         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚           FORMAT DÃ‰TECTÃ‰            â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ELF  â”‚           â”‚Mach-O â”‚           â”‚  PE   â”‚
    â”‚(Linux)â”‚           â”‚(macOS)â”‚           â”‚ (Win) â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”˜           â””â”€â”€â”€â”¬â”€â”€â”€â”˜           â””â”€â”€â”€â”¬â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
    readelf             otool               dumpbin
    objdump             nm -m               objdump
    nm                  dsymutil
    ldd                 dyldinfo


         PIPELINE POUR DÃ‰SASSEMBLER UNE FONCTION

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   nm     â”‚ â”€â”€â”€â–º â”‚  grep    â”‚ â”€â”€â”€â–º â”‚ awk/cut  â”‚
    â”‚(symboles)â”‚      â”‚(filtre)  â”‚      â”‚(adresse) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  objdump -d --start-address=0x... --stop-address â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les PiÃ¨ges en DÃ©tail

#### PiÃ¨ge 1 : ldd exÃ©cute le binaire
```bash
# DANGEREUX pour malware!
ldd suspicious_binary  # â† ExÃ©cute du code!

# SAFE alternative:
readelf -d suspicious_binary | grep NEEDED
```

#### PiÃ¨ge 2 : nm ne fonctionne pas sur stripped
```bash
nm stripped_binary
# nm: stripped_binary: no symbols

# Alternative: chercher les prologues de fonctions
objdump -d stripped_binary | grep "push.*rbp"
```

#### PiÃ¨ge 3 : otool vs objdump sur macOS
```bash
# Sur macOS, objdump existe mais c'est llvm-objdump
# Syntaxe lÃ©gÃ¨rement diffÃ©rente
otool -tV binary  # â† RecommandÃ© sur macOS
```

### 5.5 Table de RÃ©fÃ©rence des Outils

| TÃ¢che | ELF (Linux) | Mach-O (macOS) | PE (Windows) |
|-------|-------------|----------------|--------------|
| Symboles | nm, readelf -s | nm -m | dumpbin /symbols |
| DÃ©sassembly | objdump -d | otool -tV | dumpbin /disasm |
| Sections | readelf -S | otool -l | dumpbin /headers |
| DÃ©pendances | ldd, readelf -d | otool -L | dumpbin /dependents |
| Strings | strings | strings | strings |
| Format | file | file | file |
| Hex dump | xxd, hexdump | xxd, hexdump | certutil -dump |

### 5.8 MnÃ©motechniques

#### ğŸ® MEME : "I have the power!" â€” He-Man et ses outils

Chaque outil est une arme dans ton arsenal :
- **nm** = L'Ã©pÃ©e (rapide, direct, pour les symboles)
- **objdump** = Le marteau (polyvalent, pour tout casser)
- **readelf** = Le scalpel (prÃ©cis, pour ELF)
- **strings** = Le filet (attrape tout ce qui est lisible)
- **file** = L'oracle (sait tout sur le format)

---

#### ğŸ¬ MEME : "You shall not pass (without ldd warning)!"

```bash
# Gandalf dit:
echo "âš ï¸ ldd EXECUTES the binary!"
echo "Use 'readelf -d' for untrusted files"
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel outil liste les symboles d'un binaire ELF ?**

A) cat
B) nm
C) ls
D) cp
E) mv
F) grep
G) sed
H) awk
I) find
J) locate

**RÃ©ponse : B**

---

### Question 2
**Pourquoi ldd est dangereux pour analyser du malware ?**

A) Il prend trop de temps
B) Il nÃ©cessite root
C) Il exÃ©cute le binaire analysÃ©
D) Il modifie le binaire
E) Il envoie des donnÃ©es rÃ©seau
F) Il corrompt la mÃ©moire
G) Il n'existe pas sur Linux
H) Il ne fonctionne pas sur ELF
I) Il supprime les symboles
J) Aucun danger

**RÃ©ponse : C**

---

### Question 3
**Sur macOS, quel outil remplace ldd pour lister les dÃ©pendances ?**

A) ldconfig
B) otool -L
C) nm -D
D) readelf -d
E) dumpbin
F) objdump -p
G) file
H) strings
I) xxd
J) dyld

**RÃ©ponse : B**

---

### Question 4
**Quel flag de nm active le demangling C++ ?**

A) -a
B) -g
C) -C
D) -D
E) -u
F) -p
G) -n
H) -r
I) -S
J) -t

**RÃ©ponse : C**

---

### Question 5
**strings -n 10 fait quoi ?**

A) Limite Ã  10 rÃ©sultats
B) Cherche dans les 10 premiers octets
C) Affiche les strings d'au moins 10 caractÃ¨res
D) Saute les 10 premiers caractÃ¨res
E) Encode en base 10
F) Affiche 10 strings par ligne
G) Limite la recherche Ã  10 secondes
H) Cherche dans la section .10
I) Convertit en dÃ©cimal
J) Groupe par 10

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Aspect | DÃ©tail |
|--------|--------|
| **Concept clÃ©** | MaÃ®trise des outils CLI de reverse engineering |
| **DifficultÃ©** | 7/10 - Connaissance multi-outils |
| **CompÃ©tences** | nm, objdump, readelf, strings, file, xxd, ldd, otool |
| **PiÃ¨ges** | ldd exÃ©cute, stripped = no symbols, format-specific |
| **Applications** | Triage, analyse rapide, pipelines automatisÃ©s |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.5.5-a-cli-tool-master",
    "generated_at": "2026-01-12 02:45:00",

    "metadata": {
      "exercise_id": "3.5.5-a",
      "exercise_name": "cli_tool_master",
      "module": "3.5",
      "module_name": "Reverse Engineering",
      "concept": "a",
      "concept_name": "Outils CLI",
      "type": "complet",
      "tier": 1,
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "duration_minutes": 100,
      "xp_base": 350,
      "domains": ["CPU", "ASM", "FS", "Encodage"],
      "tags": ["cli", "tools", "nm", "objdump", "readelf", "strings"],
      "meme_reference": "I have the power! / You shall not pass"
    }
  }
}
```

---

*Exercice 3.5.5-a â€” CLI Tool Master*
*"Know your tools, and they will serve you well."*
*HACKBRAIN v5.5.2*
