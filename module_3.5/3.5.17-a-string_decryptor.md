# Exercice 3.5.17-a : string_decryptor

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” DÃ©cryptage de ChaÃ®nes ObfusquÃ©es

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.16
- ComprÃ©hension des encodages
- Notions de cryptographie basique

**Domaines :**
Crypto, Encodage, ASM

**DurÃ©e estimÃ©e :**
120 min

**XP Base :**
500

**ComplexitÃ© :**
T4 O(n) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "The Imitation Game" meets "National Treasure"

**"Sometimes it is the people no one imagines anything of who do the things that no one can imagine."** â€” Dans *The Imitation Game*, Turing craque Enigma. Dans *National Treasure*, les indices sont cachÃ©s dans des messages cryptÃ©s.

Tu es le **String Decryptor** â€” les malwares cachent leurs strings (URLs, commandes, clÃ©s) avec du XOR, du Base64, du RC4... Ta mission : identifier l'algorithme et dÃ©crypter automatiquement.

**Ta mission :**

Ã‰crire une fonction `decrypt_strings` qui analyse des chaÃ®nes obfusquÃ©es et tente de les dÃ©crypter.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObfuscatedString {
    pub data: Vec<u8>,
    pub address: u64,
    pub context: Option<String>,  // Surrounding code hint
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecryptedString {
    pub original: Vec<u8>,
    pub decrypted: String,
    pub algorithm: String,
    pub key: Option<String>,
    pub confidence: f64,
    pub is_interesting: bool,  // URL, path, command, etc.
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DecryptionReport {
    pub strings: Vec<DecryptedString>,
    pub detected_algorithms: Vec<String>,
    pub potential_keys: Vec<String>,
    pub iocs: Vec<String>,  // Indicators of Compromise
}

pub fn decrypt_strings(input_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Techniques de Chiffrement de Strings

| Technique | ComplexitÃ© | DÃ©tection |
|-----------|------------|-----------|
| **XOR single-byte** | Facile | Frequency analysis |
| **XOR multi-byte** | Moyenne | Key length detection |
| **Base64** | Facile | Pattern `[A-Za-z0-9+/=]` |
| **ROT13/Caesar** | Facile | Frequency analysis |
| **RC4** | Moyenne | Entropy + known patterns |
| **AES** | Difficile | High entropy, key needed |
| **Stack strings** | Moyenne | mov byte ptr patterns |

### 2.2 Indicateurs de Strings IntÃ©ressantes

```
URLs:        http://, https://, ftp://
Paths:       C:\, /etc/, /tmp/
Commands:    cmd.exe, /bin/sh, powershell
Registry:    HKEY_, SOFTWARE\
IPs:         \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
Base64:      Long alphanum + padding =
```

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Malware Analyst** | Extraire C2 URLs, commandes |
| **Threat Hunter** | Identifier IOCs pour dÃ©tection |
| **Incident Responder** | Comprendre le comportement malveillant |
| **AV Engineer** | CrÃ©er signatures YARA |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObfuscatedString {
    pub data: Vec<u8>,
    pub address: u64,
    pub context: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecryptedString {
    pub original: Vec<u8>,
    pub decrypted: String,
    pub algorithm: String,
    pub key: Option<String>,
    pub confidence: f64,
    pub is_interesting: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DecryptionReport {
    pub strings: Vec<DecryptedString>,
    pub detected_algorithms: Vec<String>,
    pub potential_keys: Vec<String>,
    pub iocs: Vec<String>,
}

const INTERESTING_PATTERNS: &[&str] = &[
    "http://", "https://", "ftp://",
    ".exe", ".dll", ".bat", ".ps1",
    "cmd", "powershell", "/bin/",
    "HKEY_", "SOFTWARE\\",
    "password", "token", "api_key",
];

pub fn decrypt_strings(input_json: &str) -> Result<String, String> {
    let strings: Vec<ObfuscatedString> = serde_json::from_str(input_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut decrypted_strings = Vec::new();
    let mut algorithms = Vec::new();
    let mut keys = Vec::new();
    let mut iocs = Vec::new();

    for obs in &strings {
        // Try different decryption methods
        let mut best_result: Option<DecryptedString> = None;
        let mut best_confidence = 0.0f64;

        // Try Base64
        if let Some(result) = try_base64(&obs.data) {
            if result.confidence > best_confidence {
                best_confidence = result.confidence;
                best_result = Some(result);
            }
        }

        // Try single-byte XOR
        if let Some(result) = try_xor_single(&obs.data) {
            if result.confidence > best_confidence {
                best_confidence = result.confidence;
                best_result = Some(result);
            }
        }

        // Try ROT13
        if let Some(result) = try_rot13(&obs.data) {
            if result.confidence > best_confidence {
                best_confidence = result.confidence;
                best_result = Some(result);
            }
        }

        // Try multi-byte XOR with common key lengths
        for key_len in &[2, 4, 8, 16] {
            if let Some(result) = try_xor_multi(&obs.data, *key_len) {
                if result.confidence > best_confidence {
                    best_confidence = result.confidence;
                    best_result = Some(result);
                }
            }
        }

        if let Some(mut result) = best_result {
            result.original = obs.data.clone();
            result.is_interesting = is_interesting(&result.decrypted);

            if result.is_interesting {
                iocs.push(result.decrypted.clone());
            }

            if !algorithms.contains(&result.algorithm) {
                algorithms.push(result.algorithm.clone());
            }

            if let Some(ref key) = result.key {
                if !keys.contains(key) {
                    keys.push(key.clone());
                }
            }

            decrypted_strings.push(result);
        } else {
            // Could not decrypt - add as unknown
            decrypted_strings.push(DecryptedString {
                original: obs.data.clone(),
                decrypted: String::from_utf8_lossy(&obs.data).to_string(),
                algorithm: "unknown".to_string(),
                key: None,
                confidence: 0.0,
                is_interesting: false,
            });
        }
    }

    let report = DecryptionReport {
        strings: decrypted_strings,
        detected_algorithms: algorithms,
        potential_keys: keys,
        iocs,
    };

    serde_json::to_string_pretty(&report)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn try_base64(data: &[u8]) -> Option<DecryptedString> {
    let s = String::from_utf8_lossy(data);

    // Check if it looks like base64
    let b64_chars: Vec<char> = s.chars().filter(|c| {
        c.is_alphanumeric() || *c == '+' || *c == '/' || *c == '='
    }).collect();

    if b64_chars.len() < s.len() * 9 / 10 {
        return None;  // Too many non-base64 chars
    }

    // Try to decode
    use base64::{Engine as _, engine::general_purpose::STANDARD};
    match STANDARD.decode(s.trim()) {
        Ok(decoded) => {
            if let Ok(text) = String::from_utf8(decoded.clone()) {
                if is_printable(&text) {
                    return Some(DecryptedString {
                        original: vec![],
                        decrypted: text,
                        algorithm: "base64".to_string(),
                        key: None,
                        confidence: 0.9,
                        is_interesting: false,
                    });
                }
            }
        }
        Err(_) => {}
    }
    None
}

fn try_xor_single(data: &[u8]) -> Option<DecryptedString> {
    // Try all single-byte XOR keys
    let mut best_key = 0u8;
    let mut best_score = 0.0f64;
    let mut best_result = String::new();

    for key in 1..=255u8 {
        let decrypted: Vec<u8> = data.iter().map(|b| b ^ key).collect();

        if let Ok(text) = String::from_utf8(decrypted.clone()) {
            let score = score_english(&text);
            if score > best_score {
                best_score = score;
                best_key = key;
                best_result = text;
            }
        }
    }

    if best_score > 0.5 && is_printable(&best_result) {
        Some(DecryptedString {
            original: vec![],
            decrypted: best_result,
            algorithm: "xor_single".to_string(),
            key: Some(format!("0x{:02X}", best_key)),
            confidence: best_score,
            is_interesting: false,
        })
    } else {
        None
    }
}

fn try_xor_multi(data: &[u8], key_len: usize) -> Option<DecryptedString> {
    if data.len() < key_len * 2 {
        return None;
    }

    // Guess key by frequency analysis on each position
    let mut key = vec![0u8; key_len];

    for i in 0..key_len {
        let mut best_byte = 0u8;
        let mut best_score = 0.0f64;

        for k in 1..=255u8 {
            let decrypted: Vec<u8> = data.iter()
                .skip(i)
                .step_by(key_len)
                .map(|b| b ^ k)
                .collect();

            let score = decrypted.iter()
                .filter(|&&c| c >= 32 && c < 127)
                .count() as f64 / decrypted.len() as f64;

            if score > best_score {
                best_score = score;
                best_byte = k;
            }
        }
        key[i] = best_byte;
    }

    // Decrypt with guessed key
    let decrypted: Vec<u8> = data.iter()
        .enumerate()
        .map(|(i, b)| b ^ key[i % key_len])
        .collect();

    if let Ok(text) = String::from_utf8(decrypted) {
        if is_printable(&text) {
            let key_hex: Vec<String> = key.iter()
                .map(|b| format!("{:02X}", b))
                .collect();

            return Some(DecryptedString {
                original: vec![],
                decrypted: text,
                algorithm: format!("xor_multi_{}", key_len),
                key: Some(key_hex.join("")),
                confidence: 0.7,
                is_interesting: false,
            });
        }
    }
    None
}

fn try_rot13(data: &[u8]) -> Option<DecryptedString> {
    let decoded: String = data.iter().map(|&c| {
        match c {
            b'A'..=b'M' | b'a'..=b'm' => c + 13,
            b'N'..=b'Z' | b'n'..=b'z' => c - 13,
            _ => c,
        }
    }).map(|c| c as char).collect();

    let score = score_english(&decoded);
    if score > 0.6 {
        Some(DecryptedString {
            original: vec![],
            decrypted: decoded,
            algorithm: "rot13".to_string(),
            key: None,
            confidence: score,
            is_interesting: false,
        })
    } else {
        None
    }
}

fn score_english(text: &str) -> f64 {
    // Simple scoring based on letter frequency and common patterns
    let common = "etaoinshrdlu ";
    let score: f64 = text.to_lowercase().chars()
        .filter(|c| common.contains(*c))
        .count() as f64 / text.len().max(1) as f64;

    // Bonus for printable ASCII
    let printable: f64 = text.chars()
        .filter(|c| *c >= ' ' && *c <= '~')
        .count() as f64 / text.len().max(1) as f64;

    (score + printable) / 2.0
}

fn is_printable(text: &str) -> bool {
    let printable_count = text.chars()
        .filter(|c| *c >= ' ' && *c <= '~' || *c == '\n' || *c == '\r' || *c == '\t')
        .count();

    printable_count as f64 / text.len().max(1) as f64 > 0.8
}

fn is_interesting(text: &str) -> bool {
    let lower = text.to_lowercase();
    INTERESTING_PATTERNS.iter().any(|p| lower.contains(p))
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
        STRING DECRYPTION PIPELINE

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                 OBFUSCATED STRING                   â”‚
    â”‚        [0x48, 0x15, 0x1D, 0x1D, 0x1E, ...]         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚               â”‚               â”‚
            â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Try Base64   â”‚ â”‚  Try XOR      â”‚ â”‚  Try ROT13    â”‚
    â”‚  Decode       â”‚ â”‚  (1-byte key) â”‚ â”‚  Shift        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚               â”‚               â”‚
            â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Score: 0.3   â”‚ â”‚  Score: 0.85  â”‚ â”‚  Score: 0.2   â”‚
    â”‚  âœ— Rejected   â”‚ â”‚  âœ“ Best!      â”‚ â”‚  âœ— Rejected   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Key: 0x5D       â”‚
                    â”‚ "http://evil..."â”‚
                    â”‚ Is IOC: YES     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


        XOR SINGLE BYTE EXAMPLE

        Original:    H    e    l    l    o
        Hex:        48   65   6C   6C   6F
        XOR 0x5D:   15   38   31   31   32

        Encrypted: [0x15, 0x38, 0x31, 0x31, 0x32]

        To decrypt: each_byte XOR 0x5D = original
```

### 5.5 Cours Complet : DÃ©cryptage de Strings

#### Pourquoi les malwares chiffrent leurs strings ?

1. **Ã‰viter la dÃ©tection** : Les antivirus cherchent des strings connus
2. **Compliquer l'analyse** : Pas de `strings` facile
3. **Cacher les IOCs** : URLs C2, commandes, chemins

#### XOR - Le Roi de l'Obfuscation Simple

```
XOR Properties:
- A ^ B = C
- C ^ B = A  (dÃ©chiffrement)
- A ^ A = 0
- A ^ 0 = A

Single-byte XOR:
for i in range(len(data)):
    decrypted[i] = data[i] ^ key

Multi-byte XOR:
for i in range(len(data)):
    decrypted[i] = data[i] ^ key[i % len(key)]
```

#### Techniques de DÃ©tection de ClÃ©

**Frequency Analysis (pour XOR single-byte):**
- En anglais, 'e' est la lettre la plus frÃ©quente
- Le byte le plus frÃ©quent XOR 'e' donne probablement la clÃ©

**Kasiski Examination (pour XOR multi-byte):**
- Cherche des sÃ©quences rÃ©pÃ©tÃ©es
- La distance entre rÃ©pÃ©titions est multiple de la longueur de clÃ©

---

## ğŸ“ SECTION 7 : QCM

### Q1. XOR est rÃ©versible car...
A) A ^ B ^ B = A
B) A ^ B = B ^ A
C) A ^ 0 = A
D) A ^ A = 0

**RÃ©ponse : A**

### Q2. Pour casser un XOR single-byte, on utilise...
A) Brute force (256 clÃ©s possibles)
B) L'analyse de frÃ©quence
C) Les deux
D) Aucun des deux

**RÃ©ponse : C**

### Q3. Base64 est reconnaissable par...
A) Son entropie Ã©levÃ©e
B) Ses caractÃ¨res [A-Za-z0-9+/=]
C) Sa longueur toujours paire
D) Ses null bytes

**RÃ©ponse : B**

### Q4. Une string "intÃ©ressante" en malware analysis contient souvent...
A) Des commentaires
B) Des URLs ou chemins
C) Des emojis
D) Du code source

**RÃ©ponse : B**

### Q5. ROT13 est...
A) Un chiffrement fort
B) Un XOR avec clÃ© 13
C) Une substitution de 13 positions
D) Un encodage base13

**RÃ©ponse : C**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.17-a-string-decryptor",
    "metadata": {
      "exercise_id": "3.5.17-a",
      "difficulty": 8,
      "xp_base": 500
    }
  }
}
```

*Exercice 3.5.17-a â€” String Decryptor*
*"Break the code, reveal the secrets."*
*HACKBRAIN v5.5.2*
