# Exercice 3.5.11-a : universal_emulator

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” Ã‰mulation de Code avec Unicorn/QEMU

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.10
- ComprÃ©hension des architectures CPU
- Notions d'Ã©mulation

**Domaines :**
CPU, ASM, Mem, Encodage

**DurÃ©e estimÃ©e :**
180 min

**XP Base :**
600

**ComplexitÃ© :**
T5 O(n) Ã— S4 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Ready Player One" meets "TRON"

**"Welcome to the OASIS."** â€” Dans *Ready Player One*, les joueurs entrent dans un monde virtuel. Dans *TRON*, les programmes vivent dans un espace simulÃ©.

Tu es le **Universal Emulator** â€” tu peux exÃ©cuter du code de n'importe quelle architecture dans un environnement contrÃ´lÃ©. x86, ARM, MIPS â€” tout peut tourner dans ton Ã©mulateur. Le code ne sait mÃªme pas qu'il n'est pas sur du vrai hardware.

**Ta mission :**

Ã‰crire une fonction `code_emulator` qui configure et exÃ©cute du code machine dans un Ã©mulateur, puis rapporte l'Ã©tat final.

**EntrÃ©e :**
- `emulation_json` : JSON contenant :
  - `architecture` : "x86", "x86_64", "arm", "arm64", "mips"
  - `code` : Code machine en hexadÃ©cimal
  - `initial_registers` : Ã‰tat initial des registres
  - `memory_map` : RÃ©gions mÃ©moire Ã  mapper
  - `hooks` : Points d'arrÃªt/hooks optionnels

**Sortie :**
- JSON contenant :
  - `final_registers` : Ã‰tat final des registres
  - `memory_changes` : Modifications mÃ©moire
  - `instructions_executed` : Nombre d'instructions
  - `execution_trace` : Trace d'exÃ©cution si demandÃ©e
  - `exit_reason` : Raison de fin d'Ã©mulation

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryRegion {
    pub address: u64,
    pub size: u64,
    pub permissions: String,  // "rwx", "r-x", etc.
    pub data: Option<String>, // hex data
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EmulationInput {
    pub architecture: String,
    pub code: String,
    pub initial_registers: HashMap<String, u64>,
    pub memory_map: Vec<MemoryRegion>,
    pub max_instructions: Option<u64>,
    pub trace_enabled: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EmulationResult {
    pub final_registers: HashMap<String, u64>,
    pub memory_changes: Vec<(u64, String)>,
    pub instructions_executed: u64,
    pub execution_trace: Vec<String>,
    pub exit_reason: String,
}

pub fn code_emulator(emulation_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Frameworks d'Ã‰mulation

| Framework | Usage | Langages |
|-----------|-------|----------|
| **Unicorn** | Ã‰mulation lÃ©gÃ¨re multi-arch | Python, Rust, C |
| **QEMU** | Ã‰mulation complÃ¨te systÃ¨me | C |
| **Qiling** | Ã‰mulation + syscalls | Python |
| **Capstone** | DÃ©sassemblage (companion) | Multiple |
| **Keystone** | Assemblage (companion) | Multiple |

### 2.2 Cas d'Usage

- **Malware analysis** : ExÃ©cuter du code suspect en sandbox
- **Unpacking** : Laisser le packer se dÃ©crypter
- **Fuzzing** : Tester des inputs sans crash rÃ©el
- **CTF** : RÃ©soudre des challenges sans le bon CPU

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryRegion {
    pub address: u64,
    pub size: u64,
    pub permissions: String,
    pub data: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EmulationInput {
    pub architecture: String,
    pub code: String,
    pub initial_registers: HashMap<String, u64>,
    pub memory_map: Vec<MemoryRegion>,
    pub max_instructions: Option<u64>,
    pub trace_enabled: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EmulationResult {
    pub final_registers: HashMap<String, u64>,
    pub memory_changes: Vec<(u64, String)>,
    pub instructions_executed: u64,
    pub execution_trace: Vec<String>,
    pub exit_reason: String,
}

// Simplified x86 emulator (educational)
fn emulate_x86(input: &EmulationInput) -> EmulationResult {
    let mut registers = input.initial_registers.clone();
    let mut memory: HashMap<u64, u8> = HashMap::new();
    let mut trace = Vec::new();
    let mut changes = Vec::new();

    // Initialize memory from regions
    for region in &input.memory_map {
        if let Some(data) = &region.data {
            let bytes = hex_to_bytes(data);
            for (i, byte) in bytes.iter().enumerate() {
                memory.insert(region.address + i as u64, *byte);
            }
        }
    }

    // Load code at standard address
    let code_bytes = hex_to_bytes(&input.code);
    let code_base = 0x1000u64;
    for (i, byte) in code_bytes.iter().enumerate() {
        memory.insert(code_base + i as u64, *byte);
    }

    // Set instruction pointer
    registers.insert("rip".to_string(), code_base);
    if !registers.contains_key("rsp") {
        registers.insert("rsp".to_string(), 0x7fff0000);
    }

    let max_instr = input.max_instructions.unwrap_or(1000);
    let mut executed = 0u64;
    let code_len = code_bytes.len() as u64;

    while executed < max_instr {
        let rip = *registers.get("rip").unwrap_or(&code_base);

        if rip < code_base || rip >= code_base + code_len {
            break;
        }

        let offset = (rip - code_base) as usize;
        if offset >= code_bytes.len() {
            break;
        }

        let opcode = code_bytes[offset];

        // Simplified instruction decoding
        match opcode {
            0x90 => {
                // NOP
                if input.trace_enabled {
                    trace.push(format!("{:#x}: nop", rip));
                }
                registers.insert("rip".to_string(), rip + 1);
            }
            0x55 => {
                // push rbp
                let rsp = registers.get("rsp").unwrap_or(&0x7fff0000) - 8;
                let rbp = *registers.get("rbp").unwrap_or(&0);
                registers.insert("rsp".to_string(), rsp);
                // Store rbp at [rsp]
                for i in 0..8 {
                    memory.insert(rsp + i, ((rbp >> (i * 8)) & 0xff) as u8);
                }
                if input.trace_enabled {
                    trace.push(format!("{:#x}: push rbp", rip));
                }
                registers.insert("rip".to_string(), rip + 1);
            }
            0xc3 => {
                // ret
                if input.trace_enabled {
                    trace.push(format!("{:#x}: ret", rip));
                }
                // Pop return address
                let rsp = *registers.get("rsp").unwrap_or(&0x7fff0000);
                let mut ret_addr = 0u64;
                for i in 0..8 {
                    ret_addr |= (*memory.get(&(rsp + i)).unwrap_or(&0) as u64) << (i * 8);
                }
                registers.insert("rsp".to_string(), rsp + 8);
                registers.insert("rip".to_string(), ret_addr);

                if ret_addr == 0 || ret_addr < code_base || ret_addr > code_base + code_len {
                    executed += 1;
                    break;
                }
            }
            0x48 if offset + 2 < code_bytes.len() => {
                // REX.W prefix - 64-bit operation
                let next = code_bytes[offset + 1];
                match next {
                    0x89 => {
                        // mov r/m64, r64
                        if input.trace_enabled {
                            trace.push(format!("{:#x}: mov (64-bit)", rip));
                        }
                        registers.insert("rip".to_string(), rip + 3);
                    }
                    0x8b => {
                        // mov r64, r/m64
                        if input.trace_enabled {
                            trace.push(format!("{:#x}: mov (64-bit load)", rip));
                        }
                        registers.insert("rip".to_string(), rip + 3);
                    }
                    _ => {
                        registers.insert("rip".to_string(), rip + 2);
                    }
                }
            }
            _ => {
                // Unknown opcode - skip
                if input.trace_enabled {
                    trace.push(format!("{:#x}: unknown opcode {:#x}", rip, opcode));
                }
                registers.insert("rip".to_string(), rip + 1);
            }
        }

        executed += 1;
    }

    let exit_reason = if executed >= max_instr {
        "max_instructions_reached".to_string()
    } else {
        "normal_exit".to_string()
    };

    EmulationResult {
        final_registers: registers,
        memory_changes: changes,
        instructions_executed: executed,
        execution_trace: trace,
        exit_reason,
    }
}

fn hex_to_bytes(hex: &str) -> Vec<u8> {
    (0..hex.len())
        .step_by(2)
        .filter_map(|i| u8::from_str_radix(&hex[i..i.min(hex.len()).max(i+2)], 16).ok())
        .collect()
}

pub fn code_emulator(emulation_json: &str) -> Result<String, String> {
    let input: EmulationInput = serde_json::from_str(emulation_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let result = match input.architecture.as_str() {
        "x86_64" | "x86" => emulate_x86(&input),
        _ => return Err(format!("Unsupported architecture: {}", input.architecture)),
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
           Ã‰MULATION AVEC UNICORN

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           VOTRE PROGRAMME                   â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚   Python/Rust/C avec Unicorn API    â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ API calls
                           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           UNICORN ENGINE                    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚          CPU Emulator               â”‚   â”‚
    â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
    â”‚  â”‚   â”‚  x86  â”‚  â”‚  ARM  â”‚  â”‚ MIPS  â”‚  â”‚   â”‚
    â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚         Virtual Memory              â”‚   â”‚
    â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”       â”‚   â”‚
    â”‚  â”‚   â”‚ Code â”‚ â”‚ Data â”‚ â”‚Stack â”‚       â”‚   â”‚
    â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜       â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.11-a-universal-emulator",
    "metadata": {
      "exercise_id": "3.5.11-a",
      "difficulty": 9,
      "xp_base": 600
    }
  }
}
```

---

*Exercice 3.5.11-a â€” Universal Emulator*
*"Execute anything, anywhere."*
*HACKBRAIN v5.5.2*
