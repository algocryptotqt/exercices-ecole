# Exercice 3.5.12-a : intel_pin_instrumenter

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî Instrumentation Binaire avec Intel PIN

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024 + C++ (PIN)

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.11
- C++ de base
- Compr√©hension du DBI (Dynamic Binary Instrumentation)

**Domaines :**
CPU, ASM, Process, Mem

**Dur√©e estim√©e :**
180 min

**XP Base :**
600

**Complexit√© :**
T5 O(n) √ó S4 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "Westworld" meets "The Adjustment Bureau"

**"These violent delights have violent ends."** ‚Äî Dans *Westworld*, chaque action des Hosts est logu√©e et analysable. Dans *The Adjustment Bureau*, des agents ajustent subtilement le destin des gens.

Tu es l'**Intel PIN Instrumenter** ‚Äî tu ins√®res du code d'instrumentation dans un programme en cours d'ex√©cution, sans le modifier sur disque. Chaque instruction peut √™tre intercept√©e, analys√©e, modifi√©e.

**Ta mission :**

√âcrire une fonction `pin_trace_analyzer` qui analyse les traces produites par des PINtools et g√©n√®re des rapports d'ex√©cution.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct PinTraceInput {
    pub trace_log: String,
    pub tool_type: String, // "inscount", "memtrace", "calltrace"
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PinAnalysis {
    pub instruction_count: u64,
    pub basic_block_count: u64,
    pub memory_accesses: HashMap<String, u64>, // read/write counts
    pub call_graph: Vec<(String, String)>,
    pub hot_spots: Vec<(String, u64)>,
}

pub fn pin_trace_analyzer(trace_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Intel PIN

| Feature | Description |
|---------|-------------|
| **JIT Compilation** | Recompile le code √† la vol√©e |
| **Granularit√©** | Instruction, BBL, Routine, Image |
| **Callbacks** | IPOINT_BEFORE, IPOINT_AFTER |
| **Platforms** | x86, x86_64 (Windows, Linux, macOS) |

### 2.2 PINtools Classiques

- **inscount** : Compte les instructions
- **memtrace** : Trace les acc√®s m√©moire
- **calltrace** : Trace les appels de fonctions
- **malloctrace** : Trace malloc/free
- **strace** : √âmule strace avec PIN

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct PinTraceInput {
    pub trace_log: String,
    pub tool_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PinAnalysis {
    pub instruction_count: u64,
    pub basic_block_count: u64,
    pub memory_accesses: HashMap<String, u64>,
    pub call_graph: Vec<(String, String)>,
    pub hot_spots: Vec<(String, u64)>,
}

pub fn pin_trace_analyzer(trace_json: &str) -> Result<String, String> {
    let input: PinTraceInput = serde_json::from_str(trace_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut instruction_count = 0u64;
    let mut basic_block_count = 0u64;
    let mut memory_accesses: HashMap<String, u64> = HashMap::new();
    let mut call_graph = Vec::new();
    let mut address_counts: HashMap<String, u64> = HashMap::new();

    memory_accesses.insert("read".to_string(), 0);
    memory_accesses.insert("write".to_string(), 0);

    for line in input.trace_log.lines() {
        let line = line.trim();

        match input.tool_type.as_str() {
            "inscount" => {
                // Format: "Count: 12345" or instruction addresses
                if line.starts_with("Count:") {
                    if let Some(count) = line.split(':').nth(1) {
                        instruction_count = count.trim().parse().unwrap_or(0);
                    }
                } else if line.starts_with("0x") {
                    instruction_count += 1;
                    *address_counts.entry(line.to_string()).or_insert(0) += 1;
                }
            }
            "memtrace" => {
                // Format: "R 0x7fff1234" or "W 0x7fff5678"
                if line.starts_with("R ") {
                    *memory_accesses.get_mut("read").unwrap() += 1;
                } else if line.starts_with("W ") {
                    *memory_accesses.get_mut("write").unwrap() += 1;
                }
            }
            "calltrace" => {
                // Format: "caller -> callee" or "CALL: func_name"
                if line.contains("->") {
                    let parts: Vec<&str> = line.split("->").collect();
                    if parts.len() == 2 {
                        call_graph.push((
                            parts[0].trim().to_string(),
                            parts[1].trim().to_string()
                        ));
                    }
                }
                if line.starts_with("BBL:") {
                    basic_block_count += 1;
                }
            }
            _ => {}
        }
    }

    // Generate hot spots (most executed addresses)
    let mut hot_spots: Vec<(String, u64)> = address_counts.into_iter().collect();
    hot_spots.sort_by(|a, b| b.1.cmp(&a.1));
    hot_spots.truncate(10);

    let result = PinAnalysis {
        instruction_count,
        basic_block_count,
        memory_accesses,
        call_graph,
        hot_spots,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.12-a-intel-pin",
    "metadata": {"exercise_id": "3.5.12-a", "difficulty": 9, "xp_base": 600}
  }
}
```

*Exercice 3.5.12-a ‚Äî Intel PIN Instrumenter*
*"See every instruction."*
*HACKBRAIN v5.5.2*
