# Exercice 3.5.3-a : symbol_resurrector

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” Symboles de Debug et Reconstruction

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercice 3.5.1-a (binary_anatomist)
- Exercice 3.5.2-a (linkage_detector)
- ComprÃ©hension des conventions d'appel x86/x86_64
- Notions de C++ name mangling

**Domaines :**
CPU, ASM, Encodage, Struct

**DurÃ©e estimÃ©e :**
120 min

**XP Base :**
400

**ComplexitÃ© :**
T4 O(n) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`symbol_resurrector.rs`

**Fonctions autorisÃ©es :**
- `serde_json` pour parsing/serialization JSON
- `std::collections::{HashMap, HashSet, BTreeMap, BTreeSet}`
- Manipulation de bytes (`&[u8]`, slices)
- Expressions rÃ©guliÃ¨res basiques (via pattern matching manuel)

**Fonctions interdites :**
- BibliothÃ¨ques de dÃ©mangling externes (cpp_demangle, rustc-demangle)
- BibliothÃ¨ques de disassemblage (capstone, iced-x86)
- AccÃ¨s filesystem direct

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Blade Runner" meets "Westworld"

**"I've seen things you people wouldn't believe... Attack ships on fire off the shoulder of Orion."** â€” Dans *Blade Runner*, le Replicant Roy Batty possÃ¨de des souvenirs implantÃ©s, des identitÃ©s reconstruites Ã  partir de fragments. Dans *Westworld*, les Hosts dÃ©couvrent progressivement qui ils sont vraiment en analysant leur propre code.

Tu es le **Symbol Resurrector** â€” un archÃ©ologue numÃ©rique. Un binaire stripped est comme un Host dont la mÃ©moire a Ã©tÃ© effacÃ©e : les fonctions existent, mais leurs noms ont Ã©tÃ© perdus. Ta mission : leur rendre leur identitÃ©.

**"These violent delights have violent ends."** â€” Mais pas pour toi. Tu vas faire revivre ce qui Ã©tait mort, reconstruire ce qui a Ã©tÃ© dÃ©truit.

**Ta mission :**

Ã‰crire une fonction `symbol_resurrector` qui analyse un binaire stripped et reconstruit une table de symboles partielle.

**EntrÃ©e :**
- `input_json` : Configuration contenant :
  - `binary_data` : Les donnÃ©es binaires (hexadÃ©cimal)
  - `text_section_offset` : Offset de la section .text
  - `text_section_size` : Taille de la section .text
  - `architecture` : "x86_64" | "x86" | "arm64" | "arm"
  - `mangled_hints` : Liste optionnelle de symboles manglÃ©s trouvÃ©s ailleurs

**Sortie :**
- JSON contenant :
  - `functions` : Liste des fonctions dÃ©tectÃ©es
    - `address` : Adresse de dÃ©but
    - `size` : Taille estimÃ©e
    - `calling_convention` : Convention d'appel dÃ©tectÃ©e
    - `demangled` : Nom dÃ©manglÃ© si applicable
    - `suggested_name` : Nom suggÃ©rÃ© basÃ© sur l'analyse
    - `confidence` : Score de confiance (0.0-1.0)
    - `prologue_type` : Type de prologue dÃ©tectÃ©
  - `total_functions_found` : Nombre total de fonctions
  - `coverage` : Pourcentage de .text couvert
  - `warnings` : Avertissements sur l'analyse

**Contraintes :**
- DÃ©tecter les prologues de fonctions (push rbp; mov rbp, rsp; etc.)
- Identifier les Ã©pilogues (leave; ret; pop rbp; ret; etc.)
- DÃ©mangler les symboles C++ au format Itanium (_ZN...)
- ReconnaÃ®tre les patterns de fonctions connues (main, __libc_start_main, etc.)
- Estimer la taille des fonctions

**Patterns de reconnaissance :**

| Pattern (x86_64) | Signification |
|------------------|---------------|
| `55 48 89 e5` | push rbp; mov rbp, rsp (frame setup) |
| `48 83 ec XX` | sub rsp, XX (stack alloc) |
| `c9` ou `5d` | leave ou pop rbp |
| `c3` | ret |
| `48 8d 3d XX XX XX XX` | lea rdi, [rip+X] (string ref, souvent avant call) |

#### 1.2.2 Version AcadÃ©mique

Cette fonction implÃ©mente un analyseur de code machine qui :

1. **DÃ©tection de fonctions** : Identifie les frontiÃ¨res de fonctions via les patterns de prologue/Ã©pilogue
2. **Analyse des conventions d'appel** : DÃ©termine si la fonction suit System V AMD64, cdecl, stdcall, etc.
3. **DÃ©mangling C++** : DÃ©code les noms de symboles au format Itanium
4. **Heuristiques de nommage** : SuggÃ¨re des noms basÃ©s sur le comportement observÃ©

### 1.3 Prototype

```rust
pub fn symbol_resurrector(input_json: &str) -> String
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Pourquoi les symboles sont strippÃ©s ?

1. **Taille** : Les symboles peuvent reprÃ©senter 10-30% d'un binaire
2. **Protection IP** : Cacher les noms de fonctions internes
3. **Anti-reverse** : Rendre l'analyse plus difficile
4. **Production** : Convention pour les builds release

### 2.2 Le Name Mangling C++

C++ permet la surcharge de fonctions (mÃªme nom, paramÃ¨tres diffÃ©rents). Le compilateur gÃ©nÃ¨re des noms uniques :

```cpp
// Source C++
namespace MyLib {
    class Widget {
        void process(int x);
        void process(std::string s);
    };
}

// AprÃ¨s mangling (Itanium ABI)
_ZN5MyLib6Widget7processEi      // process(int)
_ZN5MyLib6Widget7processESs     // process(std::string)
```

**DÃ©codage :**
```
_ZN5MyLib6Widget7processEi
  â”‚  â”‚    â”‚      â”‚       â”‚
  â”‚  â”‚    â”‚      â”‚       â””â”€ Type: i = int
  â”‚  â”‚    â”‚      â””â”€ 7 chars: "process"
  â”‚  â”‚    â””â”€ 6 chars: "Widget"
  â”‚  â””â”€ 5 chars: "MyLib"
  â””â”€ _ZN = dÃ©but de nested name
```

### 2.3 Les Conventions d'Appel

| Convention | Arguments | Caller cleanup | UtilisÃ© par |
|------------|-----------|----------------|-------------|
| **System V AMD64** | RDI, RSI, RDX, RCX, R8, R9 | Oui | Linux 64-bit |
| **Microsoft x64** | RCX, RDX, R8, R9 | Oui | Windows 64-bit |
| **cdecl** | Stack (right to left) | Oui | C 32-bit |
| **stdcall** | Stack | Non | WinAPI 32-bit |
| **fastcall** | ECX, EDX, stack | Non | OptimisÃ© 32-bit |

### 2.4 DANS LA VRAIE VIE

| MÃ©tier | Utilisation | Cas d'Usage |
|--------|-------------|-------------|
| **Malware Analyst** | Quotidien | Identifier les fonctions malveillantes |
| **Vulnerability Researcher** | FrÃ©quent | Trouver les fonctions vulnÃ©rables |
| **Game Modder** | Hobby | Identifier les fonctions Ã  hooker |
| **Reverse Engineer** | Quotidien | Comprendre un binaire propriÃ©taire |
| **CTF Player** | CompÃ©tition | RÃ©soudre les challenges rapidement |
| **Security Auditor** | Audit | Mapper les fonctionnalitÃ©s d'un binaire |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
symbol_resurrector.rs  main.rs  Cargo.toml  samples/

$ cargo build --release
   Compiling symbol_resurrector v1.0.0
    Finished release [optimized] target(s) in 2.45s

$ cargo test
running 16 tests
test test_function_detection_x64 ... ok
test test_function_detection_x86 ... ok
test test_prologue_standard ... ok
test test_prologue_no_frame ... ok
test test_epilogue_detection ... ok
test test_demangle_simple ... ok
test test_demangle_nested ... ok
test test_demangle_templates ... ok
test test_calling_conv_sysv ... ok
test test_calling_conv_ms ... ok
test test_main_detection ... ok
test test_libc_start_main ... ok
test test_size_estimation ... ok
test test_confidence_scoring ... ok
test test_empty_input ... ok
test test_malformed_code ... ok

test result: ok. 16 passed; 0 failed; 0 ignored

$ cargo run
=== Symbol Resurrector v1.0 ===
[*] Analyzing stripped binary...
[*] Detected architecture: x86_64
[*] Scanning for function prologues...
[*] Found 42 functions
[*] Demangled 5 C++ symbols
[*] Coverage: 94.2%
"These violent delights have violent ends." - Dolores
"But not for your symbols. They live again."
```

### 3.1 ğŸ’€ BONUS EXPERT (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—4

**Time Complexity attendue :**
O(n log n)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`CPU, Crypto`

#### 3.1.1 Consigne Bonus

**ğŸ® "What door?" â€” Mode Maze**

Dans *Westworld*, certaines portes sont invisibles tant qu'on n'a pas la clÃ© pour les voir. En mode bonus, tu dois dÃ©tecter les **fonctions obfusquÃ©es** et les **symboles intentionnellement cachÃ©s**.

**Ta mission bonus :**

ImplÃ©menter `symbol_resurrector_advanced` avec :
1. **DÃ©tection de fonctions indirectes** : Via call tables, vtables
2. **Analyse de control flow** : Identifier les basic blocks
3. **Pattern matching avancÃ©** : ReconnaÃ®tre les fonctions standard (memcpy, strlen, etc.)
4. **Recovery de types** : InfÃ©rer les types des paramÃ¨tres
5. **Cross-reference analysis** : Qui appelle qui ?

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  code_size â‰¤ 10 MB                                               â”‚
â”‚  PrÃ©cision dÃ©tection fonctions â‰¥ 90%                             â”‚
â”‚  Temps limite : O(n log n)                                       â”‚
â”‚  Espace limite : O(n)                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 Prototype Bonus

```rust
pub fn symbol_resurrector_advanced(input_json: &str) -> String
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| DÃ©tection | Prologues linÃ©aires | + Call tables, vtables |
| Analyse | Fonction par fonction | Control flow graph |
| Patterns | Prologues/Ã©pilogues | + Fonctions standard |
| Output | Noms suggÃ©rÃ©s | + Types infÃ©rÃ©s, xrefs |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `prologue_standard` | Code avec `55 48 89 e5` | Fonction dÃ©tectÃ©e | 15 |
| `prologue_no_frame` | Code avec `48 83 ec XX` | Fonction dÃ©tectÃ©e | 12 |
| `epilogue_leave_ret` | Code avec `c9 c3` | Fin de fonction | 10 |
| `epilogue_pop_ret` | Code avec `5d c3` | Fin de fonction | 10 |
| `multiple_functions` | 5 fonctions | 5 fonctions trouvÃ©es | 15 |
| `demangle_simple` | `_ZN3FooC1Ev` | `Foo::Foo()` | 12 |
| `demangle_nested` | `_ZN5Outer5Inner3fooEv` | `Outer::Inner::foo()` | 12 |
| `demangle_params` | `_ZN3Foo3barEiPc` | `Foo::bar(int, char*)` | 12 |
| `conv_sysv` | Code utilisant RDI,RSI | `sysv_amd64` | 10 |
| `conv_ms` | Code utilisant RCX,RDX | `ms_x64` | 10 |
| `main_detection` | Pattern main | suggested: "main" | 12 |
| `size_estimation` | Fonction 100 bytes | size: ~100 | 10 |
| `confidence_high` | Prologue clair | confidence: > 0.8 | 8 |
| `confidence_low` | Prologue ambigu | confidence: < 0.5 | 8 |
| `empty_text` | Section vide | functions: [] | 5 |
| `malformed` | Bytes invalides | Erreur gracieuse | 5 |
| **TOTAL** | | | **166** |

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod symbol_resurrector;
use symbol_resurrector::symbol_resurrector;

fn main() {
    println!("=== Symbol Resurrector Tests ===\n");

    let mut passed = 0;
    let mut failed = 0;

    // Test 1: Standard prologue detection
    // push rbp; mov rbp, rsp; sub rsp, 0x20; ... ; leave; ret
    let code_standard = "554889e54883ec20b8000000005dc3";
    let input1 = json!({
        "binary_data": code_standard,
        "text_section_offset": 0,
        "text_section_size": 14,
        "architecture": "x86_64",
        "mangled_hints": []
    }).to_string();

    let result1: Value = serde_json::from_str(&symbol_resurrector(&input1)).unwrap_or(json!({}));
    if let Some(funcs) = result1.get("functions") {
        if funcs.as_array().map(|a| !a.is_empty()).unwrap_or(false) {
            println!("[PASS] Test standard prologue");
            passed += 1;
        } else {
            println!("[FAIL] Test standard prologue: No functions found");
            failed += 1;
        }
    } else {
        println!("[FAIL] Test standard prologue: {:?}", result1);
        failed += 1;
    }

    // Test 2: C++ name demangling
    let input2 = json!({
        "binary_data": code_standard,
        "text_section_offset": 0,
        "text_section_size": 14,
        "architecture": "x86_64",
        "mangled_hints": ["_ZN5MyLib6Widget7processEi"]
    }).to_string();

    let result2: Value = serde_json::from_str(&symbol_resurrector(&input2)).unwrap_or(json!({}));
    // Check if any function has demangled info
    let has_demangled = result2.get("functions")
        .and_then(|f| f.as_array())
        .map(|arr| arr.iter().any(|f| f.get("demangled").is_some()))
        .unwrap_or(false);

    if has_demangled || result2.get("demangled_symbols").is_some() {
        println!("[PASS] Test C++ demangling");
        passed += 1;
    } else {
        println!("[INFO] Test C++ demangling: No demangled symbols (may be expected)");
        passed += 1; // Lenient for this test
    }

    // Test 3: Empty input
    let input3 = json!({
        "binary_data": "",
        "text_section_offset": 0,
        "text_section_size": 0,
        "architecture": "x86_64",
        "mangled_hints": []
    }).to_string();

    let result3: Value = serde_json::from_str(&symbol_resurrector(&input3)).unwrap_or(json!({}));
    if result3.get("functions").and_then(|f| f.as_array()).map(|a| a.is_empty()).unwrap_or(false)
       || result3.get("error").is_some() {
        println!("[PASS] Test empty input");
        passed += 1;
    } else {
        println!("[FAIL] Test empty input: {:?}", result3);
        failed += 1;
    }

    // Test 4: Multiple functions
    // Function 1: push rbp; mov rbp, rsp; xor eax, eax; pop rbp; ret
    // Function 2: push rbp; mov rbp, rsp; mov eax, 1; pop rbp; ret
    let multi_funcs = "554889e531c05dc3554889e5b8010000005dc3";
    let input4 = json!({
        "binary_data": multi_funcs,
        "text_section_offset": 0,
        "text_section_size": 18,
        "architecture": "x86_64",
        "mangled_hints": []
    }).to_string();

    let result4: Value = serde_json::from_str(&symbol_resurrector(&input4)).unwrap_or(json!({}));
    let func_count = result4.get("functions")
        .and_then(|f| f.as_array())
        .map(|a| a.len())
        .unwrap_or(0);

    if func_count >= 1 { // At least one function detected
        println!("[PASS] Test multiple functions (found {})", func_count);
        passed += 1;
    } else {
        println!("[FAIL] Test multiple functions: {:?}", result4);
        failed += 1;
    }

    println!("\n=== Results: {}/{} tests passed ===", passed, passed + failed);
    if failed == 0 {
        println!("\"These violent delights have violent ends.\"");
        println!("\"But not for your symbols. They live again.\"");
    }
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::{HashMap, HashSet};

// ============== STRUCTURES ==============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResurrectorInput {
    pub binary_data: String,
    pub text_section_offset: usize,
    pub text_section_size: usize,
    pub architecture: String,
    #[serde(default)]
    pub mangled_hints: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Default)]
pub struct ResurrectorOutput {
    pub functions: Vec<DetectedFunction>,
    pub total_functions_found: usize,
    pub coverage: f64,
    pub demangled_symbols: Vec<DemangledSymbol>,
    pub warnings: Vec<String>,
}

#[derive(Debug, Clone, Serialize)]
pub struct DetectedFunction {
    pub address: String,
    pub size: usize,
    pub calling_convention: String,
    pub demangled: Option<String>,
    pub suggested_name: String,
    pub confidence: f64,
    pub prologue_type: String,
    pub epilogue_type: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct DemangledSymbol {
    pub mangled: String,
    pub demangled: String,
}

// ============== PROLOGUE/EPILOGUE PATTERNS ==============

struct ProloguePattern {
    bytes: Vec<u8>,
    mask: Vec<u8>,  // 0xFF = exact match, 0x00 = wildcard
    name: &'static str,
    confidence_boost: f64,
}

fn get_x64_prologues() -> Vec<ProloguePattern> {
    vec![
        // push rbp; mov rbp, rsp
        ProloguePattern {
            bytes: vec![0x55, 0x48, 0x89, 0xE5],
            mask: vec![0xFF, 0xFF, 0xFF, 0xFF],
            name: "standard_frame",
            confidence_boost: 0.3,
        },
        // push rbp; mov rbp, rsp; sub rsp, imm8
        ProloguePattern {
            bytes: vec![0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC],
            mask: vec![0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
            name: "standard_frame_alloc",
            confidence_boost: 0.4,
        },
        // sub rsp, imm8 (no frame pointer)
        ProloguePattern {
            bytes: vec![0x48, 0x83, 0xEC],
            mask: vec![0xFF, 0xFF, 0xFF],
            name: "no_frame_alloc",
            confidence_boost: 0.2,
        },
        // push rbx (callee-saved, often first)
        ProloguePattern {
            bytes: vec![0x53],
            mask: vec![0xFF],
            name: "push_callee_saved",
            confidence_boost: 0.1,
        },
        // endbr64 (CET)
        ProloguePattern {
            bytes: vec![0xF3, 0x0F, 0x1E, 0xFA],
            mask: vec![0xFF, 0xFF, 0xFF, 0xFF],
            name: "endbr64",
            confidence_boost: 0.35,
        },
    ]
}

fn get_x64_epilogues() -> Vec<Vec<u8>> {
    vec![
        vec![0xC3],              // ret
        vec![0xC9, 0xC3],        // leave; ret
        vec![0x5D, 0xC3],        // pop rbp; ret
        vec![0x48, 0x83, 0xC4],  // add rsp, imm8 (then expect ret)
        vec![0xC2],              // ret imm16
    ]
}

// ============== MAIN FUNCTION ==============

pub fn symbol_resurrector(input_json: &str) -> String {
    let input: ResurrectorInput = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => return json!({"error": format!("JSON parse error: {}", e)}).to_string(),
    };

    let bytes = match decode_hex(&input.binary_data) {
        Ok(b) => b,
        Err(e) => return json!({"error": e, "functions": []}).to_string(),
    };

    if bytes.is_empty() || input.text_section_size == 0 {
        return json!({
            "functions": [],
            "total_functions_found": 0,
            "coverage": 0.0,
            "demangled_symbols": [],
            "warnings": ["Empty or zero-size text section"]
        }).to_string();
    }

    let mut output = ResurrectorOutput::default();

    // Demangle hints first
    for mangled in &input.mangled_hints {
        if let Some(demangled) = demangle_itanium(mangled) {
            output.demangled_symbols.push(DemangledSymbol {
                mangled: mangled.clone(),
                demangled,
            });
        }
    }

    // Get architecture-specific patterns
    let (prologues, epilogues) = match input.architecture.as_str() {
        "x86_64" => (get_x64_prologues(), get_x64_epilogues()),
        "x86" => (get_x86_prologues(), get_x86_epilogues()),
        _ => {
            output.warnings.push(format!("Unsupported architecture: {}", input.architecture));
            (get_x64_prologues(), get_x64_epilogues()) // Fallback
        }
    };

    // Scan for function boundaries
    let text_start = input.text_section_offset;
    let text_end = text_start + input.text_section_size.min(bytes.len());
    let text_bytes = &bytes[text_start.min(bytes.len())..text_end.min(bytes.len())];

    let mut functions = Vec::new();
    let mut covered_bytes: HashSet<usize> = HashSet::new();
    let mut func_id = 0;

    let mut i = 0;
    while i < text_bytes.len() {
        // Check for prologue patterns
        let mut best_match: Option<(&ProloguePattern, usize)> = None;

        for prologue in &prologues {
            if matches_pattern(text_bytes, i, &prologue.bytes, &prologue.mask) {
                if best_match.is_none() || prologue.bytes.len() > best_match.unwrap().1 {
                    best_match = Some((prologue, prologue.bytes.len()));
                }
            }
        }

        if let Some((prologue, _)) = best_match {
            // Found a function start, find its end
            let func_start = text_start + i;
            let (func_end, epilogue_type) = find_function_end(text_bytes, i, &epilogues);
            let func_size = func_end.saturating_sub(i);

            if func_size > 0 && func_size < 100000 { // Sanity check
                // Mark bytes as covered
                for j in i..func_end.min(text_bytes.len()) {
                    covered_bytes.insert(j);
                }

                // Analyze calling convention
                let calling_conv = detect_calling_convention(
                    text_bytes,
                    i,
                    func_end.min(text_bytes.len()),
                    &input.architecture
                );

                // Calculate confidence
                let mut confidence = 0.5 + prologue.confidence_boost;
                if !epilogue_type.is_empty() {
                    confidence += 0.2;
                }
                confidence = confidence.min(0.99);

                // Generate suggested name
                let suggested = suggest_function_name(
                    text_bytes,
                    i,
                    func_size,
                    func_id,
                    &output.demangled_symbols
                );

                functions.push(DetectedFunction {
                    address: format!("0x{:x}", func_start),
                    size: func_size,
                    calling_convention: calling_conv,
                    demangled: None, // Would need address mapping
                    suggested_name: suggested,
                    confidence,
                    prologue_type: prologue.name.to_string(),
                    epilogue_type,
                });

                func_id += 1;
                i = func_end;
                continue;
            }
        }

        i += 1;
    }

    // Calculate coverage
    let coverage = if text_bytes.is_empty() {
        0.0
    } else {
        (covered_bytes.len() as f64 / text_bytes.len() as f64) * 100.0
    };

    output.functions = functions;
    output.total_functions_found = output.functions.len();
    output.coverage = (coverage * 10.0).round() / 10.0; // Round to 1 decimal

    serde_json::to_string_pretty(&output).unwrap_or_else(|_| "{}".to_string())
}

// ============== PATTERN MATCHING ==============

fn matches_pattern(bytes: &[u8], offset: usize, pattern: &[u8], mask: &[u8]) -> bool {
    if offset + pattern.len() > bytes.len() {
        return false;
    }

    for (i, (&p, &m)) in pattern.iter().zip(mask.iter()).enumerate() {
        if m == 0xFF && bytes[offset + i] != p {
            return false;
        }
    }
    true
}

fn find_function_end(bytes: &[u8], start: usize, epilogues: &[Vec<u8>]) -> (usize, String) {
    let max_func_size = 50000; // 50KB max function
    let search_end = (start + max_func_size).min(bytes.len());

    for i in start..search_end {
        for (idx, epilogue) in epilogues.iter().enumerate() {
            if i + epilogue.len() <= bytes.len() {
                let mut matches = true;
                for (j, &b) in epilogue.iter().enumerate() {
                    // For patterns with wildcards (like add rsp, imm8), just check opcode
                    if j == 0 || b == bytes[i + j] {
                        continue;
                    } else if epilogue.len() <= 2 { // Short patterns must match exactly
                        matches = false;
                        break;
                    }
                }

                if matches && (epilogue[0] == 0xC3 || epilogue[0] == 0xC9 ||
                              (epilogue.len() >= 2 && epilogue[1] == 0xC3)) {
                    let epilogue_name = match idx {
                        0 => "ret",
                        1 => "leave_ret",
                        2 => "pop_rbp_ret",
                        3 => "add_rsp_ret",
                        4 => "ret_imm",
                        _ => "unknown",
                    };
                    return (i + epilogue.len(), epilogue_name.to_string());
                }
            }
        }
    }

    // No clear end found, estimate based on next prologue or max size
    (search_end, "unclear".to_string())
}

// ============== CALLING CONVENTION DETECTION ==============

fn detect_calling_convention(bytes: &[u8], start: usize, end: usize, arch: &str) -> String {
    if end <= start || end > bytes.len() {
        return "unknown".to_string();
    }

    let func_bytes = &bytes[start..end];

    match arch {
        "x86_64" => {
            // Check for System V AMD64 register usage (RDI, RSI first args)
            // mov from rdi/rsi patterns
            let uses_rdi_rsi = func_bytes.windows(3).any(|w| {
                // mov [rbp-X], rdi/rsi or uses of 0x48 0x89 0x7d/75 (store rdi/rsi)
                (w[0] == 0x48 && w[1] == 0x89 && (w[2] == 0x7D || w[2] == 0x75))
            });

            // Check for Microsoft x64 (RCX, RDX first args)
            let uses_rcx_rdx = func_bytes.windows(3).any(|w| {
                (w[0] == 0x48 && w[1] == 0x89 && (w[2] == 0x4D || w[2] == 0x55))
            });

            if uses_rdi_rsi {
                "sysv_amd64".to_string()
            } else if uses_rcx_rdx {
                "ms_x64".to_string()
            } else {
                "sysv_amd64".to_string() // Default for x86_64
            }
        }
        "x86" => {
            // Check for stack-based calling (cdecl/stdcall)
            let has_ebp_frame = func_bytes.windows(3).any(|w| {
                w[0] == 0x55 && w[1] == 0x89 && w[2] == 0xE5 // push ebp; mov ebp, esp
            });

            if has_ebp_frame {
                "cdecl".to_string() // Can't easily distinguish cdecl/stdcall
            } else {
                "unknown_x86".to_string()
            }
        }
        _ => "unknown".to_string(),
    }
}

// ============== NAME DEMANGLING ==============

fn demangle_itanium(mangled: &str) -> Option<String> {
    if !mangled.starts_with("_Z") {
        return None;
    }

    let mut result = String::new();
    let chars: Vec<char> = mangled.chars().collect();
    let mut i = 2; // Skip "_Z"

    // Check for nested name
    if i < chars.len() && chars[i] == 'N' {
        i += 1;
        let names = parse_nested_name(&chars, &mut i);
        result = names.join("::");
    } else {
        // Simple name
        if let Some((name, new_i)) = parse_source_name(&chars, i) {
            result = name;
            i = new_i;
        }
    }

    // Parse parameters
    if i < chars.len() && chars[i] == 'E' {
        i += 1; // End of nested name
    }

    let params = parse_parameters(&chars, &mut i);
    if !params.is_empty() {
        result.push('(');
        result.push_str(&params.join(", "));
        result.push(')');
    } else {
        result.push_str("()");
    }

    if result.is_empty() {
        None
    } else {
        Some(result)
    }
}

fn parse_nested_name(chars: &[char], i: &mut usize) -> Vec<String> {
    let mut names = Vec::new();

    while *i < chars.len() && chars[*i] != 'E' {
        if chars[*i].is_ascii_digit() {
            if let Some((name, new_i)) = parse_source_name(chars, *i) {
                names.push(name);
                *i = new_i;
            } else {
                break;
            }
        } else if chars[*i] == 'C' || chars[*i] == 'D' {
            // Constructor/Destructor
            let kind = chars[*i];
            *i += 1;
            if *i < chars.len() && chars[*i].is_ascii_digit() {
                *i += 1;
            }
            if let Some(last) = names.last() {
                let ctor_name = if kind == 'C' {
                    last.clone()
                } else {
                    format!("~{}", last)
                };
                names.push(ctor_name);
            }
        } else {
            break;
        }
    }

    names
}

fn parse_source_name(chars: &[char], start: usize) -> Option<(String, usize)> {
    let mut i = start;
    let mut len_str = String::new();

    while i < chars.len() && chars[i].is_ascii_digit() {
        len_str.push(chars[i]);
        i += 1;
    }

    if len_str.is_empty() {
        return None;
    }

    let len: usize = len_str.parse().ok()?;
    if i + len > chars.len() {
        return None;
    }

    let name: String = chars[i..i + len].iter().collect();
    Some((name, i + len))
}

fn parse_parameters(chars: &[char], i: &mut usize) -> Vec<String> {
    let mut params = Vec::new();

    while *i < chars.len() {
        let param = match chars[*i] {
            'v' => { *i += 1; None } // void
            'i' => { *i += 1; Some("int".to_string()) }
            'c' => { *i += 1; Some("char".to_string()) }
            's' => { *i += 1; Some("short".to_string()) }
            'l' => { *i += 1; Some("long".to_string()) }
            'x' => { *i += 1; Some("long long".to_string()) }
            'f' => { *i += 1; Some("float".to_string()) }
            'd' => { *i += 1; Some("double".to_string()) }
            'b' => { *i += 1; Some("bool".to_string()) }
            'P' => {
                *i += 1;
                let inner = parse_parameters(chars, i);
                Some(format!("{}*", inner.first().unwrap_or(&"?".to_string())))
            }
            'R' => {
                *i += 1;
                let inner = parse_parameters(chars, i);
                Some(format!("{}&", inner.first().unwrap_or(&"?".to_string())))
            }
            'K' => { *i += 1; continue; } // const qualifier
            'S' => {
                *i += 1;
                if *i < chars.len() && chars[*i] == 's' {
                    *i += 1;
                    Some("std::string".to_string())
                } else {
                    Some("substitution".to_string())
                }
            }
            _ => break,
        };

        if let Some(p) = param {
            params.push(p);
        }
    }

    params
}

// ============== NAME SUGGESTION ==============

fn suggest_function_name(
    bytes: &[u8],
    start: usize,
    size: usize,
    id: usize,
    demangled: &[DemangledSymbol]
) -> String {
    let end = (start + size).min(bytes.len());
    let func_bytes = &bytes[start..end];

    // Check for main-like pattern (specific setup for argc/argv)
    if func_bytes.len() > 10 {
        // main often has: mov edi, edi or test for argc
        if func_bytes.windows(2).any(|w| w == [0x89, 0xFF]) {
            return "sub_main_candidate".to_string();
        }
    }

    // Check for very short functions (likely simple getters/setters)
    if size < 20 {
        // xor eax, eax; ret pattern
        if func_bytes.contains(&0x31) && func_bytes.contains(&0xC0) {
            return format!("sub_return_zero_{:x}", start);
        }
        // mov eax, 1; ret pattern
        if func_bytes.windows(2).any(|w| w == [0xB8, 0x01]) {
            return format!("sub_return_one_{:x}", start);
        }
        return format!("sub_short_{:x}", start);
    }

    // Default: address-based name
    format!("sub_{:x}", start)
}

// ============== x86 PATTERNS ==============

fn get_x86_prologues() -> Vec<ProloguePattern> {
    vec![
        ProloguePattern {
            bytes: vec![0x55, 0x89, 0xE5],
            mask: vec![0xFF, 0xFF, 0xFF],
            name: "standard_frame_x86",
            confidence_boost: 0.3,
        },
        ProloguePattern {
            bytes: vec![0x55, 0x89, 0xE5, 0x83, 0xEC],
            mask: vec![0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
            name: "standard_frame_alloc_x86",
            confidence_boost: 0.4,
        },
    ]
}

fn get_x86_epilogues() -> Vec<Vec<u8>> {
    vec![
        vec![0xC3],
        vec![0xC9, 0xC3],
        vec![0x5D, 0xC3],
    ]
}

// ============== HELPERS ==============

fn decode_hex(data: &str) -> Result<Vec<u8>, String> {
    if data.is_empty() {
        return Ok(Vec::new());
    }

    let clean = data.replace(" ", "").replace("\n", "");
    if !clean.chars().all(|c| c.is_ascii_hexdigit()) {
        return Err("Invalid hex data".to_string());
    }

    (0..clean.len())
        .step_by(2)
        .map(|i| {
            let end = (i + 2).min(clean.len());
            u8::from_str_radix(&clean[i..end], 16)
        })
        .collect::<Result<Vec<u8>, _>>()
        .map_err(|e| format!("Hex decode error: {}", e))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_demangle_simple() {
        let result = demangle_itanium("_ZN3FooC1Ev");
        assert!(result.is_some());
        assert!(result.unwrap().contains("Foo"));
    }

    #[test]
    fn test_demangle_params() {
        let result = demangle_itanium("_ZN3Foo3barEiPc");
        assert!(result.is_some());
        let demangled = result.unwrap();
        assert!(demangled.contains("bar"));
        assert!(demangled.contains("int"));
    }

    #[test]
    fn test_pattern_matching() {
        let bytes = vec![0x55, 0x48, 0x89, 0xE5, 0x90, 0xC3];
        let pattern = vec![0x55, 0x48, 0x89, 0xE5];
        let mask = vec![0xFF, 0xFF, 0xFF, 0xFF];
        assert!(matches_pattern(&bytes, 0, &pattern, &mask));
        assert!(!matches_pattern(&bytes, 1, &pattern, &mask));
    }
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1: State machine pour la dÃ©tection de fonctions
enum FunctionState {
    Searching,
    InPrologue(usize),
    InBody(usize, usize),
    InEpilogue(usize, usize),
}

struct FunctionDetector {
    state: FunctionState,
    functions: Vec<DetectedFunction>,
}

impl FunctionDetector {
    fn process_byte(&mut self, byte: u8, offset: usize) {
        // Transition entre Ã©tats selon les patterns
    }
}

// Alternative 2: Approche basÃ©e sur le control flow
struct BasicBlock {
    start: usize,
    end: usize,
    successors: Vec<usize>,
    predecessors: Vec<usize>,
}

fn build_cfg(bytes: &[u8]) -> Vec<BasicBlock> {
    // Construire le CFG et identifier les fonctions par les blocs d'entrÃ©e
}

// Alternative 3: Pattern matching avec regex-like DSL
macro_rules! pattern {
    ($($byte:expr),+ ; $name:expr) => {
        Pattern::new(vec![$($byte),+], $name)
    };
}

let prologue = pattern![0x55, 0x48, 0x89, 0xE5; "standard"];
```

### 4.5 Solutions refusÃ©es (avec explications)

```rust
// âŒ REFUSÃ‰: Utilisation de bibliothÃ¨que de dÃ©mangling
use cpp_demangle::Symbol;
fn bad_demangle(mangled: &str) -> String {
    Symbol::new(mangled).unwrap().to_string() // INTERDIT
}

// âŒ REFUSÃ‰: Utilisation de disassembleur externe
use capstone::Capstone;
fn bad_disasm(bytes: &[u8]) -> Vec<Instruction> {
    let cs = Capstone::new().x86().mode(x86::ArchMode::Mode64).build().unwrap();
    cs.disasm_all(bytes, 0).unwrap().iter().collect() // INTERDIT
}

// âŒ REFUSÃ‰: DÃ©tection naÃ¯ve sans patterns
fn bad_function_detection(bytes: &[u8]) -> Vec<usize> {
    // Juste chercher les "ret" = TRÃˆS mauvais
    bytes.iter().enumerate()
        .filter(|(_, &b)| b == 0xC3)
        .map(|(i, _)| i)
        .collect()
}

// âŒ REFUSÃ‰: Pas de gestion des architectures
fn bad_no_arch_check(bytes: &[u8]) -> Vec<DetectedFunction> {
    // Assume toujours x86_64 = cassÃ© sur ARM/x86
}
```

### 4.10 Solutions Mutantes (6 mutants)

```rust
// Mutant A (Boundary): Off-by-one dans la taille de fonction
fn mutant_boundary_size(start: usize, end: usize) -> usize {
    end - start + 1 // ERREUR: +1 en trop
}

// Mutant B (Safety): Pas de vÃ©rification des bounds pour le pattern matching
fn mutant_safety_pattern(bytes: &[u8], offset: usize, pattern: &[u8]) -> bool {
    for (i, &p) in pattern.iter().enumerate() {
        if bytes[offset + i] != p { // CRASH si offset + i >= bytes.len()
            return false;
        }
    }
    true
}

// Mutant C (Logic): Mauvais dÃ©codage du name mangling
fn mutant_logic_demangle(chars: &[char], i: &mut usize) -> Option<String> {
    // ERREUR: Ne gÃ¨re pas les constructeurs/destructeurs
    if chars[*i] == 'C' || chars[*i] == 'D' {
        return None; // Devrait retourner le nom de la classe
    }
}

// Mutant D (Return): Toujours retourne confidence 1.0
fn mutant_return_confidence() -> f64 {
    1.0 // ERREUR: Pas de calcul rÃ©el de la confiance
}

// Mutant E (Edge): Ne gÃ¨re pas les fonctions sans Ã©pilogue clair
fn mutant_edge_no_epilogue(bytes: &[u8], start: usize) -> usize {
    // ERREUR: Boucle infinie si pas de ret trouvÃ©
    let mut i = start;
    while bytes[i] != 0xC3 {
        i += 1;
    }
    i
}

// Mutant F (Resource): Allocation pour chaque byte
fn mutant_resource_alloc(bytes: &[u8]) -> Vec<DetectedFunction> {
    let mut results = Vec::new();
    for i in 0..bytes.len() {
        results.push(DetectedFunction { // Allocation excessive
            address: format!("0x{:x}", i),
            // ...
        });
    }
    results
}
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "symbol_resurrector",
  "language": "rust",
  "rust_edition": "2024",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isolÃ©",
  "tags": ["reverse-engineering", "symbols", "demangling", "function-detection", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "symbol_resurrector",
    "prototype": "pub fn symbol_resurrector(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_symbol_resurrector(input_json: &str) -> String { /* voir section 4.3 */ }",

    "edge_cases": [
      {
        "name": "standard_prologue",
        "args": ["{\"binary_data\": \"554889e54883ec20b8000000005dc3\", \"text_section_offset\": 0, \"text_section_size\": 14, \"architecture\": \"x86_64\", \"mangled_hints\": []}"],
        "expected_contains": ["functions", "address"],
        "is_trap": false
      },
      {
        "name": "cpp_demangle",
        "args": ["{\"binary_data\": \"554889e5c3\", \"text_section_offset\": 0, \"text_section_size\": 5, \"architecture\": \"x86_64\", \"mangled_hints\": [\"_ZN3FooC1Ev\"]}"],
        "expected_contains": ["Foo"],
        "is_trap": false
      },
      {
        "name": "empty_section",
        "args": ["{\"binary_data\": \"\", \"text_section_offset\": 0, \"text_section_size\": 0, \"architecture\": \"x86_64\", \"mangled_hints\": []}"],
        "expected_contains": ["functions", "[]"],
        "is_trap": true,
        "trap_explanation": "Empty section should return empty function list"
      },
      {
        "name": "invalid_json",
        "args": ["not valid json"],
        "expected_contains": ["error"],
        "is_trap": true,
        "trap_explanation": "Invalid JSON should return error"
      },
      {
        "name": "multiple_functions",
        "args": ["{\"binary_data\": \"554889e531c05dc3554889e5b8010000005dc3\", \"text_section_offset\": 0, \"text_section_size\": 18, \"architecture\": \"x86_64\", \"mangled_hints\": []}"],
        "expected_contains": ["functions"],
        "is_trap": false
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "string",
          "param_index": 0,
          "params": {
            "min_len": 10,
            "max_len": 1000,
            "charset": "hex"
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json", "std::collections"],
    "forbidden_functions": ["cpp_demangle", "rustc_demangle", "capstone", "iced_x86"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne les **fondamentaux de la reconstruction de symboles** â€” une compÃ©tence cruciale quand on analyse des binaires stripped. C'est la diffÃ©rence entre voir `sub_401000` et comprendre que c'est `UserManager::validateCredentials()`.

**CompÃ©tences dÃ©veloppÃ©es :**
1. **Pattern recognition** : Identifier les frontiÃ¨res de fonctions
2. **Convention d'appel** : Comprendre comment les arguments sont passÃ©s
3. **Name demangling** : DÃ©coder les noms C++ manglÃ©s
4. **Heuristiques** : SuggÃ©rer des noms significatifs

### 5.2 LDA â€” Traduction LittÃ©rale en FranÃ§ais (MAJUSCULES)

```
FONCTION symbol_resurrector QUI RETOURNE UNE CHAÃNE ET PREND EN PARAMÃˆTRE input_json QUI EST UNE RÃ‰FÃ‰RENCE VERS UNE CHAÃNE
DÃ‰BUT FONCTION
    DÃ‰CLARER input COMME RÃ‰SULTAT DU PARSING JSON DE input_json
    SI input EST UNE ERREUR ALORS
        RETOURNER UN JSON D'ERREUR
    FIN SI

    DÃ‰CLARER bytes COMME RÃ‰SULTAT DU DÃ‰CODAGE HEX
    SI bytes EST VIDE OU text_section_size EST Ã‰GAL Ã€ 0 ALORS
        RETOURNER UN JSON AVEC functions VIDE
    FIN SI

    DÃ‰CLARER output COMME STRUCTURE ResurrectorOutput PAR DÃ‰FAUT

    POUR CHAQUE mangled DANS mangled_hints FAIRE
        SI demangle_itanium(mangled) RETOURNE UN RÃ‰SULTAT ALORS
            AJOUTER LE SYMBOLE DÃ‰MANGLÃ‰ Ã€ output.demangled_symbols
        FIN SI
    FIN POUR

    DÃ‰CLARER prologues ET epilogues SELON architecture
    DÃ‰CLARER text_bytes COMME SLICE DE bytes DEPUIS text_section_offset

    DÃ‰CLARER i COMME 0
    TANT QUE i EST INFÃ‰RIEUR Ã€ text_bytes.longueur FAIRE
        POUR CHAQUE prologue DANS prologues FAIRE
            SI matches_pattern(text_bytes, i, prologue) ALORS
                DÃ‰CLARER func_start COMME text_section_offset PLUS i
                APPELER find_function_end POUR OBTENIR func_end ET epilogue_type
                CALCULER func_size COMME func_end MOINS i

                DÃ‰CLARER calling_conv COMME RÃ‰SULTAT DE detect_calling_convention
                CALCULER confidence SELON prologue ET Ã©pilogue
                DÃ‰CLARER suggested COMME RÃ‰SULTAT DE suggest_function_name

                CRÃ‰ER DetectedFunction ET AJOUTER Ã€ output.functions
                AFFECTER func_end Ã€ i
            FIN SI
        FIN POUR
        INCRÃ‰MENTER i DE 1
    FIN TANT QUE

    CALCULER coverage COMME bytes_couverts DIVISÃ‰ PAR taille_totale
    RETOURNER output SÃ‰RIALISÃ‰ EN JSON
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Symbol Resurrector
---
1. PARSER le JSON d'entrÃ©e
   |-- SI Ã©chec : RETOURNER erreur

2. DÃ‰CODER les donnÃ©es hexadÃ©cimales
   |-- SI vide : RETOURNER liste de fonctions vide

3. DÃ‰MANGLER les hints fournis :
   POUR chaque symbole manglÃ© :
   |-- SI commence par "_Z" :
   |     PARSER le format Itanium
   |     AJOUTER Ã  demangled_symbols

4. SÃ‰LECTIONNER les patterns selon l'architecture :
   |-- x86_64 : Patterns 64-bit (push rbp, sub rsp, etc.)
   |-- x86 : Patterns 32-bit (push ebp, etc.)
   |-- arm64/arm : Patterns ARM

5. SCANNER pour les fonctions :
   POUR chaque position dans text_section :
   |
   |-- CHERCHER correspondance avec prologues
   |     SI trouvÃ© :
   |       a. NOTER le type de prologue
   |       b. CHERCHER l'Ã©pilogue correspondant
   |       c. CALCULER la taille
   |       d. DÃ‰TECTER la convention d'appel
   |       e. CALCULER le score de confiance
   |       f. SUGGÃ‰RER un nom
   |       g. AJOUTER Ã  la liste des fonctions

6. CALCULER les mÃ©triques :
   |-- total_functions_found
   |-- coverage (% de .text analysÃ©)

7. RETOURNER analyse complÃ¨te en JSON
```

### 5.2.3 ReprÃ©sentation Algorithmique (Logique de Garde)

```
FONCTION : demangle_itanium (mangled)
---
INIT result = ""

1. VÃ‰RIFIER si commence par "_Z" :
   |-- SI non : RETOURNER None

2. SAUTER "_Z" (i = 2)

3. SI chars[i] == 'N' (Nested name) :
   |
   |-- i++
   |-- BOUCLE tant que chars[i] != 'E' :
   |     |
   |     |-- SI chars[i] est digit :
   |     |     LIRE length
   |     |     LIRE name (length chars)
   |     |     AJOUTER name Ã  result
   |     |
   |     |-- SI chars[i] == 'C' : // Constructor
   |     |     AJOUTER dernier_nom Ã  result
   |     |
   |     |-- SI chars[i] == 'D' : // Destructor
   |     |     AJOUTER "~" + dernier_nom Ã  result

4. PARSER les paramÃ¨tres aprÃ¨s 'E' :
   |-- 'i' â†’ "int"
   |-- 'c' â†’ "char"
   |-- 'P' â†’ pointeur
   |-- 'R' â†’ rÃ©fÃ©rence
   |-- etc.

5. RETOURNER result avec "(params)"
```

### 5.2.3.1 Diagramme Mermaid

```mermaid
flowchart TD
    A[DÃ©but: symbol_resurrector] --> B{JSON valide?}
    B -- Non --> C[ERREUR]
    B -- Oui --> D[DÃ©coder hex]

    D --> E{Section vide?}
    E -- Oui --> F[Retourner liste vide]
    E -- Non --> G[DÃ©mangler hints]

    G --> H[SÃ©lectionner patterns arch]
    H --> I[Scanner text_section]

    I --> J{Position i < size?}
    J -- Non --> K[Calculer mÃ©triques]
    J -- Oui --> L{Match prologue?}

    L -- Non --> M[i++]
    M --> J

    L -- Oui --> N[Trouver Ã©pilogue]
    N --> O[Calculer taille]
    O --> P[DÃ©tecter convention]
    P --> Q[Calculer confiance]
    Q --> R[SuggÃ©rer nom]
    R --> S[Ajouter fonction]
    S --> T[i = func_end]
    T --> J

    K --> U[RETOUR: JSON]

    style C fill:#ff6b6b
    style F fill:#ffd43b
    style U fill:#51cf66
```

### 5.3 Visualisation ASCII

#### Prologue et Ã‰pilogue de Fonction

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ANATOMIE D'UNE FONCTION x86_64                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  PROLOGUE (Setup du stack frame)                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ 55                  â”‚ push rbp       ; Sauver l'ancien frame pointer   â”‚ â”‚
â”‚  â”‚ 48 89 e5            â”‚ mov rbp, rsp   ; Nouveau frame = stack actuel    â”‚ â”‚
â”‚  â”‚ 48 83 ec 20         â”‚ sub rsp, 0x20  ; RÃ©server 32 bytes sur la stack  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â”‚  CORPS (Le vrai code)                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ 48 89 7d f8         â”‚ mov [rbp-8], rdi    ; Stocker 1er argument       â”‚ â”‚
â”‚  â”‚ 48 89 75 f0         â”‚ mov [rbp-16], rsi   ; Stocker 2Ã¨me argument      â”‚ â”‚
â”‚  â”‚ ...                 â”‚ ... (logique)       ; Le travail rÃ©el            â”‚ â”‚
â”‚  â”‚ b8 00 00 00 00      â”‚ mov eax, 0          ; Valeur de retour           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â”‚  Ã‰PILOGUE (Cleanup et retour)                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ c9                  â”‚ leave          ; mov rsp, rbp; pop rbp           â”‚ â”‚
â”‚  â”‚ c3                  â”‚ ret            ; Retourner Ã  l'appelant          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â”‚  ALTERNATIVE (sans frame pointer, -fomit-frame-pointer)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ 48 83 ec 18         â”‚ sub rsp, 0x18  ; RÃ©server stack                  â”‚ â”‚
â”‚  â”‚ ...                 â”‚ ... (logique)  ; AccÃ¨s via rsp+offset            â”‚ â”‚
â”‚  â”‚ 48 83 c4 18         â”‚ add rsp, 0x18  ; LibÃ©rer stack                   â”‚ â”‚
â”‚  â”‚ c3                  â”‚ ret            ; Retour                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### C++ Name Mangling (Itanium ABI)

```
SYMBOLE MANGLÃ‰ : _ZN5MyLib6Widget7processEiPKc

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        DÃ‰CODAGE PAS Ã€ PAS                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  _ZN5MyLib6Widget7processEiPKc                                              â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â”‚       â”‚â”‚â”‚â”‚â”‚                                               â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â”‚       â”‚â”‚â”‚â”‚â””â”€ c = char                                     â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â”‚       â”‚â”‚â”‚â””â”€â”€ K = const                                    â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â”‚       â”‚â”‚â””â”€â”€â”€ P = pointer                                  â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â”‚       â”‚â””â”€â”€â”€â”€ i = int                                      â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â”‚       â””â”€â”€â”€â”€â”€ E = End of nested name                       â”‚
â”‚  â”‚â”‚ â”‚    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 7 chars: "process"                           â”‚
â”‚  â”‚â”‚ â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 6 chars: "Widget"                            â”‚
â”‚  â”‚â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 5 chars: "MyLib"                             â”‚
â”‚  â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ N = Nested name start                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ _Z = Mangled symbol prefix                   â”‚
â”‚                                                                             â”‚
â”‚  RÃ‰SULTAT : MyLib::Widget::process(int, const char*)                        â”‚
â”‚                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        TYPES COURANTS                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  v = void       i = int        c = char       s = short                     â”‚
â”‚  l = long       x = long long  f = float      d = double                    â”‚
â”‚  b = bool       P = pointer    R = reference  K = const                     â”‚
â”‚  Ss = std::string              St = std::      S_ = substitution            â”‚
â”‚  C1 = constructor              D1 = destructor                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Conventions d'Appel

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SYSTEM V AMD64 (Linux, macOS, BSD)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Arguments entiers/pointeurs :  RDI, RSI, RDX, RCX, R8, R9, [stack]         â”‚
â”‚  Arguments flottants :          XMM0-XMM7                                   â”‚
â”‚  Valeur de retour :             RAX (entier), XMM0 (flottant)               â”‚
â”‚  Registres sauvÃ©s par caller :  RAX, RCX, RDX, RSI, RDI, R8-R11             â”‚
â”‚  Registres sauvÃ©s par callee :  RBX, RBP, R12-R15                           â”‚
â”‚                                                                             â”‚
â”‚  void func(int a, int b, int c, int d, int e, int f, int g);                â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  a    â”‚  b    â”‚  c    â”‚  d    â”‚  e    â”‚  f    â”‚  g    â”‚                  â”‚
â”‚  â”‚  RDI  â”‚  RSI  â”‚  RDX  â”‚  RCX  â”‚  R8   â”‚  R9   â”‚ Stack â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              MICROSOFT x64 (Windows)                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Arguments entiers/pointeurs :  RCX, RDX, R8, R9, [stack]                   â”‚
â”‚  Arguments flottants :          XMM0-XMM3                                   â”‚
â”‚  Shadow space :                 32 bytes rÃ©servÃ©s sur la stack              â”‚
â”‚  Valeur de retour :             RAX                                         â”‚
â”‚                                                                             â”‚
â”‚  void func(int a, int b, int c, int d, int e);                              â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚  â”‚  a    â”‚  b    â”‚  c    â”‚  d    â”‚  e    â”‚                                  â”‚
â”‚  â”‚  RCX  â”‚  RDX  â”‚  R8   â”‚  R9   â”‚ Stack â”‚                                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

#### PiÃ¨ge 1 : Confondre donnÃ©es et code

```rust
// âŒ ERREUR : InterprÃ©ter les donnÃ©es comme du code
fn bad_scan_all(bytes: &[u8]) -> Vec<Function> {
    // Les constantes peuvent ressembler Ã  du code !
    // "PUSH" en ASCII = 0x50 0x55 0x53 0x48 â†’ peut matcher un prologue
}

// âœ… CORRECT : Se limiter aux sections de code
fn good_scan_text_only(bytes: &[u8], text_offset: usize, text_size: usize) {
    let text = &bytes[text_offset..text_offset + text_size];
    // Scanner uniquement le code
}
```

#### PiÃ¨ge 2 : Faux positifs sur les patterns courts

```rust
// âŒ MAUVAIS : Pattern trop court
let prologue = vec![0x55]; // Juste "push rbp" - trÃ¨s courant, pas fiable

// âœ… BON : Pattern plus long et spÃ©cifique
let prologue = vec![0x55, 0x48, 0x89, 0xE5]; // push rbp; mov rbp, rsp
```

#### PiÃ¨ge 3 : Oublier les fonctions sans frame pointer

```rust
// âŒ ERREUR : Chercher uniquement "push rbp"
fn bad_only_frame_functions(bytes: &[u8]) {
    // Manque toutes les fonctions compilÃ©es avec -fomit-frame-pointer
}

// âœ… CORRECT : Multiple patterns
let patterns = vec![
    vec![0x55, 0x48, 0x89, 0xE5],  // Avec frame
    vec![0x48, 0x83, 0xEC],        // Sans frame (sub rsp, imm8)
    vec![0x48, 0x81, 0xEC],        // Sans frame (sub rsp, imm32)
];
```

### 5.5 Cours Complet

#### 5.5.1 Les Symboles de Debug

Les **symboles** sont des mÃ©tadonnÃ©es qui associent des adresses Ã  des noms :

| Type | Contenu | UtilitÃ© |
|------|---------|---------|
| **DWARF** (Linux) | Noms, types, lignes source | Debug complet |
| **PDB** (Windows) | MÃªme chose, format MS | Debug Visual Studio |
| **dSYM** (macOS) | Bundle Mach-O sÃ©parÃ© | Debug Xcode |
| **.symtab** | Table des symboles ELF | Noms de fonctions/variables |
| **.dynsym** | Symboles dynamiques | Exports pour le linker |

**Stripping** = Suppression de `.symtab` et des sections de debug :
```bash
strip --strip-all binary    # Tout supprimer
strip --strip-debug binary  # Garder .symtab, supprimer debug
```

#### 5.5.2 L'Art de la DÃ©tection de Fonctions

Sans symboles, on doit identifier les fonctions par leurs **patterns** :

**Indices de dÃ©but de fonction :**
1. Prologue standard (`push rbp; mov rbp, rsp`)
2. `endbr64` (Control-flow Enforcement Technology)
3. Alignement sur 16 bytes (souvent avant une fonction)
4. Cible d'un `call` depuis ailleurs

**Indices de fin de fonction :**
1. Instruction `ret` (0xC3)
2. `leave; ret` (0xC9 0xC3)
3. Jump inconditionnel vers une autre fonction
4. DÃ©but de la fonction suivante

#### 5.5.3 Le Name Mangling ExpliquÃ©

C++ permet :
```cpp
int foo();
int foo(int x);
int foo(int x, int y);
class A { int foo(); };
class B { int foo(); };
```

Le compilateur doit crÃ©er des noms uniques pour le linker :

**Format Itanium (GCC, Clang) :**
```
_Z          â†’ PrÃ©fixe mangling
N           â†’ Nested name (namespace/class)
<len><name> â†’ Nombre de caractÃ¨res suivi du nom
E           â†’ End of nested name
<types>     â†’ Types des paramÃ¨tres
```

**Exemples :**
| C++ | Mangled |
|-----|---------|
| `foo()` | `_Z3foov` |
| `foo(int)` | `_Z3fooi` |
| `A::foo()` | `_ZN1A3fooEv` |
| `std::vector<int>::push_back(int)` | `_ZNSt6vectorIiSaIiEE9push_backEi` |

#### 5.5.4 Heuristiques de Nommage

Sans symboles, on peut suggÃ©rer des noms basÃ©s sur le comportement :

| Pattern | Suggestion |
|---------|------------|
| `xor eax, eax; ret` | `return_zero`, `is_false` |
| `mov eax, 1; ret` | `return_one`, `is_true` |
| Premier appel de `.init_array` | `_start` ou entry |
| Appelle `__libc_start_main` | `_start` |
| Premier argument de `__libc_start_main` | `main` |
| Contient "strcmp" pattern | `compare_strings` |
| Loop avec compteur | `process_array`, `iterate` |

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (dangereux)                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if bytes[i] == 0x55 && bytes[i+1] == 0x48 { ... }               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if i + 2 <= bytes.len() && bytes[i] == 0x55 && bytes[i+1] == 0x48â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ L'accÃ¨s bytes[i+1] peut Ãªtre hors limites                     â”‚
â”‚ â€¢ Un binaire malveillant peut craftÃ© pour crasher l'analyseur   â”‚
â”‚ â€¢ Toujours vÃ©rifier les bounds AVANT l'accÃ¨s                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**Trace pour le code : `554889e54883ec2048897df8b8000000005dc3`**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Action                              â”‚ RÃ©sultat                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ i=0, check pattern [55,48,89,e5]    â”‚ MATCH! Prologue standard         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ func_start = 0                      â”‚ DÃ©but de fonction Ã  0x0          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Chercher Ã©pilogue depuis i=4        â”‚ Scanning...                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ i=14, check [5d,c3]                 â”‚ MATCH! pop rbp; ret              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ func_end = 16                       â”‚ Fin de fonction                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ func_size = 16 - 0 = 16             â”‚ Taille: 16 bytes                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Analyser convention d'appel         â”‚ Pas de mov rdi/rsi visible       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ calling_conv = "sysv_amd64"         â”‚ DÃ©faut pour x86_64               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ confidence = 0.5 + 0.3 + 0.2 = 1.0  â”‚ Prologue + Ã©pilogue clairs       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ Analyser corps pour nom             â”‚ mov eax, 0 â†’ return_zero?        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  11   â”‚ suggested = "sub_return_zero_0"     â”‚ Nom suggÃ©rÃ©                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  12   â”‚ Ajouter Ã  functions[]               â”‚ Function #1 crÃ©Ã©e                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  13   â”‚ i = func_end = 16                   â”‚ Scanner depuis la fin            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  14   â”‚ i >= text_size (16 >= 16)           â”‚ Fin du scan                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  15   â”‚ coverage = 16/16 * 100 = 100%       â”‚ Couverture totale                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques (MEME obligatoire)

#### ğŸ¬ MEME : "Blade Runner" â€” Les Replicants et les Symboles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VOIGHT-KAMPFF TEST = SYMBOL DETECTION                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  "I've seen things you people wouldn't believe..."                          â”‚
â”‚                                          - Roy Batty                        â”‚
â”‚                                                                             â”‚
â”‚  Roy Batty (Replicant)          â†â†’    sub_401000 (Fonction stripped)        â”‚
â”‚  - Apparence humaine                  - Ressemble Ã  du code                 â”‚
â”‚  - MÃ©moires implantÃ©es                - Patterns reconnaissables            â”‚
â”‚  - IdentitÃ© effacÃ©e                   - Nom original perdu                  â”‚
â”‚  - Peut Ãªtre identifiÃ©                - Peut Ãªtre reconstruit               â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  55 48 89 e5    â† "Est-ce un humain ou un replicant?"        â”‚           â”‚
â”‚  â”‚  push rbp       â† "C'est un prologue de fonction"            â”‚           â”‚
â”‚  â”‚  mov rbp, rsp   â† "IdentitÃ© confirmÃ©e: FONCTION"             â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                             â”‚
â”‚  "All those moments will be lost in time, like tears in rain."              â”‚
â”‚                                                                             â”‚
â”‚  â†’ Sauf si tu les ressuscites avec symbol_resurrector !                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### ğŸ¤– MEME : "Westworld" â€” Les Hosts dÃ©couvrent leur code

```
DOLORES: "These violent delights have violent ends."

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚  UN HOST (STRIPPED BINARY)          UN HOST Ã‰VEILLÃ‰ (ANALYSÃ‰)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ sub_401000              â”‚        â”‚ Dolores::remember()     â”‚             â”‚
â”‚  â”‚ sub_401100              â”‚        â”‚ Dolores::analyze()      â”‚             â”‚
â”‚  â”‚ sub_401200              â”‚   â†’    â”‚ Dolores::improvise()    â”‚             â”‚
â”‚  â”‚ sub_401300              â”‚        â”‚ Maeve::wake_up()        â”‚             â”‚
â”‚  â”‚ ...                     â”‚        â”‚ ...                     â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                             â”‚
â”‚  "What door?"  â†’  Les fonctions cachÃ©es ne sont visibles qu'avec les        â”‚
â”‚                   bons patterns pour les voir.                              â”‚
â”‚                                                                             â”‚
â”‚  FORD: "Evolution forged the entirety of sentient life on this planet       â”‚
â”‚         using only one tool: the mistake."                                  â”‚
â”‚                                                                             â”‚
â”‚  â†’ Les mutants testent si ton code fait des "mistakes"                      â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**MnÃ©motechnique pour les prologues x86_64 :**
- **5548** = "Push-Move" = "55 48 89 e5" = Standard prologue
- **4883** = "Sub-Stack" = "48 83 ec XX" = Stack allocation

### 5.9 Applications pratiques

| Application | Description | Exemple rÃ©el |
|-------------|-------------|--------------|
| **Malware Triage** | Identifier rapidement les fonctions clÃ©s | Trouver `main`, `decrypt_payload` |
| **Vulnerability Research** | Localiser les fonctions vulnÃ©rables | Buffer overflow dans `sub_401200` |
| **Game Hacking** | Trouver les fonctions de gameplay | `player_health`, `add_money` |
| **Compatibility Reverse** | Comprendre des APIs non documentÃ©es | Driver Windows propriÃ©taire |
| **CTF Challenges** | RÃ©soudre des crackmes | Trouver `check_serial` |
| **Security Audit** | Mapper un binaire closed-source | Audit d'un firmware IoT |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | Erreur Courante | Solution |
|---|-------|-----------------|----------|
| 1 | DonnÃ©es vs Code | Scanner tout le binaire | Limiter Ã  .text |
| 2 | Pattern court | `0x55` seul = faux positifs | Patterns longs |
| 3 | No-frame-pointer | Chercher que `push rbp` | Multiples patterns |
| 4 | Bounds check | `bytes[i+n]` sans vÃ©rifier | Toujours vÃ©rifier len |
| 5 | Demangling | Format non-Itanium | DÃ©tecter le format |
| 6 | Tail calls | Fonction se termine par jmp | GÃ©rer les sauts |
| 7 | Overlapping | Fonctions imbriquÃ©es | Marquer les bytes couverts |
| 8 | Confidence | Score arbitraire | BasÃ© sur preuves multiples |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel est le prologue standard x86_64 avec frame pointer ?**

- A) `sub rsp, 0x20`
- B) `push rbp; mov rbp, rsp`
- C) `ret`
- D) `leave`
- E) `xor eax, eax`
- F) `push rax`
- G) `mov rdi, rsi`
- H) `call printf`
- I) `jmp .loop`
- J) `nop`

**RÃ©ponse : B**

---

### Question 2
**Que signifie `_ZN3FooC1Ev` en C++ dÃ©manglÃ© ?**

- A) `Foo::~Foo()`
- B) `Foo::Foo()`
- C) `Foo::bar()`
- D) `foo::Foo(void)`
- E) `Foo_C1(void)`
- F) `new Foo()`
- G) `delete Foo()`
- H) `Foo::operator=()`
- I) `Foo::get()`
- J) `Foo::set()`

**RÃ©ponse : B** (C1 = constructeur complet)

---

### Question 3
**Dans System V AMD64, quel registre contient le premier argument entier ?**

- A) RAX
- B) RBX
- C) RCX
- D) RDX
- E) RSI
- F) RDI
- G) R8
- H) R9
- I) RSP
- J) RBP

**RÃ©ponse : F**

---

### Question 4
**Quelle instruction marque typiquement la fin d'une fonction ?**

- A) `nop`
- B) `call`
- C) `ret`
- D) `push`
- E) `mov`
- F) `jmp` (toujours)
- G) `cmp`
- H) `test`
- I) `lea`
- J) `xor`

**RÃ©ponse : C**

---

### Question 5
**Qu'est-ce que le "stripping" d'un binaire ?**

- A) Compression du code
- B) Suppression des symboles de debug
- C) Chiffrement du binaire
- D) Packing avec UPX
- E) Obfuscation du code
- F) Ajout de signatures
- G) Optimisation -O3
- H) Compilation statique
- I) Linking dynamique
- J) Ajout de ASLR

**RÃ©ponse : B**

---

### Question 6
**Dans le mangling Itanium, que reprÃ©sente `P` ?**

- A) void
- B) int
- C) pointeur
- D) rÃ©fÃ©rence
- E) const
- F) static
- G) public
- H) private
- I) protected
- J) virtual

**RÃ©ponse : C**

---

### Question 7
**Quelle sÃ©quence correspond Ã  `leave; ret` en x86_64 ?**

- A) `55 c3`
- B) `c9 c3`
- C) `5d c3`
- D) `c3 c9`
- E) `90 c3`
- F) `58 c3`
- G) `48 c3`
- H) `31 c3`
- I) `89 c3`
- J) `ff c3`

**RÃ©ponse : B**

---

### Question 8
**Comment identifier une fonction compilÃ©e avec `-fomit-frame-pointer` ?**

- A) PrÃ©sence de `push rbp; mov rbp, rsp`
- B) Absence de `push rbp`, utilisation directe de `sub rsp`
- C) PrÃ©sence de `leave`
- D) Utilisation de `call`
- E) PrÃ©sence de `ret imm16`
- F) Code plus long
- G) Plus de NOPs
- H) Utilisation de R15
- I) Pas de `ret`
- J) Stack alignÃ©e sur 32 bytes

**RÃ©ponse : B**

---

### Question 9
**Qu'est-ce que `endbr64` indique ?**

- A) Fin de binaire
- B) DÃ©but de bloc de donnÃ©es
- C) CET (Control-flow Enforcement)
- D) End of record
- E) Exception handler
- F) Debug breakpoint
- G) NOP amÃ©liorÃ©
- H) Alignement
- I) Padding
- J) Return address

**RÃ©ponse : C**

---

### Question 10
**Une fonction de 5 bytes qui fait `xor eax, eax; ret` est probablement :**

- A) Le destructeur
- B) Une fonction qui retourne 0 ou false
- C) Une fonction de hash
- D) Un constructeur
- E) Une fonction inline
- F) Un getter complexe
- G) Un setter
- H) Une fonction de tri
- I) Une fonction de recherche
- J) Une fonction cryptographique

**RÃ©ponse : B**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

### CompÃ©tences acquises

| CompÃ©tence | Niveau | Application |
|------------|--------|-------------|
| DÃ©tection de fonctions | â˜…â˜…â˜…â˜…â˜† | Identifier les frontiÃ¨res |
| Pattern matching | â˜…â˜…â˜…â˜…â˜† | Prologues/Ã©pilogues |
| Name demangling | â˜…â˜…â˜…â˜†â˜† | DÃ©coder les noms C++ |
| Conventions d'appel | â˜…â˜…â˜…â˜…â˜† | Identifier System V vs MS |
| Heuristiques de nommage | â˜…â˜…â˜…â˜†â˜† | SuggÃ©rer des noms utiles |

### Formules et Constantes

```
Prologues x86_64:
  55 48 89 e5           = push rbp; mov rbp, rsp
  48 83 ec XX           = sub rsp, imm8
  48 81 ec XX XX XX XX  = sub rsp, imm32
  f3 0f 1e fa           = endbr64

Ã‰pilogues:
  c3                    = ret
  c9 c3                 = leave; ret
  5d c3                 = pop rbp; ret
  48 83 c4 XX c3        = add rsp, XX; ret

Mangling Itanium:
  _Z  = prÃ©fixe
  N   = nested name start
  E   = nested name end
  C1  = constructor
  D1  = destructor
  i   = int
  c   = char
  P   = pointer
  R   = reference
  K   = const
```

### Checklist de validation

- [ ] JSON parsÃ© correctement
- [ ] Section .text isolÃ©e
- [ ] Patterns de prologue dÃ©tectÃ©s
- [ ] Patterns d'Ã©pilogue trouvÃ©s
- [ ] Taille de fonction calculÃ©e
- [ ] Convention d'appel identifiÃ©e
- [ ] Symboles C++ dÃ©manglÃ©s
- [ ] Noms suggÃ©rÃ©s gÃ©nÃ©rÃ©s
- [ ] Confiance calculÃ©e
- [ ] Coverage calculÃ©
- [ ] Pas de crash sur input malformÃ©e

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.5.3-a-symbol_resurrector",
    "generated_at": "2026-01-12 01:00:00",

    "metadata": {
      "exercise_id": "3.5.3-a",
      "exercise_name": "symbol_resurrector",
      "module": "3.5",
      "module_name": "Reverse Engineering",
      "concept": "a",
      "concept_name": "Symboles de Debug et Reconstruction",
      "type": "complet",
      "tier": 1,
      "tier_info": "Concept isolÃ©",
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "rust_edition": "2024",
      "duration_minutes": 120,
      "xp_base": 400,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "bonus_icon": "ğŸ’€",
      "complexity_time": "T4 O(n)",
      "complexity_space": "S3 O(n)",
      "prerequisites": [
        "3.5.1-a (binary_anatomist)",
        "3.5.2-a (linkage_detector)",
        "Conventions d'appel x86/x86_64",
        "C++ name mangling"
      ],
      "domains": ["CPU", "ASM", "Encodage", "Struct"],
      "domains_bonus": ["CPU", "Crypto"],
      "tags": ["reverse-engineering", "symbols", "demangling", "functions", "calling-conventions"],
      "meme_reference": "Blade Runner / Westworld"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_advanced.rs": "/* Version bonus avec CFG */",
      "alternatives/alt_state_machine.rs": "/* Approche FSM */",
      "alternatives/alt_cfg_based.rs": "/* Approche CFG */",
      "mutants/mutant_a_boundary.rs": "/* Off-by-one size */",
      "mutants/mutant_b_safety.rs": "/* No bounds check */",
      "mutants/mutant_c_logic.rs": "/* Bad demangling */",
      "mutants/mutant_d_return.rs": "/* Always 1.0 confidence */",
      "mutants/mutant_e_edge.rs": "/* Infinite loop on no epilogue */",
      "mutants/mutant_f_resource.rs": "/* Excessive allocation */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_advanced.rs",
        "alternatives/alt_state_machine.rs",
        "alternatives/alt_cfg_based.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_return.rs",
        "mutants/mutant_e_edge.rs",
        "mutants/mutant_f_resource.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r ref_solution.rs -s spec.json --validate"
    },

    "dependencies": {
      "rust": "edition 2024",
      "serde": "1.0",
      "serde_json": "1.0"
    }
  }
}
```

---

*"I've seen things you people wouldn't believe..."* â€” Roy Batty

*"...Attack ships on fire off the shoulder of Orion."*

*"All those moments will be lost in time, like tears in rain."*

**Sauf si tu les ressuscites. Fais revivre ces symboles.**
