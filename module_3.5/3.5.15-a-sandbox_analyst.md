# Exercice 3.5.15-a : sandbox_analyst

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî D√©tection d'√âvasion de Sandbox

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.14
- Compr√©hension des sandboxes
- Notions de virtualisation

**Domaines :**
Process, FS, Net, Mem

**Dur√©e estim√©e :**
150 min

**XP Base :**
550

**Complexit√© :**
T5 O(n) √ó S3 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "The Truman Show" meets "Escape Room"

**"Good morning! And in case I don't see ya, good afternoon, good evening, and good night!"** ‚Äî Dans *The Truman Show*, Truman d√©couvre que son monde entier est un d√©cor. Le malware fait pareil : il teste si son environnement est r√©el ou simul√©.

Tu es le **Sandbox Analyst** ‚Äî tu d√©tectes les techniques d'√©vasion de sandbox dans le code analys√©.

**Ta mission :**

√âcrire une fonction `sandbox_evasion_detector` qui identifie les techniques utilis√©es par un sample pour d√©tecter une sandbox.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct SampleBehavior {
    pub api_calls: Vec<String>,
    pub registry_queries: Vec<String>,
    pub file_checks: Vec<String>,
    pub process_queries: Vec<String>,
    pub timing_operations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EvasionTechnique {
    pub name: String,
    pub category: String,
    pub evidence: Vec<String>,
    pub target_sandboxes: Vec<String>,
    pub deception_strategy: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EvasionReport {
    pub techniques: Vec<EvasionTechnique>,
    pub evasion_sophistication: String,
    pub sandbox_hardening_tips: Vec<String>,
}

pub fn sandbox_evasion_detector(behavior_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Techniques d'√âvasion de Sandbox

| Technique | M√©thode |
|-----------|---------|
| **Username check** | D√©tecte "sandbox", "malware", "virus" |
| **MAC address** | V√©rifie pr√©fixes VMware, VirtualBox |
| **Process list** | Cherche vmtoolsd.exe, vboxservice.exe |
| **Registry** | Cl√©s sp√©cifiques aux hyperviseurs |
| **Timing** | Sleep long pour timeout sandbox |
| **User interaction** | Attend clic souris, mouvement |
| **Hardware** | Nombre de CPU, RAM < 2GB |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct SampleBehavior {
    pub api_calls: Vec<String>,
    pub registry_queries: Vec<String>,
    pub file_checks: Vec<String>,
    pub process_queries: Vec<String>,
    pub timing_operations: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvasionTechnique {
    pub name: String,
    pub category: String,
    pub evidence: Vec<String>,
    pub target_sandboxes: Vec<String>,
    pub deception_strategy: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EvasionReport {
    pub techniques: Vec<EvasionTechnique>,
    pub evasion_sophistication: String,
    pub sandbox_hardening_tips: Vec<String>,
}

const VM_REGISTRY_KEYS: &[(&str, &[&str])] = &[
    ("HKLM\\SOFTWARE\\VMware", &["VMware"]),
    ("HKLM\\SOFTWARE\\Oracle\\VirtualBox", &["VirtualBox"]),
    ("HKLM\\HARDWARE\\ACPI\\DSDT\\VBOX", &["VirtualBox"]),
    ("HKLM\\SYSTEM\\ControlSet001\\Services\\VBoxGuest", &["VirtualBox"]),
];

const VM_PROCESSES: &[(&str, &[&str])] = &[
    ("vmtoolsd.exe", &["VMware"]),
    ("vmwaretray.exe", &["VMware"]),
    ("VBoxService.exe", &["VirtualBox"]),
    ("VBoxTray.exe", &["VirtualBox"]),
    ("vmsrvc.exe", &["Hyper-V"]),
    ("qemu-ga.exe", &["QEMU"]),
];

const VM_FILES: &[(&str, &[&str])] = &[
    ("C:\\Windows\\System32\\vmGuestLib.dll", &["VMware"]),
    ("C:\\Windows\\System32\\VBoxHook.dll", &["VirtualBox"]),
];

pub fn sandbox_evasion_detector(behavior_json: &str) -> Result<String, String> {
    let behavior: SampleBehavior = serde_json::from_str(behavior_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut techniques = Vec::new();

    // Registry-based detection
    for query in &behavior.registry_queries {
        for (key, sandboxes) in VM_REGISTRY_KEYS {
            if query.to_lowercase().contains(&key.to_lowercase()) {
                techniques.push(EvasionTechnique {
                    name: "Registry VM detection".to_string(),
                    category: "environment".to_string(),
                    evidence: vec![query.clone()],
                    target_sandboxes: sandboxes.iter().map(|s| s.to_string()).collect(),
                    deception_strategy: "Redirect registry queries to fake values".to_string(),
                });
            }
        }
    }

    // Process-based detection
    for proc in &behavior.process_queries {
        for (process, sandboxes) in VM_PROCESSES {
            if proc.to_lowercase().contains(&process.to_lowercase()) {
                techniques.push(EvasionTechnique {
                    name: "Process enumeration".to_string(),
                    category: "environment".to_string(),
                    evidence: vec![proc.clone()],
                    target_sandboxes: sandboxes.iter().map(|s| s.to_string()).collect(),
                    deception_strategy: "Hide VM processes from enumeration".to_string(),
                });
            }
        }
    }

    // File-based detection
    for file in &behavior.file_checks {
        for (vm_file, sandboxes) in VM_FILES {
            if file.to_lowercase().contains(&vm_file.to_lowercase()) {
                techniques.push(EvasionTechnique {
                    name: "File existence check".to_string(),
                    category: "environment".to_string(),
                    evidence: vec![file.clone()],
                    target_sandboxes: sandboxes.iter().map(|s| s.to_string()).collect(),
                    deception_strategy: "Remove or rename VM-specific files".to_string(),
                });
            }
        }
    }

    // Timing-based detection
    for timing in &behavior.timing_operations {
        if timing.contains("Sleep") || timing.contains("delay") {
            let duration = extract_sleep_duration(timing);
            if duration > 60000 { // > 1 minute
                techniques.push(EvasionTechnique {
                    name: "Long sleep evasion".to_string(),
                    category: "timing".to_string(),
                    evidence: vec![timing.clone()],
                    target_sandboxes: vec!["All".to_string()],
                    deception_strategy: "Accelerate sleep/timing APIs".to_string(),
                });
            }
        }
        if timing.contains("GetTickCount") || timing.contains("QueryPerformanceCounter") {
            techniques.push(EvasionTechnique {
                name: "Timing check".to_string(),
                category: "timing".to_string(),
                evidence: vec![timing.clone()],
                target_sandboxes: vec!["All".to_string()],
                deception_strategy: "Return consistent timing values".to_string(),
            });
        }
    }

    // User interaction detection
    for api in &behavior.api_calls {
        if api.contains("GetCursorPos") || api.contains("GetAsyncKeyState") {
            techniques.push(EvasionTechnique {
                name: "User interaction check".to_string(),
                category: "interaction".to_string(),
                evidence: vec![api.clone()],
                target_sandboxes: vec!["Automated sandboxes".to_string()],
                deception_strategy: "Simulate user activity".to_string(),
            });
        }
    }

    // Determine sophistication
    let sophistication = if techniques.len() >= 5 {
        "High - Multiple evasion techniques"
    } else if techniques.len() >= 2 {
        "Medium - Some evasion capabilities"
    } else if !techniques.is_empty() {
        "Low - Basic evasion"
    } else {
        "None detected"
    };

    // Hardening tips
    let tips = vec![
        "1. Use physical machines for analysis when possible".to_string(),
        "2. Install realistic software and documents".to_string(),
        "3. Simulate user activity (mouse movement, typing)".to_string(),
        "4. Rename VM processes and remove VM tools".to_string(),
        "5. Modify hardware IDs and MAC addresses".to_string(),
        "6. Use longer analysis timeouts".to_string(),
    ];

    let report = EvasionReport {
        techniques,
        evasion_sophistication: sophistication.to_string(),
        sandbox_hardening_tips: tips,
    };

    serde_json::to_string_pretty(&report)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn extract_sleep_duration(timing: &str) -> u64 {
    // Extract number from "Sleep(60000)" format
    if let Some(start) = timing.find('(') {
        if let Some(end) = timing.find(')') {
            if let Ok(dur) = timing[start+1..end].trim().parse::<u64>() {
                return dur;
            }
        }
    }
    0
}
```

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.15-a-sandbox-analyst",
    "metadata": {"exercise_id": "3.5.15-a", "difficulty": 9, "xp_base": 550}
  }
}
```

*Exercice 3.5.15-a ‚Äî Sandbox Analyst*
*"Is this the real life? Is this just fantasy?"*
*HACKBRAIN v5.5.2*
