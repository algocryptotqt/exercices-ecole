# Exercice 3.5.16-a : control_flow_deobfuscator

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” DÃ©obfuscation du Flux de ContrÃ´le

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.15
- ComprÃ©hension des graphes de flux
- Notions de compilation

**Domaines :**
CPU, ASM, Struct, MD

**DurÃ©e estimÃ©e :**
180 min

**XP Base :**
600

**ComplexitÃ© :**
T5 O(n) Ã— S4 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Inception" meets "The Maze Runner"

**"We need to go deeper."** â€” Dans *Inception*, Cobb navigue des rÃªves dans des rÃªves. Dans *The Maze Runner*, Thomas doit trouver la sortie d'un labyrinthe qui change constamment.

Tu es le **Control Flow Deobfuscator** â€” face Ã  toi, du code transformÃ© en labyrinthe par des obfuscateurs. Opaque predicates, bogus control flow, flattening â€” le code a Ã©tÃ© conÃ§u pour Ãªtre incomprÃ©hensible. Ta mission : restaurer la logique originale.

**Ta mission :**

Ã‰crire une fonction `deobfuscate_control_flow` qui analyse un CFG (Control Flow Graph) obfusquÃ© et identifie les patterns d'obfuscation.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicBlock {
    pub id: String,
    pub instructions: Vec<String>,
    pub successors: Vec<String>,
    pub predecessors: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ObfuscatedCFG {
    pub blocks: HashMap<String, BasicBlock>,
    pub entry: String,
    pub exits: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObfuscationPattern {
    pub pattern_type: String,       // "opaque_predicate", "bogus_flow", "flattening", "dispatcher"
    pub affected_blocks: Vec<String>,
    pub confidence: f64,
    pub description: String,
    pub simplification_hint: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DeobfuscationReport {
    pub patterns_found: Vec<ObfuscationPattern>,
    pub simplified_edges: Vec<(String, String)>,  // Edges that can be removed
    pub dead_blocks: Vec<String>,
    pub original_structure_hint: String,
    pub obfuscation_level: String,
}

pub fn deobfuscate_control_flow(cfg_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Techniques d'Obfuscation du Flux

| Technique | Description | DifficultÃ© |
|-----------|-------------|------------|
| **Opaque Predicates** | Conditions toujours vraies/fausses | Moyenne |
| **Bogus Control Flow** | Faux chemins jamais exÃ©cutÃ©s | Moyenne |
| **Control Flow Flattening** | Tous les blocs au mÃªme niveau | Haute |
| **Dispatcher Pattern** | Switch gÃ©ant avec Ã©tat | TrÃ¨s haute |
| **Loop Unrolling** | Boucles dÃ©roulÃ©es + faux sauts | Moyenne |

### 2.2 Indicateurs d'Obfuscation

```
OPAQUE PREDICATE :
if (x * (x + 1) % 2 == 0)  // Toujours vrai !
    real_code();
else
    dead_code();

CONTROL FLOW FLATTENING :
while (1) {
    switch (state) {
        case 0: ... state = 3; break;
        case 1: ... state = 7; break;
        case 2: ... state = 1; break;
        ...
    }
}
```

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Malware Analyst** | DÃ©obfusquer des samples protÃ©gÃ©s |
| **Security Researcher** | Analyser des protections commerciales |
| **Compiler Engineer** | Optimiser le code dÃ©sobfusquÃ© |
| **CTF Player** | RÃ©soudre des challenges reverse |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicBlock {
    pub id: String,
    pub instructions: Vec<String>,
    pub successors: Vec<String>,
    pub predecessors: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ObfuscatedCFG {
    pub blocks: HashMap<String, BasicBlock>,
    pub entry: String,
    pub exits: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObfuscationPattern {
    pub pattern_type: String,
    pub affected_blocks: Vec<String>,
    pub confidence: f64,
    pub description: String,
    pub simplification_hint: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DeobfuscationReport {
    pub patterns_found: Vec<ObfuscationPattern>,
    pub simplified_edges: Vec<(String, String)>,
    pub dead_blocks: Vec<String>,
    pub original_structure_hint: String,
    pub obfuscation_level: String,
}

// Opaque predicate patterns (always true/false)
const OPAQUE_PATTERNS: &[&str] = &[
    "x * (x + 1) % 2",     // Always even
    "x | (x - 1)",         // Common opaque
    "x ^ x",               // Always 0
    "(x & 1) | ((x + 1) & 1)", // Always 1
];

pub fn deobfuscate_control_flow(cfg_json: &str) -> Result<String, String> {
    let cfg: ObfuscatedCFG = serde_json::from_str(cfg_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut patterns = Vec::new();
    let mut simplified_edges = Vec::new();
    let mut dead_blocks = Vec::new();

    // Detect Control Flow Flattening
    if let Some(pattern) = detect_flattening(&cfg) {
        patterns.push(pattern);
    }

    // Detect Opaque Predicates
    for (id, block) in &cfg.blocks {
        if let Some(pattern) = detect_opaque_predicate(id, block) {
            patterns.push(pattern);
        }
    }

    // Detect Bogus Control Flow
    let (bogus_patterns, bogus_dead) = detect_bogus_flow(&cfg);
    patterns.extend(bogus_patterns);
    dead_blocks.extend(bogus_dead);

    // Detect Dispatcher Pattern
    if let Some(pattern) = detect_dispatcher(&cfg) {
        patterns.push(pattern);
    }

    // Find unreachable blocks
    let reachable = find_reachable(&cfg);
    for id in cfg.blocks.keys() {
        if !reachable.contains(id) && !dead_blocks.contains(id) {
            dead_blocks.push(id.clone());
        }
    }

    // Determine obfuscation level
    let level = if patterns.len() >= 4 {
        "Heavily obfuscated"
    } else if patterns.len() >= 2 {
        "Moderately obfuscated"
    } else if patterns.len() >= 1 {
        "Lightly obfuscated"
    } else {
        "Clean or unknown obfuscation"
    };

    // Structure hint
    let hint = if patterns.iter().any(|p| p.pattern_type == "flattening") {
        "Original structure likely had nested loops/conditionals - reconstruct state machine"
    } else if patterns.iter().any(|p| p.pattern_type == "opaque_predicate") {
        "Remove opaque predicates to reveal linear flow"
    } else {
        "Analyze data flow to identify true control dependencies"
    };

    let report = DeobfuscationReport {
        patterns_found: patterns,
        simplified_edges,
        dead_blocks,
        original_structure_hint: hint.to_string(),
        obfuscation_level: level.to_string(),
    };

    serde_json::to_string_pretty(&report)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn detect_flattening(cfg: &ObfuscatedCFG) -> Option<ObfuscationPattern> {
    // Look for a dispatcher block with many successors
    for (id, block) in &cfg.blocks {
        if block.successors.len() > 5 {
            // Check if it looks like a switch dispatcher
            let has_switch = block.instructions.iter()
                .any(|i| i.contains("switch") || i.contains("jmp table"));

            let has_state_var = block.instructions.iter()
                .any(|i| i.contains("state") || i.contains("_s") || i.contains("dispatch"));

            if has_switch || has_state_var || block.successors.len() > 8 {
                return Some(ObfuscationPattern {
                    pattern_type: "flattening".to_string(),
                    affected_blocks: vec![id.clone()],
                    confidence: 0.85,
                    description: format!(
                        "Dispatcher block '{}' with {} successors suggests control flow flattening",
                        id, block.successors.len()
                    ),
                    simplification_hint: "Trace state variable to reconstruct original CFG".to_string(),
                });
            }
        }
    }
    None
}

fn detect_opaque_predicate(id: &str, block: &BasicBlock) -> Option<ObfuscationPattern> {
    for instr in &block.instructions {
        let instr_lower = instr.to_lowercase();

        // Check for known opaque patterns
        for pattern in OPAQUE_PATTERNS {
            if instr_lower.contains(pattern) {
                return Some(ObfuscationPattern {
                    pattern_type: "opaque_predicate".to_string(),
                    affected_blocks: vec![id.to_string()],
                    confidence: 0.9,
                    description: format!(
                        "Opaque predicate detected: '{}' is always deterministic",
                        pattern
                    ),
                    simplification_hint: "Replace conditional with unconditional jump".to_string(),
                });
            }
        }

        // Check for comparison with constant that's always true/false
        if instr_lower.contains("cmp") && instr_lower.contains("0x7fffffff") {
            return Some(ObfuscationPattern {
                pattern_type: "opaque_predicate".to_string(),
                affected_blocks: vec![id.to_string()],
                confidence: 0.7,
                description: "Suspicious comparison with MAX_INT".to_string(),
                simplification_hint: "Verify if condition is constant".to_string(),
            });
        }
    }
    None
}

fn detect_bogus_flow(cfg: &ObfuscatedCFG) -> (Vec<ObfuscationPattern>, Vec<String>) {
    let mut patterns = Vec::new();
    let mut dead = Vec::new();

    for (id, block) in &cfg.blocks {
        // Check for blocks that only contain junk
        let is_junk = block.instructions.iter().all(|i| {
            let lower = i.to_lowercase();
            lower.contains("nop") ||
            lower.contains("xchg") && lower.contains("same") ||
            lower.contains("lea") && lower.contains("same") ||
            lower.is_empty()
        });

        if is_junk && !block.successors.is_empty() {
            patterns.push(ObfuscationPattern {
                pattern_type: "bogus_flow".to_string(),
                affected_blocks: vec![id.clone()],
                confidence: 0.8,
                description: format!("Block '{}' contains only junk instructions", id),
                simplification_hint: "Remove block and redirect predecessors".to_string(),
            });
            dead.push(id.clone());
        }

        // Check for unreferenced blocks with suspicious content
        if block.predecessors.is_empty() && id != &cfg.entry {
            dead.push(id.clone());
        }
    }

    (patterns, dead)
}

fn detect_dispatcher(cfg: &ObfuscatedCFG) -> Option<ObfuscationPattern> {
    // Look for state machine pattern
    let mut state_blocks = Vec::new();

    for (id, block) in &cfg.blocks {
        let has_state_update = block.instructions.iter().any(|i| {
            let lower = i.to_lowercase();
            (lower.contains("mov") || lower.contains("store")) &&
            (lower.contains("state") || lower.contains("_s"))
        });

        if has_state_update && block.successors.len() == 1 {
            // Block updates state and jumps back to dispatcher
            state_blocks.push(id.clone());
        }
    }

    if state_blocks.len() >= 3 {
        Some(ObfuscationPattern {
            pattern_type: "dispatcher".to_string(),
            affected_blocks: state_blocks,
            confidence: 0.75,
            description: "State machine dispatcher pattern detected".to_string(),
            simplification_hint: "Build state transition graph and simplify".to_string(),
        })
    } else {
        None
    }
}

fn find_reachable(cfg: &ObfuscatedCFG) -> HashSet<String> {
    let mut reachable = HashSet::new();
    let mut worklist = vec![cfg.entry.clone()];

    while let Some(block_id) = worklist.pop() {
        if reachable.insert(block_id.clone()) {
            if let Some(block) = cfg.blocks.get(&block_id) {
                for succ in &block.successors {
                    if !reachable.contains(succ) {
                        worklist.push(succ.clone());
                    }
                }
            }
        }
    }

    reachable
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
        AVANT DÃ‰SOBFUSCATION (Flattened)

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  DISPATCHER â”‚
                    â”‚  switch(s)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚       â”‚       â”‚       â”‚       â”‚
           â–¼       â–¼       â–¼       â–¼       â–¼
        â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
        â”‚ s=0 â”‚ â”‚ s=1 â”‚ â”‚ s=2 â”‚ â”‚ s=3 â”‚ â”‚ s=4 â”‚
        â”‚ ... â”‚ â”‚ ... â”‚ â”‚ ... â”‚ â”‚ ... â”‚ â”‚ ... â”‚
        â”‚s=3  â”‚ â”‚s=2  â”‚ â”‚s=4  â”‚ â”‚s=1  â”‚ â”‚EXIT â”‚
        â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜
           â”‚       â”‚       â”‚       â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
               (back to dispatcher)


        APRÃˆS DÃ‰SOBFUSCATION (Original)

                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  START  â”‚
                â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ Block A â”‚  (was s=0)
                â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”Œâ”€â”€â”€â”€â”‚ Block B â”‚â”€â”€â”€â”€â”  (was s=3)
           â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
           â–¼                   â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Block C â”‚         â”‚ Block D â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
           â”‚                   â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   END   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.5 Cours Complet : La DÃ©sobfuscation du Flux

#### Qu'est-ce que l'obfuscation du flux de contrÃ´le ?

L'obfuscation du flux de contrÃ´le transforme la structure logique d'un programme
pour la rendre incomprÃ©hensible tout en prÃ©servant son comportement.

#### Les Techniques Principales

**1. Opaque Predicates**

```c
// Code original
do_something();

// ObfusquÃ© avec opaque predicate
if ((x * (x + 1)) % 2 == 0) {  // TOUJOURS VRAI
    do_something();
} else {
    fake_code();  // Jamais exÃ©cutÃ©
}
```

L'expression `x * (x + 1)` est toujours paire car soit x soit x+1 est pair.

**2. Control Flow Flattening**

```c
// Code original
void func() {
    A();
    if (cond) {
        B();
    } else {
        C();
    }
    D();
}

// AprÃ¨s flattening
void func() {
    int state = 0;
    while (1) {
        switch (state) {
            case 0: A(); state = 1; break;
            case 1: state = cond ? 2 : 3; break;
            case 2: B(); state = 4; break;
            case 3: C(); state = 4; break;
            case 4: D(); return;
        }
    }
}
```

**3. Bogus Control Flow**

Ajout de faux chemins qui ne seront jamais exÃ©cutÃ©s pour augmenter
la complexitÃ© apparente du CFG.

---

## ğŸ“ SECTION 7 : QCM

### Q1. Qu'est-ce qu'un opaque predicate ?
A) Une condition dont le rÃ©sultat est connu Ã  la compilation
B) Un prÃ©dicat invisible
C) Une condition alÃ©atoire
D) Un jump indirect

**RÃ©ponse : A**

### Q2. Le control flow flattening transforme le code en...
A) Boucle infinie
B) Machine Ã  Ã©tats avec dispatcher
C) Code rÃ©cursif
D) Code parallÃ¨le

**RÃ©ponse : B**

### Q3. Comment dÃ©tecter un dispatcher de flattening ?
A) Par son nom de variable
B) Par le nombre Ã©levÃ© de successeurs
C) Par la taille du bloc
D) Par les registres utilisÃ©s

**RÃ©ponse : B**

### Q4. Un bloc "dead code" dans un CFG obfusquÃ© est...
A) Du code qui crashe
B) Du code jamais atteint
C) Du code lent
D) Du code commentÃ©

**RÃ©ponse : B**

### Q5. L'expression `x ^ x` vaut toujours...
A) x
B) 2x
C) 0
D) 1

**RÃ©ponse : C**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.16-a-control-flow-deobfuscator",
    "metadata": {
      "exercise_id": "3.5.16-a",
      "difficulty": 9,
      "xp_base": 600
    }
  }
}
```

*Exercice 3.5.16-a â€” Control Flow Deobfuscator*
*"Find your way out of the maze."*
*HACKBRAIN v5.5.2*
