# Exercice 3.5.10-a : frida_master

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” Dynamic Instrumentation avec Frida

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024 + JavaScript (Frida)

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.9
- JavaScript de base
- ComprÃ©hension du hooking

**Domaines :**
Process, Mem, Net, Crypto

**DurÃ©e estimÃ©e :**
150 min

**XP Base :**
550

**ComplexitÃ© :**
T5 O(n) Ã— S4 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
- `frida_master.rs`
- `hook_script.js`

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Inception" meets "The Matrix"

**"We need to go deeper."** â€” Dans *Inception*, Dom Cobb injecte des idÃ©es dans les rÃªves. Dans *The Matrix*, les agents modifient la rÃ©alitÃ© en temps rÃ©el.

Tu es le **Frida Master** â€” tu peux t'injecter dans n'importe quel processus et modifier son comportement en temps rÃ©el. Hooker une fonction, intercepter des donnÃ©es, changer des retours â€” tout est possible sans modifier le binaire sur disque.

**"You take the red pill, you stay in Frida-land."**

**Ta mission :**

Partie 1 (Rust): Parser et analyser les logs de scripts Frida.
Partie 2 (JS): Ã‰crire des hooks Frida pour diffÃ©rents scÃ©narios.

**EntrÃ©e (Rust) :**
- `frida_log_json` : JSON contenant :
  - `hooks` : Liste des hooks actifs
  - `intercepted_calls` : Appels interceptÃ©s
  - `modified_returns` : Retours modifiÃ©s
  - `memory_reads` : Lectures mÃ©moire

**Sortie (Rust) :**
- JSON contenant :
  - `call_summary` : RÃ©sumÃ© des appels par fonction
  - `data_flow` : Flux de donnÃ©es dÃ©tectÃ©
  - `security_findings` : DÃ©couvertes sÃ©curitÃ©
  - `suggested_hooks` : Hooks supplÃ©mentaires suggÃ©rÃ©s

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct FridaHook {
    pub module: String,
    pub function: String,
    pub address: Option<String>,
    pub hook_type: String,  // "onEnter", "onLeave", "replace"
}

#[derive(Debug, Serialize, Deserialize)]
pub struct InterceptedCall {
    pub function: String,
    pub args: Vec<String>,
    pub return_value: Option<String>,
    pub timestamp: u64,
    pub backtrace: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FridaLog {
    pub hooks: Vec<FridaHook>,
    pub intercepted_calls: Vec<InterceptedCall>,
    pub modified_returns: Vec<(String, String, String)>,
    pub memory_reads: Vec<(String, String)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FridaAnalysis {
    pub call_summary: HashMap<String, u64>,
    pub data_flow: Vec<String>,
    pub security_findings: Vec<String>,
    pub suggested_hooks: Vec<String>,
}

pub fn frida_analyzer(frida_log_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Frida est le Couteau Suisse du RE Dynamique

| CapacitÃ© | Description |
|----------|-------------|
| **Injection** | S'injecte dans n'importe quel process |
| **Hooking** | Intercepte appels de fonctions |
| **Stalker** | Trace instruction par instruction |
| **Memory** | Lit/Ã©crit mÃ©moire arbitraire |
| **Cross-platform** | Windows, macOS, Linux, iOS, Android |

### 2.2 Modes d'Utilisation

```
frida -U app         # USB (mobile)
frida -p 1234        # Attach to PID
frida -f ./binary    # Spawn and attach
frida-trace -i open* # Auto-trace
```

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo build --release
$ ./target/release/test
Test 1 (call_count): malloc called 47 times â†’ OK
Test 2 (data_flow): password flow detected â†’ OK
Test 3 (suggestions): suggested SSL_read hook â†’ OK
Tous les tests passent!
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FridaHook {
    pub module: String,
    pub function: String,
    pub address: Option<String>,
    pub hook_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InterceptedCall {
    pub function: String,
    pub args: Vec<String>,
    pub return_value: Option<String>,
    pub timestamp: u64,
    pub backtrace: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FridaLog {
    pub hooks: Vec<FridaHook>,
    pub intercepted_calls: Vec<InterceptedCall>,
    pub modified_returns: Vec<(String, String, String)>,
    pub memory_reads: Vec<(String, String)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FridaAnalysis {
    pub call_summary: HashMap<String, u64>,
    pub data_flow: Vec<String>,
    pub security_findings: Vec<String>,
    pub suggested_hooks: Vec<String>,
}

const CRYPTO_FUNCTIONS: &[&str] = &[
    "AES", "DES", "RSA", "encrypt", "decrypt",
    "SSL_read", "SSL_write", "EVP_", "CRYPTO_",
];

const SENSITIVE_FUNCTIONS: &[&str] = &[
    "password", "secret", "key", "token", "auth",
    "credential", "private", "session",
];

pub fn frida_analyzer(frida_log_json: &str) -> Result<String, String> {
    let log: FridaLog = serde_json::from_str(frida_log_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut call_summary: HashMap<String, u64> = HashMap::new();
    let mut data_flow = Vec::new();
    let mut security_findings = Vec::new();
    let mut suggested_hooks = Vec::new();
    let mut hooked_functions: std::collections::HashSet<String> = std::collections::HashSet::new();

    // Track currently hooked functions
    for hook in &log.hooks {
        hooked_functions.insert(hook.function.clone());
    }

    // Analyze intercepted calls
    for call in &log.intercepted_calls {
        *call_summary.entry(call.function.clone()).or_insert(0) += 1;

        // Check for sensitive data in args
        for arg in &call.args {
            let arg_lower = arg.to_lowercase();

            for sensitive in SENSITIVE_FUNCTIONS {
                if arg_lower.contains(sensitive) {
                    data_flow.push(format!(
                        "Sensitive data '{}' passed to {}()",
                        sensitive, call.function
                    ));
                }
            }
        }

        // Check for crypto operations
        for crypto in CRYPTO_FUNCTIONS {
            if call.function.contains(crypto) {
                security_findings.push(format!(
                    "Crypto operation detected: {} with args {:?}",
                    call.function, call.args
                ));
            }
        }

        // Detect potential vulnerabilities
        if call.function == "strcpy" || call.function == "strcat" {
            security_findings.push(format!(
                "Unsafe function {} called - potential buffer overflow",
                call.function
            ));
        }

        if call.function == "system" || call.function == "popen" {
            security_findings.push(format!(
                "Shell execution via {} - check for command injection",
                call.function
            ));
        }
    }

    // Suggest additional hooks based on findings
    let common_interesting = [
        ("recv", "Network receive"),
        ("send", "Network send"),
        ("SSL_read", "Encrypted receive"),
        ("SSL_write", "Encrypted send"),
        ("open", "File operations"),
        ("fopen", "File operations"),
        ("connect", "Network connections"),
        ("strcmp", "String comparisons (auth?)"),
        ("memcmp", "Memory comparisons (crypto?)"),
    ];

    for (func, reason) in common_interesting {
        if !hooked_functions.contains(func) {
            // Check if related calls exist
            let should_suggest = log.intercepted_calls.iter().any(|c| {
                c.function.contains("socket") || c.function.contains("SSL") || c.function.contains("file")
            });

            if should_suggest || call_summary.len() < 10 {
                suggested_hooks.push(format!("{} - {}", func, reason));
            }
        }
    }

    // Analyze modified returns
    for (func, original, modified) in &log.modified_returns {
        security_findings.push(format!(
            "Return value of {} modified: {} â†’ {} (potential bypass)",
            func, original, modified
        ));
    }

    // Analyze memory reads
    for (addr, value) in &log.memory_reads {
        if value.len() > 100 || value.contains("password") || value.contains("key") {
            data_flow.push(format!("Interesting memory at {}: {}...", addr, &value[..value.len().min(50)]));
        }
    }

    let result = FridaAnalysis {
        call_summary,
        data_flow,
        security_findings,
        suggested_hooks,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

### 4.4 Script Frida Exemple

```javascript
// hook_script.js - Exemple de hooks Frida

// Hook une fonction native
Interceptor.attach(Module.getExportByName(null, "strcmp"), {
    onEnter: function(args) {
        this.arg0 = args[0].readUtf8String();
        this.arg1 = args[1].readUtf8String();
        console.log("[strcmp] Comparing: '" + this.arg0 + "' vs '" + this.arg1 + "'");
    },
    onLeave: function(retval) {
        console.log("[strcmp] Result: " + retval);
    }
});

// Hook SSL_read pour intercepter donnÃ©es dÃ©chiffrÃ©es
var SSL_read = Module.getExportByName("libssl.so", "SSL_read");
if (SSL_read) {
    Interceptor.attach(SSL_read, {
        onLeave: function(retval) {
            if (retval.toInt32() > 0) {
                var buf = this.context.rsi; // buffer argument
                var data = buf.readByteArray(retval.toInt32());
                console.log("[SSL_read] Decrypted: " + hexdump(data));
            }
        }
    });
}

// Modifier un retour de fonction (bypass auth)
Interceptor.replace(Module.getExportByName(null, "check_password"), new NativeCallback(function() {
    console.log("[BYPASS] check_password always returns 1");
    return 1;
}, 'int', []));

// Tracer les allocations mÃ©moire
Interceptor.attach(Module.getExportByName(null, "malloc"), {
    onEnter: function(args) {
        this.size = args[0].toInt32();
    },
    onLeave: function(retval) {
        console.log("[malloc] " + this.size + " bytes at " + retval);
    }
});
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
            ARCHITECTURE FRIDA

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           FRIDA CLIENT                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚     Python / Node.js / CLI          â”‚   â”‚
    â”‚  â”‚     (your control script)           â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ JSON-RPC
                           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           FRIDA SERVER                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚          frida-server               â”‚   â”‚
    â”‚  â”‚       (runs on target device)       â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ injection
                           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           TARGET PROCESS                    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚          frida-agent                â”‚   â”‚
    â”‚  â”‚    (JavaScript runtime: V8/Duktape) â”‚   â”‚
    â”‚  â”‚                                     â”‚   â”‚
    â”‚  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   â”‚
    â”‚  â”‚    â”‚ Hooks   â”‚    â”‚ Memory  â”‚      â”‚   â”‚
    â”‚  â”‚    â”‚         â”‚    â”‚ Access  â”‚      â”‚   â”‚
    â”‚  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    HOOK FLOW

    Original:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  caller  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ function â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    With Frida Hook:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  caller  â”‚â”€â”€â”€â–ºâ”‚ onEnter  â”‚â”€â”€â”€â–ºâ”‚ function â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  (hook)  â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
                         â–²               â”‚
                         â”‚               â–¼
                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ onLeave  â”‚â—„â”€â”€â”€â”‚  return  â”‚
                    â”‚  (hook)  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ’‰ MEME : "I'm in your process, hooking your functions"

```javascript
// Comme le meme "I'm in ur base, killing ur d00ds"
Interceptor.attach(target, {
    onEnter: function(args) {
        console.log("I'm in ur function, logging ur args");
    }
});
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Frida utilise quel moteur JavaScript ?**

A) SpiderMonkey
B) V8/Duktape
C) JavaScriptCore
D) Chakra

**RÃ©ponse : B**

### Question 2
**Pour modifier la valeur de retour d'une fonction avec Frida, on utilise :**

A) Interceptor.attach avec onEnter
B) Interceptor.attach avec onLeave et retval.replace()
C) Interceptor.detach
D) Memory.write

**RÃ©ponse : B**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.10-a-frida-master",
    "metadata": {
      "exercise_id": "3.5.10-a",
      "difficulty": 9,
      "xp_base": 550
    }
  }
}
```

---

*Exercice 3.5.10-a â€” Frida Master*
*"Inject. Hook. Control."*
*HACKBRAIN v5.5.2*
