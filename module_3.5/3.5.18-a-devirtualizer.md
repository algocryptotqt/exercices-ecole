# Exercice 3.5.18-a : devirtualizer

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” DÃ©virtualisation de Code ProtÃ©gÃ©

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… (10/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.17
- ComprÃ©hension des machines virtuelles
- Architecture des interprÃ©teurs

**Domaines :**
CPU, ASM, Mem, Struct

**DurÃ©e estimÃ©e :**
240 min

**XP Base :**
750

**ComplexitÃ© :**
T6 O(n) Ã— S5 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "The Matrix" meets "Inception" meets "TRON"

**"What is the Matrix? Control."** â€” Dans *The Matrix*, la rÃ©alitÃ© est simulÃ©e. Dans *TRON*, les programmes vivent dans une couche virtuelle. Dans *Inception*, les rÃªves s'empilent.

Tu es le **Devirtualizer** â€” face Ã  toi, du code transformÃ© en bytecode propriÃ©taire, exÃ©cutÃ© par une VM custom. VMProtect, Themida, custom VMs â€” le code natif original a Ã©tÃ© traduit en un langage que seul l'obfuscateur comprend. Ta mission : reconstruire le code original.

**Ta mission :**

Ã‰crire une fonction `devirtualize` qui analyse le bytecode d'une VM custom et tente de reconstruire la sÃ©mantique originale.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VMBytecode {
    pub code: Vec<u8>,
    pub handlers: Vec<VMHandler>,
    pub entry_offset: u64,
    pub vm_context_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VMHandler {
    pub opcode: u8,
    pub name: String,
    pub semantics: String,  // "push", "pop", "add", "xor", "jmp", etc.
    pub operand_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodedInstruction {
    pub offset: u64,
    pub opcode: u8,
    pub operands: Vec<u64>,
    pub semantics: String,
    pub native_equivalent: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DevirtualizationResult {
    pub instructions: Vec<DecodedInstruction>,
    pub reconstructed_asm: Vec<String>,
    pub vm_type_guess: String,
    pub handler_analysis: HashMap<u8, HandlerAnalysis>,
    pub complexity_score: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HandlerAnalysis {
    pub frequency: usize,
    pub likely_native: String,
    pub confidence: f64,
}

pub fn devirtualize(vm_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Types de Virtualisation

| Type | Description | DifficultÃ© |
|------|-------------|------------|
| **Stack-based VM** | Comme JVM, opÃ©rations sur pile | Moyenne |
| **Register-based VM** | Comme Dalvik, registres virtuels | Haute |
| **Threaded code** | Direct threading, indirect | Haute |
| **Mixed** | Combine plusieurs approches | TrÃ¨s haute |

### 2.2 Protecteurs Commerciaux

| Protecteur | VM Type | CaractÃ©ristiques |
|------------|---------|-----------------|
| **VMProtect** | Stack | Handlers polymorphes |
| **Themida** | Stack | Code Virtualizer intÃ©grÃ© |
| **Code Virtualizer** | Stack | Multiple VM instances |
| **Obsidium** | Mixed | Anti-debug intÃ©grÃ© |

### 2.3 Composants d'une VM Protectrice

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VM ARCHITECTURE                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  BYTECODE   â”‚â”€â”€â”€â”€â–ºâ”‚  DISPATCHER â”‚â”€â”€â”€â”€â–ºâ”‚ HANDLERS  â”‚  â”‚
â”‚  â”‚  (opcodes)  â”‚     â”‚  (fetch/    â”‚     â”‚ (execute) â”‚  â”‚
â”‚  â”‚             â”‚     â”‚   decode)   â”‚     â”‚           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                    â”‚       â”‚
â”‚                             â–¼                    â–¼       â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                      â”‚ VM CONTEXT  â”‚     â”‚  NATIVE   â”‚  â”‚
â”‚                      â”‚ (vIP, vSP,  â”‚     â”‚   CODE    â”‚  â”‚
â”‚                      â”‚  vRegs)     â”‚     â”‚  (result) â”‚  â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Malware Analyst** | Analyser samples VMProtect |
| **Game Hacker** | Contourner DRM virtualisÃ© |
| **Security Researcher** | Ã‰valuer protections commerciales |
| **Reverse Engineer** | Comprendre le code protÃ©gÃ© |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VMBytecode {
    pub code: Vec<u8>,
    pub handlers: Vec<VMHandler>,
    pub entry_offset: u64,
    pub vm_context_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VMHandler {
    pub opcode: u8,
    pub name: String,
    pub semantics: String,
    pub operand_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodedInstruction {
    pub offset: u64,
    pub opcode: u8,
    pub operands: Vec<u64>,
    pub semantics: String,
    pub native_equivalent: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DevirtualizationResult {
    pub instructions: Vec<DecodedInstruction>,
    pub reconstructed_asm: Vec<String>,
    pub vm_type_guess: String,
    pub handler_analysis: HashMap<u8, HandlerAnalysis>,
    pub complexity_score: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HandlerAnalysis {
    pub frequency: usize,
    pub likely_native: String,
    pub confidence: f64,
}

// Semantic to native mapping
const SEMANTICS_TO_NATIVE: &[(&str, &str)] = &[
    ("push_imm", "push {imm}"),
    ("push_reg", "push {reg}"),
    ("pop_reg", "pop {reg}"),
    ("add", "add"),
    ("sub", "sub"),
    ("xor", "xor"),
    ("and", "and"),
    ("or", "or"),
    ("mov_reg_reg", "mov {dst}, {src}"),
    ("mov_reg_imm", "mov {dst}, {imm}"),
    ("load", "mov {dst}, [{addr}]"),
    ("store", "mov [{addr}], {src}"),
    ("jmp", "jmp {target}"),
    ("jz", "jz {target}"),
    ("jnz", "jnz {target}"),
    ("call", "call {target}"),
    ("ret", "ret"),
    ("nop", "nop"),
];

pub fn devirtualize(vm_json: &str) -> Result<String, String> {
    let vm: VMBytecode = serde_json::from_str(vm_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    // Build handler lookup
    let handler_map: HashMap<u8, &VMHandler> = vm.handlers.iter()
        .map(|h| (h.opcode, h))
        .collect();

    let mut instructions = Vec::new();
    let mut handler_stats: HashMap<u8, usize> = HashMap::new();
    let mut offset = vm.entry_offset as usize;

    // Decode bytecode
    while offset < vm.code.len() {
        let opcode = vm.code[offset];

        if let Some(handler) = handler_map.get(&opcode) {
            // Track handler frequency
            *handler_stats.entry(opcode).or_insert(0) += 1;

            // Read operands
            let mut operands = Vec::new();
            let mut op_offset = offset + 1;

            for _ in 0..handler.operand_size {
                if op_offset < vm.code.len() {
                    operands.push(vm.code[op_offset] as u64);
                    op_offset += 1;
                }
            }

            // Map to native equivalent
            let native = map_to_native(&handler.semantics, &operands);

            instructions.push(DecodedInstruction {
                offset: offset as u64,
                opcode,
                operands: operands.clone(),
                semantics: handler.semantics.clone(),
                native_equivalent: native,
            });

            offset = op_offset;
        } else {
            // Unknown opcode
            instructions.push(DecodedInstruction {
                offset: offset as u64,
                opcode,
                operands: vec![],
                semantics: "unknown".to_string(),
                native_equivalent: format!("db 0x{:02X}", opcode),
            });
            offset += 1;
        }
    }

    // Analyze handlers
    let mut handler_analysis = HashMap::new();
    for (opcode, freq) in &handler_stats {
        if let Some(handler) = handler_map.get(opcode) {
            let native = find_likely_native(&handler.semantics);
            handler_analysis.insert(*opcode, HandlerAnalysis {
                frequency: *freq,
                likely_native: native.to_string(),
                confidence: calculate_confidence(&handler.semantics, *freq),
            });
        }
    }

    // Reconstruct assembly
    let reconstructed: Vec<String> = instructions.iter()
        .map(|i| format!("{:04X}: {}", i.offset, i.native_equivalent))
        .collect();

    // Guess VM type
    let vm_type = guess_vm_type(&vm, &handler_stats);

    // Calculate complexity
    let complexity = calculate_complexity(&vm, &handler_stats);

    let result = DevirtualizationResult {
        instructions,
        reconstructed_asm: reconstructed,
        vm_type_guess: vm_type,
        handler_analysis,
        complexity_score: complexity,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn map_to_native(semantics: &str, operands: &[u64]) -> String {
    for (sem, native) in SEMANTICS_TO_NATIVE {
        if semantics.starts_with(sem) {
            let mut result = native.to_string();

            // Replace placeholders with operands
            for (i, op) in operands.iter().enumerate() {
                result = result.replace(&format!("{{op{}}}", i), &format!("0x{:X}", op));
            }
            result = result.replace("{imm}", &operands.get(0).map_or("?".to_string(), |v| format!("0x{:X}", v)));
            result = result.replace("{reg}", &format!("v{}", operands.get(0).unwrap_or(&0)));
            result = result.replace("{dst}", &format!("v{}", operands.get(0).unwrap_or(&0)));
            result = result.replace("{src}", &format!("v{}", operands.get(1).unwrap_or(&0)));
            result = result.replace("{addr}", &format!("0x{:X}", operands.get(0).unwrap_or(&0)));
            result = result.replace("{target}", &format!("0x{:X}", operands.get(0).unwrap_or(&0)));

            return result;
        }
    }

    format!("vm_op_{} {:?}", semantics, operands)
}

fn find_likely_native(semantics: &str) -> &'static str {
    match semantics {
        s if s.contains("push") => "push",
        s if s.contains("pop") => "pop",
        s if s.contains("add") => "add",
        s if s.contains("sub") => "sub",
        s if s.contains("xor") => "xor",
        s if s.contains("and") => "and",
        s if s.contains("or") => "or",
        s if s.contains("mov") || s.contains("load") || s.contains("store") => "mov",
        s if s.contains("jmp") || s.contains("jz") || s.contains("jnz") => "jcc",
        s if s.contains("call") => "call",
        s if s.contains("ret") => "ret",
        s if s.contains("nop") => "nop",
        _ => "unknown",
    }
}

fn calculate_confidence(semantics: &str, frequency: usize) -> f64 {
    let base = match semantics {
        s if s.contains("push") || s.contains("pop") => 0.95,
        s if s.contains("add") || s.contains("sub") || s.contains("xor") => 0.9,
        s if s.contains("mov") => 0.85,
        s if s.contains("jmp") || s.contains("jz") => 0.8,
        _ => 0.5,
    };

    // Higher frequency = higher confidence
    let freq_bonus = (frequency as f64 / 100.0).min(0.1);
    (base + freq_bonus).min(1.0)
}

fn guess_vm_type(vm: &VMBytecode, stats: &HashMap<u8, usize>) -> String {
    // Count stack operations
    let stack_ops: usize = vm.handlers.iter()
        .filter(|h| h.semantics.contains("push") || h.semantics.contains("pop"))
        .filter_map(|h| stats.get(&h.opcode))
        .sum();

    let total_ops: usize = stats.values().sum();

    let stack_ratio = if total_ops > 0 {
        stack_ops as f64 / total_ops as f64
    } else {
        0.0
    };

    if stack_ratio > 0.4 {
        "Stack-based VM (likely VMProtect/Themida style)".to_string()
    } else if stack_ratio > 0.2 {
        "Mixed stack/register VM".to_string()
    } else {
        "Register-based VM or threaded code".to_string()
    }
}

fn calculate_complexity(vm: &VMBytecode, stats: &HashMap<u8, usize>) -> f64 {
    let unique_handlers = stats.len() as f64;
    let total_handlers = vm.handlers.len() as f64;
    let bytecode_size = vm.code.len() as f64;

    // More handlers = more complex
    // Larger bytecode = more complex
    // Higher unique/total ratio = more obfuscated

    let handler_complexity = unique_handlers / total_handlers.max(1.0);
    let size_factor = (bytecode_size / 1000.0).min(1.0);

    (handler_complexity * 0.5 + size_factor * 0.5) * 10.0
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
              ORIGINAL CODE                    VIRTUALIZED CODE

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ push rbp            â”‚          â”‚ VM_ENTRY:                   â”‚
    â”‚ mov rbp, rsp        â”‚   â”€â”€â”€â–º   â”‚   mov [ctx.regs], native    â”‚
    â”‚ sub rsp, 0x20       â”‚          â”‚   lea rsi, [bytecode]       â”‚
    â”‚ mov [rbp-8], rdi    â”‚          â”‚   jmp dispatcher            â”‚
    â”‚ ...                 â”‚          â”‚                             â”‚
    â”‚ add rax, rbx        â”‚          â”‚ DISPATCHER:                 â”‚
    â”‚ ret                 â”‚          â”‚   movzx eax, [rsi]          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚   inc rsi                   â”‚
                                     â”‚   jmp [handlers + rax*8]    â”‚
                                     â”‚                             â”‚
                                     â”‚ BYTECODE:                   â”‚
                                     â”‚   0x01 ; vm_push            â”‚
                                     â”‚   0x00 ; operand            â”‚
                                     â”‚   0x05 ; vm_mov             â”‚
                                     â”‚   ...                       â”‚
                                     â”‚                             â”‚
                                     â”‚ HANDLERS:                   â”‚
                                     â”‚   handler_01: ...           â”‚
                                     â”‚   handler_05: ...           â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


        DEVIRTUALIZATION PROCESS

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   BYTECODE    â”‚
    â”‚ [01 00 05 02] â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ HANDLER MAP   â”‚
    â”‚ 01 â†’ push     â”‚
    â”‚ 05 â†’ mov      â”‚
    â”‚ 02 â†’ sub      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ SEMANTICS     â”‚
    â”‚ push_imm 0    â”‚
    â”‚ mov_reg_reg   â”‚
    â”‚ sub_reg_imm   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ NATIVE ASM    â”‚
    â”‚ push 0        â”‚
    â”‚ mov v0, v1    â”‚
    â”‚ sub v0, imm   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.5 Cours Complet : La DÃ©virtualisation

#### Qu'est-ce que la Virtualisation de Code ?

La virtualisation transforme le code natif en bytecode propriÃ©taire,
exÃ©cutÃ© par un interprÃ©teur custom embarquÃ© dans le binaire.

#### Structure d'une VM Protectrice

```
1. VM Entry Point
   - Sauvegarde le contexte natif
   - Initialise la VM (vIP, vSP, vRegs)
   - Saute au dispatcher

2. Dispatcher (fetch-decode loop)
   - Lit l'opcode Ã  vIP
   - IncrÃ©mente vIP
   - Saute au handler correspondant

3. Handlers
   - ExÃ©cutent les opÃ©rations
   - Modifient le contexte VM
   - Retournent au dispatcher

4. VM Exit
   - Restaure le contexte natif
   - Continue l'exÃ©cution normale
```

#### Techniques de DÃ©virtualisation

**1. Analyse Statique des Handlers**
- Identifier la sÃ©mantique de chaque handler
- Mapper vers des instructions natives

**2. Trace Dynamique**
- ExÃ©cuter et logger chaque handler
- Reconstruire le flux d'exÃ©cution

**3. Optimisation Symbolique**
- Simplifier les expressions VM
- Ã‰liminer le code mort

---

## ğŸ“ SECTION 7 : QCM

### Q1. Une VM protectrice stack-based utilise principalement...
A) Des registres virtuels
B) Une pile pour les opÃ©rations
C) Du threading direct
D) Des syscalls

**RÃ©ponse : B**

### Q2. Le dispatcher dans une VM fait...
A) ExÃ©cute directement le code
B) Fetch-decode-dispatch
C) Compile le bytecode
D) Chiffre les handlers

**RÃ©ponse : B**

### Q3. VMProtect utilise quel type de VM ?
A) Register-based
B) Stack-based
C) Threaded code
D) JIT compilation

**RÃ©ponse : B**

### Q4. La dÃ©virtualisation cherche Ã ...
A) CrÃ©er une nouvelle VM
B) Reconstruire le code natif
C) AccÃ©lÃ©rer l'exÃ©cution
D) Compresser le code

**RÃ©ponse : B**

### Q5. Le contexte VM contient typiquement...
A) Le code source original
B) vIP, vSP, registres virtuels
C) Les clÃ©s de chiffrement
D) Le nom du protecteur

**RÃ©ponse : B**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.18-a-devirtualizer",
    "metadata": {
      "exercise_id": "3.5.18-a",
      "difficulty": 10,
      "xp_base": 750
    }
  }
}
```

*Exercice 3.5.18-a â€” Devirtualizer*
*"Free yourself from the Matrix."*
*HACKBRAIN v5.5.2*
