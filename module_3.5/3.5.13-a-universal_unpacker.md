# Exercice 3.5.13-a : universal_unpacker

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî Unpacking de Binaires Prot√©g√©s

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ (10/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.12
- Compr√©hension des packers (UPX, Themida, VMProtect)
- Notions de cryptographie

**Domaines :**
CPU, Mem, Crypto, ASM

**Dur√©e estim√©e :**
240 min

**XP Base :**
700

**Complexit√© :**
T6 O(n) √ó S5 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "National Treasure" meets "The Da Vinci Code"

**"I'm gonna steal the Declaration of Independence."** ‚Äî Dans *National Treasure*, Ben Gates d√©chiffre des couches de protection. Dans *The Da Vinci Code*, Langdon d√©crypte symbole apr√®s symbole.

Tu es le **Universal Unpacker** ‚Äî face √† toi, des binaires prot√©g√©s par des packers, compresseurs, et obfuscateurs. Chaque couche de protection doit √™tre retir√©e pour r√©v√©ler le code original. UPX, Themida, VMProtect ‚Äî rien ne te r√©siste.

**Ta mission :**

√âcrire une fonction `packer_analyzer` qui identifie le type de packer et propose une strat√©gie d'unpacking.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct PackedBinaryInfo {
    pub pe_header: String,      // hex
    pub entry_point: u64,
    pub sections: Vec<SectionInfo>,
    pub imports: Vec<String>,
    pub entropy_map: Vec<(String, f64)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SectionInfo {
    pub name: String,
    pub virtual_size: u64,
    pub raw_size: u64,
    pub entropy: f64,
    pub characteristics: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UnpackingStrategy {
    pub detected_packer: String,
    pub confidence: f64,
    pub indicators: Vec<String>,
    pub unpacking_steps: Vec<String>,
    pub oep_hints: Vec<String>,
    pub warnings: Vec<String>,
}

pub fn packer_analyzer(binary_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Packers Communs

| Packer | Type | Difficult√© |
|--------|------|------------|
| **UPX** | Compresseur | Facile |
| **ASPack** | Compresseur | Moyen |
| **Themida** | Protector | Difficile |
| **VMProtect** | Virtualizer | Tr√®s difficile |
| **Enigma** | Protector | Difficile |

### 2.2 Indicateurs de Packing

- **Haute entropie** (>7.0) sur sections de code
- **Sections avec noms inhabituels** (UPX0, .packed)
- **Import table minimale** (souvent juste LoadLibrary/GetProcAddress)
- **Entry point dans section non-standard**

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectionInfo {
    pub name: String,
    pub virtual_size: u64,
    pub raw_size: u64,
    pub entropy: f64,
    pub characteristics: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PackedBinaryInfo {
    pub pe_header: String,
    pub entry_point: u64,
    pub sections: Vec<SectionInfo>,
    pub imports: Vec<String>,
    pub entropy_map: Vec<(String, f64)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UnpackingStrategy {
    pub detected_packer: String,
    pub confidence: f64,
    pub indicators: Vec<String>,
    pub unpacking_steps: Vec<String>,
    pub oep_hints: Vec<String>,
    pub warnings: Vec<String>,
}

const PACKER_SIGNATURES: &[(&str, &[&str])] = &[
    ("UPX", &["UPX0", "UPX1", "UPX!"]),
    ("ASPack", &[".aspack", ".adata"]),
    ("Themida", &[".themida", ".winlicen"]),
    ("VMProtect", &[".vmp0", ".vmp1", "VMProtect"]),
    ("PECompact", &["PEC2", ".pec"]),
];

pub fn packer_analyzer(binary_json: &str) -> Result<String, String> {
    let info: PackedBinaryInfo = serde_json::from_str(binary_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut indicators = Vec::new();
    let mut detected_packer = "Unknown".to_string();
    let mut confidence = 0.0f64;
    let mut warnings = Vec::new();

    // Check section names for packer signatures
    for section in &info.sections {
        for (packer, sigs) in PACKER_SIGNATURES {
            for sig in *sigs {
                if section.name.contains(sig) {
                    detected_packer = packer.to_string();
                    confidence = 0.9;
                    indicators.push(format!("Section name '{}' matches {} signature", section.name, packer));
                }
            }
        }

        // High entropy indicates compression/encryption
        if section.entropy > 7.0 {
            indicators.push(format!("High entropy ({:.2}) in section '{}'", section.entropy, section.name));
            confidence = (confidence + 0.1).min(1.0);
        }

        // Size mismatch indicates packing
        if section.virtual_size > section.raw_size * 3 {
            indicators.push(format!("Section '{}' will expand significantly at runtime", section.name));
        }
    }

    // Minimal imports check
    if info.imports.len() < 5 {
        indicators.push("Minimal import table - likely packed".to_string());
        confidence = (confidence + 0.2).min(1.0);
    }

    // Check for common unpacking imports
    let has_loadlib = info.imports.iter().any(|i| i.contains("LoadLibrary"));
    let has_getproc = info.imports.iter().any(|i| i.contains("GetProcAddress"));
    if has_loadlib && has_getproc && info.imports.len() < 10 {
        indicators.push("Dynamic import resolution detected (LoadLibrary + GetProcAddress)".to_string());
    }

    // Generate unpacking steps based on detected packer
    let unpacking_steps = match detected_packer.as_str() {
        "UPX" => vec![
            "1. Run 'upx -d binary.exe' to auto-unpack".to_string(),
            "2. Or manually: set breakpoint at OEP (usually POPAD; JMP)".to_string(),
            "3. Dump memory after decompression".to_string(),
        ],
        "Themida" | "VMProtect" => vec![
            "1. Use x64dbg with ScyllaHide plugin".to_string(),
            "2. Bypass anti-debug checks first".to_string(),
            "3. Find OEP via API logging (first call to non-ntdll API)".to_string(),
            "4. Dump with Scylla, fix IAT".to_string(),
        ],
        _ => vec![
            "1. Run in debugger with hardware breakpoints".to_string(),
            "2. Set memory breakpoint on code section".to_string(),
            "3. Wait for write then execute pattern".to_string(),
            "4. Dump at OEP, reconstruct IAT".to_string(),
        ],
    };

    // OEP hints
    let oep_hints = vec![
        "Look for PUSHAD...POPAD patterns".to_string(),
        "Set memory breakpoint on .text section access".to_string(),
        "First CALL after decompression loop often leads to OEP".to_string(),
    ];

    // Warnings
    if detected_packer == "VMProtect" || detected_packer == "Themida" {
        warnings.push("Advanced protection detected - may require anti-anti-debug techniques".to_string());
    }

    let result = UnpackingStrategy {
        detected_packer,
        confidence,
        indicators,
        unpacking_steps,
        oep_hints,
        warnings,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.13-a-universal-unpacker",
    "metadata": {"exercise_id": "3.5.13-a", "difficulty": 10, "xp_base": 700}
  }
}
```

*Exercice 3.5.13-a ‚Äî Universal Unpacker*
*"Peel back the layers."*
*HACKBRAIN v5.5.2*
