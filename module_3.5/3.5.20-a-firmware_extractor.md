# Exercice 3.5.20-a : firmware_extractor

**Module :**
3.5 â€” Reverse Engineering

**Concept :**
a â€” Extraction et Analyse de Firmware

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Exercices 3.5.1 Ã  3.5.19
- ComprÃ©hension des systÃ¨mes embarquÃ©s
- Notions de filesystems

**Domaines :**
FS, Encodage, Mem, CPU

**DurÃ©e estimÃ©e :**
150 min

**XP Base :**
550

**ComplexitÃ© :**
T5 O(n) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### ğŸ® CONTEXTE FUN â€” "Ex Machina" meets "Ghost in the Shell"

**"Isn't it strange, to create something that hates you?"** â€” Dans *Ex Machina*, Caleb explore le code d'une IA. Dans *Ghost in the Shell*, le Major plonge dans les systÃ¨mes embarquÃ©s.

Tu es le **Firmware Extractor** â€” face Ã  toi, des dumps de firmware de routeurs, IoT, devices industriels. Fichiers compressÃ©s, filesystems propriÃ©taires, code embarquÃ© â€” tout est mÃ©langÃ© dans un blob binaire. Ta mission : extraire et identifier les composants.

**Ta mission :**

Ã‰crire une fonction `extract_firmware` qui analyse un dump firmware et identifie ses composants.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct FirmwareDump {
    pub data: Vec<u8>,
    pub source: String,  // "router", "iot", "industrial", etc.
    pub vendor_hint: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirmwareComponent {
    pub offset: u64,
    pub size: u64,
    pub component_type: String,  // "header", "bootloader", "kernel", "rootfs", "config"
    pub format: String,          // "squashfs", "cramfs", "jffs2", "gzip", "lzma", etc.
    pub description: String,
    pub extractable: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MagicSignature {
    pub offset: u64,
    pub signature: String,
    pub description: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FirmwareAnalysis {
    pub components: Vec<FirmwareComponent>,
    pub signatures_found: Vec<MagicSignature>,
    pub architecture_guess: String,
    pub endianness: String,
    pub extraction_commands: Vec<String>,
    pub security_notes: Vec<String>,
}

pub fn extract_firmware(dump_json: &str) -> Result<String, String>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Signatures de Firmware Courantes

| Signature | Hex | Description |
|-----------|-----|-------------|
| **hsqs** | `68 73 71 73` | SquashFS (little-endian) |
| **sqsh** | `73 71 73 68` | SquashFS (big-endian) |
| **JFFS2** | `85 19` | JFFS2 filesystem |
| **cramfs** | `45 3D CD 28` | CramFS |
| **gzip** | `1F 8B` | Gzip compressed |
| **LZMA** | `5D 00 00` | LZMA compressed |
| **uImage** | `27 05 19 56` | U-Boot image |
| **ELF** | `7F 45 4C 46` | ELF binary |

### 2.2 Structure Typique d'un Firmware

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              FIRMWARE STRUCTURE                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x00000000: Header (vendor-specific)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x00001000: Bootloader (U-Boot)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x00040000: Kernel (Linux, compressed)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x00200000: Root Filesystem (SquashFS)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x00F00000: Configuration/NVRAM                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **IoT Security** | Analyser firmware vulnÃ©rables |
| **Hardware Hacker** | Modifier routeurs/devices |
| **Vulnerability Researcher** | Trouver backdoors |
| **Forensics Analyst** | Extraire donnÃ©es de devices |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct FirmwareDump {
    pub data: Vec<u8>,
    pub source: String,
    pub vendor_hint: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirmwareComponent {
    pub offset: u64,
    pub size: u64,
    pub component_type: String,
    pub format: String,
    pub description: String,
    pub extractable: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MagicSignature {
    pub offset: u64,
    pub signature: String,
    pub description: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FirmwareAnalysis {
    pub components: Vec<FirmwareComponent>,
    pub signatures_found: Vec<MagicSignature>,
    pub architecture_guess: String,
    pub endianness: String,
    pub extraction_commands: Vec<String>,
    pub security_notes: Vec<String>,
}

// Magic signatures database
const SIGNATURES: &[(&[u8], &str, &str, &str)] = &[
    // (magic bytes, name, description, extraction tool)
    (b"hsqs", "squashfs_le", "SquashFS (little-endian)", "unsquashfs"),
    (b"sqsh", "squashfs_be", "SquashFS (big-endian)", "unsquashfs"),
    (b"\x85\x19", "jffs2_le", "JFFS2 (little-endian)", "jefferson"),
    (b"\x19\x85", "jffs2_be", "JFFS2 (big-endian)", "jefferson"),
    (b"\x45\x3D\xCD\x28", "cramfs_le", "CramFS (little-endian)", "cramfsck"),
    (b"\x28\xCD\x3D\x45", "cramfs_be", "CramFS (big-endian)", "cramfsck"),
    (b"\x1F\x8B", "gzip", "Gzip compressed", "gunzip"),
    (b"\x5D\x00\x00", "lzma", "LZMA compressed", "unlzma"),
    (b"\xFD\x37\x7A\x58\x5A\x00", "xz", "XZ compressed", "unxz"),
    (b"\x27\x05\x19\x56", "uimage", "U-Boot image header", "dumpimage"),
    (b"\x7F\x45\x4C\x46", "elf", "ELF executable", "readelf"),
    (b"UBI#", "ubi", "UBI image", "ubireader"),
    (b"UBIFS", "ubifs", "UBIFS filesystem", "ubireader"),
    (b"\xD0\x0D\xFE\xED", "dtb_be", "Device Tree Blob (big-endian)", "dtc"),
    (b"\xED\xFE\x0D\xD0", "dtb_le", "Device Tree Blob (little-endian)", "dtc"),
];

// ARM/MIPS instruction patterns for architecture detection
const ARCH_PATTERNS: &[(&[u8], &str)] = &[
    (b"\x00\x00\xA0\xE1", "ARM (little-endian)"),
    (b"\xE1\xA0\x00\x00", "ARM (big-endian)"),
    (b"\x00\x00\x00\x00\x00\x00\x00\x00", "MIPS (NOP sled)"),
];

pub fn extract_firmware(dump_json: &str) -> Result<String, String> {
    let dump: FirmwareDump = serde_json::from_str(dump_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut components = Vec::new();
    let mut signatures = Vec::new();
    let mut extraction_commands = Vec::new();
    let mut security_notes = Vec::new();

    // Scan for magic signatures
    for (magic, name, desc, tool) in SIGNATURES {
        for offset in find_all_occurrences(&dump.data, magic) {
            signatures.push(MagicSignature {
                offset: offset as u64,
                signature: name.to_string(),
                description: desc.to_string(),
            });

            // Estimate component size (until next signature or end)
            let size = estimate_component_size(&dump.data, offset, magic.len());

            components.push(FirmwareComponent {
                offset: offset as u64,
                size,
                component_type: categorize_component(name),
                format: name.to_string(),
                description: desc.to_string(),
                extractable: true,
            });

            extraction_commands.push(format!(
                "dd if=firmware.bin bs=1 skip={} count={} | {} -",
                offset, size, tool
            ));
        }
    }

    // Detect architecture
    let architecture = detect_architecture(&dump.data);
    let endianness = detect_endianness(&signatures);

    // Security analysis
    security_notes.extend(analyze_security(&dump.data, &signatures));

    // Sort components by offset
    components.sort_by_key(|c| c.offset);

    // Add extraction commands
    extraction_commands.insert(0, "# Binwalk automated extraction:".to_string());
    extraction_commands.insert(1, "binwalk -e firmware.bin".to_string());
    extraction_commands.insert(2, "".to_string());
    extraction_commands.insert(3, "# Manual extraction commands:".to_string());

    let analysis = FirmwareAnalysis {
        components,
        signatures_found: signatures,
        architecture_guess: architecture,
        endianness,
        extraction_commands,
        security_notes,
    };

    serde_json::to_string_pretty(&analysis)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn find_all_occurrences(data: &[u8], pattern: &[u8]) -> Vec<usize> {
    let mut occurrences = Vec::new();
    let mut start = 0;

    while start + pattern.len() <= data.len() {
        if let Some(pos) = data[start..].windows(pattern.len())
            .position(|window| window == pattern)
        {
            occurrences.push(start + pos);
            start = start + pos + 1;
        } else {
            break;
        }
    }

    occurrences
}

fn estimate_component_size(data: &[u8], offset: usize, _magic_len: usize) -> u64 {
    // Simple heuristic: find next signature or use remaining size
    let remaining = data.len() - offset;

    // Check for embedded size in header (common in many formats)
    if offset + 8 < data.len() {
        // Try to read size from common header positions
        let size_le = u32::from_le_bytes([
            data[offset + 4],
            data[offset + 5],
            data[offset + 6],
            data[offset + 7],
        ]) as u64;

        if size_le > 0 && size_le < remaining as u64 {
            return size_le;
        }
    }

    // Default: scan for next magic or return reasonable chunk
    remaining.min(0x100000) as u64  // Max 1MB per component by default
}

fn categorize_component(format: &str) -> String {
    match format {
        "uimage" => "kernel",
        "squashfs_le" | "squashfs_be" => "rootfs",
        "jffs2_le" | "jffs2_be" => "rootfs",
        "cramfs_le" | "cramfs_be" => "rootfs",
        "ubi" | "ubifs" => "rootfs",
        "gzip" | "lzma" | "xz" => "compressed",
        "elf" => "executable",
        "dtb_le" | "dtb_be" => "device_tree",
        _ => "unknown",
    }.to_string()
}

fn detect_architecture(data: &[u8]) -> String {
    // Check ELF header if present
    if let Some(elf_offset) = find_all_occurrences(data, b"\x7FELF").first() {
        if *elf_offset + 18 < data.len() {
            let e_machine = u16::from_le_bytes([
                data[elf_offset + 18],
                data[elf_offset + 19],
            ]);

            return match e_machine {
                0x03 => "x86 (i386)",
                0x08 => "MIPS",
                0x28 => "ARM",
                0x3E => "x86_64",
                0xB7 => "AArch64",
                _ => "Unknown",
            }.to_string();
        }
    }

    // Check for ARM/MIPS patterns
    for (pattern, arch) in ARCH_PATTERNS {
        if find_all_occurrences(data, pattern).len() > 5 {
            return arch.to_string();
        }
    }

    "Unknown (manual analysis required)".to_string()
}

fn detect_endianness(signatures: &[MagicSignature]) -> String {
    let le_count = signatures.iter()
        .filter(|s| s.signature.contains("_le") || s.signature == "gzip" || s.signature == "lzma")
        .count();

    let be_count = signatures.iter()
        .filter(|s| s.signature.contains("_be"))
        .count();

    if le_count > be_count {
        "Little-endian".to_string()
    } else if be_count > le_count {
        "Big-endian".to_string()
    } else {
        "Unknown (mixed or undetermined)".to_string()
    }
}

fn analyze_security(data: &[u8], _signatures: &[MagicSignature]) -> Vec<String> {
    let mut notes = Vec::new();

    // Check for common security issues
    let data_str = String::from_utf8_lossy(data);

    // Hardcoded credentials
    if data_str.contains("root:") || data_str.contains("admin:") {
        notes.push("WARNING: Potential hardcoded credentials found".to_string());
    }

    // Debug strings
    if data_str.contains("DEBUG") || data_str.contains("TELNET") {
        notes.push("NOTE: Debug/Telnet strings found - may have backdoor".to_string());
    }

    // Private keys
    if data_str.contains("PRIVATE KEY") {
        notes.push("CRITICAL: Private key found in firmware!".to_string());
    }

    // Common default passwords
    let common_passwords = ["password", "admin", "root", "1234", "default"];
    for pwd in common_passwords {
        if data_str.contains(pwd) {
            notes.push(format!("WARNING: Common password '{}' found", pwd));
        }
    }

    if notes.is_empty() {
        notes.push("No obvious security issues detected (manual review recommended)".to_string());
    }

    notes
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
              FIRMWARE EXTRACTION PROCESS

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                   RAW FIRMWARE DUMP                      â”‚
    â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â” â”‚
    â”‚  â”‚ H â”‚ D â”‚ R â”‚...â”‚ U â”‚ B â”‚ O â”‚ O â”‚ T â”‚...â”‚ s â”‚ q â”‚ s â”‚ â”‚
    â”‚  â”‚ E â”‚ A â”‚   â”‚   â”‚ - â”‚   â”‚   â”‚   â”‚   â”‚   â”‚ q â”‚ s â”‚ h â”‚ â”‚
    â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â”‚
    â”‚    â†‘               â†‘                       â†‘            â”‚
    â”‚ Header          U-Boot                  SquashFS        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                  SIGNATURE SCANNER                       â”‚
    â”‚                                                          â”‚
    â”‚  Scanning for: hsqs, sqsh, 27 05 19 56, 1F 8B...        â”‚
    â”‚                                                          â”‚
    â”‚  Found at 0x000000: Vendor header                       â”‚
    â”‚  Found at 0x001000: U-Boot (27 05 19 56)                â”‚
    â”‚  Found at 0x200000: SquashFS (hsqs)                     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                EXTRACTED COMPONENTS                      â”‚
    â”‚                                                          â”‚
    â”‚  firmware/                                               â”‚
    â”‚  â”œâ”€â”€ header.bin      (0x000000, 4KB)                    â”‚
    â”‚  â”œâ”€â”€ uboot.bin       (0x001000, 256KB)                  â”‚
    â”‚  â”œâ”€â”€ kernel.lzma     (0x041000, 2MB)                    â”‚
    â”‚  â””â”€â”€ rootfs/         (extracted SquashFS)               â”‚
    â”‚      â”œâ”€â”€ bin/                                           â”‚
    â”‚      â”œâ”€â”€ etc/                                           â”‚
    â”‚      â”œâ”€â”€ lib/                                           â”‚
    â”‚      â””â”€â”€ usr/                                           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


        COMMON FIRMWARE LAYOUTS

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              ROUTER FIRMWARE                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [Header][U-Boot][Kernel][RootFS][Config]    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              IP CAMERA FIRMWARE               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [Boot][Kernel][App][WebUI][Config]          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              INDUSTRIAL PLC                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [Header][RTOS][Logic][Config][Backup]       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.5 Cours Complet : Analyse de Firmware

#### Qu'est-ce qu'un Firmware ?

Le firmware est le logiciel embarquÃ© dans un device. Il contient gÃ©nÃ©ralement:
- Un bootloader (U-Boot, RedBoot)
- Un kernel (Linux, RTOS)
- Un filesystem racine (SquashFS, JFFS2)
- Des configurations

#### Outils d'Extraction

**Binwalk** : L'outil principal
```bash
binwalk firmware.bin           # Analyse
binwalk -e firmware.bin        # Extraction automatique
binwalk -Me firmware.bin       # Extraction rÃ©cursive
```

**Firmware Mod Kit**
```bash
./extract-firmware.sh firmware.bin
```

**Manual avec dd**
```bash
dd if=firmware.bin bs=1 skip=$OFFSET count=$SIZE of=component.bin
```

#### ProblÃ¨mes de SÃ©curitÃ© Courants

1. **Credentials hardcodÃ©es** : root:password dans /etc/shadow
2. **ClÃ©s privÃ©es** : SSL certs dans le firmware
3. **Backdoors** : Ports telnet/SSH ouverts
4. **Command injection** : CGI vulnÃ©rables

---

## ğŸ“ SECTION 7 : QCM

### Q1. SquashFS est identifiable par la signature...
A) 7F 45 4C 46
B) 68 73 71 73 (hsqs)
C) 1F 8B
D) 27 05 19 56

**RÃ©ponse : B**

### Q2. U-Boot est un...
A) Kernel
B) Filesystem
C) Bootloader
D) Compresseur

**RÃ©ponse : C**

### Q3. L'outil principal pour extraire un firmware est...
A) strings
B) binwalk
C) objdump
D) readelf

**RÃ©ponse : B**

### Q4. JFFS2 est un...
A) Compresseur
B) Bootloader
C) Filesystem journalisÃ© pour flash
D) Format d'image kernel

**RÃ©ponse : C**

### Q5. Un firmware IoT vulnÃ©rable contient souvent...
A) Trop de documentation
B) Credentials hardcodÃ©es
C) Code obfusquÃ©
D) Signatures valides

**RÃ©ponse : B**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.20-a-firmware-extractor",
    "metadata": {
      "exercise_id": "3.5.20-a",
      "difficulty": 8,
      "xp_base": 550
    }
  }
}
```

*Exercice 3.5.20-a â€” Firmware Extractor*
*"Dissect the machine."*
*HACKBRAIN v5.5.2*
