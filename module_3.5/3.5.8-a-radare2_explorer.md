# Exercice 3.5.8-a : radare2_explorer

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî Ma√Ætrise de radare2 et alternatives CLI

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024 + r2pipe

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.7
- Connaissance de la ligne de commande
- Bases en d√©sassemblage

**Domaines :**
CPU, ASM, FS, Struct

**Dur√©e estim√©e :**
120 min

**XP Base :**
450

**Complexit√© :**
T3 O(n) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`radare2_explorer.rs`

**Fonctions autoris√©es :**
- `serde_json` pour JSON
- Collections standard

**Fonctions interdites :**
- Ex√©cution directe de radare2
- Acc√®s filesystem

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "Minority Report" meets "Ghost in the Shell"

**"The system is perfect."** ‚Äî Dans *Minority Report*, les Pre-Cogs voient l'avenir. Dans *Ghost in the Shell*, Motoko analyse les syst√®mes en temps r√©el via son interface neurale.

Tu es le **Radare2 Explorer** ‚Äî un analyste capable de piloter radare2 comme une extension de ton esprit. L√† o√π Ghidra est graphique, radare2 est minimaliste et puissant. `aaa`, `pdf`, `afl` ‚Äî chaque commande est une invocation magique.

**"I'm not a hacker. I'm a network analyst."**

**Ta mission :**

√âcrire une fonction `radare2_command_parser` qui interpr√®te la sortie de commandes radare2 et la structure en donn√©es exploitables.

**Entr√©e :**
- `r2_output_json` : JSON contenant :
  - `command` : Commande radare2 ex√©cut√©e
  - `output` : Sortie brute de la commande
  - `binary_info` : M√©tadonn√©es du binaire

**Sortie :**
- JSON structur√© selon la commande :
  - Pour `afl` : Liste de fonctions pars√©es
  - Pour `pdf` : D√©sassemblage structur√©
  - Pour `iz` : Strings structur√©es
  - Pour `ii` : Imports structur√©s
  - Pour `iS` : Sections structur√©es

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct R2Input {
    pub command: String,
    pub output: String,
    pub binary_info: Option<HashMap<String, String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct R2Function {
    pub address: String,
    pub size: u64,
    pub name: String,
    pub cc: u32,  // cyclomatic complexity
}

#[derive(Debug, Serialize, Deserialize)]
pub struct R2Instruction {
    pub address: String,
    pub bytes: String,
    pub mnemonic: String,
    pub operands: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct R2ParsedOutput {
    pub command: String,
    pub parsed_type: String,
    pub data: serde_json::Value,
    pub stats: HashMap<String, u64>,
}

pub fn radare2_command_parser(r2_output_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Radare2 est un Framework Complet

| Commande | Description |
|----------|-------------|
| `aaa` | Analyse compl√®te automatique |
| `afl` | Liste toutes les fonctions |
| `pdf` | Print Disassembly of Function |
| `iz` | Liste les strings |
| `ii` | Liste les imports |
| `iS` | Liste les sections |
| `px` | Print heXdump |
| `s` | Seek (changer l'adresse courante) |
| `/` | Recherche de patterns |
| `Vv` | Mode visuel |

### 2.2 L'√âcosyst√®me radare2

- **r2pipe** : API pour piloter r2 depuis tout langage
- **cutter** : GUI bas√©e sur radare2
- **radiff2** : Comparaison de binaires
- **rasm2** : Assembleur/d√©sassembleur standalone
- **rabin2** : Extraction d'info binaires
- **rahash2** : Hashing multi-algorithmes

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
radare2_explorer.rs  main.rs

$ cargo build --release

$ ./target/release/test
Test 1 (parse_afl): 5 functions parsed ‚Üí OK
Test 2 (parse_pdf): 12 instructions parsed ‚Üí OK
Test 3 (parse_iz): 8 strings found ‚Üí OK
Tous les tests passent!
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct R2Input {
    pub command: String,
    pub output: String,
    pub binary_info: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct R2Function {
    pub address: String,
    pub size: u64,
    pub name: String,
    pub cc: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct R2Instruction {
    pub address: String,
    pub bytes: String,
    pub mnemonic: String,
    pub operands: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct R2ParsedOutput {
    pub command: String,
    pub parsed_type: String,
    pub data: serde_json::Value,
    pub stats: HashMap<String, u64>,
}

fn parse_afl(output: &str) -> (Vec<R2Function>, HashMap<String, u64>) {
    let mut functions = Vec::new();
    let mut stats = HashMap::new();

    for line in output.lines() {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 4 {
            // Format: 0x00001149    1 42           main
            if let (Some(addr), Some(size)) = (parts.get(0), parts.get(2)) {
                if addr.starts_with("0x") {
                    functions.push(R2Function {
                        address: addr.to_string(),
                        size: size.parse().unwrap_or(0),
                        name: parts.last().unwrap_or(&"unknown").to_string(),
                        cc: parts.get(1).and_then(|s| s.parse().ok()).unwrap_or(1),
                    });
                }
            }
        }
    }

    stats.insert("total_functions".to_string(), functions.len() as u64);
    stats.insert("total_size".to_string(), functions.iter().map(|f| f.size).sum());

    (functions, stats)
}

fn parse_pdf(output: &str) -> (Vec<R2Instruction>, HashMap<String, u64>) {
    let mut instructions = Vec::new();
    let mut stats = HashMap::new();
    let mut calls = 0u64;
    let mut jumps = 0u64;

    for line in output.lines() {
        // Format: ‚îÇ 0x00001149      55             push rbp
        let line = line.trim_start_matches(|c| c == '‚îÇ' || c == ' ');
        let parts: Vec<&str> = line.split_whitespace().collect();

        if parts.len() >= 3 && parts[0].starts_with("0x") {
            let mnemonic = parts.get(2).unwrap_or(&"").to_string();

            if mnemonic.starts_with("call") { calls += 1; }
            if mnemonic.starts_with("j") { jumps += 1; }

            instructions.push(R2Instruction {
                address: parts[0].to_string(),
                bytes: parts[1].to_string(),
                mnemonic: mnemonic.clone(),
                operands: parts[3..].join(" "),
            });
        }
    }

    stats.insert("total_instructions".to_string(), instructions.len() as u64);
    stats.insert("calls".to_string(), calls);
    stats.insert("jumps".to_string(), jumps);

    (instructions, stats)
}

fn parse_iz(output: &str) -> (Vec<String>, HashMap<String, u64>) {
    let mut strings = Vec::new();

    for line in output.lines() {
        // Format: 000 0x00002000 0x00002000  13  14 (.rodata) ascii Hello World
        if let Some(idx) = line.find("ascii ").or(line.find("utf8 ")) {
            let s = line[idx..].split_once(' ').map(|(_, s)| s.to_string());
            if let Some(s) = s {
                strings.push(s);
            }
        }
    }

    let mut stats = HashMap::new();
    stats.insert("total_strings".to_string(), strings.len() as u64);

    (strings, stats)
}

pub fn radare2_command_parser(r2_output_json: &str) -> Result<String, String> {
    let input: R2Input = serde_json::from_str(r2_output_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let (parsed_type, data, stats) = match input.command.as_str() {
        "afl" | "aflj" => {
            let (funcs, stats) = parse_afl(&input.output);
            ("functions".to_string(), serde_json::to_value(funcs).unwrap(), stats)
        }
        "pdf" | "pdfj" => {
            let (instrs, stats) = parse_pdf(&input.output);
            ("disassembly".to_string(), serde_json::to_value(instrs).unwrap(), stats)
        }
        "iz" | "izj" => {
            let (strs, stats) = parse_iz(&input.output);
            ("strings".to_string(), serde_json::to_value(strs).unwrap(), stats)
        }
        _ => {
            let mut stats = HashMap::new();
            stats.insert("lines".to_string(), input.output.lines().count() as u64);
            ("raw".to_string(), serde_json::Value::String(input.output.clone()), stats)
        }
    };

    let result = R2ParsedOutput {
        command: input.command,
        parsed_type,
        data,
        stats,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
         COMMANDES RADARE2 ESSENTIELLES

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ           ANALYSE (a*)                      ‚îÇ
    ‚îÇ  aaa  ‚Üí  Analyse All (fonctions, xrefs...)  ‚îÇ
    ‚îÇ  afl  ‚Üí  Analyse Function List              ‚îÇ
    ‚îÇ  afn  ‚Üí  Analyse Function Name (rename)     ‚îÇ
    ‚îÇ  axt  ‚Üí  Analyse Xrefs To                   ‚îÇ
    ‚îÇ  axf  ‚Üí  Analyse Xrefs From                 ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ           PRINT (p*)                        ‚îÇ
    ‚îÇ  pdf  ‚Üí  Print Disassembly Function         ‚îÇ
    ‚îÇ  px   ‚Üí  Print heXdump                      ‚îÇ
    ‚îÇ  ps   ‚Üí  Print String                       ‚îÇ
    ‚îÇ  pf   ‚Üí  Print Format                       ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ           INFO (i*)                         ‚îÇ
    ‚îÇ  ii   ‚Üí  Info Imports                       ‚îÇ
    ‚îÇ  iS   ‚Üí  Info Sections                      ‚îÇ
    ‚îÇ  iz   ‚Üí  Info strings (Zero-terminated)    ‚îÇ
    ‚îÇ  ie   ‚Üí  Info Entrypoint                   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


    SESSION R2 TYPIQUE

    $ r2 binary
    [0x00001050]> aaa           # Analyse tout
    [0x00001050]> afl           # Liste fonctions
    [0x00001050]> s main        # Seek √† main
    [0x00001149]> pdf           # D√©sassemble main
    [0x00001149]> VV            # Mode graphe
```

### 5.8 Mn√©motechniques

#### üíª MEME : "I'm in." ‚Äî Les hackers de films

Dans les films, les hackers tapent 3 touches et disent "I'm in."
En r√©alit√© avec radare2 :

```bash
r2 binary
[0x00000000]> aaa
[x] Analyze all flags starting with sym. and entry0
[0x00001050]> afl
... 47 functions found ...
[0x00001050]> # "Je suis... dedans ?"
```

---

## üìù SECTION 7 : QCM

### Question 1
**La commande r2 pour analyser automatiquement un binaire est :**

A) analyze
B) aaa
C) scan
D) auto

**R√©ponse : B**

### Question 2
**pdf dans radare2 signifie :**

A) Portable Document Format
B) Print Disassembly Function
C) Program Data Flow
D) Parse Data Format

**R√©ponse : B**

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.8-a-radare2-explorer",
    "metadata": {
      "exercise_id": "3.5.8-a",
      "difficulty": 8,
      "xp_base": 450
    }
  }
}
```

---

*Exercice 3.5.8-a ‚Äî Radare2 Explorer*
*"The command line is your friend."*
*HACKBRAIN v5.5.2*
