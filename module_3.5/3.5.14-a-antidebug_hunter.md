# Exercice 3.5.14-a : antidebug_hunter

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî D√©tection et Contournement des Anti-Debug

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.13
- Compr√©hension des techniques anti-debug
- Connaissance des APIs Windows/Linux

**Domaines :**
Process, Mem, CPU, FS

**Dur√©e estim√©e :**
150 min

**XP Base :**
550

**Complexit√© :**
T5 O(n) √ó S3 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "Enemy at the Gates" meets "Spy vs Spy"

**"Every hunter knows patience is key."** ‚Äî Comme Vassili Zaitsev dans *Enemy at the Gates*, tu traques des cibles qui savent se cacher. Le malware sait qu'il est chass√© et utilise des techniques anti-debug.

Tu es l'**Anti-Debug Hunter** ‚Äî ta mission : identifier et contourner les protections anti-debug dans le code analys√©.

**Ta mission :**

√âcrire une fonction `antidebug_detector` qui analyse du code d√©sassembl√© et identifie les techniques anti-debug utilis√©es.

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct CodeAnalysis {
    pub disassembly: Vec<String>,
    pub imports: Vec<String>,
    pub strings: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AntiDebugFinding {
    pub technique: String,
    pub category: String,  // "timing", "api", "flag", "hardware", "exception"
    pub severity: String,  // "low", "medium", "high"
    pub evidence: String,
    pub bypass_suggestion: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AntiDebugReport {
    pub findings: Vec<AntiDebugFinding>,
    pub overall_protection_level: String,
    pub recommended_approach: Vec<String>,
}

pub fn antidebug_detector(code_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Techniques Anti-Debug Communes

| Technique | Cat√©gorie | Difficult√© bypass |
|-----------|-----------|-------------------|
| **IsDebuggerPresent** | API | Facile |
| **PEB.BeingDebugged** | Flag | Facile |
| **NtQueryInformationProcess** | API | Moyen |
| **RDTSC timing** | Timing | Moyen |
| **INT 2D** | Exception | Difficile |
| **Hardware breakpoints** | Hardware | Difficile |

### 2.2 Outils de Bypass

- **ScyllaHide** : Plugin x64dbg
- **TitanHide** : Driver kernel
- **HideDebugger** : OllyDbg plugin
- **Frida** : Hook dynamique

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct CodeAnalysis {
    pub disassembly: Vec<String>,
    pub imports: Vec<String>,
    pub strings: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AntiDebugFinding {
    pub technique: String,
    pub category: String,
    pub severity: String,
    pub evidence: String,
    pub bypass_suggestion: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AntiDebugReport {
    pub findings: Vec<AntiDebugFinding>,
    pub overall_protection_level: String,
    pub recommended_approach: Vec<String>,
}

const ANTIDEBUG_APIS: &[(&str, &str, &str, &str)] = &[
    ("IsDebuggerPresent", "api", "medium", "Hook to return 0"),
    ("CheckRemoteDebuggerPresent", "api", "medium", "Hook to set *pbDebuggerPresent = FALSE"),
    ("NtQueryInformationProcess", "api", "high", "Hook ProcessDebugPort to return 0"),
    ("NtSetInformationThread", "api", "high", "Hook ThreadHideFromDebugger"),
    ("OutputDebugString", "api", "low", "Ignore or hook"),
    ("CloseHandle", "api", "medium", "Handle invalid handle exception"),
];

const ANTIDEBUG_PATTERNS: &[(&str, &str, &str, &str)] = &[
    ("rdtsc", "timing", "high", "Use TitanHide or patch RDTSC"),
    ("int 2d", "exception", "high", "Handle exception in debugger"),
    ("int 3", "exception", "low", "Breakpoint - may be anti-debug or normal"),
    ("fs:[30h]", "flag", "medium", "PEB access - patch BeingDebugged"),
    ("gs:[60h]", "flag", "medium", "PEB access (64-bit)"),
    ("cpuid", "hardware", "high", "May check hypervisor bit"),
];

pub fn antidebug_detector(code_json: &str) -> Result<String, String> {
    let analysis: CodeAnalysis = serde_json::from_str(code_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut findings = Vec::new();

    // Check imports
    for import in &analysis.imports {
        let import_lower = import.to_lowercase();
        for (api, category, severity, bypass) in ANTIDEBUG_APIS {
            if import_lower.contains(&api.to_lowercase()) {
                findings.push(AntiDebugFinding {
                    technique: format!("{} API call", api),
                    category: category.to_string(),
                    severity: severity.to_string(),
                    evidence: format!("Import: {}", import),
                    bypass_suggestion: bypass.to_string(),
                });
            }
        }
    }

    // Check disassembly
    for line in &analysis.disassembly {
        let line_lower = line.to_lowercase();
        for (pattern, category, severity, bypass) in ANTIDEBUG_PATTERNS {
            if line_lower.contains(pattern) {
                findings.push(AntiDebugFinding {
                    technique: format!("{} instruction", pattern.to_uppercase()),
                    category: category.to_string(),
                    severity: severity.to_string(),
                    evidence: line.clone(),
                    bypass_suggestion: bypass.to_string(),
                });
            }
        }
    }

    // Check strings
    for s in &analysis.strings {
        let s_lower = s.to_lowercase();
        if s_lower.contains("debugger") || s_lower.contains("olly")
           || s_lower.contains("x64dbg") || s_lower.contains("ida") {
            findings.push(AntiDebugFinding {
                technique: "Debugger name check".to_string(),
                category: "string".to_string(),
                severity: "medium".to_string(),
                evidence: s.clone(),
                bypass_suggestion: "Rename debugger or hook string comparison".to_string(),
            });
        }
    }

    // Determine overall protection level
    let high_count = findings.iter().filter(|f| f.severity == "high").count();
    let overall_level = if high_count >= 3 {
        "Heavy protection"
    } else if high_count >= 1 || findings.len() >= 5 {
        "Moderate protection"
    } else if !findings.is_empty() {
        "Light protection"
    } else {
        "No anti-debug detected"
    };

    // Recommended approach
    let mut approach = vec![
        "1. Use ScyllaHide with full anti-anti-debug profile".to_string(),
    ];
    if high_count > 0 {
        approach.push("2. Consider using TitanHide (kernel driver)".to_string());
        approach.push("3. Patch timing checks with static analysis".to_string());
    }
    approach.push("4. Set hardware breakpoints instead of software".to_string());

    let report = AntiDebugReport {
        findings,
        overall_protection_level: overall_level.to_string(),
        recommended_approach: approach,
    };

    serde_json::to_string_pretty(&report)
        .map_err(|e| format!("Serialization error: {}", e))
}
```

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.14-a-antidebug-hunter",
    "metadata": {"exercise_id": "3.5.14-a", "difficulty": 9, "xp_base": 550}
  }
}
```

*Exercice 3.5.14-a ‚Äî Anti-Debug Hunter*
*"Hunt the hunters."*
*HACKBRAIN v5.5.2*
