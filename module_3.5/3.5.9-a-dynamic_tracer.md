# Exercice 3.5.9-a : dynamic_tracer

**Module :**
3.5 ‚Äî Reverse Engineering

**Concept :**
a ‚Äî Analyse Dynamique et Tracing (strace, ltrace, dtrace)

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Exercices 3.5.1 √† 3.5.8
- Compr√©hension des syscalls
- Notions de debugging

**Domaines :**
Process, FS, Net, Mem

**Dur√©e estim√©e :**
100 min

**XP Base :**
400

**Complexit√© :**
T3 O(n) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`dynamic_tracer.rs`

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "Person of Interest" meets "Eagle Eye"

**"You are being watched."** ‚Äî Dans *Person of Interest*, The Machine observe chaque action. Dans *Eagle Eye*, un syst√®me surveille les moindres communications.

Tu es le **Dynamic Tracer** ‚Äî tu observes un programme en cours d'ex√©cution sans le modifier. Chaque syscall, chaque appel de biblioth√®que, chaque allocation m√©moire est enregistr√©e. Le programme ne sait pas qu'il est observ√©.

**"Everything you do is being recorded."**

**Ta mission :**

√âcrire une fonction `trace_analyzer` qui analyse les logs de strace/ltrace et produit un rapport comportemental.

**Entr√©e :**
- `trace_json` : JSON contenant :
  - `trace_type` : "strace" | "ltrace"
  - `trace_log` : Logs bruts du tracer
  - `pid` : PID du processus trac√©

**Sortie :**
- JSON contenant :
  - `syscalls` : Statistiques par syscall
  - `files_accessed` : Fichiers ouverts/lus/√©crits
  - `network_activity` : Connexions r√©seau
  - `memory_ops` : Op√©rations m√©moire
  - `suspicious_behavior` : Comportements suspects d√©tect√©s
  - `timeline` : Chronologie des √©v√©nements cl√©s

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct TraceInput {
    pub trace_type: String,
    pub trace_log: String,
    pub pid: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FileAccess {
    pub path: String,
    pub operations: Vec<String>,
    pub fd: Option<i32>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkActivity {
    pub address: String,
    pub port: u16,
    pub protocol: String,
    pub direction: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TraceAnalysis {
    pub syscalls: HashMap<String, u64>,
    pub files_accessed: Vec<FileAccess>,
    pub network_activity: Vec<NetworkActivity>,
    pub memory_ops: HashMap<String, u64>,
    pub suspicious_behavior: Vec<String>,
    pub timeline: Vec<String>,
}

pub fn trace_analyzer(trace_json: &str) -> Result<String, String>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Outils de Tracing

| Outil | OS | Trace |
|-------|-----|-------|
| **strace** | Linux | Syscalls |
| **ltrace** | Linux | Library calls |
| **dtrace** | macOS/Solaris | Universel |
| **procmon** | Windows | Syscalls + Registry |
| **sysdig** | Linux | Conteneurs |

### 2.2 Syscalls Critiques √† Surveiller

| Cat√©gorie | Syscalls |
|-----------|----------|
| **Fichiers** | open, read, write, unlink |
| **R√©seau** | socket, connect, send, recv |
| **Process** | fork, exec, ptrace |
| **M√©moire** | mmap, mprotect, brk |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ./target/release/test
Test 1 (file_ops): 3 files detected ‚Üí OK
Test 2 (network): connect to 192.168.1.1:443 ‚Üí OK
Test 3 (suspicious): ptrace detected ‚Üí OK
Tous les tests passent!
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct TraceInput {
    pub trace_type: String,
    pub trace_log: String,
    pub pid: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileAccess {
    pub path: String,
    pub operations: Vec<String>,
    pub fd: Option<i32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkActivity {
    pub address: String,
    pub port: u16,
    pub protocol: String,
    pub direction: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TraceAnalysis {
    pub syscalls: HashMap<String, u64>,
    pub files_accessed: Vec<FileAccess>,
    pub network_activity: Vec<NetworkActivity>,
    pub memory_ops: HashMap<String, u64>,
    pub suspicious_behavior: Vec<String>,
    pub timeline: Vec<String>,
}

const SUSPICIOUS_SYSCALLS: &[&str] = &[
    "ptrace", "process_vm_readv", "process_vm_writev",
    "init_module", "delete_module", "kexec_load",
];

pub fn trace_analyzer(trace_json: &str) -> Result<String, String> {
    let input: TraceInput = serde_json::from_str(trace_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let mut syscalls: HashMap<String, u64> = HashMap::new();
    let mut files: HashMap<String, FileAccess> = HashMap::new();
    let mut network_activity = Vec::new();
    let mut memory_ops: HashMap<String, u64> = HashMap::new();
    let mut suspicious_behavior = Vec::new();
    let mut timeline = Vec::new();

    for line in input.trace_log.lines() {
        // Parse strace format: syscall(args) = result
        if let Some(paren_idx) = line.find('(') {
            let syscall = &line[..paren_idx].trim();

            // Count syscalls
            *syscalls.entry(syscall.to_string()).or_insert(0) += 1;

            // File operations
            if *syscall == "open" || *syscall == "openat" {
                if let Some(path) = extract_string_arg(line) {
                    let entry = files.entry(path.clone()).or_insert(FileAccess {
                        path: path.clone(),
                        operations: Vec::new(),
                        fd: extract_fd_result(line),
                    });
                    entry.operations.push("open".to_string());
                    timeline.push(format!("Opened: {}", path));
                }
            }

            if *syscall == "read" || *syscall == "write" {
                if let Some(fd) = extract_first_int_arg(line) {
                    for file in files.values_mut() {
                        if file.fd == Some(fd) {
                            file.operations.push(syscall.to_string());
                        }
                    }
                }
            }

            // Network operations
            if *syscall == "connect" {
                if let Some((addr, port)) = extract_connect_info(line) {
                    network_activity.push(NetworkActivity {
                        address: addr.clone(),
                        port,
                        protocol: "tcp".to_string(),
                        direction: "outbound".to_string(),
                    });
                    timeline.push(format!("Connected to {}:{}", addr, port));
                }
            }

            if *syscall == "socket" {
                *memory_ops.entry("socket_created".to_string()).or_insert(0) += 1;
            }

            // Memory operations
            if *syscall == "mmap" || *syscall == "mprotect" || *syscall == "brk" {
                *memory_ops.entry(syscall.to_string()).or_insert(0) += 1;
            }

            // Suspicious behavior
            if SUSPICIOUS_SYSCALLS.contains(&syscall.as_ref()) {
                suspicious_behavior.push(format!(
                    "Suspicious syscall detected: {} (anti-debug/rootkit indicator)",
                    syscall
                ));
            }

            // Anti-debug detection
            if *syscall == "ptrace" && line.contains("PTRACE_TRACEME") {
                suspicious_behavior.push("Anti-debugging: PTRACE_TRACEME detected".to_string());
            }
        }
    }

    // Convert files HashMap to Vec
    let files_accessed: Vec<FileAccess> = files.into_values().collect();

    let result = TraceAnalysis {
        syscalls,
        files_accessed,
        network_activity,
        memory_ops,
        suspicious_behavior,
        timeline,
    };

    serde_json::to_string_pretty(&result)
        .map_err(|e| format!("Serialization error: {}", e))
}

fn extract_string_arg(line: &str) -> Option<String> {
    let start = line.find('"')? + 1;
    let end = line[start..].find('"')? + start;
    Some(line[start..end].to_string())
}

fn extract_fd_result(line: &str) -> Option<i32> {
    let eq_idx = line.rfind('=')?;
    let result = line[eq_idx + 1..].trim().split_whitespace().next()?;
    result.parse().ok()
}

fn extract_first_int_arg(line: &str) -> Option<i32> {
    let start = line.find('(')? + 1;
    let end = line[start..].find(',').map(|i| i + start).unwrap_or(line.len());
    line[start..end].trim().parse().ok()
}

fn extract_connect_info(line: &str) -> Option<(String, u16)> {
    // Format: connect(3, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr("192.168.1.1")}, 16)
    if let Some(addr_start) = line.find("inet_addr(\"") {
        let addr_start = addr_start + 11;
        if let Some(addr_end) = line[addr_start..].find('"') {
            let addr = line[addr_start..addr_start + addr_end].to_string();

            if let Some(port_start) = line.find("htons(") {
                let port_start = port_start + 6;
                if let Some(port_end) = line[port_start..].find(')') {
                    if let Ok(port) = line[port_start..port_start + port_end].parse::<u16>() {
                        return Some((addr, port));
                    }
                }
            }
        }
    }
    None
}
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
            ANALYSE DYNAMIQUE VS STATIQUE

    ANALYSE STATIQUE              ANALYSE DYNAMIQUE
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   Fichier       ‚îÇ          ‚îÇ   Processus     ‚îÇ
    ‚îÇ   Binaire       ‚îÇ          ‚îÇ   en cours      ‚îÇ
    ‚îÇ                 ‚îÇ          ‚îÇ                 ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ          ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
    ‚îÇ  ‚îÇ   .text   ‚îÇ  ‚îÇ          ‚îÇ  ‚îÇ Ex√©cution ‚îÇ  ‚îÇ
    ‚îÇ  ‚îÇ   .data   ‚îÇ  ‚îÇ          ‚îÇ  ‚îÇ   Live    ‚îÇ  ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ          ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ                            ‚îÇ
             ‚ñº                            ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  ‚Ä¢ Code mort    ‚îÇ          ‚îÇ  ‚Ä¢ Vrais paths  ‚îÇ
    ‚îÇ  ‚Ä¢ Tous paths   ‚îÇ          ‚îÇ  ‚Ä¢ Syscalls     ‚îÇ
    ‚îÇ  ‚Ä¢ Obfuscation  ‚îÇ          ‚îÇ  ‚Ä¢ Donn√©es      ‚îÇ
    ‚îÇ    probl√®mes    ‚îÇ          ‚îÇ    runtime      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


    FLUX STRACE

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  Programme  ‚îÇ
    ‚îÇ  (tracee)   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ syscall
           ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ              KERNEL                      ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
    ‚îÇ  ‚îÇ   ptrace    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   strace    ‚îÇ     ‚îÇ
    ‚îÇ  ‚îÇ   hooks     ‚îÇ    ‚îÇ   (tracer)  ‚îÇ     ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  ‚îÇ
                                  ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ   Log Output    ‚îÇ
                         ‚îÇ open("/etc/..") ‚îÇ
                         ‚îÇ read(3, "...", )‚îÇ
                         ‚îÇ write(1, "Hi")  ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üîç MEME : "I see everything" ‚Äî Doctor Strange

Comme Doctor Strange qui voit tous les futurs possibles, strace voit tous les syscalls possibles.

```bash
$ strace ./program 2>&1 | head -5
execve("./program", ["./program"], ...) = 0
brk(NULL)                    = 0x5555...
# "I've seen 14,000,605 syscalls..."
```

---

## üìù SECTION 7 : QCM

### Question 1
**strace trace :**

A) Les appels de biblioth√®ques
B) Les appels syst√®me (syscalls)
C) Les variables d'environnement
D) Les signaux uniquement

**R√©ponse : B**

### Question 2
**Quel syscall indique une tentative d'anti-debugging ?**

A) read
B) write
C) ptrace
D) open

**R√©ponse : C**

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "exercise_slug": "3.5.9-a-dynamic-tracer",
    "metadata": {
      "exercise_id": "3.5.9-a",
      "difficulty": 8,
      "xp_base": 400
    }
  }
}
```

---

*Exercice 3.5.9-a ‚Äî Dynamic Tracer*
*"Watch. Learn. Understand."*
*HACKBRAIN v5.5.2*
