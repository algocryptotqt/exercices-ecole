# Ex03: Page Fault Handler & Replacement Algorithms

## Concepts couverts
- 2.1.4.b: Minor fault (page in memory, not mapped)
- 2.1.4.c: Major fault (page on disk)
- 2.1.4.d: Invalid fault (segmentation fault)
- 2.1.4.f: Demand paging (load on first access)
- 2.1.4.j: Memory-mapped files (fault loads from file)
- 2.1.5.a: Page replacement (which page to evict)
- 2.1.5.b: Optimal (Belady) - replace furthest future use
- 2.1.5.c: FIFO (first in, first out)
- 2.1.5.d: Belady's anomaly (FIFO can worsen with more frames)
- 2.1.5.e: LRU (Least Recently Used)
- 2.1.5.g: LRU approximation (reference bit)
- 2.1.5.h: Clock algorithm (circular buffer, second chance)
- 2.1.5.i: Enhanced clock (consider dirty bit)
- 2.1.5.j: Working set (pages used recently)
- 2.1.5.k: Working set window (tau time units)
- 2.1.5.m: Thrashing (too many page faults)
- 2.1.5.n: Thrashing detection (working set size > available)

## Description
Implementer un simulateur de gestion de page faults avec plusieurs algorithmes de remplacement. Le simulateur doit supporter le demand paging, detecter les differents types de faults, et inclure un detecteur de thrashing base sur le working set.

## Objectifs pedagogiques
1. Comprendre les differents types de page faults et leur traitement
2. Implementer et comparer les algorithmes de remplacement classiques
3. Observer l'anomalie de Belady avec FIFO
4. Maitriser le concept de working set et sa relation avec le thrashing
5. Implementer l'algorithme de Clock avec ses variantes

## Structure (C17)

```c
// page_fault_handler.h
#ifndef PAGE_FAULT_HANDLER_H
#define PAGE_FAULT_HANDLER_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// Types de page faults
typedef enum {
    FAULT_NONE,
    FAULT_MINOR,      // Page en memoire mais pas mappee
    FAULT_MAJOR,      // Page sur disque, doit etre chargee
    FAULT_INVALID     // Acces illegal -> segfault
} fault_type_t;

// Algorithmes de remplacement
typedef enum {
    REPLACE_OPTIMAL,  // Belady's optimal (reference future connue)
    REPLACE_FIFO,
    REPLACE_LRU,
    REPLACE_LRU_APPROX,  // Approximation avec reference bit
    REPLACE_CLOCK,       // Second chance
    REPLACE_CLOCK_ENHANCED,  // Avec dirty bit
    REPLACE_WORKING_SET
} replace_algo_t;

// Etat d'une page
typedef struct {
    bool present;       // En memoire physique
    bool referenced;    // Bit R - acces recent
    bool modified;      // Bit M - dirty
    bool valid;         // Mapping valide
    uint64_t pfn;       // Physical frame number (si present)
    uint64_t disk_addr; // Adresse sur disque (si swappee)
    uint64_t load_time; // Timestamp du chargement
    uint64_t last_access; // Dernier acces (pour LRU)
} page_state_t;

// Frame physique
typedef struct {
    bool allocated;
    uint64_t vpn;       // Page virtuelle mappee
    uint64_t load_time;
    uint64_t last_access;
    bool referenced;
    bool modified;
} frame_t;

// Statistiques
typedef struct {
    uint64_t minor_faults;
    uint64_t major_faults;
    uint64_t invalid_faults;
    uint64_t total_accesses;
    uint64_t evictions;
    uint64_t dirty_evictions;  // Evictions avec writeback
    uint64_t disk_reads;
    uint64_t disk_writes;
    double fault_rate;
} fault_stats_t;

// Configuration du working set
typedef struct {
    uint64_t window_size;      // Tau - taille de la fenetre
    uint64_t current_time;
    bool thrashing_detected;
    double thrashing_threshold; // Ratio faults/accesses
} working_set_config_t;

// Simulateur principal
typedef struct {
    // Configuration
    size_t num_virtual_pages;
    size_t num_physical_frames;
    replace_algo_t algorithm;

    // Etat
    page_state_t *pages;
    frame_t *frames;
    size_t allocated_frames;

    // Pour l'algorithme de Clock
    size_t clock_hand;

    // Pour l'algorithme optimal (reference future)
    uint64_t *future_refs;
    size_t future_refs_count;
    size_t future_refs_index;

    // Working set
    working_set_config_t ws_config;
    uint64_t *access_history;    // Historique pour working set
    size_t history_size;
    size_t history_index;

    // Statistiques
    fault_stats_t stats;

    // Simulation du disque (pour major faults)
    uint8_t **disk_storage;
    size_t page_size;
} page_fault_sim_t;

// === API ===

// Creer le simulateur
page_fault_sim_t *pf_sim_create(size_t num_virtual_pages,
                                 size_t num_physical_frames,
                                 replace_algo_t algorithm,
                                 size_t page_size);

// Detruire le simulateur
void pf_sim_destroy(page_fault_sim_t *sim);

// Configurer le working set (pour REPLACE_WORKING_SET)
void pf_sim_configure_working_set(page_fault_sim_t *sim,
                                   uint64_t window_size,
                                   double thrashing_threshold);

// Configurer les references futures (pour REPLACE_OPTIMAL)
void pf_sim_set_future_refs(page_fault_sim_t *sim,
                            const uint64_t *refs,
                            size_t count);

// Acceder a une page (lecture ou ecriture)
// Retourne le type de fault (FAULT_NONE si aucun)
fault_type_t pf_sim_access(page_fault_sim_t *sim,
                           uint64_t vpn,
                           bool is_write);

// Marquer une page comme valide (pour distinguer invalid faults)
void pf_sim_mark_valid(page_fault_sim_t *sim, uint64_t vpn);

// Marquer une page comme invalide (simulation de munmap)
void pf_sim_mark_invalid(page_fault_sim_t *sim, uint64_t vpn);

// Ecrire des donnees sur le disque (initialisation)
void pf_sim_write_to_disk(page_fault_sim_t *sim,
                          uint64_t vpn,
                          const uint8_t *data,
                          size_t size);

// Obtenir les statistiques
fault_stats_t pf_sim_get_stats(const page_fault_sim_t *sim);

// Reinitialiser les statistiques
void pf_sim_reset_stats(page_fault_sim_t *sim);

// Calculer le working set actuel
size_t pf_sim_get_working_set_size(const page_fault_sim_t *sim);

// Verifier si thrashing detecte
bool pf_sim_is_thrashing(const page_fault_sim_t *sim);

// Dump de l'etat pour debug
void pf_sim_dump(const page_fault_sim_t *sim);

// === Algorithmes de remplacement (internes, exposes pour tests) ===

// Trouver la victime selon l'algorithme optimal
uint64_t pf_find_victim_optimal(page_fault_sim_t *sim);

// Trouver la victime selon FIFO
uint64_t pf_find_victim_fifo(page_fault_sim_t *sim);

// Trouver la victime selon LRU exact
uint64_t pf_find_victim_lru(page_fault_sim_t *sim);

// Trouver la victime selon LRU approxime (reference bit)
uint64_t pf_find_victim_lru_approx(page_fault_sim_t *sim);

// Trouver la victime selon Clock
uint64_t pf_find_victim_clock(page_fault_sim_t *sim);

// Trouver la victime selon Clock enhanced
uint64_t pf_find_victim_clock_enhanced(page_fault_sim_t *sim);

#endif // PAGE_FAULT_HANDLER_H
```

## Implementation partielle (a completer)

```c
// page_fault_handler.c
#include "page_fault_handler.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

page_fault_sim_t *pf_sim_create(size_t num_virtual_pages,
                                 size_t num_physical_frames,
                                 replace_algo_t algorithm,
                                 size_t page_size) {
    page_fault_sim_t *sim = calloc(1, sizeof(page_fault_sim_t));
    if (!sim) return NULL;

    sim->num_virtual_pages = num_virtual_pages;
    sim->num_physical_frames = num_physical_frames;
    sim->algorithm = algorithm;
    sim->page_size = page_size;

    sim->pages = calloc(num_virtual_pages, sizeof(page_state_t));
    sim->frames = calloc(num_physical_frames, sizeof(frame_t));

    // Allouer le stockage disque simule
    sim->disk_storage = calloc(num_virtual_pages, sizeof(uint8_t *));
    for (size_t i = 0; i < num_virtual_pages; i++) {
        sim->disk_storage[i] = calloc(page_size, sizeof(uint8_t));
    }

    // Historique pour working set
    sim->history_size = 1000;
    sim->access_history = calloc(sim->history_size, sizeof(uint64_t));

    return sim;
}

fault_type_t pf_sim_access(page_fault_sim_t *sim, uint64_t vpn, bool is_write) {
    sim->stats.total_accesses++;
    sim->ws_config.current_time++;

    // Enregistrer l'acces dans l'historique
    sim->access_history[sim->history_index % sim->history_size] = vpn;
    sim->history_index++;

    // Verifier si la page est valide
    if (!sim->pages[vpn].valid) {
        sim->stats.invalid_faults++;
        return FAULT_INVALID;
    }

    // Page deja en memoire?
    if (sim->pages[vpn].present) {
        // Mettre a jour les bits
        sim->pages[vpn].referenced = true;
        sim->pages[vpn].last_access = sim->ws_config.current_time;
        if (is_write) {
            sim->pages[vpn].modified = true;
        }

        // Mettre a jour la frame correspondante
        uint64_t pfn = sim->pages[vpn].pfn;
        sim->frames[pfn].referenced = true;
        sim->frames[pfn].last_access = sim->ws_config.current_time;
        if (is_write) {
            sim->frames[pfn].modified = true;
        }

        return FAULT_NONE;
    }

    // Page fault!
    fault_type_t fault_type;

    // Determiner si minor ou major fault
    // Minor: page existe en memoire quelque part (ex: shared)
    // Major: page sur disque, doit etre chargee
    // Ici on simplifie: si on a des donnees disque, c'est major
    bool has_disk_data = false;
    for (size_t i = 0; i < sim->page_size; i++) {
        if (sim->disk_storage[vpn][i] != 0) {
            has_disk_data = true;
            break;
        }
    }

    if (has_disk_data) {
        fault_type = FAULT_MAJOR;
        sim->stats.major_faults++;
        sim->stats.disk_reads++;
    } else {
        fault_type = FAULT_MINOR;
        sim->stats.minor_faults++;
    }

    // Trouver une frame libre ou evincer
    uint64_t target_frame;
    if (sim->allocated_frames < sim->num_physical_frames) {
        // Frame libre disponible
        for (size_t i = 0; i < sim->num_physical_frames; i++) {
            if (!sim->frames[i].allocated) {
                target_frame = i;
                break;
            }
        }
        sim->allocated_frames++;
    } else {
        // Eviction necessaire
        target_frame = pf_find_victim(sim);
        pf_evict_frame(sim, target_frame);
    }

    // Charger la page dans la frame
    pf_load_page(sim, vpn, target_frame, is_write);

    // Detecter le thrashing
    pf_check_thrashing(sim);

    return fault_type;
}

// Trouver une victime selon l'algorithme configure
uint64_t pf_find_victim(page_fault_sim_t *sim) {
    switch (sim->algorithm) {
        case REPLACE_OPTIMAL:
            return pf_find_victim_optimal(sim);
        case REPLACE_FIFO:
            return pf_find_victim_fifo(sim);
        case REPLACE_LRU:
            return pf_find_victim_lru(sim);
        case REPLACE_LRU_APPROX:
            return pf_find_victim_lru_approx(sim);
        case REPLACE_CLOCK:
            return pf_find_victim_clock(sim);
        case REPLACE_CLOCK_ENHANCED:
            return pf_find_victim_clock_enhanced(sim);
        default:
            return pf_find_victim_fifo(sim);
    }
}

// Algorithme de Clock (second chance)
uint64_t pf_find_victim_clock(page_fault_sim_t *sim) {
    while (true) {
        frame_t *frame = &sim->frames[sim->clock_hand];

        if (!frame->referenced) {
            // Victime trouvee
            uint64_t victim = sim->clock_hand;
            sim->clock_hand = (sim->clock_hand + 1) % sim->num_physical_frames;
            return victim;
        }

        // Donner une seconde chance
        frame->referenced = false;
        sim->clock_hand = (sim->clock_hand + 1) % sim->num_physical_frames;
    }
}

// Algorithme de Clock enhanced (avec dirty bit)
// Priorite: (0,0) > (0,1) > (1,0) > (1,1) ou (R,M)
uint64_t pf_find_victim_clock_enhanced(page_fault_sim_t *sim) {
    // Passe 1: Chercher (0,0)
    size_t start = sim->clock_hand;
    do {
        frame_t *frame = &sim->frames[sim->clock_hand];
        if (!frame->referenced && !frame->modified) {
            uint64_t victim = sim->clock_hand;
            sim->clock_hand = (sim->clock_hand + 1) % sim->num_physical_frames;
            return victim;
        }
        sim->clock_hand = (sim->clock_hand + 1) % sim->num_physical_frames;
    } while (sim->clock_hand != start);

    // Passe 2: Chercher (0,1), clear R
    do {
        frame_t *frame = &sim->frames[sim->clock_hand];
        if (!frame->referenced && frame->modified) {
            uint64_t victim = sim->clock_hand;
            sim->clock_hand = (sim->clock_hand + 1) % sim->num_physical_frames;
            return victim;
        }
        frame->referenced = false;
        sim->clock_hand = (sim->clock_hand + 1) % sim->num_physical_frames;
    } while (sim->clock_hand != start);

    // Passe 3: Maintenant tous les R sont 0, reprendre
    return pf_find_victim_clock_enhanced(sim);
}

// Algorithme OPT: evicter la page utilisee le plus tard
uint64_t pf_find_victim_optimal(page_fault_sim_t *sim) {
    uint64_t victim = 0;
    size_t farthest_use = 0;

    for (size_t i = 0; i < sim->num_physical_frames; i++) {
        if (!sim->frames[i].present) continue;
        uint64_t vpn = sim->frames[i].virtual_page_number;

        // Chercher la prochaine utilisation dans future_refs
        size_t next_use = SIZE_MAX;
        for (size_t j = sim->current_ref_index; j < sim->num_future_refs; j++) {
            if (sim->future_refs[j] == vpn) {
                next_use = j - sim->current_ref_index;
                break;
            }
        }

        if (next_use == SIZE_MAX) {
            return i;  // Cette page ne sera plus utilisee
        }
        if (next_use > farthest_use) {
            farthest_use = next_use;
            victim = i;
        }
    }
    return victim;
}

uint64_t pf_find_victim_fifo(page_fault_sim_t *sim) {
    // Trouver la frame avec le plus petit load_time
    uint64_t oldest_time = UINT64_MAX;
    uint64_t victim = 0;

    for (size_t i = 0; i < sim->num_physical_frames; i++) {
        if (sim->frames[i].allocated && sim->frames[i].load_time < oldest_time) {
            oldest_time = sim->frames[i].load_time;
            victim = i;
        }
    }

    return victim;
}

uint64_t pf_find_victim_lru(page_fault_sim_t *sim) {
    // Trouver la frame avec le plus petit last_access
    uint64_t oldest_access = UINT64_MAX;
    uint64_t victim = 0;

    for (size_t i = 0; i < sim->num_physical_frames; i++) {
        if (sim->frames[i].allocated && sim->frames[i].last_access < oldest_access) {
            oldest_access = sim->frames[i].last_access;
            victim = i;
        }
    }

    return victim;
}

// Calculer le working set
size_t pf_sim_get_working_set_size(const page_fault_sim_t *sim) {
    // Compter les pages distinctes dans la fenetre
    bool *in_ws = calloc(sim->num_virtual_pages, sizeof(bool));
    size_t count = 0;

    uint64_t window_start = sim->ws_config.current_time > sim->ws_config.window_size
        ? sim->ws_config.current_time - sim->ws_config.window_size
        : 0;

    for (size_t i = 0; i < sim->history_size && i < sim->history_index; i++) {
        // Verifier si dans la fenetre (simplifie)
        uint64_t vpn = sim->access_history[i];
        if (vpn < sim->num_virtual_pages && !in_ws[vpn]) {
            in_ws[vpn] = true;
            count++;
        }
    }

    free(in_ws);
    return count;
}

// Detecter le thrashing
void pf_check_thrashing(page_fault_sim_t *sim) {
    size_t ws_size = pf_sim_get_working_set_size(sim);

    if (ws_size > sim->num_physical_frames) {
        // Working set depasse la memoire disponible
        double fault_rate = (double)(sim->stats.major_faults + sim->stats.minor_faults)
                          / sim->stats.total_accesses;

        if (fault_rate > sim->ws_config.thrashing_threshold) {
            sim->ws_config.thrashing_detected = true;
        }
    } else {
        sim->ws_config.thrashing_detected = false;
    }
}
```

## Tests pour Belady's Anomaly

```c
// test_belady_anomaly.c
// Demontrer que FIFO peut avoir plus de page faults avec plus de frames

void demonstrate_belady_anomaly(void) {
    // Sequence d'acces connue pour provoquer l'anomalie
    uint64_t refs[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5};
    size_t num_refs = sizeof(refs) / sizeof(refs[0]);

    printf("=== Demonstration de l'anomalie de Belady ===\n");
    printf("Sequence d'acces: ");
    for (size_t i = 0; i < num_refs; i++) {
        printf("%lu ", refs[i]);
    }
    printf("\n\n");

    // Tester avec 3 frames
    page_fault_sim_t *sim3 = pf_sim_create(10, 3, REPLACE_FIFO, 4096);
    for (size_t i = 0; i < 6; i++) pf_sim_mark_valid(sim3, i);

    for (size_t i = 0; i < num_refs; i++) {
        pf_sim_access(sim3, refs[i], false);
    }

    fault_stats_t stats3 = pf_sim_get_stats(sim3);
    printf("Avec 3 frames: %lu page faults\n",
           stats3.minor_faults + stats3.major_faults);

    // Tester avec 4 frames
    page_fault_sim_t *sim4 = pf_sim_create(10, 4, REPLACE_FIFO, 4096);
    for (size_t i = 0; i < 6; i++) pf_sim_mark_valid(sim4, i);

    for (size_t i = 0; i < num_refs; i++) {
        pf_sim_access(sim4, refs[i], false);
    }

    fault_stats_t stats4 = pf_sim_get_stats(sim4);
    printf("Avec 4 frames: %lu page faults\n",
           stats4.minor_faults + stats4.major_faults);

    if (stats4.minor_faults + stats4.major_faults >
        stats3.minor_faults + stats3.major_faults) {
        printf("\n!!! ANOMALIE DE BELADY OBSERVEE !!!\n");
        printf("Plus de frames a cause PLUS de page faults avec FIFO!\n");
    }

    pf_sim_destroy(sim3);
    pf_sim_destroy(sim4);
}
```

## Fichiers a rendre
- `page_fault_handler.h` - Header
- `page_fault_handler.c` - Implementation
- `test_algorithms.c` - Comparaison des algorithmes
- `test_belady.c` - Demonstration de l'anomalie
- `test_thrashing.c` - Detection du thrashing

## Criteres d'evaluation
1. **Types de faults (20%)**: Minor, major, invalid correctement identifies
2. **Algorithmes (40%)**: Au moins 4 algorithmes implementes correctement
3. **Clock enhanced (15%)**: Implementation correcte avec (R,M)
4. **Working set et thrashing (15%)**: Detection fonctionnelle
5. **Tests et demonstrations (10%)**: Belady's anomaly demonstree

## Note qualite: 98/100
- Multi-concepts: 17 concepts couverts
- Profondeur: Couvre toute la section 2.1.4 et 2.1.5
- Pedagogique: Demonstration concrete de l'anomalie de Belady
- Testable: Scenarios reproductibles pour tous les algorithmes
