<thinking>
## Analyse du Concept
- Concept : Buddy System & Slab Allocator (allocateurs kernel avancÃ©s)
- Phase demandÃ©e : 2
- AdaptÃ© ? OUI - Concepts intermÃ©diaires-avancÃ©s de gestion mÃ©moire, parfait pour Phase 2

## Combo Base + Bonus
- Exercice de base : ImplÃ©menter buddy system (split/coalesce) + slab allocator (caches/Ã©tats/coloring)
- Bonus : Optimisation lock-free pour multi-threading + NUMA awareness
- Palier bonus : ğŸ’€ Expert (difficile 8/10)
- Progression logique ? OUI - Base = algorithmes fondamentaux, Bonus = optimisation concurrente

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : Rust ownership, pointeurs, allocation mÃ©moire basique, bitwise operations
- DifficultÃ© estimÃ©e : 6/10 base, 8/10 bonus
- CohÃ©rent avec phase ? OUI (Phase 2 = 4-6/10)

## Aspect Fun/Culture
- Contexte choisi : Dragon Ball Z
- MEME mnÃ©motechnique : "FUSION-HA!" pour buddy coalesce, Cell splitting pour buddy split
- Pourquoi c'est fun :
  - Fusion Dance = deux buddies de mÃªme puissance qui fusionnent
  - Cell qui se divise = buddy split en deux parties Ã©gales
  - Power levels = tailles de blocs (puissances de 2)
  - Hyperbolic Time Chamber = slab caches organisÃ©s par type d'entraÃ®nement
  - Super Saiyan transformations = diffÃ©rents ordres de buddy
  - Tournament Arena = arena allocator avec bump pointer

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Boundary) : XOR formula inversÃ©e - `addr ^ size` devient `addr | size`
2. Mutant B (Safety) : Pas de vÃ©rification des limites dans buddy_address - buddy hors rÃ©gion
3. Mutant C (Resource) : Oubli de retirer le buddy de la free list avant coalesce
4. Mutant D (Logic) : Coalesce avec le mauvais ordre - current_order non incrÃ©mentÃ©
5. Mutant E (Return) : Slab state incorrect - Empty retournÃ© quand Partial

## Verdict
VALIDE - Analogie Dragon Ball Z parfaite pour buddy/slab, excellente progression pÃ©dagogique
Note qualitÃ© estimÃ©e : 96/100
</thinking>

---

# Exercice 2.1.5 : saiyan_allocator

**Module :**
2.1 â€” Memory Management

**Concept :**
e â€” Buddy System & Slab Allocator

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10)

**Type :**
complet

**Tiers :**
2 â€” MÃ©lange (concepts buddy + slab + arena)

**Langage :**
Rust (Edition 2024)

**PrÃ©requis :**
- Rust ownership et borrowing
- Pointeurs et rÃ©fÃ©rences
- OpÃ©rations bitwise (XOR, shifts)
- Allocation mÃ©moire basique (malloc/free concepts)
- Puissances de 2 et alignement

**Domaines :**
Mem, CPU, Struct

**DurÃ©e estimÃ©e :**
180 min

**XP Base :**
450

**ComplexitÃ© :**
T3 O(log n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
```
src/
â”œâ”€â”€ lib.rs           # Buddy + Slab + Arena allocators
â”œâ”€â”€ main.rs          # DÃ©monstration et tests visuels
â””â”€â”€ benches/
    â””â”€â”€ allocator_bench.rs  # Benchmarks comparatifs
```

**Fonctions autorisÃ©es :**
- `std::alloc::{alloc, dealloc, Layout}`
- `std::collections::HashMap`
- `std::ptr::NonNull`
- Toutes les opÃ©rations arithmÃ©tiques et bitwise

**Fonctions interdites :**
- `unsafe` blocks non justifiÃ©s
- External crates d'allocation (jemalloc, mimalloc)

---

### 1.2 Consigne

#### 1.2.1 Contexte Culturel â€” Dragon Ball Z : L'Allocateur des Saiyans

**ğŸ‰ "FUSION-HA!" â€” Quand la mÃ©moire fusionne comme Goku et Vegeta**

Dans l'univers de Dragon Ball Z, les guerriers Saiyans maÃ®trisent deux techniques lÃ©gendaires :

1. **La Division de Cell** : Cell peut se diviser en versions plus petites mais Ã©gales de lui-mÃªme. Chaque "mini-Cell" a exactement la moitiÃ© de la puissance originale. C'est le **Buddy Split**.

2. **La Fusion Dance** : Goku et Vegeta exÃ©cutent la danse de fusion pour devenir Gogeta. Pour que la fusion fonctionne, les deux guerriers doivent avoir un **niveau de puissance Ã©quivalent**. C'est le **Buddy Coalesce**.

La formule secrÃ¨te de la fusion ? **L'adresse du buddy = Adresse XOR Taille** â€” aussi Ã©lÃ©gante que le Kamehameha !

**L'Hyperbolic Time Chamber** reprÃ©sente les **Slab Caches** : des salles spÃ©cialisÃ©es par type d'entraÃ®nement (combat, ki, endurance). Chaque salle contient des "slots" d'entraÃ®nement de taille fixe.

Les **Ã©tats des Slabs** correspondent aux Ã©tats des guerriers :
- **Full** : Tous les guerriers sont Ã  pleine puissance (occupÃ©s)
- **Partial** : Certains rÃ©cupÃ¨rent, d'autres combattent
- **Empty** : Salle de rÃ©cupÃ©ration complÃ¨te

Le **Slab Coloring** ? C'est comme les transformations Super Saiyan â€” chaque couleur (SS1 jaune, SSB bleu, etc.) reprÃ©sente un alignement diffÃ©rent pour Ã©viter les conflits de cache !

**Ta mission :**

CrÃ©er le `SaiyanAllocator`, un systÃ¨me d'allocation mÃ©moire digne du Prince des Saiyans, combinant :
- Un **Buddy Allocator** pour la gestion des pages (Cell splitting/fusion)
- Un **Slab Allocator** pour les objets de taille fixe (Hyperbolic Time Chamber)
- Un **Arena Allocator** bonus (Tournament Arena)

---

#### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter deux allocateurs mÃ©moire avancÃ©s utilisÃ©s dans les kernels modernes :

**1. Buddy Allocator :**
- GÃ¨re une rÃ©gion mÃ©moire en blocs de puissances de 2
- **Split** : divise un bloc en deux "buddies" de taille Ã©gale
- **Coalesce** : fusionne deux buddies adjacents libres
- Formule d'adresse du buddy : `buddy_addr = addr XOR size`

**2. Slab Allocator :**
- OptimisÃ© pour les allocations rÃ©pÃ©tÃ©es d'objets de mÃªme taille
- Organise les objets en "slabs" (pages) regroupÃ©s en "caches"
- Trois Ã©tats : Empty, Partial, Full
- **Slab Coloring** : dÃ©calage variable pour distribution cache L1

**3. Arena Allocator (optionnel) :**
- Allocation O(1) avec bump pointer
- LibÃ©ration en masse O(1) avec reset

**EntrÃ©e :**
- Configuration : taille de rÃ©gion, taille d'objets, alignement

**Sortie :**
- Adresses allouÃ©es
- Statistiques d'allocation (splits, coalesces, fragmentation)

---

### 1.3 Prototype

```rust
// ============================================
// BUDDY ALLOCATOR â€” La Division de Cell
// ============================================

pub const MIN_ORDER: usize = 12;  // 4KB minimum (niveau de puissance minimum)
pub const MAX_ORDER: usize = 20;  // 1MB maximum (Super Saiyan God)
pub const NUM_ORDERS: usize = MAX_ORDER - MIN_ORDER + 1;

/// Statistiques de combat du Buddy Allocator
#[derive(Debug, Default)]
pub struct CellStats {
    pub divisions: u64,      // splits
    pub fusions: u64,        // coalesces
    pub allocations: u64,
    pub liberations: u64,
    pub fragmentation_interne: u64,
}

/// Buddy Allocator â€” Le systÃ¨me de Cell
pub struct CellAllocator {
    base: usize,
    total_size: usize,
    free_lists: [Vec<usize>; NUM_ORDERS],
    allocated_bitmap: Vec<bool>,
    stats: CellStats,
}

impl CellAllocator {
    /// CrÃ©er un nouvel allocateur Cell
    pub fn new(base: usize, size: usize) -> Self;

    /// Allouer un bloc (Cell se divise si nÃ©cessaire)
    pub fn allocate(&mut self, size: usize) -> Option<usize>;

    /// LibÃ©rer un bloc (fusion si le buddy est libre)
    pub fn free(&mut self, addr: usize, size: usize);

    /// LA FORMULE MAGIQUE : buddy_addr = addr XOR size
    pub fn get_buddy_address(&self, addr: usize, order: usize) -> usize;
}

// ============================================
// SLAB ALLOCATOR â€” Hyperbolic Time Chamber
// ============================================

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum WarriorState {
    Exhausted,  // Empty - tous rÃ©cupÃ¨rent
    Training,   // Partial - mix actifs/repos
    FullPower,  // Full - tous en combat
}

/// Un Slab = une salle d'entraÃ®nement
pub struct TrainingRoom {
    base: usize,
    object_size: usize,
    num_slots: usize,
    free_slots: Vec<usize>,
    color_offset: usize,  // Transformation Super Saiyan
}

/// Cache de Slabs = Hyperbolic Time Chamber
pub struct HyperbolicChamber {
    name: String,
    object_size: usize,
    rooms_partial: Vec<TrainingRoom>,
    rooms_full: Vec<TrainingRoom>,
    rooms_empty: Vec<TrainingRoom>,
    next_color: usize,
    stats: ChamberStats,
}

impl HyperbolicChamber {
    pub fn new(name: &str, object_size: usize, alignment: usize) -> Self;
    pub fn alloc(&mut self, buddy: &mut CellAllocator) -> Option<usize>;
    pub fn free(&mut self, addr: usize, buddy: &mut CellAllocator) -> bool;
}

// ============================================
// ARENA ALLOCATOR â€” Tournament Arena
// ============================================

pub struct TournamentArena {
    base: usize,
    size: usize,
    next_fighter: usize,  // bump pointer
}

impl TournamentArena {
    pub fn new(base: usize, size: usize) -> Self;
    pub fn call_next_fighter(&mut self, size: usize, alignment: usize) -> Option<usize>;
    pub fn reset_tournament(&mut self);  // Tous Ã©liminÃ©s, on recommence !
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 La Formule XOR â€” L'Ã‰lÃ©gance du Buddy System

La formule `buddy_addr = addr XOR size` est un chef-d'Å“uvre d'Ã©lÃ©gance mathÃ©matique !

**Pourquoi Ã§a marche :**
- Les adresses sont alignÃ©es sur des puissances de 2
- XOR avec la taille "flip" exactement le bon bit
- L'opÃ©ration est sa propre inverse : `buddy(buddy(addr)) = addr`

```
Exemple avec bloc 4KB (0x1000) Ã  l'adresse 0x10000:

    0x10000 = 0001 0000 0000 0000 0000
XOR 0x01000 = 0000 0001 0000 0000 0000
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0x11000 = 0001 0001 0000 0000 0000  â† Adresse du buddy !

VÃ©rification inverse:
    0x11000 XOR 0x01000 = 0x10000  âœ“
```

### 2.2 Pourquoi le Slab Coloring ?

Les caches CPU L1 ont une taille limitÃ©e (32-64KB). Si tous les premiers objets de chaque slab ont le mÃªme offset, ils se battent pour les mÃªmes lignes de cache !

Le **coloring** dÃ©cale chaque nouveau slab d'un offset diffÃ©rent, distribuant les objets sur diffÃ©rentes lignes de cache. C'est comme les transformations Super Saiyan : chaque couleur (dÃ©calage) Ã©vite les conflits !

---

## 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Kernel Developer** | Linux utilise le buddy system pour `/proc/buddyinfo` et SLUB pour les objets kernel |
| **Game Engine Dev** | Pool allocators (variante de slab) pour les entitÃ©s de jeu |
| **Database Engineer** | Buffer pools avec buddy allocation pour les pages |
| **Embedded Systems** | Arena allocators pour les systÃ¨mes temps-rÃ©el sans fragmentation |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
src/  Cargo.toml

$ cargo build --release

$ cargo run
=== CELL ALLOCATOR (Buddy System) ===
Cell division: 0x10000 -> 0x10000 + 0x11000
Allocation 4KB: 0x10000
Allocation 4KB: 0x11000
FUSION-HA! 0x10000 + 0x11000 -> 0x10000 (8KB)

=== HYPERBOLIC TIME CHAMBER (Slab Cache) ===
Training room created: 63 slots of 64B
Warrior allocated at: 0x20040 (color offset: 64)
State: Training (Partial)

=== TOURNAMENT ARENA ===
Fighter 1: 0x30000
Fighter 2: 0x30064
RESET! Tournament recommence.

Stats Cell: divisions=3, fusions=1
Stats Chamber: rooms_created=1, cache_hits=45
```

---

## ğŸ’€ SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—4

**Time Complexity attendue :**
O(1) amortized pour allocation/libÃ©ration

**Space Complexity attendue :**
O(log n) pour les free lists

**Domaines Bonus :**
`Process, CPU`

### 3.1.1 Consigne Bonus â€” La Fusion Potara (Lock-Free)

**ğŸ”® La Fusion Potara â€” Sans Limite de Temps !**

Contrairement Ã  la Fusion Dance limitÃ©e Ã  30 minutes, les **Potara Earrings** crÃ©ent une fusion permanente et instantanÃ©e !

ImplÃ©mente une version **lock-free** du buddy allocator utilisant les opÃ©rations atomiques Compare-And-Swap (CAS), comme les Potara qui fusionnent instantanÃ©ment sans le rituel de la danse.

**Ta mission bonus :**

1. **Lock-Free Free Lists** avec `AtomicPtr` et CAS
2. **Per-CPU Slab Caches** pour Ã©viter la contention
3. **NUMA Awareness** : allouer depuis le nÅ“ud mÃ©moire local

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Threads concurrents : 8-64            â”‚
â”‚  Pas de Mutex/RwLock global            â”‚
â”‚  Memory ordering : Acquire/Release     â”‚
â”‚  Pas de spinlock prolongÃ©              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```rust
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};

pub struct PotaraAllocator {
    // Lock-free free list avec tagged pointers
    free_lists: [AtomicPtr<FreeNode>; NUM_ORDERS],
    // Per-CPU caches
    cpu_caches: Vec<LocalCache>,
    // ABA counter
    version: AtomicUsize,
}

impl PotaraAllocator {
    /// Allocation lock-free avec CAS
    pub fn allocate_lockfree(&self, size: usize) -> Option<NonNull<u8>>;

    /// LibÃ©ration lock-free
    pub fn free_lockfree(&self, ptr: NonNull<u8>, size: usize);
}
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Synchronisation | Single-threaded | Lock-free avec CAS |
| Free lists | Vec<usize> | AtomicPtr + tagged pointers |
| Slab caches | Global | Per-CPU |
| ComplexitÃ© | O(log n) | O(1) amortized |
| ABA Problem | N/A | RÃ©solu avec version counter |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points | RÃ©sultat Attendu |
|------|-------------|--------|------------------|
| `test_cell_division` | Buddy split basique | 10 | 2 blocs Ã©gaux |
| `test_fusion_ha` | Buddy coalesce | 15 | Bloc fusionnÃ© |
| `test_xor_formula` | Calcul buddy address | 10 | Formule correcte |
| `test_chamber_states` | Ã‰tats Full/Partial/Empty | 15 | Transitions correctes |
| `test_slab_coloring` | Offsets variÃ©s | 10 | â‰¥2 couleurs diffÃ©rentes |
| `test_arena_bump` | Bump pointer | 10 | Adresses croissantes |
| `test_arena_reset` | Reset complet | 5 | offset = 0 |
| `test_integration` | Buddy + Slab ensemble | 15 | Pas de corruption |
| `test_fragmentation` | Stats fragmentation | 10 | Valeurs cohÃ©rentes |

### 4.2 main.rs de test

```rust
use saiyan_allocator::*;

fn main() {
    println!("=== DRAGON BALL Z ALLOCATOR ===\n");

    // Test Cell Allocator (Buddy)
    let mut cell = CellAllocator::new(0x10000, 1 << 16);

    let a1 = cell.allocate(4096).expect("Allocation failed");
    let a2 = cell.allocate(4096).expect("Allocation failed");
    println!("Cell divisions: {} blocks allocated", 2);

    // Test buddy address formula
    let buddy = cell.get_buddy_address(a1, 12);
    println!("Buddy of 0x{:x} = 0x{:x}", a1, buddy);
    assert_eq!(buddy, a1 ^ (1 << 12));

    // Test fusion
    cell.free(a1, 4096);
    cell.free(a2, 4096);
    println!("FUSION-HA! Coalesces: {}", cell.stats().fusions);

    // Test Hyperbolic Chamber (Slab)
    let mut chamber = HyperbolicChamber::new("warriors", 64, 8);
    let mut cell2 = CellAllocator::new(0x100000, 1 << 20);

    let w1 = chamber.alloc(&mut cell2).expect("Warrior failed");
    let w2 = chamber.alloc(&mut cell2).expect("Warrior failed");
    println!("\nWarriors training at: 0x{:x}, 0x{:x}", w1, w2);

    // Test Arena
    let mut arena = TournamentArena::new(0x200000, 4096);
    let f1 = arena.call_next_fighter(100, 8).expect("Fighter failed");
    let f2 = arena.call_next_fighter(200, 16).expect("Fighter failed");
    println!("\nTournament fighters: 0x{:x}, 0x{:x}", f1, f2);

    arena.reset_tournament();
    println!("Tournament reset! Next fighter starts at: 0x{:x}",
             arena.call_next_fighter(50, 8).unwrap());

    println!("\n=== ALL TESTS PASSED ===");
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
// src/lib.rs â€” Solution complÃ¨te

use std::collections::HashMap;

pub const MIN_ORDER: usize = 12;
pub const MAX_ORDER: usize = 20;
pub const NUM_ORDERS: usize = MAX_ORDER - MIN_ORDER + 1;

// ============================================
// CELL ALLOCATOR (Buddy System)
// ============================================

#[derive(Debug, Default, Clone)]
pub struct CellStats {
    pub allocations: u64,
    pub liberations: u64,
    pub divisions: u64,
    pub fusions: u64,
    pub fragmentation_interne: u64,
}

pub struct CellAllocator {
    base: usize,
    total_size: usize,
    free_lists: [Vec<usize>; NUM_ORDERS],
    allocated_bitmap: Vec<bool>,
    stats: CellStats,
}

impl CellAllocator {
    pub fn new(base: usize, size: usize) -> Self {
        assert!(size.is_power_of_two(), "Size must be power of 2");
        assert!(size >= (1 << MIN_ORDER), "Size too small for Saiyan!");
        assert!(size <= (1 << MAX_ORDER), "Even Goku has limits!");

        let order = size.trailing_zeros() as usize;
        let order_index = order - MIN_ORDER;

        let mut alloc = Self {
            base,
            total_size: size,
            free_lists: Default::default(),
            allocated_bitmap: vec![false; size / (1 << MIN_ORDER)],
            stats: CellStats::default(),
        };

        alloc.free_lists[order_index].push(base);
        alloc
    }

    pub fn allocate(&mut self, size: usize) -> Option<usize> {
        let size = size.max(1 << MIN_ORDER);
        let order = (size.next_power_of_two().trailing_zeros() as usize).max(MIN_ORDER);

        if order > MAX_ORDER {
            return None;
        }

        let order_index = order - MIN_ORDER;

        // Chercher un bloc libre
        for i in order_index..NUM_ORDERS {
            if !self.free_lists[i].is_empty() {
                let block_addr = self.free_lists[i].pop().unwrap();

                // Cell se divise jusqu'Ã  l'ordre dÃ©sirÃ©
                let mut current_order = i + MIN_ORDER;
                let mut current_addr = block_addr;

                while current_order > order {
                    self.stats.divisions += 1;
                    current_order -= 1;

                    // Le buddy = la moitiÃ© droite
                    let buddy_addr = current_addr + (1 << current_order);
                    self.free_lists[current_order - MIN_ORDER].push(buddy_addr);
                }

                self.mark_allocated(current_addr, order);
                self.stats.allocations += 1;

                let actual_size = 1 << order;
                self.stats.fragmentation_interne += (actual_size - size) as u64;

                return Some(current_addr);
            }
        }

        None
    }

    pub fn free(&mut self, addr: usize, size: usize) {
        let size = size.max(1 << MIN_ORDER);
        let order = (size.next_power_of_two().trailing_zeros() as usize).max(MIN_ORDER);
        let mut current_order = order;
        let mut current_addr = addr;

        self.mark_free(addr, order);
        self.stats.liberations += 1;

        // FUSION-HA! Tenter de fusionner avec le buddy
        while current_order < MAX_ORDER {
            let buddy_addr = self.get_buddy_address(current_addr, current_order);

            if self.is_free_at_order(buddy_addr, current_order) {
                let order_index = current_order - MIN_ORDER;
                if let Some(pos) = self.free_lists[order_index]
                    .iter()
                    .position(|&a| a == buddy_addr)
                {
                    self.free_lists[order_index].remove(pos);
                    self.stats.fusions += 1;

                    // La fusion commence Ã  l'adresse la plus basse
                    current_addr = current_addr.min(buddy_addr);
                    current_order += 1;
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        self.free_lists[current_order - MIN_ORDER].push(current_addr);
    }

    /// LA FORMULE MAGIQUE : buddy_addr = addr XOR size
    pub fn get_buddy_address(&self, addr: usize, order: usize) -> usize {
        let size = 1 << order;
        addr ^ size  // FUSION-HA!
    }

    fn mark_allocated(&mut self, addr: usize, order: usize) {
        let start_page = (addr - self.base) / (1 << MIN_ORDER);
        let num_pages = 1 << (order - MIN_ORDER);
        for i in 0..num_pages {
            if start_page + i < self.allocated_bitmap.len() {
                self.allocated_bitmap[start_page + i] = true;
            }
        }
    }

    fn mark_free(&mut self, addr: usize, order: usize) {
        let start_page = (addr - self.base) / (1 << MIN_ORDER);
        let num_pages = 1 << (order - MIN_ORDER);
        for i in 0..num_pages {
            if start_page + i < self.allocated_bitmap.len() {
                self.allocated_bitmap[start_page + i] = false;
            }
        }
    }

    fn is_free_at_order(&self, addr: usize, order: usize) -> bool {
        if addr < self.base || addr >= self.base + self.total_size {
            return false;
        }

        let start_page = (addr - self.base) / (1 << MIN_ORDER);
        let num_pages = 1 << (order - MIN_ORDER);

        for i in 0..num_pages {
            if start_page + i >= self.allocated_bitmap.len() {
                return false;
            }
            if self.allocated_bitmap[start_page + i] {
                return false;
            }
        }
        true
    }

    pub fn stats(&self) -> &CellStats {
        &self.stats
    }
}

// ============================================
// HYPERBOLIC CHAMBER (Slab Allocator)
// ============================================

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum WarriorState {
    Exhausted,  // Empty
    Training,   // Partial
    FullPower,  // Full
}

pub struct TrainingRoom {
    base: usize,
    object_size: usize,
    num_slots: usize,
    free_count: usize,
    free_slots: Vec<usize>,
    color_offset: usize,
}

impl TrainingRoom {
    pub fn new(base: usize, page_size: usize, object_size: usize, color_offset: usize) -> Self {
        let effective_start = base + color_offset;
        let available_size = page_size - color_offset;
        let num_slots = available_size / object_size;

        let mut free_slots = Vec::with_capacity(num_slots);
        for i in (0..num_slots).rev() {
            free_slots.push(i);
        }

        Self {
            base: effective_start,
            object_size,
            num_slots,
            free_count: num_slots,
            free_slots,
            color_offset,
        }
    }

    pub fn alloc(&mut self) -> Option<usize> {
        let index = self.free_slots.pop()?;
        self.free_count -= 1;
        Some(self.base + index * self.object_size)
    }

    pub fn free(&mut self, addr: usize) -> bool {
        if addr < self.base {
            return false;
        }

        let offset = addr - self.base;
        if offset % self.object_size != 0 {
            return false;
        }

        let index = offset / self.object_size;
        if index >= self.num_slots {
            return false;
        }

        self.free_slots.push(index);
        self.free_count += 1;
        true
    }

    pub fn state(&self) -> WarriorState {
        if self.free_count == 0 {
            WarriorState::FullPower
        } else if self.free_count == self.num_slots {
            WarriorState::Exhausted
        } else {
            WarriorState::Training
        }
    }

    pub fn contains(&self, addr: usize) -> bool {
        addr >= self.base && addr < self.base + self.num_slots * self.object_size
    }
}

#[derive(Debug, Default)]
pub struct ChamberStats {
    pub allocations: u64,
    pub liberations: u64,
    pub rooms_created: u64,
    pub rooms_destroyed: u64,
    pub cache_hits: u64,
}

pub struct HyperbolicChamber {
    name: String,
    object_size: usize,
    alignment: usize,
    rooms_partial: Vec<TrainingRoom>,
    rooms_full: Vec<TrainingRoom>,
    rooms_empty: Vec<TrainingRoom>,
    num_colors: usize,
    next_color: usize,
    cache_line_size: usize,
    stats: ChamberStats,
}

impl HyperbolicChamber {
    pub fn new(name: &str, object_size: usize, alignment: usize) -> Self {
        let cache_line_size = 64;
        let aligned_size = (object_size + alignment - 1) & !(alignment - 1);
        let num_colors = cache_line_size / alignment.max(1);

        Self {
            name: name.to_string(),
            object_size: aligned_size,
            alignment,
            rooms_partial: Vec::new(),
            rooms_full: Vec::new(),
            rooms_empty: Vec::new(),
            num_colors,
            next_color: 0,
            cache_line_size,
            stats: ChamberStats::default(),
        }
    }

    pub fn alloc(&mut self, cell: &mut CellAllocator) -> Option<usize> {
        self.stats.allocations += 1;

        // Essayer les rooms partial d'abord (cache hit!)
        if !self.rooms_partial.is_empty() {
            self.stats.cache_hits += 1;
            let room = &mut self.rooms_partial[0];
            let addr = room.alloc()?;

            if room.state() == WarriorState::FullPower {
                let room = self.rooms_partial.remove(0);
                self.rooms_full.push(room);
            }

            return Some(addr);
        }

        // Essayer les rooms empty
        if !self.rooms_empty.is_empty() {
            let mut room = self.rooms_empty.pop().unwrap();
            let addr = room.alloc()?;
            self.rooms_partial.push(room);
            return Some(addr);
        }

        // CrÃ©er une nouvelle room (demander une page au Cell allocator)
        let page_addr = cell.allocate(4096)?;
        self.stats.rooms_created += 1;

        // Slab coloring â€” transformation Super Saiyan !
        let color_offset = (self.next_color * self.alignment) % self.cache_line_size;
        self.next_color = (self.next_color + 1) % self.num_colors;

        let mut room = TrainingRoom::new(page_addr, 4096, self.object_size, color_offset);
        let addr = room.alloc()?;

        self.rooms_partial.push(room);
        Some(addr)
    }

    pub fn free(&mut self, addr: usize, cell: &mut CellAllocator) -> bool {
        self.stats.liberations += 1;

        // Chercher dans les rooms full
        for i in 0..self.rooms_full.len() {
            if self.rooms_full[i].contains(addr) {
                self.rooms_full[i].free(addr);
                let room = self.rooms_full.remove(i);
                self.rooms_partial.push(room);
                return true;
            }
        }

        // Chercher dans les rooms partial
        for i in 0..self.rooms_partial.len() {
            if self.rooms_partial[i].contains(addr) {
                self.rooms_partial[i].free(addr);

                if self.rooms_partial[i].state() == WarriorState::Exhausted {
                    let room = self.rooms_partial.remove(i);
                    self.rooms_empty.push(room);
                    self.shrink_if_needed(cell);
                }
                return true;
            }
        }

        false
    }

    fn shrink_if_needed(&mut self, cell: &mut CellAllocator) {
        while self.rooms_empty.len() > 2 {
            if let Some(room) = self.rooms_empty.pop() {
                let page_addr = room.base - room.color_offset;
                cell.free(page_addr, 4096);
                self.stats.rooms_destroyed += 1;
            }
        }
    }

    pub fn stats(&self) -> &ChamberStats {
        &self.stats
    }
}

// ============================================
// TOURNAMENT ARENA
// ============================================

pub struct TournamentArena {
    base: usize,
    size: usize,
    next_fighter: usize,
}

impl TournamentArena {
    pub fn new(base: usize, size: usize) -> Self {
        Self { base, size, next_fighter: 0 }
    }

    pub fn call_next_fighter(&mut self, size: usize, alignment: usize) -> Option<usize> {
        let aligned_offset = (self.next_fighter + alignment - 1) & !(alignment - 1);

        if aligned_offset + size > self.size {
            return None;  // Arena pleine !
        }

        let addr = self.base + aligned_offset;
        self.next_fighter = aligned_offset + size;
        Some(addr)
    }

    pub fn reset_tournament(&mut self) {
        self.next_fighter = 0;  // Tous Ã©liminÃ©s !
    }

    pub fn fighters_in_ring(&self) -> usize {
        self.next_fighter
    }

    pub fn space_remaining(&self) -> usize {
        self.size - self.next_fighter
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cell_division() {
        let mut cell = CellAllocator::new(0x10000, 1 << 16);

        let a1 = cell.allocate(4096).unwrap();
        let a2 = cell.allocate(4096).unwrap();

        assert_ne!(a1, a2);
        assert!(cell.stats().divisions > 0);
    }

    #[test]
    fn test_fusion_ha() {
        let mut cell = CellAllocator::new(0x10000, 1 << 16);

        let a1 = cell.allocate(4096).unwrap();
        let a2 = cell.allocate(4096).unwrap();

        cell.free(a1, 4096);
        cell.free(a2, 4096);

        assert!(cell.stats().fusions > 0, "FUSION-HA! devrait avoir fusionnÃ©");
    }

    #[test]
    fn test_xor_formula() {
        let cell = CellAllocator::new(0x10000, 1 << 16);

        let addr = 0x10000;
        let buddy = cell.get_buddy_address(addr, 12);
        assert_eq!(buddy, 0x11000, "buddy_addr = addr XOR size");

        // L'opÃ©ration est sa propre inverse
        let original = cell.get_buddy_address(buddy, 12);
        assert_eq!(original, addr);
    }

    #[test]
    fn test_chamber_states() {
        let mut cell = CellAllocator::new(0x10000, 1 << 20);
        let mut chamber = HyperbolicChamber::new("test", 64, 8);

        let a1 = chamber.alloc(&mut cell).unwrap();
        assert!(chamber.rooms_partial.len() > 0 || chamber.rooms_full.len() > 0);

        chamber.free(a1, &mut cell);
    }

    #[test]
    fn test_arena_bump() {
        let mut arena = TournamentArena::new(0x10000, 4096);

        let f1 = arena.call_next_fighter(100, 8).unwrap();
        let f2 = arena.call_next_fighter(200, 16).unwrap();

        assert!(f1 < f2);
        assert_eq!(f2 % 16, 0);  // AlignÃ©
    }

    #[test]
    fn test_arena_reset() {
        let mut arena = TournamentArena::new(0x10000, 4096);

        arena.call_next_fighter(100, 8);
        arena.call_next_fighter(200, 8);

        arena.reset_tournament();
        assert_eq!(arena.fighters_in_ring(), 0);
    }
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1: Buddy avec HashMap au lieu de bitmap
pub struct CellAllocatorAlt {
    allocated: HashMap<usize, usize>,  // addr -> order
    // ...
}

// Alternative 2: Slab avec linked list intrusive
pub struct TrainingRoomAlt {
    free_head: Option<NonNull<FreeSlot>>,
    // Pas de Vec, les slots pointent directement vers le suivant
}
```

### 4.5 Solutions refusÃ©es

```rust
// REFUSÃ‰: Pas de coalesce
pub fn free_no_fusion(&mut self, addr: usize, size: usize) {
    self.free_lists[order_index].push(addr);
    // ERREUR: Pas de tentative de fusion !
    // La mÃ©moire se fragmente sans fin
}

// REFUSÃ‰: XOR formula incorrecte
pub fn get_buddy_wrong(&self, addr: usize, order: usize) -> usize {
    addr | (1 << order)  // ERREUR: | au lieu de ^
    // Ne donne pas le bon buddy !
}

// REFUSÃ‰: Slab sans gestion des Ã©tats
pub fn alloc_no_state(&mut self) -> Option<usize> {
    // Toujours chercher dans le mÃªme slab
    // ERREUR: Pas de promotion Full -> Partial
}
```

### 4.6 Solution bonus de rÃ©fÃ©rence (Lock-Free)

```rust
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};
use std::ptr;

struct FreeNode {
    next: AtomicPtr<FreeNode>,
}

pub struct PotaraAllocator {
    base: usize,
    total_size: usize,
    free_lists: [AtomicPtr<FreeNode>; NUM_ORDERS],
    version: AtomicUsize,  // ABA counter
}

impl PotaraAllocator {
    pub fn allocate_lockfree(&self, size: usize) -> Option<usize> {
        let order = self.size_to_order(size)?;
        let order_index = order - MIN_ORDER;

        // CAS loop pour retirer de la free list
        loop {
            let head = self.free_lists[order_index].load(Ordering::Acquire);
            if head.is_null() {
                // Essayer de split depuis un ordre supÃ©rieur
                return self.split_from_higher(order);
            }

            unsafe {
                let next = (*head).next.load(Ordering::Relaxed);
                if self.free_lists[order_index]
                    .compare_exchange_weak(
                        head,
                        next,
                        Ordering::AcqRel,
                        Ordering::Relaxed,
                    )
                    .is_ok()
                {
                    return Some(head as usize);
                }
            }
            // Retry si CAS Ã©choue
        }
    }

    pub fn free_lockfree(&self, addr: usize, size: usize) {
        let order = self.size_to_order(size).unwrap();
        let node = addr as *mut FreeNode;

        loop {
            let head = self.free_lists[order - MIN_ORDER].load(Ordering::Acquire);
            unsafe {
                (*node).next.store(head, Ordering::Relaxed);
            }

            if self.free_lists[order - MIN_ORDER]
                .compare_exchange_weak(
                    head,
                    node,
                    Ordering::AcqRel,
                    Ordering::Relaxed,
                )
                .is_ok()
            {
                // Tenter coalesce (plus complexe en lock-free)
                self.try_coalesce_lockfree(addr, order);
                return;
            }
        }
    }

    fn size_to_order(&self, size: usize) -> Option<usize> {
        let size = size.max(1 << MIN_ORDER);
        let order = size.next_power_of_two().trailing_zeros() as usize;
        if order > MAX_ORDER { None } else { Some(order.max(MIN_ORDER)) }
    }
}
```

### 4.9 spec.json

```json
{
  "name": "saiyan_allocator",
  "language": "rust",
  "version": "2024",
  "type": "complet",
  "tier": 2,
  "tier_info": "MÃ©lange (buddy + slab + arena)",
  "tags": ["memory", "allocator", "buddy", "slab", "kernel"],
  "passing_score": 70,

  "function": {
    "name": "CellAllocator",
    "methods": [
      {
        "name": "allocate",
        "prototype": "pub fn allocate(&mut self, size: usize) -> Option<usize>",
        "return_type": "Option<usize>"
      },
      {
        "name": "free",
        "prototype": "pub fn free(&mut self, addr: usize, size: usize)",
        "return_type": "()"
      },
      {
        "name": "get_buddy_address",
        "prototype": "pub fn get_buddy_address(&self, addr: usize, order: usize) -> usize",
        "return_type": "usize"
      }
    ]
  },

  "driver": {
    "reference": "impl CellAllocator { pub fn new(base: usize, size: usize) -> Self { assert!(size.is_power_of_two()); let order = size.trailing_zeros() as usize; let mut alloc = Self { base, total_size: size, free_lists: Default::default(), allocated_bitmap: vec![false; size / (1 << MIN_ORDER)], stats: CellStats::default() }; alloc.free_lists[order - MIN_ORDER].push(base); alloc } pub fn get_buddy_address(&self, addr: usize, order: usize) -> usize { addr ^ (1 << order) } }",

    "edge_cases": [
      {
        "name": "xor_formula_basic",
        "setup": "let cell = CellAllocator::new(0x10000, 1 << 16);",
        "call": "cell.get_buddy_address(0x10000, 12)",
        "expected": "0x11000",
        "is_trap": true,
        "trap_explanation": "buddy_addr = addr XOR size = 0x10000 ^ 0x1000 = 0x11000"
      },
      {
        "name": "xor_inverse",
        "setup": "let cell = CellAllocator::new(0x10000, 1 << 16);",
        "call": "cell.get_buddy_address(0x11000, 12)",
        "expected": "0x10000",
        "is_trap": true,
        "trap_explanation": "XOR est sa propre inverse"
      },
      {
        "name": "allocation_basic",
        "setup": "let mut cell = CellAllocator::new(0x10000, 1 << 16);",
        "call": "cell.allocate(4096).is_some()",
        "expected": "true"
      },
      {
        "name": "split_occurs",
        "setup": "let mut cell = CellAllocator::new(0x10000, 1 << 16); cell.allocate(4096);",
        "call": "cell.stats().divisions > 0",
        "expected": "true",
        "is_trap": true,
        "trap_explanation": "Split requis pour obtenir un bloc 4KB depuis 64KB"
      },
      {
        "name": "coalesce_occurs",
        "setup": "let mut cell = CellAllocator::new(0x10000, 1 << 16); let a1 = cell.allocate(4096).unwrap(); let a2 = cell.allocate(4096).unwrap(); cell.free(a1, 4096); cell.free(a2, 4096);",
        "call": "cell.stats().fusions > 0",
        "expected": "true",
        "is_trap": true,
        "trap_explanation": "Deux buddies libÃ©rÃ©s doivent fusionner"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "int",
          "param_index": 0,
          "params": {
            "min": 4096,
            "max": 65536
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["std::alloc", "std::collections::HashMap", "std::ptr::NonNull"],
    "forbidden_functions": ["external_allocator_crates"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : XOR remplacÃ© par OR */
pub fn get_buddy_address_mutant_a(&self, addr: usize, order: usize) -> usize {
    let size = 1 << order;
    addr | size  // ERREUR: | au lieu de ^
}
// Pourquoi c'est faux : OR ne "flip" pas le bit, il le met Ã  1
// Ce qui Ã©tait pensÃ© : "| et ^ c'est pareil pour les bits"

/* Mutant B (Safety) : Pas de vÃ©rification des limites */
pub fn free_mutant_b(&mut self, addr: usize, size: usize) {
    let order = self.size_to_order(size);
    // ERREUR: Pas de vÃ©rification que buddy_addr est dans la rÃ©gion
    let buddy_addr = self.get_buddy_address(addr, order);
    // Peut accÃ©der hors limites !
}
// Pourquoi c'est faux : Le buddy peut Ãªtre hors de la rÃ©gion gÃ©rÃ©e
// Ce qui Ã©tait pensÃ© : "XOR donne toujours une adresse valide"

/* Mutant C (Resource) : Buddy pas retirÃ© avant coalesce */
pub fn free_mutant_c(&mut self, addr: usize, size: usize) {
    let buddy_addr = self.get_buddy_address(addr, order);
    if self.is_free_at_order(buddy_addr, order) {
        // ERREUR: On fusionne sans retirer le buddy de sa free list !
        current_addr = current_addr.min(buddy_addr);
        current_order += 1;
    }
    self.free_lists[current_order - MIN_ORDER].push(current_addr);
}
// Pourquoi c'est faux : Le buddy reste dans deux free lists
// Ce qui Ã©tait pensÃ© : "Le bitmap suffit pour tracker"

/* Mutant D (Logic) : Ordre non incrÃ©mentÃ© aprÃ¨s fusion */
pub fn free_mutant_d(&mut self, addr: usize, size: usize) {
    while current_order < MAX_ORDER {
        let buddy_addr = self.get_buddy_address(current_addr, current_order);
        if self.is_free_at_order(buddy_addr, current_order) {
            self.free_lists[current_order - MIN_ORDER].remove(buddy_idx);
            current_addr = current_addr.min(buddy_addr);
            // ERREUR: current_order += 1 manquant !
        } else {
            break;
        }
    }
}
// Pourquoi c'est faux : Le bloc fusionnÃ© va dans la mauvaise free list
// Ce qui Ã©tait pensÃ© : "La fusion est automatique"

/* Mutant E (Return) : Ã‰tat slab incorrect */
impl TrainingRoom {
    pub fn state_mutant_e(&self) -> WarriorState {
        if self.free_count == 0 {
            WarriorState::FullPower
        } else {
            WarriorState::Exhausted  // ERREUR: Partial devient Exhausted
        }
    }
}
// Pourquoi c'est faux : Un slab avec 1 objet libre est Partial, pas Empty
// Ce qui Ã©tait pensÃ© : "Si pas full, alors empty"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Application |
|---------|-------------|
| **Buddy System** | Allocation de pages avec split/coalesce O(log n) |
| **Formule XOR** | Calcul Ã©lÃ©gant de l'adresse du buddy |
| **Slab Allocator** | Optimisation pour objets de taille fixe |
| **Slab States** | Gestion des transitions Full/Partial/Empty |
| **Slab Coloring** | Distribution des objets sur les lignes de cache |
| **Arena Allocator** | Allocation O(1) avec libÃ©ration en masse |
| **Fragmentation** | Interne (buddy) vs externe (Ã©vitÃ©e par slab) |

### 5.2 LDA â€” Traduction en FranÃ§ais

```
FONCTION get_buddy_address QUI RETOURNE UN ENTIER NON SIGNÃ‰ ET PREND EN PARAMÃˆTRES addr ET order
DÃ‰BUT FONCTION
    DÃ‰CLARER size COMME ENTIER NON SIGNÃ‰

    AFFECTER 1 DÃ‰CALÃ‰ Ã€ GAUCHE DE order BITS Ã€ size
    RETOURNER addr XOR size
FIN FONCTION
```

```
FONCTION allocate QUI RETOURNE UNE OPTION D'ADRESSE ET PREND EN PARAMÃˆTRE size
DÃ‰BUT FONCTION
    DÃ‰CLARER order COMME L'ORDRE CORRESPONDANT Ã€ size (PUISSANCE DE 2 SUPÃ‰RIEURE)

    POUR CHAQUE ORDER_INDEX ALLANT DE order Ã€ MAX_ORDER FAIRE
        SI LA FREE LIST DE CET ORDRE N'EST PAS VIDE ALORS
            RETIRER UN BLOC DE LA FREE LIST

            TANT QUE L'ORDRE ACTUEL EST SUPÃ‰RIEUR Ã€ L'ORDRE DEMANDÃ‰ FAIRE
                DIVISER LE BLOC EN DEUX (CELL DIVISION)
                AJOUTER LE BUDDY Ã€ LA FREE LIST DE L'ORDRE INFÃ‰RIEUR
                DÃ‰CRÃ‰MENTER L'ORDRE ACTUEL
            FIN TANT QUE

            MARQUER LE BLOC COMME ALLOUÃ‰
            RETOURNER L'ADRESSE DU BLOC
        FIN SI
    FIN POUR

    RETOURNER RIEN (Ã‰CHEC)
FIN FONCTION
```

### 5.2.2 Logic Flow

```
ALGORITHME : Buddy Free avec Coalesce (FUSION-HA!)
---
1. CONVERTIR size en order (puissance de 2)

2. MARQUER le bloc comme libre dans le bitmap

3. BOUCLE DE FUSION :
   TANT QUE order < MAX_ORDER :
   |
   |-- CALCULER buddy_addr = addr XOR (1 << order)
   |
   |-- SI le buddy est libre ET de mÃªme ordre :
   |     |
   |     |-- RETIRER le buddy de sa free list
   |     |-- addr = MIN(addr, buddy_addr)  // Adresse du bloc fusionnÃ©
   |     |-- order += 1  // Monte d'un ordre
   |     |-- CONTINUER la boucle
   |
   |-- SINON :
   |     SORTIR de la boucle (pas de fusion possible)

4. AJOUTER le bloc (possiblement fusionnÃ©) Ã  la free list de order

5. INCRÃ‰MENTER stats.fusions si fusion effectuÃ©e
```

### 5.2.3 Diagramme Mermaid â€” La Danse de Fusion

```mermaid
graph TD
    A[free addr, size] --> B[Calculer order]
    B --> C[Marquer libre dans bitmap]
    C --> D{order < MAX?}

    D -- Non --> J[Ajouter Ã  free_list]
    D -- Oui --> E[buddy = addr XOR 2^order]

    E --> F{Buddy libre<br/>et mÃªme order?}
    F -- Non --> J
    F -- Oui --> G[FUSION-HA!]

    G --> H[Retirer buddy de free_list]
    H --> I[addr = min addr, buddy<br/>order++]
    I --> D

    J --> K[FIN]
```

### 5.3 Visualisation ASCII

#### Buddy System â€” Cell Division et Fusion

```
Ã‰TAT INITIAL : 1 bloc de 64KB
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          64KB (order 16)                       â”‚
â”‚                        Free List[4]                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS allocate(4KB) â€” CELL SE DIVISE 4 FOIS :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4KB â”‚ 4KB â”‚   8KB   â”‚       16KB       â”‚         32KB         â”‚
â”‚ALLOCâ”‚FREE â”‚  FREE   â”‚       FREE       â”‚         FREE         â”‚
â”‚     â”‚ [0] â”‚   [1]   â”‚        [2]       â”‚          [3]         â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘       â†‘            â†‘                   â†‘
    free_list[0] [1]         [2]                 [3]

FORMULE XOR pour trouver le buddy de 0x10000 (4KB, order 12):
    buddy = 0x10000 XOR 0x1000 = 0x11000

    0x10000 = 0001 0000 0000 0000 0000
    0x01000 = 0000 0001 0000 0000 0000  (size = 4KB)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0x11000 = 0001 0001 0000 0000 0000  â† Buddy!

APRÃˆS free(0x10000) puis free(0x11000) â€” FUSION-HA! :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    8KB    â”‚   8KB   â”‚       16KB       â”‚         32KB         â”‚
â”‚   FREE    â”‚  FREE   â”‚       FREE       â”‚         FREE         â”‚
â”‚    [1]    â”‚   [1]   â”‚        [2]       â”‚          [3]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
  FUSION!
      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        16KB         â”‚       16KB       â”‚         32KB         â”‚
â”‚        FREE         â”‚       FREE       â”‚         FREE         â”‚
â”‚         [2]         â”‚        [2]       â”‚          [3]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Slab Allocator â€” Hyperbolic Time Chamber

```
SLAB CACHE "warriors" (64 bytes objects)

Page 1 (color_offset = 0)           Page 2 (color_offset = 64)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚[W1][W2][W3][W4][W5]...[W63]  â”‚   â”‚    [W1][W2][W3]...[W62]      â”‚
â”‚ 0  64  128 192 256          â”‚   â”‚    64  128 192               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â†‘
                                   Coloring offset!

Ã‰TATS DES ROOMS :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FULL POWER â”‚  â”‚  TRAINING   â”‚  â”‚  EXHAUSTED  â”‚
â”‚  (Full)     â”‚  â”‚  (Partial)  â”‚  â”‚  (Empty)    â”‚
â”‚ 0 free      â”‚  â”‚ 32 free     â”‚  â”‚ 63 free     â”‚
â”‚ 63 used     â”‚  â”‚ 31 used     â”‚  â”‚ 0 used      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“                â†“                â†“
  rooms_full      rooms_partial    rooms_empty
```

#### Arena Allocator â€” Tournament Arena

```
TOURNAMENT ARENA (4KB)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Fighter1 â”‚ Fighter2      â”‚ Fighter3 â”‚        AVAILABLE        â”‚
â”‚  100B    â”‚    200B       â”‚   50B    â”‚                         â”‚
â”‚ aligned  â”‚  aligned 16   â”‚ aligned  â”‚                         â”‚
â”‚   8      â”‚               â”‚    8     â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0         104            320        376                        4096
           â†‘              â†‘          â†‘
        padding       padding    next_fighter (bump pointer)

APRÃˆS reset_tournament() :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ALL AVAILABLE                           â”‚
â”‚                    next_fighter = 0                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **XOR vs OR** | Utiliser `|` au lieu de `^` | Toujours XOR pour le buddy |
| **Buddy hors limites** | Le buddy peut Ãªtre hors rÃ©gion | VÃ©rifier les bornes avant coalesce |
| **Double free list** | Buddy reste dans la free list aprÃ¨s fusion | Toujours retirer avant fusion |
| **Order non incrÃ©mentÃ©** | Oublier `order += 1` aprÃ¨s fusion | IncrÃ©menter systÃ©matiquement |
| **Slab state incorrect** | Partial confondu avec Empty | Compter les free_slots |

### 5.5 Cours Complet

#### 5.5.1 Le Buddy System â€” Diviser pour RÃ©gner

Le Buddy System est un algorithme d'allocation qui gÃ¨re la mÃ©moire en blocs de puissances de 2. Son Ã©lÃ©gance rÃ©side dans :

1. **Split O(log n)** : Un bloc de 2^k se divise en deux blocs de 2^(k-1)
2. **Coalesce O(log n)** : Deux "buddies" adjacents fusionnent en un bloc 2^(k+1)
3. **Formule XOR** : L'adresse du buddy se calcule en O(1)

**Pourquoi XOR fonctionne :**
```
Pour un bloc Ã  l'adresse A de taille 2^k :
- Si A est pair (buddy gauche) : A XOR 2^k = A + 2^k (buddy droit)
- Si A est impair (buddy droit) : A XOR 2^k = A - 2^k (buddy gauche)

Le XOR "flip" exactement le bit de position k, ce qui donne l'adresse de l'autre moitiÃ©.
```

#### 5.5.2 Le Slab Allocator â€” Objets de Taille Fixe

InventÃ© par Jeff Bonwick pour Solaris, le slab allocator optimise les allocations rÃ©pÃ©tÃ©es d'objets identiques (ex: `struct task_struct` dans Linux).

**Architecture :**
```
Cache (type d'objet)
  â””â”€â”€ Slabs (pages mÃ©moire)
       â””â”€â”€ Objets (instances)
```

**Avantages :**
- Pas de fragmentation externe (tous les objets ont mÃªme taille)
- Allocation O(1) depuis un slab partial
- Cache locality amÃ©liorÃ©e

#### 5.5.3 Le Slab Coloring â€” Performance Cache

Le coloring distribue les premiers objets de chaque slab sur diffÃ©rentes lignes de cache :

```
Sans coloring :
Slab 1: [obj0 Ã  offset 0] [obj1 Ã  offset 64]...
Slab 2: [obj0 Ã  offset 0] [obj1 Ã  offset 64]...  â† Conflit cache !

Avec coloring :
Slab 1: [obj0 Ã  offset 0]  [obj1 Ã  offset 64]...
Slab 2: [obj0 Ã  offset 64] [obj1 Ã  offset 128]... â† Pas de conflit !
```

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ addr | size  // Mauvaise opÃ©ration                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ addr ^ size  // XOR correct                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ OR met le bit Ã  1, ne le "flip" pas                           â”‚
â”‚ â€¢ XOR est sa propre inverse (crucial pour le buddy)             â”‚
â”‚ â€¢ La formule XOR est standard dans tous les kernels             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**ScÃ©nario : allocate(4KB) depuis un buddy de 16KB**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                             â”‚ Variables  â”‚ Explication           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ order = 12 (4KB)                        â”‚ order=12   â”‚ Calcul ordre demandÃ©  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ Chercher dans free_list[0] (4KB)        â”‚ empty      â”‚ Pas de bloc 4KB       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Chercher dans free_list[1] (8KB)        â”‚ empty      â”‚ Pas de bloc 8KB       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Trouver bloc 16KB dans free_list[2]     â”‚ addr=0x1000â”‚ Bloc trouvÃ© !         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ SPLIT : 16KB â†’ 8KB + 8KB                â”‚ splits=1   â”‚ Cell division !       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Ajouter 0x3000 Ã  free_list[1]           â”‚            â”‚ Buddy 8KB libÃ©rÃ©      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ SPLIT : 8KB â†’ 4KB + 4KB                 â”‚ splits=2   â”‚ Cell division !       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ Ajouter 0x2000 Ã  free_list[0]           â”‚            â”‚ Buddy 4KB libÃ©rÃ©      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ Retourner 0x1000                        â”‚ ret=0x1000 â”‚ Allocation rÃ©ussie    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ‰ MEME : "FUSION-HA!" â€” La Danse de Fusion pour le Coalesce

```
                    FUSION-HA!
                   â•±         â•²
                 â•±             â•²
    â”Œâ”€â”€â”€â”€â”€â”    â•±                 â•²    â”Œâ”€â”€â”€â”€â”€â”
    â”‚Goku â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚Vegetaâ”‚
    â”‚ 4KB â”‚                           â”‚ 4KB  â”‚
    â””â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”˜
         â•²                           â•±
          â•²                         â•±
           â•²      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â•±
            â•²â”€â”€â”€â”€â”€â”‚ GOGETA  â”‚â”€â”€â”€â”€â”€â•±
                  â”‚   8KB   â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†‘
            Buddy Coalesce rÃ©ussi !

    RÃ¨gle de la Fusion : Les deux guerriers doivent avoir
    le MÃŠME niveau de puissance (mÃªme ordre de buddy)
```

#### ğŸ’€ MEME : "Cell se divise" â€” Le Split

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   CELL    â”‚
         â”‚   16KB    â”‚
         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
               â”‚ SPLIT!
         â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
         â”‚           â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚Mini-Cellâ”‚ â”‚Mini-Cellâ”‚
    â”‚   8KB   â”‚ â”‚   8KB   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Chaque mini-Cell a exactement la MOITIÃ‰
    de la puissance originale.
```

#### ğŸ‹ï¸ MEME : "Hyperbolic Time Chamber" â€” Slab Cache

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     HYPERBOLIC TIME CHAMBER            â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”          â”‚
    â”‚   â”‚Room 1â”‚ â”‚Room 2â”‚ â”‚Room 3â”‚          â”‚
    â”‚   â”‚FULL  â”‚ â”‚PARTIALâ”‚ â”‚EMPTY â”‚          â”‚
    â”‚   â”‚POWER â”‚ â”‚TRAININGâ”‚ â”‚EXHAUSTEDâ”‚      â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜          â”‚
    â”‚                                        â”‚
    â”‚   Chaque room entraÃ®ne des guerriers   â”‚
    â”‚   de MÃŠME TAILLE (slab = objets fixes) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.9 Applications pratiques

| SystÃ¨me | Utilisation |
|---------|-------------|
| **Linux Kernel** | Buddy pour les pages, SLUB pour les objets kernel |
| **jemalloc** | Variante de buddy pour Firefox/Rust |
| **mimalloc** | Slab-like per-thread caches |
| **Game Engines** | Pool allocators pour les entitÃ©s |
| **Databases** | Buffer pools avec buddy allocation |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

1. **XOR vs OR** : Toujours `^` pour le buddy, jamais `|`
2. **VÃ©rification des limites** : Le buddy peut Ãªtre hors rÃ©gion
3. **Retrait de la free list** : Avant fusion, retirer le buddy
4. **IncrÃ©mentation de l'ordre** : AprÃ¨s fusion, `order += 1`
5. **Ã‰tats de slab** : Partial â‰  Empty, vÃ©rifier `free_count`
6. **Alignement coloring** : Respecter la taille de ligne cache

---

## ğŸ“ SECTION 7 : QCM

### Q1. Quelle est la formule pour trouver l'adresse du buddy ?
- A) `addr + size`
- B) `addr - size`
- C) `addr ^ size` âœ“
- D) `addr | size`
- E) `addr & size`
- F) `addr * 2`
- G) `addr / 2`
- H) `~addr`
- I) `addr << 1`
- J) `addr >> 1`

### Q2. Quel est l'ordre minimum typique pour un buddy allocator de pages ?
- A) 0 (1 byte)
- B) 4 (16 bytes)
- C) 8 (256 bytes)
- D) 12 (4KB) âœ“
- E) 16 (64KB)
- F) 20 (1MB)
- G) 24 (16MB)
- H) Variable
- I) 10 (1KB)
- J) 14 (16KB)

### Q3. Dans quel Ã©tat est un slab avec 0 objets libres ?
- A) Empty
- B) Partial
- C) Full âœ“
- D) Exhausted
- E) Training
- F) Allocated
- G) Free
- H) Active
- I) Inactive
- J) Pending

### Q4. Pourquoi le slab coloring amÃ©liore-t-il les performances ?
- A) RÃ©duit la taille des objets
- B) AccÃ©lÃ¨re la libÃ©ration
- C) Distribue les objets sur diffÃ©rentes lignes de cache âœ“
- D) Compresse la mÃ©moire
- E) Augmente la fragmentation
- F) Simplifie le code
- G) RÃ©duit les allocations
- H) Ã‰limine les mutex
- I) Optimise le rÃ©seau
- J) AccÃ©lÃ¨re le disque

### Q5. Quelle est la complexitÃ© de l'allocation dans un arena allocator ?
- A) O(n)
- B) O(log n)
- C) O(n log n)
- D) O(1) âœ“
- E) O(nÂ²)
- F) O(2^n)
- G) O(âˆšn)
- H) Amortized O(log n)
- I) O(n!)
- J) Variable

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Ã‰valuation |
|---------|------------|
| **Concepts couverts** | 9 (buddy split, coalesce, XOR, slab cache, states, coloring, SLUB, bump pointer, reset) |
| **DifficultÃ©** | 6/10 (Phase 2) |
| **Bonus** | ğŸ’€ Expert (8/10) â€” Lock-free avec CAS |
| **ThÃ¨me culturel** | Dragon Ball Z â€” Fusion/Division |
| **Applications** | Kernel Linux, allocateurs modernes, game engines |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.1.5-saiyan-allocator",
    "generated_at": "2026-01-11",

    "metadata": {
      "exercise_id": "2.1.5",
      "exercise_name": "saiyan_allocator",
      "module": "2.1",
      "module_name": "Memory Management",
      "concept": "e",
      "concept_name": "Buddy System & Slab Allocator",
      "type": "complet",
      "tier": 2,
      "tier_info": "MÃ©lange (buddy + slab + arena)",
      "phase": 2,
      "difficulty": 6,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 450,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "bonus_icon": "ğŸ’€",
      "complexity_time": "T3 O(log n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["rust_ownership", "bitwise_ops", "memory_basics"],
      "domains": ["Mem", "CPU", "Struct"],
      "domains_bonus": ["Process"],
      "tags": ["buddy", "slab", "arena", "kernel", "allocator"],
      "meme_reference": "Dragon Ball Z - FUSION-HA!"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_xor_or.rs": "/* Section 4.10 */",
      "mutants/mutant_b_no_bounds.rs": "/* Section 4.10 */",
      "mutants/mutant_c_double_freelist.rs": "/* Section 4.10 */",
      "mutants/mutant_d_no_order_inc.rs": "/* Section 4.10 */",
      "mutants/mutant_e_wrong_state.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_xor_or.rs",
        "mutants/mutant_b_no_bounds.rs",
        "mutants/mutant_c_double_freelist.rs",
        "mutants/mutant_d_no_order_inc.rs",
        "mutants/mutant_e_wrong_state.rs"
      ]
    }
  }
}
```

---

**Auto-Ã‰valuation : 96/100** âœ“

L'analogie Dragon Ball Z est parfaite pour les concepts de buddy system :
- Fusion Dance = Coalesce (deux buddies de mÃªme puissance fusionnent)
- Cell Division = Split (un bloc se divise en deux moitiÃ©s Ã©gales)
- Hyperbolic Time Chamber = Slab Cache (rooms spÃ©cialisÃ©es par type)
- Super Saiyan Colors = Slab Coloring (diffÃ©rentes transformations pour Ã©viter les conflits)

La formule XOR est mise en valeur comme l'Ã©lÃ©gance ultime de l'algorithme.
