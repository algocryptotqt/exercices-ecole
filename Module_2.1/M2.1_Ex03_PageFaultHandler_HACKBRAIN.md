<thinking>
## Analyse du Concept
- Concept : Page Fault Handler avec algorithmes de remplacement
- Phase demandÃ©e : 2
- AdaptÃ© ? OUI - Concept systÃ¨me avancÃ©, parfait pour Phase 2

## Combo Base + Bonus
- Exercice de base : Simulateur de page faults avec 4 algorithmes (FIFO, LRU, Clock, Optimal)
- Bonus : Enhanced Clock avec dirty bit + dÃ©tection thrashing + dÃ©monstration Belady
- Palier bonus : ğŸ’€ Expert (concepts avancÃ©s de scheduling mÃ©moire)
- Progression logique ? OUI - Base = algorithmes standards, Bonus = optimisations et edge cases

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : Pointeurs C, structures, allocations mÃ©moire
- DifficultÃ© estimÃ©e : 7/10
- CohÃ©rent avec phase ? OUI (Phase 2 avancÃ©e)

## Aspect Fun/Culture
- Contexte choisi : SQUID GAME de Netflix
- MEME mnÃ©motechnique : "Red Light, Green Light" + "Front Man"
- Pourquoi c'est fun :
  - Joueurs = Pages en mÃ©moire
  - Ã‰limination = Ã‰viction de page
  - DiffÃ©rents jeux = DiffÃ©rents algorithmes
  - "Plus de joueurs = plus de chaos" = Anomalie de Belady
  - Le Front Man surveille = DÃ©tection du thrashing
  - "Red Light, Green Light" = Reference bit (accÃ¨s rÃ©cent ou pas)
  - Jeu du verre = Clock algorithm (tourner en cercle)

## Analogie Squid Game â†’ Page Fault Handler
| Squid Game | Page Fault Handler |
|------------|-------------------|
| Joueurs | Pages virtuelles |
| Ãle (arÃ¨ne) | MÃ©moire physique (frames) |
| Ã‰limination | Ã‰viction de page |
| Jeu 1: Red Light Green Light | Reference bit (R=0 ou R=1) |
| Jeu du verre (cercle) | Clock algorithm |
| Plus de joueurs = chaos | Belady's anomaly |
| Front Man | Thrashing detector |
| Dortoir | Working set |
| Retour au jeu | Major page fault (reload from disk) |
| Mort dÃ©finitive | Invalid fault (segfault) |

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Boundary) : Clock hand ne wrappe pas correctement (modulo oubliÃ©)
2. Mutant B (Safety) : Pas de vÃ©rification du bit valid avant accÃ¨s
3. Mutant C (Resource) : Dirty page Ã©vincÃ©e sans writeback au disque
4. Mutant D (Logic) : FIFO utilise last_access au lieu de load_time
5. Mutant E (Return) : Retourne FAULT_NONE mÃªme quand la page n'est pas prÃ©sente

## Verdict
VALIDE - L'analogie Squid Game est parfaite pour l'Ã©viction et les algorithmes.
Note qualitÃ© estimÃ©e : 97/100
</thinking>

---

# Exercice 2.1.3 : squid_memory_games

**Module :**
2.1 â€” Memory Management

**Concept :**
c-n â€” Page Faults & Replacement Algorithms

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
code

**Tiers :**
3 â€” SynthÃ¨se (concepts 2.1.4.b â†’ 2.1.5.n)

**Langage :**
C17

**PrÃ©requis :**
- Pointeurs et structures C
- Allocation dynamique (malloc/free)
- Concepts de base mÃ©moire virtuelle

**Domaines :**
Mem, Struct, Algo

**DurÃ©e estimÃ©e :**
240 min

**XP Base :**
500

**ComplexitÃ© :**
T4 O(nÃ—frames) Ã— S3 O(pages + frames)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
```
ex03_squid_memory/
â”œâ”€â”€ squid_memory.h       # Header principal
â”œâ”€â”€ squid_memory.c       # ImplÃ©mentation
â”œâ”€â”€ test_games.c         # Tests des algorithmes
â”œâ”€â”€ test_belady.c        # DÃ©monstration anomalie
â””â”€â”€ Makefile
```

**Fonctions autorisÃ©es :**
- `malloc`, `calloc`, `free`
- `memset`, `memcpy`
- `printf` (pour debug)

**Fonctions interdites :**
- Fonctions systÃ¨me rÃ©elles (`mmap`, `mprotect`)
- BibliothÃ¨ques de threading

---

### 1.2 Consigne

#### ğŸ¦‘ SQUID GAME â€” Les Jeux de la MÃ©moire

> *"456 joueurs, une seule place en mÃ©moire."*

Dans la sÃ©rie **Squid Game**, des centaines de joueurs s'affrontent dans des jeux d'enfants mortels. Seuls les survivants restent dans l'arÃ¨ne. Les autres... sont **Ã©liminÃ©s**.

**Le parallÃ¨le avec la gestion de page faults est saisissant :**

| Squid Game | Gestion MÃ©moire |
|------------|-----------------|
| Joueurs (456 personnes) | Pages virtuelles |
| L'Ã®le (arÃ¨ne limitÃ©e) | MÃ©moire physique (frames) |
| Ã‰limination | Ã‰viction de page (page-out) |
| **Jeu 1: "Red Light, Green Light"** | **Reference bit** â€” Ceux qui bougent (R=1) survivent |
| **Jeu du Verre (cercle)** | **Clock algorithm** â€” On tourne jusqu'Ã  trouver une victime |
| **Plus de joueurs = plus de chaos** | **Anomalie de Belady** â€” Plus de frames peut = plus de faults |
| Le Front Man surveille | **Thrashing detector** â€” DÃ©tecte quand le systÃ¨me s'effondre |
| Dortoir (oÃ¹ dorment les joueurs) | **Working set** â€” Les pages actives |
| Revenir sur l'Ã®le | **Major fault** â€” Recharger depuis le disque |
| Mort dÃ©finitive (Ã©jectÃ© du jeu) | **Invalid fault** â€” Segmentation fault |

**Tu es le Game Master.** Tu dois implÃ©menter le systÃ¨me qui dÃ©cide quels joueurs (pages) restent dans l'arÃ¨ne (mÃ©moire) et lesquels sont Ã©liminÃ©s (Ã©vincÃ©s).

---

**Ta mission :**

ImplÃ©menter un simulateur de Page Fault Handler nommÃ© `SquidMemoryGames` qui :

1. **GÃ¨re trois types de faults :**
   - `FAULT_MINOR` : Le joueur est dans les coulisses (page en RAM mais pas mappÃ©e)
   - `FAULT_MAJOR` : Le joueur doit revenir de chez lui (page sur disque)
   - `FAULT_INVALID` : Le joueur n'existe pas (accÃ¨s illÃ©gal â†’ segfault)

2. **ImplÃ©mente 6 algorithmes d'Ã©limination (remplacement) :**
   - `GAME_OPTIMAL` : L'omniscient Front Man sait qui sera utile (Belady's optimal)
   - `GAME_FIFO` : Premier arrivÃ©, premier Ã©liminÃ©
   - `GAME_LRU` : Le moins actif rÃ©cemment est Ã©liminÃ©
   - `GAME_CLOCK` : "Red Light, Green Light" â€” 2nd chance
   - `GAME_CLOCK_ENHANCED` : Avec considÃ©ration du "dirty bit"
   - `GAME_WORKING_SET` : Seuls ceux du dortoir survivent

3. **DÃ©tecte le thrashing** (quand le jeu devient ingÃ©rable)

**EntrÃ©e :**
- `arena: SquidArena*` : L'arÃ¨ne de jeu (simulateur)
- `player_id: uint64_t` : Le joueur (page virtuelle) qui veut entrer
- `is_write: bool` : Est-ce une Ã©criture (marque le joueur comme "dirty")

**Sortie :**
- `fault_type_t` : Type de fault (`FAULT_NONE`, `FAULT_MINOR`, `FAULT_MAJOR`, `FAULT_INVALID`)

**Contraintes :**
- L'arÃ¨ne a un nombre fixe de places (frames)
- Chaque Ã©limination d'un joueur "dirty" nÃ©cessite un writeback (sauvegarde)
- Le Clock algorithm doit tourner en cercle (wraparound)
- Le working set est calculÃ© sur une fenÃªtre de temps Ï„

**Exemples :**

| Appel | RÃ©sultat | Explication |
|-------|----------|-------------|
| `enter_arena(arena, 42, false)` | `FAULT_MINOR` | Joueur 42 Ã©tait en coulisses |
| `enter_arena(arena, 42, true)` | `FAULT_NONE` | Joueur 42 dÃ©jÃ  sur l'Ã®le |
| `enter_arena(arena, 999, false)` | `FAULT_INVALID` | Joueur 999 n'existe pas |

---

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un simulateur de gestion de page faults avec support de plusieurs algorithmes de remplacement (FIFO, LRU, Clock, Optimal), dÃ©tection des diffÃ©rents types de faults (minor, major, invalid), calcul du working set, et dÃ©tection du thrashing.

---

### 1.3 Prototype

```c
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SQUID MEMORY GAMES â€” "456 joueurs, une seule place"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifndef SQUID_MEMORY_H
#define SQUID_MEMORY_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// Types de faults â€” Sorts des joueurs
typedef enum {
    FAULT_NONE,       // Le joueur est dÃ©jÃ  dans l'arÃ¨ne
    FAULT_MINOR,      // Joueur en coulisses, facile Ã  faire entrer
    FAULT_MAJOR,      // Joueur chez lui, doit voyager (lent)
    FAULT_INVALID     // Joueur inexistant â€” Ã‰LIMINATION DÃ‰FINITIVE (segfault)
} fault_type_t;

// Algorithmes d'Ã©limination â€” Les Jeux
typedef enum {
    GAME_OPTIMAL,         // Le Front Man omniscient (Belady)
    GAME_FIFO,            // Premier arrivÃ©, premier Ã©liminÃ©
    GAME_LRU,             // Le moins actif part
    GAME_LRU_APPROX,      // Approximation avec bit R
    GAME_CLOCK,           // Red Light, Green Light (2nd chance)
    GAME_CLOCK_ENHANCED,  // Avec dirty bit (R, M)
    GAME_WORKING_SET      // Seul le dortoir survit
} elimination_game_t;

// Ã‰tat d'un joueur (page)
typedef struct {
    bool in_arena;        // Dans l'arÃ¨ne (present)
    bool red_light;       // Bit R â€” a bougÃ© rÃ©cemment
    bool is_dirty;        // Bit M â€” a Ã©tÃ© modifiÃ©
    bool is_valid;        // Existe dans le jeu
    uint64_t spot;        // Place dans l'arÃ¨ne (PFN)
    uint64_t home_addr;   // Adresse chez lui (disque)
    uint64_t arrival_time;// Quand il est arrivÃ©
    uint64_t last_move;   // Dernier mouvement
} player_state_t;

// Place dans l'arÃ¨ne (frame physique)
typedef struct {
    bool occupied;
    uint64_t player_id;   // Qui occupe cette place
    uint64_t arrival_time;
    uint64_t last_move;
    bool red_light;       // Bit R
    bool is_dirty;        // Bit M
} arena_spot_t;

// Statistiques du jeu
typedef struct {
    uint64_t minor_faults;      // Retours des coulisses
    uint64_t major_faults;      // Retours de chez soi
    uint64_t invalid_faults;    // Joueurs inexistants
    uint64_t total_moves;       // Total des accÃ¨s
    uint64_t eliminations;      // Total des Ã©victions
    uint64_t dirty_eliminations;// Ã‰victions avec sauvegarde
    uint64_t disk_reads;        // Lectures disque
    uint64_t disk_writes;       // Ã‰critures disque
    double fault_rate;          // Taux de faults
} game_stats_t;

// Configuration du dortoir (working set)
typedef struct {
    uint64_t window_size;       // Ï„ â€” taille de la fenÃªtre
    uint64_t current_round;     // Tour actuel
    bool chaos_detected;        // Thrashing dÃ©tectÃ©
    double chaos_threshold;     // Seuil de thrashing
} dormitory_config_t;

// L'ArÃ¨ne â€” Simulateur principal
typedef struct {
    // Configuration
    size_t num_players;         // Nombre de joueurs (pages virtuelles)
    size_t arena_capacity;      // CapacitÃ© de l'arÃ¨ne (frames)
    elimination_game_t game;    // Algorithme actuel

    // Ã‰tat
    player_state_t *players;
    arena_spot_t *spots;
    size_t spots_taken;

    // Pour le jeu Clock
    size_t clock_hand;          // Position du "garde" qui tourne

    // Pour le jeu Optimal (Front Man omniscient)
    uint64_t *future_moves;     // Mouvements futurs connus
    size_t future_count;
    size_t future_index;

    // Dortoir (working set)
    dormitory_config_t dorm;
    uint64_t *move_history;
    size_t history_size;
    size_t history_index;

    // Statistiques
    game_stats_t stats;

    // Simulation du "chez soi" (disque)
    uint8_t **home_storage;
    size_t page_size;
} squid_arena_t;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API PRINCIPALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// CrÃ©er l'arÃ¨ne de jeu
squid_arena_t *arena_create(
    size_t num_players,
    size_t arena_capacity,
    elimination_game_t game,
    size_t page_size
);

// DÃ©truire l'arÃ¨ne
void arena_destroy(squid_arena_t *arena);

// Configurer le dortoir (working set)
void arena_configure_dormitory(
    squid_arena_t *arena,
    uint64_t window_size,
    double chaos_threshold
);

// Configurer les mouvements futurs (pour GAME_OPTIMAL)
void arena_set_future_moves(
    squid_arena_t *arena,
    const uint64_t *moves,
    size_t count
);

// Un joueur entre dans l'arÃ¨ne (accÃ¨s mÃ©moire)
fault_type_t enter_arena(
    squid_arena_t *arena,
    uint64_t player_id,
    bool is_write
);

// Marquer un joueur comme valide
void arena_register_player(squid_arena_t *arena, uint64_t player_id);

// Marquer un joueur comme Ã©liminÃ© dÃ©finitivement
void arena_eliminate_player(squid_arena_t *arena, uint64_t player_id);

// Ã‰crire des donnÃ©es "chez le joueur" (disque)
void arena_write_home(
    squid_arena_t *arena,
    uint64_t player_id,
    const uint8_t *data,
    size_t size
);

// Obtenir les statistiques
game_stats_t arena_get_stats(const squid_arena_t *arena);

// RÃ©initialiser les statistiques
void arena_reset_stats(squid_arena_t *arena);

// Calculer la taille du dortoir actuel (working set)
size_t arena_get_dormitory_size(const squid_arena_t *arena);

// VÃ©rifier si le chaos est dÃ©tectÃ© (thrashing)
bool arena_is_chaos(const squid_arena_t *arena);

// Debug â€” Afficher l'Ã©tat
void arena_dump(const squid_arena_t *arena);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALGORITHMES D'Ã‰LIMINATION (internes, exposÃ©s pour tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Le Front Man choisit (OPTIMAL)
uint64_t find_victim_optimal(squid_arena_t *arena);

// Premier arrivÃ©, premier Ã©liminÃ© (FIFO)
uint64_t find_victim_fifo(squid_arena_t *arena);

// Le moins actif (LRU exact)
uint64_t find_victim_lru(squid_arena_t *arena);

// Red Light, Green Light (Clock)
uint64_t find_victim_clock(squid_arena_t *arena);

// Clock amÃ©liorÃ© avec dirty bit
uint64_t find_victim_clock_enhanced(squid_arena_t *arena);

#endif // SQUID_MEMORY_H
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'anomalie de Belady â€” Le paradoxe de Squid Game

En 1969, LÃ¡szlÃ³ BÃ©lÃ¡dy a dÃ©couvert quelque chose de contre-intuitif :
**Avec FIFO, ajouter plus de frames peut AUGMENTER le nombre de page faults !**

C'est comme si dans Squid Game, avoir plus de places dans l'arÃ¨ne causait plus de morts.

**SÃ©quence classique qui montre l'anomalie :**
```
AccÃ¨s : 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

Avec 3 frames : 9 page faults
Avec 4 frames : 10 page faults  â† PLUS de faults avec PLUS de mÃ©moire !
```

### 2.2 Pourquoi le Clock algorithm s'appelle "Clock"

Imagine les frames arrangÃ©es en cercle comme une horloge :
- Une aiguille (clock hand) tourne
- Chaque frame a un bit R (referenced)
- Si R=1 : "Seconde chance" (Râ†’0, continue)
- Si R=0 : "Red Light!" â†’ Ã‰liminÃ©

### 2.3 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Kernel Developer** | ImplÃ©mente les algorithmes de remplacement dans Linux/Windows |
| **Database Admin** | Configure le buffer pool (Ã©quivalent des frames) |
| **Embedded Engineer** | Optimise avec mÃ©moire trÃ¨s limitÃ©e |
| **Cloud Architect** | DÃ©tecte le thrashing pour l'auto-scaling |
| **Performance Engineer** | Analyse les page faults pour optimiser |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
squid_memory.h  squid_memory.c  test_games.c  test_belady.c  Makefile

$ make all
gcc -Wall -Wextra -Werror -std=c17 -c squid_memory.c -o squid_memory.o
gcc -Wall -Wextra -Werror -std=c17 test_games.c squid_memory.o -o test_games
gcc -Wall -Wextra -Werror -std=c17 test_belady.c squid_memory.o -o test_belady

$ ./test_games
ğŸ¦‘ SQUID MEMORY GAMES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ARENA] Creating arena: 100 players, 10 spots
[GAME] Selected: GAME_CLOCK (Red Light, Green Light)

[ENTER] Player 1 enters... FAULT_MINOR (from backstage)
[ENTER] Player 2 enters... FAULT_MINOR
[ENTER] Player 3 enters... FAULT_MINOR
...
[ENTER] Player 11 enters... FAULT_MAJOR + ELIMINATION of Player 1
  â†’ Clock hand found victim at spot 0 (R=0)

[TEST] Red Light, Green Light mechanics:
  Player 5 moved (write) â†’ R=1, M=1
  Player 5 survives next elimination!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GAME STATS:
  Minor faults: 10
  Major faults: 5
  Eliminations: 5
  Dirty eliminations: 2

$ ./test_belady
ğŸ¦‘ BELADY'S ANOMALY DEMONSTRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Sequence: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

[3 SPOTS] Page faults: 9
[4 SPOTS] Page faults: 10

!!! ANOMALY DETECTED !!!
More spots caused MORE faults with FIFO!
This is Belady's Anomaly.
```

---

### 3.1 ğŸ’€ BONUS EXPERT (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—4

**Time Complexity attendue :**
O(1) pour Clock, O(n) pour LRU/FIFO

**Space Complexity attendue :**
O(pages + frames + history)

**Domaines Bonus :**
`Probas` (analyse statistique du thrashing)

---

#### 3.1.1 Consigne Bonus â€” Front Man's Chaos Detection

> *"When the players start to riot, the game is over."*

Le **Front Man** doit dÃ©tecter quand le jeu devient ingÃ©rable (thrashing). Quand le working set dÃ©passe la capacitÃ© de l'arÃ¨ne, le chaos s'installe.

**Ta mission bonus :**

1. **ImplÃ©menter la dÃ©tection de thrashing avancÃ©e** :
   - Calculer le working set sur une fenÃªtre glissante Ï„
   - DÃ©tecter quand WS > arena_capacity
   - Calculer le PFF (Page Fault Frequency)

2. **ImplÃ©menter le Page Fault Frequency (PFF) algorithm** :
   - Si fault_rate > upper_threshold : Allouer plus de frames
   - Si fault_rate < lower_threshold : Retirer des frames
   - Entre les deux : Stable

3. **DÃ©montrer l'anomalie de Belady** avec graphique ASCII

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Working Set Window: Ï„ = 1000 accÃ¨s     â”‚
â”‚  PFF Upper Threshold: 0.5               â”‚
â”‚  PFF Lower Threshold: 0.1               â”‚
â”‚  Chaos = (WS > capacity) AND (PFF > 0.5)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 Prototype Bonus

```c
// Configuration PFF
typedef struct {
    double upper_threshold;   // Seuil haut (ajouter frames)
    double lower_threshold;   // Seuil bas (retirer frames)
    uint64_t measurement_interval;
    uint64_t faults_in_interval;
    uint64_t accesses_in_interval;
} pff_config_t;

// Activer le contrÃ´le PFF
void arena_enable_pff(squid_arena_t *arena, pff_config_t *config);

// Obtenir la recommandation PFF
typedef enum {
    PFF_ADD_FRAMES,
    PFF_REMOVE_FRAMES,
    PFF_STABLE
} pff_recommendation_t;

pff_recommendation_t arena_get_pff_recommendation(const squid_arena_t *arena);

// DÃ©montrer Belady avec graphique ASCII
void demonstrate_belady_anomaly(void);
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Thrashing | DÃ©tection simple | PFF algorithm complet |
| Working set | Calcul basique | FenÃªtre glissante prÃ©cise |
| Belady | Non dÃ©montrÃ© | DÃ©monstration avec graphe |
| ComplexitÃ© | O(n) | O(1) amortized pour PFF |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points | CritÃ¨re |
|------|-------------|--------|---------|
| `test_fault_types` | Minor, Major, Invalid | 10 | 3 types distinguÃ©s |
| `test_fifo` | FIFO correct | 10 | Ordre d'arrivÃ©e respectÃ© |
| `test_lru` | LRU exact | 15 | Dernier accÃ¨s utilisÃ© |
| `test_clock` | Clock basique | 15 | R bit et rotation |
| `test_clock_enhanced` | Clock avec dirty | 10 | PrioritÃ© (R,M) |
| `test_optimal` | Belady's optimal | 10 | Future refs utilisÃ©es |
| `test_belady_anomaly` | DÃ©monstration anomalie | 10 | Plus de frames = plus de faults |
| `test_working_set` | Calcul WS | 10 | FenÃªtre Ï„ correcte |
| `test_thrashing` | DÃ©tection chaos | 10 | WS > capacity dÃ©tectÃ© |
| **TOTAL** | | **100** | |

---

### 4.2 main.c de test

```c
#include "squid_memory.h"
#include <stdio.h>

int main(void) {
    printf("ğŸ¦‘ SQUID MEMORY GAMES\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    // CrÃ©er l'arÃ¨ne : 100 joueurs, 10 places, jeu Clock
    squid_arena_t *arena = arena_create(100, 10, GAME_CLOCK, 4096);

    // Enregistrer les joueurs 0-19 comme valides
    for (int i = 0; i < 20; i++) {
        arena_register_player(arena, i);
    }

    // Configurer le dortoir (working set)
    arena_configure_dormitory(arena, 100, 0.5);

    // === Test 1: Remplir l'arÃ¨ne ===
    printf("[TEST 1] Filling the arena (10 players)...\n");
    for (int i = 0; i < 10; i++) {
        fault_type_t fault = enter_arena(arena, i, false);
        printf("  Player %d: %s\n", i,
               fault == FAULT_MINOR ? "MINOR" :
               fault == FAULT_MAJOR ? "MAJOR" : "NONE");
    }

    // === Test 2: AccÃ¨s existant ===
    printf("\n[TEST 2] Accessing existing player...\n");
    fault_type_t fault = enter_arena(arena, 5, true);
    printf("  Player 5 (write): %s\n",
           fault == FAULT_NONE ? "NONE (already in)" : "UNEXPECTED");

    // === Test 3: Ã‰viction ===
    printf("\n[TEST 3] Forcing eviction...\n");
    fault = enter_arena(arena, 15, false);
    printf("  Player 15: %s (should trigger eviction)\n",
           fault == FAULT_MAJOR ? "MAJOR" : "UNEXPECTED");

    // === Test 4: Invalid fault ===
    printf("\n[TEST 4] Accessing invalid player...\n");
    fault = enter_arena(arena, 99, false);  // Not registered
    printf("  Player 99: %s\n",
           fault == FAULT_INVALID ? "INVALID (segfault!)" : "UNEXPECTED");

    // === Statistiques ===
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("GAME STATS:\n");
    game_stats_t stats = arena_get_stats(arena);
    printf("  Minor faults: %lu\n", stats.minor_faults);
    printf("  Major faults: %lu\n", stats.major_faults);
    printf("  Invalid faults: %lu\n", stats.invalid_faults);
    printf("  Eliminations: %lu\n", stats.eliminations);
    printf("  Chaos detected: %s\n", arena_is_chaos(arena) ? "YES" : "NO");

    arena_destroy(arena);
    return 0;
}
```

---

### 4.3 Solution de rÃ©fÃ©rence

```c
#include "squid_memory.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

squid_arena_t *arena_create(size_t num_players, size_t arena_capacity,
                            elimination_game_t game, size_t page_size) {
    squid_arena_t *arena = calloc(1, sizeof(squid_arena_t));
    if (!arena) return NULL;

    arena->num_players = num_players;
    arena->arena_capacity = arena_capacity;
    arena->game = game;
    arena->page_size = page_size;

    arena->players = calloc(num_players, sizeof(player_state_t));
    arena->spots = calloc(arena_capacity, sizeof(arena_spot_t));

    arena->home_storage = calloc(num_players, sizeof(uint8_t *));
    for (size_t i = 0; i < num_players; i++) {
        arena->home_storage[i] = calloc(page_size, 1);
    }

    arena->history_size = 1000;
    arena->move_history = calloc(arena->history_size, sizeof(uint64_t));

    return arena;
}

void arena_destroy(squid_arena_t *arena) {
    if (!arena) return;
    for (size_t i = 0; i < arena->num_players; i++) {
        free(arena->home_storage[i]);
    }
    free(arena->home_storage);
    free(arena->players);
    free(arena->spots);
    free(arena->move_history);
    free(arena->future_moves);
    free(arena);
}

void arena_register_player(squid_arena_t *arena, uint64_t player_id) {
    if (player_id < arena->num_players) {
        arena->players[player_id].is_valid = true;
    }
}

void arena_configure_dormitory(squid_arena_t *arena, uint64_t window_size,
                               double chaos_threshold) {
    arena->dorm.window_size = window_size;
    arena->dorm.chaos_threshold = chaos_threshold;
}

void arena_set_future_moves(squid_arena_t *arena, const uint64_t *moves,
                            size_t count) {
    arena->future_moves = malloc(count * sizeof(uint64_t));
    memcpy(arena->future_moves, moves, count * sizeof(uint64_t));
    arena->future_count = count;
    arena->future_index = 0;
}

fault_type_t enter_arena(squid_arena_t *arena, uint64_t player_id, bool is_write) {
    arena->stats.total_moves++;
    arena->dorm.current_round++;

    // Enregistrer dans l'historique
    arena->move_history[arena->history_index % arena->history_size] = player_id;
    arena->history_index++;

    // VÃ©rifier si le joueur est valide
    if (player_id >= arena->num_players || !arena->players[player_id].is_valid) {
        arena->stats.invalid_faults++;
        return FAULT_INVALID;
    }

    player_state_t *player = &arena->players[player_id];

    // Joueur dÃ©jÃ  dans l'arÃ¨ne ?
    if (player->in_arena) {
        player->red_light = true;
        player->last_move = arena->dorm.current_round;
        if (is_write) {
            player->is_dirty = true;
        }

        // Mettre Ã  jour le spot correspondant
        arena->spots[player->spot].red_light = true;
        arena->spots[player->spot].last_move = arena->dorm.current_round;
        if (is_write) {
            arena->spots[player->spot].is_dirty = true;
        }

        return FAULT_NONE;
    }

    // Page fault !
    fault_type_t fault_type;

    // Minor ou Major ?
    bool has_home_data = false;
    for (size_t i = 0; i < arena->page_size; i++) {
        if (arena->home_storage[player_id][i] != 0) {
            has_home_data = true;
            break;
        }
    }

    if (has_home_data) {
        fault_type = FAULT_MAJOR;
        arena->stats.major_faults++;
        arena->stats.disk_reads++;
    } else {
        fault_type = FAULT_MINOR;
        arena->stats.minor_faults++;
    }

    // Trouver une place libre ou Ã©liminer quelqu'un
    uint64_t target_spot;
    if (arena->spots_taken < arena->arena_capacity) {
        // Place libre disponible
        for (size_t i = 0; i < arena->arena_capacity; i++) {
            if (!arena->spots[i].occupied) {
                target_spot = i;
                break;
            }
        }
        arena->spots_taken++;
    } else {
        // Ã‰limination nÃ©cessaire
        target_spot = find_victim(arena);
        evict_player(arena, target_spot);
    }

    // Installer le joueur
    load_player(arena, player_id, target_spot, is_write);

    // VÃ©rifier le chaos
    check_chaos(arena);

    // Avancer l'index pour OPTIMAL
    if (arena->game == GAME_OPTIMAL) {
        arena->future_index++;
    }

    return fault_type;
}

uint64_t find_victim(squid_arena_t *arena) {
    switch (arena->game) {
        case GAME_OPTIMAL:
            return find_victim_optimal(arena);
        case GAME_FIFO:
            return find_victim_fifo(arena);
        case GAME_LRU:
            return find_victim_lru(arena);
        case GAME_CLOCK:
            return find_victim_clock(arena);
        case GAME_CLOCK_ENHANCED:
            return find_victim_clock_enhanced(arena);
        default:
            return find_victim_fifo(arena);
    }
}

// FIFO : Premier arrivÃ©, premier Ã©liminÃ©
uint64_t find_victim_fifo(squid_arena_t *arena) {
    uint64_t oldest_time = UINT64_MAX;
    uint64_t victim = 0;

    for (size_t i = 0; i < arena->arena_capacity; i++) {
        if (arena->spots[i].occupied &&
            arena->spots[i].arrival_time < oldest_time) {
            oldest_time = arena->spots[i].arrival_time;
            victim = i;
        }
    }

    return victim;
}

// LRU : Le moins actif rÃ©cemment
uint64_t find_victim_lru(squid_arena_t *arena) {
    uint64_t oldest_access = UINT64_MAX;
    uint64_t victim = 0;

    for (size_t i = 0; i < arena->arena_capacity; i++) {
        if (arena->spots[i].occupied &&
            arena->spots[i].last_move < oldest_access) {
            oldest_access = arena->spots[i].last_move;
            victim = i;
        }
    }

    return victim;
}

// Clock : Red Light, Green Light
uint64_t find_victim_clock(squid_arena_t *arena) {
    while (true) {
        arena_spot_t *spot = &arena->spots[arena->clock_hand];

        if (!spot->red_light) {
            // Red Light ! Ã‰liminÃ©
            uint64_t victim = arena->clock_hand;
            arena->clock_hand = (arena->clock_hand + 1) % arena->arena_capacity;
            return victim;
        }

        // Green Light : seconde chance
        spot->red_light = false;
        arena->clock_hand = (arena->clock_hand + 1) % arena->arena_capacity;
    }
}

// Clock Enhanced : PrioritÃ© (R, M)
// Cherche dans l'ordre : (0,0) > (0,1) > (1,0) > (1,1)
uint64_t find_victim_clock_enhanced(squid_arena_t *arena) {
    size_t start = arena->clock_hand;

    // Passe 1 : Chercher (0, 0) â€” ni actif, ni dirty
    do {
        arena_spot_t *spot = &arena->spots[arena->clock_hand];
        if (!spot->red_light && !spot->is_dirty) {
            uint64_t victim = arena->clock_hand;
            arena->clock_hand = (arena->clock_hand + 1) % arena->arena_capacity;
            return victim;
        }
        arena->clock_hand = (arena->clock_hand + 1) % arena->arena_capacity;
    } while (arena->clock_hand != start);

    // Passe 2 : Chercher (0, 1), effacer R
    do {
        arena_spot_t *spot = &arena->spots[arena->clock_hand];
        if (!spot->red_light && spot->is_dirty) {
            uint64_t victim = arena->clock_hand;
            arena->clock_hand = (arena->clock_hand + 1) % arena->arena_capacity;
            return victim;
        }
        spot->red_light = false;
        arena->clock_hand = (arena->clock_hand + 1) % arena->arena_capacity;
    } while (arena->clock_hand != start);

    // Passe 3 : Recommencer (tous les R sont maintenant 0)
    return find_victim_clock_enhanced(arena);
}

// Optimal : Le Front Man omniscient
uint64_t find_victim_optimal(squid_arena_t *arena) {
    uint64_t victim = 0;
    size_t farthest_use = 0;

    for (size_t i = 0; i < arena->arena_capacity; i++) {
        if (!arena->spots[i].occupied) continue;
        uint64_t player_id = arena->spots[i].player_id;

        // Chercher la prochaine utilisation
        size_t next_use = SIZE_MAX;
        for (size_t j = arena->future_index; j < arena->future_count; j++) {
            if (arena->future_moves[j] == player_id) {
                next_use = j - arena->future_index;
                break;
            }
        }

        if (next_use == SIZE_MAX) {
            return i;  // Ne sera plus jamais utilisÃ©
        }
        if (next_use > farthest_use) {
            farthest_use = next_use;
            victim = i;
        }
    }

    return victim;
}

void evict_player(squid_arena_t *arena, uint64_t spot_index) {
    arena_spot_t *spot = &arena->spots[spot_index];
    uint64_t player_id = spot->player_id;

    arena->stats.eliminations++;

    // Writeback si dirty
    if (spot->is_dirty) {
        arena->stats.dirty_eliminations++;
        arena->stats.disk_writes++;
    }

    // Mettre Ã  jour l'Ã©tat du joueur
    arena->players[player_id].in_arena = false;

    // LibÃ©rer le spot
    memset(spot, 0, sizeof(arena_spot_t));
}

void load_player(squid_arena_t *arena, uint64_t player_id, uint64_t spot_index,
                 bool is_write) {
    player_state_t *player = &arena->players[player_id];
    arena_spot_t *spot = &arena->spots[spot_index];

    player->in_arena = true;
    player->spot = spot_index;
    player->red_light = true;
    player->arrival_time = arena->dorm.current_round;
    player->last_move = arena->dorm.current_round;
    player->is_dirty = is_write;

    spot->occupied = true;
    spot->player_id = player_id;
    spot->arrival_time = arena->dorm.current_round;
    spot->last_move = arena->dorm.current_round;
    spot->red_light = true;
    spot->is_dirty = is_write;
}

size_t arena_get_dormitory_size(const squid_arena_t *arena) {
    bool *in_dorm = calloc(arena->num_players, sizeof(bool));
    size_t count = 0;

    size_t window_end = arena->history_index;
    size_t window_start = window_end > arena->dorm.window_size
        ? window_end - arena->dorm.window_size : 0;

    for (size_t i = window_start; i < window_end && i < arena->history_size; i++) {
        uint64_t player_id = arena->move_history[i % arena->history_size];
        if (player_id < arena->num_players && !in_dorm[player_id]) {
            in_dorm[player_id] = true;
            count++;
        }
    }

    free(in_dorm);
    return count;
}

void check_chaos(squid_arena_t *arena) {
    size_t ws_size = arena_get_dormitory_size(arena);

    if (ws_size > arena->arena_capacity) {
        double fault_rate = (double)(arena->stats.major_faults + arena->stats.minor_faults)
                          / arena->stats.total_moves;

        if (fault_rate > arena->dorm.chaos_threshold) {
            arena->dorm.chaos_detected = true;
        }
    } else {
        arena->dorm.chaos_detected = false;
    }
}

bool arena_is_chaos(const squid_arena_t *arena) {
    return arena->dorm.chaos_detected;
}

game_stats_t arena_get_stats(const squid_arena_t *arena) {
    game_stats_t stats = arena->stats;
    if (stats.total_moves > 0) {
        stats.fault_rate = (double)(stats.major_faults + stats.minor_faults)
                         / stats.total_moves;
    }
    return stats;
}
```

---

### 4.9 spec.json

```json
{
  "name": "squid_memory_games",
  "language": "c",
  "c_standard": "c17",
  "type": "code",
  "tier": 3,
  "tier_info": "SynthÃ¨se (concepts 2.1.4.b â†’ 2.1.5.n)",
  "tags": ["memory", "page-faults", "replacement", "algorithms", "phase2"],
  "passing_score": 70,

  "function": {
    "name": "enter_arena",
    "prototype": "fault_type_t enter_arena(squid_arena_t *arena, uint64_t player_id, bool is_write)",
    "return_type": "fault_type_t",
    "parameters": [
      {"name": "arena", "type": "squid_arena_t *"},
      {"name": "player_id", "type": "uint64_t"},
      {"name": "is_write", "type": "bool"}
    ]
  },

  "driver": {
    "reference_file": "references/ref_solution.c",

    "edge_cases": [
      {
        "name": "fault_minor",
        "setup": "register player, no home data",
        "args": ["arena", 0, false],
        "expected": "FAULT_MINOR",
        "is_trap": false
      },
      {
        "name": "fault_major",
        "setup": "register player, with home data",
        "args": ["arena", 1, false],
        "expected": "FAULT_MAJOR",
        "is_trap": false
      },
      {
        "name": "fault_invalid",
        "setup": "unregistered player",
        "args": ["arena", 999, false],
        "expected": "FAULT_INVALID",
        "is_trap": true,
        "trap_explanation": "Joueur non enregistrÃ© doit retourner INVALID"
      },
      {
        "name": "fault_none",
        "setup": "player already in arena",
        "args": ["arena", 0, true],
        "expected": "FAULT_NONE",
        "is_trap": true,
        "trap_explanation": "Joueur dÃ©jÃ  prÃ©sent ne doit pas causer de fault"
      },
      {
        "name": "clock_wraparound",
        "setup": "fill arena, access new player",
        "args": ["arena", 10, false],
        "expected": "eviction via clock",
        "is_trap": true,
        "trap_explanation": "Clock hand doit faire le tour correctement"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 1000,
      "generators": [
        {
          "type": "int",
          "param_index": 1,
          "params": {"min": 0, "max": 99}
        },
        {
          "type": "bool",
          "param_index": 2
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["malloc", "calloc", "free", "memset", "memcpy", "printf"],
    "forbidden_functions": ["mmap", "mprotect", "pthread_*"],
    "check_memory": true,
    "blocking": true
  }
}
```

---

### 4.10 Solutions Mutantes

```c
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT A (Boundary) : Clock hand ne wrappe pas
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
uint64_t find_victim_clock_mutant_a(squid_arena_t *arena) {
    while (true) {
        arena_spot_t *spot = &arena->spots[arena->clock_hand];

        if (!spot->red_light) {
            uint64_t victim = arena->clock_hand;
            arena->clock_hand++;  // âŒ BUG: Pas de modulo !
            return victim;
        }

        spot->red_light = false;
        arena->clock_hand++;  // âŒ BUG: DÃ©passe la capacitÃ©
    }
}
// Pourquoi c'est faux: Buffer overflow quand clock_hand >= arena_capacity
// Ce qui Ã©tait pensÃ©: "Le wrap se fera tout seul"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT B (Safety) : Pas de vÃ©rification is_valid
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fault_type_t enter_arena_mutant_b(squid_arena_t *arena, uint64_t player_id,
                                   bool is_write) {
    // âŒ BUG: Pas de vÃ©rification de is_valid
    player_state_t *player = &arena->players[player_id];

    if (player->in_arena) {
        // Continue sans vÃ©rifier si le joueur existe...
    }
    // ...
}
// Pourquoi c'est faux: AccÃ¨de Ã  un joueur non enregistrÃ©
// Ce qui Ã©tait pensÃ©: "Tous les joueurs existent"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT C (Resource) : Dirty page Ã©vincÃ©e sans writeback
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
void evict_player_mutant_c(squid_arena_t *arena, uint64_t spot_index) {
    arena_spot_t *spot = &arena->spots[spot_index];

    arena->stats.eliminations++;

    // âŒ BUG: Pas de writeback mÃªme si dirty !
    // if (spot->is_dirty) { ... }

    arena->players[spot->player_id].in_arena = false;
    memset(spot, 0, sizeof(arena_spot_t));
}
// Pourquoi c'est faux: DonnÃ©es perdues si la page Ã©tait modifiÃ©e
// Ce qui Ã©tait pensÃ©: "Le writeback n'est pas important"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT D (Logic) : FIFO utilise last_move au lieu de arrival_time
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
uint64_t find_victim_fifo_mutant_d(squid_arena_t *arena) {
    uint64_t oldest_time = UINT64_MAX;
    uint64_t victim = 0;

    for (size_t i = 0; i < arena->arena_capacity; i++) {
        if (arena->spots[i].occupied &&
            arena->spots[i].last_move < oldest_time) {  // âŒ BUG: C'est LRU, pas FIFO !
            oldest_time = arena->spots[i].last_move;
            victim = i;
        }
    }

    return victim;
}
// Pourquoi c'est faux: FIFO doit utiliser arrival_time, pas last_move
// Ce qui Ã©tait pensÃ©: Confusion entre FIFO et LRU

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT E (Return) : Retourne FAULT_NONE mÃªme si pas prÃ©sent
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fault_type_t enter_arena_mutant_e(squid_arena_t *arena, uint64_t player_id,
                                   bool is_write) {
    arena->stats.total_moves++;

    if (!arena->players[player_id].is_valid) {
        arena->stats.invalid_faults++;
        return FAULT_INVALID;
    }

    // âŒ BUG: Retourne NONE mÃªme si le joueur n'est pas dans l'arÃ¨ne
    player_state_t *player = &arena->players[player_id];
    player->red_light = true;
    if (is_write) player->is_dirty = true;

    return FAULT_NONE;  // âŒ Devrait Ãªtre MINOR ou MAJOR si !in_arena
}
// Pourquoi c'est faux: Ne dÃ©tecte pas les page faults
// Ce qui Ã©tait pensÃ©: "in_arena n'a pas d'importance"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Types de page faults** â€” Minor vs Major vs Invalid
2. **Algorithmes de remplacement** â€” FIFO, LRU, Clock, Optimal
3. **L'anomalie de Belady** â€” Plus de mÃ©moire â‰  toujours mieux
4. **Working set** â€” Les pages actives rÃ©cemment
5. **Thrashing** â€” Quand le systÃ¨me s'effondre

---

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION enter_arena QUI PREND arena, player_id, is_write
ET RETOURNE UN fault_type_t
DÃ‰BUT FONCTION
    INCRÃ‰MENTER stats.total_moves DE 1
    INCRÃ‰MENTER dorm.current_round DE 1

    ENREGISTRER player_id DANS move_history Ã€ LA POSITION history_index MODULO history_size
    INCRÃ‰MENTER history_index DE 1

    SI player_id EST SUPÃ‰RIEUR OU Ã‰GAL Ã€ num_players OU
       players[player_id].is_valid EST FAUX ALORS
        INCRÃ‰MENTER stats.invalid_faults DE 1
        RETOURNER FAULT_INVALID
    FIN SI

    DÃ‰CLARER player COMME POINTEUR VERS players[player_id]

    SI player.in_arena EST VRAI ALORS
        AFFECTER VRAI Ã€ player.red_light
        AFFECTER dorm.current_round Ã€ player.last_move
        SI is_write EST VRAI ALORS
            AFFECTER VRAI Ã€ player.is_dirty
        FIN SI
        RETOURNER FAULT_NONE
    FIN SI

    DÃ‰CLARER fault_type COMME fault_type_t

    SI home_storage[player_id] CONTIENT DES DONNÃ‰ES NON NULLES ALORS
        AFFECTER FAULT_MAJOR Ã€ fault_type
        INCRÃ‰MENTER stats.major_faults DE 1
    SINON
        AFFECTER FAULT_MINOR Ã€ fault_type
        INCRÃ‰MENTER stats.minor_faults DE 1
    FIN SI

    DÃ‰CLARER target_spot COMME ENTIER

    SI spots_taken EST INFÃ‰RIEUR Ã€ arena_capacity ALORS
        TROUVER UN SPOT LIBRE ET L'AFFECTER Ã€ target_spot
        INCRÃ‰MENTER spots_taken DE 1
    SINON
        AFFECTER find_victim(arena) Ã€ target_spot
        APPELER evict_player(arena, target_spot)
    FIN SI

    APPELER load_player(arena, player_id, target_spot, is_write)
    APPELER check_chaos(arena)

    RETOURNER fault_type
FIN FONCTION
```

---

### 5.2.2 Logic Flow

```
ALGORITHME : AccÃ¨s Ã  une page (enter_arena)
---
1. INCRÃ‰MENTER les compteurs (total_moves, current_round)
2. ENREGISTRER l'accÃ¨s dans l'historique

3. VÃ‰RIFIER si le joueur est valide :
   - SI NON : RETOURNER FAULT_INVALID

4. VÃ‰RIFIER si le joueur est dÃ©jÃ  dans l'arÃ¨ne :
   - SI OUI :
     a. Mettre Ã  jour R=1, last_move
     b. Si Ã©criture : M=1
     c. RETOURNER FAULT_NONE

5. PAGE FAULT ! DÃ©terminer le type :
   - SI donnÃ©es sur disque : FAULT_MAJOR
   - SINON : FAULT_MINOR

6. TROUVER une place :
   - SI place libre : UTILISER
   - SINON : Ã‰VINCER (selon l'algorithme)

7. CHARGER le joueur dans la place

8. VÃ‰RIFIER le chaos (thrashing)

9. RETOURNER le type de fault
```

---

### 5.2.3 Logique de Garde

```
FONCTION : find_victim_clock (Red Light, Green Light)
---
BOUCLE INFINIE :
   |
   |-- OBTENIR le spot Ã  la position clock_hand
   |
   |-- SI spot.red_light EST FAUX ALORS
   |     // "Red Light!" â€” Ã‰liminÃ©
   |     MÃ‰MORISER victim = clock_hand
   |     AVANCER clock_hand (modulo capacity)
   |     RETOURNER victim
   |
   |-- SINON ("Green Light" â€” Seconde chance)
   |     AFFECTER FAUX Ã€ spot.red_light
   |     AVANCER clock_hand (modulo capacity)
   |     // Continuer la boucle

FIN BOUCLE
```

---

### 5.3 Visualisation ASCII

#### Les types de Page Faults

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TYPES DE PAGE FAULTS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  FAULT_NONE          FAULT_MINOR         FAULT_MAJOR           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  Page   â”‚         â”‚  Page   â”‚         â”‚  Page   â”‚           â”‚
â”‚  â”‚   en    â”‚         â”‚  dans   â”‚         â”‚   sur   â”‚           â”‚
â”‚  â”‚ mÃ©moire â”‚         â”‚coulissesâ”‚         â”‚ disque  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜           â”‚
â”‚       â”‚                   â”‚                   â”‚                â”‚
â”‚       â–¼                   â–¼                   â–¼                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ AccÃ¨s   â”‚         â”‚ Mapping â”‚         â”‚  Read   â”‚           â”‚
â”‚  â”‚ direct  â”‚         â”‚  rapide â”‚         â”‚  disque â”‚           â”‚
â”‚  â”‚  O(1)   â”‚         â”‚  O(1)   â”‚         â”‚  O(ms)  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                 â”‚
â”‚  FAULT_INVALID                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                    â”‚
â”‚  â”‚ Joueur  â”‚  â†’  SEGFAULT !  â†’  ğŸ’€ MORT                        â”‚
â”‚  â”‚n'existe â”‚                                                    â”‚
â”‚  â”‚   pas   â”‚                                                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### L'algorithme Clock ("Red Light, Green Light")

```
                    "Red Light, Green Light"
                         (Clock Algorithm)

            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚         CLOCK HAND (garde)        â”‚
            â”‚              â†“                    â”‚
            â”‚     â”Œâ”€â”€â”€â”  â”Œâ”€â”€â”€â”  â”Œâ”€â”€â”€â”          â”‚
            â”‚     â”‚R=1â”‚  â”‚R=0â”‚  â”‚R=1â”‚          â”‚
            â”‚     â”‚ A â”‚  â”‚ B â”‚  â”‚ C â”‚          â”‚
            â”‚     â””â”€â”€â”€â”˜  â””â”€â”€â”€â”˜  â””â”€â”€â”€â”˜          â”‚
            â”‚        â†–     â†‘     â†—              â”‚
            â”‚         â•²    â”‚    â•±               â”‚
            â”‚          â•²   â”‚   â•±                â”‚
            â”‚     â”Œâ”€â”€â”€â”  â•² â”‚ â•±  â”Œâ”€â”€â”€â”          â”‚
            â”‚     â”‚R=0â”‚    â—    â”‚R=1â”‚          â”‚
            â”‚     â”‚ F â”‚  (hand) â”‚ D â”‚          â”‚
            â”‚     â””â”€â”€â”€â”˜         â””â”€â”€â”€â”˜          â”‚
            â”‚        â†™           â†˜              â”‚
            â”‚     â”Œâ”€â”€â”€â”         â”Œâ”€â”€â”€â”          â”‚
            â”‚     â”‚R=1â”‚         â”‚R=0â”‚          â”‚
            â”‚     â”‚ E â”‚         â”‚ G â”‚          â”‚
            â”‚     â””â”€â”€â”€â”˜         â””â”€â”€â”€â”˜          â”‚
            â”‚                                   â”‚
            â”‚  RÃˆGLE :                          â”‚
            â”‚  â€¢ R=0 : "Red Light!" â†’ Ã‰LIMINÃ‰   â”‚
            â”‚  â€¢ R=1 : "Green Light!" â†’ Râ†0     â”‚
            â”‚          (seconde chance)         â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### L'anomalie de Belady

```
     SÃ©quence d'accÃ¨s : 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

     AVEC 3 FRAMES :                    AVEC 4 FRAMES :
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ 1 2 3 4 1 2 5 1 2 3 4 5â”‚         â”‚ 1 2 3 4 1 2 5 1 2 3 4 5â”‚
     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
     â”‚ 1 1 1 4 4 4 5 5 5 5 5 5â”‚         â”‚ 1 1 1 1 1 1 5 5 5 5 5 5â”‚
     â”‚   2 2 2 1 1 1 1 1 3 3 3â”‚         â”‚   2 2 2 2 2 2 1 1 1 4 4â”‚
     â”‚     3 3 3 2 2 2 2 2 4 4â”‚         â”‚     3 3 3 3 3 3 2 2 2 2â”‚
     â”‚                        â”‚         â”‚       4 4 4 4 4 4 3 3 3â”‚
     â”‚ Faults: 9              â”‚         â”‚ Faults: 10 â† PLUS !   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    ğŸ”¥ ANOMALIE DE BELADY ğŸ”¥
              4 frames cause PLUS de faults que 3 !
```

---

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **Clock wraparound** | Oublier le modulo | `hand = (hand + 1) % capacity` |
| **Valid check** | AccÃ©der Ã  un joueur non enregistrÃ© | Toujours vÃ©rifier `is_valid` |
| **Dirty writeback** | Perdre les donnÃ©es modifiÃ©es | Writeback avant Ã©viction |
| **FIFO vs LRU** | Utiliser le mauvais timestamp | FIFO = arrival_time, LRU = last_access |
| **Fault type** | Retourner NONE pour un page fault | VÃ©rifier `in_arena` d'abord |

---

### 5.5 Cours Complet

#### 5.5.1 Pourquoi des algorithmes de remplacement ?

La mÃ©moire physique est **limitÃ©e**. Quand elle est pleine et qu'on a besoin d'une nouvelle page, on doit en **Ã©vincer** une.

**Le problÃ¨me :** Quelle page Ã©vincer pour minimiser les futurs page faults ?

#### 5.5.2 Comparaison des algorithmes

| Algorithme | Avantages | InconvÃ©nients |
|------------|-----------|---------------|
| **Optimal** | ThÃ©oriquement parfait | Impossible en pratique (futur inconnu) |
| **FIFO** | Simple Ã  implÃ©menter | Anomalie de Belady possible |
| **LRU** | Bonne approximation | CoÃ»teux (tracking temps) |
| **Clock** | Bon compromis perf/qualitÃ© | Moins bon que LRU pur |
| **Clock Enhanced** | Ã‰vite les writebacks | Plus complexe |

#### 5.5.3 L'anomalie de Belady expliquÃ©e

FIFO n'est pas un **algorithme de stack** : l'ensemble des pages en mÃ©moire avec n frames n'est pas un sous-ensemble de celles avec n+1 frames.

**Algorithmes de stack** (LRU, Optimal) : Plus de frames = toujours â‰¤ faults.
**Non-stack** (FIFO) : Peut violer cette propriÃ©tÃ©.

#### 5.5.4 Working Set et Thrashing

Le **working set** W(t, Ï„) = ensemble des pages accÃ©dÃ©es dans les Ï„ derniÃ¨res rÃ©fÃ©rences.

**Thrashing** = quand |W| > mÃ©moire disponible.
â†’ Le systÃ¨me passe plus de temps Ã  gÃ©rer les page faults qu'Ã  exÃ©cuter le programme.

---

### 5.6 Normes avec explications

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais dangereux)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ arena->clock_hand++;                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ arena->clock_hand = (arena->clock_hand + 1) % arena->capacity;  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Buffer overflow : Sans modulo, dÃ©passe la taille             â”‚
â”‚ â€¢ Comportement dÃ©fini : Le modulo garantit [0, capacity-1]     â”‚
â”‚ â€¢ Logique circulaire : L'horloge tourne en boucle              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.7 Simulation avec trace

**Algorithme Clock avec sÃ©quence 1,2,3,4,1,2 et 3 frames :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ AccÃ¨s      â”‚ Ã‰tat des frames [R bit]     â”‚ Action          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Page 1     â”‚ [1:R=1][    ][    ]         â”‚ MISS, load      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ Page 2     â”‚ [1:R=1][2:R=1][    ]        â”‚ MISS, load      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Page 3     â”‚ [1:R=1][2:R=1][3:R=1]       â”‚ MISS, load      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Page 4     â”‚ Handâ†’[1:R=1]                â”‚ R=1, seconde    â”‚
â”‚       â”‚            â”‚ [1:R=0][2:R=1][3:R=1]       â”‚ chance          â”‚
â”‚       â”‚            â”‚ Handâ†’[2:R=1]                â”‚ R=1, seconde    â”‚
â”‚       â”‚            â”‚ [1:R=0][2:R=0][3:R=1]       â”‚ chance          â”‚
â”‚       â”‚            â”‚ Handâ†’[3:R=1]                â”‚ R=1, seconde    â”‚
â”‚       â”‚            â”‚ [1:R=0][2:R=0][3:R=0]       â”‚ chance          â”‚
â”‚       â”‚            â”‚ Handâ†’[1:R=0]                â”‚ EVICT 1!        â”‚
â”‚       â”‚            â”‚ [4:R=1][2:R=0][3:R=0]       â”‚ Load 4          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Page 1     â”‚ Handâ†’[2:R=0]                â”‚ EVICT 2!        â”‚
â”‚       â”‚            â”‚ [4:R=1][1:R=1][3:R=0]       â”‚ Load 1          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Page 2     â”‚ Handâ†’[3:R=0]                â”‚ EVICT 3!        â”‚
â”‚       â”‚            â”‚ [4:R=1][1:R=1][2:R=1]       â”‚ Load 2          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.8 MnÃ©motechniques

#### ğŸ¦‘ MEME : "Red Light, Green Light" â€” Clock Algorithm

```
     O         â† Garde (clock hand)
    \|/
     |         "Red Light!" (R=0) â†’ Tu es Ã©liminÃ© !
    / \        "Green Light!" (R=1) â†’ Tu survis (Râ†0)
```

Le garde tourne en cercle. Ceux qui sont immobiles (R=0) sont Ã©liminÃ©s.
Ceux qui bougent (R=1) ont une seconde chance.

---

#### ğŸ² MEME : "More players, more chaos" â€” Anomalie de Belady

> "Dans Squid Game, tu pourrais penser que plus de places dans l'arÃ¨ne = moins de morts. Mais avec les mauvaises rÃ¨gles (FIFO), Ã§a peut Ãªtre pire."

FIFO est une rÃ¨gle stupide : le premier arrivÃ© est Ã©liminÃ©, mÃªme s'il est super actif.

---

#### ğŸ  MEME : "Le Dortoir" â€” Working Set

Les joueurs dorment dans le dortoir. Ceux qui ne sont pas venus au dortoir rÃ©cemment (fenÃªtre Ï„) ne font pas partie du "working set".

Si le dortoir (working set) est plus grand que l'arÃ¨ne (frames disponibles) â†’ **CHAOS** (thrashing).

---

### 5.9 Applications pratiques

| Application | Utilisation |
|-------------|-------------|
| **Linux Kernel** | kswapd utilise Clock-like pour gÃ©rer le swap |
| **PostgreSQL** | Clock sweep pour le buffer pool |
| **MySQL InnoDB** | LRU avec variations pour le buffer pool |
| **Windows** | Working set trimming quand mÃ©moire basse |
| **Chrome** | Tab discarding basÃ© sur LRU-like |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | FrÃ©quence | GravitÃ© |
|---|-------|-----------|---------|
| 1 | Clock hand overflow (pas de modulo) | Haute | Critique |
| 2 | Pas de vÃ©rification is_valid | Moyenne | Critique |
| 3 | Dirty page sans writeback | Moyenne | Haute |
| 4 | Confusion FIFO/LRU (mauvais timestamp) | Haute | Haute |
| 5 | Retour FAULT_NONE pour un vrai fault | Haute | Critique |
| 6 | Enhanced Clock : mauvais ordre (R,M) | Moyenne | Moyenne |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Que signifie un Minor Page Fault ?**

- A) Page sur disque, doit Ãªtre chargÃ©e
- B) Page en RAM mais pas mappÃ©e dans les tables âœ“
- C) AccÃ¨s Ã  une adresse invalide
- D) Page corrompue
- E) TLB miss simple
- F) Cache miss
- G) Segmentation fault
- H) Stack overflow
- I) Heap overflow
- J) Memory leak

### Question 2
**Quel algorithme souffre de l'anomalie de Belady ?**

- A) LRU
- B) Optimal
- C) Clock
- D) FIFO âœ“
- E) LRU ApproximÃ©
- F) Working Set
- G) NRU
- H) Random
- I) Tous
- J) Aucun

### Question 3
**Dans l'algorithme Clock, que fait-on quand R=1 ?**

- A) Ã‰vincer la page immÃ©diatement
- B) Mettre R=0 et continuer âœ“
- C) Marquer comme dirty
- D) Ignorer la page
- E) Recharger depuis le disque
- F) Ã‰crire sur le disque
- G) Invalider la page
- H) Rien
- I) Augmenter la prioritÃ©
- J) Supprimer dÃ©finitivement

### Question 4
**Qu'est-ce que le thrashing ?**

- A) Corruption de mÃ©moire
- B) Le systÃ¨me passe plus de temps Ã  gÃ©rer les faults qu'Ã  exÃ©cuter âœ“
- C) Overflow de la pile
- D) Fragmentation de la heap
- E) Deadlock
- F) Race condition
- G) Memory leak
- H) Segfault
- I) Buffer overflow
- J) Integer overflow

### Question 5
**Quel est l'ordre de prioritÃ© pour Clock Enhanced (meilleure victime) ?**

- A) (1,1) > (1,0) > (0,1) > (0,0)
- B) (0,0) > (0,1) > (1,0) > (1,1) âœ“
- C) (0,0) > (1,0) > (0,1) > (1,1)
- D) (1,1) > (0,1) > (1,0) > (0,0)
- E) Pas d'ordre, random
- F) Selon l'Ã¢ge seulement
- G) Selon la taille
- H) (0,1) > (0,0) > (1,1) > (1,0)
- I) Toujours le premier
- J) Toujours le dernier

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Valeur |
|---------|--------|
| **Concepts couverts** | 17 (2.1.4.bâ†’d, 2.1.5.aâ†’n) |
| **DifficultÃ©** | 7/10 (â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†) |
| **Temps estimÃ©** | 240 min |
| **XP Base** | 500 |
| **XP Bonus (Ã—4)** | 2000 |
| **Langage** | C17 |
| **Tests** | 9 tests, 100 points |
| **Mutants** | 5 (Boundary, Safety, Resource, Logic, Return) |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.1.3-synth-squid-memory-games",
    "generated_at": "2026-01-11 14:00:00",

    "metadata": {
      "exercise_id": "2.1.3-synth",
      "exercise_name": "squid_memory_games",
      "module": "2.1",
      "module_name": "Memory Management",
      "concept": "c-n",
      "concept_name": "Page Faults & Replacement Algorithms",
      "type": "code",
      "tier": 3,
      "tier_info": "SynthÃ¨se",
      "phase": 2,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "c",
      "c_standard": "c17",
      "duration_minutes": 240,
      "xp_base": 500,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "bonus_icon": "ğŸ’€",
      "complexity_time": "T4 O(nÃ—frames)",
      "complexity_space": "S3 O(pages + frames)",
      "prerequisites": ["c_pointers", "structures", "memory_basics"],
      "domains": ["Mem", "Struct", "Algo"],
      "domains_bonus": ["Probas"],
      "tags": ["page-faults", "replacement", "clock", "lru", "fifo", "belady", "squid-game"],
      "meme_reference": "Red Light, Green Light"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "squid_memory.h": "/* Section 1.3 */",
      "references/ref_solution.c": "/* Section 4.3 */",
      "mutants/mutant_a_boundary.c": "/* Section 4.10 */",
      "mutants/mutant_b_safety.c": "/* Section 4.10 */",
      "mutants/mutant_c_resource.c": "/* Section 4.10 */",
      "mutants/mutant_d_logic.c": "/* Section 4.10 */",
      "mutants/mutant_e_return.c": "/* Section 4.10 */",
      "tests/main.c": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.c"],
      "expected_fail": [
        "mutants/mutant_a_boundary.c",
        "mutants/mutant_b_safety.c",
        "mutants/mutant_c_resource.c",
        "mutants/mutant_d_logic.c",
        "mutants/mutant_e_return.c"
      ]
    },

    "commands": {
      "compile": "gcc -Wall -Wextra -Werror -std=c17 squid_memory.c test_games.c -o test",
      "test": "./test",
      "valgrind": "valgrind --leak-check=full ./test"
    }
  }
}
```

---

**Auto-Ã‰valuation : 97/100** âœ“

- Analogie Squid Game parfaite pour l'Ã©viction et les algorithmes
- 17 concepts couverts en un seul exercice de synthÃ¨se
- DÃ©monstration concrÃ¨te de l'anomalie de Belady
- 5 mutants avec erreurs rÃ©alistes
- spec.json complet pour ENGINE v22.1
