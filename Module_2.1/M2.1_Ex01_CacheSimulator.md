# Ex01: Cache Hierarchy Simulator

## Concepts couverts
- 2.1.1.e: Direct-mapped cache
- 2.1.1.f: Set-associative cache
- 2.1.1.g: Fully associative cache
- 2.1.1.i: Replacement policies (LRU, FIFO, random)
- 2.1.1.j: Cache coherency intro (MESI protocol basics)
- 2.1.1.k: TLB (Translation Lookaside Buffer)

## Description
Implementer un simulateur de cache configurable en C17 qui supporte differentes organisations (direct-mapped, set-associative, fully associative) avec plusieurs politiques de remplacement. Le simulateur doit aussi inclure un TLB simplifie et afficher des statistiques de performance (hit/miss ratio).

## Objectifs pedagogiques
1. Comprendre les differentes organisations de cache et leurs compromis
2. Implementer les algorithmes de remplacement LRU, FIFO et random
3. Apprehender le role du TLB dans la hierarchie memoire
4. Analyser l'impact des parametres de cache sur les performances
5. Introduction aux concepts de coherence de cache (MESI simplifie)

## Structure (C17)

```c
// cache_simulator.h
#ifndef CACHE_SIMULATOR_H
#define CACHE_SIMULATOR_H

#include <stdint.h>
#include <stdbool.h>

// Types d'organisation de cache
typedef enum {
    CACHE_DIRECT_MAPPED,
    CACHE_SET_ASSOCIATIVE,
    CACHE_FULLY_ASSOCIATIVE
} cache_org_t;

// Politiques de remplacement
typedef enum {
    REPLACE_LRU,
    REPLACE_FIFO,
    REPLACE_RANDOM
} replace_policy_t;

// Etats MESI pour la coherence
typedef enum {
    MESI_MODIFIED,
    MESI_EXCLUSIVE,
    MESI_SHARED,
    MESI_INVALID
} mesi_state_t;

// Ligne de cache
typedef struct {
    bool valid;
    bool dirty;
    uint64_t tag;
    uint64_t last_access;    // Pour LRU
    uint64_t insertion_time; // Pour FIFO
    mesi_state_t mesi_state;
    uint8_t *data;           // Donnees (taille = line_size)
} cache_line_t;

// Set de cache (pour set-associative)
typedef struct {
    cache_line_t *lines;     // Tableau de lignes (ways)
    size_t num_ways;
} cache_set_t;

// Structure principale du cache
typedef struct {
    cache_org_t organization;
    replace_policy_t policy;
    size_t total_size;       // Taille totale en bytes
    size_t line_size;        // Taille d'une ligne (64 bytes typique)
    size_t num_sets;
    size_t num_ways;         // Associativite
    cache_set_t *sets;

    // Statistiques
    uint64_t hits;
    uint64_t misses;
    uint64_t evictions;
    uint64_t access_count;
} cache_t;

// Entree TLB
typedef struct {
    bool valid;
    uint64_t vpn;            // Virtual Page Number
    uint64_t pfn;            // Physical Frame Number
    uint64_t last_access;
} tlb_entry_t;

// Structure TLB
typedef struct {
    tlb_entry_t *entries;
    size_t num_entries;
    uint64_t hits;
    uint64_t misses;
} tlb_t;

// === API Cache ===

// Creer un cache avec la configuration specifiee
cache_t *cache_create(cache_org_t org, replace_policy_t policy,
                      size_t total_size, size_t line_size, size_t associativity);

// Liberer le cache
void cache_destroy(cache_t *cache);

// Acceder au cache (lecture)
// Retourne true si hit, false si miss
bool cache_read(cache_t *cache, uint64_t address, uint8_t *data, size_t size);

// Acceder au cache (ecriture)
bool cache_write(cache_t *cache, uint64_t address, const uint8_t *data, size_t size);

// Obtenir les statistiques
void cache_get_stats(const cache_t *cache, uint64_t *hits, uint64_t *misses,
                     double *hit_ratio);

// Reinitialiser les statistiques
void cache_reset_stats(cache_t *cache);

// Afficher l'etat du cache (debug)
void cache_dump(const cache_t *cache);

// === API TLB ===

// Creer un TLB
tlb_t *tlb_create(size_t num_entries);

// Liberer le TLB
void tlb_destroy(tlb_t *tlb);

// Rechercher dans le TLB
// Retourne true si trouve, pfn est rempli
bool tlb_lookup(tlb_t *tlb, uint64_t vpn, uint64_t *pfn);

// Inserer dans le TLB (avec eviction LRU si necessaire)
void tlb_insert(tlb_t *tlb, uint64_t vpn, uint64_t pfn);

// Invalider une entree
void tlb_invalidate(tlb_t *tlb, uint64_t vpn);

// Flush complet du TLB
void tlb_flush(tlb_t *tlb);

// === Simulation MESI simplifiee ===

// Simuler une lecture dans un systeme multi-cache
// Retourne le nouvel etat MESI
mesi_state_t mesi_read(cache_t *local_cache, cache_t *remote_cache,
                       uint64_t address);

// Simuler une ecriture dans un systeme multi-cache
mesi_state_t mesi_write(cache_t *local_cache, cache_t *remote_cache,
                        uint64_t address);

#endif // CACHE_SIMULATOR_H
```

## Fichiers a rendre
- `cache_simulator.h` - Header avec les declarations
- `cache_simulator.c` - Implementation complete
- `main.c` - Programme de test avec scenarios

## Criteres d'evaluation
1. **Organisation cache (30%)**: Implementation correcte des 3 types
2. **Politiques de remplacement (25%)**: LRU, FIFO, random fonctionnels
3. **TLB (20%)**: Lookup, insertion, invalidation corrects
4. **MESI basique (15%)**: Transitions d'etat correctes
5. **Tests et documentation (10%)**: Code teste et commente

## Tests automatises

```c
// test_cache.c
void test_direct_mapped(void) {
    cache_t *cache = cache_create(CACHE_DIRECT_MAPPED, REPLACE_LRU,
                                  1024, 64, 1);
    assert(cache != NULL);

    uint8_t data[8] = {1, 2, 3, 4, 5, 6, 7, 8};

    // Premier acces = miss
    assert(cache_write(cache, 0x1000, data, 8) == false);

    // Deuxieme acces meme ligne = hit
    assert(cache_read(cache, 0x1000, data, 8) == true);

    // Acces conflictuel (meme set, tag different)
    assert(cache_write(cache, 0x1000 + 1024, data, 8) == false);

    // L'original a ete evince
    assert(cache_read(cache, 0x1000, data, 8) == false);

    cache_destroy(cache);
    printf("test_direct_mapped: PASS\n");
}

void test_lru_replacement(void) {
    cache_t *cache = cache_create(CACHE_SET_ASSOCIATIVE, REPLACE_LRU,
                                  1024, 64, 4); // 4-way
    // ... tests LRU
}

void test_tlb(void) {
    tlb_t *tlb = tlb_create(16);

    // Insertion
    tlb_insert(tlb, 0x1000, 0x5000);

    // Lookup hit
    uint64_t pfn;
    assert(tlb_lookup(tlb, 0x1000, &pfn) == true);
    assert(pfn == 0x5000);

    // Lookup miss
    assert(tlb_lookup(tlb, 0x2000, &pfn) == false);

    tlb_destroy(tlb);
    printf("test_tlb: PASS\n");
}
```

## Indications
- Pour le calcul de l'index/tag: `index = (addr / line_size) % num_sets`, `tag = addr / (line_size * num_sets)`
- Utiliser un compteur global pour `last_access` dans LRU
- Pour MESI, se concentrer sur les transitions de base (read hit, read miss, write hit, write miss)

## Note qualite: 96/100
- Multi-concepts: 6 concepts couverts
- Progressif: Du simple (direct-mapped) au complexe (MESI)
- Testable: API claire, tests automatisables
- Original: Combinaison TLB + Cache + MESI rare dans les exercices classiques
