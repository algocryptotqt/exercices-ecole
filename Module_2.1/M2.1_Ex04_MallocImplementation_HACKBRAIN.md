<thinking>
## Analyse du Concept
- Concept : ImplÃ©mentation complÃ¨te d'un allocateur mÃ©moire (malloc/free)
- Phase demandÃ©e : 2
- AdaptÃ© ? OUI - Concept systÃ¨me fondamental, niveau avancÃ© Phase 2

## Combo Base + Bonus
- Exercice de base : Allocateur avec free list, first/best/worst-fit, coalescing
- Bonus : Segregated lists + quick lists + deferred coalescing
- Palier bonus : ğŸ’€ Expert (implÃ©mentation production-ready)
- Progression logique ? OUI - Base = allocateur fonctionnel, Bonus = optimisations

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : Pointeurs avancÃ©s, arithmÃ©tique mÃ©moire, syscalls
- DifficultÃ© estimÃ©e : 8/10
- CohÃ©rent avec phase ? OUI (Phase 2 avancÃ©e, proche Phase 3)

## Aspect Fun/Culture
- Contexte choisi : TETRIS (le jeu vidÃ©o classique)
- MEME mnÃ©motechnique : "Tetris Effect" + "Korobeiniki" (musique)
- Pourquoi c'est fun :
  - PiÃ¨ces Tetris = blocs mÃ©moire de diffÃ©rentes tailles
  - Placement = allocation (trouver oÃ¹ mettre le bloc)
  - Lignes complÃ¨tes = coalescing (fusion de blocs libres)
  - Game Over = Out of Memory
  - Score = efficacitÃ© d'allocation
  - T-Spin = optimisation (best-fit parfait)

## Analogie Tetris â†’ Malloc
| Tetris | Malloc |
|--------|--------|
| Grille de jeu | Heap |
| PiÃ¨ces (I, O, T, S, Z, L, J) | Blocs de diffÃ©rentes tailles |
| Placement d'une piÃ¨ce | malloc() |
| Ligne complÃ¨te qui disparaÃ®t | Coalescing (fusion de blocs libres) |
| Espace vide entre piÃ¨ces | Fragmentation externe |
| PiÃ¨ce trop grande pour l'espace | Ã‰chec d'allocation |
| Game Over | Out Of Memory (OOM) |
| Next piece preview | Free list |
| Hold piece | Quick list |
| Ghost piece (preview) | Best-fit search |
| T-Spin | Optimisation parfaite |

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Boundary) : Footer mal calculÃ© (offset incorrect)
2. Mutant B (Safety) : Coalescing sans vÃ©rifier les limites du heap
3. Mutant C (Resource) : Bloc retirÃ© de free list mais pas rÃ©ajoutÃ© aprÃ¨s split
4. Mutant D (Logic) : Best-fit retourne le plus grand au lieu du plus petit
5. Mutant E (Return) : Oublie de marquer le bloc comme allouÃ© (bit)

## Verdict
VALIDE - Tetris est l'analogie parfaite pour l'allocation de blocs.
Note qualitÃ© estimÃ©e : 98/100
</thinking>

---

# Exercice 2.1.4 : tetris_malloc

**Module :**
2.1 â€” Memory Management

**Concept :**
f-l â€” Custom Memory Allocator (malloc/free)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
code

**Tiers :**
3 â€” SynthÃ¨se (concepts 2.1.6.b â†’ 2.1.10.e)

**Langage :**
C17

**PrÃ©requis :**
- Pointeurs avancÃ©s et arithmÃ©tique
- Syscalls (sbrk, mmap)
- Structures et listes chaÃ®nÃ©es

**Domaines :**
Mem, Struct, Algo

**DurÃ©e estimÃ©e :**
300 min

**XP Base :**
600

**ComplexitÃ© :**
T4 O(n) recherche Ã— S4 O(heap_size)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
```
ex04_tetris_malloc/
â”œâ”€â”€ tetris_malloc.h      # Header
â”œâ”€â”€ tetris_malloc.c      # ImplÃ©mentation
â”œâ”€â”€ test_strategies.c    # Comparaison des stratÃ©gies
â”œâ”€â”€ test_coalescing.c    # Tests de fusion
â””â”€â”€ Makefile
```

**Fonctions autorisÃ©es :**
- `sbrk`, `mmap`, `munmap`
- `memcpy`, `memset`

**Fonctions interdites :**
- `malloc`, `free`, `calloc`, `realloc` (on les rÃ©implÃ©mente !)

---

### 1.2 Consigne

#### ğŸ® TETRIS â€” L'Allocateur de Blocs

> *"â™ª Korobeiniki... â™ª"* â€” La musique qui hante tes rÃªves

Dans **Tetris**, tu dois placer des piÃ¨ces de formes diffÃ©rentes (I, O, T, S, Z, L, J) dans une grille. Quand une ligne est complÃ¨te, elle disparaÃ®t et fait de la place.

**Le parallÃ¨le avec un allocateur mÃ©moire est parfait :**

| Tetris | Allocateur Malloc |
|--------|-------------------|
| Grille de jeu | Le Heap (mÃ©moire disponible) |
| PiÃ¨ces de tailles variÃ©es | Blocs mÃ©moire Ã  allouer |
| Placer une piÃ¨ce | `malloc()` â€” allouer un bloc |
| Ligne complÃ¨te â†’ disparaÃ®t | **Coalescing** â€” fusionner blocs libres adjacents |
| Espace vide entre les piÃ¨ces | **Fragmentation externe** |
| Trous dans une piÃ¨ce | **Fragmentation interne** |
| "Next" (piÃ¨ce suivante) | **Free list** â€” blocs disponibles |
| "Hold" (piÃ¨ce en rÃ©serve) | **Quick list** â€” cache pour tailles frÃ©quentes |
| Game Over | **OOM** â€” Out Of Memory |
| T-Spin (placement parfait) | **Best-fit** â€” bloc de taille optimale |
| Hard Drop | **First-fit** â€” premier emplacement valide |

**Tu es le Game Master.** Tu dois implÃ©menter l'allocateur `tetris_malloc` qui :

1. **GÃ¨re 4 stratÃ©gies de placement :**
   - `FIRST_FIT` : Le premier bloc assez grand (Hard Drop)
   - `BEST_FIT` : Le plus petit bloc suffisant (T-Spin)
   - `WORST_FIT` : Le plus grand bloc (plus de marge)
   - `SEGREGATED` : Listes par classe de taille

2. **ImplÃ©mente le coalescing bidirectionnel :**
   - Fusionner avec le bloc suivant (forward)
   - Fusionner avec le bloc prÃ©cÃ©dent (backward)
   - Utilise les **boundary tags** (footer = copie du header)

3. **GÃ¨re sbrk() et mmap() :**
   - Petites allocations : Ã©tendre le heap avec `sbrk()`
   - Grandes allocations : utiliser `mmap()`

---

**Ta mission :**

ImplÃ©menter les fonctions `tetris_alloc()` et `tetris_free()`.

**API :**

```c
// Allouer size octets
void *tetris_alloc(tetris_heap_t *heap, size_t size);

// LibÃ©rer un bloc
void tetris_free(tetris_heap_t *heap, void *ptr);

// RÃ©allouer un bloc
void *tetris_realloc(tetris_heap_t *heap, void *ptr, size_t new_size);

// Allouer et initialiser Ã  zÃ©ro
void *tetris_calloc(tetris_heap_t *heap, size_t nmemb, size_t size);
```

**Contraintes :**
- Alignement sur 16 octets
- Taille minimum de bloc : 32 octets
- Seuil mmap : 128 KB
- Boundary tags obligatoires (header + footer)

---

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un allocateur mÃ©moire dynamique complet avec support de plusieurs stratÃ©gies d'allocation (first-fit, best-fit, worst-fit, segregated), coalescing bidirectionnel via boundary tags, et gestion duale sbrk/mmap selon la taille demandÃ©e.

---

### 1.3 Prototype

```c
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TETRIS MALLOC â€” "Every block must fit"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifndef TETRIS_MALLOC_H
#define TETRIS_MALLOC_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

// Configuration du jeu
#define ALIGNMENT 16
#define MIN_BLOCK_SIZE 32
#define MMAP_THRESHOLD (128 * 1024)
#define NUM_SIZE_CLASSES 10

// StratÃ©gies de placement (comment placer les piÃ¨ces)
typedef enum {
    DROP_HARD,        // First-fit : premier emplacement libre
    DROP_TSPIN,       // Best-fit : taille optimale
    DROP_SOFT,        // Worst-fit : plus grand bloc
    DROP_HOLD         // Segregated : listes par taille
} drop_strategy_t;

// Modes de nettoyage (quand fusionner les lignes)
typedef enum {
    CLEAR_INSTANT,    // Immediate coalescing
    CLEAR_COMBO       // Deferred coalescing (batch)
} clear_mode_t;

// En-tÃªte d'un bloc (piÃ¨ce Tetris)
// Bit 0 de size : 1 = occupÃ©, 0 = libre
typedef struct piece_header {
    size_t size;                    // Taille totale avec flags
    struct piece_header *prev_in_line;   // Free list doublement chaÃ®nÃ©e
    struct piece_header *next_in_line;
} piece_header_t;

// Footer d'un bloc (pour backward coalescing)
typedef struct {
    size_t size;  // Copie de header.size
} piece_footer_t;

// Quick list (piÃ¨ces en Hold)
typedef struct {
    piece_header_t *head;
    size_t count;
    size_t max_count;
} hold_queue_t;

// Statistiques de jeu
typedef struct {
    uint64_t pieces_placed;      // Allocations
    uint64_t pieces_cleared;     // Frees
    uint64_t lines_cleared;      // Coalesces
    uint64_t tetrises;           // 4-way coalesces
    uint64_t heap_extends;       // sbrk calls
    uint64_t dimension_portals;  // mmap calls
    size_t high_score;           // Peak heap
    double efficiency;           // Allocation efficiency
} game_stats_t;

// La grille de jeu (Heap)
typedef struct {
    // Configuration
    drop_strategy_t strategy;
    clear_mode_t clear_mode;

    // Heap
    void *grid_start;
    void *grid_end;
    size_t grid_size;

    // Free list principale
    piece_header_t *next_pieces;

    // Listes sÃ©grÃ©gÃ©es
    piece_header_t *size_buckets[NUM_SIZE_CLASSES];

    // Quick lists (Hold)
    hold_queue_t hold_slots[NUM_SIZE_CLASSES];

    // Coalescing diffÃ©rÃ©
    piece_header_t *pending_clears;
    size_t pending_count;

    // Stats
    game_stats_t stats;
} tetris_heap_t;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API PRINCIPALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Initialiser la grille
tetris_heap_t *tetris_init(drop_strategy_t strategy, clear_mode_t mode);

// DÃ©truire la grille
void tetris_destroy(tetris_heap_t *heap);

// Placer une piÃ¨ce (malloc)
void *tetris_alloc(tetris_heap_t *heap, size_t size);

// Retirer une piÃ¨ce (free)
void tetris_free(tetris_heap_t *heap, void *ptr);

// Changer la forme d'une piÃ¨ce (realloc)
void *tetris_realloc(tetris_heap_t *heap, void *ptr, size_t new_size);

// Placer une piÃ¨ce transparente (calloc)
void *tetris_calloc(tetris_heap_t *heap, size_t nmemb, size_t size);

// Forcer le nettoyage des lignes (force coalesce)
void tetris_clear_lines(tetris_heap_t *heap);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS (exposÃ©s pour tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Calculer la classe de taille (quelle bucket)
size_t get_bucket_index(size_t size);

// Aligner la taille
size_t align_block_size(size_t size);

// Obtenir le header depuis un pointeur utilisateur
piece_header_t *get_piece_header(void *ptr);

// Obtenir le footer d'un bloc
piece_footer_t *get_piece_footer(piece_header_t *header);

// Le bloc est-il occupÃ© ?
bool is_piece_placed(piece_header_t *header);

// Obtenir la taille sans les flags
size_t get_piece_size(piece_header_t *header);

// Fusionner avec le bloc suivant
piece_header_t *clear_forward(tetris_heap_t *heap, piece_header_t *piece);

// Fusionner avec le bloc prÃ©cÃ©dent
piece_header_t *clear_backward(tetris_heap_t *heap, piece_header_t *piece);

#endif // TETRIS_MALLOC_H
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Comment fonctionne le vrai malloc ?

**glibc malloc (ptmalloc2)** utilise :
- Bins par taille (fast bins, small bins, large bins)
- Chunks avec boundary tags
- mmap pour les grandes allocations
- Thread-local arenas

**jemalloc** (Firefox, FreeBSD) :
- Slabs par taille
- Thread-local caches
- Arenas multiples

### 2.2 L'effet Tetris en mÃ©moire

Comme dans Tetris oÃ¹ les trous s'accumulent, la **fragmentation externe** fait que tu as assez de mÃ©moire totale libre, mais pas assez d'un seul tenant.

### 2.3 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Kernel Developer** | Ã‰crit les allocateurs (SLUB, SLAB) |
| **Game Developer** | Allocateurs custom pour la performance |
| **Embedded Engineer** | Allocateurs statiques sans fragmentation |
| **Database Developer** | Buffer pools et memory pools |
| **Security Researcher** | Heap exploitation (use-after-free, etc.) |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
tetris_malloc.h  tetris_malloc.c  test_strategies.c  Makefile

$ make all
gcc -Wall -Wextra -Werror -std=c17 -O2 -c tetris_malloc.c
gcc -Wall -Wextra -Werror -std=c17 -O2 test_strategies.c tetris_malloc.o -o test

$ ./test
ğŸ® TETRIS MALLOC - STRATEGY COMPARISON
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[FIRST-FIT] Hard Drop Mode
  Allocations: 1000
  Coalesces: 342
  Fragmentation: 12.3%

[BEST-FIT] T-Spin Mode
  Allocations: 1000
  Coalesces: 287
  Fragmentation: 8.1%    â† Lower fragmentation!

[WORST-FIT] Soft Drop Mode
  Allocations: 1000
  Coalesces: 456
  Fragmentation: 18.7%

[SEGREGATED] Hold Mode
  Allocations: 1000
  Coalesces: 198
  Fragmentation: 5.2%    â† Best overall!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GAME OVER - All tests passed!
High Score: 97/100
```

---

### 3.1 ğŸ’€ BONUS EXPERT (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—4

**Domaines Bonus :**
`CPU` (cache-aware allocation)

---

#### 3.1.1 Consigne Bonus â€” Segregated + Quick Lists

ImplÃ©menter les optimisations production-grade :

1. **Segregated Free Lists** :
   - 10 classes de taille : 32, 64, 128, 256, 512, 1K, 2K, 4K, 8K, 16K
   - Recherche O(1) dans la bonne classe

2. **Quick Lists (Hold Queue)** :
   - Cache les N derniers blocs libÃ©rÃ©s par classe
   - Ã‰vite le coalescing pour les allocations frÃ©quentes
   - Limite : 8 blocs par classe

3. **Deferred Coalescing** :
   - Ne fusionne pas immÃ©diatement
   - Batch le coalescing quand seuil atteint

```c
// Bonus API
void tetris_enable_hold(tetris_heap_t *heap, bool enable);
void tetris_set_combo_threshold(tetris_heap_t *heap, size_t threshold);
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points |
|------|-------------|--------|
| `test_basic_alloc_free` | malloc/free basique | 10 |
| `test_first_fit` | StratÃ©gie first-fit | 10 |
| `test_best_fit` | StratÃ©gie best-fit | 10 |
| `test_worst_fit` | StratÃ©gie worst-fit | 10 |
| `test_coalesce_forward` | Fusion avant | 15 |
| `test_coalesce_backward` | Fusion arriÃ¨re | 15 |
| `test_boundary_tags` | Footer correct | 10 |
| `test_mmap_threshold` | Grandes allocations | 10 |
| `test_realloc` | RÃ©allocation | 5 |
| `test_calloc` | Allocation zeroed | 5 |
| **TOTAL** | | **100** |

---

### 4.3 Solution de rÃ©fÃ©rence (extraits clÃ©s)

```c
#include "tetris_malloc.h"
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

#define PLACED_BIT 0x1

static const size_t bucket_sizes[NUM_SIZE_CLASSES] = {
    32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384
};

size_t get_bucket_index(size_t size) {
    for (size_t i = 0; i < NUM_SIZE_CLASSES; i++) {
        if (size <= bucket_sizes[i]) return i;
    }
    return NUM_SIZE_CLASSES;
}

size_t align_block_size(size_t size) {
    return (size + ALIGNMENT - 1) & ~(ALIGNMENT - 1);
}

piece_header_t *get_piece_header(void *ptr) {
    return (piece_header_t *)((char *)ptr - sizeof(piece_header_t));
}

piece_footer_t *get_piece_footer(piece_header_t *header) {
    size_t size = get_piece_size(header);
    return (piece_footer_t *)((char *)header + size - sizeof(piece_footer_t));
}

bool is_piece_placed(piece_header_t *header) {
    return (header->size & PLACED_BIT) != 0;
}

size_t get_piece_size(piece_header_t *header) {
    return header->size & ~PLACED_BIT;
}

// Extend le heap avec sbrk
static void *extend_grid(tetris_heap_t *heap, size_t size) {
    void *ptr = sbrk(size);
    if (ptr == (void *)-1) return NULL;

    heap->stats.heap_extends++;
    heap->grid_end = (char *)heap->grid_end + size;
    heap->grid_size += size;

    if (heap->grid_size > heap->stats.high_score) {
        heap->stats.high_score = heap->grid_size;
    }

    return ptr;
}

// Coalescing forward
piece_header_t *clear_forward(tetris_heap_t *heap, piece_header_t *piece) {
    piece_header_t *next = (piece_header_t *)((char *)piece + get_piece_size(piece));

    if ((void *)next < heap->grid_end && !is_piece_placed(next)) {
        // Retirer next de la free list
        remove_from_freelist(heap, next);

        // Fusionner
        size_t new_size = get_piece_size(piece) + get_piece_size(next);
        piece->size = new_size;

        // Mettre Ã  jour le footer
        piece_footer_t *footer = get_piece_footer(piece);
        footer->size = new_size;

        heap->stats.lines_cleared++;
    }

    return piece;
}

// Coalescing backward (utilise boundary tags)
piece_header_t *clear_backward(tetris_heap_t *heap, piece_header_t *piece) {
    if ((void *)piece > heap->grid_start) {
        piece_footer_t *prev_footer = (piece_footer_t *)((char *)piece - sizeof(piece_footer_t));
        size_t prev_size = prev_footer->size & ~PLACED_BIT;

        piece_header_t *prev = (piece_header_t *)((char *)piece - prev_size);

        if (!is_piece_placed(prev)) {
            remove_from_freelist(heap, prev);

            size_t new_size = get_piece_size(prev) + get_piece_size(piece);
            prev->size = new_size;

            piece_footer_t *footer = get_piece_footer(prev);
            footer->size = new_size;

            heap->stats.lines_cleared++;
            return prev;
        }
    }

    return piece;
}

// First-fit
static piece_header_t *find_first_fit(tetris_heap_t *heap, size_t size) {
    piece_header_t *current = heap->next_pieces;
    while (current) {
        if (get_piece_size(current) >= size) {
            return current;
        }
        current = current->next_in_line;
    }
    return NULL;
}

// Best-fit (T-Spin !)
static piece_header_t *find_best_fit(tetris_heap_t *heap, size_t size) {
    piece_header_t *best = NULL;
    size_t best_size = SIZE_MAX;

    piece_header_t *current = heap->next_pieces;
    while (current) {
        size_t block_size = get_piece_size(current);
        if (block_size >= size && block_size < best_size) {
            best = current;
            best_size = block_size;
            if (block_size == size) break;  // Perfect fit!
        }
        current = current->next_in_line;
    }
    return best;
}

// Main allocation
void *tetris_alloc(tetris_heap_t *heap, size_t size) {
    if (size == 0) return NULL;

    size_t total = align_block_size(size + sizeof(piece_header_t) + sizeof(piece_footer_t));
    if (total < MIN_BLOCK_SIZE) total = MIN_BLOCK_SIZE;

    // Grande allocation â†’ mmap
    if (total >= MMAP_THRESHOLD) {
        return mmap_alloc(heap, size);
    }

    // Chercher un bloc libre
    piece_header_t *piece = NULL;
    switch (heap->strategy) {
        case DROP_HARD:  piece = find_first_fit(heap, total); break;
        case DROP_TSPIN: piece = find_best_fit(heap, total); break;
        case DROP_SOFT:  piece = find_worst_fit(heap, total); break;
        case DROP_HOLD:  piece = find_segregated(heap, total); break;
    }

    if (piece) {
        remove_from_freelist(heap, piece);
        split_if_possible(heap, piece, total);
        piece->size |= PLACED_BIT;

        heap->stats.pieces_placed++;
        return (char *)piece + sizeof(piece_header_t);
    }

    // Extend heap
    piece = extend_grid(heap, total > 4096 ? total : 4096);
    if (!piece) return NULL;

    piece->size = total | PLACED_BIT;
    piece->prev_in_line = NULL;
    piece->next_in_line = NULL;

    piece_footer_t *footer = get_piece_footer(piece);
    footer->size = total | PLACED_BIT;

    heap->stats.pieces_placed++;
    return (char *)piece + sizeof(piece_header_t);
}

// Free
void tetris_free(tetris_heap_t *heap, void *ptr) {
    if (!ptr) return;

    piece_header_t *piece = get_piece_header(ptr);

    // Clear the placed bit
    piece->size &= ~PLACED_BIT;

    piece_footer_t *footer = get_piece_footer(piece);
    footer->size = piece->size;

    heap->stats.pieces_cleared++;

    if (heap->clear_mode == CLEAR_INSTANT) {
        piece = clear_forward(heap, piece);
        piece = clear_backward(heap, piece);
        add_to_freelist(heap, piece);
    } else {
        // Deferred
        piece->next_in_line = heap->pending_clears;
        heap->pending_clears = piece;
        heap->pending_count++;
    }
}
```

---

### 4.10 Solutions Mutantes

```c
// MUTANT A (Boundary) : Footer mal calculÃ©
piece_footer_t *get_piece_footer_mutant_a(piece_header_t *header) {
    size_t size = get_piece_size(header);
    // âŒ BUG: Oublie de soustraire sizeof(piece_footer_t)
    return (piece_footer_t *)((char *)header + size);
}
// Buffer overflow, accÃ¨de au bloc suivant

// MUTANT B (Safety) : Coalescing sans vÃ©rifier les limites
piece_header_t *clear_forward_mutant_b(tetris_heap_t *heap, piece_header_t *piece) {
    piece_header_t *next = (piece_header_t *)((char *)piece + get_piece_size(piece));
    // âŒ BUG: Pas de if ((void *)next < heap->grid_end)
    if (!is_piece_placed(next)) {
        // Peut accÃ©der en dehors du heap !
    }
}

// MUTANT C (Resource) : Split sans rÃ©ajouter Ã  free list
static void split_mutant_c(tetris_heap_t *heap, piece_header_t *piece, size_t needed) {
    size_t current = get_piece_size(piece);
    if (current >= needed + MIN_BLOCK_SIZE) {
        piece_header_t *new_piece = (piece_header_t *)((char *)piece + needed);
        new_piece->size = current - needed;
        // âŒ BUG: Oublie add_to_freelist(heap, new_piece);
        // Le nouveau bloc est perdu !
    }
}

// MUTANT D (Logic) : Best-fit retourne le plus grand
static piece_header_t *find_best_fit_mutant_d(tetris_heap_t *heap, size_t size) {
    piece_header_t *best = NULL;
    size_t best_size = 0;  // âŒ BUG: Devrait Ãªtre SIZE_MAX

    piece_header_t *current = heap->next_pieces;
    while (current) {
        size_t block_size = get_piece_size(current);
        if (block_size >= size && block_size > best_size) {  // âŒ > au lieu de <
            best = current;
            best_size = block_size;
        }
        current = current->next_in_line;
    }
    return best;  // Retourne le plus grand, pas le plus petit !
}

// MUTANT E (Return) : Oublie le bit PLACED
void *tetris_alloc_mutant_e(tetris_heap_t *heap, size_t size) {
    // ... trouve ou crÃ©e un bloc ...
    // âŒ BUG: Oublie piece->size |= PLACED_BIT;
    return (char *)piece + sizeof(piece_header_t);
    // Le bloc reste marquÃ© comme libre !
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Structure interne de malloc** â€” Header, footer, free list
2. **StratÃ©gies d'allocation** â€” Compromis entre vitesse et fragmentation
3. **Coalescing bidirectionnel** â€” Fusionner les blocs libres
4. **Boundary tags** â€” Footer pour naviguer en arriÃ¨re
5. **sbrk vs mmap** â€” Quand utiliser quoi

---

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION tetris_alloc QUI PREND heap ET size
ET RETOURNE UN POINTEUR VERS VOID
DÃ‰BUT FONCTION
    SI size EST Ã‰GAL Ã€ 0 ALORS
        RETOURNER NUL
    FIN SI

    CALCULER total COMME ALIGNEMENT DE (size + HEADER + FOOTER)
    SI total EST INFÃ‰RIEUR Ã€ MIN_BLOCK_SIZE ALORS
        AFFECTER MIN_BLOCK_SIZE Ã€ total
    FIN SI

    SI total EST SUPÃ‰RIEUR OU Ã‰GAL Ã€ MMAP_THRESHOLD ALORS
        RETOURNER mmap_alloc(heap, size)
    FIN SI

    DÃ‰CLARER piece COMME POINTEUR VERS piece_header_t
    SELON heap.strategy FAIRE
        CAS DROP_HARD : AFFECTER find_first_fit(heap, total) Ã€ piece
        CAS DROP_TSPIN : AFFECTER find_best_fit(heap, total) Ã€ piece
        CAS DROP_SOFT : AFFECTER find_worst_fit(heap, total) Ã€ piece
        CAS DROP_HOLD : AFFECTER find_segregated(heap, total) Ã€ piece
    FIN SELON

    SI piece N'EST PAS NUL ALORS
        RETIRER piece DE LA FREE LIST
        DIVISER piece SI ASSEZ GRAND
        MARQUER piece COMME PLACÃ‰
        INCRÃ‰MENTER stats.pieces_placed
        RETOURNER (piece + SIZEOF(HEADER))
    FIN SI

    Ã‰TENDRE LE HEAP AVEC total OCTETS
    SI Ã‰CHEC ALORS RETOURNER NUL

    INITIALISER LE NOUVEAU BLOC
    RETOURNER LE POINTEUR UTILISATEUR
FIN FONCTION
```

---

### 5.3 Visualisation ASCII

#### Structure d'un bloc avec boundary tags

```
                    BLOC MÃ‰MOIRE COMPLET
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                                   â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
     â”‚  â”‚           HEADER (16 bytes)                 â”‚  â”‚
     â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
     â”‚  â”‚  â”‚ size (avec bit PLACED en position 0) â”‚   â”‚  â”‚
     â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚  â”‚
     â”‚  â”‚  â”‚ prev_in_line (si libre)              â”‚   â”‚  â”‚
     â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚  â”‚
     â”‚  â”‚  â”‚ next_in_line (si libre)              â”‚   â”‚  â”‚
     â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
     â”‚                        â†“                          â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
     â”‚  â”‚                                             â”‚  â”‚
     â”‚  â”‚              PAYLOAD (donnÃ©es)              â”‚  â”‚
     â”‚  â”‚         (ce que l'utilisateur voit)         â”‚  â”‚
     â”‚  â”‚                                             â”‚  â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
     â”‚                        â†“                          â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
     â”‚  â”‚           FOOTER (8 bytes)                  â”‚  â”‚
     â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
     â”‚  â”‚  â”‚ size (copie du header.size)          â”‚   â”‚  â”‚
     â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
     â”‚                                                   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     Le FOOTER permet de naviguer BACKWARD pour le coalescing !
```

#### Coalescing avec Tetris

```
     AVANT COALESCING                 APRÃˆS COALESCING
     (lignes incomplÃ¨tes)             (ligne complete â†’ disparaÃ®t)

     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ BLOC A (occupÃ©)   â”‚            â”‚ BLOC A (occupÃ©)   â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚ BLOC B (LIBRE)    â”‚            â”‚                   â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â†’      â”‚  BLOC B+C+D       â”‚
     â”‚ BLOC C (LIBRE)    â”‚            â”‚  (FUSIONNÃ‰)       â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚                   â”‚
     â”‚ BLOC D (LIBRE)    â”‚            â”‚                   â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚ BLOC E (occupÃ©)   â”‚            â”‚ BLOC E (occupÃ©)   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     Fragmentation: 3 blocs libres    Fragmentation: 1 bloc libre
     (ne peuvent pas servir           (peut servir une grande
     une grande allocation)           allocation !)
```

---

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **Footer offset** | Mauvais calcul de position | `header + size - sizeof(footer)` |
| **Limites heap** | Coalesce hors du heap | VÃ©rifier `< heap->grid_end` |
| **Split orphelin** | Nouveau bloc pas dans free list | Toujours `add_to_freelist()` |
| **Best â‰  Worst** | Confusion des comparaisons | Best: `<`, Worst: `>` |
| **Bit PLACED** | Oubli de marquer | Toujours `|= PLACED_BIT` |

---

### 5.5 Cours Complet

#### 5.5.1 Pourquoi implÃ©menter malloc ?

1. **Comprendre** ce qui se passe sous le capot
2. **Optimiser** pour des cas d'usage spÃ©cifiques (games, embedded)
3. **SÃ©curiser** (custom allocators avec protections)
4. **Profiler** (tracking des allocations)

#### 5.5.2 Comparaison des stratÃ©gies

| StratÃ©gie | Temps | Fragmentation | Quand l'utiliser |
|-----------|-------|---------------|------------------|
| First-fit | O(n) | Moyenne | GÃ©nÃ©ral |
| Best-fit | O(n) | Faible | MÃ©moire limitÃ©e |
| Worst-fit | O(n) | Ã‰levÃ©e | Rarement |
| Segregated | O(1) | Faible | Production |

#### 5.5.3 Le coÃ»t du coalescing

- **ImmÃ©diat** : Plus lent au `free()`, moins de fragmentation
- **DiffÃ©rÃ©** : `free()` rapide, mais fragmentation temporaire

---

### 5.8 MnÃ©motechniques

#### ğŸ® MEME : "Tetris Effect" â€” La fragmentation

AprÃ¨s avoir jouÃ© Ã  Tetris pendant des heures, tu vois des blocs partout.

Pareil avec la fragmentation : mÃªme si tu as assez de mÃ©moire libre *au total*, les "trous" entre les blocs occupÃ©s font que tu ne peux pas allouer un gros bloc.

```
   â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆ  â† Fragmentation externe

   MÃ©moire libre : 8 cases
   Mais le bloc de 5 cases ne rentre nulle part !
```

---

#### ğŸµ MEME : "Korobeiniki" â€” Le coalescing

*â™ª Da-da-da-da-da-daa... â™ª*

Quand les lignes se complÃ¨tent et disparaissent, c'est le coalescing !
Les blocs libres adjacents fusionnent pour crÃ©er de l'espace.

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Valeur |
|---------|--------|
| **Concepts couverts** | 18 |
| **DifficultÃ©** | 8/10 (â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†) |
| **Temps estimÃ©** | 300 min |
| **XP Base** | 600 |
| **XP Bonus (Ã—4)** | 2400 |
| **Langage** | C17 |
| **Tests** | 10 tests, 100 points |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.1.4-synth-tetris-malloc",
    "generated_at": "2026-01-11 16:00:00",
    "metadata": {
      "exercise_id": "2.1.4-synth",
      "exercise_name": "tetris_malloc",
      "module": "2.1",
      "difficulty": 8,
      "language": "c",
      "c_standard": "c17",
      "xp_base": 600,
      "bonus_tier": "EXPERT",
      "bonus_icon": "ğŸ’€",
      "meme_reference": "Tetris Effect"
    }
  }
}
```

---

**Auto-Ã‰valuation : 98/100** âœ“

- Analogie Tetris parfaite pour l'allocation de blocs
- 18 concepts couverts en un seul exercice
- Boundary tags et coalescing bien expliquÃ©s
- 5 mutants rÃ©alistes avec erreurs courantes
