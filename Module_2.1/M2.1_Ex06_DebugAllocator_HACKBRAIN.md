<thinking>
## Analyse du Concept
- Concept : Debug Memory Allocator avec dÃ©tection d'erreurs
- Phase demandÃ©e : 2
- AdaptÃ© ? OUI - Concepts intermÃ©diaires de sÃ©curitÃ© mÃ©moire, parfait pour Phase 2

## Combo Base + Bonus
- Exercice de base : ImplÃ©menter allocateur debug avec canaries, red zones, poison, dÃ©tection leaks
- Bonus : Valgrind complet avec heaptrack-style profiling et shadow memory
- Palier bonus : ğŸ”¥ AvancÃ© (difficile 7/10)
- Progression logique ? OUI - Base = dÃ©tection d'erreurs, Bonus = profiling avancÃ©

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : C17, pointeurs, malloc/free, structures de donnÃ©es
- DifficultÃ© estimÃ©e : 6/10 base, 7/10 bonus
- CohÃ©rent avec phase ? OUI (Phase 2 = 4-6/10)

## Aspect Fun/Culture
- Contexte choisi : Sherlock Holmes - Detective Agency
- MEME mnÃ©motechnique : "Elementary, my dear Watson" pour la dÃ©tection d'erreurs
- Pourquoi c'est fun :
  - Sherlock dÃ©tecte les indices (canaries corrompus)
  - Crime scene tape = Red zones (DO NOT CROSS)
  - Poison = DEADBEEF pattern (le poison de Moriarty)
  - Double murder attempt = Double-free
  - Cold cases = Memory leaks non rÃ©solus
  - Evidence trail = Stack traces
  - Definitely lost / Possibly lost = Types d'affaires froides

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Boundary) : Canary vÃ©rifiÃ© au mauvais offset
2. Mutant B (Safety) : Red zone pas initialisÃ©e avec le bon pattern
3. Mutant C (Resource) : Allocation info pas ajoutÃ©e Ã  la hash table
4. Mutant D (Logic) : Double-free pas dÃ©tectÃ© (pas de quarantine check)
5. Mutant E (Return) : Leak report retourne 0 mÃªme avec des leaks

## Verdict
VALIDE - Analogie Sherlock Holmes parfaite pour debug/dÃ©tection mÃ©moire
Note qualitÃ© estimÃ©e : 97/100
</thinking>

---

# Exercice 2.1.6 : sherlock_allocator

**Module :**
2.1 â€” Memory Management

**Concept :**
f â€” Debug Memory Allocator

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10)

**Type :**
complet

**Tiers :**
2 â€” MÃ©lange (concepts canaries + poison + leak detection)

**Langage :**
C (C17)

**PrÃ©requis :**
- Pointeurs et arithmÃ©tique de pointeurs
- malloc/free et gestion mÃ©moire
- Structures de donnÃ©es (hash table, liste chaÃ®nÃ©e)
- Patterns de bits et valeurs magiques

**Domaines :**
Mem, Struct, CPU

**DurÃ©e estimÃ©e :**
180 min

**XP Base :**
450

**ComplexitÃ© :**
T2 O(1) amortized Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
```
â”œâ”€â”€ sherlock_allocator.h   # Header avec types et API
â”œâ”€â”€ sherlock_allocator.c   # ImplÃ©mentation complÃ¨te
â”œâ”€â”€ test_sherlock.c        # Tests des dÃ©tections
â””â”€â”€ demo_valgrind_style.c  # DÃ©mo des rapports
```

**Fonctions autorisÃ©es :**
- `malloc`, `calloc`, `realloc`, `free`
- `memset`, `memcpy`
- `printf`, `fprintf`, `sprintf`
- `time`, `clock`
- `backtrace` (Linux)

**Fonctions interdites :**
- `mmap` direct
- BibliothÃ¨ques de debugging externes (ASan, Valgrind)

---

### 1.2 Consigne

#### 1.2.1 Contexte Culturel â€” Sherlock Holmes : Le DÃ©tective de la MÃ©moire

**ğŸ” "Elementary, my dear Watson!" â€” La MÃ©moire ne ment jamais**

Bienvenue au **221B Baker Street**, le cabinet de dÃ©tective spÃ©cialisÃ© dans les crimes mÃ©moire. Sherlock Holmes et le Dr. Watson enquÃªtent sur les mystÃ¨res les plus sombres de la heap :

**Les indices (Canaries) :**
Sherlock place des "canaris" secrets aux frontiÃ¨res de chaque allocation. Si le canari est mort (corrompu), c'est qu'un crime a Ã©tÃ© commis â€” un **buffer overflow** ! Comme le canari dans les mines de charbon qui mourait en prÃ©sence de gaz toxique.

**Le ruban de scÃ¨ne de crime (Red Zones) :**
Autour de chaque bloc mÃ©moire, Watson installe un pÃ©rimÃ¨tre de sÃ©curitÃ© â€” la **Red Zone**. Si quelqu'un marche sur la scÃ¨ne de crime (Ã©crit dans la red zone), les preuves sont lÃ .

**Le poison de Moriarty (DEADBEEF) :**
Quand un bloc est "libÃ©rÃ©", Sherlock le remplit de **poison** (0xDEADBEEF). Si quelqu'un tente d'utiliser cette mÃ©moire empoisonnÃ©e, c'est un **use-after-free** â€” Moriarty a frappÃ© !

**Le double meurtre (Double-Free) :**
On ne peut pas tuer la mÃªme victime deux fois. Si quelqu'un essaie de libÃ©rer un bloc dÃ©jÃ  libre, c'est un **double-free** â€” suspect !

**Les affaires froides (Memory Leaks) :**
Ã€ la fin de l'enquÃªte, Sherlock examine les dossiers encore ouverts :
- **Definitely Lost** : Aucune trace, aucun suspect, affaire sans issue
- **Indirectly Lost** : Perdus Ã  cause d'un autre cas perdu
- **Possibly Lost** : Il reste peut-Ãªtre un indice intÃ©rieur
- **Still Reachable** : L'affaire aurait pu Ãªtre rÃ©solue, mais reste ouverte

**Ta mission :**

CrÃ©er l'agence **Holmes & Watson Memory Detectives**, un allocateur de debug qui dÃ©tecte automatiquement tous les crimes mÃ©moire et gÃ©nÃ¨re des rapports dignes de Scotland Yard (style Valgrind).

---

#### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un allocateur mÃ©moire de debug qui dÃ©tecte automatiquement :

**1. Buffer Overflow/Underflow :**
- Canaries (valeurs magiques) aux frontiÃ¨res des blocs
- Red zones (zones interdites) avant et aprÃ¨s les donnÃ©es utilisateur

**2. Use-After-Free :**
- Pattern de poison (0xDEADBEEF) Ã©crit aprÃ¨s libÃ©ration
- DÃ©tection si le pattern est lu

**3. Double-Free :**
- Liste de quarantaine des blocs rÃ©cemment libÃ©rÃ©s
- VÃ©rification avant toute libÃ©ration

**4. Memory Leaks :**
- Tracking de toutes les allocations actives
- Rapport de leaks avec stack traces
- Classification style Valgrind (definitely/possibly/still reachable)

**Layout mÃ©moire d'un bloc :**
```
[RED_ZONE_BEFORE][CANARY][USER_DATA][CANARY][RED_ZONE_AFTER]
```

---

### 1.3 Prototype

```c
// sherlock_allocator.h

#ifndef SHERLOCK_ALLOCATOR_H
#define SHERLOCK_ALLOCATOR_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

// ============================================
// VALEURS MAGIQUES â€” Les Indices de Sherlock
// ============================================

#define CANARY_VALUE       0xDEADCAFE   // Le canari vivant
#define FREED_POISON       0xDEADBEEF   // Le poison de Moriarty
#define UNINITIALIZED      0xCDCDCDCD   // MÃ©moire non initialisÃ©e
#define RED_ZONE_FILL      0xFD         // Ruban de scÃ¨ne de crime

#define RED_ZONE_SIZE      16
#define CANARY_SIZE        sizeof(uint32_t)
#define MAX_STACK_FRAMES   32
#define HASH_TABLE_SIZE    4096

// ============================================
// TYPES D'ERREURS â€” Les Crimes MÃ©moire
// ============================================

typedef enum {
    CRIME_NONE = 0,
    CRIME_BUFFER_OVERFLOW,     // Canari aprÃ¨s corrompu
    CRIME_BUFFER_UNDERFLOW,    // Canari avant corrompu
    CRIME_USE_AFTER_FREE,      // AccÃ¨s mÃ©moire empoisonnÃ©e
    CRIME_DOUBLE_FREE,         // Double meurtre
    CRIME_INVALID_FREE,        // Faux suspect (pointeur invalide)
    CRIME_MEMORY_LEAK,         // Affaire froide
    CRIME_MISMATCHED_FREE,     // Mauvaise juridiction (malloc/new mismatch)
} memory_crime_t;

// ============================================
// CATÃ‰GORIES DE LEAKS â€” Types d'Affaires Froides
// ============================================

typedef enum {
    CASE_DEFINITELY_LOST,      // Aucune trace, dÃ©finitivement perdu
    CASE_INDIRECTLY_LOST,      // Perdu via un autre cas perdu
    CASE_POSSIBLY_LOST,        // Indice intÃ©rieur possible
    CASE_STILL_REACHABLE,      // Affaire non fermÃ©e mais accessible
} cold_case_t;

// ============================================
// STRUCTURES â€” Les Dossiers d'EnquÃªte
// ============================================

typedef struct {
    void *address;
    const char *function;
    const char *file;
    int line;
} evidence_frame_t;

typedef struct {
    evidence_frame_t frames[MAX_STACK_FRAMES];
    int num_frames;
} evidence_trail_t;  // Stack trace

typedef struct case_file {
    void *user_ptr;              // Adresse pour l'utilisateur
    void *real_ptr;              // Adresse rÃ©elle (avec overhead)
    size_t user_size;            // Taille demandÃ©e
    size_t real_size;            // Taille avec protections
    evidence_trail_t alloc_trail; // OÃ¹ allouÃ©
    evidence_trail_t free_trail;  // OÃ¹ libÃ©rÃ©
    uint64_t alloc_time;
    uint64_t free_time;
    bool is_closed;              // true si libÃ©rÃ©
    uint32_t case_id;            // ID unique
    struct case_file *next;       // Hash table chain
} case_file_t;

typedef struct {
    uint64_t total_allocations;
    uint64_t total_frees;
    uint64_t current_cases;      // Affaires ouvertes
    uint64_t peak_cases;
    uint64_t total_bytes;
    uint64_t current_bytes;
    uint64_t peak_bytes;

    // Crimes dÃ©tectÃ©s
    uint64_t buffer_overflows;
    uint64_t buffer_underflows;
    uint64_t use_after_frees;
    uint64_t double_frees;
    uint64_t invalid_frees;

    // Affaires froides par catÃ©gorie
    uint64_t definitely_lost_blocks;
    uint64_t definitely_lost_bytes;
    uint64_t possibly_lost_blocks;
    uint64_t possibly_lost_bytes;
    uint64_t still_reachable_blocks;
    uint64_t still_reachable_bytes;
} detective_stats_t;

typedef struct {
    case_file_t *open_cases[HASH_TABLE_SIZE];   // Hash table
    case_file_t *cold_cases;                    // Liste des libÃ©rÃ©s
    size_t cold_cases_max;
    size_t cold_cases_count;

    detective_stats_t stats;

    bool check_on_free;
    bool poison_on_free;
    bool track_evidence;
    bool quarantine_enabled;

    void (*crime_callback)(memory_crime_t, const case_file_t*, const char*);
    uint32_t next_case_id;
} detective_agency_t;

// ============================================
// API PRINCIPALE â€” Holmes & Watson Services
// ============================================

// Ouvrir l'agence de dÃ©tectives
detective_agency_t *holmes_open_agency(void);

// Fermer l'agence et rapport final
void holmes_close_agency(detective_agency_t *agency);

// Allocation avec surveillance
void *holmes_investigate_malloc(detective_agency_t *agency, size_t size,
                                 const char *file, int line);

// Allocation avec initialisation Ã  zÃ©ro
void *holmes_investigate_calloc(detective_agency_t *agency, size_t nmemb, size_t size,
                                 const char *file, int line);

// LibÃ©ration avec vÃ©rification
void holmes_close_case(detective_agency_t *agency, void *ptr,
                        const char *file, int line);

// Macros pour capture automatique de localisation
#define HOLMES_MALLOC(agency, size) \
    holmes_investigate_malloc(agency, size, __FILE__, __LINE__)
#define HOLMES_CALLOC(agency, nmemb, size) \
    holmes_investigate_calloc(agency, nmemb, size, __FILE__, __LINE__)
#define HOLMES_FREE(agency, ptr) \
    holmes_close_case(agency, ptr, __FILE__, __LINE__)

// ============================================
// VÃ‰RIFICATION â€” Examiner les Preuves
// ============================================

// VÃ©rifier l'intÃ©gritÃ© d'un bloc (canaries + red zones)
bool holmes_examine_evidence(detective_agency_t *agency, void *ptr);

// VÃ©rifier tous les blocs actifs
int holmes_examine_all_evidence(detective_agency_t *agency);

// DÃ©tecter les affaires froides (leaks)
int holmes_find_cold_cases(detective_agency_t *agency, case_file_t ***reports);

// ============================================
// RAPPORTS â€” Scotland Yard Style
// ============================================

// Afficher les statistiques
void holmes_print_stats(const detective_agency_t *agency);

// Afficher le rapport de leaks style Valgrind
void holmes_print_leak_summary(detective_agency_t *agency);

// Exporter le profil heap
void holmes_export_case_files(detective_agency_t *agency, const char *filename);

// ============================================
// UTILITAIRES â€” Outils d'Investigation
// ============================================

// VÃ©rifier si le canari est vivant
bool verify_canary_alive(void *real_ptr, size_t offset);

// VÃ©rifier si la scÃ¨ne de crime est intacte
bool verify_crime_scene_intact(void *real_ptr, size_t user_size);

// VÃ©rifier si la mÃ©moire est empoisonnÃ©e
bool is_memory_poisoned(void *ptr, size_t size);

// Hash d'un pointeur
size_t ptr_hash(void *ptr);

#endif // SHERLOCK_ALLOCATOR_H
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Origine du Canari

Le terme "canary" vient des mines de charbon oÃ¹ les mineurs emmenaient des canaris. Les oiseaux Ã©taient plus sensibles aux gaz toxiques â€” si le canari mourait, les mineurs savaient qu'il fallait Ã©vacuer.

En programmation, un canary est une valeur magique placÃ©e aux frontiÃ¨res d'un buffer. Si cette valeur change, c'est qu'un overflow a "tuÃ©" le canari.

### 2.2 Pourquoi 0xDEADBEEF ?

Les valeurs magiques comme `0xDEADBEEF`, `0xCAFEBABE`, `0xDEADCAFE` sont choisies car :
1. Elles sont facilement reconnaissables en hexadÃ©cimal
2. Elles forment des mots lisibles ("dead beef", "cafe babe")
3. Elles sont peu probables comme donnÃ©es lÃ©gitimes
4. Elles apparaissent clairement dans les dumps mÃ©moire

### 2.3 Valgrind et les CatÃ©gories de Leaks

Valgrind classe les memory leaks en 4 catÃ©gories :
- **Definitely lost** : Plus aucun pointeur ne rÃ©fÃ©rence le dÃ©but du bloc
- **Indirectly lost** : Perdu parce qu'un autre bloc (qui le pointait) est perdu
- **Possibly lost** : Un pointeur existe mais pointe vers l'intÃ©rieur du bloc (pas le dÃ©but)
- **Still reachable** : Un pointeur valide existe encore Ã  la fin du programme

---

## 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Systems Developer** | AddressSanitizer (ASan) utilise des red zones similaires |
| **Security Engineer** | Stack canaries protÃ¨gent contre les buffer overflow attacks |
| **QA Engineer** | Valgrind pour dÃ©tecter les memory leaks en CI/CD |
| **Game Developer** | Custom allocators avec debugging pour optimisation |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
sherlock_allocator.c  sherlock_allocator.h  test_sherlock.c

$ gcc -Wall -Wextra -Werror -g sherlock_allocator.c test_sherlock.c -o test -rdynamic

$ ./test
=== HOLMES & WATSON MEMORY DETECTIVES ===

Test buffer overflow...
=== CRIME DETECTED: BUFFER OVERFLOW ===
Address: 0x55a8c8f01080
Canary after corrupted! Expected: 0xDEADCAFE, Found: 0x00000000
Case #1 opened at test_sherlock.c:15

Test double-free...
=== CRIME DETECTED: DOUBLE FREE ===
Address: 0x55a8c8f01200
Case #2 was already closed!

Test memory leaks...
====================
=== LEAK SUMMARY ===
====================
definitely lost: 400 bytes in 2 blocks
indirectly lost: 0 bytes in 0 blocks
  possibly lost: 0 bytes in 0 blocks
still reachable: 0 bytes in 0 blocks

=== ALL TESTS COMPLETED ===
```

---

## ğŸ”¥ SECTION 3.1 : BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(1) pour allocation/libÃ©ration avec shadow memory

**Space Complexity attendue :**
O(n) + overhead de shadow memory

**Domaines Bonus :**
`CPU, Process`

### 3.1.1 Consigne Bonus â€” Le RÃ©seau Mycroft (Shadow Memory)

**ğŸ•µï¸ Mycroft Holmes â€” L'Å’il qui voit tout**

Le frÃ¨re de Sherlock, Mycroft, contrÃ´le un rÃ©seau d'espionnage qui surveille TOUT. ImplÃ©mente la **Shadow Memory**, une technique utilisÃ©e par AddressSanitizer.

Chaque byte de mÃ©moire utilisateur a un byte de "shadow" qui indique son Ã©tat :
- `0x00` : 8 bytes accessibles
- `0x01-0x07` : N bytes accessibles (les autres empoisonnÃ©s)
- `0xFA` : Stack red zone
- `0xFB` : Stack aprÃ¨s return
- `0xFC` : Heap red zone
- `0xFD` : Freed heap
- `0xFE` : Stack use after scope

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Shadow ratio : 1:8 (1 shadow byte      â”‚
â”‚  pour 8 bytes de mÃ©moire)               â”‚
â”‚  Mapping : shadow = (addr >> 3) + offsetâ”‚
â”‚  Overhead maximum : 12.5%               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```c
typedef struct {
    uint8_t *shadow_base;
    size_t shadow_size;
    uintptr_t shadow_offset;
} mycroft_network_t;

// Initialiser le rÃ©seau de shadow memory
mycroft_network_t *mycroft_init_network(size_t heap_size);

// VÃ©rifier un accÃ¨s mÃ©moire via shadow
bool mycroft_check_access(mycroft_network_t *net, void *addr, size_t size);

// Marquer la mÃ©moire comme accessible/empoisonnÃ©e
void mycroft_mark_accessible(mycroft_network_t *net, void *addr, size_t size);
void mycroft_mark_poisoned(mycroft_network_t *net, void *addr, size_t size, uint8_t type);
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points | RÃ©sultat Attendu |
|------|-------------|--------|------------------|
| `test_canary_setup` | Canaries correctement placÃ©s | 10 | Valeur 0xDEADCAFE |
| `test_red_zone_setup` | Red zones remplies | 10 | Pattern 0xFD |
| `test_overflow_detection` | DÃ©tection buffer overflow | 15 | Crime dÃ©tectÃ© |
| `test_underflow_detection` | DÃ©tection buffer underflow | 10 | Crime dÃ©tectÃ© |
| `test_poison_pattern` | MÃ©moire empoisonnÃ©e aprÃ¨s free | 15 | Pattern 0xDEADBEEF |
| `test_double_free` | DÃ©tection double-free | 15 | Crime dÃ©tectÃ© |
| `test_leak_detection` | DÃ©tection des leaks | 15 | Nombre correct |
| `test_no_false_positive` | Pas de faux positifs | 10 | Aucune erreur |

### 4.2 main.c de test

```c
#include "sherlock_allocator.h"
#include <assert.h>
#include <string.h>
#include <stdio.h>

void test_canary_alive(void) {
    detective_agency_t *agency = holmes_open_agency();

    char *ptr = HOLMES_MALLOC(agency, 100);

    // Les canaries doivent Ãªtre intacts
    void *real_ptr = (uint8_t *)ptr - RED_ZONE_SIZE - CANARY_SIZE;
    assert(verify_canary_alive(real_ptr, RED_ZONE_SIZE));

    HOLMES_FREE(agency, ptr);
    holmes_close_agency(agency);
    printf("test_canary_alive: PASS\n");
}

void test_overflow_detection(void) {
    detective_agency_t *agency = holmes_open_agency();

    char *buf = HOLMES_MALLOC(agency, 10);

    // Ã‰crire au-delÃ  du buffer â€” CRIME!
    strcpy(buf, "This string is way too long for the buffer!");

    // Le free devrait dÃ©tecter l'overflow
    HOLMES_FREE(agency, buf);

    assert(agency->stats.buffer_overflows >= 1);
    holmes_close_agency(agency);
    printf("test_overflow_detection: PASS (crime detected)\n");
}

void test_double_free(void) {
    detective_agency_t *agency = holmes_open_agency();

    void *ptr = HOLMES_MALLOC(agency, 100);
    HOLMES_FREE(agency, ptr);

    // Double murder attempt!
    HOLMES_FREE(agency, ptr);

    assert(agency->stats.double_frees == 1);
    holmes_close_agency(agency);
    printf("test_double_free: PASS\n");
}

void test_poison_pattern(void) {
    detective_agency_t *agency = holmes_open_agency();

    uint32_t *ptr = HOLMES_MALLOC(agency, sizeof(uint32_t) * 10);
    ptr[0] = 42;

    HOLMES_FREE(agency, ptr);

    // La mÃ©moire doit Ãªtre empoisonnÃ©e
    assert(is_memory_poisoned(ptr, sizeof(uint32_t) * 10));

    holmes_close_agency(agency);
    printf("test_poison_pattern: PASS (Moriarty's poison detected)\n");
}

void test_leak_detection(void) {
    detective_agency_t *agency = holmes_open_agency();

    // Ouvrir des cas sans les fermer
    void *p1 = HOLMES_MALLOC(agency, 100);
    void *p2 = HOLMES_MALLOC(agency, 200);
    void *p3 = HOLMES_MALLOC(agency, 300);

    // Fermer seulement un cas
    HOLMES_FREE(agency, p2);

    // DÃ©tecter les affaires froides
    case_file_t **reports;
    int num_leaks = holmes_find_cold_cases(agency, &reports);

    assert(num_leaks == 2);  // p1 et p3

    // Rapport style Valgrind
    holmes_print_leak_summary(agency);

    holmes_close_agency(agency);
    printf("test_leak_detection: PASS\n");
}

void test_no_false_positives(void) {
    detective_agency_t *agency = holmes_open_agency();

    // Utilisation correcte â€” pas de crime
    for (int i = 0; i < 100; i++) {
        void *ptr = HOLMES_MALLOC(agency, 128);
        memset(ptr, 0, 128);
        HOLMES_FREE(agency, ptr);
    }

    assert(agency->stats.buffer_overflows == 0);
    assert(agency->stats.buffer_underflows == 0);
    assert(agency->stats.double_frees == 0);
    assert(agency->stats.current_cases == 0);

    holmes_close_agency(agency);
    printf("test_no_false_positives: PASS\n");
}

int main(void) {
    printf("=== HOLMES & WATSON MEMORY DETECTIVES ===\n\n");

    test_canary_alive();
    test_no_false_positives();
    test_overflow_detection();
    test_double_free();
    test_poison_pattern();
    test_leak_detection();

    printf("\n=== THE GAME IS AFOOT! All tests passed! ===\n");
    return 0;
}
```

### 4.3 Solution de rÃ©fÃ©rence

```c
// sherlock_allocator.c â€” Solution complÃ¨te

#include "sherlock_allocator.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#ifdef __linux__
#include <execinfo.h>
#endif

// ============================================
// UTILITAIRES INTERNES
// ============================================

static size_t calculate_real_size(size_t user_size) {
    return RED_ZONE_SIZE +     // Red zone avant
           CANARY_SIZE +       // Canari avant
           user_size +         // DonnÃ©es utilisateur
           CANARY_SIZE +       // Canari aprÃ¨s
           RED_ZONE_SIZE;      // Red zone aprÃ¨s
}

static void *user_ptr_from_real(void *real_ptr) {
    return (uint8_t *)real_ptr + RED_ZONE_SIZE + CANARY_SIZE;
}

static void *real_ptr_from_user(void *user_ptr) {
    return (uint8_t *)user_ptr - RED_ZONE_SIZE - CANARY_SIZE;
}

size_t ptr_hash(void *ptr) {
    return ((uintptr_t)ptr >> 3) % HASH_TABLE_SIZE;
}

static void capture_evidence_trail(evidence_trail_t *trail) {
#ifdef __linux__
    void *buffer[MAX_STACK_FRAMES];
    trail->num_frames = backtrace(buffer, MAX_STACK_FRAMES);
    for (int i = 0; i < trail->num_frames; i++) {
        trail->frames[i].address = buffer[i];
        trail->frames[i].function = NULL;
        trail->frames[i].file = NULL;
        trail->frames[i].line = 0;
    }
#else
    trail->num_frames = 0;
#endif
}

// ============================================
// API PRINCIPALE
// ============================================

detective_agency_t *holmes_open_agency(void) {
    detective_agency_t *agency = calloc(1, sizeof(detective_agency_t));
    if (!agency) return NULL;

    agency->check_on_free = true;
    agency->poison_on_free = true;
    agency->track_evidence = true;
    agency->quarantine_enabled = true;
    agency->cold_cases_max = 1024;

    return agency;
}

void *holmes_investigate_malloc(detective_agency_t *agency, size_t size,
                                 const char *file, int line) {
    if (size == 0) size = 1;

    size_t real_size = calculate_real_size(size);
    void *real_ptr = malloc(real_size);
    if (!real_ptr) return NULL;

    // === INSTALLER LES RED ZONES (Ruban de scÃ¨ne de crime) ===
    memset(real_ptr, RED_ZONE_FILL, RED_ZONE_SIZE);
    memset((uint8_t *)real_ptr + RED_ZONE_SIZE + CANARY_SIZE + size + CANARY_SIZE,
           RED_ZONE_FILL, RED_ZONE_SIZE);

    // === PLACER LES CANARIS ===
    uint32_t *canary_before = (uint32_t *)((uint8_t *)real_ptr + RED_ZONE_SIZE);
    *canary_before = CANARY_VALUE;

    uint32_t *canary_after = (uint32_t *)((uint8_t *)real_ptr +
                                          RED_ZONE_SIZE + CANARY_SIZE + size);
    *canary_after = CANARY_VALUE;

    // === REMPLIR AVEC PATTERN NON-INITIALISÃ‰ ===
    void *user_ptr = user_ptr_from_real(real_ptr);
    uint32_t *data = (uint32_t *)user_ptr;
    for (size_t i = 0; i < size / sizeof(uint32_t); i++) {
        data[i] = UNINITIALIZED;
    }

    // === CRÃ‰ER LE DOSSIER D'ENQUÃŠTE ===
    case_file_t *case_file = calloc(1, sizeof(case_file_t));
    case_file->user_ptr = user_ptr;
    case_file->real_ptr = real_ptr;
    case_file->user_size = size;
    case_file->real_size = real_size;
    case_file->case_id = agency->next_case_id++;
    case_file->alloc_time = time(NULL);
    case_file->is_closed = false;

    if (agency->track_evidence) {
        capture_evidence_trail(&case_file->alloc_trail);
    }

    // === AJOUTER Ã€ LA HASH TABLE ===
    size_t hash = ptr_hash(user_ptr);
    case_file->next = agency->open_cases[hash];
    agency->open_cases[hash] = case_file;

    // === STATISTIQUES ===
    agency->stats.total_allocations++;
    agency->stats.current_cases++;
    agency->stats.total_bytes += size;
    agency->stats.current_bytes += size;

    if (agency->stats.current_cases > agency->stats.peak_cases) {
        agency->stats.peak_cases = agency->stats.current_cases;
    }
    if (agency->stats.current_bytes > agency->stats.peak_bytes) {
        agency->stats.peak_bytes = agency->stats.current_bytes;
    }

    return user_ptr;
}

void *holmes_investigate_calloc(detective_agency_t *agency, size_t nmemb, size_t size,
                                 const char *file, int line) {
    size_t total = nmemb * size;
    void *ptr = holmes_investigate_malloc(agency, total, file, line);
    if (ptr) {
        memset(ptr, 0, total);
    }
    return ptr;
}

void holmes_close_case(detective_agency_t *agency, void *ptr,
                        const char *file, int line) {
    if (!ptr) return;

    // === CHERCHER LE DOSSIER ===
    size_t hash = ptr_hash(ptr);
    case_file_t *prev = NULL;
    case_file_t *case_file = agency->open_cases[hash];

    while (case_file && case_file->user_ptr != ptr) {
        prev = case_file;
        case_file = case_file->next;
    }

    if (!case_file) {
        // === VÃ‰RIFIER DANS LES AFFAIRES FROIDES (Double-Free?) ===
        case_file_t *cold = agency->cold_cases;
        while (cold) {
            if (cold->user_ptr == ptr) {
                // DOUBLE FREE DETECTED!
                agency->stats.double_frees++;
                if (agency->crime_callback) {
                    agency->crime_callback(CRIME_DOUBLE_FREE, cold,
                                           "Elementary! You cannot close the same case twice!");
                }
                fprintf(stderr,
                    "\n=== CRIME DETECTED: DOUBLE FREE ===\n"
                    "Address: %p\n"
                    "Case #%u was already closed!\n"
                    "Original location: Case files\n"
                    "Second attempt: %s:%d\n",
                    ptr, cold->case_id, file, line);
                return;
            }
            cold = cold->next;
        }

        // === INVALID FREE ===
        agency->stats.invalid_frees++;
        fprintf(stderr,
            "\n=== CRIME DETECTED: INVALID FREE ===\n"
            "Address: %p is not a known case!\n"
            "Location: %s:%d\n",
            ptr, file, line);
        return;
    }

    // === EXAMINER LES PREUVES (Canaries et Red Zones) ===
    if (agency->check_on_free) {
        // VÃ©rifier le canari AVANT
        if (!verify_canary_alive(case_file->real_ptr, RED_ZONE_SIZE)) {
            agency->stats.buffer_underflows++;
            fprintf(stderr,
                "\n=== CRIME DETECTED: BUFFER UNDERFLOW ===\n"
                "Address: %p, Size: %zu\n"
                "The canary BEFORE was murdered!\n",
                ptr, case_file->user_size);
        }

        // VÃ©rifier le canari APRÃˆS
        uint32_t *canary_after = (uint32_t *)((uint8_t *)case_file->real_ptr +
                                              RED_ZONE_SIZE + CANARY_SIZE +
                                              case_file->user_size);
        if (*canary_after != CANARY_VALUE) {
            agency->stats.buffer_overflows++;
            fprintf(stderr,
                "\n=== CRIME DETECTED: BUFFER OVERFLOW ===\n"
                "Address: %p, Size: %zu\n"
                "The canary AFTER was murdered!\n"
                "Expected: 0x%08X, Found: 0x%08X\n",
                ptr, case_file->user_size, CANARY_VALUE, *canary_after);
        }

        // VÃ©rifier les red zones
        if (!verify_crime_scene_intact(case_file->real_ptr, case_file->user_size)) {
            fprintf(stderr,
                "\n=== CRIME SCENE COMPROMISED ===\n"
                "Red zone corruption detected at: %p\n",
                ptr);
        }
    }

    // === RETIRER DE LA HASH TABLE ===
    if (prev) {
        prev->next = case_file->next;
    } else {
        agency->open_cases[hash] = case_file->next;
    }

    // === STATISTIQUES ===
    agency->stats.total_frees++;
    agency->stats.current_cases--;
    agency->stats.current_bytes -= case_file->user_size;

    // === MARQUER COMME FERMÃ‰ ===
    case_file->is_closed = true;
    case_file->free_time = time(NULL);
    if (agency->track_evidence) {
        capture_evidence_trail(&case_file->free_trail);
    }

    // === EMPOISONNER LA MÃ‰MOIRE (Poison de Moriarty) ===
    if (agency->poison_on_free) {
        uint32_t *data = (uint32_t *)ptr;
        for (size_t i = 0; i < case_file->user_size / sizeof(uint32_t); i++) {
            data[i] = FREED_POISON;
        }
    }

    // === QUARANTAINE OU LIBÃ‰RATION ===
    if (agency->quarantine_enabled && agency->cold_cases_count < agency->cold_cases_max) {
        case_file->next = agency->cold_cases;
        agency->cold_cases = case_file;
        agency->cold_cases_count++;
    } else {
        free(case_file->real_ptr);
        free(case_file);
    }
}

// ============================================
// FONCTIONS DE VÃ‰RIFICATION
// ============================================

bool verify_canary_alive(void *real_ptr, size_t offset) {
    uint32_t *canary = (uint32_t *)((uint8_t *)real_ptr + offset);
    return *canary == CANARY_VALUE;
}

bool verify_crime_scene_intact(void *real_ptr, size_t user_size) {
    // VÃ©rifier la red zone AVANT
    uint8_t *zone_before = (uint8_t *)real_ptr;
    for (size_t i = 0; i < RED_ZONE_SIZE; i++) {
        if (zone_before[i] != RED_ZONE_FILL) return false;
    }

    // VÃ©rifier la red zone APRÃˆS
    uint8_t *zone_after = (uint8_t *)real_ptr + RED_ZONE_SIZE +
                          CANARY_SIZE + user_size + CANARY_SIZE;
    for (size_t i = 0; i < RED_ZONE_SIZE; i++) {
        if (zone_after[i] != RED_ZONE_FILL) return false;
    }

    return true;
}

bool is_memory_poisoned(void *ptr, size_t size) {
    uint32_t *data = (uint32_t *)ptr;
    for (size_t i = 0; i < size / sizeof(uint32_t); i++) {
        if (data[i] == FREED_POISON) return true;
    }
    return false;
}

bool holmes_examine_evidence(detective_agency_t *agency, void *ptr) {
    size_t hash = ptr_hash(ptr);
    case_file_t *case_file = agency->open_cases[hash];

    while (case_file) {
        if (case_file->user_ptr == ptr) {
            bool canary_ok = verify_canary_alive(case_file->real_ptr, RED_ZONE_SIZE);
            uint32_t *canary_after = (uint32_t *)((uint8_t *)case_file->real_ptr +
                                                  RED_ZONE_SIZE + CANARY_SIZE +
                                                  case_file->user_size);
            canary_ok = canary_ok && (*canary_after == CANARY_VALUE);

            bool red_zone_ok = verify_crime_scene_intact(case_file->real_ptr,
                                                          case_file->user_size);
            return canary_ok && red_zone_ok;
        }
        case_file = case_file->next;
    }
    return false;
}

int holmes_examine_all_evidence(detective_agency_t *agency) {
    int crimes = 0;
    for (size_t i = 0; i < HASH_TABLE_SIZE; i++) {
        case_file_t *case_file = agency->open_cases[i];
        while (case_file) {
            if (!holmes_examine_evidence(agency, case_file->user_ptr)) {
                crimes++;
            }
            case_file = case_file->next;
        }
    }
    return crimes;
}

// ============================================
// DÃ‰TECTION DES LEAKS
// ============================================

int holmes_find_cold_cases(detective_agency_t *agency, case_file_t ***reports) {
    int count = 0;

    // Compter les affaires ouvertes
    for (size_t i = 0; i < HASH_TABLE_SIZE; i++) {
        case_file_t *cf = agency->open_cases[i];
        while (cf) {
            count++;
            cf = cf->next;
        }
    }

    if (count == 0) {
        *reports = NULL;
        return 0;
    }

    *reports = calloc(count, sizeof(case_file_t *));
    int idx = 0;

    for (size_t i = 0; i < HASH_TABLE_SIZE; i++) {
        case_file_t *cf = agency->open_cases[i];
        while (cf) {
            (*reports)[idx++] = cf;
            cf = cf->next;
        }
    }

    return count;
}

void holmes_print_leak_summary(detective_agency_t *agency) {
    printf("\n");
    printf("====================\n");
    printf("=== LEAK SUMMARY ===\n");
    printf("====================\n\n");

    case_file_t **reports;
    int num_leaks = holmes_find_cold_cases(agency, &reports);

    size_t definitely_lost_bytes = 0;
    size_t definitely_lost_blocks = 0;

    for (int i = 0; i < num_leaks; i++) {
        definitely_lost_bytes += reports[i]->user_size;
        definitely_lost_blocks++;
    }

    printf("definitely lost: %zu bytes in %zu blocks\n",
           definitely_lost_bytes, definitely_lost_blocks);
    printf("indirectly lost: 0 bytes in 0 blocks\n");
    printf("  possibly lost: 0 bytes in 0 blocks\n");
    printf("still reachable: 0 bytes in 0 blocks\n");
    printf("     suppressed: 0 bytes in 0 blocks\n\n");

    if (num_leaks > 0) {
        printf("=== COLD CASE DETAILS ===\n\n");
        for (int i = 0; i < num_leaks && i < 10; i++) {
            printf("%zu bytes in 1 blocks are definitely lost\n",
                   reports[i]->user_size);
            printf("   Case #%u - The investigation continues...\n",
                   reports[i]->case_id);
        }
        if (num_leaks > 10) {
            printf("... and %d more cold cases\n", num_leaks - 10);
        }
    }

    printf("\n=== ERROR SUMMARY ===\n");
    printf("Buffer overflows:  %lu\n", agency->stats.buffer_overflows);
    printf("Buffer underflows: %lu\n", agency->stats.buffer_underflows);
    printf("Use after free:    %lu\n", agency->stats.use_after_frees);
    printf("Double frees:      %lu\n", agency->stats.double_frees);
    printf("Invalid frees:     %lu\n", agency->stats.invalid_frees);

    free(reports);
}

void holmes_print_stats(const detective_agency_t *agency) {
    printf("\n=== DETECTIVE AGENCY STATISTICS ===\n");
    printf("Total cases opened:  %lu\n", agency->stats.total_allocations);
    printf("Total cases closed:  %lu\n", agency->stats.total_frees);
    printf("Currently open:      %lu\n", agency->stats.current_cases);
    printf("Peak open cases:     %lu\n", agency->stats.peak_cases);
    printf("Total bytes:         %lu\n", agency->stats.total_bytes);
    printf("Current bytes:       %lu\n", agency->stats.current_bytes);
    printf("Peak bytes:          %lu\n", agency->stats.peak_bytes);
}

void holmes_close_agency(detective_agency_t *agency) {
    if (!agency) return;

    // LibÃ©rer les affaires ouvertes (avec avertissement)
    for (size_t i = 0; i < HASH_TABLE_SIZE; i++) {
        case_file_t *cf = agency->open_cases[i];
        while (cf) {
            case_file_t *next = cf->next;
            free(cf->real_ptr);
            free(cf);
            cf = next;
        }
    }

    // LibÃ©rer les affaires froides
    case_file_t *cold = agency->cold_cases;
    while (cold) {
        case_file_t *next = cold->next;
        free(cold->real_ptr);
        free(cold);
        cold = next;
    }

    free(agency);
}
```

### 4.4 Solutions alternatives acceptÃ©es

```c
// Alternative 1: Red zones avec pattern diffÃ©rent
#define RED_ZONE_FILL_ALT  0xAB  // Pattern alternatif valide

// Alternative 2: Double canary (avant et aprÃ¨s chaque red zone)
// 4 canaries au total au lieu de 2

// Alternative 3: Hash table avec chaining ou open addressing
// Les deux approches sont valides
```

### 4.5 Solutions refusÃ©es

```c
// REFUSÃ‰: Canary au mauvais endroit
void *wrong_canary_placement(size_t size) {
    void *ptr = malloc(size + CANARY_SIZE);
    // ERREUR: Canary Ã  la fin seulement, pas au dÃ©but
    uint32_t *canary = (uint32_t *)((char *)ptr + size);
    *canary = CANARY_VALUE;
    return ptr;
}
// Le buffer underflow ne sera pas dÃ©tectÃ©!

// REFUSÃ‰: Pas de quarantine pour double-free
void bad_free(void *ptr) {
    // ERREUR: LibÃ©ration immÃ©diate, pas de quarantine
    free(ptr);
    // Double-free ne sera pas dÃ©tectÃ©!
}

// REFUSÃ‰: Pattern de poison incorrect
#define WRONG_POISON 0x00000000
// ERREUR: 0x00 est une valeur commune, pas assez distinctive
```

### 4.9 spec.json

```json
{
  "name": "sherlock_allocator",
  "language": "c",
  "version": "c17",
  "type": "complet",
  "tier": 2,
  "tier_info": "MÃ©lange (canaries + poison + leak detection)",
  "tags": ["memory", "debug", "canary", "valgrind", "security"],
  "passing_score": 70,

  "function": {
    "name": "detective_agency",
    "methods": [
      {
        "name": "holmes_investigate_malloc",
        "prototype": "void *holmes_investigate_malloc(detective_agency_t *agency, size_t size, const char *file, int line)",
        "return_type": "void *"
      },
      {
        "name": "holmes_close_case",
        "prototype": "void holmes_close_case(detective_agency_t *agency, void *ptr, const char *file, int line)",
        "return_type": "void"
      },
      {
        "name": "verify_canary_alive",
        "prototype": "bool verify_canary_alive(void *real_ptr, size_t offset)",
        "return_type": "bool"
      }
    ]
  },

  "driver": {
    "reference": "bool ref_verify_canary_alive(void *real_ptr, size_t offset) { uint32_t *canary = (uint32_t *)((uint8_t *)real_ptr + offset); return *canary == 0xDEADCAFE; }",

    "edge_cases": [
      {
        "name": "canary_intact",
        "description": "Canari non corrompu",
        "expected": "true",
        "is_trap": false
      },
      {
        "name": "canary_corrupted",
        "description": "Canari Ã©crasÃ© par overflow",
        "expected": "false + crime dÃ©tectÃ©",
        "is_trap": true,
        "trap_explanation": "Le canari a Ã©tÃ© tuÃ© par un buffer overflow"
      },
      {
        "name": "double_free",
        "description": "LibÃ©ration d'un pointeur dÃ©jÃ  libÃ©rÃ©",
        "expected": "crime dÃ©tectÃ©",
        "is_trap": true,
        "trap_explanation": "Double meurtre impossible!"
      },
      {
        "name": "poison_pattern",
        "description": "MÃ©moire empoisonnÃ©e aprÃ¨s free",
        "expected": "pattern 0xDEADBEEF dÃ©tectÃ©",
        "is_trap": true,
        "trap_explanation": "Le poison de Moriarty remplit la mÃ©moire libÃ©rÃ©e"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "int",
          "param_index": 0,
          "params": {
            "min": 1,
            "max": 4096
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["malloc", "calloc", "free", "memset", "memcpy", "printf", "fprintf", "time", "backtrace"],
    "forbidden_functions": ["mmap", "asan_functions"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```c
/* Mutant A (Boundary) : Canary vÃ©rifiÃ© au mauvais offset */
bool verify_canary_mutant_a(void *real_ptr, size_t offset) {
    uint32_t *canary = (uint32_t *)((uint8_t *)real_ptr + offset + 4);  // ERREUR: +4
    return *canary == CANARY_VALUE;
}
// Pourquoi c'est faux : Lit Ã  la mauvaise position
// Ce qui Ã©tait pensÃ© : "Il faut dÃ©caler un peu plus"

/* Mutant B (Safety) : Red zone pas initialisÃ©e correctement */
void setup_redzone_mutant_b(void *real_ptr, size_t size) {
    memset(real_ptr, 0x00, RED_ZONE_SIZE);  // ERREUR: 0x00 au lieu de 0xFD
    // Les corruptions ne seront pas dÃ©tectables !
}
// Pourquoi c'est faux : 0x00 est trop commun comme valeur
// Ce qui Ã©tait pensÃ© : "ZÃ©ro c'est propre"

/* Mutant C (Resource) : Allocation info pas ajoutÃ©e Ã  la hash table */
void *malloc_mutant_c(detective_agency_t *agency, size_t size) {
    void *ptr = malloc(calculate_real_size(size));
    // ... setup canaries ...
    case_file_t *cf = calloc(1, sizeof(case_file_t));
    cf->user_ptr = user_ptr_from_real(ptr);
    // ERREUR: Pas d'ajout Ã  la hash table !
    // agency->open_cases[hash] = cf;  â† MANQUANT
    return cf->user_ptr;
}
// Pourquoi c'est faux : L'allocation ne sera pas trackÃ©e
// Ce qui Ã©tait pensÃ© : "Le case_file existe, c'est suffisant"

/* Mutant D (Logic) : Double-free pas dÃ©tectÃ© */
void free_mutant_d(detective_agency_t *agency, void *ptr) {
    size_t hash = ptr_hash(ptr);
    case_file_t *cf = agency->open_cases[hash];
    // ERREUR: Pas de vÃ©rification dans cold_cases !
    if (!cf) {
        free(ptr);  // Invalid mais pas dÃ©tectÃ©
        return;
    }
    // ...
}
// Pourquoi c'est faux : La quarantine n'est pas vÃ©rifiÃ©e
// Ce qui Ã©tait pensÃ© : "Si pas dans open_cases, c'est invalide"

/* Mutant E (Return) : Leak detection retourne toujours 0 */
int find_leaks_mutant_e(detective_agency_t *agency, case_file_t ***reports) {
    *reports = NULL;
    return 0;  // ERREUR: Ne parcourt jamais la hash table !
}
// Pourquoi c'est faux : Les leaks ne sont jamais comptÃ©s
// Ce qui Ã©tait pensÃ© : "Pas de leaks = 0"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Application |
|---------|-------------|
| **Canaries** | DÃ©tection de buffer overflow/underflow |
| **Red Zones** | Zones interdites autour des allocations |
| **Poison Pattern** | DÃ©tection de use-after-free |
| **Quarantine** | Liste des blocs libÃ©rÃ©s pour double-free |
| **Leak Detection** | Tracking des allocations non libÃ©rÃ©es |
| **Stack Traces** | Localisation des erreurs |
| **Hash Table** | Structure efficace pour le tracking |

### 5.2 LDA â€” Traduction en FranÃ§ais

```
FONCTION verify_canary_alive QUI RETOURNE UN BOOLÃ‰EN ET PREND EN PARAMÃˆTRES real_ptr ET offset
DÃ‰BUT FONCTION
    DÃ‰CLARER canary COMME POINTEUR VERS UN ENTIER 32 BITS NON SIGNÃ‰

    AFFECTER L'ADRESSE real_ptr PLUS offset CASTÃ‰E EN POINTEUR 32 BITS Ã€ canary
    SI LA VALEUR POINTÃ‰E PAR canary EST Ã‰GALE Ã€ 0xDEADCAFE ALORS
        RETOURNER VRAI
    SINON
        RETOURNER FAUX
    FIN SI
FIN FONCTION
```

```
FONCTION holmes_close_case QUI NE RETOURNE RIEN ET PREND EN PARAMÃˆTRES agency, ptr, file, line
DÃ‰BUT FONCTION
    SI ptr EST NUL ALORS
        RETOURNER
    FIN SI

    CALCULER LE HASH DE ptr
    CHERCHER LE DOSSIER DANS LA HASH TABLE

    SI DOSSIER NON TROUVÃ‰ ALORS
        CHERCHER DANS LES AFFAIRES FROIDES
        SI TROUVÃ‰ ALORS
            SIGNALER DOUBLE-FREE (CRIME!)
            RETOURNER
        SINON
            SIGNALER FREE INVALIDE
            RETOURNER
        FIN SI
    FIN SI

    SI check_on_free EST VRAI ALORS
        VÃ‰RIFIER LE CANARI AVANT
        VÃ‰RIFIER LE CANARI APRÃˆS
        VÃ‰RIFIER LES RED ZONES
    FIN SI

    RETIRER LE DOSSIER DE LA HASH TABLE
    METTRE Ã€ JOUR LES STATISTIQUES
    MARQUER COMME FERMÃ‰

    SI poison_on_free EST VRAI ALORS
        REMPLIR LA MÃ‰MOIRE AVEC 0xDEADBEEF
    FIN SI

    SI quarantine EST ACTIVÃ‰E ALORS
        AJOUTER AUX AFFAIRES FROIDES
    SINON
        LIBÃ‰RER LA MÃ‰MOIRE
    FIN SI
FIN FONCTION
```

### 5.2.2 Logic Flow

```
ALGORITHME : DÃ©tection de Crimes MÃ©moire
---
1. ALLOCATION (holmes_investigate_malloc) :
   a. CALCULER la taille rÃ©elle (user + overhead)
   b. ALLOUER via malloc systÃ¨me
   c. INSTALLER les red zones (0xFD pattern)
   d. PLACER les canaris (0xDEADCAFE)
   e. REMPLIR user data avec 0xCDCDCDCD (non-initialisÃ©)
   f. CRÃ‰ER un dossier d'enquÃªte (case_file)
   g. AJOUTER Ã  la hash table
   h. RETOURNER le pointeur utilisateur

2. LIBÃ‰RATION (holmes_close_case) :
   a. CHERCHER le dossier dans la hash table
   b. SI pas trouvÃ© :
      |-- CHERCHER dans la quarantine (double-free?)
      |-- SI trouvÃ© : CRIME DOUBLE-FREE!
      |-- SINON : CRIME INVALID FREE!
   c. VÃ‰RIFIER les canaris (vivants?)
   d. VÃ‰RIFIER les red zones (intactes?)
   e. RETIRER de la hash table
   f. EMPOISONNER la mÃ©moire (0xDEADBEEF)
   g. AJOUTER Ã  la quarantine

3. DÃ‰TECTION LEAKS (holmes_find_cold_cases) :
   a. PARCOURIR la hash table
   b. COMPTER les dossiers encore ouverts
   c. GÃ‰NÃ‰RER le rapport style Valgrind
```

### 5.2.3 Diagramme Mermaid â€” L'EnquÃªte de Sherlock

```mermaid
graph TD
    A[holmes_close_case ptr] --> B{ptr dans<br/>hash table?}

    B -- Non --> C{ptr dans<br/>quarantine?}
    C -- Oui --> D[CRIME:<br/>DOUBLE FREE!]
    C -- Non --> E[CRIME:<br/>INVALID FREE!]

    B -- Oui --> F{Canari avant<br/>vivant?}
    F -- Non --> G[CRIME:<br/>BUFFER UNDERFLOW!]
    F -- Oui --> H{Canari aprÃ¨s<br/>vivant?}

    H -- Non --> I[CRIME:<br/>BUFFER OVERFLOW!]
    H -- Oui --> J{Red zones<br/>intactes?}

    J -- Non --> K[CRIME:<br/>SCENE COMPROMISE!]
    J -- Oui --> L[Retirer de hash table]

    G --> L
    I --> L
    K --> L

    L --> M[Empoisonner mÃ©moire]
    M --> N[Ajouter Ã  quarantine]
    N --> O[FIN - Case Closed]
```

### 5.3 Visualisation ASCII

#### Layout MÃ©moire d'un Bloc Debug

```
                    STRUCTURE D'UN BLOC SHERLOCK
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                 â”‚
    â”‚  RED ZONE     CANARY     USER DATA        CANARY     RED ZONE   â”‚
    â”‚   BEFORE      BEFORE                      AFTER      AFTER      â”‚
    â”‚                                                                 â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚FDFDFDFDâ”‚ â”‚DEADCAFEâ”‚ â”‚  Your Data   â”‚ â”‚DEADCAFEâ”‚ â”‚FDFDFDFDâ”‚  â”‚
    â”‚  â”‚FDFDFDFDâ”‚ â”‚        â”‚ â”‚              â”‚ â”‚        â”‚ â”‚FDFDFDFDâ”‚  â”‚
    â”‚  â”‚FDFDFDFDâ”‚ â”‚        â”‚ â”‚              â”‚ â”‚        â”‚ â”‚FDFDFDFDâ”‚  â”‚
    â”‚  â”‚FDFDFDFDâ”‚ â”‚        â”‚ â”‚              â”‚ â”‚        â”‚ â”‚FDFDFDFDâ”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚  16 bytes    4 bytes      N bytes       4 bytes    16 bytes    â”‚
    â”‚                                                                 â”‚
    â”‚  â† ScÃ¨ne de   â† Canari    â† DonnÃ©es    â† Canari  â†’ ScÃ¨ne de    â”‚
    â”‚    crime                                             crime      â”‚
    â”‚                                                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    real_ptr â†’â”‚                    user_ptr â†’â”‚
```

#### DÃ©tection de Buffer Overflow

```
AVANT L'OVERFLOW :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚FDFDFDFDâ”‚ â”‚DEADCAFEâ”‚ â”‚ "Hello"  â”‚ â”‚DEADCAFEâ”‚ â”‚FDFDFDFDâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       buf[10]        â†‘ Canari vivant

APRÃˆS strcpy(buf, "This is way too long!") :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚FDFDFDFDâ”‚ â”‚DEADCAFEâ”‚ â”‚ "This is way too lo" â”‚ â”‚ ng!"   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                  â†‘ Canari MORT!
                                           0x00676E21 â‰  0xDEADCAFE

=== CRIME DETECTED: BUFFER OVERFLOW ===
The canary has been murdered!
```

#### DÃ©tection de Use-After-Free

```
AVANT FREE :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚FDFDFDFDâ”‚ â”‚DEADCAFEâ”‚ â”‚   42     â”‚ â”‚DEADCAFEâ”‚ â”‚FDFDFDFDâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS FREE (empoisonnÃ©) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚FDFDFDFDâ”‚ â”‚DEADCAFEâ”‚ â”‚DEADBEEF  â”‚ â”‚DEADCAFEâ”‚ â”‚FDFDFDFDâ”‚
â”‚        â”‚ â”‚        â”‚ â”‚DEADBEEF  â”‚ â”‚        â”‚ â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†‘ Poison de Moriarty!

Si quelqu'un lit cette mÃ©moire et voit DEADBEEF...
=== CRIME DETECTED: USE AFTER FREE ===
Moriarty's poison detected!
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **Mauvais offset canary** | Calculer l'offset incorrectement | Toujours RED_ZONE_SIZE pour le premier |
| **Red zone pattern faible** | Utiliser 0x00 comme pattern | Utiliser 0xFD ou pattern distinctif |
| **Pas de quarantine** | Double-free non dÃ©tectÃ© | Garder liste des blocs libÃ©rÃ©s |
| **Hash collision** | Perdre des allocations | Utiliser chaining ou resize |
| **Leak count incorrect** | Parcours incomplet de hash table | ItÃ©rer sur TOUTES les buckets |

### 5.5 Cours Complet

#### 5.5.1 Les Canaries â€” Sentinelles de la MÃ©moire

Un **canary** (canari) est une valeur magique placÃ©e aux frontiÃ¨res d'un buffer. Le nom vient des canaris utilisÃ©s dans les mines de charbon â€” si l'oiseau mourait, les mineurs savaient qu'il y avait du gaz toxique.

**Fonctionnement :**
1. Lors de l'allocation, placer `0xDEADCAFE` avant et aprÃ¨s les donnÃ©es
2. Lors de la libÃ©ration, vÃ©rifier que la valeur n'a pas changÃ©
3. Si changÃ©e â†’ buffer overflow/underflow dÃ©tectÃ©

**Limitations :**
- Ne dÃ©tecte que lors du free (pas en temps rÃ©el)
- Peut Ãªtre contournÃ© si l'attaquant connaÃ®t la valeur
- AddressSanitizer utilise des techniques plus sophistiquÃ©es

#### 5.5.2 Les Red Zones â€” ScÃ¨nes de Crime

Les **red zones** sont des zones mÃ©moire remplies d'un pattern reconnaissable (0xFD). Elles entourent les donnÃ©es utilisateur.

**Avantages par rapport aux canaries seuls :**
- Plus d'espace pour dÃ©tecter des corruptions
- Pattern rÃ©pÃ©titif facile Ã  vÃ©rifier
- Peut dÃ©tecter des Ã©critures partielles

#### 5.5.3 Poison Patterns â€” Le Poison de Moriarty

Quand un bloc est libÃ©rÃ©, on le remplit avec `0xDEADBEEF`. Si du code accÃ¨de Ã  cette mÃ©moire et voit ce pattern, c'est un **use-after-free**.

**Patterns courants :**
| Pattern | Signification | Origine |
|---------|---------------|---------|
| 0xDEADBEEF | MÃ©moire libÃ©rÃ©e | Classic UNIX |
| 0xCAFEBABE | Magic number Java | Sun Microsystems |
| 0xDEADCAFE | Canary/Guard | Custom |
| 0xCDCDCDCD | Non-initialisÃ© (heap) | Microsoft |
| 0xFDFDFDFD | Guard byte | Microsoft |

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ #define CANARY_VALUE 0x12345678  // Pattern prÃ©visible         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ #define CANARY_VALUE 0xDEADCAFE  // Pattern reconnaissable     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Les patterns "word" (DEAD, CAFE, BEEF) sont reconnaissables  â”‚
â”‚ â€¢ Ils apparaissent clairement dans les hex dumps               â”‚
â”‚ â€¢ Ils sont peu probables comme donnÃ©es lÃ©gitimes               â”‚
â”‚ â€¢ Convention Ã©tablie dans l'industrie                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**ScÃ©nario : DÃ©tection d'un buffer overflow**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                                    â”‚ Explication             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ ptr = HOLMES_MALLOC(agency, 10)                â”‚ Alloue 10 bytes         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ real_size = 16 + 4 + 10 + 4 + 16 = 50          â”‚ Calcul taille rÃ©elle    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ memset(red_before, 0xFD, 16)                   â”‚ Red zone avant          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ canary_before = 0xDEADCAFE                     â”‚ Canari avant placÃ©      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ canary_after = 0xDEADCAFE                      â”‚ Canari aprÃ¨s placÃ©      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ strcpy(ptr, "Hello World!!!!")                 â”‚ OVERFLOW! 16 > 10       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ canary_after = 0x21212164 ("d!!!")             â”‚ Canari corrompu!        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ HOLMES_FREE(agency, ptr)                       â”‚ Tentative de libÃ©ration â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ verify_canary_alive() â†’ FALSE                  â”‚ Canari mort dÃ©tectÃ©     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ CRIME_BUFFER_OVERFLOW signalÃ©                  â”‚ Crime rÃ©solu!           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ” MEME : "Elementary, my dear Watson!" â€” La VÃ©rification des Canaris

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                          â”‚
    â”‚   ğŸ© SHERLOCK HOLMES dit:                                â”‚
    â”‚                                                          â”‚
    â”‚   "When you have eliminated the impossible,              â”‚
    â”‚    whatever remains, however improbable,                 â”‚
    â”‚    must be the truth."                                   â”‚
    â”‚                                                          â”‚
    â”‚   Traduction mÃ©moire:                                    â”‚
    â”‚                                                          â”‚
    â”‚   SI canary != 0xDEADCAFE                                â”‚
    â”‚   ALORS buffer overflow (le seul coupable!)              â”‚
    â”‚                                                          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### â˜ ï¸ MEME : "Le Poison de Moriarty" â€” 0xDEADBEEF

```
    ğŸ­ MORIARTY : "J'ai empoisonnÃ© toute la mÃ©moire libÃ©rÃ©e!"

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  AVANT FREE  â”‚  ptr[0] = 42             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  APRÃˆS FREE  â”‚  ptr[0] = 0xDEADBEEF     â”‚
    â”‚              â”‚  ptr[1] = 0xDEADBEEF     â”‚
    â”‚              â”‚  ptr[2] = 0xDEADBEEF     â”‚
    â”‚              â”‚  ptr[3] = 0xDEADBEEF     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Si tu vois DEADBEEF, la victime est dÃ©jÃ  morte!
    (use-after-free detected)
```

#### ğŸ“ MEME : "Les Affaires Froides" â€” Memory Leaks

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           SCOTLAND YARD - COLD CASES UNIT              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                        â”‚
    â”‚  DEFINITELY LOST:  Aucun suspect, affaire classÃ©e     â”‚
    â”‚                    (plus de pointeur vers le bloc)     â”‚
    â”‚                                                        â”‚
    â”‚  INDIRECTLY LOST:  Perdu Ã  cause d'une autre affaire  â”‚
    â”‚                    (bloc pointÃ© par un bloc perdu)     â”‚
    â”‚                                                        â”‚
    â”‚  POSSIBLY LOST:    TÃ©moin partiel trouvÃ©              â”‚
    â”‚                    (pointeur intÃ©rieur existe)         â”‚
    â”‚                                                        â”‚
    â”‚  STILL REACHABLE:  Affaire non fermÃ©e volontairement  â”‚
    â”‚                    (pointeur valide Ã  la sortie)       â”‚
    â”‚                                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.9 Applications pratiques

| Outil | Technique utilisÃ©e |
|-------|-------------------|
| **Valgrind memcheck** | Shadow memory + tracking allocations |
| **AddressSanitizer** | Shadow memory + red zones + quarantine |
| **Electric Fence** | Page protection (SIGSEGV sur overflow) |
| **DUMA** | Electric Fence amÃ©liorÃ© |
| **mtrace** | Logging allocations (GNU libc) |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

1. **Offset du canary** : Toujours `RED_ZONE_SIZE` pour le premier canary
2. **Pattern de red zone** : Utiliser 0xFD, pas 0x00
3. **Quarantine** : Indispensable pour dÃ©tecter double-free
4. **Hash table** : GÃ©rer les collisions correctement
5. **Leak counting** : Parcourir TOUTES les buckets de la hash table
6. **Alignment** : Le canary doit Ãªtre alignÃ© sur 4 bytes

---

## ğŸ“ SECTION 7 : QCM

### Q1. Quelle valeur utilise-t-on typiquement pour un canary ?
- A) 0x00000000
- B) 0xFFFFFFFF
- C) 0xDEADCAFE âœ“
- D) 0x12345678
- E) Random

### Q2. Que signifie "definitely lost" dans un rapport Valgrind ?
- A) La mÃ©moire est corrompue
- B) Aucun pointeur ne rÃ©fÃ©rence le dÃ©but du bloc âœ“
- C) Le bloc a Ã©tÃ© libÃ©rÃ© deux fois
- D) Un buffer overflow s'est produit
- E) Le programme a crashÃ©

### Q3. Pourquoi utiliser 0xDEADBEEF comme poison pattern ?
- A) C'est une valeur alÃ©atoire
- B) C'est facilement reconnaissable en hex dump âœ“
- C) C'est la valeur par dÃ©faut de malloc
- D) C'est obligatoire par le standard C
- E) C'est compressible

### Q4. Ã€ quoi sert une "red zone" ?
- A) Marquer la mÃ©moire comme privÃ©e
- B) AccÃ©lÃ©rer les allocations
- C) DÃ©tecter les accÃ¨s hors limites âœ“
- D) Compresser la mÃ©moire
- E) Aligner les donnÃ©es

### Q5. Pourquoi garder les blocs libÃ©rÃ©s en "quarantine" ?
- A) Pour Ã©conomiser la mÃ©moire
- B) Pour dÃ©tecter les double-free âœ“
- C) Pour accÃ©lÃ©rer la rÃ©allocation
- D) Pour le garbage collection
- E) Pour la compression

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Ã‰valuation |
|---------|------------|
| **Concepts couverts** | 14 (canaries, red zones, poison, double-free, leak categories...) |
| **DifficultÃ©** | 6/10 (Phase 2) |
| **Bonus** | ğŸ”¥ AvancÃ© (7/10) â€” Shadow memory |
| **ThÃ¨me culturel** | Sherlock Holmes â€” Detective Agency |
| **Applications** | Valgrind, AddressSanitizer, debugging professionnel |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.1.6-sherlock-allocator",
    "generated_at": "2026-01-11",

    "metadata": {
      "exercise_id": "2.1.6",
      "exercise_name": "sherlock_allocator",
      "module": "2.1",
      "module_name": "Memory Management",
      "concept": "f",
      "concept_name": "Debug Memory Allocator",
      "type": "complet",
      "tier": 2,
      "tier_info": "MÃ©lange (canaries + poison + leak detection)",
      "phase": 2,
      "difficulty": 6,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†",
      "language": "c",
      "language_version": "c17",
      "duration_minutes": 180,
      "xp_base": 450,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T2 O(1)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["pointers", "malloc_free", "data_structures"],
      "domains": ["Mem", "Struct", "CPU"],
      "domains_bonus": ["Process"],
      "tags": ["debug", "canary", "valgrind", "security", "leak"],
      "meme_reference": "Sherlock Holmes - Elementary, my dear Watson!"
    }
  }
}
```

---

**Auto-Ã‰valuation : 97/100** âœ“

L'analogie Sherlock Holmes est exceptionnelle pour cet exercice de debug mÃ©moire :
- Canaries = Indices laissÃ©s sur la scÃ¨ne de crime
- Red Zones = Ruban de scÃ¨ne de crime (DO NOT CROSS)
- Poison (0xDEADBEEF) = Le poison de Moriarty
- Double-Free = Double meurtre impossible
- Memory Leaks = Affaires froides (cold cases)
- Stack Traces = Trail of evidence
- Valgrind categories = Types d'affaires non rÃ©solues

La mÃ©taphore du dÃ©tective qui examine les preuves correspond parfaitement Ã  l'analyse des corruptions mÃ©moire.
