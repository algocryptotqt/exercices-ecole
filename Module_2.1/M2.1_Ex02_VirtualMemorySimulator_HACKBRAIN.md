<thinking>
## Analyse du Concept
- Concept : MÃ©moire virtuelle avec tables de pages multi-niveaux (2, 4, 5 niveaux)
- Phase demandÃ©e : 2
- AdaptÃ© ? OUI - Concept avancÃ© de gestion mÃ©moire, parfait pour Phase 2

## Combo Base + Bonus
- Exercice de base : Simulateur de mÃ©moire virtuelle avec traduction d'adresses VA->PA
- Bonus : Support des huge pages 2MB/1GB + TLP (Transparent Large Pages) automatique
- Palier bonus : ğŸ”¥ AvancÃ© (concepts systÃ¨me avancÃ©s)
- Progression logique ? OUI - Base = page walk standard, Bonus = optimisations production

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : Pointeurs, arithmÃ©tique binaire, HashMap en Rust
- DifficultÃ© estimÃ©e : 6/10
- CohÃ©rent avec phase ? OUI (Phase 2 = 4-6/10)

## Aspect Fun/Culture
- Contexte choisi : INCEPTION de Christopher Nolan
- MEME mnÃ©motechnique : "We need to go deeper" + Totem
- Pourquoi c'est fun : Les niveaux de rÃªves = niveaux de page tables,
  traduction VA->PA = transition rÃªve->rÃ©alitÃ©, TLB = raccourcis de Cobb,
  kick = TLB flush, totem = validation d'adresse

## Analogie Inception â†’ MÃ©moire Virtuelle
| Inception | MÃ©moire Virtuelle |
|-----------|-------------------|
| RÃ©alitÃ© | MÃ©moire Physique |
| Niveau 1 (RÃªve) | PML4 |
| Niveau 2 (RÃªve dans rÃªve) | PDPT |
| Niveau 3 (Plus profond) | PD |
| Niveau 4 (Limbo) | PT |
| Le Kick | TLB Invalidation |
| Totem | Bit Present/Valid |
| RÃªve partagÃ© | Huge Pages |
| Architecte | OS/Kernel |
| Extractor | Process |

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Boundary) : Calcul d'index avec mauvais shift (12 + level*9 au lieu de 12 + (level-1)*9)
2. Mutant B (Safety) : Pas de vÃ©rification du bit "present" avant d'accÃ©der Ã  l'entrÃ©e
3. Mutant C (Resource) : TLB jamais invalidÃ© aprÃ¨s un mapping, donnÃ©es stales
4. Mutant D (Logic) : Offset calculÃ© avec page_size de base au lieu du page_size rÃ©el (huge pages)
5. Mutant E (Return) : Page walk s'arrÃªte trop tÃ´t sur huge page (oubli du bit huge_page)

## Verdict
VALIDE - Analogie Inception parfaite pour illustrer la hiÃ©rarchie et les niveaux.
Note qualitÃ© estimÃ©e : 98/100
</thinking>

---

# Exercice 2.1.2 : dream_architect

**Module :**
2.1 â€” Memory Management

**Concept :**
b-k â€” Virtual Memory & Multi-Level Page Tables

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10)

**Type :**
code

**Tiers :**
3 â€” SynthÃ¨se (concepts 2.1.2.a â†’ 2.1.3.k)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- ArithmÃ©tique binaire (shifts, masks)
- HashMap et structures Rust
- Concepts de base de la mÃ©moire (Phase 1)

**Domaines :**
Mem, CPU, Struct

**DurÃ©e estimÃ©e :**
180 min

**XP Base :**
400

**ComplexitÃ© :**
T3 O(levels) Ã— S3 O(pages_mapped)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
```
ex02_dream_architect/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs          # BibliothÃ¨que principale
â”‚   â””â”€â”€ main.rs         # Programme de dÃ©monstration
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration_tests.rs
â””â”€â”€ Cargo.toml
```

**Fonctions/Crates autorisÃ©es :**
- `std::collections::HashMap`
- `std::fmt` pour le debug
- OpÃ©rateurs bitwise (`<<`, `>>`, `&`, `|`)

**Fonctions interdites :**
- BibliothÃ¨ques d'OS rÃ©el (`libc`, `nix`)
- `unsafe` (sauf bonus)
- Crates externes

---

### 1.2 Consigne

#### ğŸ¬ INCEPTION â€” L'Architecture des RÃªves

> *"You mustn't be afraid to dream a little bigger, darling."* â€” Eames

Dans le film **Inception** de Christopher Nolan, Dom Cobb et son Ã©quipe naviguent Ã  travers des **niveaux de rÃªves imbriquÃ©s**. Pour atteindre une idÃ©e enfouie dans le subconscient, ils doivent descendre niveau par niveau :
- **RÃ©alitÃ©** â†’ Niveau 1 â†’ Niveau 2 â†’ Niveau 3 â†’ **Limbo**

Chaque niveau a ses propres rÃ¨gles, son propre espace, et pour remonter, il faut un **"kick"** synchronisÃ©.

**Le parallÃ¨le avec la mÃ©moire virtuelle est saisissant :**

| Inception | SystÃ¨me de MÃ©moire |
|-----------|-------------------|
| RÃ©alitÃ© | MÃ©moire Physique (RAM) |
| Adresse dans le rÃªve | Adresse Virtuelle |
| Adresse rÃ©elle | Adresse Physique |
| Niveaux de rÃªves | Niveaux de Page Tables |
| Le Kick | TLB Flush (invalidation) |
| Totem (vÃ©rification) | Bit Present/Valid |
| Architecte | Operating System |
| Shared Dreaming | Huge Pages (2MB/1GB) |
| Limbo (temps infini) | Page Fault (blocage) |

**Tu es l'Architecte.** Tu dois construire le systÃ¨me qui permet de traduire les **adresses virtuelles** (positions dans le rÃªve) en **adresses physiques** (positions dans la rÃ©alitÃ©).

---

**Ta mission :**

ImplÃ©menter un simulateur de mÃ©moire virtuelle nommÃ© `DreamArchitect` qui :

1. **Supporte 3 configurations de niveaux :**
   - `x86_32` : 2 niveaux (comme un rÃªve simple)
   - `x86_64` : 4 niveaux (architecture standard)
   - `x86_64_la57` : 5 niveaux (Limbo profond, >256TB)

2. **Effectue la traduction d'adresses (Page Walk)** :
   - Descend niveau par niveau comme dans Inception
   - Enregistre chaque Ã©tape du "voyage"
   - DÃ©tecte les Page Faults (Ã©quivalent de rester coincÃ© en Limbo)

3. **GÃ¨re un TLB (Translation Lookaside Buffer)** :
   - Cache les traductions rÃ©centes (raccourcis de Cobb)
   - Ã‰vite de refaire le page walk complet

**EntrÃ©e :**
- `config: DreamConfig` : Configuration des niveaux (2, 4 ou 5)
- `va: u64` : Adresse virtuelle Ã  traduire
- `pa: Option<u64>` : Adresse physique cible (ou None pour auto-allocation)
- `flags: DreamFlags` : Permissions de la page

**Sortie :**
- `Result<TranslationResult, DreamError>`
- `TranslationResult` contient :
  - `physical_address: u64` â€” L'adresse dans la "rÃ©alitÃ©"
  - `dream_size: u64` â€” Taille de la page (4KB, 2MB, 1GB)
  - `journey: Vec<DreamLevel>` â€” Trace du page walk

**Contraintes :**
- Les adresses 4KB doivent Ãªtre alignÃ©es sur 4096
- Les huge pages 2MB sur 2097152 (2^21)
- Les huge pages 1GB sur 1073741824 (2^30)
- L'index par niveau utilise 9 bits (512 entrÃ©es par table)
- Le TLB a une capacitÃ© limitÃ©e (Ã©viction LRU simplifiÃ©e)

**Exemples :**

| Appel | RÃ©sultat | Explication |
|-------|----------|-------------|
| `architect.descend(0x1000)` | `Ok(TranslationResult { pa: 0x100000, ... })` | Page walk 4 niveaux |
| `architect.descend(0x200000)` avec huge | `Ok(TranslationResult { dream_size: 2MB, ... })` | ArrÃªt au niveau 1 |
| `architect.descend(0xDEAD)` non mappÃ© | `Err(DreamError::Limbo { va, level: 3 })` | Page Fault = coincÃ© en Limbo |

---

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un simulateur de mÃ©moire virtuelle avec support des tables de pages multi-niveaux (2, 4, 5 niveaux), traduction d'adresses virtuelle vers physique (page walk), gestion du TLB pour optimiser les accÃ¨s, et support optionnel des huge pages 2MB et 1GB.

---

### 1.3 Prototype

```rust
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INCEPTION MEMORY SYSTEM â€” "We need to go deeper"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Tailles de pages â€” Les dimensions des rÃªves
pub const DREAM_4K: u64 = 4096;                    // RÃªve standard
pub const DREAM_2M: u64 = 2 * 1024 * 1024;         // Shared Dream (2MB)
pub const DREAM_1G: u64 = 1024 * 1024 * 1024;      // Collective Unconscious (1GB)

/// Configuration du monde des rÃªves
#[derive(Debug, Clone)]
pub struct DreamConfig {
    pub levels: u8,              // Profondeur maximale (2, 4, ou 5)
    pub va_bits: u8,             // Bits d'adresse virtuelle
    pub pa_bits: u8,             // Bits d'adresse physique
    pub base_dream_size: u64,    // Taille de page par dÃ©faut
    pub allow_shared_dreams: bool, // Support des huge pages
}

/// Flags â€” Le Totem de chaque page
#[derive(Debug, Clone, Copy, Default)]
pub struct DreamFlags {
    pub present: bool,           // Totem valide â€” sommes-nous dans la rÃ©alitÃ© ?
    pub writable: bool,          // Peut-on modifier ce rÃªve ?
    pub user_access: bool,       // Accessible depuis le rÃªve ?
    pub accessed: bool,          // A-t-on visitÃ© ce niveau ?
    pub dirty: bool,             // Le rÃªve a-t-il Ã©tÃ© altÃ©rÃ© ?
    pub shared_dream: bool,      // Huge page (PS bit)
    pub global: bool,            // PrÃ©sent dans tous les rÃªves
    pub no_execute: bool,        // Interdit d'exÃ©cuter du code ici
}

/// Une Ã©tape du voyage dans les rÃªves (Page Walk)
#[derive(Debug, Clone)]
pub struct DreamLevel {
    pub depth: u8,               // Niveau actuel
    pub table_location: u64,     // Adresse de la table
    pub index: usize,            // Index dans la table (0-511)
    pub is_shared_dream: bool,   // Est-ce une huge page ?
}

/// RÃ©sultat de la traduction â€” Retour Ã  la rÃ©alitÃ©
#[derive(Debug)]
pub struct TranslationResult {
    pub physical_address: u64,   // Position dans la rÃ©alitÃ©
    pub dream_size: u64,         // Taille de la zone (4K, 2M, 1G)
    pub flags: DreamFlags,       // Ã‰tat du totem
    pub journey: Vec<DreamLevel>, // Trace du page walk
}

/// Erreurs â€” Quand on reste coincÃ©
#[derive(Debug)]
pub enum DreamError {
    Limbo { va: u64, level: u8 },         // Page Fault â€” coincÃ© dans les limbes
    MisalignedDream,                       // Adresse non alignÃ©e
    SharedDreamsDisabled,                  // Huge pages non supportÃ©es
    CorruptedTotem,                        // Table invalide
    OutOfDreams,                           // Plus de mÃ©moire
}

/// L'Architecte â€” Gestionnaire de mÃ©moire virtuelle
pub struct DreamArchitect {
    config: DreamConfig,
    // Tables de pages hiÃ©rarchiques
    root_table: DreamTable,
    subtables: HashMap<u64, DreamTable>,
    // TLB â€” Les raccourcis de Cobb
    shortcuts: HashMap<u64, (u64, DreamFlags, u64)>,
    shortcut_capacity: usize,
    // Allocateur de frames
    next_reality_frame: u64,
    // Statistiques
    stats: DreamStats,
}

impl DreamArchitect {
    /// CrÃ©er un nouvel Architecte
    pub fn new(config: DreamConfig, tlb_size: usize) -> Self;

    /// Construire un rÃªve â€” mapper une page
    pub fn build_dream(
        &mut self,
        virtual_pos: u64,
        physical_pos: Option<u64>,
        flags: DreamFlags,
        dream_size: u64,
    ) -> Result<u64, DreamError>;

    /// Descendre dans les rÃªves â€” traduire une adresse
    pub fn descend(&mut self, va: u64) -> Result<TranslationResult, DreamError>;

    /// Le Kick â€” invalider le TLB
    pub fn kick(&mut self);

    /// Obtenir les statistiques
    pub fn inception_report(&self) -> &DreamStats;
}

/// Statistiques de l'Architecte
#[derive(Debug, Default)]
pub struct DreamStats {
    pub total_translations: u64,
    pub page_walks: u64,
    pub shortcut_hits: u64,      // TLB hits
    pub shortcut_misses: u64,    // TLB misses
    pub shared_dream_uses: u64,  // Huge pages utilisÃ©es
    pub tables_created: usize,
    pub memory_footprint: u64,
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 La vraie architecture x86-64

Le processeur Intel/AMD moderne utilise **exactement** cette hiÃ©rarchie :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              VIRTUAL ADDRESS (48 bits typiquement)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PML4   â”‚  PDPT  â”‚   PD   â”‚   PT   â”‚ Offset â”‚    Structure      â”‚
â”‚ [47:39]â”‚ [38:30]â”‚ [29:21]â”‚ [20:12]â”‚ [11:0] â”‚                   â”‚
â”‚ 9 bits â”‚ 9 bits â”‚ 9 bits â”‚ 9 bits â”‚ 12 bitsâ”‚                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  512   â”‚  512   â”‚  512   â”‚  512   â”‚  4096  â”‚ EntrÃ©es/Octets    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Pourquoi 4 niveaux ne suffisent plus

Avec 48 bits d'adresse virtuelle â†’ 256 TB adressables.
Avec 57 bits (LA57, 5 niveaux) â†’ 128 PB (pÃ©taoctets) !

**Qui utilise Ã§a ?**
- Data centers avec > 256 TB de RAM
- Cloud providers (AWS, Google, Azure)
- Supercalculateurs

### 2.3 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Kernel Developer** | ImplÃ©mente le page walk dans le noyau Linux/Windows |
| **Hypervisor Engineer** | GÃ¨re les nested page tables (EPT/NPT) pour la virtualisation |
| **Game Engine Developer** | Utilise les huge pages pour rÃ©duire les TLB misses |
| **HPC Engineer** | Configure les huge pages pour les simulations scientifiques |
| **Security Researcher** | Exploite les side-channels du TLB (Meltdown, Spectre) |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/  tests/

$ cargo build --release
   Compiling dream_architect v0.1.0
    Finished release [optimized]

$ cargo run
ğŸ¬ INCEPTION MEMORY SIMULATOR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ARCHITECT] Building dream world (x86_64, 4 levels)...
[BUILD] Mapping 0x1000 -> auto (4KB)
[BUILD] Mapping 0x200000 -> auto (2MB shared dream)
[BUILD] Mapping 0x40000000 -> auto (1GB collective)

[DESCEND] Translating 0x1000...
  Level 3 (PML4): index 0
  Level 2 (PDPT): index 0
  Level 1 (PD):   index 0
  Level 0 (PT):   index 1
  â†’ Physical: 0x100000, Size: 4KB

[DESCEND] Translating 0x200000 (shared dream)...
  Level 3 (PML4): index 0
  Level 2 (PDPT): index 0
  Level 1 (PD):   index 1 [SHARED DREAM - STOP]
  â†’ Physical: 0x104000, Size: 2MB

[SHORTCUT HIT] 0x1000 found in TLB!
  â†’ Physical: 0x100000 (no page walk needed)

[KICK] TLB flushed - all shortcuts cleared

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
INCEPTION REPORT:
  Translations: 4
  Page walks: 3
  TLB hits: 1
  TLB misses: 3
  Shared dreams: 1
  Tables: 5
  Memory: 20KB
```

---

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(1) pour TLB hit, O(levels) pour page walk

**Space Complexity attendue :**
O(pages) + O(tlb_size)

**Domaines Bonus :**
`Process` (Transparent Huge Pages automatiques)

---

#### 3.1.1 Consigne Bonus â€” Transparent Shared Dreams (THP)

> *"The dream has become their reality."* â€” Mal

Dans le monde rÃ©el, Linux peut **automatiquement** promouvoir des pages 4KB en huge pages 2MB quand c'est avantageux. C'est le **Transparent Huge Pages (THP)**.

**Ta mission bonus :**

ImplÃ©menter le systÃ¨me `TransparentSharedDreams` qui :

1. **DÃ©tecte les patterns d'accÃ¨s contigus** :
   - Si 512 pages 4KB consÃ©cutives sont mappÃ©es
   - â†’ Promotion automatique en 1 huge page 2MB

2. **DÃ©mote les huge pages sous-utilisÃ©es** :
   - Si <10% d'une huge page est accÃ©dÃ©e
   - â†’ Split en 512 pages 4KB

3. **Khunpaging background** :
   - Thread/async qui scanne et optimise

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Promotion : 512 pages 4K â†’ 1 page 2M   â”‚
â”‚  Demotion : 1 page 2M â†’ 512 pages 4K    â”‚
â”‚  Scan interval : configurable           â”‚
â”‚  Access tracking : via bit "accessed"   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 Prototype Bonus

```rust
/// SystÃ¨me de Transparent Huge Pages
pub struct TransparentSharedDreams {
    architect: DreamArchitect,
    promotion_threshold: usize,    // Nombre de pages 4K contiguÃ«s pour promouvoir
    demotion_threshold: f64,       // % d'utilisation sous lequel dÃ©moter
    scan_enabled: bool,
}

impl TransparentSharedDreams {
    /// Scanner et optimiser les mappings
    pub fn optimize(&mut self) -> OptimizationReport;

    /// Promouvoir manuellement une rÃ©gion
    pub fn promote_region(&mut self, start_va: u64) -> Result<(), DreamError>;

    /// DÃ©moter une huge page
    pub fn demote_page(&mut self, va: u64) -> Result<(), DreamError>;
}
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Huge pages | Manuelles | Automatiques (THP) |
| Optimisation | Aucune | Promotion/Demotion dynamique |
| Tracking | Simple stats | Access bit monitoring |
| ComplexitÃ© | O(levels) | O(levels) + O(n) scan pÃ©riodique |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points | CritÃ¨re |
|------|-------------|--------|---------|
| `test_2level_32bit` | Config x86_32 basique | 10 | 2 niveaux fonctionnels |
| `test_4level_64bit` | Config x86_64 standard | 15 | 4 niveaux fonctionnels |
| `test_5level_la57` | Config LA57 (57 bits) | 10 | 5 niveaux fonctionnels |
| `test_page_walk_trace` | Trace du page walk | 10 | Tous niveaux enregistrÃ©s |
| `test_tlb_hit` | TLB cache hit | 10 | Pas de page walk |
| `test_tlb_miss` | TLB cache miss | 5 | Page walk effectuÃ© |
| `test_tlb_eviction` | Ã‰viction LRU | 10 | Remplacement correct |
| `test_huge_page_2m` | Huge page 2MB | 10 | ArrÃªt niveau 1 |
| `test_huge_page_1g` | Huge page 1GB | 10 | ArrÃªt niveau 2 |
| `test_page_fault` | Page non mappÃ©e | 5 | Erreur Limbo correcte |
| `test_alignment_check` | Alignement des adresses | 5 | Rejet si non alignÃ© |
| **TOTAL** | | **100** | |

---

### 4.2 main.rs de test

```rust
use dream_architect::*;

fn main() {
    println!("ğŸ¬ INCEPTION MEMORY SIMULATOR");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // CrÃ©er l'Architecte avec config x86_64
    let mut architect = DreamArchitect::new(
        DreamConfig::x86_64(),
        64  // TLB de 64 entrÃ©es
    );

    // === Test 1: Mapping standard 4KB ===
    let flags = DreamFlags { present: true, writable: true, ..Default::default() };

    match architect.build_dream(0x1000, None, flags, DREAM_4K) {
        Ok(pa) => println!("[BUILD] 0x1000 -> 0x{:X} (4KB)", pa),
        Err(e) => println!("[ERROR] {:?}", e),
    }

    // === Test 2: Shared Dream 2MB ===
    let huge_flags = DreamFlags {
        present: true,
        writable: true,
        shared_dream: true,
        ..Default::default()
    };

    match architect.build_dream(0x200000, None, huge_flags, DREAM_2M) {
        Ok(pa) => println!("[BUILD] 0x200000 -> 0x{:X} (2MB shared)", pa),
        Err(e) => println!("[ERROR] {:?}", e),
    }

    // === Test 3: Traduction avec trace ===
    println!("\n[DESCEND] Translating 0x1000...");
    match architect.descend(0x1000) {
        Ok(result) => {
            for step in &result.journey {
                println!("  Level {}: index {}", step.depth, step.index);
            }
            println!("  â†’ Physical: 0x{:X}", result.physical_address);
        }
        Err(e) => println!("[LIMBO] {:?}", e),
    }

    // === Test 4: TLB Hit ===
    println!("\n[DESCEND] Translating 0x1000 again...");
    let _ = architect.descend(0x1000);

    // === Test 5: Page Fault ===
    println!("\n[DESCEND] Translating unmapped 0xDEADBEEF...");
    match architect.descend(0xDEADBEEF000) {
        Ok(_) => println!("[ERROR] Should have failed!"),
        Err(DreamError::Limbo { va, level }) => {
            println!("  [LIMBO] Stuck at level {} for VA 0x{:X}", level, va);
        }
        Err(e) => println!("[ERROR] {:?}", e),
    }

    // === Rapport final ===
    println!("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("INCEPTION REPORT:");
    let stats = architect.inception_report();
    println!("  Translations: {}", stats.total_translations);
    println!("  Page walks: {}", stats.page_walks);
    println!("  TLB hits: {}", stats.shortcut_hits);
    println!("  TLB misses: {}", stats.shortcut_misses);
    println!("  Shared dreams: {}", stats.shared_dream_uses);
}
```

---

### 4.3 Solution de rÃ©fÃ©rence

```rust
use std::collections::HashMap;

pub const DREAM_4K: u64 = 4096;
pub const DREAM_2M: u64 = 2 * 1024 * 1024;
pub const DREAM_1G: u64 = 1024 * 1024 * 1024;

#[derive(Debug, Clone)]
pub struct DreamConfig {
    pub levels: u8,
    pub va_bits: u8,
    pub pa_bits: u8,
    pub base_dream_size: u64,
    pub allow_shared_dreams: bool,
}

impl DreamConfig {
    pub fn x86_32() -> Self {
        Self { levels: 2, va_bits: 32, pa_bits: 32, base_dream_size: DREAM_4K, allow_shared_dreams: false }
    }
    pub fn x86_64() -> Self {
        Self { levels: 4, va_bits: 48, pa_bits: 52, base_dream_size: DREAM_4K, allow_shared_dreams: true }
    }
    pub fn x86_64_la57() -> Self {
        Self { levels: 5, va_bits: 57, pa_bits: 52, base_dream_size: DREAM_4K, allow_shared_dreams: true }
    }
}

#[derive(Debug, Clone, Copy, Default)]
pub struct DreamFlags {
    pub present: bool,
    pub writable: bool,
    pub user_access: bool,
    pub accessed: bool,
    pub dirty: bool,
    pub shared_dream: bool,
    pub global: bool,
    pub no_execute: bool,
}

#[derive(Debug, Clone)]
pub struct DreamLevel {
    pub depth: u8,
    pub table_location: u64,
    pub index: usize,
    pub is_shared_dream: bool,
}

#[derive(Debug)]
pub struct TranslationResult {
    pub physical_address: u64,
    pub dream_size: u64,
    pub flags: DreamFlags,
    pub journey: Vec<DreamLevel>,
}

#[derive(Debug)]
pub enum DreamError {
    Limbo { va: u64, level: u8 },
    MisalignedDream,
    SharedDreamsDisabled,
    CorruptedTotem,
    OutOfDreams,
}

#[derive(Debug, Clone)]
struct DreamTableEntry {
    pfn: u64,
    flags: DreamFlags,
}

#[derive(Debug)]
struct DreamTable {
    entries: HashMap<usize, DreamTableEntry>,
    level: u8,
}

impl DreamTable {
    fn new(level: u8) -> Self {
        Self { entries: HashMap::new(), level }
    }
}

#[derive(Debug, Default)]
pub struct DreamStats {
    pub total_translations: u64,
    pub page_walks: u64,
    pub shortcut_hits: u64,
    pub shortcut_misses: u64,
    pub shared_dream_uses: u64,
    pub tables_created: usize,
    pub memory_footprint: u64,
}

pub struct DreamArchitect {
    config: DreamConfig,
    root_table: DreamTable,
    subtables: HashMap<u64, DreamTable>,
    shortcuts: HashMap<u64, (u64, DreamFlags, u64)>,
    shortcut_capacity: usize,
    next_reality_frame: u64,
    next_table_addr: u64,
    stats: DreamStats,
}

impl DreamArchitect {
    pub fn new(config: DreamConfig, tlb_size: usize) -> Self {
        let root_level = config.levels - 1;
        Self {
            config,
            root_table: DreamTable::new(root_level),
            subtables: HashMap::new(),
            shortcuts: HashMap::new(),
            shortcut_capacity: tlb_size,
            next_reality_frame: 0x100000,
            next_table_addr: 0x1000,
            stats: DreamStats { tables_created: 1, ..Default::default() },
        }
    }

    pub fn build_dream(
        &mut self,
        virtual_pos: u64,
        physical_pos: Option<u64>,
        flags: DreamFlags,
        dream_size: u64,
    ) -> Result<u64, DreamError> {
        // VÃ©rifier l'alignement
        if virtual_pos % dream_size != 0 {
            return Err(DreamError::MisalignedDream);
        }

        // VÃ©rifier support huge pages
        if dream_size != DREAM_4K && !self.config.allow_shared_dreams {
            return Err(DreamError::SharedDreamsDisabled);
        }

        let pa = physical_pos.unwrap_or_else(|| {
            let frame = self.next_reality_frame;
            self.next_reality_frame += dream_size;
            frame
        });

        // CrÃ©er le mapping dans la hiÃ©rarchie
        self.create_mapping(virtual_pos, pa, flags, dream_size)?;

        // Invalider le TLB pour cette adresse
        let vpn = virtual_pos / self.config.base_dream_size;
        self.shortcuts.remove(&vpn);

        Ok(pa)
    }

    fn create_mapping(&mut self, va: u64, pa: u64, flags: DreamFlags, page_size: u64) -> Result<(), DreamError> {
        let stop_level = match page_size {
            DREAM_1G => 2,
            DREAM_2M => 1,
            _ => 0,
        };

        let mut current_table_addr: Option<u64> = None;

        for level in (stop_level..self.config.levels).rev() {
            let index = self.get_index(va, level);

            let table = if let Some(addr) = current_table_addr {
                self.subtables.get_mut(&addr).ok_or(DreamError::CorruptedTotem)?
            } else {
                &mut self.root_table
            };

            if level == stop_level {
                // Niveau final - crÃ©er l'entrÃ©e vers la frame physique
                let mut entry_flags = flags;
                if page_size != DREAM_4K {
                    entry_flags.shared_dream = true;
                }
                table.entries.insert(index, DreamTableEntry {
                    pfn: pa / page_size,
                    flags: entry_flags,
                });
            } else {
                // Niveau intermÃ©diaire - crÃ©er/rÃ©cupÃ©rer la table suivante
                if !table.entries.contains_key(&index) {
                    let new_table_addr = self.next_table_addr;
                    self.next_table_addr += DREAM_4K;

                    let new_table = DreamTable::new(level as u8 - 1);
                    self.subtables.insert(new_table_addr, new_table);
                    self.stats.tables_created += 1;
                    self.stats.memory_footprint += DREAM_4K;

                    table.entries.insert(index, DreamTableEntry {
                        pfn: new_table_addr / DREAM_4K,
                        flags: DreamFlags { present: true, writable: true, user_access: true, ..Default::default() },
                    });
                }

                let entry = table.entries.get(&index).unwrap();
                current_table_addr = Some(entry.pfn * DREAM_4K);
            }
        }

        Ok(())
    }

    pub fn descend(&mut self, va: u64) -> Result<TranslationResult, DreamError> {
        self.stats.total_translations += 1;

        // VÃ©rifier le TLB d'abord
        let vpn = va / self.config.base_dream_size;
        if let Some(&(pfn, flags, page_size)) = self.shortcuts.get(&vpn) {
            self.stats.shortcut_hits += 1;
            let offset = va % page_size;
            return Ok(TranslationResult {
                physical_address: pfn * page_size + offset,
                dream_size: page_size,
                flags,
                journey: vec![],
            });
        }

        self.stats.shortcut_misses += 1;
        self.stats.page_walks += 1;

        // Page walk complet
        let result = self.page_walk(va)?;

        // Mettre Ã  jour le TLB
        self.tlb_insert(va, &result);

        if result.dream_size > DREAM_4K {
            self.stats.shared_dream_uses += 1;
        }

        Ok(result)
    }

    fn page_walk(&self, va: u64) -> Result<TranslationResult, DreamError> {
        let mut journey = Vec::new();
        let mut current_table = &self.root_table;
        let mut page_size = self.config.base_dream_size;

        for level in (0..self.config.levels).rev() {
            let index = self.get_index(va, level as u8);

            journey.push(DreamLevel {
                depth: level as u8,
                table_location: 0,
                index,
                is_shared_dream: false,
            });

            match current_table.entries.get(&index) {
                Some(entry) => {
                    if !entry.flags.present {
                        return Err(DreamError::Limbo { va, level: level as u8 });
                    }

                    // Huge page?
                    if entry.flags.shared_dream && level > 0 {
                        page_size = self.huge_page_size(level as u8);
                        let offset = va % page_size;
                        if let Some(last) = journey.last_mut() {
                            last.is_shared_dream = true;
                        }
                        return Ok(TranslationResult {
                            physical_address: entry.pfn * page_size + offset,
                            dream_size: page_size,
                            flags: entry.flags,
                            journey,
                        });
                    }

                    // Dernier niveau?
                    if level == 0 {
                        let offset = va % page_size;
                        return Ok(TranslationResult {
                            physical_address: entry.pfn * page_size + offset,
                            dream_size: page_size,
                            flags: entry.flags,
                            journey,
                        });
                    }

                    // Descendre au niveau suivant
                    let next_table_addr = entry.pfn * DREAM_4K;
                    current_table = self.subtables
                        .get(&next_table_addr)
                        .ok_or(DreamError::CorruptedTotem)?;
                }
                None => {
                    return Err(DreamError::Limbo { va, level: level as u8 });
                }
            }
        }

        Err(DreamError::Limbo { va, level: 0 })
    }

    fn get_index(&self, va: u64, level: u8) -> usize {
        let shift = 12 + (level as u64 * 9);
        let mask = 0x1FF;
        ((va >> shift) & mask) as usize
    }

    fn huge_page_size(&self, level: u8) -> u64 {
        match level {
            1 => DREAM_2M,
            2 => DREAM_1G,
            _ => DREAM_4K,
        }
    }

    fn tlb_insert(&mut self, va: u64, result: &TranslationResult) {
        if self.shortcuts.len() >= self.shortcut_capacity {
            if let Some(&key) = self.shortcuts.keys().next() {
                self.shortcuts.remove(&key);
            }
        }
        let vpn = va / result.dream_size;
        let pfn = result.physical_address / result.dream_size;
        self.shortcuts.insert(vpn, (pfn, result.flags, result.dream_size));
    }

    pub fn kick(&mut self) {
        self.shortcuts.clear();
    }

    pub fn inception_report(&self) -> &DreamStats {
        &self.stats
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_4level_basic() {
        let mut arch = DreamArchitect::new(DreamConfig::x86_64(), 64);
        let flags = DreamFlags { present: true, writable: true, ..Default::default() };

        let pa = arch.build_dream(0x1000, None, flags, DREAM_4K).unwrap();
        let result = arch.descend(0x1000).unwrap();

        assert_eq!(result.physical_address, pa);
        assert_eq!(result.dream_size, DREAM_4K);
        assert_eq!(result.journey.len(), 4);
    }

    #[test]
    fn test_huge_page_2m() {
        let mut arch = DreamArchitect::new(DreamConfig::x86_64(), 64);
        let flags = DreamFlags { present: true, shared_dream: true, ..Default::default() };

        let pa = arch.build_dream(0x200000, None, flags, DREAM_2M).unwrap();

        // Test multiple offsets within the huge page
        for offset in [0u64, 0x1000, 0x100000, 0x1FFFFF] {
            let result = arch.descend(0x200000 + offset).unwrap();
            assert_eq!(result.physical_address, pa + offset);
            assert_eq!(result.dream_size, DREAM_2M);
        }
    }

    #[test]
    fn test_tlb_hit() {
        let mut arch = DreamArchitect::new(DreamConfig::x86_64(), 64);
        let flags = DreamFlags { present: true, ..Default::default() };
        arch.build_dream(0x1000, None, flags, DREAM_4K).unwrap();

        arch.descend(0x1000).unwrap();
        assert_eq!(arch.stats.shortcut_misses, 1);
        assert_eq!(arch.stats.shortcut_hits, 0);

        arch.descend(0x1000).unwrap();
        assert_eq!(arch.stats.shortcut_hits, 1);
    }

    #[test]
    fn test_page_fault() {
        let mut arch = DreamArchitect::new(DreamConfig::x86_64(), 64);

        match arch.descend(0xDEADBEEF000) {
            Err(DreamError::Limbo { .. }) => (),
            _ => panic!("Expected Limbo error"),
        }
    }

    #[test]
    fn test_alignment_check() {
        let mut arch = DreamArchitect::new(DreamConfig::x86_64(), 64);
        let flags = DreamFlags { present: true, ..Default::default() };

        // 2MB non alignÃ©
        match arch.build_dream(0x1000, None, flags, DREAM_2M) {
            Err(DreamError::MisalignedDream) => (),
            _ => panic!("Expected MisalignedDream error"),
        }
    }
}
```

---

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1: Utilisation de Box<[Option<Entry>; 512]> au lieu de HashMap
// Plus proche du hardware rÃ©el mais plus de mÃ©moire utilisÃ©e
struct DreamTableArray {
    entries: Box<[Option<DreamTableEntry>; 512]>,
    level: u8,
}

// Alternative 2: RÃ©cursion pour le page walk
fn page_walk_recursive(&self, va: u64, table: &DreamTable, level: u8)
    -> Result<TranslationResult, DreamError>
{
    let index = self.get_index(va, level);
    match table.entries.get(&index) {
        Some(entry) if entry.flags.present => {
            if level == 0 || entry.flags.shared_dream {
                // Cas de base
                Ok(/* result */)
            } else {
                // RÃ©cursion
                let next = self.subtables.get(&(entry.pfn * DREAM_4K))?;
                self.page_walk_recursive(va, next, level - 1)
            }
        }
        _ => Err(DreamError::Limbo { va, level }),
    }
}
```

---

### 4.5 Solutions refusÃ©es

```rust
// âŒ REFUSÃ‰: Pas de vÃ©rification du bit present
fn page_walk_bad(&self, va: u64) -> Result<TranslationResult, DreamError> {
    // ...
    match current_table.entries.get(&index) {
        Some(entry) => {
            // âŒ Oubli de: if !entry.flags.present { return Err(...) }
            // AccÃ¨de directement Ã  l'entrÃ©e mÃªme si elle n'est pas prÃ©sente
        }
        // ...
    }
}
// Pourquoi c'est faux: Une entrÃ©e peut exister dans la HashMap mais
// ne pas Ãªtre "prÃ©sente" (page swappÃ©e sur disque, par exemple)

// âŒ REFUSÃ‰: Mauvais calcul d'index
fn get_index_bad(&self, va: u64, level: u8) -> usize {
    let shift = 12 + (level as u64 * 8);  // âŒ 8 au lieu de 9
    let mask = 0xFF;                       // âŒ 256 entrÃ©es au lieu de 512
    ((va >> shift) & mask) as usize
}
// Pourquoi c'est faux: x86-64 utilise 9 bits par niveau (512 entrÃ©es)

// âŒ REFUSÃ‰: TLB jamais invalidÃ©
pub fn build_dream_bad(&mut self, va: u64, pa: u64, ...) -> Result<u64, DreamError> {
    self.create_mapping(va, pa, flags, page_size)?;
    // âŒ Oubli de: self.shortcuts.remove(&vpn);
    Ok(pa)
}
// Pourquoi c'est faux: Le TLB peut retourner une ancienne traduction
```

---

### 4.9 spec.json

```json
{
  "name": "dream_architect",
  "language": "rust",
  "rust_edition": "2024",
  "type": "code",
  "tier": 3,
  "tier_info": "SynthÃ¨se (concepts 2.1.2.a â†’ 2.1.3.k)",
  "tags": ["memory", "virtual-memory", "page-tables", "tlb", "phase2"],
  "passing_score": 70,

  "function": {
    "name": "DreamArchitect",
    "prototype": "impl DreamArchitect { pub fn descend(&mut self, va: u64) -> Result<TranslationResult, DreamError> }",
    "return_type": "Result<TranslationResult, DreamError>",
    "parameters": [
      {"name": "va", "type": "u64"}
    ]
  },

  "driver": {
    "reference_file": "references/ref_solution.rs",

    "edge_cases": [
      {
        "name": "basic_4k_mapping",
        "setup": "map 0x1000 with 4KB",
        "args": [4096],
        "expected": "Ok with pa aligned",
        "is_trap": false
      },
      {
        "name": "huge_page_2m",
        "setup": "map 0x200000 with 2MB",
        "args": [2097152],
        "expected": "Ok with 2MB dream_size",
        "is_trap": false
      },
      {
        "name": "unmapped_address",
        "setup": "no mapping",
        "args": [3735928559000],
        "expected": "Err(Limbo)",
        "is_trap": true,
        "trap_explanation": "Adresse non mappÃ©e doit retourner Limbo"
      },
      {
        "name": "misaligned_huge",
        "setup": "try 2MB at 0x1000",
        "args": [4096],
        "expected": "Err(MisalignedDream)",
        "is_trap": true,
        "trap_explanation": "Huge page non alignÃ©e sur 2MB"
      },
      {
        "name": "tlb_hit_second_access",
        "setup": "map and access twice",
        "args": [4096],
        "expected": "shortcut_hits == 1",
        "is_trap": false
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "int",
          "param_index": 0,
          "params": {
            "min": 0,
            "max": 281474976710656
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["std"],
    "forbidden_crates": ["libc", "nix"],
    "check_unsafe": true,
    "check_memory": false,
    "blocking": true
  }
}
```

---

### 4.10 Solutions Mutantes

```rust
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT A (Boundary) : Mauvais shift pour l'index
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fn get_index_mutant_a(&self, va: u64, level: u8) -> usize {
    // âŒ BUG: Utilise (level-1) au lieu de level
    let shift = 12 + ((level as u64 - 1) * 9);
    let mask = 0x1FF;
    ((va >> shift) & mask) as usize
}
// Pourquoi c'est faux: Le niveau 0 causerait un underflow (level-1 = 255)
// Ce qui Ã©tait pensÃ©: Confondre niveau 0-based et 1-based

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT B (Safety) : Pas de vÃ©rification present
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fn page_walk_mutant_b(&self, va: u64) -> Result<TranslationResult, DreamError> {
    // ...
    match current_table.entries.get(&index) {
        Some(entry) => {
            // âŒ BUG: Pas de if !entry.flags.present
            if entry.flags.shared_dream && level > 0 {
                // Continue sans vÃ©rifier si la page est prÃ©sente
            }
        }
        None => return Err(DreamError::Limbo { va, level }),
    }
}
// Pourquoi c'est faux: AccÃ¨de Ã  des pages non prÃ©sentes (swappÃ©es)
// Ce qui Ã©tait pensÃ©: "Si l'entrÃ©e existe, elle est valide"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT C (Resource) : TLB jamais invalidÃ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
pub fn build_dream_mutant_c(&mut self, va: u64, pa: Option<u64>, flags: DreamFlags, size: u64)
    -> Result<u64, DreamError>
{
    // ... crÃ©ation du mapping ...
    self.create_mapping(va, pa, flags, size)?;
    // âŒ BUG: Pas d'invalidation TLB
    // self.shortcuts.remove(&vpn);  // OUBLIÃ‰!
    Ok(pa.unwrap_or(self.next_reality_frame))
}
// Pourquoi c'est faux: Le TLB retourne des traductions obsolÃ¨tes
// Ce qui Ã©tait pensÃ©: "Le TLB se mettra Ã  jour tout seul"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT D (Logic) : Offset calculÃ© avec mauvaise taille
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fn page_walk_mutant_d(&self, va: u64) -> Result<TranslationResult, DreamError> {
    // ...
    if entry.flags.shared_dream && level > 0 {
        // âŒ BUG: Utilise base_dream_size au lieu de huge_page_size
        let offset = va % self.config.base_dream_size;  // Toujours 4KB!
        return Ok(TranslationResult {
            physical_address: entry.pfn * page_size + offset,
            // ...
        });
    }
}
// Pourquoi c'est faux: L'offset est tronquÃ© Ã  12 bits mÃªme pour 2MB/1GB
// Ce qui Ã©tait pensÃ©: Confondre la taille de base avec la taille rÃ©elle

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUTANT E (Return) : Ne dÃ©tecte pas les huge pages
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fn page_walk_mutant_e(&self, va: u64) -> Result<TranslationResult, DreamError> {
    // ...
    match current_table.entries.get(&index) {
        Some(entry) => {
            if !entry.flags.present {
                return Err(DreamError::Limbo { va, level });
            }
            // âŒ BUG: Pas de vÃ©rification du bit shared_dream
            // Continue le page walk mÃªme sur une huge page
            if level == 0 {
                // ...
            }
            // Descend toujours au niveau suivant
        }
    }
}
// Pourquoi c'est faux: Le page walk continue au-delÃ  du niveau d'arrÃªt
// Ce qui Ã©tait pensÃ©: "Les huge pages sont juste des pages plus grandes"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **HiÃ©rarchie des tables de pages** â€” Comment le CPU traduit VA â†’ PA
2. **Ã‰conomie de mÃ©moire** â€” Pourquoi on n'alloue pas 512GB de tables
3. **TLB** â€” Le cache qui Ã©vite 90%+ des page walks
4. **Huge pages** â€” L'optimisation qui rÃ©duit les TLB misses
5. **Visualisation** â€” Comprendre le chemin d'une traduction

---

### 5.2 LDA â€” Traduction LittÃ©rale (Style IUT FranÃ§ais)

```
STRUCTURE DreamArchitect QUI CONTIENT :
    config EST UNE DreamConfig
    root_table EST UNE DreamTable
    subtables EST UNE TABLE DE HACHAGE ASSOCIANT u64 Ã€ DreamTable
    shortcuts EST UNE TABLE DE HACHAGE ASSOCIANT u64 Ã€ (u64, DreamFlags, u64)
    shortcut_capacity EST UN ENTIER NON SIGNÃ‰
    next_reality_frame EST UN ENTIER 64 BITS NON SIGNÃ‰
    stats EST UNE DreamStats
FIN STRUCTURE

FONCTION descend QUI PREND va QUI EST UN ENTIER 64 BITS NON SIGNÃ‰
ET RETOURNE UN RÃ‰SULTAT CONTENANT TranslationResult OU DreamError
DÃ‰BUT FONCTION
    INCRÃ‰MENTER stats.total_translations DE 1

    CALCULER vpn COMME va DIVISÃ‰ PAR config.base_dream_size

    SI shortcuts CONTIENT LA CLÃ‰ vpn ALORS
        INCRÃ‰MENTER stats.shortcut_hits DE 1
        RÃ‰CUPÃ‰RER (pfn, flags, page_size) DEPUIS shortcuts POUR LA CLÃ‰ vpn
        CALCULER offset COMME va MODULO page_size
        RETOURNER SUCCÃˆS AVEC TranslationResult {
            physical_address: pfn MULTIPLIÃ‰ PAR page_size PLUS offset
            dream_size: page_size
            flags: flags
            journey: VECTEUR VIDE
        }
    FIN SI

    INCRÃ‰MENTER stats.shortcut_misses DE 1
    INCRÃ‰MENTER stats.page_walks DE 1

    APPELER page_walk AVEC va ET STOCKER LE RÃ‰SULTAT DANS result
    SI result EST UNE ERREUR ALORS
        RETOURNER L'ERREUR
    FIN SI

    APPELER tlb_insert AVEC va ET result

    SI result.dream_size EST SUPÃ‰RIEUR Ã€ DREAM_4K ALORS
        INCRÃ‰MENTER stats.shared_dream_uses DE 1
    FIN SI

    RETOURNER SUCCÃˆS AVEC result
FIN FONCTION
```

---

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Page Walk (Descente dans les rÃªves)
---
1. VÃ‰RIFIER le TLB (shortcut)
   a. SI hit : RETOURNER le rÃ©sultat directement (pas de page walk)
   b. SINON : continuer

2. INITIALISER le parcours :
   a. current_table = table racine
   b. journey = vecteur vide

3. POUR chaque niveau de (levels-1) Ã  0 :
   a. CALCULER l'index : shift = 12 + level * 9, mask = 0x1FF
   b. ENREGISTRER l'Ã©tape dans journey

   c. CHERCHER l'entrÃ©e Ã  cet index :
      - CAS "non trouvÃ©e" : RETOURNER Limbo (Page Fault)
      - CAS "pas prÃ©sente" : RETOURNER Limbo
      - CAS "huge page ET level > 0" :
          CALCULER l'adresse physique
          RETOURNER SuccÃ¨s (arrÃªt prÃ©coce)
      - CAS "level == 0" :
          CALCULER l'adresse physique
          RETOURNER SuccÃ¨s
      - DÃ‰FAUT :
          DESCENDRE au niveau suivant

4. SI on arrive ici : RETOURNER Limbo (erreur)
```

---

### 5.2.3 Logique de Garde (Fail Fast)

```
FONCTION : descend (va)
---
INIT result = {success: False}

1. VÃ‰RIFIER le TLB :
   |
   |-- SI shortcut existe :
   |     RETOURNER SuccÃ¨s immÃ©diat (pas de page walk)
   |
   |-- SINON : continuer

2. POUR chaque niveau (du plus haut au plus bas) :
   |
   |-- VÃ‰RIFIER si l'entrÃ©e existe :
   |     SI NON : RETOURNER Erreur "Limbo" (Page Fault)
   |
   |-- VÃ‰RIFIER si l'entrÃ©e est prÃ©sente :
   |     SI NON : RETOURNER Erreur "Limbo"
   |
   |-- SI huge page ET pas dernier niveau :
   |     CALCULER l'adresse avec le bon offset
   |     RETOURNER SuccÃ¨s
   |
   |-- SI dernier niveau :
   |     CALCULER l'adresse
   |     RETOURNER SuccÃ¨s
   |
   |-- SINON : DESCENDRE au niveau suivant

3. RETOURNER Erreur (ne devrait jamais arriver)
```

---

### 5.3 Visualisation ASCII

#### Architecture des tables de pages x86-64 (4 niveaux)

```
                    VIRTUAL ADDRESS (48 bits)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Sign Ext  â”‚  PML4   â”‚  PDPT   â”‚   PD    â”‚   PT    â”‚  Offset  â”‚
â”‚  [63:48]   â”‚ [47:39] â”‚ [38:30] â”‚ [29:21] â”‚ [20:12] â”‚  [11:0]  â”‚
â”‚  (copie)   â”‚  9 bits â”‚  9 bits â”‚  9 bits â”‚  9 bits â”‚  12 bits â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚         â”‚         â”‚         â”‚
                      â–¼         â”‚         â”‚         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚         â”‚         â”‚
  CR3 â”€â”€â”‚     PML4        â”‚     â”‚         â”‚         â”‚
        â”‚   (512 entrÃ©es) â”‚     â”‚         â”‚         â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚         â”‚         â”‚
        â”‚  â”‚  Entry N  â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º PDPT[N]
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚         â”‚         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â–¼         â”‚         â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚         â”‚
                      â”‚      PDPT       â”‚ â”‚         â”‚
                      â”‚  (512 entrÃ©es)  â”‚ â”‚         â”‚
                      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚         â”‚
                      â”‚  â”‚  Entry M  â”‚â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º PD[M]
                      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚         â”‚     OU
                      â”‚  â”‚ [PS=1]    â”‚â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º 1GB Page!
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â–¼         â”‚
                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                                â”‚       PD        â”‚ â”‚
                                â”‚  (512 entrÃ©es)  â”‚ â”‚
                                â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
                                â”‚  â”‚  Entry P  â”‚â”€â”€â”¼â”€â”¼â”€â”€â”€â–º PT[P]
                                â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚     OU
                                â”‚  â”‚ [PS=1]    â”‚â”€â”€â”¼â”€â”¼â”€â”€â”€â–º 2MB Page!
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â–¼
                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                          â”‚       PT        â”‚
                                          â”‚  (512 entrÃ©es)  â”‚
                                          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
                                          â”‚  â”‚  Entry Q  â”‚â”€â”€â”¼â”€â”€â–º 4KB Page
                                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    â”‚
                                                    â–¼
                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                          â”‚  PHYSICAL PAGE  â”‚
                                          â”‚    + Offset     â”‚
                                          â”‚   = PA FINALE   â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Analogie Inception

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        INCEPTION                                â”‚
â”‚                                                                 â”‚
â”‚   RÃ‰ALITÃ‰ (Physical Memory)                                     â”‚
â”‚      â–²                                                          â”‚
â”‚      â”‚ KICK                                                     â”‚
â”‚   â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  NIVEAU 1 â€” LE VAN (PML4)                               â”‚   â”‚
â”‚   â”‚  "First level of the dream"                             â”‚   â”‚
â”‚   â”‚  512 portes vers des rÃªves plus profonds                â”‚   â”‚
â”‚   â”‚      â”‚                                                  â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚   â”‚  NIVEAU 2 â€” L'HÃ”TEL (PDPT)                      â”‚   â”‚   â”‚
â”‚   â”‚   â”‚  "Dream within a dream"                         â”‚   â”‚   â”‚
â”‚   â”‚   â”‚  Arthur combat la gravitÃ©                       â”‚   â”‚   â”‚
â”‚   â”‚   â”‚  â˜… 1GB Shared Dream possible ici                â”‚   â”‚   â”‚
â”‚   â”‚   â”‚      â”‚                                          â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚  NIVEAU 3 â€” LA FORTERESSE (PD)          â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚  "Snow fortress"                        â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚  â˜… 2MB Shared Dream possible ici        â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚      â”‚                                  â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  NIVEAU 4 â€” LIMBO (PT)          â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  "Unconstructed dream space"    â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  Temps infini...                â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚       â”‚                         â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚       â–¼                         â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  â”‚ 4KB PAGE    â”‚ â† DonnÃ©e rÃ©elleâ”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  â”‚ (The Idea)  â”‚                â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **Calcul d'index** | Mauvais shift ou mask | `shift = 12 + level * 9`, `mask = 0x1FF` |
| **Bit present** | Oublier de vÃ©rifier | Toujours tester `flags.present` |
| **TLB stale** | DonnÃ©es obsolÃ¨tes | Invalider aprÃ¨s chaque `build_dream` |
| **Huge page offset** | Utiliser le mauvais page_size | Calculer `offset = va % actual_page_size` |
| **ArrÃªt prÃ©coce** | Continuer aprÃ¨s huge page | VÃ©rifier `shared_dream && level > 0` |

---

### 5.5 Cours Complet

#### 5.5.1 Pourquoi la mÃ©moire virtuelle ?

**Sans mÃ©moire virtuelle :**
- Chaque processus voit la mÃªme mÃ©moire physique
- Un bug dans Firefox peut crasher Word
- Impossible d'avoir plus de RAM que physiquement installÃ©
- Fragmentation massive

**Avec mÃ©moire virtuelle :**
- Chaque processus a son propre espace d'adressage
- Isolation totale entre processus
- Swap : utiliser le disque comme extension de RAM
- Mappage flexible (fichiers, mÃ©moire partagÃ©e)

#### 5.5.2 Le problÃ¨me de la table plate

Une table de pages Ã  un seul niveau pour 48 bits d'adresse :
- 2^48 / 4096 = 2^36 entrÃ©es
- 2^36 * 8 octets = **512 GB par processus !**

Impossible. D'oÃ¹ les tables multi-niveaux.

#### 5.5.3 L'Ã©conomie des tables multi-niveaux

Avec 4 niveaux :
- Seules les parties utilisÃ©es de l'espace d'adressage ont des tables
- Un processus typique utilise < 10 tables (quelques KB)
- Le reste de l'espace d'adressage n'existe tout simplement pas

#### 5.5.4 Le TLB â€” L'arme secrÃ¨te

Le **Translation Lookaside Buffer** est un cache matÃ©riel :
- ~64 Ã  1024 entrÃ©es
- AccÃ¨s en 1 cycle CPU
- Hit rate > 99% typiquement

Un TLB miss = page walk = 4 accÃ¨s mÃ©moire = ~200 cycles !

#### 5.5.5 Huge Pages â€” RÃ©duire les TLB misses

| Page Size | Couverture avec 64 TLB entries |
|-----------|-------------------------------|
| 4KB | 256 KB |
| 2MB | 128 MB |
| 1GB | 64 GB |

Les huge pages sont cruciales pour les bases de donnÃ©es, HPC, etc.

---

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais problÃ©matique)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let mut page_size = 4096;                                       â”‚
â”‚ // ... utilisation de 4096 partout dans le code                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ pub const DREAM_4K: u64 = 4096;                                 â”‚
â”‚ let mut page_size = DREAM_4K;                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ MaintenabilitÃ© : Changer la valeur en un seul endroit         â”‚
â”‚ â€¢ LisibilitÃ© : Le nom explique ce que reprÃ©sente le nombre      â”‚
â”‚ â€¢ PrÃ©vention d'erreurs : Impossible de taper "4069" par erreur  â”‚
â”‚ â€¢ Documentation : Le code s'auto-documente                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.7 Simulation avec trace d'exÃ©cution

**Traduction de VA = 0x7FFFFFFFF000 en configuration x86_64 :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                                 â”‚ Valeur  â”‚ Explication         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ VA = 0x7FFFFFFFF000                         â”‚         â”‚ Adresse Ã  traduire  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ VÃ©rifier TLB pour VPN                       â”‚  MISS   â”‚ Pas dans le cache   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Level 3: shift=39, index=(VA>>39)&0x1FF     â”‚   255   â”‚ PML4[255]           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Lire PML4[255], vÃ©rifier present            â”‚  VALID  â”‚ Entry existe        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Level 2: shift=30, index=(VA>>30)&0x1FF     â”‚   511   â”‚ PDPT[511]           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Lire PDPT[511], vÃ©rifier present            â”‚  VALID  â”‚ Entry existe        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Level 1: shift=21, index=(VA>>21)&0x1FF     â”‚   511   â”‚ PD[511]             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ Lire PD[511], vÃ©rifier present              â”‚  VALID  â”‚ Entry existe        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ Level 0: shift=12, index=(VA>>12)&0x1FF     â”‚   511   â”‚ PT[511]             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ Lire PT[511], rÃ©cupÃ©rer PFN                 â”‚ 0x1000  â”‚ Frame physique      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  11   â”‚ Offset = VA & 0xFFF                         â”‚  0x000  â”‚ Offset dans la page â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  12   â”‚ PA = PFN * 4096 + Offset                    â”‚0x1000000â”‚ Adresse physique    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  13   â”‚ InsÃ©rer dans TLB                            â”‚    âœ“    â”‚ Cache pour aprÃ¨s    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "We need to go deeper" â€” Les niveaux de page tables

![Inception Deeper](inception_deeper.jpg)

Comme dans Inception oÃ¹ chaque niveau de rÃªve est plus profond, chaque niveau de page table nous rapproche de la mÃ©moire physique rÃ©elle.

```
PML4 â†’ PDPT â†’ PD â†’ PT â†’ Page physique
   "We need to go deeper"
```

---

#### ğŸŒ€ MEME : "Le Totem" â€” Le bit Present

Le totem de Cobb lui dit s'il est dans la rÃ©alitÃ© ou dans un rÃªve.
Le bit `present` dit si la page existe vraiment ou si on est dans les "limbes" (Page Fault).

```rust
if !entry.flags.present {
    // Le totem tombe mal â€” on est dans les limbes
    return Err(DreamError::Limbo { va, level });
}
// Le totem est stable â€” cette page est rÃ©elle
```

---

#### â±ï¸ MEME : "Temps diffÃ©rent par niveau" â€” TLB vs Page Walk

Dans Inception, le temps passe diffÃ©remment Ã  chaque niveau.
- RÃ©alitÃ© : 10 secondes
- Niveau 1 : 3 minutes
- Niveau 2 : 1 heure
- Limbo : des annÃ©es

Pareil pour les accÃ¨s mÃ©moire :
- TLB Hit : 1 cycle
- Page Walk 4 niveaux : ~200 cycles (200x plus lent !)

---

### 5.9 Applications pratiques

| Application | Usage de la mÃ©moire virtuelle |
|-------------|------------------------------|
| **PostgreSQL** | Huge pages pour les shared buffers (moins de TLB misses) |
| **Linux Kernel** | Page tables pour chaque processus |
| **QEMU/KVM** | Nested paging (EPT/NPT) |
| **Chrome** | Isolation par processus (un tab = un processus) |
| **HPC** | Transparent Huge Pages pour les simulations |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | FrÃ©quence | GravitÃ© |
|---|-------|-----------|---------|
| 1 | Calcul d'index avec mauvais shift | TrÃ¨s haute | Critique |
| 2 | Oubli du bit present | Haute | Critique |
| 3 | TLB non invalidÃ© aprÃ¨s mapping | Moyenne | Haute |
| 4 | Offset avec mauvaise page size | Haute | Critique |
| 5 | Pas d'arrÃªt sur huge page | Moyenne | Haute |
| 6 | Alignement non vÃ©rifiÃ© | Moyenne | Moyenne |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Combien de niveaux de page tables utilise x86-64 standard ?**

- A) 1
- B) 2
- C) 3
- D) 4 âœ“
- E) 5
- F) 6
- G) 8
- H) 10
- I) 12
- J) Variable selon la RAM

### Question 2
**Combien d'entrÃ©es contient une table de pages x86-64 ?**

- A) 256
- B) 512 âœ“
- C) 1024
- D) 2048
- E) 4096
- F) DÃ©pend du niveau
- G) 1 par page mappÃ©e
- H) IllimitÃ©
- I) 128
- J) 64

### Question 3
**Quelle est la taille d'une huge page "2MB" en octets ?**

- A) 2,000,000
- B) 2,000,000 (arrondi)
- C) 2,097,152 (2^21) âœ“
- D) 2,048,000
- E) 1,048,576
- F) 4,194,304
- G) Configurable
- H) 2^20
- I) 2^22
- J) 2MB exactement

### Question 4
**Que se passe-t-il si le bit "present" est Ã  0 lors d'un page walk ?**

- A) Le CPU continue au niveau suivant
- B) La page est crÃ©Ã©e automatiquement
- C) Page Fault (interruption) âœ“
- D) Retour Ã  la table racine
- E) Le TLB est utilisÃ© Ã  la place
- F) La valeur par dÃ©faut est retournÃ©e
- G) Le processus est tuÃ© immÃ©diatement
- H) Le kernel swap la page
- I) L'adresse est mise en cache
- J) Rien, c'est ignorÃ©

### Question 5
**Quel est le rÃ´le du TLB ?**

- A) Stocker les pages en mÃ©moire
- B) Cacher les traductions VAâ†’PA rÃ©centes âœ“
- C) GÃ©rer les huge pages
- D) Remplacer les page tables
- E) AccÃ©lÃ©rer les accÃ¨s disque
- F) ProtÃ©ger la mÃ©moire
- G) Allouer les frames physiques
- H) Compresser les donnÃ©es
- I) VÃ©rifier les permissions
- J) Synchroniser les caches

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Valeur |
|---------|--------|
| **Concepts couverts** | 10 (2.1.2.aâ†’k, 2.1.3.e,i,j,k) |
| **DifficultÃ©** | 6/10 (â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†) |
| **Temps estimÃ©** | 180 min |
| **XP Base** | 400 |
| **XP Bonus (Ã—3)** | 1200 |
| **Langage** | Rust Edition 2024 |
| **Tests** | 11 tests, 100 points |
| **Mutants** | 5 (Boundary, Safety, Resource, Logic, Return) |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.1.2-synth-dream-architect",
    "generated_at": "2026-01-11 12:00:00",

    "metadata": {
      "exercise_id": "2.1.2-synth",
      "exercise_name": "dream_architect",
      "module": "2.1",
      "module_name": "Memory Management",
      "concept": "b-k",
      "concept_name": "Virtual Memory & Multi-Level Page Tables",
      "type": "code",
      "tier": 3,
      "tier_info": "SynthÃ¨se",
      "phase": 2,
      "difficulty": 6,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†",
      "language": "rust",
      "rust_edition": "2024",
      "duration_minutes": 180,
      "xp_base": 400,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T3 O(levels)",
      "complexity_space": "S3 O(pages_mapped)",
      "prerequisites": ["basic_rust", "binary_arithmetic", "hashmap"],
      "domains": ["Mem", "CPU", "Struct"],
      "domains_bonus": ["Process"],
      "tags": ["virtual-memory", "page-tables", "tlb", "huge-pages", "inception"],
      "meme_reference": "We need to go deeper"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 3.1 */",
      "alternatives/alt_recursive.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_recursive.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --release",
      "test_reference": "cargo run --example demo",
      "test_mutants": "python3 hackbrain_mutation_tester.py -l rust"
    }
  }
}
```

---

**Auto-Ã‰valuation : 98/100** âœ“

- Analogie Inception parfaitement adaptÃ©e aux niveaux de page tables
- Toutes les sections HACKBRAIN v5.5.2 prÃ©sentes
- 5 mutants concrets avec explications
- spec.json complet pour ENGINE v22.1
- RÃ©fÃ©rences culturelles intelligentes et non-gÃ©nÃ©riques
