<thinking>
## Analyse du Concept
- Concept : DNS Resolver Client
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le DNS est un protocole fondamental d'Internet. L'exercice combine parsing binaire, UDP networking, et gestion de cache.

## Combo Base + Bonus
- Exercice de base : Client DNS capable de construire des requetes, parser les reponses (avec compression), supporter A/AAAA/CNAME/MX/NS/TXT
- Bonus : Implementation d'un cache avec TTL et resolution recursive (suivre les CNAME)
- Palier bonus : EXPERT (protocole complexe + state management)
- Progression logique ? OUI - Base = query/response, Bonus = cache + recursion

## Prerequis & Difficulte
- Prerequis reels : tokio::net::UdpSocket, binary parsing (big-endian), HashMap, Instant
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Matrix" - L'Oracle qui revele les vraies adresses derriere les noms
- MEME mnemotonique : "There is no spoon, only IP addresses" (le nom n'est qu'une abstraction)
- Pourquoi c'est fun : DNS = Oracle du reseau, traduit les "noms humains" en "realite machine"

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Encoding) : Oubli du null-terminator dans encode_name -> serveur rejette
2. Mutant B (Endianness) : Little-endian au lieu de big-endian -> parsing corrompu
3. Mutant C (Pointer) : Pas de gestion des pointeurs de compression -> noms tronques
4. Mutant D (ID Match) : Pas de verification de l'ID reponse -> reponses melangees
5. Mutant E (TTL) : Cache sans expiration -> donnees obsoletes

## Verdict
VALIDE - Exercice avance couvrant le protocole DNS en profondeur
</thinking>

# Exercice 5.1.6-a : dns_resolver

**Module :**
5.1.6 - DNS Protocol & Resolution

**Concept :**
a - DNS Resolver Client (query building, response parsing, name compression)

**Difficulte :**
(8/10)

**Type :**
code

**Tiers :**
2 - Integration (UDP + parsing binaire + cache)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 - Types et ownership
- 2.3 - Traits et generics
- 5.1.1 - Fondamentaux reseau (IP, ports)
- 5.1.4 - UDP fundamentals
- Module 2.4 - I/O et parsing binaire

**Domaines :**
Net, Parse, Algo

**Duree estimee :**
180 min

**XP Base :**
250

**Complexite :**
T2 O(n) x S2 O(n) ou n = taille du message DNS

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
src/lib.rs
Cargo.toml
```

**Dependances autorisees :**
- `tokio` (runtime async, UdpSocket)
- `std::collections::HashMap`
- `std::net::{Ipv4Addr, Ipv6Addr, SocketAddr}`
- `std::time::{Duration, Instant}`

**Fonctions/methodes interdites :**
- Crates DNS externes (trust-dns, hickory-dns, etc.)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Oracle of Networks"**

*"Tu cherches google.com ? Ce n'est qu'un nom, une etiquette. La vraie question est : quelle est son adresse ? L'Oracle DNS connait la reponse. Mais pour l'interroger, tu dois parler son langage binaire."* - Morpheus, administrateur reseau

Dans le monde des reseaux, DNS (Domain Name System) est l'Oracle. Il traduit les noms humainement lisibles (google.com) en adresses IP (142.250.74.46). Sans DNS, tu devrais memoriser des sequences de chiffres pour chaque site.

**Ta mission :**

Implementer un client DNS capable de :
1. Construire des messages de requete DNS (header + question)
2. Encoder les noms de domaine en format DNS (labels)
3. Envoyer des requetes UDP a un serveur DNS (port 53)
4. Parser les reponses DNS completes
5. Gerer la compression des noms (pointeurs 0xC0)
6. Supporter les types A, AAAA, CNAME, MX, NS, TXT

**Format DNS Message :**
```
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |  16 bits
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |  16 bits flags
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QDCOUNT                    |  Question count
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ANCOUNT                    |  Answer count
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    NSCOUNT                    |  Authority count
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ARCOUNT                    |  Additional count
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

**Encoding des noms :**
- `www.example.com` -> `[3, 'w', 'w', 'w', 7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 3, 'c', 'o', 'm', 0]`
- Compression : pointeur `0xC0 | offset` renvoie vers un nom deja encode

**Entree :**
- `server: SocketAddr` - Serveur DNS (ex: "8.8.8.8:53")
- `name: &str` - Nom de domaine a resoudre
- `qtype: RecordType` - Type d'enregistrement demande

**Sortie :**
- `Result<Vec<DnsRecord>, DnsError>` - Enregistrements ou erreur

**Contraintes :**
- Tous les entiers sont en big-endian (network byte order)
- Le timeout de requete est de 5 secondes
- L'ID de requete doit etre unique et verifie dans la reponse
- La decompression des noms doit gerer les pointeurs recursifs

**Exemples :**

| Requete | Type | Reponse attendue |
|---------|------|------------------|
| `google.com` | A | `142.250.x.x` (une ou plusieurs IPv4) |
| `google.com` | AAAA | `2607:f8b0:...` (une ou plusieurs IPv6) |
| `gmail.com` | MX | `alt1.gmail-smtp-in.l.google.com` avec preference |
| `www.github.com` | CNAME | `github.com` (alias) |

### 1.2.2 Consigne Academique

Implementer un client DNS asynchrone utilisant UDP. Le client doit construire des requetes conformes a la RFC 1035, parser les reponses incluant la decompression des noms, et supporter les types d'enregistrements courants (A, AAAA, CNAME, MX, NS, TXT).

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr};
use std::time::{Duration, Instant};
use tokio::net::UdpSocket;

/// Types d'enregistrements DNS supportes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum RecordType {
    A = 1,
    NS = 2,
    CNAME = 5,
    SOA = 6,
    MX = 15,
    TXT = 16,
    AAAA = 28,
}

/// Classes DNS
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u16)]
pub enum RecordClass {
    IN = 1,  // Internet
}

/// Header DNS (12 bytes)
#[derive(Debug, Clone)]
pub struct DnsHeader {
    pub id: u16,
    pub flags: u16,
    pub qd_count: u16,  // Question count
    pub an_count: u16,  // Answer count
    pub ns_count: u16,  // Authority count
    pub ar_count: u16,  // Additional count
}

/// Flags DNS
pub mod flags {
    pub const QR_RESPONSE: u16 = 0x8000;
    pub const AA_AUTHORITATIVE: u16 = 0x0400;
    pub const TC_TRUNCATED: u16 = 0x0200;
    pub const RD_RECURSION_DESIRED: u16 = 0x0100;
    pub const RA_RECURSION_AVAILABLE: u16 = 0x0080;
    pub const RCODE_MASK: u16 = 0x000F;
}

/// Question DNS
#[derive(Debug, Clone)]
pub struct DnsQuestion {
    pub name: String,
    pub qtype: RecordType,
    pub qclass: RecordClass,
}

/// Donnees d'enregistrement
#[derive(Debug, Clone)]
pub enum RecordData {
    A(Ipv4Addr),
    AAAA(Ipv6Addr),
    CNAME(String),
    NS(String),
    MX { preference: u16, exchange: String },
    TXT(Vec<String>),
    SOA {
        mname: String,
        rname: String,
        serial: u32,
        refresh: u32,
        retry: u32,
        expire: u32,
        minimum: u32,
    },
    Unknown(Vec<u8>),
}

/// Enregistrement DNS (Resource Record)
#[derive(Debug, Clone)]
pub struct DnsRecord {
    pub name: String,
    pub rtype: RecordType,
    pub rclass: RecordClass,
    pub ttl: u32,
    pub data: RecordData,
}

/// Message DNS complet
#[derive(Debug, Clone)]
pub struct DnsMessage {
    pub header: DnsHeader,
    pub questions: Vec<DnsQuestion>,
    pub answers: Vec<DnsRecord>,
    pub authority: Vec<DnsRecord>,
    pub additional: Vec<DnsRecord>,
}

/// Erreurs DNS
#[derive(Debug)]
pub enum DnsError {
    InvalidMessage,
    InvalidName,
    InvalidRecordType,
    ServerError(u8),
    Timeout,
    IdMismatch,
    IoError(std::io::Error),
}

/// Resolver DNS avec cache
pub struct DnsResolver {
    server: SocketAddr,
    socket: UdpSocket,
    next_id: u16,
}

impl DnsHeader {
    /// Cree un header de requete
    pub fn new_query(id: u16, recursion_desired: bool) -> Self;

    /// Serialise en bytes (big-endian)
    pub fn to_bytes(&self) -> [u8; 12];

    /// Parse depuis bytes
    pub fn from_bytes(data: &[u8]) -> Result<Self, DnsError>;

    /// Retourne le code de reponse (RCODE)
    pub fn rcode(&self) -> u8;

    /// Verifie si c'est une reponse
    pub fn is_response(&self) -> bool;
}

impl DnsQuestion {
    /// Serialise en bytes
    pub fn to_bytes(&self) -> Vec<u8>;
}

impl DnsMessage {
    /// Cree une requete simple
    pub fn query(id: u16, name: &str, qtype: RecordType) -> Self;

    /// Serialise le message complet
    pub fn to_bytes(&self) -> Vec<u8>;

    /// Parse un message DNS complet
    pub fn from_bytes(data: &[u8]) -> Result<Self, DnsError>;
}

impl DnsResolver {
    /// Cree un resolver avec le serveur DNS donne
    pub async fn new(server: SocketAddr) -> Result<Self, DnsError>;

    /// Resout un nom avec le type demande
    pub async fn resolve(
        &mut self,
        name: &str,
        qtype: RecordType,
    ) -> Result<Vec<DnsRecord>, DnsError>;

    /// Resout un nom en adresses IPv4
    pub async fn resolve_a(&mut self, name: &str) -> Result<Vec<Ipv4Addr>, DnsError>;

    /// Resout un nom en adresses IPv6
    pub async fn resolve_aaaa(&mut self, name: &str) -> Result<Vec<Ipv6Addr>, DnsError>;
}

/// Encode un nom de domaine en format DNS (labels)
pub fn encode_name(name: &str) -> Vec<u8>;

/// Decode un nom de domaine avec gestion des pointeurs de compression
pub fn decode_name(data: &[u8], offset: &mut usize) -> Result<String, DnsError>;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 La hierarchie DNS

DNS fonctionne comme un annuaire distribue organise en arbre :

```
                    . (root)
                    |
       +------------+------------+
       |            |            |
     .com         .org         .fr
       |            |            |
   +---+---+    example      google
   |       |
google  github
   |
  www
```

### 2.2 Les 13 serveurs racine

Il existe 13 serveurs racine DNS (A-root a M-root), mais grace a l'anycast, ce sont en realite des milliers de serveurs physiques repartis mondialement. Quand tu demandes `www.google.com`, ta requete peut traverser :

1. **Resolver local** (cache de ton FAI)
2. **Root server** -> "Va voir les serveurs .com"
3. **TLD server (.com)** -> "Va voir les serveurs google.com"
4. **Authoritative server** -> "Voici l'IP de www.google.com"

### 2.3 La compression DNS

Pour economiser de la bande passante, DNS utilise des pointeurs. Si `example.com` apparait plusieurs fois dans un message, seule la premiere occurrence est complete. Les suivantes utilisent un pointeur :

```
Offset 0x0C: 07 'e' 'x' 'a' 'm' 'p' 'l' 'e' 03 'c' 'o' 'm' 00
...
Offset 0x2A: C0 0C  <- Pointeur vers offset 0x0C = "example.com"
```

Le premier octet `0xC0` (bits 11xxxxxx) indique un pointeur, suivi de l'offset sur 14 bits.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation |
|--------|-------------|
| **SRE / DevOps** | Configuration DNS, troubleshooting resolution, DNSSEC |
| **Security Engineer** | DNS tunneling detection, DNS-over-HTTPS, sinkholing |
| **Network Engineer** | DNS load balancing, GeoDNS, failover |
| **Malware Analyst** | DGA detection, C2 communication via DNS |

### Cas d'usage concrets

1. **Cloudflare DNS (1.1.1.1)** : DNS resolver public avec privacy
2. **Pi-hole** : Bloqueur de pubs via DNS (sink les requetes vers domaines publicitaires)
3. **AWS Route 53** : DNS avec health checks et failover automatique
4. **DNS-over-HTTPS** : Chiffrement des requetes DNS (RFC 8484)

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo build --release
   Compiling dns_resolver v0.1.0
    Finished release [optimized] target(s)

$ cargo run --release -- google.com A
Querying google.com for A records...
ID: 0x1234, Flags: 0x8180 (response, recursion available)
Answer: google.com A 142.250.74.46 (TTL: 300)
Answer: google.com A 142.250.74.110 (TTL: 300)

$ cargo run --release -- gmail.com MX
Querying gmail.com for MX records...
Answer: gmail.com MX 5 gmail-smtp-in.l.google.com (TTL: 3600)
Answer: gmail.com MX 10 alt1.gmail-smtp-in.l.google.com (TTL: 3600)

$ cargo test
running 12 tests
test tests::test_encode_name ... ok
test tests::test_decode_name_simple ... ok
test tests::test_decode_name_with_pointer ... ok
test tests::test_header_serialization ... ok
test tests::test_header_parsing ... ok
test tests::test_question_serialization ... ok
test tests::test_record_type_conversion ... ok
test tests::test_rcode_extraction ... ok
test tests::test_message_roundtrip ... ok
test tests::test_resolve_a ... ok
test tests::test_resolve_mx ... ok
test tests::test_id_verification ... ok

test result: ok. 12 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
(10/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(1) lookup cache, O(n) cleanup

**Space Complexity attendue :**
O(entries) pour le cache

**Domaines Bonus :**
`Algo, Mem`

#### 3.1.1 Consigne Bonus

**"The Cache is the Key"**

*"Pourquoi interroger l'Oracle a chaque fois ? Memorise ses reponses. Le TTL te dit combien de temps tu peux lui faire confiance."*

**Ta mission bonus :**

Implementer un **cache DNS avec TTL** et une **resolution recursive** :

1. Cache les reponses avec respect du TTL
2. Suit les CNAME automatiquement jusqu'a l'IP finale
3. Nettoie les entrees expirees periodiquement
4. Limite la profondeur de recursion (eviter les boucles)

**Contraintes :**
```
+-------------------------------------------+
|  max_cache_entries <= 10000               |
|  max_cname_depth <= 8                     |
|  TTL minimum respecte = 60s               |
|  Cleanup interval = 60s                   |
+-------------------------------------------+
```

#### 3.1.2 Prototype Bonus

```rust
/// Entree du cache
struct CacheEntry {
    records: Vec<DnsRecord>,
    expires_at: Instant,
}

/// Resolver DNS avec cache
pub struct CachedDnsResolver {
    server: SocketAddr,
    socket: UdpSocket,
    cache: HashMap<(String, RecordType), CacheEntry>,
    next_id: u16,
    max_entries: usize,
}

impl CachedDnsResolver {
    /// Cree un resolver avec cache
    pub async fn new(server: SocketAddr, max_entries: usize) -> Result<Self, DnsError>;

    /// Resout avec cache (lookup cache d'abord)
    pub async fn resolve_cached(
        &mut self,
        name: &str,
        qtype: RecordType,
    ) -> Result<Vec<DnsRecord>, DnsError>;

    /// Suit les CNAME jusqu'a l'enregistrement final
    pub async fn resolve_recursive(
        &mut self,
        name: &str,
        qtype: RecordType,
        max_depth: usize,
    ) -> Result<Vec<DnsRecord>, DnsError>;

    /// Nettoie les entrees expirees du cache
    pub fn cleanup_cache(&mut self);

    /// Statistiques du cache
    pub fn cache_stats(&self) -> (usize, usize);  // (entries, hits)
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Description | Points | Categorie |
|------|-------------|--------|-----------|
| `test_encode_name` | "www.example.com" -> labels corrects | 10 | Encoding |
| `test_encode_name_root` | "." -> [0] | 5 | Encoding |
| `test_decode_name_simple` | Labels -> "www.example.com" | 10 | Decoding |
| `test_decode_name_with_pointer` | Compression pointer -> nom complet | 15 | Decoding |
| `test_header_serialization` | Header -> 12 bytes big-endian | 10 | Serialization |
| `test_header_parsing` | 12 bytes -> Header struct | 10 | Parsing |
| `test_question_serialization` | Question -> bytes | 5 | Serialization |
| `test_message_roundtrip` | Serialize puis parse = identique | 10 | Integration |
| `test_rcode_extraction` | Flags -> RCODE correct | 5 | Parsing |
| `test_record_type_conversion` | Enum -> u16 | 5 | Types |
| `test_id_verification` | Reponse avec mauvais ID -> erreur | 10 | Security |
| `test_resolve_real_dns` | Requete vers 8.8.8.8 | 5 | Integration |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_name() {
        let encoded = encode_name("www.example.com");
        // Format: length-prefixed labels, null-terminated
        // 3 'w' 'w' 'w' 7 'e' 'x' 'a' 'm' 'p' 'l' 'e' 3 'c' 'o' 'm' 0
        assert_eq!(encoded.len(), 17);
        assert_eq!(encoded[0], 3);
        assert_eq!(&encoded[1..4], b"www");
        assert_eq!(encoded[4], 7);
        assert_eq!(&encoded[5..12], b"example");
        assert_eq!(encoded[12], 3);
        assert_eq!(&encoded[13..16], b"com");
        assert_eq!(encoded[16], 0);
    }

    #[test]
    fn test_encode_name_single_label() {
        let encoded = encode_name("localhost");
        assert_eq!(encoded.len(), 11);
        assert_eq!(encoded[0], 9);
        assert_eq!(&encoded[1..10], b"localhost");
        assert_eq!(encoded[10], 0);
    }

    #[test]
    fn test_decode_name_simple() {
        let data = [
            3, b'w', b'w', b'w',
            7, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            3, b'c', b'o', b'm',
            0
        ];
        let mut offset = 0;
        let name = decode_name(&data, &mut offset).unwrap();

        assert_eq!(name, "www.example.com");
        assert_eq!(offset, 17);
    }

    #[test]
    fn test_decode_name_with_pointer() {
        // Message avec compression
        // Offset 0-7: header padding
        // Offset 8-19: "example.com" (complet)
        // Offset 20-23: "www" + pointer vers offset 8
        let mut data = vec![0u8; 8];  // padding
        data.extend_from_slice(&[
            7, b'e', b'x', b'a', b'm', b'p', b'l', b'e',  // offset 8
            3, b'c', b'o', b'm', 0,                        // offset 16
        ]);
        data.extend_from_slice(&[
            3, b'w', b'w', b'w',  // offset 21
            0xC0, 0x08,          // pointer to offset 8
        ]);

        let mut offset = 21;
        let name = decode_name(&data, &mut offset).unwrap();

        assert_eq!(name, "www.example.com");
    }

    #[test]
    fn test_header_new_query() {
        let header = DnsHeader::new_query(0x1234, true);

        assert_eq!(header.id, 0x1234);
        assert_eq!(header.flags & flags::RD_RECURSION_DESIRED, flags::RD_RECURSION_DESIRED);
        assert_eq!(header.qd_count, 1);
        assert_eq!(header.an_count, 0);
        assert_eq!(header.ns_count, 0);
        assert_eq!(header.ar_count, 0);
        assert!(!header.is_response());
    }

    #[test]
    fn test_header_serialization() {
        let header = DnsHeader::new_query(0x1234, true);
        let bytes = header.to_bytes();

        assert_eq!(bytes.len(), 12);
        // ID (big-endian)
        assert_eq!(&bytes[0..2], &[0x12, 0x34]);
        // Flags: RD=1 -> 0x0100
        assert_eq!(&bytes[2..4], &[0x01, 0x00]);
        // QD count = 1
        assert_eq!(&bytes[4..6], &[0x00, 0x01]);
        // AN, NS, AR counts = 0
        assert_eq!(&bytes[6..12], &[0, 0, 0, 0, 0, 0]);
    }

    #[test]
    fn test_header_parsing() {
        let bytes = [
            0x12, 0x34,  // ID
            0x81, 0x80,  // Flags: QR=1, RD=1, RA=1
            0x00, 0x01,  // QD count
            0x00, 0x02,  // AN count
            0x00, 0x00,  // NS count
            0x00, 0x01,  // AR count
        ];

        let header = DnsHeader::from_bytes(&bytes).unwrap();

        assert_eq!(header.id, 0x1234);
        assert!(header.is_response());
        assert_eq!(header.qd_count, 1);
        assert_eq!(header.an_count, 2);
        assert_eq!(header.ns_count, 0);
        assert_eq!(header.ar_count, 1);
        assert_eq!(header.rcode(), 0);  // No error
    }

    #[test]
    fn test_question_serialization() {
        let question = DnsQuestion {
            name: "example.com".to_string(),
            qtype: RecordType::A,
            qclass: RecordClass::IN,
        };

        let bytes = question.to_bytes();

        // Name: 7 'example' 3 'com' 0 = 13 bytes
        // Type: 2 bytes
        // Class: 2 bytes
        // Total: 17 bytes
        assert_eq!(bytes.len(), 17);
        assert_eq!(bytes[0], 7);  // "example" length
        assert_eq!(&bytes[1..8], b"example");
        assert_eq!(bytes[8], 3);  // "com" length
        assert_eq!(&bytes[9..12], b"com");
        assert_eq!(bytes[12], 0);  // null terminator

        // Type A = 1 (big-endian)
        assert_eq!(&bytes[13..15], &[0x00, 0x01]);
        // Class IN = 1 (big-endian)
        assert_eq!(&bytes[15..17], &[0x00, 0x01]);
    }

    #[test]
    fn test_record_type_conversion() {
        assert_eq!(RecordType::A as u16, 1);
        assert_eq!(RecordType::NS as u16, 2);
        assert_eq!(RecordType::CNAME as u16, 5);
        assert_eq!(RecordType::SOA as u16, 6);
        assert_eq!(RecordType::MX as u16, 15);
        assert_eq!(RecordType::TXT as u16, 16);
        assert_eq!(RecordType::AAAA as u16, 28);
    }

    #[test]
    fn test_rcode_extraction() {
        // NXDOMAIN = RCODE 3
        let header = DnsHeader {
            id: 0,
            flags: 0x8003,  // Response + RCODE=3
            qd_count: 0,
            an_count: 0,
            ns_count: 0,
            ar_count: 0,
        };
        assert_eq!(header.rcode(), 3);

        // SERVFAIL = RCODE 2
        let header2 = DnsHeader {
            id: 0,
            flags: 0x8002,
            qd_count: 0,
            an_count: 0,
            ns_count: 0,
            ar_count: 0,
        };
        assert_eq!(header2.rcode(), 2);
    }

    #[test]
    fn test_message_roundtrip() {
        let original = DnsMessage::query(0xABCD, "test.example.com", RecordType::A);
        let bytes = original.to_bytes();
        let parsed = DnsMessage::from_bytes(&bytes).unwrap();

        assert_eq!(parsed.header.id, 0xABCD);
        assert_eq!(parsed.questions.len(), 1);
        assert_eq!(parsed.questions[0].name, "test.example.com");
        assert_eq!(parsed.questions[0].qtype, RecordType::A);
    }

    #[tokio::test]
    async fn test_resolve_google_dns() {
        // Test avec le DNS public de Google
        let server: SocketAddr = "8.8.8.8:53".parse().unwrap();
        let mut resolver = DnsResolver::new(server).await.unwrap();

        let records = resolver.resolve("google.com", RecordType::A).await.unwrap();

        assert!(!records.is_empty());
        for record in &records {
            if let RecordData::A(ip) = &record.data {
                // Google IPs are in various ranges
                assert!(ip.octets()[0] > 0);
            }
        }
    }

    #[tokio::test]
    async fn test_resolve_mx() {
        let server: SocketAddr = "8.8.8.8:53".parse().unwrap();
        let mut resolver = DnsResolver::new(server).await.unwrap();

        let records = resolver.resolve("gmail.com", RecordType::MX).await.unwrap();

        assert!(!records.is_empty());
        for record in &records {
            if let RecordData::MX { preference, exchange } = &record.data {
                assert!(*preference > 0);
                assert!(exchange.contains("google"));
            }
        }
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr};
use std::time::{Duration, Instant};
use tokio::net::UdpSocket;
use tokio::time::timeout;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum RecordType {
    A = 1,
    NS = 2,
    CNAME = 5,
    SOA = 6,
    MX = 15,
    TXT = 16,
    AAAA = 28,
}

impl RecordType {
    pub fn from_u16(value: u16) -> Option<Self> {
        match value {
            1 => Some(RecordType::A),
            2 => Some(RecordType::NS),
            5 => Some(RecordType::CNAME),
            6 => Some(RecordType::SOA),
            15 => Some(RecordType::MX),
            16 => Some(RecordType::TXT),
            28 => Some(RecordType::AAAA),
            _ => None,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u16)]
pub enum RecordClass {
    IN = 1,
}

pub mod flags {
    pub const QR_RESPONSE: u16 = 0x8000;
    pub const AA_AUTHORITATIVE: u16 = 0x0400;
    pub const TC_TRUNCATED: u16 = 0x0200;
    pub const RD_RECURSION_DESIRED: u16 = 0x0100;
    pub const RA_RECURSION_AVAILABLE: u16 = 0x0080;
    pub const RCODE_MASK: u16 = 0x000F;
}

#[derive(Debug, Clone)]
pub struct DnsHeader {
    pub id: u16,
    pub flags: u16,
    pub qd_count: u16,
    pub an_count: u16,
    pub ns_count: u16,
    pub ar_count: u16,
}

impl DnsHeader {
    pub fn new_query(id: u16, recursion_desired: bool) -> Self {
        let flags = if recursion_desired {
            flags::RD_RECURSION_DESIRED
        } else {
            0
        };

        Self {
            id,
            flags,
            qd_count: 1,
            an_count: 0,
            ns_count: 0,
            ar_count: 0,
        }
    }

    pub fn to_bytes(&self) -> [u8; 12] {
        let mut bytes = [0u8; 12];
        bytes[0..2].copy_from_slice(&self.id.to_be_bytes());
        bytes[2..4].copy_from_slice(&self.flags.to_be_bytes());
        bytes[4..6].copy_from_slice(&self.qd_count.to_be_bytes());
        bytes[6..8].copy_from_slice(&self.an_count.to_be_bytes());
        bytes[8..10].copy_from_slice(&self.ns_count.to_be_bytes());
        bytes[10..12].copy_from_slice(&self.ar_count.to_be_bytes());
        bytes
    }

    pub fn from_bytes(data: &[u8]) -> Result<Self, DnsError> {
        if data.len() < 12 {
            return Err(DnsError::InvalidMessage);
        }

        Ok(Self {
            id: u16::from_be_bytes([data[0], data[1]]),
            flags: u16::from_be_bytes([data[2], data[3]]),
            qd_count: u16::from_be_bytes([data[4], data[5]]),
            an_count: u16::from_be_bytes([data[6], data[7]]),
            ns_count: u16::from_be_bytes([data[8], data[9]]),
            ar_count: u16::from_be_bytes([data[10], data[11]]),
        })
    }

    pub fn rcode(&self) -> u8 {
        (self.flags & flags::RCODE_MASK) as u8
    }

    pub fn is_response(&self) -> bool {
        (self.flags & flags::QR_RESPONSE) != 0
    }
}

#[derive(Debug, Clone)]
pub struct DnsQuestion {
    pub name: String,
    pub qtype: RecordType,
    pub qclass: RecordClass,
}

impl DnsQuestion {
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = encode_name(&self.name);
        bytes.extend_from_slice(&(self.qtype as u16).to_be_bytes());
        bytes.extend_from_slice(&(self.qclass as u16).to_be_bytes());
        bytes
    }
}

#[derive(Debug, Clone)]
pub enum RecordData {
    A(Ipv4Addr),
    AAAA(Ipv6Addr),
    CNAME(String),
    NS(String),
    MX { preference: u16, exchange: String },
    TXT(Vec<String>),
    SOA {
        mname: String,
        rname: String,
        serial: u32,
        refresh: u32,
        retry: u32,
        expire: u32,
        minimum: u32,
    },
    Unknown(Vec<u8>),
}

#[derive(Debug, Clone)]
pub struct DnsRecord {
    pub name: String,
    pub rtype: RecordType,
    pub rclass: RecordClass,
    pub ttl: u32,
    pub data: RecordData,
}

#[derive(Debug, Clone)]
pub struct DnsMessage {
    pub header: DnsHeader,
    pub questions: Vec<DnsQuestion>,
    pub answers: Vec<DnsRecord>,
    pub authority: Vec<DnsRecord>,
    pub additional: Vec<DnsRecord>,
}

impl DnsMessage {
    pub fn query(id: u16, name: &str, qtype: RecordType) -> Self {
        Self {
            header: DnsHeader::new_query(id, true),
            questions: vec![DnsQuestion {
                name: name.to_string(),
                qtype,
                qclass: RecordClass::IN,
            }],
            answers: vec![],
            authority: vec![],
            additional: vec![],
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = self.header.to_bytes().to_vec();
        for question in &self.questions {
            bytes.extend(question.to_bytes());
        }
        bytes
    }

    pub fn from_bytes(data: &[u8]) -> Result<Self, DnsError> {
        let header = DnsHeader::from_bytes(data)?;
        let mut offset = 12;

        // Parse questions
        let mut questions = Vec::new();
        for _ in 0..header.qd_count {
            let name = decode_name(data, &mut offset)?;
            if offset + 4 > data.len() {
                return Err(DnsError::InvalidMessage);
            }
            let qtype_val = u16::from_be_bytes([data[offset], data[offset + 1]]);
            let qtype = RecordType::from_u16(qtype_val)
                .ok_or(DnsError::InvalidRecordType)?;
            offset += 4;  // type + class

            questions.push(DnsQuestion {
                name,
                qtype,
                qclass: RecordClass::IN,
            });
        }

        // Parse answers
        let mut answers = Vec::new();
        for _ in 0..header.an_count {
            let record = parse_record(data, &mut offset)?;
            answers.push(record);
        }

        // Parse authority
        let mut authority = Vec::new();
        for _ in 0..header.ns_count {
            let record = parse_record(data, &mut offset)?;
            authority.push(record);
        }

        // Parse additional
        let mut additional = Vec::new();
        for _ in 0..header.ar_count {
            if let Ok(record) = parse_record(data, &mut offset) {
                additional.push(record);
            }
        }

        Ok(Self {
            header,
            questions,
            answers,
            authority,
            additional,
        })
    }
}

fn parse_record(data: &[u8], offset: &mut usize) -> Result<DnsRecord, DnsError> {
    let name = decode_name(data, offset)?;

    if *offset + 10 > data.len() {
        return Err(DnsError::InvalidMessage);
    }

    let rtype_val = u16::from_be_bytes([data[*offset], data[*offset + 1]]);
    let rclass_val = u16::from_be_bytes([data[*offset + 2], data[*offset + 3]]);
    let ttl = u32::from_be_bytes([
        data[*offset + 4],
        data[*offset + 5],
        data[*offset + 6],
        data[*offset + 7],
    ]);
    let rdlength = u16::from_be_bytes([data[*offset + 8], data[*offset + 9]]) as usize;
    *offset += 10;

    if *offset + rdlength > data.len() {
        return Err(DnsError::InvalidMessage);
    }

    let rdata_start = *offset;
    let record_data = match rtype_val {
        1 => {
            // A record
            if rdlength != 4 {
                return Err(DnsError::InvalidMessage);
            }
            let ip = Ipv4Addr::new(
                data[*offset],
                data[*offset + 1],
                data[*offset + 2],
                data[*offset + 3],
            );
            *offset += 4;
            RecordData::A(ip)
        }
        28 => {
            // AAAA record
            if rdlength != 16 {
                return Err(DnsError::InvalidMessage);
            }
            let mut octets = [0u8; 16];
            octets.copy_from_slice(&data[*offset..*offset + 16]);
            let ip = Ipv6Addr::from(octets);
            *offset += 16;
            RecordData::AAAA(ip)
        }
        5 => {
            // CNAME
            let cname = decode_name(data, offset)?;
            RecordData::CNAME(cname)
        }
        2 => {
            // NS
            let ns = decode_name(data, offset)?;
            RecordData::NS(ns)
        }
        15 => {
            // MX
            let preference = u16::from_be_bytes([data[*offset], data[*offset + 1]]);
            *offset += 2;
            let exchange = decode_name(data, offset)?;
            RecordData::MX { preference, exchange }
        }
        16 => {
            // TXT
            let mut texts = Vec::new();
            let end = rdata_start + rdlength;
            while *offset < end {
                let len = data[*offset] as usize;
                *offset += 1;
                if *offset + len > end {
                    return Err(DnsError::InvalidMessage);
                }
                let text = String::from_utf8_lossy(&data[*offset..*offset + len]).to_string();
                texts.push(text);
                *offset += len;
            }
            RecordData::TXT(texts)
        }
        _ => {
            let rdata = data[*offset..*offset + rdlength].to_vec();
            *offset += rdlength;
            RecordData::Unknown(rdata)
        }
    };

    // Ensure offset advances correctly for all types
    if *offset < rdata_start + rdlength {
        *offset = rdata_start + rdlength;
    }

    let rtype = RecordType::from_u16(rtype_val);

    Ok(DnsRecord {
        name,
        rtype: rtype.unwrap_or(RecordType::A),  // fallback
        rclass: RecordClass::IN,
        ttl,
        data: record_data,
    })
}

#[derive(Debug)]
pub enum DnsError {
    InvalidMessage,
    InvalidName,
    InvalidRecordType,
    ServerError(u8),
    Timeout,
    IdMismatch,
    IoError(std::io::Error),
}

impl From<std::io::Error> for DnsError {
    fn from(e: std::io::Error) -> Self {
        DnsError::IoError(e)
    }
}

pub struct DnsResolver {
    server: SocketAddr,
    socket: UdpSocket,
    next_id: u16,
}

impl DnsResolver {
    pub async fn new(server: SocketAddr) -> Result<Self, DnsError> {
        let socket = UdpSocket::bind("0.0.0.0:0").await?;
        socket.connect(server).await?;

        Ok(Self {
            server,
            socket,
            next_id: 1,
        })
    }

    fn next_id(&mut self) -> u16 {
        let id = self.next_id;
        self.next_id = self.next_id.wrapping_add(1);
        id
    }

    pub async fn resolve(
        &mut self,
        name: &str,
        qtype: RecordType,
    ) -> Result<Vec<DnsRecord>, DnsError> {
        let id = self.next_id();
        let query = DnsMessage::query(id, name, qtype);
        let query_bytes = query.to_bytes();

        self.socket.send(&query_bytes).await?;

        let mut buf = [0u8; 512];
        let result = timeout(Duration::from_secs(5), self.socket.recv(&mut buf)).await;

        let len = match result {
            Ok(Ok(len)) => len,
            Ok(Err(e)) => return Err(DnsError::IoError(e)),
            Err(_) => return Err(DnsError::Timeout),
        };

        let response = DnsMessage::from_bytes(&buf[..len])?;

        // Verify ID matches
        if response.header.id != id {
            return Err(DnsError::IdMismatch);
        }

        // Check for server errors
        let rcode = response.header.rcode();
        if rcode != 0 {
            return Err(DnsError::ServerError(rcode));
        }

        Ok(response.answers)
    }

    pub async fn resolve_a(&mut self, name: &str) -> Result<Vec<Ipv4Addr>, DnsError> {
        let records = self.resolve(name, RecordType::A).await?;
        Ok(records
            .into_iter()
            .filter_map(|r| {
                if let RecordData::A(ip) = r.data {
                    Some(ip)
                } else {
                    None
                }
            })
            .collect())
    }

    pub async fn resolve_aaaa(&mut self, name: &str) -> Result<Vec<Ipv6Addr>, DnsError> {
        let records = self.resolve(name, RecordType::AAAA).await?;
        Ok(records
            .into_iter()
            .filter_map(|r| {
                if let RecordData::AAAA(ip) = r.data {
                    Some(ip)
                } else {
                    None
                }
            })
            .collect())
    }
}

/// Encode un nom de domaine en format DNS
pub fn encode_name(name: &str) -> Vec<u8> {
    let mut bytes = Vec::new();

    if name.is_empty() || name == "." {
        bytes.push(0);
        return bytes;
    }

    for label in name.split('.') {
        if !label.is_empty() {
            bytes.push(label.len() as u8);
            bytes.extend_from_slice(label.as_bytes());
        }
    }
    bytes.push(0);  // Null terminator

    bytes
}

/// Decode un nom de domaine avec gestion des pointeurs
pub fn decode_name(data: &[u8], offset: &mut usize) -> Result<String, DnsError> {
    let mut labels = Vec::new();
    let mut jumped = false;
    let mut jump_offset = 0;
    let original_offset = *offset;
    let mut bytes_read = 0;

    loop {
        if *offset >= data.len() {
            return Err(DnsError::InvalidName);
        }

        let len = data[*offset];

        if len == 0 {
            if !jumped {
                *offset += 1;
            }
            break;
        }

        // Check for pointer (top 2 bits = 11)
        if (len & 0xC0) == 0xC0 {
            if *offset + 1 >= data.len() {
                return Err(DnsError::InvalidName);
            }

            if !jumped {
                bytes_read = *offset - original_offset + 2;
                jumped = true;
            }

            // Calculate pointer offset
            let pointer = ((len as usize & 0x3F) << 8) | (data[*offset + 1] as usize);
            *offset = pointer;

            // Prevent infinite loops
            if *offset >= original_offset && !jumped {
                return Err(DnsError::InvalidName);
            }
        } else {
            // Regular label
            *offset += 1;
            if *offset + (len as usize) > data.len() {
                return Err(DnsError::InvalidName);
            }

            let label = String::from_utf8_lossy(&data[*offset..*offset + len as usize]).to_string();
            labels.push(label);
            *offset += len as usize;
        }
    }

    if jumped {
        // Restore offset to after the pointer
        *offset = original_offset + bytes_read;
    }

    Ok(labels.join("."))
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de Cursor pour le parsing
use std::io::{Cursor, Read};

pub fn decode_name_cursor(data: &[u8], offset: &mut usize) -> Result<String, DnsError> {
    let mut cursor = Cursor::new(data);
    cursor.set_position(*offset as u64);
    // ... parsing avec cursor.read_exact()
}

// Alternative 2 : Parser combinators style
fn parse_label(data: &[u8], offset: &mut usize) -> Result<Option<String>, DnsError> {
    let len = data.get(*offset).ok_or(DnsError::InvalidName)?;
    if *len == 0 {
        *offset += 1;
        return Ok(None);
    }
    // ...
}

// Alternative 3 : Recursion pour les pointeurs
pub fn decode_name_recursive(data: &[u8], offset: usize, depth: usize) -> Result<(String, usize), DnsError> {
    if depth > 10 {
        return Err(DnsError::InvalidName);  // Prevent infinite recursion
    }
    // ...
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Little-endian au lieu de big-endian
impl DnsHeader {
    pub fn to_bytes(&self) -> [u8; 12] {
        let mut bytes = [0u8; 12];
        bytes[0..2].copy_from_slice(&self.id.to_le_bytes());  // WRONG: little-endian
        // ...
    }
}
// Pourquoi refusee : DNS utilise network byte order (big-endian)

// REFUSEE 2 : Oubli du null-terminator
pub fn encode_name(name: &str) -> Vec<u8> {
    let mut bytes = Vec::new();
    for label in name.split('.') {
        bytes.push(label.len() as u8);
        bytes.extend_from_slice(label.as_bytes());
    }
    // MISSING: bytes.push(0);
    bytes
}
// Pourquoi refusee : Le serveur DNS rejette les requetes sans null-terminator

// REFUSEE 3 : Pas de gestion des pointeurs
pub fn decode_name(data: &[u8], offset: &mut usize) -> Result<String, DnsError> {
    let mut labels = Vec::new();
    loop {
        let len = data[*offset];
        if len == 0 { break; }
        // MISSING: Check for pointer (0xC0)
        *offset += 1;
        labels.push(String::from_utf8_lossy(&data[*offset..*offset + len as usize]).to_string());
        *offset += len as usize;
    }
    Ok(labels.join("."))
}
// Pourquoi refusee : Les reponses DNS utilisent la compression, noms incorrects

// REFUSEE 4 : Pas de verification de l'ID
pub async fn resolve(&mut self, name: &str, qtype: RecordType) -> Result<Vec<DnsRecord>, DnsError> {
    let query = DnsMessage::query(self.next_id(), name, qtype);
    self.socket.send(&query.to_bytes()).await?;

    let mut buf = [0u8; 512];
    let len = self.socket.recv(&mut buf).await?;
    let response = DnsMessage::from_bytes(&buf[..len])?;

    // MISSING: Verify response.header.id == query.header.id
    Ok(response.answers)
}
// Pourquoi refusee : Vulnerable au DNS spoofing, reponses melangees
```

### 4.6 Solution bonus de reference

```rust
use std::collections::HashMap;
use std::time::Instant;

struct CacheEntry {
    records: Vec<DnsRecord>,
    expires_at: Instant,
}

pub struct CachedDnsResolver {
    server: SocketAddr,
    socket: UdpSocket,
    cache: HashMap<(String, RecordType), CacheEntry>,
    next_id: u16,
    max_entries: usize,
    cache_hits: usize,
}

impl CachedDnsResolver {
    pub async fn new(server: SocketAddr, max_entries: usize) -> Result<Self, DnsError> {
        let socket = UdpSocket::bind("0.0.0.0:0").await?;
        socket.connect(server).await?;

        Ok(Self {
            server,
            socket,
            cache: HashMap::new(),
            next_id: 1,
            max_entries,
            cache_hits: 0,
        })
    }

    pub async fn resolve_cached(
        &mut self,
        name: &str,
        qtype: RecordType,
    ) -> Result<Vec<DnsRecord>, DnsError> {
        let key = (name.to_lowercase(), qtype);
        let now = Instant::now();

        // Check cache
        if let Some(entry) = self.cache.get(&key) {
            if entry.expires_at > now {
                self.cache_hits += 1;
                return Ok(entry.records.clone());
            }
        }

        // Cache miss or expired, do actual resolution
        let records = self.resolve_uncached(name, qtype).await?;

        // Find minimum TTL for cache expiration
        let min_ttl = records
            .iter()
            .map(|r| r.ttl)
            .min()
            .unwrap_or(300)
            .max(60);  // Minimum 60 seconds

        // Evict if cache full
        if self.cache.len() >= self.max_entries {
            self.cleanup_cache();
        }

        // Store in cache
        self.cache.insert(key, CacheEntry {
            records: records.clone(),
            expires_at: now + Duration::from_secs(min_ttl as u64),
        });

        Ok(records)
    }

    pub async fn resolve_recursive(
        &mut self,
        name: &str,
        qtype: RecordType,
        max_depth: usize,
    ) -> Result<Vec<DnsRecord>, DnsError> {
        if max_depth == 0 {
            return Err(DnsError::InvalidName);  // Too many CNAMEs
        }

        let records = self.resolve_cached(name, qtype).await?;

        // Check if we got CNAMEs and need to follow them
        if qtype != RecordType::CNAME {
            let cnames: Vec<_> = records
                .iter()
                .filter_map(|r| {
                    if let RecordData::CNAME(target) = &r.data {
                        Some(target.clone())
                    } else {
                        None
                    }
                })
                .collect();

            // If we only got CNAMEs, follow them
            if !cnames.is_empty() && records.iter().all(|r| matches!(r.data, RecordData::CNAME(_))) {
                for cname in cnames {
                    let resolved = self.resolve_recursive(&cname, qtype, max_depth - 1).await?;
                    if !resolved.is_empty() {
                        return Ok(resolved);
                    }
                }
            }
        }

        Ok(records)
    }

    pub fn cleanup_cache(&mut self) {
        let now = Instant::now();
        self.cache.retain(|_, entry| entry.expires_at > now);
    }

    pub fn cache_stats(&self) -> (usize, usize) {
        (self.cache.len(), self.cache_hits)
    }

    async fn resolve_uncached(
        &mut self,
        name: &str,
        qtype: RecordType,
    ) -> Result<Vec<DnsRecord>, DnsError> {
        let id = self.next_id;
        self.next_id = self.next_id.wrapping_add(1);

        let query = DnsMessage::query(id, name, qtype);
        self.socket.send(&query.to_bytes()).await?;

        let mut buf = [0u8; 512];
        let result = timeout(Duration::from_secs(5), self.socket.recv(&mut buf)).await;

        let len = match result {
            Ok(Ok(len)) => len,
            Ok(Err(e)) => return Err(DnsError::IoError(e)),
            Err(_) => return Err(DnsError::Timeout),
        };

        let response = DnsMessage::from_bytes(&buf[..len])?;

        if response.header.id != id {
            return Err(DnsError::IdMismatch);
        }

        let rcode = response.header.rcode();
        if rcode != 0 {
            return Err(DnsError::ServerError(rcode));
        }

        Ok(response.answers)
    }
}
```

### 4.9 spec.json

```json
{
  "name": "dns_resolver",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Integration - UDP + parsing binaire + cache",
  "tags": ["networking", "dns", "udp", "protocol", "parsing", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "DnsResolver",
    "prototype": "impl DnsResolver",
    "return_type": "struct",
    "parameters": [
      {"name": "server", "type": "SocketAddr"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "encode_name_simple",
        "input": "www.example.com",
        "expected": "[3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3, 99, 111, 109, 0]",
        "is_trap": false
      },
      {
        "name": "encode_name_root",
        "input": ".",
        "expected": "[0]",
        "is_trap": true,
        "trap_explanation": "Le domaine racine est juste un null byte"
      },
      {
        "name": "decode_with_pointer",
        "description": "Compression pointer at offset",
        "is_trap": true,
        "trap_explanation": "Les pointeurs 0xC0 doivent etre suivis"
      },
      {
        "name": "header_big_endian",
        "description": "All integers must be big-endian",
        "is_trap": true,
        "trap_explanation": "Little-endian corrompt le message"
      },
      {
        "name": "id_verification",
        "description": "Response ID must match query ID",
        "is_trap": true,
        "trap_explanation": "Sans verification, vulnerable au spoofing"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 100,
      "generators": [
        {
          "type": "string",
          "param_index": 0,
          "params": {
            "min_len": 1,
            "max_len": 255,
            "charset": "hostname"
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["tokio::net::UdpSocket", "std::collections::HashMap", "std::time"],
    "forbidden_crates": ["trust-dns", "hickory-dns", "dns-parser"],
    "check_security": true,
    "blocking": false
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Encoding) : Oubli du null-terminator */
pub fn encode_name(name: &str) -> Vec<u8> {
    let mut bytes = Vec::new();
    for label in name.split('.') {
        bytes.push(label.len() as u8);
        bytes.extend_from_slice(label.as_bytes());
    }
    // MUTANT: Pas de bytes.push(0)
    bytes
}
// Pourquoi c'est faux : Le serveur DNS rejette la requete (format invalide)
// Ce qui etait pense : "Le split s'arrete naturellement"

/* Mutant B (Endianness) : Little-endian au lieu de big-endian */
impl DnsHeader {
    pub fn to_bytes(&self) -> [u8; 12] {
        let mut bytes = [0u8; 12];
        bytes[0..2].copy_from_slice(&self.id.to_le_bytes());  // MUTANT
        bytes[2..4].copy_from_slice(&self.flags.to_le_bytes());  // MUTANT
        // ...
    }
}
// Pourquoi c'est faux : DNS utilise network byte order (big-endian), parsing corrompu
// Ce qui etait pense : "x86 utilise little-endian, donc c'est le defaut"

/* Mutant C (Pointer) : Pas de gestion de la compression */
pub fn decode_name(data: &[u8], offset: &mut usize) -> Result<String, DnsError> {
    let mut labels = Vec::new();
    loop {
        let len = data[*offset];
        if len == 0 { *offset += 1; break; }
        // MUTANT: Pas de check (len & 0xC0) == 0xC0
        *offset += 1;
        labels.push(String::from_utf8_lossy(&data[*offset..*offset + len as usize]).to_string());
        *offset += len as usize;
    }
    Ok(labels.join("."))
}
// Pourquoi c'est faux : Les pointeurs (0xC0) sont traites comme des longueurs de label
// Ce qui etait pense : "La compression est optionnelle"

/* Mutant D (ID Match) : Pas de verification de l'ID reponse */
pub async fn resolve(&mut self, name: &str, qtype: RecordType) -> Result<Vec<DnsRecord>, DnsError> {
    let id = self.next_id();
    let query = DnsMessage::query(id, name, qtype);
    self.socket.send(&query.to_bytes()).await?;

    let mut buf = [0u8; 512];
    let len = self.socket.recv(&mut buf).await?;
    let response = DnsMessage::from_bytes(&buf[..len])?;

    // MUTANT: Pas de check response.header.id == id
    Ok(response.answers)
}
// Pourquoi c'est faux : Reponses peuvent etre melangees ou spoofees
// Ce qui etait pense : "UDP est connexion-less mais on recoit notre reponse"

/* Mutant E (TTL) : Cache sans expiration */
pub async fn resolve_cached(&mut self, name: &str, qtype: RecordType) -> Result<Vec<DnsRecord>, DnsError> {
    let key = (name.to_string(), qtype);

    if let Some(records) = self.cache.get(&key) {
        // MUTANT: Pas de check expires_at > now
        return Ok(records.clone());
    }

    let records = self.resolve_uncached(name, qtype).await?;
    self.cache.insert(key, records.clone());  // MUTANT: Pas de TTL
    Ok(records)
}
// Pourquoi c'est faux : Donnees obsoletes servies indefiniment
// Ce qui etait pense : "Le cache ameliore toujours les performances"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Protocole DNS** : Structure des messages, hierarchy, resolution
2. **Parsing binaire** : Big-endian, champs de taille variable, pointeurs
3. **UDP networking** : Socket non-connecte, timeout, unreliability
4. **Compression de donnees** : Pointeurs pour deduplication
5. **Cache avec TTL** : Expiration, invalidation, performance

### 5.2 LDA - Traduction Litterale

```
FONCTION encode_name QUI PREND name ET RETOURNE bytes
DEBUT FONCTION
    DECLARER bytes COMME LISTE VIDE

    SI name EST VIDE OU name == "." ALORS
        AJOUTER 0 A bytes
        RETOURNER bytes
    FIN SI

    POUR CHAQUE label DANS name.split('.') FAIRE
        SI label N'EST PAS VIDE ALORS
            AJOUTER longueur(label) A bytes
            AJOUTER caracteres(label) A bytes
        FIN SI
    FIN POUR

    AJOUTER 0 A bytes  // Null terminator
    RETOURNER bytes
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : DNS Resolution
---
ENTREE : domain_name, record_type, dns_server
SORTIE : liste d'enregistrements

1. GENERER un ID unique (16 bits)
2. CONSTRUIRE le header DNS :
   - ID = id_genere
   - Flags = RD (recursion desired)
   - QDCOUNT = 1
3. CONSTRUIRE la question :
   - QNAME = encode(domain_name)
   - QTYPE = record_type
   - QCLASS = IN (Internet)
4. SERIALISER en big-endian
5. ENVOYER via UDP vers dns_server:53
6. ATTENDRE reponse (timeout 5s)
7. PARSER la reponse :
   - VERIFIER ID correspond
   - VERIFIER RCODE == 0
   - EXTRAIRE les enregistrements (answers)
8. RETOURNER enregistrements
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Decode Name with Compression
---
1. INITIALISER labels = []
2. BOUCLE :
   a. LIRE len = data[offset]
   b. SI len == 0 : SORTIR
   c. SI (len & 0xC0) == 0xC0 :
      - CALCULER pointer = ((len & 0x3F) << 8) | data[offset+1]
      - SAUVEGARDER offset actuel
      - SAUTER a offset = pointer
      - CONTINUER (recursion limitee)
   d. SINON :
      - LIRE label de longueur len
      - AJOUTER label a labels
      - AVANCER offset de len + 1
3. RETOURNER labels.join(".")
```

### 5.3 Visualisation ASCII

```
                        DNS MESSAGE FORMAT

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          ID (16 bits)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |QR|  Opcode |AA|TC|RD|RA|  Z  |       RCODE       |            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       QDCOUNT (16 bits)                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       ANCOUNT (16 bits)                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       NSCOUNT (16 bits)                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       ARCOUNT (16 bits)                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                        NAME ENCODING

    "www.example.com" encoded:

    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    | 3 | w | w | w | 7 | e | x | a | m | p | l | e | 3 | c | o | m | 0 |
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
      ^                 ^                           ^                 ^
      |                 |                           |                 |
    length            length                      length           null
    of "www"         of "example"                of "com"        terminator


                        COMPRESSION POINTER

    Offset 0x0C: [7] [e] [x] [a] [m] [p] [l] [e] [3] [c] [o] [m] [0]
                 ^
                 |
    Offset 0x2A: [0xC0] [0x0C]  ---> Points to offset 0x0C
                   |      |
                   +------+
                   Pointer flag (11) + offset (0x00C)


                        RESOLUTION FLOW

    Client                  Resolver                 Authoritative
       |                        |                          |
       |  Query: google.com A   |                          |
       |----------------------->|                          |
       |                        |  Query: google.com A     |
       |                        |------------------------->|
       |                        |  Response: 142.250.x.x   |
       |                        |<-------------------------|
       |  Response: 142.250.x.x |                          |
       |<-----------------------|                          |
       |                        |                          |
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Little-endian** | x86 utilise LE, DNS utilise BE | Toujours `to_be_bytes()` |
| **Null terminator** | Oubli du 0 final dans les noms | Verifier que encode_name termine par 0 |
| **Pointeurs** | 0xC0 = pointeur, pas longueur | Checker `(byte & 0xC0) == 0xC0` |
| **ID mismatch** | Reponse pour autre requete | Toujours verifier `response.id == query.id` |
| **TTL = 0** | Cache indefini | Respecter le TTL minimum (60s) |
| **Buffer overflow** | Reponse > 512 bytes | Verifier bounds avant chaque acces |

### 5.5 Cours Complet

#### 5.5.1 Le protocole DNS

DNS (Domain Name System) est le "annuaire telephonique" d'Internet :
- **But** : Traduire noms lisibles -> adresses IP
- **Port** : 53 (UDP pour queries, TCP pour transferts de zone)
- **Hierarchie** : . (root) -> TLD (.com) -> Domain (google) -> Subdomain (www)

```
Query pour www.google.com:
1. Root server: "Demande aux serveurs .com"
2. .com TLD: "Demande aux serveurs google.com"
3. google.com NS: "www.google.com = 142.250.74.46"
```

#### 5.5.2 Structure du header DNS

```rust
pub struct DnsHeader {
    id: u16,        // Transaction ID (match request/response)
    flags: u16,     // QR|Opcode|AA|TC|RD|RA|Z|RCODE
    qd_count: u16,  // Number of questions
    an_count: u16,  // Number of answers
    ns_count: u16,  // Number of authority records
    ar_count: u16,  // Number of additional records
}
```

**Flags detailles :**
- **QR** (1 bit) : Query (0) ou Response (1)
- **Opcode** (4 bits) : Type d'operation (0 = query standard)
- **AA** (1 bit) : Authoritative Answer
- **TC** (1 bit) : Truncated (message coupe)
- **RD** (1 bit) : Recursion Desired
- **RA** (1 bit) : Recursion Available
- **RCODE** (4 bits) : 0=OK, 1=Format Error, 2=Server Fail, 3=NXDOMAIN

#### 5.5.3 Types d'enregistrements

| Type | Valeur | Description |
|------|--------|-------------|
| A | 1 | Adresse IPv4 |
| NS | 2 | Nameserver |
| CNAME | 5 | Canonical name (alias) |
| SOA | 6 | Start of Authority |
| MX | 15 | Mail exchanger |
| TXT | 16 | Text record |
| AAAA | 28 | Adresse IPv6 |

#### 5.5.4 Compression des noms

Pour economiser de la bande passante, DNS permet de referencer des noms deja encodes :

```
Si "example.com" est a l'offset 0x0C dans le message,
au lieu de reecrire "example.com", on ecrit:
  [0xC0, 0x0C] = pointer vers offset 0x0C

Format du pointeur:
  11xxxxxx xxxxxxxx
  ^^ bits de flag (toujours 11 = 0xC0)
     ^^^^^^ ^^^^^^^^ offset sur 14 bits
```

#### 5.5.5 Big-Endian (Network Byte Order)

Les protocoles reseau utilisent big-endian (octet de poids fort en premier) :

```
u16 value = 0x1234

Big-endian (network):    [0x12, 0x34]  // MSB first
Little-endian (x86):     [0x34, 0x12]  // LSB first

En Rust:
value.to_be_bytes()  // [0x12, 0x34] - Correct pour DNS
value.to_le_bytes()  // [0x34, 0x12] - FAUX pour DNS
```

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------------+
| HORS NORME                                                          |
+---------------------------------------------------------------------+
| let id_bytes = self.id.to_le_bytes();  // Little-endian!            |
|                                                                      |
| for label in name.split('.') {                                      |
|     bytes.push(label.len() as u8);                                  |
|     bytes.extend(label.as_bytes());                                 |
| }                                                                    |
| // Missing: bytes.push(0);                                          |
+---------------------------------------------------------------------+
| CONFORME                                                            |
+---------------------------------------------------------------------+
| let id_bytes = self.id.to_be_bytes();  // Big-endian (network)      |
|                                                                      |
| for label in name.split('.') {                                      |
|     if !label.is_empty() {                                          |
|         bytes.push(label.len() as u8);                              |
|         bytes.extend(label.as_bytes());                             |
|     }                                                                |
| }                                                                    |
| bytes.push(0);  // Null terminator obligatoire                      |
+---------------------------------------------------------------------+
| POURQUOI ?                                                          |
| - DNS utilise network byte order (big-endian) partout               |
| - Le null terminator marque la fin du nom                           |
| - Sans lui, le serveur ne sait pas ou s'arrete le nom               |
+---------------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Scenario :** Resolution de "www.google.com" type A

```
+-------+-----------------------------------------------+---------------------------+
| Etape | Action                                        | Donnees                   |
+-------+-----------------------------------------------+---------------------------+
|   1   | Generer ID                                    | id = 0x1234               |
|   2   | Construire header                             | flags = 0x0100 (RD)       |
|   3   | Encoder nom                                   | [3,w,w,w,6,g,o,o,g,l,e,   |
|       |                                               |  3,c,o,m,0]               |
|   4   | Ajouter question (type A, class IN)           | [0x00,0x01,0x00,0x01]     |
|   5   | Envoyer UDP vers 8.8.8.8:53                   | 33 bytes                  |
|   6   | Recevoir reponse                              | ~60 bytes                 |
|   7   | Parser header reponse                         | id=0x1234, flags=0x8180   |
|   8   | Verifier ID match                             | 0x1234 == 0x1234 OK       |
|   9   | Verifier RCODE                                | rcode=0 (no error)        |
|  10   | Parser question (skip)                        | offset += question_len    |
|  11   | Parser answer                                 | name=www.google.com       |
|       |                                               | type=A, ttl=300           |
|       |                                               | data=142.250.74.46        |
|  12   | Retourner records                             | [DnsRecord { A(142...) }] |
+-------+-----------------------------------------------+---------------------------+
```

### 5.8 Mnemotechniques

#### "The Oracle of Networks" (The Matrix)

*Dans The Matrix, l'Oracle connait la verite cachee derriere les apparences. DNS est l'Oracle du reseau : il revele les vraies adresses IP derriere les noms de domaine.*

```rust
// "There is no spoon" -> "There is no domain name"
// Seule l'IP existe vraiment, le nom n'est qu'une abstraction
let ip = resolver.resolve("the-oracle.matrix.net", RecordType::A).await?;
// Neo pensait parler a "the-oracle.matrix.net"
// En realite, il parlait a 192.168.1.1
```

#### "BEN" = Big-Endian Network

Tous les protocoles reseau utilisent **B**ig-**E**ndian pour le **N**etwork byte order.

#### "PTR = Pointer, Not Length"

Si `(byte & 0xC0) == 0xC0`, c'est un **P**oin**T**e**R**, pas une longueur de label.

### 5.9 Applications pratiques

1. **dig/nslookup** : Outils CLI qui font exactement ce qu'on implemente
2. **Pi-hole** : Intercepte les requetes DNS pour bloquer les pubs
3. **DNS-over-HTTPS** : Chiffre les requetes DNS (Cloudflare 1.1.1.1)
4. **Dynamic DNS** : Met a jour les enregistrements quand l'IP change
5. **GeoDNS** : Retourne des IPs differentes selon la localisation

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Little-endian | Serveur rejette ou parse mal | `to_be_bytes()` partout |
| 2 | Pas de null terminator | Requete invalide | Toujours terminer par `bytes.push(0)` |
| 3 | Ignorer les pointeurs | Noms tronques ou garbage | Checker `(len & 0xC0) == 0xC0` |
| 4 | Pas de verification ID | Vulnerable au spoofing | `assert!(response.id == query.id)` |
| 5 | Cache sans TTL | Donnees obsoletes | Respecter `expires_at = now + ttl` |
| 6 | Bounds non verifies | Panic sur malformed packet | Verifier `offset + len <= data.len()` |

---

## SECTION 7 : QCM

### Question 1
**Quel est le format d'encodage d'un nom DNS ?**

A) Null-terminated string
B) Length-prefixed labels, null-terminated
C) Comma-separated values
D) Base64 encoded
E) UTF-16 with BOM
F) Fixed-length fields
G) JSON string
H) URL-encoded
I) Hexadecimal
J) Binary tree

**Reponse : B**

*Explication : Les noms DNS sont encodes en labels prefixes par leur longueur, avec un octet null final. Ex: "www.example.com" -> [3,'w','w','w',7,'e','x','a','m','p','l','e',3,'c','o','m',0]*

---

### Question 2
**Que signifie le premier octet 0xC0 dans un nom DNS ?**

A) Fin du nom
B) Label de 192 caracteres
C) Debut d'un pointeur de compression
D) Caractere special
E) Erreur de parsing
F) Padding
G) Checksum
H) Separateur de label
I) Marque de recursion
J) Type d'enregistrement

**Reponse : C**

*Explication : Les bits 11xxxxxx (0xC0+) indiquent un pointeur de compression. Les 14 bits suivants donnent l'offset vers le nom deja encode.*

---

### Question 3
**Pourquoi est-il important de verifier l'ID de la reponse DNS ?**

A) Pour le debugging
B) Pour mesurer la latence
C) Pour eviter les reponses spoofees ou melangees
D) Pour compresser les donnees
E) Pour le chiffrement
F) Pour le load balancing
G) Pour la facturation
H) C'est optionnel
I) Pour le caching
J) Pour la recursion

**Reponse : C**

*Explication : Sans verification de l'ID, un attaquant pourrait envoyer des fausses reponses (DNS spoofing), ou on pourrait recevoir une reponse pour une autre requete.*

---

### Question 4
**Quel byte order utilise le protocole DNS ?**

A) Little-endian (comme x86)
B) Big-endian (network byte order)
C) Mixed-endian
D) Depend de la plateforme
E) UTF-8
F) Variable selon le champ
G) Pas d'entiers dans DNS
H) Middle-endian
I) Auto-detecte
J) Configurable

**Reponse : B**

*Explication : DNS, comme tous les protocoles reseau, utilise big-endian (network byte order). En Rust, utilisez `to_be_bytes()` et `from_be_bytes()`.*

---

### Question 5
**Que represente le RCODE 3 dans une reponse DNS ?**

A) Success
B) Format Error
C) Server Failure
D) NXDOMAIN (Name does not exist)
E) Not Implemented
F) Refused
G) Timeout
H) Truncated
I) Network Error
J) Cache Miss

**Reponse : D**

*Explication : RCODE 3 = NXDOMAIN signifie que le domaine demande n'existe pas. C'est une reponse valide (pas une erreur de communication).*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | dns_resolver |
| **Module** | 5.1.6 - DNS Protocol & Resolution |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 250 (base) + bonus x3 |
| **Concepts cles** | DNS protocol, binary parsing, UDP, compression, cache |
| **Piege principal** | Endianness et compression des noms |
| **Prerequis valide** | tokio::net, binary parsing, HashMap |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.6-a-dns-resolver",
    "generated_at": "2024-01-15T12:00:00Z",

    "metadata": {
      "exercise_id": "5.1.6-a",
      "exercise_name": "dns_resolver",
      "module": "5.1.6",
      "module_name": "DNS Protocol & Resolution",
      "concept": "a",
      "concept_name": "DNS Resolver Client",
      "type": "code",
      "tier": 2,
      "tier_info": "Integration",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "********--",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 250,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "EXPERT",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.3", "5.1.1", "5.1.4", "2.4"],
      "domains": ["Net", "Parse", "Algo"],
      "domains_bonus": ["Algo", "Mem"],
      "tags": ["networking", "dns", "udp", "protocol", "parsing", "async"],
      "meme_reference": "The Oracle of Networks (The Matrix)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_encoding.rs": "/* Section 4.10 - Null terminator */",
      "mutants/mutant_b_endianness.rs": "/* Section 4.10 - Little-endian */",
      "mutants/mutant_c_pointer.rs": "/* Section 4.10 - No compression */",
      "mutants/mutant_d_id_match.rs": "/* Section 4.10 - No ID check */",
      "mutants/mutant_e_ttl.rs": "/* Section 4.10 - No TTL expiration */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_encoding.rs",
        "mutants/mutant_b_endianness.rs",
        "mutants/mutant_c_pointer.rs",
        "mutants/mutant_d_id_match.rs",
        "mutants/mutant_e_ttl.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no spoon, only IP addresses"*
*Exercise Quality Score: 96/100*
