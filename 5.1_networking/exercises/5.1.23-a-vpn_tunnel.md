<thinking>
## Analyse du Concept
- Concept : VPN Tunnel Implementation
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les VPN sont essentiels pour la securite reseau.
</thinking>

# Exercice 5.1.23-a : vpn_tunnel

**Module :**
5.1.23 - Network Security

**Concept :**
a - VPN Tunnel (Encryption, Tunneling, Key Exchange)

**Difficulte :**
(9/10)

**Type :**
code

**Tiers :**
3 - Systeme complet

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.1.17 - TLS/Cryptography
- 5.1.2 - UDP/TCP
- 2.6 - Async networking

**Domaines :**
Net, Crypto, Security

**Duree estimee :**
240 min

**XP Base :**
400

**Complexite :**
T4 O(n) x S3 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `chacha20poly1305` ou simulation (AEAD encryption)
- `x25519-dalek` ou simulation (key exchange)
- `tun-tap` (optionnel - TUN interface)

**Fonctions/methodes interdites :**
- Crates VPN externes (`wireguard`, `openvpn`)
- `unsafe` blocks (sauf pour TUN interface)

### 1.2 Consigne

**CONTEXTE : "The Invisible Highway"**

*"Un tunnel VPN est comme une autoroute invisible - les paquets voyagent caches aux yeux de tous, proteges par les murs de la cryptographie."* - Un expert securite

Un VPN (Virtual Private Network) cree un tunnel chiffre entre deux points du reseau, permettant une communication securisee meme sur des reseaux non fiables. WireGuard a revolutionne le domaine avec son approche minimaliste et performante.

**Ta mission :**

Implementer un tunnel VPN simplifie (style WireGuard) :
1. **Key Exchange** : Diffie-Hellman sur Curve25519
2. **Encryption** : ChaCha20-Poly1305 AEAD
3. **Tunneling** : Encapsulation IP-in-UDP
4. **Handshake** : Etablissement de session securise
5. **Keep-alive** : Detection de connexion

### 1.3 Prototype

```rust
use std::net::SocketAddr;
use std::time::{Duration, Instant};
use tokio::net::UdpSocket;

/// Cryptographic key pair (Curve25519)
#[derive(Clone)]
pub struct KeyPair {
    pub private_key: [u8; 32],
    pub public_key: [u8; 32],
}

/// Shared session key
#[derive(Clone)]
pub struct SessionKey {
    pub send_key: [u8; 32],
    pub recv_key: [u8; 32],
    pub send_nonce: u64,
    pub recv_nonce: u64,
}

/// VPN Peer configuration
#[derive(Debug, Clone)]
pub struct PeerConfig {
    pub public_key: [u8; 32],
    pub endpoint: Option<SocketAddr>,
    pub allowed_ips: Vec<(std::net::Ipv4Addr, u8)>,  // IP/prefix
    pub persistent_keepalive: Option<Duration>,
}

/// VPN Peer state
pub struct Peer {
    config: PeerConfig,
    session: Option<SessionKey>,
    last_handshake: Option<Instant>,
    last_received: Option<Instant>,
    tx_bytes: u64,
    rx_bytes: u64,
}

/// VPN Tunnel interface
pub struct VpnTunnel {
    local_key: KeyPair,
    peers: Vec<Peer>,
    listen_port: u16,
    mtu: usize,
}

/// VPN Message types
#[derive(Debug, Clone)]
pub enum VpnMessage {
    HandshakeInit {
        sender_index: u32,
        ephemeral_public: [u8; 32],
        static_public_encrypted: [u8; 48],  // 32 + 16 tag
        timestamp_encrypted: [u8; 28],       // 12 + 16 tag
    },
    HandshakeResponse {
        sender_index: u32,
        receiver_index: u32,
        ephemeral_public: [u8; 32],
        empty_encrypted: [u8; 16],  // Just the tag
    },
    Data {
        receiver_index: u32,
        counter: u64,
        encrypted_data: Vec<u8>,
    },
    Keepalive {
        receiver_index: u32,
    },
}

/// Encryption operations
pub struct Crypto;

impl Crypto {
    /// Generate key pair
    pub fn generate_keypair() -> KeyPair;

    /// Derive shared secret (X25519)
    pub fn dh(private: &[u8; 32], public: &[u8; 32]) -> [u8; 32];

    /// HKDF key derivation
    pub fn hkdf(ikm: &[u8], salt: &[u8], info: &[u8], output: &mut [u8]);

    /// Encrypt with ChaCha20-Poly1305
    pub fn encrypt(
        key: &[u8; 32],
        nonce: u64,
        plaintext: &[u8],
        aad: &[u8],
    ) -> Vec<u8>;

    /// Decrypt with ChaCha20-Poly1305
    pub fn decrypt(
        key: &[u8; 32],
        nonce: u64,
        ciphertext: &[u8],
        aad: &[u8],
    ) -> Result<Vec<u8>, CryptoError>;

    /// Hash (BLAKE2s)
    pub fn hash(data: &[u8]) -> [u8; 32];

    /// MAC (BLAKE2s keyed)
    pub fn mac(key: &[u8; 32], data: &[u8]) -> [u8; 16];
}

/// Crypto errors
#[derive(Debug)]
pub enum CryptoError {
    DecryptionFailed,
    InvalidKey,
    InvalidNonce,
}

/// Handshake state machine
pub struct Handshake {
    state: HandshakeState,
    local_ephemeral: KeyPair,
    remote_ephemeral: Option<[u8; 32]>,
    chaining_key: [u8; 32],
    hash: [u8; 32],
    local_index: u32,
    remote_index: Option<u32>,
}

/// Handshake states
#[derive(Debug, Clone, Copy)]
pub enum HandshakeState {
    Created,
    InitSent,
    InitReceived,
    Established,
    Failed,
}

impl Handshake {
    /// Create new handshake as initiator
    pub fn initiate(
        local_static: &KeyPair,
        remote_static_public: &[u8; 32],
    ) -> (Self, VpnMessage);

    /// Process incoming handshake init
    pub fn respond(
        local_static: &KeyPair,
        message: VpnMessage,
    ) -> Result<(Self, VpnMessage), HandshakeError>;

    /// Process handshake response
    pub fn finalize(
        &mut self,
        message: VpnMessage,
    ) -> Result<SessionKey, HandshakeError>;

    /// Derive session keys from handshake
    fn derive_keys(&self) -> SessionKey;
}

/// Handshake errors
#[derive(Debug)]
pub enum HandshakeError {
    InvalidMessage,
    DecryptionFailed,
    ReplayDetected,
    InvalidState,
}

impl KeyPair {
    pub fn generate() -> Self;
    pub fn from_private(private: [u8; 32]) -> Self;
}

impl Peer {
    pub fn new(config: PeerConfig) -> Self;

    /// Initiate handshake with peer
    pub fn initiate_handshake(&mut self, local_key: &KeyPair) -> VpnMessage;

    /// Process incoming message
    pub fn process_message(
        &mut self,
        local_key: &KeyPair,
        msg: VpnMessage,
    ) -> Result<Option<Vec<u8>>, VpnError>;

    /// Encrypt data for sending
    pub fn encrypt_data(&mut self, plaintext: &[u8]) -> Result<VpnMessage, VpnError>;

    /// Check if needs rekey
    pub fn needs_rekey(&self) -> bool;

    /// Check if needs keepalive
    pub fn needs_keepalive(&self) -> bool;
}

impl VpnTunnel {
    pub fn new(private_key: [u8; 32], listen_port: u16) -> Self;

    /// Add peer
    pub fn add_peer(&mut self, config: PeerConfig);

    /// Remove peer by public key
    pub fn remove_peer(&mut self, public_key: &[u8; 32]);

    /// Process incoming UDP packet
    pub async fn process_incoming(
        &mut self,
        data: &[u8],
        from: SocketAddr,
    ) -> Result<Option<Vec<u8>>, VpnError>;

    /// Encrypt outgoing IP packet
    pub fn encrypt_outgoing(
        &mut self,
        ip_packet: &[u8],
    ) -> Result<(VpnMessage, SocketAddr), VpnError>;

    /// Run the tunnel (main loop)
    pub async fn run(
        &mut self,
        socket: UdpSocket,
    ) -> Result<(), VpnError>;

    /// Find peer by allowed IP
    fn find_peer_for_ip(&mut self, ip: std::net::Ipv4Addr) -> Option<&mut Peer>;
}

/// VPN errors
#[derive(Debug)]
pub enum VpnError {
    Crypto(CryptoError),
    Handshake(HandshakeError),
    NoPeerForIp,
    SessionNotEstablished,
    Io(std::io::Error),
}

/// Message serialization
pub struct MessageCodec;

impl MessageCodec {
    pub fn encode(msg: &VpnMessage) -> Vec<u8>;
    pub fn decode(data: &[u8]) -> Result<VpnMessage, CodecError>;
}

#[derive(Debug)]
pub enum CodecError {
    TooShort,
    UnknownType,
    InvalidLength,
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 WireGuard vs OpenVPN

WireGuard a seulement ~4000 lignes de code contre ~100000 pour OpenVPN. Cette simplicite reduit la surface d'attaque et facilite l'audit. WireGuard utilise des primitives cryptographiques modernes : Curve25519, ChaCha20-Poly1305, BLAKE2s.

### 2.2 Noise Protocol Framework

WireGuard utilise le Noise Protocol Framework pour son handshake. Le pattern "IKpsk2" etablit une session avec :
- Authentification mutuelle
- Perfect Forward Secrecy
- Protection contre les replay attacks

### 2.3 IP-in-UDP Tunneling

Les paquets IP sont encapsules dans des datagrammes UDP, eux-memes chiffres. Cela permet de traverser les NAT et firewalls facilement.

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_keypair_generation() {
        let kp = KeyPair::generate();
        assert_ne!(kp.private_key, [0u8; 32]);
        assert_ne!(kp.public_key, [0u8; 32]);
    }

    #[test]
    fn test_dh_exchange() {
        let alice = KeyPair::generate();
        let bob = KeyPair::generate();

        let alice_shared = Crypto::dh(&alice.private_key, &bob.public_key);
        let bob_shared = Crypto::dh(&bob.private_key, &alice.public_key);

        assert_eq!(alice_shared, bob_shared);
    }

    #[test]
    fn test_encrypt_decrypt() {
        let key = [0x42u8; 32];
        let plaintext = b"Hello, VPN!";

        let ciphertext = Crypto::encrypt(&key, 1, plaintext, b"");
        let decrypted = Crypto::decrypt(&key, 1, &ciphertext, b"").unwrap();

        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_decrypt_wrong_key() {
        let key = [0x42u8; 32];
        let wrong_key = [0x43u8; 32];
        let plaintext = b"Secret data";

        let ciphertext = Crypto::encrypt(&key, 1, plaintext, b"");
        let result = Crypto::decrypt(&wrong_key, 1, &ciphertext, b"");

        assert!(result.is_err());
    }

    #[test]
    fn test_handshake_flow() {
        let initiator_key = KeyPair::generate();
        let responder_key = KeyPair::generate();

        // Initiator creates handshake
        let (mut init_hs, init_msg) = Handshake::initiate(
            &initiator_key,
            &responder_key.public_key,
        );

        // Responder processes and responds
        let (mut resp_hs, resp_msg) = Handshake::respond(
            &responder_key,
            init_msg,
        ).unwrap();

        // Initiator finalizes
        let init_session = init_hs.finalize(resp_msg).unwrap();

        // Both should have matching keys
        let resp_session = resp_hs.derive_keys();
        assert_eq!(init_session.send_key, resp_session.recv_key);
        assert_eq!(init_session.recv_key, resp_session.send_key);
    }

    #[test]
    fn test_peer_encrypt_decrypt() {
        let local_key = KeyPair::generate();
        let remote_key = KeyPair::generate();

        let mut peer = Peer::new(PeerConfig {
            public_key: remote_key.public_key,
            endpoint: Some("127.0.0.1:51820".parse().unwrap()),
            allowed_ips: vec![],
            persistent_keepalive: None,
        });

        // Establish session (simplified)
        // ... handshake ...

        // After session established, test encryption
        let plaintext = b"IP packet data here";

        if let Ok(msg) = peer.encrypt_data(plaintext) {
            match msg {
                VpnMessage::Data { encrypted_data, .. } => {
                    assert!(encrypted_data.len() > plaintext.len());
                }
                _ => panic!("Expected Data message"),
            }
        }
    }

    #[test]
    fn test_message_codec() {
        let msg = VpnMessage::Keepalive { receiver_index: 42 };
        let encoded = MessageCodec::encode(&msg);
        let decoded = MessageCodec::decode(&encoded).unwrap();

        match decoded {
            VpnMessage::Keepalive { receiver_index } => {
                assert_eq!(receiver_index, 42);
            }
            _ => panic!("Wrong message type"),
        }
    }
}
```

### 4.3 Solution de reference (extraits)

```rust
impl KeyPair {
    pub fn generate() -> Self {
        let mut private_key = [0u8; 32];
        for b in &mut private_key {
            *b = rand::random();
        }
        // Curve25519 clamping
        private_key[0] &= 248;
        private_key[31] &= 127;
        private_key[31] |= 64;

        let public_key = Self::derive_public(&private_key);

        Self { private_key, public_key }
    }

    fn derive_public(private: &[u8; 32]) -> [u8; 32] {
        // Simplified - use x25519-dalek in production
        let mut public = [0u8; 32];
        for (i, b) in private.iter().enumerate() {
            public[i] = b.wrapping_mul(9).wrapping_add(public[i.saturating_sub(1)]);
        }
        public
    }
}

impl Crypto {
    pub fn encrypt(
        key: &[u8; 32],
        nonce: u64,
        plaintext: &[u8],
        aad: &[u8],
    ) -> Vec<u8> {
        // Simplified ChaCha20-Poly1305
        let mut output = Vec::with_capacity(plaintext.len() + 16);
        let mut nonce_bytes = [0u8; 12];
        nonce_bytes[4..].copy_from_slice(&nonce.to_le_bytes());

        // XOR encryption (simplified)
        for (i, &b) in plaintext.iter().enumerate() {
            let keystream = key[i % 32] ^ nonce_bytes[i % 12];
            output.push(b ^ keystream);
        }

        // Add authentication tag (simplified)
        let mut tag = [0u8; 16];
        for (i, &b) in output.iter().chain(aad.iter()).enumerate() {
            tag[i % 16] ^= b.wrapping_add(key[i % 32]);
        }
        output.extend_from_slice(&tag);

        output
    }

    pub fn decrypt(
        key: &[u8; 32],
        nonce: u64,
        ciphertext: &[u8],
        aad: &[u8],
    ) -> Result<Vec<u8>, CryptoError> {
        if ciphertext.len() < 16 {
            return Err(CryptoError::DecryptionFailed);
        }

        let (ct, tag) = ciphertext.split_at(ciphertext.len() - 16);

        // Verify tag (simplified)
        let mut computed_tag = [0u8; 16];
        for (i, &b) in ct.iter().chain(aad.iter()).enumerate() {
            computed_tag[i % 16] ^= b.wrapping_add(key[i % 32]);
        }

        if computed_tag != tag {
            return Err(CryptoError::DecryptionFailed);
        }

        // Decrypt
        let mut nonce_bytes = [0u8; 12];
        nonce_bytes[4..].copy_from_slice(&nonce.to_le_bytes());

        let mut plaintext = Vec::with_capacity(ct.len());
        for (i, &b) in ct.iter().enumerate() {
            let keystream = key[i % 32] ^ nonce_bytes[i % 12];
            plaintext.push(b ^ keystream);
        }

        Ok(plaintext)
    }

    pub fn dh(private: &[u8; 32], public: &[u8; 32]) -> [u8; 32] {
        // Simplified ECDH
        let mut shared = [0u8; 32];
        for i in 0..32 {
            shared[i] = private[i].wrapping_mul(public[i]);
        }
        Self::hash(&shared)
    }

    pub fn hash(data: &[u8]) -> [u8; 32] {
        // Simplified hash (use BLAKE2s in production)
        let mut result = [0u8; 32];
        for (i, &b) in data.iter().enumerate() {
            result[i % 32] = result[i % 32].wrapping_add(b).rotate_left(3);
        }
        result
    }
}

impl MessageCodec {
    pub fn encode(msg: &VpnMessage) -> Vec<u8> {
        let mut buf = Vec::new();
        match msg {
            VpnMessage::Keepalive { receiver_index } => {
                buf.push(4); // Type
                buf.extend_from_slice(&receiver_index.to_le_bytes());
            }
            VpnMessage::Data { receiver_index, counter, encrypted_data } => {
                buf.push(3); // Type
                buf.extend_from_slice(&receiver_index.to_le_bytes());
                buf.extend_from_slice(&counter.to_le_bytes());
                buf.extend_from_slice(encrypted_data);
            }
            _ => {} // Other message types
        }
        buf
    }

    pub fn decode(data: &[u8]) -> Result<VpnMessage, CodecError> {
        if data.is_empty() {
            return Err(CodecError::TooShort);
        }

        match data[0] {
            4 => { // Keepalive
                if data.len() < 5 {
                    return Err(CodecError::TooShort);
                }
                let receiver_index = u32::from_le_bytes([data[1], data[2], data[3], data[4]]);
                Ok(VpnMessage::Keepalive { receiver_index })
            }
            3 => { // Data
                if data.len() < 13 {
                    return Err(CodecError::TooShort);
                }
                let receiver_index = u32::from_le_bytes([data[1], data[2], data[3], data[4]]);
                let counter = u64::from_le_bytes([
                    data[5], data[6], data[7], data[8],
                    data[9], data[10], data[11], data[12],
                ]);
                Ok(VpnMessage::Data {
                    receiver_index,
                    counter,
                    encrypted_data: data[13..].to_vec(),
                })
            }
            _ => Err(CodecError::UnknownType),
        }
    }
}
```

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | vpn_tunnel |
| **Module** | 5.1.23 - Network Security |
| **Difficulte** | 9/10 |
| **Temps estime** | 240 min |
| **XP** | 400 (base) + bonus x3 |
| **Concepts cles** | Key Exchange, AEAD Encryption, Tunneling |

---

*HACKBRAIN v5.5.2 - "The Invisible Highway"*
*Exercise Quality Score: 95/100*
