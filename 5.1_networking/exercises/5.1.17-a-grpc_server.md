<thinking>
## Analyse du Concept
- Concept : gRPC Server Implementation
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - gRPC est le standard RPC moderne utilise par Google, Kubernetes, et microservices. L'exercice combine Protocol Buffers, HTTP/2, et streaming bidirectionnel.

## Combo Base + Bonus
- Exercice de base : Implementation d'un serveur gRPC avec unary calls, encoding protobuf, et metadata handling
- Bonus : Implementation de streaming bidirectionnel et intercepteurs middleware
- Palier bonus : AVANCE (streaming async + middleware chain)
- Progression logique ? OUI - Base = requete/reponse simple, Bonus = streams complexes

## Prerequis & Difficulte
- Prerequis reels : HTTP/2 fundamentals, Protocol Buffers, async Rust (tokio)
- Difficulte estimee : 8/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "Star Trek" - Communications interstellaires comme RPC distant
- MEME mn√©motechnique : "Beam me up, gRPC" (parodie de "Beam me up, Scotty")
- Pourquoi c'est fun : gRPC teleporte vos donnees comme le transporteur de l'Enterprise

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Message protobuf trop grand non rejete
2. Mutant B (Safety) : Metadata non validee (injection possible)
3. Mutant C (Logic) : Status code mal mappe (OK au lieu de error)
4. Mutant D (Edge) : Stream ferme mais donnees encore envoyees
5. Mutant E (Return) : Deadline non respectee (timeout ignore)

## Verdict
VALIDE - Exercice de qualite industrielle couvrant le protocole gRPC
</thinking>

# Exercice 5.1.17-a : grpc_server

**Module :**
5.1.17 - gRPC Protocol Implementation

**Concept :**
a - gRPC Server Engine (Protocol Buffers, HTTP/2, Streaming)

**Difficulte :**
(8/10)

**Type :**
code

**Tiers :**
2 - Multi-concepts integres

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.1.16 - HTTP/2 Multiplexing
- 2.4 - Async Rust (tokio runtime)
- 2.5 - Serialization (serde basics)
- 2.3 - Traits et generics avances

**Domaines :**
Net, Proto, Async, RPC

**Duree estimee :**
180 min

**XP Base :**
300

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `tokio` (runtime async)
- `bytes` (BytesMut, Buf, BufMut)
- `prost` (Protocol Buffers encoding - optionnel)
- `std::collections::{HashMap, VecDeque}`

**Fonctions/methodes interdites :**
- Crates gRPC externes (`tonic`, `grpc-rs`)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "Star Trek: The gRPC Generation"**

*"Beam me up, gRPC! We need to send this protobuf message to the Enterprise before the Klingons intercept our HTTP/1.1 transmission!"* - Captain Kirk, s'il etait ingenieur backend

gRPC (gRPC Remote Procedure Calls) est le framework RPC moderne de Google, utilise par Kubernetes, Envoy, et des milliers de microservices. Il combine la puissance de Protocol Buffers (serialisation binaire compacte) avec HTTP/2 (multiplexage, streaming).

**Ta mission :**

Implementer un serveur gRPC complet qui gere :
1. L'encodage/decodage Protocol Buffers simplifie (varint, length-delimited)
2. Le framing gRPC sur HTTP/2 (5-byte header + message)
3. Les appels Unary (requete -> reponse)
4. La gestion des metadata (headers gRPC)
5. Les status codes gRPC et error details

**Entree :**
- `service: GrpcService` - Definition du service avec methodes
- `request: GrpcRequest` - Requete entrante

**Sortie :**
- `GrpcResponse` - Reponse avec status et message
- `GrpcError` - En cas d'erreur de protocole ou applicative

**Contraintes :**
- Message frame : 1 byte compressed flag + 4 bytes length + message
- Content-Type : `application/grpc`
- Metadata : headers HTTP/2 avec prefixe `grpc-`
- Status : `grpc-status` header en trailer

**Exemples :**

| Operation | Resultat | Explication |
|-----------|----------|-------------|
| `Greeter.SayHello(name)` | `HelloReply { message }` | Unary call |
| `invalid service` | `Status::Unimplemented` | Service inconnu |
| `timeout exceeded` | `Status::DeadlineExceeded` | Deadline passee |

### 1.2.2 Consigne Academique

Implementer un serveur gRPC supportant les appels unary avec encodage Protocol Buffers, framing gRPC sur HTTP/2, gestion des metadata, et status codes standardises selon la specification gRPC.

### 1.3 Prototype

```rust
use bytes::{Bytes, BytesMut, Buf, BufMut};
use std::collections::HashMap;
use std::time::Duration;

/// gRPC Status Codes (grpc/grpc spec)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(i32)]
pub enum StatusCode {
    Ok = 0,
    Cancelled = 1,
    Unknown = 2,
    InvalidArgument = 3,
    DeadlineExceeded = 4,
    NotFound = 5,
    AlreadyExists = 6,
    PermissionDenied = 7,
    ResourceExhausted = 8,
    FailedPrecondition = 9,
    Aborted = 10,
    OutOfRange = 11,
    Unimplemented = 12,
    Internal = 13,
    Unavailable = 14,
    DataLoss = 15,
    Unauthenticated = 16,
}

/// gRPC Status with message
#[derive(Debug, Clone)]
pub struct Status {
    pub code: StatusCode,
    pub message: String,
    pub details: Vec<u8>,
}

/// gRPC Metadata (HTTP/2 headers)
#[derive(Debug, Clone, Default)]
pub struct Metadata {
    entries: HashMap<String, MetadataValue>,
}

/// Metadata value (text or binary)
#[derive(Debug, Clone)]
pub enum MetadataValue {
    Text(String),
    Binary(Vec<u8>),
}

/// gRPC Message Frame
#[derive(Debug, Clone)]
pub struct GrpcFrame {
    pub compressed: bool,
    pub data: Bytes,
}

/// Protocol Buffers wire types
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum WireType {
    Varint = 0,
    Fixed64 = 1,
    LengthDelimited = 2,
    StartGroup = 3,  // Deprecated
    EndGroup = 4,    // Deprecated
    Fixed32 = 5,
}

/// Protobuf field
#[derive(Debug, Clone)]
pub struct ProtoField {
    pub field_number: u32,
    pub wire_type: WireType,
    pub value: ProtoValue,
}

/// Protobuf value
#[derive(Debug, Clone)]
pub enum ProtoValue {
    Varint(u64),
    Fixed64(u64),
    Fixed32(u32),
    LengthDelimited(Bytes),
}

/// Protobuf message (simplified)
#[derive(Debug, Clone, Default)]
pub struct ProtoMessage {
    pub fields: Vec<ProtoField>,
}

/// gRPC Method descriptor
#[derive(Debug, Clone)]
pub struct MethodDescriptor {
    pub name: String,
    pub full_name: String,  // /package.Service/Method
    pub client_streaming: bool,
    pub server_streaming: bool,
}

/// gRPC Service descriptor
#[derive(Debug, Clone)]
pub struct ServiceDescriptor {
    pub name: String,
    pub full_name: String,
    pub methods: Vec<MethodDescriptor>,
}

/// gRPC Request
#[derive(Debug)]
pub struct GrpcRequest {
    pub method: String,  // Full method path
    pub metadata: Metadata,
    pub message: ProtoMessage,
    pub deadline: Option<std::time::Instant>,
}

/// gRPC Response
#[derive(Debug)]
pub struct GrpcResponse {
    pub metadata: Metadata,
    pub message: Option<ProtoMessage>,
    pub status: Status,
    pub trailing_metadata: Metadata,
}

/// gRPC Error
#[derive(Debug)]
pub enum GrpcError {
    InvalidFrame(String),
    InvalidProtobuf(String),
    ServiceNotFound(String),
    MethodNotFound(String),
    DeadlineExceeded,
    Internal(String),
}

/// Protobuf Encoder
pub struct ProtoEncoder;

impl ProtoEncoder {
    /// Encode varint (variable-length integer)
    pub fn encode_varint(value: u64, buf: &mut BytesMut);

    /// Encode field tag (field_number << 3 | wire_type)
    pub fn encode_tag(field_number: u32, wire_type: WireType, buf: &mut BytesMut);

    /// Encode length-delimited field (string, bytes, embedded message)
    pub fn encode_length_delimited(field_number: u32, data: &[u8], buf: &mut BytesMut);

    /// Encode complete message
    pub fn encode_message(message: &ProtoMessage) -> Bytes;
}

/// Protobuf Decoder
pub struct ProtoDecoder;

impl ProtoDecoder {
    /// Decode varint
    pub fn decode_varint(buf: &mut impl Buf) -> Result<u64, GrpcError>;

    /// Decode field tag
    pub fn decode_tag(buf: &mut impl Buf) -> Result<(u32, WireType), GrpcError>;

    /// Decode complete message
    pub fn decode_message(data: &[u8]) -> Result<ProtoMessage, GrpcError>;
}

/// gRPC Frame Codec
pub struct GrpcCodec;

impl GrpcCodec {
    /// Encode message to gRPC frame (1 + 4 + message bytes)
    pub fn encode_frame(message: &ProtoMessage, compressed: bool) -> Bytes;

    /// Decode gRPC frame
    pub fn decode_frame(buf: &mut BytesMut) -> Result<Option<GrpcFrame>, GrpcError>;
}

/// Metadata operations
impl Metadata {
    pub fn new() -> Self;

    /// Insert text metadata
    pub fn insert(&mut self, key: String, value: String);

    /// Insert binary metadata (key must end with -bin)
    pub fn insert_binary(&mut self, key: String, value: Vec<u8>);

    /// Get metadata value
    pub fn get(&self, key: &str) -> Option<&MetadataValue>;

    /// Get text value
    pub fn get_text(&self, key: &str) -> Option<&str>;

    /// Get binary value
    pub fn get_binary(&self, key: &str) -> Option<&[u8]>;

    /// Convert to HTTP/2 headers
    pub fn to_headers(&self) -> Vec<(String, String)>;

    /// Parse from HTTP/2 headers
    pub fn from_headers(headers: &[(String, String)]) -> Self;
}

/// Status operations
impl Status {
    pub fn ok() -> Self;
    pub fn with_code(code: StatusCode) -> Self;
    pub fn with_message(code: StatusCode, message: impl Into<String>) -> Self;

    /// Check if status is OK
    pub fn is_ok(&self) -> bool;
}

/// gRPC Service Handler trait
pub trait ServiceHandler: Send + Sync {
    /// Get service descriptor
    fn descriptor(&self) -> &ServiceDescriptor;

    /// Handle unary call
    fn handle_unary(
        &self,
        method: &str,
        request: GrpcRequest,
    ) -> Result<GrpcResponse, GrpcError>;
}

/// gRPC Server
pub struct GrpcServer {
    services: HashMap<String, Box<dyn ServiceHandler>>,
    max_message_size: usize,
    default_timeout: Duration,
}

impl GrpcServer {
    /// Create new server
    pub fn new() -> Self;

    /// Register service
    pub fn register_service(&mut self, service: Box<dyn ServiceHandler>);

    /// Process incoming request
    pub fn process_request(
        &self,
        method: &str,
        metadata: Metadata,
        frame: GrpcFrame,
    ) -> Result<GrpcResponse, GrpcError>;

    /// Set max message size
    pub fn set_max_message_size(&mut self, size: usize);

    /// Set default timeout
    pub fn set_default_timeout(&mut self, timeout: Duration);

    /// Parse method path (/package.Service/Method)
    fn parse_method_path(path: &str) -> Option<(&str, &str)>;
}

/// Example: Greeter Service
pub struct GreeterService {
    descriptor: ServiceDescriptor,
}

impl GreeterService {
    pub fn new() -> Self;
}

impl ServiceHandler for GreeterService {
    fn descriptor(&self) -> &ServiceDescriptor;

    fn handle_unary(
        &self,
        method: &str,
        request: GrpcRequest,
    ) -> Result<GrpcResponse, GrpcError>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine de gRPC

gRPC a ete developpe par Google et open-source en 2015. Le "g" signifie initialement "Google", mais l'equipe a depuis adopte differentes significations humoristiques : "good", "green", "groovy"... Le protocole est base sur Stubby, le systeme RPC interne de Google utilise depuis 2001.

### 2.2 Protocol Buffers : L'Art du Varint

Les varints (variable-length integers) sont l'innovation cle de Protocol Buffers. Un entier utilise seulement le nombre d'octets necessaires :

```
Valeur 1:    0x01        (1 byte)
Valeur 127:  0x7F        (1 byte)
Valeur 128:  0x80 0x01   (2 bytes)
Valeur 300:  0xAC 0x02   (2 bytes)
```

Le MSB de chaque byte indique si d'autres bytes suivent.

### 2.3 Le Frame gRPC : 5 Bytes Magiques

Chaque message gRPC est encapsule dans un frame de 5 bytes :

```
+----------+----------------+
| Compress |    Length      |
|  (1 byte)|   (4 bytes)    |
+----------+----------------+-----------------+
|                Message                      |
+---------------------------------------------+
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de gRPC |
|--------|---------------------|
| **Backend Engineer** | APIs microservices haute performance |
| **Platform Engineer** | Infrastructure Kubernetes (kubelet, etcd) |
| **Mobile Developer** | APIs mobiles efficaces (bandwidth reduit) |
| **Data Engineer** | Streaming de donnees (BigQuery, Dataflow) |
| **DevOps/SRE** | Service mesh (Envoy, Istio) |

### Cas d'usage concrets

1. **Kubernetes** : Toute communication interne utilise gRPC (kubelet, API server, etcd)
2. **Netflix** : Migration de REST vers gRPC pour reduire la latence de 300%
3. **Dropbox** : Sync client utilise gRPC pour le streaming bidirectionnel
4. **Envoy Proxy** : Support natif gRPC avec load balancing et circuit breaking

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo test
   Compiling grpc_server v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 18 tests
test tests::test_varint_encode_decode ... ok
test tests::test_tag_encode_decode ... ok
test tests::test_length_delimited ... ok
test tests::test_proto_message ... ok
test tests::test_grpc_frame_encode ... ok
test tests::test_grpc_frame_decode ... ok
test tests::test_metadata_text ... ok
test tests::test_metadata_binary ... ok
test tests::test_metadata_headers ... ok
test tests::test_status_codes ... ok
test tests::test_server_register_service ... ok
test tests::test_server_unary_call ... ok
test tests::test_server_not_found ... ok
test tests::test_server_deadline ... ok
test tests::test_greeter_service ... ok
test tests::test_method_path_parsing ... ok
test tests::test_max_message_size ... ok
test tests::test_invalid_protobuf ... ok

test result: ok. 18 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
(9/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) pour le streaming, O(1) pour les intercepteurs

**Space Complexity attendue :**
O(n) buffer de stream

**Domaines Bonus :**
`Async, Stream`

#### 3.1.1 Consigne Bonus

**"Engage Warp Stream"**

*"Mr. Sulu, activate bidirectional streaming. We need real-time communication with Starfleet."* - Captain Kirk, s'il gerait une flotte de microservices

**Ta mission bonus :**

Implementer :
1. **Server Streaming** : Une requete, multiple reponses
2. **Client Streaming** : Multiple requetes, une reponse
3. **Bidirectional Streaming** : Communication full-duplex
4. **Interceptors** : Middleware chain pour logging, auth, metrics

**Entree :**
- `stream: GrpcStream` - Stream bidirectionnel
- `interceptors: Vec<Interceptor>` - Chain d'intercepteurs

**Sortie :**
- Messages streames avec backpressure
- Execution de la chain d'intercepteurs

#### 3.1.2 Prototype Bonus

```rust
use tokio::sync::mpsc;

/// Streaming types
#[derive(Debug, Clone, Copy)]
pub enum StreamType {
    Unary,
    ServerStreaming,
    ClientStreaming,
    BidirectionalStreaming,
}

/// gRPC Stream (bidirectional)
pub struct GrpcStream {
    incoming: mpsc::Receiver<GrpcFrame>,
    outgoing: mpsc::Sender<GrpcFrame>,
    metadata: Metadata,
}

impl GrpcStream {
    /// Receive next message
    pub async fn recv(&mut self) -> Option<Result<ProtoMessage, GrpcError>>;

    /// Send message
    pub async fn send(&mut self, message: ProtoMessage) -> Result<(), GrpcError>;

    /// Close stream with status
    pub async fn close(self, status: Status) -> Result<(), GrpcError>;
}

/// Interceptor context
pub struct InterceptorContext {
    pub method: String,
    pub metadata: Metadata,
    pub extensions: HashMap<String, Box<dyn std::any::Any + Send + Sync>>,
}

/// Interceptor trait
pub trait Interceptor: Send + Sync {
    /// Called before handler
    fn intercept(
        &self,
        ctx: &mut InterceptorContext,
        request: GrpcRequest,
    ) -> Result<GrpcRequest, Status>;

    /// Called after handler
    fn on_response(
        &self,
        ctx: &InterceptorContext,
        response: &mut GrpcResponse,
    );
}

/// Logging interceptor
pub struct LoggingInterceptor;

/// Authentication interceptor
pub struct AuthInterceptor {
    validate_token: Box<dyn Fn(&str) -> bool + Send + Sync>,
}

/// Metrics interceptor
pub struct MetricsInterceptor {
    histogram: std::sync::Arc<std::sync::Mutex<Vec<Duration>>>,
}

impl GrpcServer {
    /// Add interceptor
    pub fn add_interceptor(&mut self, interceptor: Box<dyn Interceptor>);

    /// Handle streaming call
    pub async fn handle_streaming(
        &self,
        method: &str,
        stream: GrpcStream,
    ) -> Result<(), GrpcError>;
}

/// Streaming service handler trait
pub trait StreamingHandler: Send + Sync {
    /// Handle server streaming
    fn handle_server_streaming(
        &self,
        method: &str,
        request: GrpcRequest,
        response_stream: mpsc::Sender<ProtoMessage>,
    ) -> Result<Status, GrpcError>;

    /// Handle client streaming
    fn handle_client_streaming(
        &self,
        method: &str,
        request_stream: mpsc::Receiver<ProtoMessage>,
    ) -> Result<GrpcResponse, GrpcError>;

    /// Handle bidirectional streaming
    fn handle_bidi_streaming(
        &self,
        method: &str,
        stream: GrpcStream,
    ) -> Result<Status, GrpcError>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `varint_encode_1` | `1u64` | `[0x01]` | 5 | Basic |
| `varint_encode_300` | `300u64` | `[0xAC, 0x02]` | 5 | Basic |
| `varint_decode` | `[0xAC, 0x02]` | `300u64` | 5 | Basic |
| `tag_encode` | `(1, Varint)` | `0x08` | 5 | Core |
| `length_delimited` | `field 1, "hello"` | encoded bytes | 10 | Core |
| `grpc_frame_encode` | message | 5-byte header + msg | 10 | Core |
| `grpc_frame_decode` | frame bytes | `GrpcFrame` | 10 | Core |
| `frame_too_large` | 5MB message | `Err(MessageTooLarge)` | 5 | Edge |
| `metadata_text` | `("key", "value")` | stored correctly | 5 | Core |
| `metadata_binary` | `("key-bin", bytes)` | base64 encoded | 5 | Core |
| `status_ok` | `Status::ok()` | code=0, message="" | 5 | Core |
| `status_error` | `Status::with_code(Internal)` | code=13 | 5 | Core |
| `server_unary` | valid request | `GrpcResponse` | 10 | Core |
| `server_not_found` | invalid service | `Status::Unimplemented` | 5 | Edge |
| `method_not_found` | invalid method | `Status::Unimplemented` | 5 | Edge |
| `deadline_exceeded` | expired deadline | `Status::DeadlineExceeded` | 5 | Edge |
| `invalid_protobuf` | malformed bytes | `Err(InvalidProtobuf)` | 5 | Edge |
| `greeter_hello` | `HelloRequest{name}` | `HelloReply{message}` | 10 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_varint_encode_small() {
        let mut buf = BytesMut::new();
        ProtoEncoder::encode_varint(1, &mut buf);
        assert_eq!(buf.as_ref(), &[0x01]);

        buf.clear();
        ProtoEncoder::encode_varint(127, &mut buf);
        assert_eq!(buf.as_ref(), &[0x7F]);
    }

    #[test]
    fn test_varint_encode_large() {
        let mut buf = BytesMut::new();
        ProtoEncoder::encode_varint(128, &mut buf);
        assert_eq!(buf.as_ref(), &[0x80, 0x01]);

        buf.clear();
        ProtoEncoder::encode_varint(300, &mut buf);
        assert_eq!(buf.as_ref(), &[0xAC, 0x02]);
    }

    #[test]
    fn test_varint_decode() {
        let mut buf = Bytes::from_static(&[0xAC, 0x02]);
        let value = ProtoDecoder::decode_varint(&mut buf).unwrap();
        assert_eq!(value, 300);
    }

    #[test]
    fn test_tag_encode_decode() {
        let mut buf = BytesMut::new();
        ProtoEncoder::encode_tag(1, WireType::Varint, &mut buf);
        assert_eq!(buf.as_ref(), &[0x08]); // (1 << 3) | 0 = 8

        let mut read_buf = buf.freeze();
        let (field_num, wire_type) = ProtoDecoder::decode_tag(&mut read_buf).unwrap();
        assert_eq!(field_num, 1);
        assert_eq!(wire_type, WireType::Varint);
    }

    #[test]
    fn test_grpc_frame_encode() {
        let message = ProtoMessage::default();
        let frame = GrpcCodec::encode_frame(&message, false);

        assert_eq!(frame[0], 0); // Not compressed
        // Next 4 bytes are length (big-endian)
    }

    #[test]
    fn test_grpc_frame_decode() {
        let mut buf = BytesMut::new();
        buf.put_u8(0); // Not compressed
        buf.put_u32(5); // Length
        buf.extend_from_slice(&[0x08, 0x96, 0x01, 0x10, 0x01]); // Protobuf

        let frame = GrpcCodec::decode_frame(&mut buf).unwrap().unwrap();
        assert!(!frame.compressed);
        assert_eq!(frame.data.len(), 5);
    }

    #[test]
    fn test_metadata_text() {
        let mut metadata = Metadata::new();
        metadata.insert("content-type".to_string(), "application/grpc".to_string());

        assert_eq!(
            metadata.get_text("content-type"),
            Some("application/grpc")
        );
    }

    #[test]
    fn test_metadata_binary() {
        let mut metadata = Metadata::new();
        metadata.insert_binary("token-bin".to_string(), vec![0x01, 0x02, 0x03]);

        assert_eq!(
            metadata.get_binary("token-bin"),
            Some(&[0x01, 0x02, 0x03][..])
        );
    }

    #[test]
    fn test_metadata_to_headers() {
        let mut metadata = Metadata::new();
        metadata.insert("grpc-timeout".to_string(), "1S".to_string());
        metadata.insert_binary("auth-bin".to_string(), vec![0xDE, 0xAD]);

        let headers = metadata.to_headers();
        assert!(headers.iter().any(|(k, _)| k == "grpc-timeout"));
    }

    #[test]
    fn test_status_codes() {
        assert!(Status::ok().is_ok());
        assert!(!Status::with_code(StatusCode::Internal).is_ok());
        assert_eq!(Status::with_code(StatusCode::NotFound).code as i32, 5);
    }

    #[test]
    fn test_server_register_service() {
        let mut server = GrpcServer::new();
        server.register_service(Box::new(GreeterService::new()));

        // Service should be registered
        assert!(server.services.contains_key("helloworld.Greeter"));
    }

    #[test]
    fn test_server_unary_call() {
        let mut server = GrpcServer::new();
        server.register_service(Box::new(GreeterService::new()));

        let metadata = Metadata::new();
        let mut message = ProtoMessage::default();
        message.fields.push(ProtoField {
            field_number: 1,
            wire_type: WireType::LengthDelimited,
            value: ProtoValue::LengthDelimited(Bytes::from("World")),
        });

        let frame = GrpcFrame {
            compressed: false,
            data: ProtoEncoder::encode_message(&message),
        };

        let response = server
            .process_request("/helloworld.Greeter/SayHello", metadata, frame)
            .unwrap();

        assert!(response.status.is_ok());
    }

    #[test]
    fn test_server_service_not_found() {
        let server = GrpcServer::new();
        let metadata = Metadata::new();
        let frame = GrpcFrame {
            compressed: false,
            data: Bytes::new(),
        };

        let result = server.process_request("/unknown.Service/Method", metadata, frame);
        match result {
            Err(GrpcError::ServiceNotFound(_)) => {}
            _ => panic!("Expected ServiceNotFound error"),
        }
    }

    #[test]
    fn test_greeter_service() {
        let service = GreeterService::new();
        let descriptor = service.descriptor();

        assert_eq!(descriptor.name, "Greeter");
        assert!(descriptor.methods.iter().any(|m| m.name == "SayHello"));
    }

    #[test]
    fn test_method_path_parsing() {
        let (service, method) = GrpcServer::parse_method_path("/helloworld.Greeter/SayHello")
            .unwrap();
        assert_eq!(service, "helloworld.Greeter");
        assert_eq!(method, "SayHello");
    }

    #[test]
    fn test_invalid_method_path() {
        assert!(GrpcServer::parse_method_path("invalid").is_none());
        assert!(GrpcServer::parse_method_path("/onlyservice").is_none());
    }
}
```

### 4.3 Solution de reference

```rust
use bytes::{Bytes, BytesMut, Buf, BufMut};
use std::collections::HashMap;
use std::time::Duration;

impl ProtoEncoder {
    pub fn encode_varint(mut value: u64, buf: &mut BytesMut) {
        loop {
            let mut byte = (value & 0x7F) as u8;
            value >>= 7;
            if value != 0 {
                byte |= 0x80;
            }
            buf.put_u8(byte);
            if value == 0 {
                break;
            }
        }
    }

    pub fn encode_tag(field_number: u32, wire_type: WireType, buf: &mut BytesMut) {
        let tag = (field_number << 3) | (wire_type as u32);
        Self::encode_varint(tag as u64, buf);
    }

    pub fn encode_length_delimited(field_number: u32, data: &[u8], buf: &mut BytesMut) {
        Self::encode_tag(field_number, WireType::LengthDelimited, buf);
        Self::encode_varint(data.len() as u64, buf);
        buf.extend_from_slice(data);
    }

    pub fn encode_message(message: &ProtoMessage) -> Bytes {
        let mut buf = BytesMut::new();
        for field in &message.fields {
            Self::encode_tag(field.field_number, field.wire_type, &mut buf);
            match &field.value {
                ProtoValue::Varint(v) => Self::encode_varint(*v, &mut buf),
                ProtoValue::Fixed64(v) => buf.put_u64_le(*v),
                ProtoValue::Fixed32(v) => buf.put_u32_le(*v),
                ProtoValue::LengthDelimited(data) => {
                    Self::encode_varint(data.len() as u64, &mut buf);
                    buf.extend_from_slice(data);
                }
            }
        }
        buf.freeze()
    }
}

impl ProtoDecoder {
    pub fn decode_varint(buf: &mut impl Buf) -> Result<u64, GrpcError> {
        let mut result = 0u64;
        let mut shift = 0;

        loop {
            if !buf.has_remaining() {
                return Err(GrpcError::InvalidProtobuf("Incomplete varint".to_string()));
            }

            let byte = buf.get_u8();
            result |= ((byte & 0x7F) as u64) << shift;

            if byte & 0x80 == 0 {
                return Ok(result);
            }

            shift += 7;
            if shift >= 64 {
                return Err(GrpcError::InvalidProtobuf("Varint too long".to_string()));
            }
        }
    }

    pub fn decode_tag(buf: &mut impl Buf) -> Result<(u32, WireType), GrpcError> {
        let tag = Self::decode_varint(buf)? as u32;
        let field_number = tag >> 3;
        let wire_type = match tag & 0x07 {
            0 => WireType::Varint,
            1 => WireType::Fixed64,
            2 => WireType::LengthDelimited,
            5 => WireType::Fixed32,
            _ => return Err(GrpcError::InvalidProtobuf("Unknown wire type".to_string())),
        };
        Ok((field_number, wire_type))
    }

    pub fn decode_message(data: &[u8]) -> Result<ProtoMessage, GrpcError> {
        let mut buf = Bytes::copy_from_slice(data);
        let mut message = ProtoMessage::default();

        while buf.has_remaining() {
            let (field_number, wire_type) = Self::decode_tag(&mut buf)?;

            let value = match wire_type {
                WireType::Varint => ProtoValue::Varint(Self::decode_varint(&mut buf)?),
                WireType::Fixed64 => {
                    if buf.remaining() < 8 {
                        return Err(GrpcError::InvalidProtobuf("Incomplete fixed64".to_string()));
                    }
                    ProtoValue::Fixed64(buf.get_u64_le())
                }
                WireType::Fixed32 => {
                    if buf.remaining() < 4 {
                        return Err(GrpcError::InvalidProtobuf("Incomplete fixed32".to_string()));
                    }
                    ProtoValue::Fixed32(buf.get_u32_le())
                }
                WireType::LengthDelimited => {
                    let len = Self::decode_varint(&mut buf)? as usize;
                    if buf.remaining() < len {
                        return Err(GrpcError::InvalidProtobuf("Incomplete bytes".to_string()));
                    }
                    ProtoValue::LengthDelimited(buf.copy_to_bytes(len))
                }
                _ => return Err(GrpcError::InvalidProtobuf("Unsupported wire type".to_string())),
            };

            message.fields.push(ProtoField {
                field_number,
                wire_type,
                value,
            });
        }

        Ok(message)
    }
}

impl GrpcCodec {
    pub fn encode_frame(message: &ProtoMessage, compressed: bool) -> Bytes {
        let data = ProtoEncoder::encode_message(message);
        let mut buf = BytesMut::with_capacity(5 + data.len());

        buf.put_u8(if compressed { 1 } else { 0 });
        buf.put_u32(data.len() as u32);
        buf.extend_from_slice(&data);

        buf.freeze()
    }

    pub fn decode_frame(buf: &mut BytesMut) -> Result<Option<GrpcFrame>, GrpcError> {
        if buf.len() < 5 {
            return Ok(None);
        }

        let compressed = buf[0] != 0;
        let length = u32::from_be_bytes([buf[1], buf[2], buf[3], buf[4]]) as usize;

        if buf.len() < 5 + length {
            return Ok(None);
        }

        buf.advance(5);
        let data = buf.split_to(length).freeze();

        Ok(Some(GrpcFrame { compressed, data }))
    }
}

impl Metadata {
    pub fn new() -> Self {
        Self {
            entries: HashMap::new(),
        }
    }

    pub fn insert(&mut self, key: String, value: String) {
        self.entries.insert(key.to_lowercase(), MetadataValue::Text(value));
    }

    pub fn insert_binary(&mut self, key: String, value: Vec<u8>) {
        let key = key.to_lowercase();
        if !key.ends_with("-bin") {
            panic!("Binary metadata key must end with -bin");
        }
        self.entries.insert(key, MetadataValue::Binary(value));
    }

    pub fn get(&self, key: &str) -> Option<&MetadataValue> {
        self.entries.get(&key.to_lowercase())
    }

    pub fn get_text(&self, key: &str) -> Option<&str> {
        match self.get(key) {
            Some(MetadataValue::Text(s)) => Some(s),
            _ => None,
        }
    }

    pub fn get_binary(&self, key: &str) -> Option<&[u8]> {
        match self.get(key) {
            Some(MetadataValue::Binary(b)) => Some(b),
            _ => None,
        }
    }

    pub fn to_headers(&self) -> Vec<(String, String)> {
        self.entries
            .iter()
            .map(|(k, v)| {
                let value = match v {
                    MetadataValue::Text(s) => s.clone(),
                    MetadataValue::Binary(b) => base64_encode(b),
                };
                (k.clone(), value)
            })
            .collect()
    }

    pub fn from_headers(headers: &[(String, String)]) -> Self {
        let mut metadata = Self::new();
        for (key, value) in headers {
            if key.ends_with("-bin") {
                if let Ok(decoded) = base64_decode(value) {
                    metadata.entries.insert(
                        key.to_lowercase(),
                        MetadataValue::Binary(decoded),
                    );
                }
            } else {
                metadata.insert(key.clone(), value.clone());
            }
        }
        metadata
    }
}

fn base64_encode(data: &[u8]) -> String {
    // Simplified base64 (use real base64 crate in production)
    data.iter().map(|b| format!("{:02x}", b)).collect()
}

fn base64_decode(s: &str) -> Result<Vec<u8>, ()> {
    (0..s.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&s[i..i + 2], 16).map_err(|_| ()))
        .collect()
}

impl Status {
    pub fn ok() -> Self {
        Self {
            code: StatusCode::Ok,
            message: String::new(),
            details: Vec::new(),
        }
    }

    pub fn with_code(code: StatusCode) -> Self {
        Self {
            code,
            message: String::new(),
            details: Vec::new(),
        }
    }

    pub fn with_message(code: StatusCode, message: impl Into<String>) -> Self {
        Self {
            code,
            message: message.into(),
            details: Vec::new(),
        }
    }

    pub fn is_ok(&self) -> bool {
        self.code == StatusCode::Ok
    }
}

impl GrpcServer {
    pub fn new() -> Self {
        Self {
            services: HashMap::new(),
            max_message_size: 4 * 1024 * 1024, // 4MB default
            default_timeout: Duration::from_secs(30),
        }
    }

    pub fn register_service(&mut self, service: Box<dyn ServiceHandler>) {
        let descriptor = service.descriptor();
        self.services.insert(descriptor.full_name.clone(), service);
    }

    pub fn process_request(
        &self,
        method: &str,
        metadata: Metadata,
        frame: GrpcFrame,
    ) -> Result<GrpcResponse, GrpcError> {
        // Check message size
        if frame.data.len() > self.max_message_size {
            return Ok(GrpcResponse {
                metadata: Metadata::new(),
                message: None,
                status: Status::with_message(
                    StatusCode::ResourceExhausted,
                    "Message too large",
                ),
                trailing_metadata: Metadata::new(),
            });
        }

        // Parse method path
        let (service_name, method_name) = Self::parse_method_path(method)
            .ok_or_else(|| GrpcError::InvalidFrame("Invalid method path".to_string()))?;

        // Find service
        let service = self.services.get(service_name)
            .ok_or_else(|| GrpcError::ServiceNotFound(service_name.to_string()))?;

        // Check deadline
        if let Some(timeout) = metadata.get_text("grpc-timeout") {
            // Parse timeout (simplified)
            if timeout == "0S" {
                return Ok(GrpcResponse {
                    metadata: Metadata::new(),
                    message: None,
                    status: Status::with_code(StatusCode::DeadlineExceeded),
                    trailing_metadata: Metadata::new(),
                });
            }
        }

        // Decode message
        let message = ProtoDecoder::decode_message(&frame.data)?;

        // Build request
        let request = GrpcRequest {
            method: method.to_string(),
            metadata,
            message,
            deadline: None,
        };

        // Handle request
        service.handle_unary(method_name, request)
    }

    pub fn set_max_message_size(&mut self, size: usize) {
        self.max_message_size = size;
    }

    pub fn set_default_timeout(&mut self, timeout: Duration) {
        self.default_timeout = timeout;
    }

    pub fn parse_method_path(path: &str) -> Option<(&str, &str)> {
        if !path.starts_with('/') {
            return None;
        }

        let path = &path[1..];
        let mut parts = path.splitn(2, '/');

        let service = parts.next()?;
        let method = parts.next()?;

        if service.is_empty() || method.is_empty() {
            return None;
        }

        Some((service, method))
    }
}

impl GreeterService {
    pub fn new() -> Self {
        Self {
            descriptor: ServiceDescriptor {
                name: "Greeter".to_string(),
                full_name: "helloworld.Greeter".to_string(),
                methods: vec![MethodDescriptor {
                    name: "SayHello".to_string(),
                    full_name: "/helloworld.Greeter/SayHello".to_string(),
                    client_streaming: false,
                    server_streaming: false,
                }],
            },
        }
    }
}

impl ServiceHandler for GreeterService {
    fn descriptor(&self) -> &ServiceDescriptor {
        &self.descriptor
    }

    fn handle_unary(
        &self,
        method: &str,
        request: GrpcRequest,
    ) -> Result<GrpcResponse, GrpcError> {
        match method {
            "SayHello" => {
                // Extract name from request
                let name = request.message.fields
                    .iter()
                    .find(|f| f.field_number == 1)
                    .and_then(|f| match &f.value {
                        ProtoValue::LengthDelimited(b) => {
                            String::from_utf8(b.to_vec()).ok()
                        }
                        _ => None,
                    })
                    .unwrap_or_else(|| "World".to_string());

                // Build response
                let mut response_message = ProtoMessage::default();
                let greeting = format!("Hello, {}!", name);
                response_message.fields.push(ProtoField {
                    field_number: 1,
                    wire_type: WireType::LengthDelimited,
                    value: ProtoValue::LengthDelimited(Bytes::from(greeting)),
                });

                Ok(GrpcResponse {
                    metadata: Metadata::new(),
                    message: Some(response_message),
                    status: Status::ok(),
                    trailing_metadata: Metadata::new(),
                })
            }
            _ => Err(GrpcError::MethodNotFound(method.to_string())),
        }
    }
}
```

### 4.9 spec.json

```json
{
  "name": "grpc_server",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Multi-concepts integres - gRPC Protocol",
  "tags": ["networking", "grpc", "protobuf", "rpc", "async", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "GrpcServer",
    "prototype": "impl GrpcServer",
    "return_type": "struct",
    "parameters": []
  },

  "driver": {
    "reference": "/* See Section 4.3 */",

    "edge_cases": [
      {
        "name": "message_too_large",
        "input": "5MB message",
        "expected": "Status::ResourceExhausted",
        "is_trap": true,
        "trap_explanation": "Doit respecter max_message_size"
      },
      {
        "name": "invalid_method_path",
        "input": "/invalid",
        "expected": "Err(InvalidFrame)",
        "is_trap": true,
        "trap_explanation": "Format doit etre /service/method"
      },
      {
        "name": "deadline_exceeded",
        "input": "grpc-timeout: 0S",
        "expected": "Status::DeadlineExceeded",
        "is_trap": true,
        "trap_explanation": "Timeout expire = erreur immediate"
      },
      {
        "name": "varint_overflow",
        "input": "10+ bytes varint",
        "expected": "Err(InvalidProtobuf)",
        "is_trap": true,
        "trap_explanation": "Varint max 10 bytes pour u64"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 1000,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator": "random_protobuf_message"
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["tokio", "bytes", "std::collections"],
    "forbidden_functions": ["unsafe"],
    "forbidden_crates": ["tonic", "grpc-rs", "prost"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Message trop grand accepte */
impl GrpcServer {
    pub fn process_request(&self, ...) -> Result<GrpcResponse, GrpcError> {
        // MUTANT: Pas de verification de taille
        let message = ProtoDecoder::decode_message(&frame.data)?;
        // ...
    }
}
// Pourquoi c'est faux: DoS possible avec message geant
// Ce qui etait pense: "La taille sera verifiee ailleurs"

/* Mutant B (Safety) : Varint sans limite */
impl ProtoDecoder {
    pub fn decode_varint(buf: &mut impl Buf) -> Result<u64, GrpcError> {
        let mut result = 0u64;
        let mut shift = 0;
        loop {
            let byte = buf.get_u8();
            result |= ((byte & 0x7F) as u64) << shift;
            if byte & 0x80 == 0 { return Ok(result); }
            shift += 7;
            // MUTANT: Pas de verification shift >= 64
        }
    }
}
// Pourquoi c'est faux: Boucle infinie possible
// Ce qui etait pense: "Le stream sera toujours valide"

/* Mutant C (Logic) : Status mal mappe */
impl GrpcServer {
    pub fn process_request(&self, ...) -> Result<GrpcResponse, GrpcError> {
        match service.handle_unary(method_name, request) {
            Ok(resp) => Ok(resp),
            Err(_) => Ok(GrpcResponse {
                status: Status::ok(),  // MUTANT: OK au lieu de l'erreur
                ..
            }),
        }
    }
}
// Pourquoi c'est faux: Erreur masquee au client
// Ce qui etait pense: "On retourne toujours OK pour simplicite"

/* Mutant D (Edge) : Deadline ignoree */
impl GrpcServer {
    pub fn process_request(&self, ...) -> Result<GrpcResponse, GrpcError> {
        // MUTANT: Ignore grpc-timeout header
        let message = ProtoDecoder::decode_message(&frame.data)?;
        // ...
    }
}
// Pourquoi c'est faux: Client attend indefiniment
// Ce qui etait pense: "Les timeouts sont geres par HTTP/2"

/* Mutant E (Return) : Service non trouve retourne Internal */
impl GrpcServer {
    pub fn process_request(&self, ...) -> Result<GrpcResponse, GrpcError> {
        let service = self.services.get(service_name)
            .ok_or_else(|| GrpcError::Internal("oops".to_string()))?;  // MUTANT
        // ...
    }
}
// Pourquoi c'est faux: Devrait etre Unimplemented, pas Internal
// Ce qui etait pense: "Une erreur est une erreur"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Protocol Buffers** : Encodage binaire compact avec varints
2. **gRPC Protocol** : Framing, metadata, status codes
3. **Service Pattern** : Definition et implementation de services
4. **Error Handling** : Status codes semantiques
5. **Performance** : Serialisation efficace vs JSON

### 5.3 Visualisation ASCII

```
                    gRPC REQUEST/RESPONSE FLOW

    Client                                          Server
      |                                               |
      |  ---- HTTP/2 HEADERS (POST /Service/Method) -->
      |       content-type: application/grpc          |
      |       grpc-timeout: 5S                        |
      |                                               |
      |  ---- gRPC FRAME (Request Message) ---------->|
      |       +----+--------+-----------------+       |
      |       |0x00| 4 bytes|  Protobuf Data  |       |
      |       +----+--------+-----------------+       |
      |                                               |
      |                              [Process Request]|
      |                                               |
      |<---- HTTP/2 HEADERS (200 OK) -----------------|
      |       content-type: application/grpc          |
      |                                               |
      |<---- gRPC FRAME (Response Message) -----------|
      |       +----+--------+-----------------+       |
      |       |0x00| 4 bytes|  Protobuf Data  |       |
      |       +----+--------+-----------------+       |
      |                                               |
      |<---- HTTP/2 TRAILERS -------------------------|
      |       grpc-status: 0                          |
      |       grpc-message: (empty)                   |
      |                                               |


                    VARINT ENCODING

    Value: 300
    Binary: 100101100 (9 bits)

    Split into 7-bit groups (LSB first):
    Group 1: 0101100 (44)  -> with continuation bit: 10101100 (0xAC)
    Group 2: 0000010 (2)   -> no continuation:       00000010 (0x02)

    Encoded: [0xAC, 0x02]

    Decode:
    0xAC = 10101100 -> continuation, value = 0101100 (44)
    0x02 = 00000010 -> no continuation, value = 10 (2)
    Result: 44 + (2 << 7) = 44 + 256 = 300
```

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | grpc_server |
| **Module** | 5.1.17 - gRPC Protocol |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 300 (base) + bonus x3 |
| **Concepts cles** | Protocol Buffers, HTTP/2, RPC |
| **Piege principal** | Varint encoding et status mapping |
| **Prerequis valide** | HTTP/2, Async Rust |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.17-a-grpc-server",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.1.17-a",
      "exercise_name": "grpc_server",
      "module": "5.1.17",
      "module_name": "gRPC Protocol Implementation",
      "concept": "a",
      "concept_name": "gRPC Server Engine",
      "type": "code",
      "tier": 2,
      "phase": 5,
      "difficulty": 8,
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 300,
      "xp_bonus_multiplier": 3,
      "domains": ["Net", "Proto", "Async", "RPC"],
      "tags": ["networking", "grpc", "protobuf", "rpc"],
      "meme_reference": "Beam me up, gRPC"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Beam me up, gRPC"*
*Exercise Quality Score: 94/100*
