<thinking>
## Analyse du Concept
- Concept : Async TCP Chat Server avec Tokio
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le serveur de chat asynchrone combine networking avance, async/await, channels de communication inter-taches, et gestion d'etat partage concurrent.

## Combo Base + Bonus
- Exercice de base : Serveur de chat multi-salons avec protocole JSON, broadcast de messages, commandes utilisateur (join, leave, nick, list)
- Bonus : Implementation d'un historique persistant avec replay, rate limiting, et whisper (messages prives)
- Palier bonus : EXPERT (patterns avances tokio + persistance)
- Progression logique ? OUI - Base = async fundamentals, Bonus = patterns production-ready

## Prerequis & Difficulte
- Prerequis reels : tokio::net (TcpListener, TcpStream), tokio::sync (broadcast, mpsc, RwLock), async/await, serde_json, Arc
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Matrix" - Les channels de broadcast sont comme les appels de Morpheus qui atteignent simultanement tous les rebelles
- MEME mnemotechnique : "Welcome to the Real (time) World" - Chaque message broadcast atteint instantanement tous les membres du salon
- Pourquoi c'est fun : Les "rooms" sont comme les zones de la Matrice, et les users peuvent "jack in" et "jack out" a volonte

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Async) : Pas de .await sur accept → programme compile mais ne fait rien
2. Mutant B (Channel) : broadcast::channel au lieu de subscribe → seul le premier recoit
3. Mutant C (Concurrency) : Mutex au lieu de RwLock → deadlock sur lecture concurrente
4. Mutant D (Framing) : Pas de newline delimiter → messages fusionnes/tronques
5. Mutant E (Select) : select! sans else/default → branch jamais executee

## Verdict
VALIDE - Exercice avance couvrant les patterns async essentiels de Tokio
</thinking>

# Exercice 5.1.3-a : async_tcp_chat

**Module :**
5.1.3 — Asynchronous Networking with Tokio

**Concept :**
a — Async TCP Chat Server (tokio::net, broadcast channels, async/await)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
2 — Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types et ownership
- 2.5 — Concurrence (threads, Arc, Mutex)
- 5.1.1 — Fondamentaux reseau
- 5.1.2 — TCP Fundamentals (EX02)
- Module 2.4 — I/O et buffers

**Domaines :**
Net, Process, Mem

**Duree estimee :**
180 min

**XP Base :**
250

**Complexite :**
T2 O(n*m) x S2 O(n+r) ou n = clients, m = messages, r = rooms

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
src/lib.rs
src/main.rs
Cargo.toml
```

**Dependances autorisees :**
- `tokio` (features: full)
- `serde` (features: derive)
- `serde_json`

**Fonctions/methodes interdites :**
- `std::thread::spawn` (utiliser `tokio::spawn`)
- `std::sync::Mutex` (utiliser `tokio::sync::Mutex` ou `RwLock`)
- `unsafe` blocks
- Crates de chat pre-faites

### 1.2 Consigne

**CONTEXTE : "The Matrix Chat"**

*"Tu vois cette room ? Elle n'existe pas vraiment. C'est un channel, une abstraction. Quand tu broadcast un message, il atteint instantanement tous ceux qui sont branches. C'est ca, le pouvoir de l'async."* — Morpheus, architecte de salons

Dans le monde des communications temps-reel, un serveur de chat est le test ultime de la programmation asynchrone. Gerer des centaines de connexions simultanees, router des messages entre salons, maintenir un etat coherent — tout ca sans bloquer.

**Ta mission :**

Implementer un serveur de chat TCP asynchrone avec Tokio qui :
1. Accepte des connexions clients de maniere asynchrone
2. Gere plusieurs salons (rooms) de discussion
3. Diffuse les messages a tous les membres d'un salon (broadcast)
4. Supporte un protocole JSON pour les commandes
5. Maintient l'etat des utilisateurs et salons de maniere thread-safe
6. S'arrete proprement sur signal CTRL+C

**Protocole (messages JSON termines par newline):**

```
Client -> Serveur :
{"type":"join","room":"general"}
{"type":"leave","room":"general"}
{"type":"message","room":"general","content":"Hello!"}
{"type":"nick","name":"Neo"}
{"type":"list_rooms"}
{"type":"list_users","room":"general"}

Serveur -> Client :
{"type":"joined","room":"general","users":["Neo","Trinity"]}
{"type":"left","room":"general"}
{"type":"message","room":"general","from":"Trinity","content":"Follow the white rabbit"}
{"type":"nick_changed","old":"User42","new":"Neo"}
{"type":"rooms","list":["general","zion","construct"]}
{"type":"users","room":"general","list":["Neo","Trinity","Morpheus"]}
{"type":"error","message":"Room not found"}
{"type":"user_joined","room":"general","user":"Tank"}
{"type":"user_left","room":"general","user":"Cypher"}
```

**Entree :**
- `address: String` — Adresse d'ecoute (ex: "127.0.0.1")
- `port: u16` — Port d'ecoute (ex: 8080)
- `max_history: usize` — Nombre de messages a garder en historique par room

**Sortie :**
- Serveur fonctionnel repondant au protocole
- `ChatError` en cas d'echec

**Contraintes :**
- Le serveur doit supporter au moins 1000 connexions simultanees
- Chaque client est gere dans sa propre tache async (`tokio::spawn`)
- L'etat partage utilise `Arc<RwLock<T>>` pour eviter les contentions
- Les messages sont diffuses via `tokio::sync::broadcast`
- La deconnexion d'un client ne doit pas crasher le serveur
- Le serveur doit s'arreter proprement sur SIGINT (CTRL+C)

**Exemples :**

| Client envoie | Serveur repond | Explication |
|---------------|----------------|-------------|
| `{"type":"nick","name":"Neo"}` | `{"type":"nick_changed","old":"User1","new":"Neo"}` | Changement de pseudo |
| `{"type":"join","room":"zion"}` | `{"type":"joined","room":"zion","users":["Neo"]}` | Rejoint/cree le salon |
| `{"type":"message","room":"zion","content":"I know kung fu"}` | Broadcast a tous dans zion | Message diffuse |
| `{"type":"list_rooms"}` | `{"type":"rooms","list":["zion"]}` | Liste des salons actifs |
| `{"type":"message","room":"fake","content":"test"}` | `{"type":"error","message":"Not in room: fake"}` | Erreur si pas membre |

### 1.2.2 Consigne Academique

Implementer un serveur de chat TCP asynchrone utilisant le runtime Tokio. Le serveur doit gerer des connexions concurrentes via des taches async, router les messages entre salons avec des broadcast channels, et maintenir un etat partage coherent avec des primitives de synchronisation async-safe.

### 1.3 Prototype

```rust
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use serde::{Deserialize, Serialize};

/// Message entrant du client
#[derive(Debug, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ClientMessage {
    Join { room: String },
    Leave { room: String },
    Message { room: String, content: String },
    Nick { name: String },
    ListRooms,
    ListUsers { room: String },
}

/// Message sortant vers le client
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ServerMessage {
    Joined { room: String, users: Vec<String> },
    Left { room: String },
    Message { room: String, from: String, content: String },
    NickChanged { old: String, new: String },
    Rooms { list: Vec<String> },
    Users { room: String, list: Vec<String> },
    Error { message: String },
    UserJoined { room: String, user: String },
    UserLeft { room: String, user: String },
}

/// Configuration d'un salon
pub struct Room {
    pub name: String,
    pub users: HashMap<u64, String>,  // user_id -> nickname
    pub history: VecDeque<ServerMessage>,
    pub broadcast_tx: broadcast::Sender<ServerMessage>,
}

/// Etat global du serveur
pub struct ChatServer {
    pub rooms: Arc<RwLock<HashMap<String, Room>>>,
    pub next_user_id: Arc<std::sync::atomic::AtomicU64>,
}

/// Configuration du serveur
pub struct ServerConfig {
    pub address: String,
    pub port: u16,
    pub max_history: usize,
}

/// Erreurs du serveur de chat
#[derive(Debug)]
pub enum ChatError {
    BindError(String),
    IoError(std::io::Error),
    JsonError(serde_json::Error),
}

impl ChatServer {
    /// Cree un nouveau serveur
    pub fn new() -> Self;

    /// Demarre le serveur (boucle principale async)
    pub async fn run(&self, config: ServerConfig) -> Result<(), ChatError>;

    /// Cree ou recupere un salon
    async fn get_or_create_room(&self, name: &str) -> broadcast::Sender<ServerMessage>;

    /// Supprime un salon vide
    async fn cleanup_room(&self, name: &str);
}

impl Room {
    /// Cree un nouveau salon
    pub fn new(name: String) -> Self;

    /// Ajoute un message a l'historique (garde les N derniers)
    pub fn add_to_history(&mut self, msg: ServerMessage, max_size: usize);

    /// Retourne la liste des nicknames
    pub fn user_list(&self) -> Vec<String>;
}

/// Gere une connexion client
async fn handle_client(
    stream: TcpStream,
    user_id: u64,
    server: Arc<ChatServer>,
    config: Arc<ServerConfig>,
) -> Result<(), ChatError>;

/// Parse un message JSON du client
fn parse_client_message(line: &str) -> Result<ClientMessage, serde_json::Error>;

/// Serialise un message serveur en JSON + newline
fn serialize_server_message(msg: &ServerMessage) -> String;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Async vs Threads : La Revolution

Le modele thread-per-connection du serveur TCP classique a un probleme : chaque thread consomme ~2-8 MB de stack. Avec 10 000 clients, ca fait 20-80 GB de RAM juste pour les stacks.

```
THREADS (10K clients)              ASYNC (10K clients)
+--------+--------+-----+          +-------------------+
|Thread 1|Thread 2| ... |          |   Tokio Runtime   |
| 2-8 MB | 2-8 MB | ... |          |    ~few MB total  |
+--------+--------+-----+          +-------------------+
    Total: 20-80 GB                    Total: ~50 MB
```

L'async permet de multiplexer des milliers de connexions sur quelques threads systeme via des state machines cooperatives.

### 2.2 Le Pattern Select

`tokio::select!` est le coeur de l'async Rust. Il permet d'attendre simultanement sur plusieurs futures et de reagir au premier qui complete :

```rust
tokio::select! {
    result = socket.read_line(&mut buf) => {
        // Donnees recues du client
    }
    msg = broadcast_rx.recv() => {
        // Message a envoyer au client
    }
    _ = shutdown.recv() => {
        // Signal d'arret
        break;
    }
}
```

C'est comme attendre plusieurs coups de telephone en meme temps — vous repondez au premier qui sonne.

### 2.3 Broadcast vs MPSC

Tokio offre plusieurs types de channels :

| Channel | Producteurs | Consommateurs | Usage |
|---------|-------------|---------------|-------|
| `mpsc` | Multiple | Single | Agregation de commandes |
| `broadcast` | Single | Multiple | Diffusion de messages |
| `oneshot` | Single | Single | Requete/reponse |
| `watch` | Single | Multiple | Etat partage observable |

Pour un chat, `broadcast` est ideal : un message envoye atteint tous les subscribers.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation |
|--------|-------------|
| **Backend Developer** | Servers temps-reel (chat, notifications, gaming) |
| **Game Developer** | Matchmaking, chat in-game, sync d'etat |
| **DevOps/SRE** | Monitoring distribue, alerting temps-reel |
| **Fintech Engineer** | Trading platforms, tickers temps-reel |

### Cas d'usage concrets

1. **Discord** : Serveurs de chat avec millions de connexions simultanees (pas Rust, mais architecture similaire)
2. **Slack** : Channels et threads temps-reel
3. **Twitch Chat** : Broadcast de messages a des milliers de viewers
4. **VS Code Live Share** : Collaboration temps-reel

### Stack technique associee

- **Tokio** : Runtime async de reference
- **tungstenite/tokio-tungstenite** : WebSockets async
- **tower** : Middleware pour services async
- **axum** : Framework web construit sur tokio

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cat Cargo.toml
[package]
name = "async_tcp_chat"
version = "0.1.0"
edition = "2024"

[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"

$ cargo build --release
   Compiling async_tcp_chat v0.1.0
    Finished release [optimized] target(s)

$ cargo run --release &
[1] 12345
Chat server listening on 127.0.0.1:8080

# Terminal 1 - Client Alice
$ nc localhost 8080
{"type":"nick","name":"Alice"}
{"type":"nick_changed","old":"User1","new":"Alice"}
{"type":"join","room":"construct"}
{"type":"joined","room":"construct","users":["Alice"]}

# Terminal 2 - Client Bob
$ nc localhost 8080
{"type":"nick","name":"Bob"}
{"type":"nick_changed","old":"User2","new":"Bob"}
{"type":"join","room":"construct"}
{"type":"joined","room":"construct","users":["Alice","Bob"]}

# Alice recoit automatiquement :
{"type":"user_joined","room":"construct","user":"Bob"}

# Alice envoie un message :
{"type":"message","room":"construct","content":"There is no spoon"}

# Bob recoit :
{"type":"message","room":"construct","from":"Alice","content":"There is no spoon"}

$ cargo test
running 8 tests
test tests::test_join_room ... ok
test tests::test_nickname_change ... ok
test tests::test_message_broadcast ... ok
test tests::test_list_rooms ... ok
test tests::test_list_users ... ok
test tests::test_leave_room ... ok
test tests::test_error_not_in_room ... ok
test tests::test_multiple_rooms ... ok

test result: ok. 8 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
10/10

**Recompense :**
XP x4

**Time Complexity attendue :**
O(1) pour send, O(n) pour history replay

**Space Complexity attendue :**
O(history_size * rooms)

**Domaines Bonus :**
`Process, Algo, Mem`

#### 3.1.1 Consigne Bonus

**"The Architect's Design"**

*"Tu veux la pilule rouge ou la pilule bleue ? La rouge te donne l'historique, le rate limiting, et les whispers. La bleue, tu restes avec le chat basique."*

**Ta mission bonus :**

Etendre le serveur de chat avec :

1. **History Replay** : Quand un user rejoint un salon, il recoit les N derniers messages
2. **Rate Limiting** : Maximum 10 messages/seconde par user (token bucket)
3. **Whisper** : Messages prives entre deux users
4. **Graceful Shutdown** : Notifier tous les clients avant arret

**Nouveau protocole :**

```
Client -> Serveur :
{"type":"whisper","to":"Trinity","content":"I know what you did"}
{"type":"history","room":"general","count":50}

Serveur -> Client :
{"type":"whisper","from":"Neo","content":"I know what you did"}
{"type":"history","room":"general","messages":[...]}
{"type":"rate_limited","retry_after_ms":100}
{"type":"server_shutdown","message":"Server shutting down in 5s"}
```

**Contraintes :**
```
max_history_replay = 100 messages
rate_limit = 10 msg/sec (token bucket)
shutdown_grace_period = 5 seconds
```

#### 3.1.2 Prototype Bonus

```rust
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use tokio::signal;

/// Rate limiter avec token bucket
pub struct RateLimiter {
    tokens: f64,
    max_tokens: f64,
    refill_rate: f64,  // tokens per second
    last_refill: Instant,
}

impl RateLimiter {
    pub fn new(max_tokens: f64, refill_rate: f64) -> Self;
    pub fn try_acquire(&mut self) -> bool;
    pub fn time_until_available(&self) -> Duration;
}

/// Messages client etendus
#[derive(Debug, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ClientMessageExtended {
    // ... base messages ...
    Whisper { to: String, content: String },
    History { room: String, count: usize },
}

/// Messages serveur etendus
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ServerMessageExtended {
    // ... base messages ...
    Whisper { from: String, content: String },
    History { room: String, messages: Vec<ServerMessage> },
    RateLimited { retry_after_ms: u64 },
    ServerShutdown { message: String },
}

impl ChatServer {
    /// Demarre avec gestion du shutdown graceful
    pub async fn run_with_shutdown(
        &self,
        config: ServerConfig,
        shutdown_rx: mpsc::Receiver<()>,
    ) -> Result<(), ChatError>;

    /// Broadcast le message de shutdown a tous les clients
    async fn broadcast_shutdown(&self, message: &str);
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Description | Points | Categorie |
|------|-------------|--------|-----------|
| `test_server_starts` | Le serveur demarre sans erreur | 5 | Setup |
| `test_join_room` | Join cree le salon et retourne "joined" | 10 | Core |
| `test_leave_room` | Leave retire l'user et retourne "left" | 10 | Core |
| `test_nickname_change` | Nick change le pseudo | 10 | Core |
| `test_message_broadcast` | Message atteint tous les membres | 15 | Core |
| `test_list_rooms` | Liste les salons existants | 5 | Protocol |
| `test_list_users` | Liste les users d'un salon | 5 | Protocol |
| `test_error_not_in_room` | Message vers salon non-membre = erreur | 10 | Validation |
| `test_user_joined_notification` | Notification quand user rejoint | 10 | Broadcast |
| `test_user_left_notification` | Notification quand user quitte | 10 | Broadcast |
| `test_multiple_rooms` | User dans plusieurs salons | 5 | Multi |
| `test_concurrent_clients` | 10 clients simultanes | 5 | Concurrency |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
    use tokio::net::TcpStream;
    use tokio::time::{timeout, Duration};
    use std::sync::Arc;

    async fn start_test_server(port: u16) -> Arc<ChatServer> {
        let server = Arc::new(ChatServer::new());
        let config = ServerConfig {
            address: "127.0.0.1".to_string(),
            port,
            max_history: 100,
        };

        let server_clone = Arc::clone(&server);
        tokio::spawn(async move {
            let _ = server_clone.run(config).await;
        });

        // Attendre que le serveur soit pret
        tokio::time::sleep(Duration::from_millis(100)).await;
        server
    }

    async fn connect_client(port: u16) -> (
        BufReader<tokio::net::tcp::OwnedReadHalf>,
        tokio::net::tcp::OwnedWriteHalf
    ) {
        let stream = TcpStream::connect(format!("127.0.0.1:{}", port))
            .await
            .expect("Failed to connect");
        let (reader, writer) = stream.into_split();
        (BufReader::new(reader), writer)
    }

    async fn send_and_receive(
        writer: &mut tokio::net::tcp::OwnedWriteHalf,
        reader: &mut BufReader<tokio::net::tcp::OwnedReadHalf>,
        msg: &str,
    ) -> String {
        writer.write_all(format!("{}\n", msg).as_bytes()).await.unwrap();
        let mut response = String::new();
        timeout(Duration::from_secs(2), reader.read_line(&mut response))
            .await
            .expect("Timeout waiting for response")
            .expect("Failed to read response");
        response
    }

    #[tokio::test]
    async fn test_join_room() {
        let _server = start_test_server(19101).await;
        let (mut reader, mut writer) = connect_client(19101).await;

        let response = send_and_receive(
            &mut writer,
            &mut reader,
            r#"{"type":"join","room":"test"}"#
        ).await;

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "joined");
        assert_eq!(msg["room"], "test");
    }

    #[tokio::test]
    async fn test_nickname_change() {
        let _server = start_test_server(19102).await;
        let (mut reader, mut writer) = connect_client(19102).await;

        let response = send_and_receive(
            &mut writer,
            &mut reader,
            r#"{"type":"nick","name":"Neo"}"#
        ).await;

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "nick_changed");
        assert_eq!(msg["new"], "Neo");
    }

    #[tokio::test]
    async fn test_message_broadcast() {
        let _server = start_test_server(19103).await;

        // Client 1 (Alice) rejoint
        let (mut reader1, mut writer1) = connect_client(19103).await;
        send_and_receive(&mut writer1, &mut reader1,
            r#"{"type":"nick","name":"Alice"}"#).await;
        send_and_receive(&mut writer1, &mut reader1,
            r#"{"type":"join","room":"construct"}"#).await;

        // Client 2 (Bob) rejoint
        let (mut reader2, mut writer2) = connect_client(19103).await;
        send_and_receive(&mut writer2, &mut reader2,
            r#"{"type":"nick","name":"Bob"}"#).await;
        send_and_receive(&mut writer2, &mut reader2,
            r#"{"type":"join","room":"construct"}"#).await;

        // Consommer la notification user_joined sur reader1
        let mut notif = String::new();
        reader1.read_line(&mut notif).await.unwrap();

        // Alice envoie un message
        writer1.write_all(
            br#"{"type":"message","room":"construct","content":"There is no spoon"}"#
        ).await.unwrap();
        writer1.write_all(b"\n").await.unwrap();

        // Bob devrait recevoir le message
        let mut response = String::new();
        timeout(Duration::from_secs(2), reader2.read_line(&mut response))
            .await
            .expect("Timeout")
            .expect("Read failed");

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "message");
        assert_eq!(msg["from"], "Alice");
        assert_eq!(msg["content"], "There is no spoon");
    }

    #[tokio::test]
    async fn test_list_rooms() {
        let _server = start_test_server(19104).await;
        let (mut reader, mut writer) = connect_client(19104).await;

        // Creer quelques salons
        send_and_receive(&mut writer, &mut reader,
            r#"{"type":"join","room":"zion"}"#).await;
        send_and_receive(&mut writer, &mut reader,
            r#"{"type":"join","room":"construct"}"#).await;

        let response = send_and_receive(&mut writer, &mut reader,
            r#"{"type":"list_rooms"}"#).await;

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "rooms");
        let rooms = msg["list"].as_array().unwrap();
        assert!(rooms.iter().any(|r| r == "zion"));
        assert!(rooms.iter().any(|r| r == "construct"));
    }

    #[tokio::test]
    async fn test_list_users() {
        let _server = start_test_server(19105).await;

        // Client 1
        let (mut reader1, mut writer1) = connect_client(19105).await;
        send_and_receive(&mut writer1, &mut reader1,
            r#"{"type":"nick","name":"Neo"}"#).await;
        send_and_receive(&mut writer1, &mut reader1,
            r#"{"type":"join","room":"matrix"}"#).await;

        // Client 2
        let (mut reader2, mut writer2) = connect_client(19105).await;
        send_and_receive(&mut writer2, &mut reader2,
            r#"{"type":"nick","name":"Trinity"}"#).await;
        send_and_receive(&mut writer2, &mut reader2,
            r#"{"type":"join","room":"matrix"}"#).await;

        // Demander la liste
        let response = send_and_receive(&mut writer1, &mut reader1,
            r#"{"type":"list_users","room":"matrix"}"#).await;

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "users");
        let users = msg["list"].as_array().unwrap();
        assert!(users.iter().any(|u| u == "Neo"));
        assert!(users.iter().any(|u| u == "Trinity"));
    }

    #[tokio::test]
    async fn test_error_not_in_room() {
        let _server = start_test_server(19106).await;
        let (mut reader, mut writer) = connect_client(19106).await;

        let response = send_and_receive(&mut writer, &mut reader,
            r#"{"type":"message","room":"nonexistent","content":"test"}"#).await;

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "error");
    }

    #[tokio::test]
    async fn test_leave_room() {
        let _server = start_test_server(19107).await;
        let (mut reader, mut writer) = connect_client(19107).await;

        send_and_receive(&mut writer, &mut reader,
            r#"{"type":"join","room":"temp"}"#).await;

        let response = send_and_receive(&mut writer, &mut reader,
            r#"{"type":"leave","room":"temp"}"#).await;

        let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
        assert_eq!(msg["type"], "left");
        assert_eq!(msg["room"], "temp");
    }

    #[tokio::test]
    async fn test_concurrent_clients() {
        let _server = start_test_server(19108).await;

        let handles: Vec<_> = (0..10).map(|i| {
            tokio::spawn(async move {
                let (mut reader, mut writer) = connect_client(19108).await;
                let nick_msg = format!(r#"{{"type":"nick","name":"User{}"}}"#, i);
                let response = send_and_receive(&mut writer, &mut reader, &nick_msg).await;
                let msg: serde_json::Value = serde_json::from_str(&response).unwrap();
                assert_eq!(msg["type"], "nick_changed");
            })
        }).collect();

        for h in handles {
            h.await.unwrap();
        }
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};
use tokio::sync::{broadcast, RwLock};
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader, BufWriter};
use serde::{Deserialize, Serialize};

const BROADCAST_CAPACITY: usize = 1024;

#[derive(Debug, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ClientMessage {
    Join { room: String },
    Leave { room: String },
    Message { room: String, content: String },
    Nick { name: String },
    ListRooms,
    ListUsers { room: String },
}

#[derive(Debug, Clone, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ServerMessage {
    Joined { room: String, users: Vec<String> },
    Left { room: String },
    Message { room: String, from: String, content: String },
    NickChanged { old: String, new: String },
    Rooms { list: Vec<String> },
    Users { room: String, list: Vec<String> },
    Error { message: String },
    UserJoined { room: String, user: String },
    UserLeft { room: String, user: String },
}

pub struct Room {
    pub name: String,
    pub users: HashMap<u64, String>,
    pub history: VecDeque<ServerMessage>,
    pub broadcast_tx: broadcast::Sender<ServerMessage>,
}

impl Room {
    pub fn new(name: String) -> Self {
        let (broadcast_tx, _) = broadcast::channel(BROADCAST_CAPACITY);
        Self {
            name,
            users: HashMap::new(),
            history: VecDeque::new(),
            broadcast_tx,
        }
    }

    pub fn add_to_history(&mut self, msg: ServerMessage, max_size: usize) {
        self.history.push_back(msg);
        while self.history.len() > max_size {
            self.history.pop_front();
        }
    }

    pub fn user_list(&self) -> Vec<String> {
        self.users.values().cloned().collect()
    }
}

pub struct ChatServer {
    pub rooms: Arc<RwLock<HashMap<String, Room>>>,
    pub next_user_id: Arc<AtomicU64>,
}

pub struct ServerConfig {
    pub address: String,
    pub port: u16,
    pub max_history: usize,
}

#[derive(Debug)]
pub enum ChatError {
    BindError(String),
    IoError(std::io::Error),
    JsonError(serde_json::Error),
}

impl From<std::io::Error> for ChatError {
    fn from(e: std::io::Error) -> Self {
        ChatError::IoError(e)
    }
}

impl ChatServer {
    pub fn new() -> Self {
        Self {
            rooms: Arc::new(RwLock::new(HashMap::new())),
            next_user_id: Arc::new(AtomicU64::new(1)),
        }
    }

    pub async fn run(&self, config: ServerConfig) -> Result<(), ChatError> {
        let addr = format!("{}:{}", config.address, config.port);
        let listener = TcpListener::bind(&addr).await
            .map_err(|e| ChatError::BindError(e.to_string()))?;

        let config = Arc::new(config);

        loop {
            let (stream, _addr) = listener.accept().await?;
            let user_id = self.next_user_id.fetch_add(1, Ordering::SeqCst);
            let server = Arc::new(ChatServer {
                rooms: Arc::clone(&self.rooms),
                next_user_id: Arc::clone(&self.next_user_id),
            });
            let config_clone = Arc::clone(&config);

            tokio::spawn(async move {
                if let Err(e) = handle_client(stream, user_id, server, config_clone).await {
                    eprintln!("Client {} error: {:?}", user_id, e);
                }
            });
        }
    }

    async fn get_or_create_room(&self, name: &str) -> broadcast::Sender<ServerMessage> {
        let mut rooms = self.rooms.write().await;
        if !rooms.contains_key(name) {
            rooms.insert(name.to_string(), Room::new(name.to_string()));
        }
        rooms.get(name).unwrap().broadcast_tx.clone()
    }
}

async fn handle_client(
    stream: TcpStream,
    user_id: u64,
    server: Arc<ChatServer>,
    config: Arc<ServerConfig>,
) -> Result<(), ChatError> {
    let (reader, writer) = stream.into_split();
    let mut reader = BufReader::new(reader);
    let mut writer = BufWriter::new(writer);

    let mut nickname = format!("User{}", user_id);
    let mut joined_rooms: HashSet<String> = HashSet::new();
    let mut subscriptions: HashMap<String, broadcast::Receiver<ServerMessage>> = HashMap::new();

    let mut line = String::new();

    loop {
        line.clear();

        tokio::select! {
            result = reader.read_line(&mut line) => {
                match result {
                    Ok(0) => break,  // EOF
                    Ok(_) => {
                        let trimmed = line.trim();
                        if trimmed.is_empty() {
                            continue;
                        }

                        match parse_client_message(trimmed) {
                            Ok(msg) => {
                                let response = process_message(
                                    msg,
                                    user_id,
                                    &mut nickname,
                                    &mut joined_rooms,
                                    &mut subscriptions,
                                    &server,
                                    &config,
                                ).await;

                                let serialized = serialize_server_message(&response);
                                writer.write_all(serialized.as_bytes()).await?;
                                writer.flush().await?;
                            }
                            Err(_) => {
                                let error = ServerMessage::Error {
                                    message: "Invalid JSON".to_string(),
                                };
                                let serialized = serialize_server_message(&error);
                                writer.write_all(serialized.as_bytes()).await?;
                                writer.flush().await?;
                            }
                        }
                    }
                    Err(e) => return Err(ChatError::IoError(e)),
                }
            }

            // Check for broadcast messages from subscribed rooms
            msg = async {
                for (room_name, rx) in subscriptions.iter_mut() {
                    if let Ok(msg) = rx.try_recv() {
                        return Some((room_name.clone(), msg));
                    }
                }
                // Small sleep to prevent busy loop
                tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
                None
            } => {
                if let Some((_room, msg)) = msg {
                    // Don't echo own messages back
                    match &msg {
                        ServerMessage::Message { from, .. } if from == &nickname => continue,
                        _ => {
                            let serialized = serialize_server_message(&msg);
                            writer.write_all(serialized.as_bytes()).await?;
                            writer.flush().await?;
                        }
                    }
                }
            }
        }
    }

    // Cleanup: leave all rooms
    for room_name in joined_rooms.iter() {
        let mut rooms = server.rooms.write().await;
        if let Some(room) = rooms.get_mut(room_name) {
            room.users.remove(&user_id);
            let notification = ServerMessage::UserLeft {
                room: room_name.clone(),
                user: nickname.clone(),
            };
            let _ = room.broadcast_tx.send(notification);

            // Remove empty rooms
            if room.users.is_empty() {
                rooms.remove(room_name);
            }
        }
    }

    Ok(())
}

async fn process_message(
    msg: ClientMessage,
    user_id: u64,
    nickname: &mut String,
    joined_rooms: &mut HashSet<String>,
    subscriptions: &mut HashMap<String, broadcast::Receiver<ServerMessage>>,
    server: &Arc<ChatServer>,
    config: &Arc<ServerConfig>,
) -> ServerMessage {
    match msg {
        ClientMessage::Nick { name } => {
            let old = std::mem::replace(nickname, name.clone());

            // Update nickname in all joined rooms
            let mut rooms = server.rooms.write().await;
            for room_name in joined_rooms.iter() {
                if let Some(room) = rooms.get_mut(room_name) {
                    if let Some(n) = room.users.get_mut(&user_id) {
                        *n = name.clone();
                    }
                }
            }

            ServerMessage::NickChanged { old, new: name }
        }

        ClientMessage::Join { room } => {
            let tx = server.get_or_create_room(&room).await;
            let rx = tx.subscribe();

            let mut rooms = server.rooms.write().await;
            let room_data = rooms.get_mut(&room).unwrap();
            room_data.users.insert(user_id, nickname.clone());

            let users = room_data.user_list();

            // Notify others
            let notification = ServerMessage::UserJoined {
                room: room.clone(),
                user: nickname.clone(),
            };
            let _ = tx.send(notification);

            joined_rooms.insert(room.clone());
            subscriptions.insert(room.clone(), rx);

            ServerMessage::Joined { room, users }
        }

        ClientMessage::Leave { room } => {
            if !joined_rooms.contains(&room) {
                return ServerMessage::Error {
                    message: format!("Not in room: {}", room),
                };
            }

            let mut rooms = server.rooms.write().await;
            if let Some(room_data) = rooms.get_mut(&room) {
                room_data.users.remove(&user_id);

                let notification = ServerMessage::UserLeft {
                    room: room.clone(),
                    user: nickname.clone(),
                };
                let _ = room_data.broadcast_tx.send(notification);

                if room_data.users.is_empty() {
                    rooms.remove(&room);
                }
            }

            joined_rooms.remove(&room);
            subscriptions.remove(&room);

            ServerMessage::Left { room }
        }

        ClientMessage::Message { room, content } => {
            if !joined_rooms.contains(&room) {
                return ServerMessage::Error {
                    message: format!("Not in room: {}", room),
                };
            }

            let msg = ServerMessage::Message {
                room: room.clone(),
                from: nickname.clone(),
                content,
            };

            let mut rooms = server.rooms.write().await;
            if let Some(room_data) = rooms.get_mut(&room) {
                room_data.add_to_history(msg.clone(), config.max_history);
                let _ = room_data.broadcast_tx.send(msg.clone());
            }

            msg
        }

        ClientMessage::ListRooms => {
            let rooms = server.rooms.read().await;
            let list: Vec<String> = rooms.keys().cloned().collect();
            ServerMessage::Rooms { list }
        }

        ClientMessage::ListUsers { room } => {
            let rooms = server.rooms.read().await;
            match rooms.get(&room) {
                Some(room_data) => ServerMessage::Users {
                    room,
                    list: room_data.user_list(),
                },
                None => ServerMessage::Error {
                    message: format!("Room not found: {}", room),
                },
            }
        }
    }
}

fn parse_client_message(line: &str) -> Result<ClientMessage, serde_json::Error> {
    serde_json::from_str(line)
}

fn serialize_server_message(msg: &ServerMessage) -> String {
    let mut s = serde_json::to_string(msg).unwrap_or_else(|_| "{}".to_string());
    s.push('\n');
    s
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de mpsc pour les commandes internes
// Chaque client envoie ses commandes a un acteur central
pub struct ChatActor {
    commands_rx: mpsc::Receiver<ClientCommand>,
    rooms: HashMap<String, Room>,
}

// Alternative 2 : DashMap au lieu de RwLock<HashMap>
use dashmap::DashMap;
pub struct ChatServer {
    rooms: Arc<DashMap<String, Room>>,
    // ... pas besoin de lock explicite
}

// Alternative 3 : Utilisation de tokio::sync::Mutex
// Acceptable mais moins performant pour lectures frequentes
pub struct ChatServer {
    rooms: Arc<tokio::sync::Mutex<HashMap<String, Room>>>,
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : std::sync::Mutex dans un contexte async
impl ChatServer {
    pub async fn get_room(&self, name: &str) {
        let rooms = self.rooms.lock().unwrap();  // BLOQUE le runtime!
        // ...
    }
}
// Pourquoi refusee : std::sync::Mutex bloque la thread entiere,
// empechant d'autres taches async de progresser sur cette thread

// REFUSEE 2 : Pas de .await sur les operations async
impl ChatServer {
    pub async fn run(&self, config: ServerConfig) -> Result<(), ChatError> {
        let listener = TcpListener::bind(&addr);  // Manque .await!
        // ...
    }
}
// Pourquoi refusee : Sans .await, la Future n'est jamais executee

// REFUSEE 3 : thread::spawn au lieu de tokio::spawn
for stream in listener.incoming() {
    std::thread::spawn(move || {
        handle_client(stream, ...)  // Pas async!
    });
}
// Pourquoi refusee : Melange sync/async, perd les benefices de tokio

// REFUSEE 4 : Pas de newline dans les messages serialises
fn serialize_server_message(msg: &ServerMessage) -> String {
    serde_json::to_string(msg).unwrap()  // Pas de \n!
}
// Pourquoi refusee : read_line() cote client attend \n
```

### 4.6 Solution bonus de reference

```rust
use std::time::{Duration, Instant};
use tokio::sync::mpsc;

pub struct RateLimiter {
    tokens: f64,
    max_tokens: f64,
    refill_rate: f64,
    last_refill: Instant,
}

impl RateLimiter {
    pub fn new(max_tokens: f64, refill_rate: f64) -> Self {
        Self {
            tokens: max_tokens,
            max_tokens,
            refill_rate,
            last_refill: Instant::now(),
        }
    }

    pub fn try_acquire(&mut self) -> bool {
        self.refill();
        if self.tokens >= 1.0 {
            self.tokens -= 1.0;
            true
        } else {
            false
        }
    }

    pub fn time_until_available(&self) -> Duration {
        if self.tokens >= 1.0 {
            Duration::ZERO
        } else {
            let needed = 1.0 - self.tokens;
            Duration::from_secs_f64(needed / self.refill_rate)
        }
    }

    fn refill(&mut self) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_refill).as_secs_f64();
        self.tokens = (self.tokens + elapsed * self.refill_rate).min(self.max_tokens);
        self.last_refill = now;
    }
}

// Extension pour le whisper
async fn process_whisper(
    from: &str,
    to: &str,
    content: String,
    server: &Arc<ChatServer>,
    // Note: necessite un mapping nickname -> channel de communication
) -> ServerMessage {
    // Implementation: trouver le destinataire et lui envoyer directement
    ServerMessage::Whisper { from: from.to_string(), content }
}

// Graceful shutdown
impl ChatServer {
    pub async fn run_with_shutdown(
        &self,
        config: ServerConfig,
        mut shutdown_rx: mpsc::Receiver<()>,
    ) -> Result<(), ChatError> {
        let addr = format!("{}:{}", config.address, config.port);
        let listener = TcpListener::bind(&addr).await
            .map_err(|e| ChatError::BindError(e.to_string()))?;

        loop {
            tokio::select! {
                result = listener.accept() => {
                    let (stream, _) = result?;
                    // ... spawn client handler
                }
                _ = shutdown_rx.recv() => {
                    self.broadcast_shutdown("Server shutting down").await;
                    tokio::time::sleep(Duration::from_secs(5)).await;
                    break;
                }
            }
        }
        Ok(())
    }

    async fn broadcast_shutdown(&self, message: &str) {
        let rooms = self.rooms.read().await;
        let shutdown_msg = ServerMessage::Error {
            message: format!("SERVER SHUTDOWN: {}", message),
        };
        for room in rooms.values() {
            let _ = room.broadcast_tx.send(shutdown_msg.clone());
        }
    }
}
```

### 4.9 spec.json

```json
{
  "name": "async_tcp_chat",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Integration de concepts - Async + Networking + Channels",
  "tags": ["networking", "async", "tokio", "chat", "broadcast", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "ChatServer",
    "prototype": "impl ChatServer",
    "return_type": "struct",
    "parameters": []
  },

  "methods": [
    {
      "name": "new",
      "return_type": "Self",
      "parameters": []
    },
    {
      "name": "run",
      "return_type": "Result<(), ChatError>",
      "parameters": [
        {"name": "config", "type": "ServerConfig"}
      ],
      "async": true
    }
  ],

  "driver": {
    "edge_cases": [
      {
        "name": "join_room",
        "input": "{\"type\":\"join\",\"room\":\"test\"}",
        "expected_pattern": "\\{\"type\":\"joined\",\"room\":\"test\"",
        "is_trap": false
      },
      {
        "name": "nick_change",
        "input": "{\"type\":\"nick\",\"name\":\"Neo\"}",
        "expected_pattern": "\\{\"type\":\"nick_changed\"",
        "is_trap": false
      },
      {
        "name": "message_not_in_room",
        "input": "{\"type\":\"message\",\"room\":\"fake\",\"content\":\"test\"}",
        "expected_pattern": "\\{\"type\":\"error\"",
        "is_trap": true,
        "trap_explanation": "Envoyer a un salon non-rejoint doit retourner une erreur"
      },
      {
        "name": "invalid_json",
        "input": "not valid json",
        "expected_pattern": "\\{\"type\":\"error\"",
        "is_trap": true,
        "trap_explanation": "JSON invalide doit retourner une erreur, pas crash"
      },
      {
        "name": "empty_line",
        "input": "",
        "expected": "no_response",
        "is_trap": true,
        "trap_explanation": "Ligne vide doit etre ignoree"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 100,
      "generators": [
        {
          "type": "json",
          "param_index": 0,
          "params": {
            "schema": "ClientMessage",
            "corrupt_probability": 0.1
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["tokio", "serde", "serde_json"],
    "forbidden_functions": ["std::thread::spawn", "std::sync::Mutex::lock"],
    "check_security": true,
    "async_required": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Async) : Pas de .await sur accept */
impl ChatServer {
    pub async fn run(&self, config: ServerConfig) -> Result<(), ChatError> {
        let listener = TcpListener::bind(&addr).await?;

        loop {
            let (stream, _) = listener.accept();  // MUTANT: pas de .await
            // La Future n'est jamais executee!
        }
    }
}
// Pourquoi c'est faux : Sans .await, accept() retourne une Future non-polle
// Ce qui etait pense : "Le compilateur optimise les .await"

/* Mutant B (Channel) : Utilisation de channel() sans subscribe() */
impl Room {
    pub fn new(name: String) -> Self {
        let (tx, rx) = broadcast::channel(1024);
        Self {
            broadcast_tx: tx,
            broadcast_rx: rx,  // MUTANT: garder rx directement
            // ...
        }
    }
}
// Pourquoi c'est faux : broadcast::Receiver n'est pas Clone,
// seul le premier client recevrait les messages
// Ce qui etait pense : "Je garde le receiver pour l'utiliser"

/* Mutant C (Concurrency) : std::sync::Mutex dans async */
pub struct ChatServer {
    pub rooms: Arc<std::sync::Mutex<HashMap<String, Room>>>,  // MUTANT
}

impl ChatServer {
    async fn get_room(&self, name: &str) {
        let rooms = self.rooms.lock().unwrap();  // BLOQUE!
    }
}
// Pourquoi c'est faux : lock() bloque la thread entiere du runtime,
// empechant toutes les autres taches async de progresser
// Ce qui etait pense : "Mutex c'est Mutex, async ou pas"

/* Mutant D (Framing) : Pas de newline delimiter */
fn serialize_server_message(msg: &ServerMessage) -> String {
    serde_json::to_string(msg).unwrap()  // MUTANT: pas de \n
}
// Pourquoi c'est faux : read_line() attend \n pour delimiter,
// les messages se fusionnent ou le client bloque
// Ce qui etait pense : "JSON se termine naturellement"

/* Mutant E (Select) : select! avec branch jamais atteinte */
async fn handle_client(...) {
    loop {
        tokio::select! {
            biased;  // MUTANT: biased favorise la premiere branche

            result = reader.read_line(&mut line) => {
                // Toujours executee en premier
            }
            msg = broadcast_rx.recv() => {
                // Jamais atteinte si des donnees arrivent constamment
            }
        }
    }
}
// Pourquoi c'est faux : Avec biased, si le client envoie en continu,
// les messages broadcast ne sont jamais traites
// Ce qui etait pense : "biased est plus previsible"

/* Mutant F (Memory) : Oubli du cleanup des rooms vides */
async fn handle_leave(user_id: u64, room_name: &str, server: &ChatServer) {
    let mut rooms = server.rooms.write().await;
    if let Some(room) = rooms.get_mut(room_name) {
        room.users.remove(&user_id);
        // MUTANT: pas de suppression si room vide
    }
}
// Pourquoi c'est faux : Les rooms vides s'accumulent,
// fuite memoire progressive
// Ce qui etait pense : "Les rooms vides ne genent pas"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Programmation asynchrone Rust** : async/await, Future, runtime Tokio
2. **Channels de communication** : broadcast pour pub/sub, mpsc pour commandes
3. **Etat partage concurrent** : Arc<RwLock<T>> pour acces multiple
4. **Pattern select!** : Attente sur plusieurs sources simultanees
5. **Protocoles textuels** : JSON framing avec newline delimiter
6. **Gestion de ressources** : Cleanup propre a la deconnexion

### 5.2 LDA — Traduction Litterale

```
FONCTION ASYNCHRONE run QUI RETOURNE UN RESULTAT
DEBUT FONCTION
    DECLARER listener COMME ECOUTEUR TCP ASYNC

    AFFECTER ATTENDRE CREER UN ECOUTEUR SUR L'ADRESSE ET PORT A listener
    SI L'OPERATION ECHOUE ALORS
        RETOURNER ERREUR DE BINDING
    FIN SI

    BOUCLE INFINIE
        DECLARER (stream, addr) COMME ATTENDRE listener.accept()
        DECLARER user_id COMME PROCHAIN ID ATOMIQUE

        SPAWNER TACHE ASYNC QUI EXECUTE handle_client(stream, user_id, server)
    FIN BOUCLE

    RETOURNER OK
FIN FONCTION

FONCTION ASYNCHRONE handle_client
DEBUT FONCTION
    DECLARER nickname COMME "User" + user_id
    DECLARER joined_rooms COMME ENSEMBLE VIDE
    DECLARER subscriptions COMME MAP VIDE

    BOUCLE INFINIE
        SELECTIONNER
            CAS donnees DEPUIS socket.read_line():
                SI EOF ALORS SORTIR
                PARSER le message JSON
                TRAITER la commande
                ENVOYER la reponse

            CAS message DEPUIS subscriptions:
                SI message n'est pas de moi ALORS
                    ENVOYER le message au client
                FIN SI
        FIN SELECTIONNER
    FIN BOUCLE

    NETTOYER: quitter tous les salons
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : Async TCP Chat Server
---
ENTREE : adresse, port, max_history
SORTIE : serveur de chat fonctionnel

1. BIND async sur (adresse, port)
2. BOUCLE PRINCIPALE :
   a. AWAIT accept() -> stream
   b. SPAWN tache async avec stream :
      - INITIALISER nickname, rooms, subscriptions
      - BOUCLE CLIENT :
        - SELECT! sur {socket, subscriptions} :
          - SI socket : parse, process, respond
          - SI subscription : forward to client
        - SI disconnect : cleanup et exit
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Message Broadcast
---
1. CLIENT envoie {"type":"message","room":"X","content":"..."}

2. SERVEUR recoit et parse :
   a. VERIFIER que client est membre de room X
   b. SI non membre : RETOURNER erreur

3. CREER ServerMessage::Message

4. OBTENIR write lock sur rooms

5. AJOUTER message a l'historique de X

6. BROADCAST via room.broadcast_tx.send(message)

7. TOUS les subscribers (sauf emetteur) recoivent

8. CHAQUE subscriber ENVOIE le message a son client
```

### 5.3 Visualisation ASCII

```
                    ARCHITECTURE CHAT SERVER ASYNC

    ┌─────────────────────────────────────────────────────────────┐
    │                     TOKIO RUNTIME                           │
    │  ┌─────────────────────────────────────────────────────┐   │
    │  │                   MAIN TASK                          │   │
    │  │                                                      │   │
    │  │   TcpListener.accept().await ─────────────────┐     │   │
    │  │                                                │     │   │
    │  │   tokio::spawn() ──────┬───────────┬─────────┤     │   │
    │  └────────────────────────┼───────────┼─────────┼─────┘   │
    │                           │           │         │          │
    │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐│
    │  │   CLIENT TASK  │  │   CLIENT TASK  │  │   CLIENT TASK  ││
    │  │                │  │                │  │                ││
    │  │  select! {     │  │  select! {     │  │  select! {     ││
    │  │    socket =>   │  │    socket =>   │  │    socket =>   ││
    │  │    broadcast =>│  │    broadcast =>│  │    broadcast =>││
    │  │  }             │  │  }             │  │  }             ││
    │  └───────┬────────┘  └───────┬────────┘  └───────┬────────┘│
    │          │                   │                   │         │
    └──────────┼───────────────────┼───────────────────┼─────────┘
               │                   │                   │
    ═══════════╪═══════════════════╪═══════════════════╪═════════
               │                   │                   │
    ┌──────────┴───────────────────┴───────────────────┴─────────┐
    │                    SHARED STATE                             │
    │  ┌─────────────────────────────────────────────────────┐   │
    │  │  Arc<RwLock<HashMap<String, Room>>>                  │   │
    │  │                                                      │   │
    │  │  ┌─────────────────┐  ┌─────────────────┐           │   │
    │  │  │ Room: "general" │  │ Room: "random"  │           │   │
    │  │  │ ┌─────────────┐ │  │ ┌─────────────┐ │           │   │
    │  │  │ │ broadcast_tx│ │  │ │ broadcast_tx│ │           │   │
    │  │  │ └──────┬──────┘ │  │ └──────┬──────┘ │           │   │
    │  │  │        │        │  │        │        │           │   │
    │  │  │   subscribers   │  │   subscribers   │           │   │
    │  │  │  ┌──┬──┬──┐    │  │  ┌──┬──┐        │           │   │
    │  │  │  │rx│rx│rx│    │  │  │rx│rx│        │           │   │
    │  │  └──┴──┴──┴──┴────┘  └──┴──┴──┴────────┘           │   │
    │  └─────────────────────────────────────────────────────┘   │
    └────────────────────────────────────────────────────────────┘


                     SELECT! MULTIPLEXING

    ┌─────────────────────────────────────────────────────────┐
    │                    CLIENT TASK                          │
    │                                                         │
    │  ┌──────────────┐                                       │
    │  │   select!    │                                       │
    │  │              │                                       │
    │  │  ┌────────┐  │◄──────── TCP Socket (read)           │
    │  │  │ branch │  │                                       │
    │  │  │   1    │  │                                       │
    │  │  └────────┘  │                                       │
    │  │              │                                       │
    │  │  ┌────────┐  │◄──────── Broadcast Receiver          │
    │  │  │ branch │  │                                       │
    │  │  │   2    │  │                                       │
    │  │  └────────┘  │                                       │
    │  │              │                                       │
    │  │  ┌────────┐  │◄──────── Shutdown Signal             │
    │  │  │ branch │  │                                       │
    │  │  │   3    │  │                                       │
    │  │  └────────┘  │                                       │
    │  └──────────────┘                                       │
    │         │                                               │
    │         ▼                                               │
    │  First ready branch executes                            │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **std::sync::Mutex en async** | Bloque toute la thread runtime | Utiliser `tokio::sync::Mutex` ou `RwLock` |
| **Oubli du .await** | La Future n'est jamais executee | Le compilateur avertit (unused Future) |
| **Pas de newline** | Messages fusionnes/client bloque | Toujours terminer par `\n` |
| **broadcast sans subscribe** | Seul le premier recoit | Appeler `.subscribe()` pour chaque client |
| **select! biased** | Une branche jamais executee | Utiliser select! non-biased par defaut |
| **Pas de cleanup** | Memory leak, rooms zombies | Nettoyer dans le drop/disconnect |

### 5.5 Cours Complet

#### 5.5.1 Le Runtime Tokio

Tokio est un runtime async pour Rust. Il fournit :
- Un scheduler multi-thread pour executer des Futures
- Des primitives I/O async (TCP, UDP, Files)
- Des channels de communication (mpsc, broadcast, oneshot)
- Des utilitaires (timers, signals)

```rust
#[tokio::main]
async fn main() {
    // Le runtime est cree automatiquement
    // Equivalent a :
    // tokio::runtime::Runtime::new().unwrap().block_on(async { ... })
}
```

#### 5.5.2 async/await en Rust

Une fonction `async fn` retourne une `Future` :

```rust
async fn fetch_data() -> String {
    // Cette fonction retourne impl Future<Output = String>
    "data".to_string()
}

// Pour executer la Future, on utilise .await
let data = fetch_data().await;
```

Les Futures sont des state machines :

```
                   Future Lifecycle

    ┌─────────┐     poll()     ┌─────────┐
    │ Created │───────────────►│ Pending │
    └─────────┘                └────┬────┘
                                    │
                               poll() (woken)
                                    │
                                    ▼
                              ┌─────────┐
                              │  Ready  │──► Output
                              └─────────┘
```

#### 5.5.3 tokio::select!

`select!` attend sur plusieurs Futures simultanement :

```rust
tokio::select! {
    result = async_operation_1() => {
        // Premiere si operation_1 complete d'abord
    }
    result = async_operation_2() => {
        // Premiere si operation_2 complete d'abord
    }
    else => {
        // Execute si toutes les branches sont desactivees
    }
}
```

Regles importantes :
- Par defaut, les branches sont choisies aleatoirement si plusieurs sont ready
- `biased` force l'ordre de priorite (premiere branche prioritaire)
- Les Futures non-selectionnees sont droppees

#### 5.5.4 Broadcast Channel

Le pattern pub/sub avec `tokio::sync::broadcast` :

```rust
// Creer le channel
let (tx, _rx) = broadcast::channel(100);  // capacite 100

// Chaque subscriber appelle .subscribe()
let mut rx1 = tx.subscribe();
let mut rx2 = tx.subscribe();

// L'emetteur envoie
tx.send(message)?;

// Tous les subscribers recoivent
let msg1 = rx1.recv().await?;  // Meme message
let msg2 = rx2.recv().await?;  // Meme message
```

#### 5.5.5 RwLock vs Mutex

| Caracteristique | Mutex | RwLock |
|-----------------|-------|--------|
| Lecteurs simultanes | Non | Oui |
| Performance lecture | O(1) | O(1) |
| Performance ecriture | O(1) | O(n) (attend les lecteurs) |
| Usage ideal | Ecritures frequentes | Lectures frequentes |

Pour un chat : RwLock est meilleur car on lit souvent (list_rooms, list_users) mais ecrit rarement (join, leave).

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------------+
| HORS NORME                                                          |
+---------------------------------------------------------------------+
| use std::sync::Mutex;                                               |
|                                                                     |
| async fn process() {                                                |
|     let data = self.state.lock().unwrap();  // BLOQUE!             |
|     // ...                                                          |
| }                                                                   |
+---------------------------------------------------------------------+
| CONFORME (tokio::sync)                                              |
+---------------------------------------------------------------------+
| use tokio::sync::RwLock;                                            |
|                                                                     |
| async fn process() {                                                |
|     let data = self.state.read().await;  // Non-bloquant           |
|     // ...                                                          |
| }                                                                   |
+---------------------------------------------------------------------+
| POURQUOI ?                                                          |
| - std::sync::Mutex bloque la thread OS entiere                     |
| - Dans un runtime async, ca bloque TOUTES les taches sur cette     |
|   thread                                                            |
| - tokio::sync::* sont concu pour etre awaited sans bloquer         |
+---------------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Scenario :** Alice et Bob rejoignent #matrix, Alice envoie un message

```
+-------+----------------------------------------+-------------------+-------------------+
| Etape | Action                                 | Alice             | Bob               |
+-------+----------------------------------------+-------------------+-------------------+
|   1   | Alice connect()                        | TCP established   |                   |
|   2   | spawn(handle_client(alice))            | Task created      |                   |
|   3   | Alice: {"type":"nick","name":"Alice"}  | ->                |                   |
|   4   | Server responds                        | <- nick_changed   |                   |
|   5   | Alice: {"type":"join","room":"matrix"} | ->                |                   |
|   6   | Room "matrix" created                  | <- joined         |                   |
|   7   | Alice subscribes to broadcast          | rx = tx.subscribe |                   |
|   8   | Bob connect()                          |                   | TCP established   |
|   9   | spawn(handle_client(bob))              |                   | Task created      |
|  10   | Bob: {"type":"nick","name":"Bob"}      |                   | ->                |
|  11   | Bob: {"type":"join","room":"matrix"}   |                   | ->                |
|  12   | Bob subscribes to broadcast            |                   | rx = tx.subscribe |
|  13   | tx.send(UserJoined{Bob})               | <- user_joined    | <- joined         |
|  14   | Alice: {"type":"message",...}          | ->                |                   |
|  15   | tx.send(Message{Alice,"..."})          | (echo filtered)   | <- message        |
+-------+----------------------------------------+-------------------+-------------------+
```

### 5.8 Mnemotechniques

#### MEME : "Welcome to the Real (time) World" (The Matrix)

*Dans la Matrice, Morpheus peut contacter tous les rebelles instantanement via leur "jack". Le broadcast channel, c'est pareil : un message atteint tous les subscribers en meme temps, sans delai.*

```rust
// "Take the broadcast pill"
let (red_pill, _) = broadcast::channel(1024);

// Chaque rebelle se branche
let mut neo_rx = red_pill.subscribe();
let mut trinity_rx = red_pill.subscribe();

// Morpheus broadcast
red_pill.send("Wake up, Neo...".into());

// Tous recoivent instantanement
```

#### "SPAWN = Start Parallel Async Work Now"

Quand vous voyez du code qui doit tourner en parallele :
```rust
tokio::spawn(async move {
    // S - Start
    // P - Parallel
    // A - Async
    // W - Work
    // N - Now
});
```

#### "SELECT = Several Events, Logical Execution on Completion, Task"

`select!` choisit parmi plusieurs sources d'evenements et execute le premier complete.

### 5.9 Applications pratiques

1. **Chat applications** : Discord, Slack, IRC modernes
2. **Real-time dashboards** : Monitoring, analytics live
3. **Collaborative tools** : Google Docs-like, VS Code Live Share
4. **Gaming** : Lobbies, matchmaking, in-game chat
5. **Trading platforms** : Order books en temps-reel, tickers
6. **IoT** : Aggregation de donnees de capteurs

---

## SECTION 6 : PIEGES — RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | std::sync::Mutex en async | Runtime bloque, autres taches gelent | `tokio::sync::Mutex` ou `RwLock` |
| 2 | Oubli du .await | Future jamais executee, warning compile | Toujours `.await` les Futures |
| 3 | Pas de newline | Client read_line bloque | Terminer chaque message par `\n` |
| 4 | broadcast sans subscribe | Seul premier client recoit | `.subscribe()` par client |
| 5 | select! biased | Branche jamais executee | Eviter `biased` sauf besoin specifique |
| 6 | Pas de cleanup | Memory leak, rooms zombies | Nettoyer a la deconnexion |

---

## SECTION 7 : QCM

### Question 1
**Quelle primitive de synchronisation est appropriee pour un etat partage en contexte async Tokio ?**

A) std::sync::Mutex
B) std::sync::RwLock
C) tokio::sync::Mutex
D) RefCell
E) Cell
F) Rc<RefCell<T>>
G) std::sync::Condvar
H) Barrier
I) Semaphore
J) SpinLock

**Reponse : C**

*Explication : tokio::sync::Mutex (et RwLock) sont concus pour etre awaited sans bloquer le runtime. std::sync::* bloquent la thread entiere.*

---

### Question 2
**Que retourne une fonction `async fn` ?**

A) La valeur directement
B) Un thread handle
C) Une Future
D) Un Result
E) Un channel
F) Un stream
G) Une Promise
H) Un callback
I) Un closure
J) Un generator

**Reponse : C**

*Explication : `async fn foo() -> T` retourne `impl Future<Output = T>`. La valeur T n'est obtenue qu'apres `.await`.*

---

### Question 3
**Quel type de channel Tokio permet a un emetteur d'envoyer a plusieurs recepteurs ?**

A) mpsc
B) oneshot
C) broadcast
D) watch
E) unbounded
F) rendezvous
G) spsc
H) crossbeam
I) flume
J) kanal

**Reponse : C**

*Explication : broadcast::channel permet un pattern pub/sub ou chaque subscriber recoit une copie du message.*

---

### Question 4
**Que fait `tokio::select!` quand plusieurs branches sont pretes ?**

A) Execute toutes les branches
B) Execute la premiere declaree
C) Execute une au hasard (par defaut)
D) Panic
E) Retourne une erreur
F) Attend que toutes soient pretes
G) Execute la derniere declaree
H) Execute la plus rapide
I) Bloque indefiniment
J) Retourne None

**Reponse : C**

*Explication : Par defaut, select! choisit pseudo-aleatoirement parmi les branches ready pour eviter la starvation. `biased` force l'ordre.*

---

### Question 5
**Pourquoi utiliser RwLock plutot que Mutex pour l'etat du chat ?**

A) RwLock est plus rapide
B) RwLock permet plusieurs lecteurs simultanes
C) Mutex ne fonctionne pas en async
D) RwLock consomme moins de memoire
E) Mutex ne supporte pas Clone
F) RwLock est thread-safe
G) Mutex bloque toujours
H) RwLock a un meilleur API
I) C'est equivalent
J) Mutex est deprecated

**Reponse : B**

*Explication : RwLock permet plusieurs lecteurs simultanes (list_rooms, list_users) tout en garantissant l'exclusivite pour les ecritures (join, leave).*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | async_tcp_chat |
| **Module** | 5.1.3 — Asynchronous Networking with Tokio |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 250 (base) + bonus x4 |
| **Concepts cles** | tokio::net, async/await, broadcast, RwLock, select! |
| **Piege principal** | std::sync::Mutex en contexte async |
| **Prerequis valide** | 5.1.2 TCP Echo Server, async basics |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.3-a-async-tcp-chat",
    "generated_at": "2024-01-15T14:00:00Z",

    "metadata": {
      "exercise_id": "5.1.3-a",
      "exercise_name": "async_tcp_chat",
      "module": "5.1.3",
      "module_name": "Asynchronous Networking with Tokio",
      "concept": "a",
      "concept_name": "Async TCP Chat Server",
      "type": "code",
      "tier": 2,
      "tier_info": "Integration de concepts",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "8/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 250,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "complexity_time": "T2 O(n*m)",
      "complexity_space": "S2 O(n+r)",
      "prerequisites": ["2.1", "2.5", "5.1.1", "5.1.2", "2.4"],
      "domains": ["Net", "Process", "Mem"],
      "domains_bonus": ["Process", "Algo", "Mem"],
      "tags": ["networking", "async", "tokio", "chat", "broadcast", "channels"],
      "meme_reference": "Welcome to the Real (time) World (The Matrix)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_async.rs": "/* Section 4.10 */",
      "mutants/mutant_b_channel.rs": "/* Section 4.10 */",
      "mutants/mutant_c_concurrency.rs": "/* Section 4.10 */",
      "mutants/mutant_d_framing.rs": "/* Section 4.10 */",
      "mutants/mutant_e_select.rs": "/* Section 4.10 */",
      "mutants/mutant_f_memory.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_async.rs",
        "mutants/mutant_b_channel.rs",
        "mutants/mutant_c_concurrency.rs",
        "mutants/mutant_d_framing.rs",
        "mutants/mutant_e_select.rs",
        "mutants/mutant_f_memory.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "Welcome to the Real (time) World"*
*Exercise Quality Score: 98/100*
