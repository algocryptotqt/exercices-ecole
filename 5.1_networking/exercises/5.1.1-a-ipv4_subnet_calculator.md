<thinking>
## Analyse du Concept
- Concept : IPv4 Subnet Calculator
- Phase demandÃ©e : 5 (Advanced Systems)
- AdaptÃ© ? OUI - Le subnetting est fondamental pour tout ingÃ©nieur rÃ©seau/systÃ¨mes. L'exercice combine manipulation binaire, parsing de chaÃ®nes, et concepts rÃ©seau.

## Combo Base + Bonus
- Exercice de base : Calculatrice de sous-rÃ©seaux IPv4 avec parsing CIDR, calcul network/broadcast, plages utilisables
- Bonus : ImplÃ©mentation d'un VLSM (Variable Length Subnet Masking) pour dÃ©couper un rÃ©seau en sous-rÃ©seaux de tailles variables optimisÃ©es
- Palier bonus : ğŸ”¥ AvancÃ© (complexitÃ© algorithmique + contrainte d'espace)
- Progression logique ? OUI - Base = calculs simples, Bonus = algorithme d'allocation optimale

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : Manipulation binaire, std::net::Ipv4Addr, Result/Option, traits FromStr/Display
- DifficultÃ© estimÃ©e : 7/10 (base), 9/10 (bonus)
- CohÃ©rent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : RÃ©fÃ©rence Ã  "The Matrix" - Les adresses IP comme coordonnÃ©es dans la Matrix
- MEME mnÃ©motechnique : "There is no subnet" (parodie de "There is no spoon")
- Pourquoi c'est fun : Les rÃ©seaux sont littÃ©ralement la "matrice" d'Internet

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Boundary) : prefix_len > 32 acceptÃ© sans erreur
2. Mutant B (Safety) : Pas de validation des octets > 255
3. Mutant C (Logic) : Masque calculÃ© avec dÃ©calage dans le mauvais sens (>> au lieu de <<)
4. Mutant D (Edge) : /31 et /32 traitÃ©s comme des rÃ©seaux normaux (first_usable retourne une valeur au lieu de None)
5. Mutant E (Return) : hosts_count retourne 2^(32-prefix) au lieu de 2^(32-prefix) - 2

## Verdict
VALIDE - Exercice de qualitÃ© industrielle couvrant les fondamentaux du subnetting IPv4
</thinking>

# Exercice 5.1.1-a : ipv4_subnet_calculator

**Module :**
5.1.1 â€” IPv4 Addressing Fundamentals

**Concept :**
a â€” IPv4 Subnet Calculation (CIDR, masques, plages d'adresses)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 2.1 â€” Types primitifs et ownership
- 2.3 â€” Traits (FromStr, Display)
- 2.4 â€” Gestion d'erreurs (Result, Option)
- Phase 0.0.C.1 â€” Fondamentaux rÃ©seaux (modÃ¨le OSI, adressage)

**Domaines :**
Net, Encodage, MD

**DurÃ©e estimÃ©e :**
90 min

**XP Base :**
150

**ComplexitÃ© :**
T2 O(1) Ã— S1 O(1)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
```
src/lib.rs
```

**DÃ©pendances autorisÃ©es :**
- `std::net::Ipv4Addr`
- `std::str::FromStr`
- `std::fmt::{Display, Formatter}`

**Fonctions/mÃ©thodes interdites :**
- Crates externes (`ipnetwork`, `ipnet`, etc.)
- `unsafe` blocks

### 1.2 Consigne

**ğŸ¬ CONTEXTE : "The IPv4 Matrix"**

*"Tu vois ces nombres, Neo ? Ce ne sont pas juste des adresses. C'est la structure mÃªme de la Matrix. Chaque sous-rÃ©seau est une piÃ¨ce, chaque masque une porte. Apprends Ã  les manipuler, et tu pourras naviguer n'importe oÃ¹."* â€” Morpheus, probablement

Dans le monde des rÃ©seaux, les adresses IPv4 sont les coordonnÃ©es qui permettent Ã  chaque machine de communiquer. Le subnetting (dÃ©coupage en sous-rÃ©seaux) est l'art de partitionner un espace d'adressage pour organiser et sÃ©curiser les rÃ©seaux.

**Ta mission :**

ImplÃ©menter une bibliothÃ¨que `Ipv4Network` qui permet de :
1. Parser une adresse en notation CIDR (ex: `192.168.1.0/24`)
2. Calculer l'adresse rÃ©seau (tous les bits host Ã  0)
3. Calculer l'adresse de broadcast (tous les bits host Ã  1)
4. DÃ©terminer la plage d'adresses utilisables
5. VÃ©rifier l'appartenance d'une IP Ã  un sous-rÃ©seau
6. DÃ©tecter les adresses privÃ©es RFC 1918

**EntrÃ©e :**
- `address: Ipv4Addr` â€” L'adresse IPv4
- `prefix_len: u8` â€” La longueur du prÃ©fixe CIDR (0-32)

**Sortie :**
- `Ipv4Network` â€” Structure reprÃ©sentant le sous-rÃ©seau
- `NetworkError` â€” En cas d'erreur de parsing ou de prÃ©fixe invalide

**Contraintes :**
- Le prÃ©fixe doit Ãªtre â‰¤ 32
- Les adresses doivent Ãªtre validÃ©es (octets 0-255)
- `/31` et `/32` sont des cas spÃ©ciaux (pas d'adresses "utilisables" au sens classique)
- Aucune allocation dynamique requise

**Exemples :**

| Appel | RÃ©sultat | Explication |
|-------|----------|-------------|
| `"192.168.1.0/24".parse()` | `Ok(Ipv4Network)` | RÃ©seau de classe C typique |
| `"10.0.0.0/8".parse()` | `Ok(Ipv4Network)` | RÃ©seau privÃ© classe A |
| `"192.168.1.0/33".parse()` | `Err(InvalidPrefix)` | PrÃ©fixe > 32 invalide |

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter une structure `Ipv4Network` reprÃ©sentant un sous-rÃ©seau IPv4 avec notation CIDR. La structure doit permettre le parsing depuis une chaÃ®ne, le calcul des adresses rÃ©seau/broadcast, la dÃ©termination des plages utilisables, et la vÃ©rification d'appartenance.

### 1.3 Prototype

```rust
use std::net::Ipv4Addr;
use std::str::FromStr;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Ipv4Network {
    address: Ipv4Addr,
    prefix_len: u8,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NetworkError {
    InvalidFormat,
    InvalidPrefix,
    InvalidOctet,
}

impl Ipv4Network {
    pub fn new(address: Ipv4Addr, prefix_len: u8) -> Result<Self, NetworkError>;
    pub fn network_address(&self) -> Ipv4Addr;
    pub fn broadcast_address(&self) -> Ipv4Addr;
    pub fn subnet_mask(&self) -> Ipv4Addr;
    pub fn first_usable(&self) -> Option<Ipv4Addr>;
    pub fn last_usable(&self) -> Option<Ipv4Addr>;
    pub fn hosts_count(&self) -> u32;
    pub fn contains(&self, ip: Ipv4Addr) -> bool;
    pub fn is_private(&self) -> bool;
    pub fn prefix_len(&self) -> u8;
    pub fn to_binary_string(ip: Ipv4Addr) -> String;
}

impl FromStr for Ipv4Network {
    type Err = NetworkError;
    fn from_str(s: &str) -> Result<Self, Self::Err>;
}

impl std::fmt::Display for Ipv4Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Subnetting

Le subnetting a Ã©tÃ© introduit en 1985 avec la RFC 950 pour rÃ©soudre la pÃ©nurie d'adresses IPv4. Avant cela, il n'existait que trois classes (A, B, C) avec des tailles fixes. Le CIDR (Classless Inter-Domain Routing) en 1993 a permis des dÃ©coupages plus flexibles.

### 2.2 Le Masque : Un Filtre Binaire

Le masque de sous-rÃ©seau est un **filtre AND bit-Ã -bit**. Quand vous appliquez un masque `/24` (255.255.255.0) Ã  une adresse, vous isolez les 24 premiers bits (partie rÃ©seau) en mettant Ã  zÃ©ro les 8 derniers (partie hÃ´te).

```
Adresse:    11000000.10101000.00000001.01100100  (192.168.1.100)
Masque /24: 11111111.11111111.11111111.00000000  (255.255.255.0)
AND:        11000000.10101000.00000001.00000000  (192.168.1.0) â† Adresse rÃ©seau
```

### 2.3 Pourquoi 2^n - 2 ?

Un rÃ©seau /24 a 256 adresses (2^8), mais seulement 254 utilisables. Pourquoi ?
- L'adresse `.0` (tous bits hÃ´te Ã  0) = **adresse rÃ©seau** (identifie le rÃ©seau lui-mÃªme)
- L'adresse `.255` (tous bits hÃ´te Ã  1) = **broadcast** (envoie Ã  tous les hÃ´tes)

---

## ğŸ“‹ SECTION 2.5 : DANS LA VRAIE VIE

### MÃ©tiers concernÃ©s

| MÃ©tier | Utilisation du subnetting |
|--------|---------------------------|
| **Network Engineer** | Design de topologies, allocation d'adresses, routage inter-VLAN |
| **Cloud Architect** | Design de VPC (AWS/GCP/Azure), peering, security groups |
| **DevOps/SRE** | Configuration Kubernetes (CNI), service mesh, load balancing |
| **Security Engineer** | Segmentation rÃ©seau, firewall rules, micro-segmentation |
| **Embedded Systems** | Configuration rÃ©seau IoT, protocoles industriels |

### Cas d'usage concrets

1. **AWS VPC Design** : DÃ©couper un /16 en sous-rÃ©seaux publics (/24) et privÃ©s (/20) multi-AZ
2. **Kubernetes Networking** : Allouer des plages pour pods, services, et nodes
3. **Enterprise Network** : Segmenter par dÃ©partement avec VLANs et routage inter-VLAN

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo test
   Compiling ipv4_subnet_calculator v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 12 tests
test tests::test_parse_valid_cidr ... ok
test tests::test_parse_invalid_prefix ... ok
test tests::test_network_address ... ok
test tests::test_broadcast_address ... ok
test tests::test_subnet_mask ... ok
test tests::test_usable_range ... ok
test tests::test_hosts_count ... ok
test tests::test_contains ... ok
test tests::test_is_private ... ok
test tests::test_binary_string ... ok
test tests::test_edge_cases_slash_32 ... ok
test tests::test_edge_cases_slash_31 ... ok

test result: ok. 12 passed; 0 failed
```

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(n log n) oÃ¹ n = nombre de sous-rÃ©seaux demandÃ©s

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Algo, DP`

#### 3.1.1 Consigne Bonus

**ğŸ¬ "The Architect's Blueprint"**

*"Le problÃ¨me, c'est le choix."* L'Architecte de la Matrix devait optimiser l'allocation des ressources. Toi aussi.

**Ta mission bonus :**

ImplÃ©menter un **allocateur VLSM** (Variable Length Subnet Masking) qui dÃ©coupe un rÃ©seau parent en sous-rÃ©seaux de tailles demandÃ©es, en minimisant le gaspillage d'adresses.

**EntrÃ©e :**
- `parent: &Ipv4Network` â€” Le rÃ©seau Ã  dÃ©couper
- `requirements: &[u32]` â€” Liste des nombres d'hÃ´tes requis par sous-rÃ©seau

**Sortie :**
- `Vec<Ipv4Network>` â€” Sous-rÃ©seaux allouÃ©s, triÃ©s par adresse
- `Err(AllocationError)` â€” Si l'allocation est impossible

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Î£(2^ceil(log2(req_i + 2))) â‰¤ 2^(32-prefix_parent)  â”‚
â”‚  Chaque sous-rÃ©seau doit Ãªtre contigu   â”‚
â”‚  Pas de chevauchement                   â”‚
â”‚  Algorithme glouton : plus gros d'abord â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemples :**

| Parent | Requirements | RÃ©sultat |
|--------|--------------|----------|
| `192.168.0.0/24` | `[100, 50, 20]` | `[/25, /26, /27]` |
| `10.0.0.0/24` | `[200, 100]` | `Err(InsufficientSpace)` |

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AllocationError {
    InsufficientSpace,
    InvalidRequirement,
}

impl Ipv4Network {
    pub fn vlsm_allocate(
        &self,
        requirements: &[u32]
    ) -> Result<Vec<Ipv4Network>, AllocationError>;
}
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| OpÃ©ration | Calculs sur UN rÃ©seau | Algorithme d'allocation |
| ComplexitÃ© | O(1) | O(n log n) |
| Structures | Une seule Ipv4Network | Collection de rÃ©seaux |
| Validation | PrÃ©fixe valide | Contraintes de capacitÃ© |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette â€” Tableau des tests

| Test | Input | Expected | Points | CatÃ©gorie |
|------|-------|----------|--------|-----------|
| `parse_valid_cidr` | `"192.168.1.0/24"` | `Ok(...)` | 5 | Basic |
| `parse_invalid_prefix` | `"192.168.1.0/33"` | `Err(InvalidPrefix)` | 5 | Edge |
| `parse_invalid_format` | `"not.an.ip"` | `Err(InvalidFormat)` | 5 | Edge |
| `network_address` | `"192.168.1.100/24"` | `192.168.1.0` | 10 | Core |
| `broadcast_address` | `"192.168.1.0/24"` | `192.168.1.255` | 10 | Core |
| `subnet_mask_8` | `"10.0.0.0/8"` | `255.0.0.0` | 5 | Core |
| `subnet_mask_12` | `"172.16.0.0/12"` | `255.240.0.0` | 5 | Core |
| `subnet_mask_24` | `"192.168.0.0/24"` | `255.255.255.0` | 5 | Core |
| `hosts_count_24` | `/24` | `254` | 10 | Core |
| `hosts_count_8` | `/8` | `16777214` | 5 | Core |
| `first_usable` | `"192.168.1.0/24"` | `192.168.1.1` | 5 | Core |
| `last_usable` | `"192.168.1.0/24"` | `192.168.1.254` | 5 | Core |
| `contains_true` | `192.168.1.100 in /24` | `true` | 5 | Core |
| `contains_false` | `192.168.2.1 in 192.168.1.0/24` | `false` | 5 | Core |
| `is_private_10` | `10.0.0.0/8` | `true` | 3 | RFC |
| `is_private_172` | `172.16.0.0/12` | `true` | 3 | RFC |
| `is_private_192` | `192.168.0.0/16` | `true` | 3 | RFC |
| `is_private_public` | `8.8.8.0/24` | `false` | 3 | RFC |
| `binary_string` | `192.168.1.1` | `"11000000..."` (32 chars) | 5 | Format |
| `slash_32_hosts` | `/32` | `1` | 3 | Edge |
| `slash_32_usable` | `/32` | `None` | 3 | Edge |
| `slash_31_hosts` | `/31` | `2` | 3 | Edge |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_valid_cidr() {
        let net: Ipv4Network = "192.168.1.0/24".parse().unwrap();
        assert_eq!(net.prefix_len(), 24);
    }

    #[test]
    fn test_parse_invalid_prefix() {
        let result: Result<Ipv4Network, _> = "192.168.1.0/33".parse();
        assert_eq!(result, Err(NetworkError::InvalidPrefix));
    }

    #[test]
    fn test_network_address() {
        let net: Ipv4Network = "192.168.1.100/24".parse().unwrap();
        assert_eq!(net.network_address(), Ipv4Addr::new(192, 168, 1, 0));
    }

    #[test]
    fn test_broadcast_address() {
        let net: Ipv4Network = "192.168.1.0/24".parse().unwrap();
        assert_eq!(net.broadcast_address(), Ipv4Addr::new(192, 168, 1, 255));
    }

    #[test]
    fn test_subnet_mask() {
        let net: Ipv4Network = "10.0.0.0/8".parse().unwrap();
        assert_eq!(net.subnet_mask(), Ipv4Addr::new(255, 0, 0, 0));

        let net: Ipv4Network = "172.16.0.0/12".parse().unwrap();
        assert_eq!(net.subnet_mask(), Ipv4Addr::new(255, 240, 0, 0));
    }

    #[test]
    fn test_usable_range() {
        let net: Ipv4Network = "192.168.1.0/24".parse().unwrap();
        assert_eq!(net.first_usable(), Some(Ipv4Addr::new(192, 168, 1, 1)));
        assert_eq!(net.last_usable(), Some(Ipv4Addr::new(192, 168, 1, 254)));
    }

    #[test]
    fn test_hosts_count() {
        let net: Ipv4Network = "192.168.1.0/24".parse().unwrap();
        assert_eq!(net.hosts_count(), 254);

        let net: Ipv4Network = "10.0.0.0/8".parse().unwrap();
        assert_eq!(net.hosts_count(), 16777214);
    }

    #[test]
    fn test_contains() {
        let net: Ipv4Network = "192.168.1.0/24".parse().unwrap();
        assert!(net.contains(Ipv4Addr::new(192, 168, 1, 100)));
        assert!(!net.contains(Ipv4Addr::new(192, 168, 2, 1)));
    }

    #[test]
    fn test_is_private() {
        assert!("10.0.0.0/8".parse::<Ipv4Network>().unwrap().is_private());
        assert!("172.16.0.0/12".parse::<Ipv4Network>().unwrap().is_private());
        assert!("192.168.0.0/16".parse::<Ipv4Network>().unwrap().is_private());
        assert!(!"8.8.8.0/24".parse::<Ipv4Network>().unwrap().is_private());
    }

    #[test]
    fn test_binary_string() {
        let binary = Ipv4Network::to_binary_string(Ipv4Addr::new(192, 168, 1, 1));
        assert_eq!(binary, "11000000101010000000000100000001");
        assert_eq!(binary.len(), 32);
    }

    #[test]
    fn test_edge_cases_slash_32() {
        let net: Ipv4Network = "192.168.1.1/32".parse().unwrap();
        assert_eq!(net.hosts_count(), 1);
        assert_eq!(net.first_usable(), None);
        assert_eq!(net.last_usable(), None);
    }

    #[test]
    fn test_edge_cases_slash_31() {
        let net: Ipv4Network = "192.168.1.0/31".parse().unwrap();
        assert_eq!(net.hosts_count(), 2);
    }
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use std::net::Ipv4Addr;
use std::str::FromStr;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Ipv4Network {
    address: Ipv4Addr,
    prefix_len: u8,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NetworkError {
    InvalidFormat,
    InvalidPrefix,
    InvalidOctet,
}

impl Ipv4Network {
    pub fn new(address: Ipv4Addr, prefix_len: u8) -> Result<Self, NetworkError> {
        if prefix_len > 32 {
            return Err(NetworkError::InvalidPrefix);
        }
        Ok(Self { address, prefix_len })
    }

    pub fn network_address(&self) -> Ipv4Addr {
        let addr_u32 = u32::from(self.address);
        let mask = self.mask_as_u32();
        Ipv4Addr::from(addr_u32 & mask)
    }

    pub fn broadcast_address(&self) -> Ipv4Addr {
        let addr_u32 = u32::from(self.address);
        let mask = self.mask_as_u32();
        let host_mask = !mask;
        Ipv4Addr::from(addr_u32 | host_mask)
    }

    pub fn subnet_mask(&self) -> Ipv4Addr {
        Ipv4Addr::from(self.mask_as_u32())
    }

    pub fn first_usable(&self) -> Option<Ipv4Addr> {
        if self.prefix_len >= 31 {
            return None;
        }
        let network = u32::from(self.network_address());
        Some(Ipv4Addr::from(network + 1))
    }

    pub fn last_usable(&self) -> Option<Ipv4Addr> {
        if self.prefix_len >= 31 {
            return None;
        }
        let broadcast = u32::from(self.broadcast_address());
        Some(Ipv4Addr::from(broadcast - 1))
    }

    pub fn hosts_count(&self) -> u32 {
        if self.prefix_len == 32 {
            return 1;
        }
        if self.prefix_len == 31 {
            return 2;
        }
        let host_bits = 32 - self.prefix_len;
        (1u32 << host_bits) - 2
    }

    pub fn contains(&self, ip: Ipv4Addr) -> bool {
        let mask = self.mask_as_u32();
        let network = u32::from(self.address) & mask;
        let ip_network = u32::from(ip) & mask;
        network == ip_network
    }

    pub fn is_private(&self) -> bool {
        let octets = self.address.octets();
        // 10.0.0.0/8
        if octets[0] == 10 {
            return true;
        }
        // 172.16.0.0/12
        if octets[0] == 172 && (octets[1] >= 16 && octets[1] <= 31) {
            return true;
        }
        // 192.168.0.0/16
        if octets[0] == 192 && octets[1] == 168 {
            return true;
        }
        false
    }

    pub fn prefix_len(&self) -> u8 {
        self.prefix_len
    }

    pub fn to_binary_string(ip: Ipv4Addr) -> String {
        let val = u32::from(ip);
        format!("{:032b}", val)
    }

    fn mask_as_u32(&self) -> u32 {
        if self.prefix_len == 0 {
            return 0;
        }
        !0u32 << (32 - self.prefix_len)
    }
}

impl FromStr for Ipv4Network {
    type Err = NetworkError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 2 {
            return Err(NetworkError::InvalidFormat);
        }

        let address = parts[0]
            .parse::<Ipv4Addr>()
            .map_err(|_| NetworkError::InvalidFormat)?;

        let prefix_len = parts[1]
            .parse::<u8>()
            .map_err(|_| NetworkError::InvalidFormat)?;

        Self::new(address, prefix_len)
    }
}

impl std::fmt::Display for Ipv4Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}/{}", self.address, self.prefix_len)
    }
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1 : Utilisation de bitwise explicite sans u32::from
impl Ipv4Network {
    pub fn network_address(&self) -> Ipv4Addr {
        let octets = self.address.octets();
        let mask_octets = self.subnet_mask().octets();
        Ipv4Addr::new(
            octets[0] & mask_octets[0],
            octets[1] & mask_octets[1],
            octets[2] & mask_octets[2],
            octets[3] & mask_octets[3],
        )
    }
}

// Alternative 2 : Calcul du masque avec loop
fn mask_as_u32(&self) -> u32 {
    let mut mask = 0u32;
    for i in 0..self.prefix_len {
        mask |= 1 << (31 - i);
    }
    mask
}
```

### 4.5 Solutions refusÃ©es

```rust
// REFUSÃ‰E 1 : Pas de validation du prÃ©fixe
impl Ipv4Network {
    pub fn new(address: Ipv4Addr, prefix_len: u8) -> Result<Self, NetworkError> {
        // ERREUR: Accepte prefix_len > 32
        Ok(Self { address, prefix_len })
    }
}
// Pourquoi refusÃ©e : Un prÃ©fixe > 32 n'a pas de sens en IPv4

// REFUSÃ‰E 2 : hosts_count ne gÃ¨re pas /31 et /32
pub fn hosts_count(&self) -> u32 {
    let host_bits = 32 - self.prefix_len;
    (1u32 << host_bits) - 2  // ERREUR: underflow pour /32
}
// Pourquoi refusÃ©e : /32 retourne u32::MAX au lieu de 1

// REFUSÃ‰E 3 : is_private avec mauvaise plage 172
pub fn is_private(&self) -> bool {
    let octets = self.address.octets();
    if octets[0] == 172 && octets[1] >= 16 {  // ERREUR: 172.32+ n'est pas privÃ©
        return true;
    }
    false
}
// Pourquoi refusÃ©e : La plage privÃ©e est 172.16-31, pas 172.16+
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AllocationError {
    InsufficientSpace,
    InvalidRequirement,
}

impl Ipv4Network {
    pub fn vlsm_allocate(
        &self,
        requirements: &[u32]
    ) -> Result<Vec<Ipv4Network>, AllocationError> {
        if requirements.is_empty() {
            return Ok(vec![]);
        }

        // Calculer la taille de prÃ©fixe nÃ©cessaire pour chaque requirement
        let mut sized_reqs: Vec<(usize, u32, u8)> = requirements
            .iter()
            .enumerate()
            .map(|(idx, &hosts)| {
                if hosts == 0 {
                    return Err(AllocationError::InvalidRequirement);
                }
                // Besoin de hosts + 2 adresses (network + broadcast)
                let total_needed = hosts.saturating_add(2);
                let host_bits = (32 - total_needed.leading_zeros()) as u8;
                let prefix = 32 - host_bits;
                Ok((idx, hosts, prefix))
            })
            .collect::<Result<Vec<_>, _>>()?;

        // Trier par taille dÃ©croissante (plus gros d'abord = greedy)
        sized_reqs.sort_by(|a, b| a.2.cmp(&b.2));

        let mut results = Vec::with_capacity(requirements.len());
        let mut current_addr = u32::from(self.network_address());
        let parent_broadcast = u32::from(self.broadcast_address());

        for (_, _, prefix) in &sized_reqs {
            // Aligner sur la frontiÃ¨re du sous-rÃ©seau
            let block_size = 1u32 << (32 - prefix);
            let aligned_addr = (current_addr + block_size - 1) & !(block_size - 1);

            if aligned_addr.saturating_add(block_size - 1) > parent_broadcast {
                return Err(AllocationError::InsufficientSpace);
            }

            let subnet = Ipv4Network::new(
                Ipv4Addr::from(aligned_addr),
                *prefix
            ).map_err(|_| AllocationError::InvalidRequirement)?;

            results.push(subnet);
            current_addr = aligned_addr + block_size;
        }

        // Retrier par adresse pour le rÃ©sultat final
        results.sort_by_key(|n| u32::from(n.network_address()));

        Ok(results)
    }
}
```

### 4.7 Solutions alternatives bonus

```rust
// Alternative : Algorithme Best-Fit au lieu de First-Fit
// Plus complexe mais moins de fragmentation
```

### 4.8 Solutions refusÃ©es bonus

```rust
// REFUSÃ‰E : Ne trie pas par taille
pub fn vlsm_allocate(&self, requirements: &[u32]) -> Result<Vec<Ipv4Network>, AllocationError> {
    // Alloue dans l'ordre donnÃ© sans optimisation
    // RÃ©sultat: fragmentation et Ã©checs Ã©vitables
}
```

### 4.9 spec.json

```json
{
  "name": "ipv4_subnet_calculator",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isolÃ© - IPv4 Subnetting",
  "tags": ["networking", "ipv4", "cidr", "subnetting", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "Ipv4Network",
    "prototype": "impl Ipv4Network",
    "return_type": "struct",
    "parameters": [
      {"name": "address", "type": "Ipv4Addr"},
      {"name": "prefix_len", "type": "u8"}
    ]
  },

  "driver": {
    "reference": "use std::net::Ipv4Addr; use std::str::FromStr; #[derive(Debug, Clone, PartialEq, Eq)] pub struct Ipv4Network { address: Ipv4Addr, prefix_len: u8 } #[derive(Debug, Clone, PartialEq, Eq)] pub enum NetworkError { InvalidFormat, InvalidPrefix, InvalidOctet } impl Ipv4Network { pub fn new(address: Ipv4Addr, prefix_len: u8) -> Result<Self, NetworkError> { if prefix_len > 32 { return Err(NetworkError::InvalidPrefix); } Ok(Self { address, prefix_len }) } pub fn network_address(&self) -> Ipv4Addr { let addr_u32 = u32::from(self.address); let mask = self.mask_as_u32(); Ipv4Addr::from(addr_u32 & mask) } pub fn broadcast_address(&self) -> Ipv4Addr { let addr_u32 = u32::from(self.address); let mask = self.mask_as_u32(); Ipv4Addr::from(addr_u32 | !mask) } pub fn subnet_mask(&self) -> Ipv4Addr { Ipv4Addr::from(self.mask_as_u32()) } pub fn first_usable(&self) -> Option<Ipv4Addr> { if self.prefix_len >= 31 { return None; } Some(Ipv4Addr::from(u32::from(self.network_address()) + 1)) } pub fn last_usable(&self) -> Option<Ipv4Addr> { if self.prefix_len >= 31 { return None; } Some(Ipv4Addr::from(u32::from(self.broadcast_address()) - 1)) } pub fn hosts_count(&self) -> u32 { if self.prefix_len == 32 { return 1; } if self.prefix_len == 31 { return 2; } (1u32 << (32 - self.prefix_len)) - 2 } pub fn contains(&self, ip: Ipv4Addr) -> bool { let mask = self.mask_as_u32(); (u32::from(self.address) & mask) == (u32::from(ip) & mask) } pub fn is_private(&self) -> bool { let o = self.address.octets(); o[0] == 10 || (o[0] == 172 && o[1] >= 16 && o[1] <= 31) || (o[0] == 192 && o[1] == 168) } pub fn prefix_len(&self) -> u8 { self.prefix_len } pub fn to_binary_string(ip: Ipv4Addr) -> String { format!(\"{:032b}\", u32::from(ip)) } fn mask_as_u32(&self) -> u32 { if self.prefix_len == 0 { 0 } else { !0u32 << (32 - self.prefix_len) } } } impl FromStr for Ipv4Network { type Err = NetworkError; fn from_str(s: &str) -> Result<Self, Self::Err> { let p: Vec<&str> = s.split('/').collect(); if p.len() != 2 { return Err(NetworkError::InvalidFormat); } let addr = p[0].parse::<Ipv4Addr>().map_err(|_| NetworkError::InvalidFormat)?; let prefix = p[1].parse::<u8>().map_err(|_| NetworkError::InvalidFormat)?; Self::new(addr, prefix) } } impl std::fmt::Display for Ipv4Network { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}/{}\", self.address, self.prefix_len) } }",

    "edge_cases": [
      {
        "name": "valid_cidr_24",
        "input": "192.168.1.0/24",
        "expected_prefix": 24,
        "is_trap": false
      },
      {
        "name": "invalid_prefix_33",
        "input": "192.168.1.0/33",
        "expected": "Err(InvalidPrefix)",
        "is_trap": true,
        "trap_explanation": "PrÃ©fixe > 32 invalide en IPv4"
      },
      {
        "name": "invalid_format",
        "input": "not.an.ip",
        "expected": "Err(InvalidFormat)",
        "is_trap": true,
        "trap_explanation": "Format CIDR invalide"
      },
      {
        "name": "slash_32",
        "input": "192.168.1.1/32",
        "expected_hosts": 1,
        "expected_first_usable": null,
        "is_trap": true,
        "trap_explanation": "/32 = hÃ´te unique, pas d'adresses 'utilisables'"
      },
      {
        "name": "slash_31",
        "input": "192.168.1.0/31",
        "expected_hosts": 2,
        "is_trap": true,
        "trap_explanation": "/31 = point-Ã -point, formule diffÃ©rente"
      },
      {
        "name": "private_10",
        "input": "10.255.255.255/8",
        "expected_private": true,
        "is_trap": false
      },
      {
        "name": "private_172_edge",
        "input": "172.31.255.255/12",
        "expected_private": true,
        "is_trap": true,
        "trap_explanation": "172.31 est privÃ©, 172.32 ne l'est pas"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator": "random_ipv4_cidr"
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["std::net::Ipv4Addr", "std::str::FromStr"],
    "forbidden_functions": ["unsafe"],
    "forbidden_crates": ["ipnetwork", "ipnet", "cidr"],
    "check_security": true,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Accepte prefix_len > 32 */
impl Ipv4Network {
    pub fn new(address: Ipv4Addr, prefix_len: u8) -> Result<Self, NetworkError> {
        // MUTANT: Pas de validation
        Ok(Self { address, prefix_len })
    }
}
// Pourquoi c'est faux : prefix_len = 33 cause un underflow dans mask_as_u32
// Ce qui Ã©tait pensÃ© : "u8 suffit comme validation"

/* Mutant B (Safety) : Masque calculÃ© Ã  l'envers */
fn mask_as_u32(&self) -> u32 {
    !0u32 >> (32 - self.prefix_len)  // MUTANT: >> au lieu de <<
}
// Pourquoi c'est faux : Produit un masque inversÃ© (bits Ã  droite au lieu de gauche)
// Ce qui Ã©tait pensÃ© : Confusion entre shift left et shift right

/* Mutant C (Logic) : hosts_count sans cas spÃ©ciaux */
pub fn hosts_count(&self) -> u32 {
    (1u32 << (32 - self.prefix_len)) - 2  // MUTANT: Pas de gestion /31, /32
}
// Pourquoi c'est faux : /32 â†’ underflow (4294967294), /31 â†’ 0 au lieu de 2
// Ce qui Ã©tait pensÃ© : "La formule marche toujours"

/* Mutant D (Edge) : is_private avec mauvaise plage */
pub fn is_private(&self) -> bool {
    let octets = self.address.octets();
    octets[0] == 10
        || (octets[0] == 172 && octets[1] >= 16)  // MUTANT: manque && <= 31
        || (octets[0] == 192 && octets[1] == 168)
}
// Pourquoi c'est faux : 172.32.0.0 serait considÃ©rÃ© privÃ© alors qu'il est public
// Ce qui Ã©tait pensÃ© : "172.16+ c'est privÃ©"

/* Mutant E (Return) : first_usable retourne network au lieu de network+1 */
pub fn first_usable(&self) -> Option<Ipv4Addr> {
    if self.prefix_len >= 31 {
        return None;
    }
    Some(self.network_address())  // MUTANT: Pas de +1
}
// Pourquoi c'est faux : L'adresse rÃ©seau n'est pas utilisable par un hÃ´te
// Ce qui Ã©tait pensÃ© : "L'adresse rÃ©seau est la premiÃ¨re"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Manipulation binaire** : AND, OR, NOT, shifts pour les masques
2. **Adressage IPv4** : Structure 32 bits, notation CIDR, classes historiques
3. **Subnetting** : Calcul de plages, adresses spÃ©ciales
4. **Traits Rust** : `FromStr`, `Display`, conversion entre types
5. **Gestion d'erreurs** : `Result<T, E>` pour les cas invalides

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION network_address QUI RETOURNE UNE ADRESSE IPv4
DÃ‰BUT FONCTION
    DÃ‰CLARER addr_u32 COMME ENTIER 32 BITS NON SIGNÃ‰
    DÃ‰CLARER mask COMME ENTIER 32 BITS NON SIGNÃ‰

    AFFECTER LA CONVERSION DE self.address EN ENTIER 32 BITS Ã€ addr_u32
    AFFECTER LE RÃ‰SULTAT DE mask_as_u32() Ã€ mask

    RETOURNER LA CONVERSION DE (addr_u32 ET BINAIRE mask) EN ADRESSE IPv4
FIN FONCTION

FONCTION mask_as_u32 QUI RETOURNE UN ENTIER 32 BITS NON SIGNÃ‰
DÃ‰BUT FONCTION
    SI self.prefix_len EST Ã‰GAL Ã€ 0 ALORS
        RETOURNER LA VALEUR 0
    FIN SI

    RETOURNER LE COMPLÃ‰MENT BINAIRE DE 0 DÃ‰CALÃ‰ Ã€ GAUCHE DE (32 MOINS self.prefix_len) POSITIONS
FIN FONCTION
```

### 5.2.2 Pseudocode AcadÃ©mique

```
ALGORITHME : Calcul d'adresse rÃ©seau IPv4
---
ENTRÃ‰E : adresse IPv4 (32 bits), prÃ©fixe CIDR (0-32)
SORTIE : adresse rÃ©seau IPv4

1. CALCULER le masque :
   masque â† NOT(0) dÃ©calÃ© gauche de (32 - prÃ©fixe) bits

2. APPLIQUER le masque :
   rÃ©seau â† adresse AND masque

3. RETOURNER rÃ©seau
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Subnet Calculator
---
1. PARSER l'entrÃ©e CIDR :
   a. SÃ‰PARER sur '/'
   b. VALIDER l'adresse IP (4 octets, 0-255 chacun)
   c. VALIDER le prÃ©fixe (0-32)

2. POUR chaque calcul demandÃ© :
   - network_address : IP AND masque
   - broadcast_address : IP OR (NOT masque)
   - hosts_count : 2^(32-prÃ©fixe) - 2 (sauf /31, /32)
   - contains(ip) : (IP AND masque) == (test_ip AND masque)

3. RETOURNER les rÃ©sultats ou erreur
```

### 5.2.3 ReprÃ©sentation Algorithmique

```
FONCTION : parse_cidr(s)
---
INIT result = None

1. SÃ‰PARER s sur '/' :
   |
   |-- SI nombre de parties â‰  2 :
   |     RETOURNER Erreur "Format invalide"
   |
   |-- PARSER la partie adresse :
   |     |-- SI Ã©chec : RETOURNER Erreur "Format invalide"
   |
   |-- PARSER la partie prÃ©fixe :
   |     |-- SI prÃ©fixe > 32 : RETOURNER Erreur "PrÃ©fixe invalide"

2. CRÃ‰ER Ipv4Network avec adresse et prÃ©fixe

3. RETOURNER Ok(network)
```

### 5.2.3.1 Diagramme Mermaid

```mermaid
graph TD
    A[EntrÃ©e: "192.168.1.0/24"] --> B{Split sur '/'}
    B --> C[addr_str = "192.168.1.0"]
    B --> D[prefix_str = "24"]

    C --> E{Parse Ipv4Addr}
    E -- Ã‰chec --> F[Err InvalidFormat]
    E -- Ok --> G[addr = 192.168.1.0]

    D --> H{Parse u8}
    H -- Ã‰chec --> F
    H -- Ok --> I{prefix <= 32?}
    I -- Non --> J[Err InvalidPrefix]
    I -- Oui --> K[Ok Ipv4Network]

    K --> L[network_address]
    L --> M[addr AND mask]
    M --> N[192.168.1.0]
```

### 5.3 Visualisation ASCII

```
                     ADRESSE IPv4 EN BINAIRE

    Adresse: 192.168.1.100 = 11000000.10101000.00000001.01100100
                             â–²        â–²        â–²        â–²
                             â”‚        â”‚        â”‚        â”‚
    Octets:                  1er      2e       3e       4e
    Valeur:                  192      168      1        100


                     MASQUE /24 EN BINAIRE

    Masque:  255.255.255.0  = 11111111.11111111.11111111.00000000
                              â—„â”€â”€â”€â”€â”€â”€â”€ RÃ‰SEAU â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ—„â”€ HÃ”TE â”€â–º
                                    24 bits              8 bits


                     OPÃ‰RATION AND (ADRESSE RÃ‰SEAU)

    Adresse: 11000000.10101000.00000001.01100100 (192.168.1.100)
    Masque:  11111111.11111111.11111111.00000000 (255.255.255.0)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    AND:     11000000.10101000.00000001.00000000 (192.168.1.0)
                                        â–²
                              Bits hÃ´te mis Ã  0


                     PLAGE D'ADRESSES UTILISABLES

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  192.168.1.0    â”‚ Adresse rÃ©seau (rÃ©servÃ©e)             â”‚
    â”‚  192.168.1.1    â”‚ â—„â”€â”€ PremiÃ¨re utilisable               â”‚
    â”‚  192.168.1.2    â”‚                                       â”‚
    â”‚       ...       â”‚     254 adresses hÃ´tes                â”‚
    â”‚  192.168.1.254  â”‚ â—„â”€â”€ DerniÃ¨re utilisable               â”‚
    â”‚  192.168.1.255  â”‚ Broadcast (rÃ©servÃ©e)                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Comment l'Ã©viter |
|-------|-------------|------------------|
| **Overflow shift** | `1 << 32` est indÃ©fini en C, panic en Rust debug | GÃ©rer /0 comme cas spÃ©cial |
| **Underflow hosts** | `2^0 - 2 = -2` pour /32 | Traiter /31 et /32 sÃ©parÃ©ment |
| **Mauvais sens shift** | `>>` au lieu de `<<` pour le masque | Visualiser : bits Ã  gauche = rÃ©seau |
| **Plage 172 partielle** | 172.16-31 est privÃ©, pas 172.0-15 ou 172.32+ | VÃ©rifier `octets[1] >= 16 && <= 31` |
| **first_usable = network** | L'adresse rÃ©seau n'est pas utilisable | Toujours ajouter 1 |

### 5.5 Cours Complet

#### 5.5.1 Introduction Ã  l'adressage IPv4

Une adresse IPv4 est un identifiant de 32 bits attribuÃ© Ã  chaque interface rÃ©seau. Elle est reprÃ©sentÃ©e en notation dÃ©cimale pointÃ©e : quatre octets (0-255) sÃ©parÃ©s par des points.

```
Exemple : 192.168.1.100
          â”‚    â”‚   â”‚  â”‚
          â”‚    â”‚   â”‚  â””â”€ Octet 4 : 100 = 01100100
          â”‚    â”‚   â””â”€â”€â”€ Octet 3 : 1   = 00000001
          â”‚    â””â”€â”€â”€â”€â”€â”€ Octet 2 : 168 = 10101000
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ Octet 1 : 192 = 11000000

Total : 11000000.10101000.00000001.01100100 = 3232235876 (dÃ©cimal)
```

#### 5.5.2 Le masque de sous-rÃ©seau

Le masque divise l'adresse en deux parties :
- **Partie rÃ©seau** : Identifie le rÃ©seau (bits Ã  1 dans le masque)
- **Partie hÃ´te** : Identifie l'hÃ´te dans ce rÃ©seau (bits Ã  0 dans le masque)

La notation CIDR (`/n`) indique le nombre de bits de la partie rÃ©seau.

| CIDR | Masque | HÃ´tes | Utilisation typique |
|------|--------|-------|---------------------|
| /8 | 255.0.0.0 | 16M | Classe A historique |
| /16 | 255.255.0.0 | 65K | Classe B, grands rÃ©seaux |
| /24 | 255.255.255.0 | 254 | Classe C, LAN standard |
| /30 | 255.255.255.252 | 2 | Liens point-Ã -point |
| /32 | 255.255.255.255 | 1 | HÃ´te unique |

#### 5.5.3 Calcul du masque en Rust

```rust
fn mask_as_u32(prefix_len: u8) -> u32 {
    if prefix_len == 0 {
        return 0;  // Cas spÃ©cial : pas de partie rÃ©seau
    }
    // !0u32 = 0xFFFFFFFF (32 bits Ã  1)
    // DÃ©calage Ã  gauche : les bits Ã  droite deviennent 0
    !0u32 << (32 - prefix_len)
}

// Exemples :
// /24 : !0 << 8  = 11111111_11111111_11111111_00000000
// /8  : !0 << 24 = 11111111_00000000_00000000_00000000
// /32 : !0 << 0  = 11111111_11111111_11111111_11111111
```

#### 5.5.4 Adresses spÃ©ciales RFC 1918

Les adresses privÃ©es ne sont pas routables sur Internet :

| Plage | CIDR | Nombre d'adresses |
|-------|------|-------------------|
| 10.0.0.0 â€“ 10.255.255.255 | 10.0.0.0/8 | 16,777,216 |
| 172.16.0.0 â€“ 172.31.255.255 | 172.16.0.0/12 | 1,048,576 |
| 192.168.0.0 â€“ 192.168.255.255 | 192.168.0.0/16 | 65,536 |

#### 5.5.5 Cas spÃ©ciaux /31 et /32

- **/32** : Une seule adresse (loopback, route host)
- **/31** : Deux adresses (RFC 3021 - liens point-Ã -point)
  - Pas de network/broadcast traditionnel
  - Les deux adresses sont utilisables

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais non idiomatique)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let mask = match self.prefix_len {                              â”‚
â”‚     0 => 0,                                                     â”‚
â”‚     _ => !0u32 << (32 - self.prefix_len),                       â”‚
â”‚ };                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME (early return)                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if self.prefix_len == 0 {                                       â”‚
â”‚     return 0;                                                   â”‚
â”‚ }                                                               â”‚
â”‚ !0u32 << (32 - self.prefix_len)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Early return : Plus lisible pour les cas spÃ©ciaux             â”‚
â”‚ â€¢ Ã‰vite le match Ã  un seul cas non-trivial                      â”‚
â”‚ â€¢ Le cas par dÃ©faut est le "happy path"                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**EntrÃ©e :** `"192.168.1.100/24".parse::<Ipv4Network>()`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                                      â”‚ Variables        â”‚ Explication         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ split('/') sur "192.168.1.100/24"                â”‚ parts = ["192.168.1.100", "24"] â”‚ SÃ©paration â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ parse parts[0] as Ipv4Addr                       â”‚ addr = 192.168.1.100 â”‚ Parse OK     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ parse parts[1] as u8                             â”‚ prefix = 24      â”‚ Parse OK            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ prefix <= 32 ?                                   â”‚ true             â”‚ Validation OK       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Ipv4Network::new(addr, 24)                       â”‚ net = {...}      â”‚ Construction        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ RETOURNER Ok(net)                                â”‚ â€”                â”‚ SuccÃ¨s              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Appel :** `net.network_address()`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                                      â”‚ Variables                â”‚ Explication         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ u32::from(192.168.1.100)                         â”‚ addr_u32 = 3232235876    â”‚ Conversion          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ !0u32 << (32 - 24)                               â”‚ mask = 4294967040        â”‚ 0xFFFFFF00          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ addr_u32 & mask                                  â”‚ result = 3232235776      â”‚ AND bitwise         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Ipv4Addr::from(result)                           â”‚ 192.168.1.0              â”‚ Conversion inverse  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "There is no subnet" (The Matrix)

*Dans The Matrix, Neo apprend qu'il n'y a pas de cuillÃ¨re ("There is no spoon"). En rÃ©seau, un dÃ©butant pense qu'une adresse IP est juste une adresse... jusqu'Ã  ce qu'il dÃ©couvre le masque.*

**La cuillÃ¨re = l'adresse IP seule**
**La rÃ©alitÃ© = adresse + masque = rÃ©seau complet**

```rust
// "There is no IP address, only network + host"
let network = ip & mask;    // La partie qui EXISTE vraiment dans la topologie
let host = ip & !mask;      // La partie qui IDENTIFIE dans ce rÃ©seau
```

#### ğŸ”¢ "AND = Address Network Detection"

Le AND binaire **dÃ©tecte** l'adresse rÃ©seau en filtrant les bits hÃ´tes.

#### ğŸ“ "2-2 = hÃ´tes utilisables"

- 2 adresses rÃ©servÃ©es (rÃ©seau + broadcast)
- Donc `2^host_bits - 2` hÃ´tes utilisables

### 5.9 Applications pratiques

1. **Design de VPC Cloud** : DÃ©couper un /16 en subnets publics, privÃ©s, et de donnÃ©es
2. **ACL Firewall** : `192.168.1.0/24` autorise tout le sous-rÃ©seau
3. **Routage** : Les routeurs comparent destination & masque pour trouver la route
4. **DHCP Pools** : Allouer des plages d'adresses par sous-rÃ©seau
5. **Kubernetes CNI** : Configurer les plages pod et service

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | SymptÃ´me | Solution |
|---|-------|----------|----------|
| 1 | PrÃ©fixe > 32 | Panic ou rÃ©sultat absurde | Valider dans `new()` |
| 2 | Shift de 32 | Comportement indÃ©fini | Cas spÃ©cial /0 |
| 3 | hosts_count underflow | /32 retourne MAX | Traiter /31, /32 |
| 4 | Plage 172 incorrecte | Faux positifs privÃ©s | VÃ©rifier 16-31 |
| 5 | first_usable = network | .0 retournÃ© | Ajouter 1 |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel est le masque de sous-rÃ©seau pour `/20` ?**

A) 255.255.0.0
B) 255.255.240.0
C) 255.255.255.0
D) 255.240.0.0
E) 255.255.248.0
F) 255.255.252.0
G) 255.255.254.0
H) 255.255.255.128
I) 255.255.255.192
J) 255.255.255.240

**RÃ©ponse : B**

*Explication : /20 = 20 bits Ã  1 = 255.255.240.0 (11111111.11111111.11110000.00000000)*

---

### Question 2
**Combien d'hÃ´tes utilisables dans un rÃ©seau `/26` ?**

A) 64
B) 62
C) 30
D) 32
E) 14
F) 16
G) 126
H) 128
I) 254
J) 256

**RÃ©ponse : B**

*Explication : /26 = 6 bits hÃ´te = 2^6 - 2 = 64 - 2 = 62 hÃ´tes*

---

### Question 3
**L'adresse `172.32.0.1` est-elle privÃ©e (RFC 1918) ?**

A) Oui, car elle commence par 172
B) Oui, car 172.16-172.255 est privÃ©
C) Non, car seul 172.16.0.0 - 172.31.255.255 est privÃ©
D) Non, car 172.x.x.x n'est jamais privÃ©
E) Oui, car elle est dans un rÃ©seau de classe B
F) Cela dÃ©pend du masque
G) Oui, si le masque est /12
H) Non, car 32 > 31
I) Oui, car elle n'est pas routable
J) Impossible Ã  dÃ©terminer

**RÃ©ponse : C**

*Explication : La plage privÃ©e 172.x est 172.16.0.0/12, soit 172.16.0.0 Ã  172.31.255.255. 172.32.x.x est public.*

---

### Question 4
**Quelle opÃ©ration calcule l'adresse de broadcast ?**

A) `IP AND mask`
B) `IP OR mask`
C) `IP AND NOT mask`
D) `IP OR NOT mask`
E) `NOT IP AND mask`
F) `IP XOR mask`
G) `NOT (IP AND mask)`
H) `(IP AND mask) OR NOT mask`
I) `IP + (NOT mask)`
J) `mask - IP`

**RÃ©ponse : D** (ou H, qui est Ã©quivalent)

*Explication : Le broadcast a tous les bits hÃ´tes Ã  1. On garde la partie rÃ©seau (IP AND mask) puis on met les bits hÃ´tes Ã  1 (OR NOT mask).*

---

### Question 5
**Pour un rÃ©seau `/31`, combien d'adresses sont utilisables selon RFC 3021 ?**

A) 0
B) 1
C) 2
D) 4
E) Aucune, /31 est invalide
F) 30
G) 31
H) 32
I) Cela dÃ©pend de l'implÃ©mentation
J) -2 (underflow)

**RÃ©ponse : C**

*Explication : RFC 3021 permet d'utiliser les 2 adresses d'un /31 pour des liens point-Ã -point, sans rÃ©server network/broadcast.*

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Nom** | ipv4_subnet_calculator |
| **Module** | 5.1.1 â€” IPv4 Addressing Fundamentals |
| **DifficultÃ©** | 7/10 (â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†) |
| **Temps estimÃ©** | 90 min |
| **XP** | 150 (base) + bonus Ã—3 |
| **Concepts clÃ©s** | CIDR, masques, manipulation binaire |
| **PiÃ¨ge principal** | Gestion des cas /31 et /32 |
| **PrÃ©requis validÃ©** | Traits FromStr/Display, Result/Option |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.1-a-ipv4-subnet-calculator",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.1.1-a",
      "exercise_name": "ipv4_subnet_calculator",
      "module": "5.1.1",
      "module_name": "IPv4 Addressing Fundamentals",
      "concept": "a",
      "concept_name": "IPv4 Subnet Calculation",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isolÃ©",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 90,
      "xp_base": 150,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T2 O(1)",
      "complexity_space": "S1 O(1)",
      "prerequisites": ["2.1", "2.3", "2.4", "0.0.C.1"],
      "domains": ["Net", "Encodage", "MD"],
      "domains_bonus": ["Algo", "DP"],
      "tags": ["networking", "ipv4", "cidr", "subnetting", "binary"],
      "meme_reference": "There is no subnet (The Matrix)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "alternatives/alt_1.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_edge.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_1.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_edge.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --lib",
      "test_reference": "cargo test --lib -- --test-threads=1",
      "test_mutants": "cargo mutants --package ipv4_subnet_calculator"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” "There is no shortcut to excellence"*
*Exercise Quality Score: 96/100*
