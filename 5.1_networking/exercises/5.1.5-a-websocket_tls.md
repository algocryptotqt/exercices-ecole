<thinking>
## Analyse du Concept
- Concept : WebSocket Chat with TLS
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - WebSocket est LE protocole pour communication bidirectionnelle temps reel. L'ajout de TLS couvre la securisation essentielle en production.

## Combo Base + Bonus
- Exercice de base : Serveur WebSocket avec handshake RFC 6455, framing, masking, support Text/Binary/Ping/Pong/Close
- Bonus : Integration TLS complete avec tokio-rustls, certificats auto-signes, et chat broadcast multi-client
- Palier bonus : EXPERT (protocol implementation + cryptographie)
- Progression logique ? OUI - Base = protocole WebSocket pur, Bonus = securisation TLS

## Prerequis & Difficulte
- Prerequis reels : TCP (5.1.2), HTTP basics (5.1.3), async Rust (tokio), base64, SHA-1
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI - Implementation de protocole avance avec crypto

## Aspect Fun/Culture
- Contexte choisi : Reference a "Person of Interest" - The Machine qui communique en temps reel de maniere securisee
- MEME mnemonique : "Can you hear me?" (communication persistante bidirectionnelle)
- Pourquoi c'est fun : WebSocket = le "canal secret" entre The Machine et Finch

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Handshake) : Mauvais calcul du Sec-WebSocket-Accept -> connexion rejetee par client
2. Mutant B (Framing) : Oubli du bit FIN -> frames fragmentees mal reassemblees
3. Mutant C (Masking) : Pas de demasquage des frames client -> payload corrompu
4. Mutant D (Opcode) : Pas de reponse Pong aux Ping -> timeout client
5. Mutant E (TLS) : Certificat mal charge -> handshake TLS echoue

## Verdict
VALIDE - Exercice avance couvrant WebSocket RFC 6455 + securisation TLS
</thinking>

# Exercice 5.1.5-a : websocket_tls

**Module :**
5.1.5 — WebSocket Protocol & TLS Security

**Concept :**
a — Secure WebSocket Server (RFC 6455, handshake, framing, TLS)

**Difficulte :**
(8/10)

**Type :**
code

**Tiers :**
2 — Multi-concepts (WebSocket + TLS)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.1.2 — TCP Fundamentals
- 5.1.3 — HTTP Protocol Basics
- 2.6 — Async Rust (tokio runtime)
- Module 2.4 — Encoding (base64, SHA-1)

**Domaines :**
Net, Crypto, Async

**Duree estimee :**
180 min

**XP Base :**
250

**Complexite :**
T2 O(n) x S2 O(n) ou n = nombre de messages/clients

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
src/lib.rs
src/main.rs
Cargo.toml
```

**Dependances autorisees :**
- `tokio` (runtime async, net, io, sync)
- `tokio-rustls` (TLS async wrapper)
- `rustls` (pure Rust TLS)
- `rustls-pemfile` (parsing certificats PEM)
- `sha1` (hash pour handshake)
- `base64` (encodage Sec-WebSocket-Accept)

**Fonctions/methodes interdites :**
- Crates WebSocket completes (`tungstenite`, `tokio-tungstenite`, `ws`)
- `unsafe` blocks (sauf si justifie pour perf)

### 1.2 Consigne

**CONTEXTE : "The Machine's Whisper"**

*"Every connection is a conversation. Every frame, a secret. The Machine doesn't just listen - it speaks back, encrypted, persistent, alive."* — Harold Finch, architecte de systemes

Dans Person of Interest, The Machine communique avec ses operateurs via des canaux secrets, persistants et securises. WebSocket, c'est exactement ca : une connexion qui reste ouverte, bidirectionnelle, temps reel. Ajoutez TLS, et vous avez un canal que meme Samaritan ne peut intercepter.

**Ta mission :**

Implementer un serveur WebSocket securise par TLS avec :
1. Handshake WebSocket complet (upgrade HTTP vers WebSocket)
2. Parsing et creation de frames selon RFC 6455
3. Support des opcodes : Text, Binary, Ping, Pong, Close
4. Demasquage obligatoire des frames client (XOR avec masking key)
5. Configuration TLS avec rustls (certificats PEM)
6. Chat broadcast : chaque message Text est renvoye a tous les clients connectes

**Le protocole WebSocket en bref :**

```
                    HANDSHAKE (sur HTTP)
    ┌────────────────────────────────────────────────────┐
    │  Client                              Server        │
    │    │                                    │          │
    │    │ ─── GET /chat HTTP/1.1 ─────────► │          │
    │    │     Upgrade: websocket            │          │
    │    │     Connection: Upgrade           │          │
    │    │     Sec-WebSocket-Key: xxx        │          │
    │    │     Sec-WebSocket-Version: 13     │          │
    │    │                                    │          │
    │    │ ◄── HTTP/1.1 101 Switching ────── │          │
    │    │     Upgrade: websocket            │          │
    │    │     Connection: Upgrade           │          │
    │    │     Sec-WebSocket-Accept: yyy     │          │
    │    │                                    │          │
    └────────────────────────────────────────────────────┘

                    FRAMING (apres handshake)
    ┌────────────────────────────────────────────────────┐
    │                                                    │
    │   0                   1                   2        │
    │   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3  │
    │  +-+-+-+-+-------+-+-------------+----------------+│
    │  |F|R|R|R| opcode|M| Payload len |    Extended    ││
    │  |I|S|S|S|  (4)  |A|     (7)     |  payload len   ││
    │  |N|V|V|V|       |S|             |   (16/64 bits) ││
    │  | |1|2|3|       |K|             |                ││
    │  +-+-+-+-+-------+-+-------------+----------------+│
    │  |     Masking-key (si MASK=1)    |               ││
    │  +--------------------------------+               ││
    │  |          Payload Data          |               ││
    │  +--------------------------------+               ││
    │                                                    │
    └────────────────────────────────────────────────────┘
```

**Calcul de Sec-WebSocket-Accept :**
```
Accept = Base64(SHA1(Sec-WebSocket-Key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))
```

**Entree :**
- `address: &str` — Adresse d'ecoute (ex: "127.0.0.1")
- `port: u16` — Port d'ecoute (ex: 8443)
- `tls_config: TlsConfig` — Chemins vers certificat et cle privee

**Sortie :**
- Serveur WebSocket TLS fonctionnel
- `WebSocketError` en cas d'echec

**Contraintes :**
- Le handshake DOIT valider Sec-WebSocket-Version = 13
- Les frames client DOIVENT etre masquees (RFC 6455 Section 5.1)
- Les frames serveur NE DOIVENT PAS etre masquees
- Ping DOIT recevoir Pong avec meme payload
- Close DOIT etre acquitte puis connexion fermee

**Exemples :**

| Client envoie | Serveur repond | Explication |
|---------------|----------------|-------------|
| Frame Text "Hello" | Broadcast "Hello" a tous | Message diffuse |
| Frame Ping "beat" | Frame Pong "beat" | Heartbeat |
| Frame Close 1000 | Frame Close 1000, fermeture | Fermeture propre |
| Frame Binary [...] | Broadcast binaire a tous | Donnees binaires |

### 1.2.2 Consigne Academique

Implementer un serveur WebSocket conforme a la RFC 6455 avec support TLS. Le serveur doit gerer le handshake HTTP Upgrade, parser et generer des frames WebSocket, appliquer le demasquage XOR sur les frames client, et securiser les connexions avec TLS via la crate rustls.

### 1.3 Prototype

```rust
use std::sync::Arc;
use tokio::sync::broadcast;
use tokio::net::TcpStream;
use tokio_rustls::TlsAcceptor;
use sha1::{Sha1, Digest};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};

/// GUID WebSocket pour le calcul de Sec-WebSocket-Accept (RFC 6455)
pub const WS_GUID: &str = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

/// Opcode WebSocket (4 bits)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Opcode {
    Continuation = 0x0,
    Text = 0x1,
    Binary = 0x2,
    Close = 0x8,
    Ping = 0x9,
    Pong = 0xA,
}

impl TryFrom<u8> for Opcode {
    type Error = WebSocketError;
    fn try_from(value: u8) -> Result<Self, Self::Error>;
}

/// Frame WebSocket
#[derive(Debug, Clone)]
pub struct WebSocketFrame {
    pub fin: bool,
    pub opcode: Opcode,
    pub mask: Option<[u8; 4]>,
    pub payload: Vec<u8>,
}

/// Message WebSocket (peut etre compose de plusieurs frames)
#[derive(Debug, Clone)]
pub enum WebSocketMessage {
    Text(String),
    Binary(Vec<u8>),
    Ping(Vec<u8>),
    Pong(Vec<u8>),
    Close(Option<(u16, String)>),
}

/// Erreurs WebSocket
#[derive(Debug)]
pub enum WebSocketError {
    InvalidHandshake(String),
    InvalidFrame(String),
    InvalidOpcode(u8),
    InvalidUtf8,
    MaskRequired,
    ConnectionClosed,
    TlsError(String),
    IoError(std::io::Error),
}

/// Configuration TLS
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

impl WebSocketFrame {
    /// Cree une frame text (FIN=1, opcode=Text)
    pub fn text(data: &str) -> Self;

    /// Cree une frame binary (FIN=1, opcode=Binary)
    pub fn binary(data: Vec<u8>) -> Self;

    /// Cree une frame ping
    pub fn ping(data: Vec<u8>) -> Self;

    /// Cree une frame pong (meme payload que le ping recu)
    pub fn pong(data: Vec<u8>) -> Self;

    /// Cree une frame close avec code et raison optionnels
    pub fn close(code: Option<u16>, reason: &str) -> Self;

    /// Parse une frame depuis un reader async
    /// DOIT gerer les 3 formats de longueur (7-bit, 16-bit, 64-bit)
    pub async fn read<R: tokio::io::AsyncReadExt + Unpin>(
        reader: &mut R
    ) -> Result<Self, WebSocketError>;

    /// Serialise la frame en bytes (sans masking pour serveur)
    pub fn to_bytes(&self) -> Vec<u8>;

    /// Applique le demasquage XOR au payload
    /// payload[i] ^= mask[i % 4]
    pub fn unmask(&mut self);
}

/// Calcule Sec-WebSocket-Accept depuis Sec-WebSocket-Key
/// Accept = Base64(SHA1(Key + GUID))
pub fn compute_accept_key(key: &str) -> String {
    let mut hasher = Sha1::new();
    hasher.update(key.trim().as_bytes());
    hasher.update(WS_GUID.as_bytes());
    BASE64.encode(hasher.finalize())
}

/// Parse la requete HTTP de handshake et extrait Sec-WebSocket-Key
/// Valide: GET, Upgrade: websocket, Connection: Upgrade, Version: 13
pub fn parse_handshake(request: &str) -> Result<String, WebSocketError>;

/// Genere la reponse HTTP 101 Switching Protocols
pub fn handshake_response(accept_key: &str) -> String;

/// Charge les certificats TLS depuis fichiers PEM
pub async fn load_tls_config(config: &TlsConfig) -> Result<TlsAcceptor, WebSocketError>;

/// Serveur WebSocket avec TLS
pub struct SecureWebSocketServer {
    address: String,
    port: u16,
    tls_acceptor: TlsAcceptor,
    broadcast_tx: broadcast::Sender<WebSocketMessage>,
}

impl SecureWebSocketServer {
    /// Cree un nouveau serveur
    pub async fn new(
        address: &str,
        port: u16,
        tls_config: TlsConfig,
    ) -> Result<Self, WebSocketError>;

    /// Demarre le serveur (boucle accept)
    pub async fn run(&self) -> Result<(), WebSocketError>;

    /// Retourne le nombre de clients connectes
    pub fn client_count(&self) -> usize;
}

/// Gere une connexion WebSocket (handshake + message loop)
async fn handle_websocket_connection<S>(
    stream: S,
    broadcast_tx: broadcast::Sender<WebSocketMessage>,
) -> Result<(), WebSocketError>
where
    S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Pourquoi le masking client vers serveur ?

Le masking n'est PAS pour la securite (TLS s'en charge). C'est une protection contre les **cache poisoning attacks** sur les proxies HTTP intermediaires.

```
Sans masking, un attaquant pourrait:
1. Envoyer une frame WebSocket qui ressemble a une requete HTTP
2. Un proxy mal configure pourrait la cacher
3. D'autres utilisateurs recevraient le contenu malicieux

Le masking rend les donnees WebSocket indistinguables de donnees aleatoires.
```

### 2.2 Frame fragmentation

Un message peut etre fragmente en plusieurs frames :

```
Message "Hello World" fragmente:
  Frame 1: FIN=0, opcode=Text, payload="Hello "
  Frame 2: FIN=0, opcode=Continuation, payload="Wor"
  Frame 3: FIN=1, opcode=Continuation, payload="ld"
```

Seule la premiere frame a l'opcode reel. Les suivantes ont `Continuation` (0x0).

### 2.3 Close handshake

La fermeture WebSocket est bidirectionnelle :

```
Client                                Server
   │                                     │
   │ ─── Close(1000, "bye") ──────────► │  1. Client initie
   │                                     │
   │ ◄── Close(1000, "bye") ─────────── │  2. Server acquitte
   │                                     │
   ═══════ TCP FIN/ACK ════════════════    3. Fermeture TCP
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation |
|--------|-------------|
| **Full-Stack Developer** | Chat temps reel, notifications push, collaborative editing |
| **Game Developer** | Multiplayer networking, game state sync, matchmaking |
| **Trading Systems** | Market data feeds, order updates, low-latency trading |
| **IoT Engineer** | Device telemetry, command & control, sensor streaming |

### Cas d'usage concrets

1. **Slack/Discord** : Chat temps reel avec presence indicators
2. **Figma** : Collaborative design avec curseurs multi-utilisateurs
3. **Binance** : WebSocket streams pour market data (100K+ msg/sec)
4. **Grafana** : Dashboards temps reel avec metrics streaming

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/  certs/

$ cat certs/README.md
# Generer certificats auto-signes pour dev:
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes

$ cargo build --release
   Compiling websocket_tls v0.1.0
    Finished release [optimized] target(s)

$ cargo run --release -- --cert certs/cert.pem --key certs/key.pem &
[1] 54321
SecureWebSocket server listening on wss://127.0.0.1:8443

# Test avec websocat (client WebSocket CLI)
$ websocat --insecure wss://127.0.0.1:8443/chat
Connected to wss://127.0.0.1:8443/chat
> Hello Machine
< Hello Machine
> Can you hear me?
< Can you hear me?
^C

$ cargo test
running 10 tests
test tests::test_compute_accept_key ... ok
test tests::test_parse_handshake ... ok
test tests::test_handshake_response ... ok
test tests::test_frame_serialization_text ... ok
test tests::test_frame_serialization_extended_length ... ok
test tests::test_frame_parsing ... ok
test tests::test_unmask ... ok
test tests::test_close_frame_with_code ... ok
test tests::test_ping_pong ... ok
test tests::test_opcode_from_byte ... ok

test result: ok. 10 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
(10/10)

**Recompense :**
XP x4

**Time Complexity attendue :**
O(1) pour broadcast, O(n) pour gestion clients

**Space Complexity attendue :**
O(clients x messages)

**Domaines Bonus :**
`Crypto, Async, Algo`

#### 3.1.1 Consigne Bonus

**"The Secure Network"**

*"Numbers never stop coming. Neither do the threats. The Machine must scale."*

**Ta mission bonus :**

Implementer un serveur WebSocket TLS production-ready avec :
1. **Connection pooling** avec limite configurable
2. **Heartbeat automatique** (Ping toutes les 30s, timeout 60s)
3. **Rooms/Channels** : les clients rejoignent des salons nommes
4. **Rate limiting** : max 100 messages/minute par client
5. **Graceful shutdown** : fermeture propre de toutes les connexions

**Contraintes :**
```
max_connections <= 10000
heartbeat_interval = 30s
heartbeat_timeout = 60s
rate_limit = 100 msg/min
shutdown_timeout = 30s
```

#### 3.1.2 Prototype Bonus

```rust
pub struct ServerConfig {
    pub address: String,
    pub port: u16,
    pub tls_config: TlsConfig,
    pub max_connections: usize,
    pub heartbeat_interval: Duration,
    pub heartbeat_timeout: Duration,
    pub rate_limit: RateLimit,
}

pub struct RateLimit {
    pub max_messages: usize,
    pub window: Duration,
}

pub struct Room {
    pub name: String,
    pub clients: HashSet<ClientId>,
    pub broadcast_tx: broadcast::Sender<WebSocketMessage>,
}

pub struct ProductionWebSocketServer {
    config: ServerConfig,
    rooms: Arc<RwLock<HashMap<String, Room>>>,
    clients: Arc<RwLock<HashMap<ClientId, ClientState>>>,
    shutdown_tx: watch::Sender<bool>,
}

impl ProductionWebSocketServer {
    pub async fn new(config: ServerConfig) -> Result<Self, WebSocketError>;
    pub async fn run(&self) -> Result<(), WebSocketError>;
    pub async fn shutdown(&self, timeout: Duration) -> Result<(), WebSocketError>;
    pub async fn join_room(&self, client_id: ClientId, room: &str);
    pub async fn leave_room(&self, client_id: ClientId, room: &str);
    pub fn room_count(&self) -> usize;
    pub fn client_count(&self) -> usize;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Description | Points | Categorie |
|------|-------------|--------|-----------|
| `test_compute_accept_key` | RFC 6455 example key | 10 | Handshake |
| `test_parse_handshake` | Extraction Sec-WebSocket-Key | 10 | Handshake |
| `test_handshake_response` | Format HTTP 101 correct | 10 | Handshake |
| `test_frame_serialization_text` | Frame text simple | 10 | Framing |
| `test_frame_serialization_extended_length` | Frame >125 bytes | 10 | Framing |
| `test_frame_parsing` | Parse frame masquee | 10 | Framing |
| `test_unmask` | XOR demasquage correct | 10 | Masking |
| `test_close_frame_with_code` | Frame close avec status | 10 | Control |
| `test_ping_pong` | Ping genere Pong correct | 10 | Control |
| `test_opcode_from_byte` | Conversion opcode valide/invalide | 10 | Protocol |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compute_accept_key() {
        // Exemple officiel RFC 6455 Section 1.3
        let key = "dGhlIHNhbXBsZSBub25jZQ==";
        let accept = compute_accept_key(key);
        assert_eq!(accept, "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=");
    }

    #[test]
    fn test_parse_handshake() {
        let request = "GET /chat HTTP/1.1\r\n\
            Host: server.example.com\r\n\
            Upgrade: websocket\r\n\
            Connection: Upgrade\r\n\
            Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n\
            Sec-WebSocket-Version: 13\r\n\r\n";

        let key = parse_handshake(request).unwrap();
        assert_eq!(key, "dGhlIHNhbXBsZSBub25jZQ==");
    }

    #[test]
    fn test_parse_handshake_invalid_method() {
        let request = "POST /chat HTTP/1.1\r\n\
            Upgrade: websocket\r\n\r\n";

        let result = parse_handshake(request);
        assert!(matches!(result, Err(WebSocketError::InvalidHandshake(_))));
    }

    #[test]
    fn test_parse_handshake_missing_upgrade() {
        let request = "GET /chat HTTP/1.1\r\n\
            Connection: Upgrade\r\n\
            Sec-WebSocket-Key: xxx\r\n\r\n";

        let result = parse_handshake(request);
        assert!(matches!(result, Err(WebSocketError::InvalidHandshake(_))));
    }

    #[test]
    fn test_handshake_response() {
        let accept_key = "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=";
        let response = handshake_response(accept_key);

        assert!(response.starts_with("HTTP/1.1 101 Switching Protocols\r\n"));
        assert!(response.contains("Upgrade: websocket\r\n"));
        assert!(response.contains("Connection: Upgrade\r\n"));
        assert!(response.contains(&format!("Sec-WebSocket-Accept: {}\r\n", accept_key)));
        assert!(response.ends_with("\r\n\r\n"));
    }

    #[test]
    fn test_frame_serialization_text() {
        let frame = WebSocketFrame::text("Hello");
        let bytes = frame.to_bytes();

        // FIN=1, opcode=1 (text) => 0x81
        assert_eq!(bytes[0], 0x81);
        // Length=5, no mask (server frame)
        assert_eq!(bytes[1], 5);
        // Payload
        assert_eq!(&bytes[2..], b"Hello");
    }

    #[test]
    fn test_frame_serialization_extended_length_16bit() {
        let data = vec![0x42u8; 200]; // 200 bytes
        let frame = WebSocketFrame::binary(data.clone());
        let bytes = frame.to_bytes();

        // FIN=1, opcode=2 (binary) => 0x82
        assert_eq!(bytes[0], 0x82);
        // Length=126 indicates 16-bit extended length follows
        assert_eq!(bytes[1], 126);
        // 16-bit length in big-endian: 200 = 0x00C8
        assert_eq!(bytes[2], 0x00);
        assert_eq!(bytes[3], 0xC8);
        // Payload starts at index 4
        assert_eq!(&bytes[4..], &data[..]);
    }

    #[test]
    fn test_frame_serialization_extended_length_64bit() {
        let data = vec![0x42u8; 70000]; // > 65535 bytes
        let frame = WebSocketFrame::binary(data.clone());
        let bytes = frame.to_bytes();

        // FIN=1, opcode=2 (binary) => 0x82
        assert_eq!(bytes[0], 0x82);
        // Length=127 indicates 64-bit extended length follows
        assert_eq!(bytes[1], 127);
        // 64-bit length in big-endian
        let len_bytes = &bytes[2..10];
        let len = u64::from_be_bytes(len_bytes.try_into().unwrap());
        assert_eq!(len, 70000);
        // Payload starts at index 10
        assert_eq!(&bytes[10..], &data[..]);
    }

    #[tokio::test]
    async fn test_frame_parsing() {
        // Frame text "Hello" masquee (client vers serveur)
        let masked_frame: Vec<u8> = vec![
            0x81,  // FIN=1, opcode=1 (text)
            0x85,  // MASK=1, length=5
            0x37, 0xfa, 0x21, 0x3d,  // Masking key
            0x7f, 0x9f, 0x4d, 0x51, 0x58,  // Masked "Hello"
        ];

        let mut reader = &masked_frame[..];
        let mut frame = WebSocketFrame::read(&mut reader).await.unwrap();

        assert!(frame.fin);
        assert_eq!(frame.opcode, Opcode::Text);
        assert!(frame.mask.is_some());
        assert_eq!(frame.mask.unwrap(), [0x37, 0xfa, 0x21, 0x3d]);

        frame.unmask();
        assert_eq!(frame.payload, b"Hello");
    }

    #[tokio::test]
    async fn test_frame_parsing_unmasked() {
        // Frame sans mask (serveur vers client) - illegal pour client
        let unmasked_frame: Vec<u8> = vec![
            0x81,  // FIN=1, opcode=1
            0x05,  // MASK=0, length=5
            b'H', b'e', b'l', b'l', b'o',
        ];

        let mut reader = &unmasked_frame[..];
        let frame = WebSocketFrame::read(&mut reader).await.unwrap();

        assert!(frame.fin);
        assert_eq!(frame.opcode, Opcode::Text);
        assert!(frame.mask.is_none());
        assert_eq!(frame.payload, b"Hello");
    }

    #[test]
    fn test_unmask() {
        let mask = [0x37, 0xfa, 0x21, 0x3d];
        let masked = vec![0x7f, 0x9f, 0x4d, 0x51, 0x58];

        let mut frame = WebSocketFrame {
            fin: true,
            opcode: Opcode::Text,
            mask: Some(mask),
            payload: masked,
        };

        frame.unmask();
        assert_eq!(frame.payload, b"Hello");
        assert!(frame.mask.is_none()); // mask consumed after unmask
    }

    #[test]
    fn test_unmask_longer_payload() {
        // "Hello World" with mask [0x12, 0x34, 0x56, 0x78]
        let mask = [0x12, 0x34, 0x56, 0x78];
        let original = b"Hello World";
        let mut masked = original.to_vec();
        for (i, byte) in masked.iter_mut().enumerate() {
            *byte ^= mask[i % 4];
        }

        let mut frame = WebSocketFrame {
            fin: true,
            opcode: Opcode::Text,
            mask: Some(mask),
            payload: masked,
        };

        frame.unmask();
        assert_eq!(frame.payload, original);
    }

    #[test]
    fn test_close_frame_with_code() {
        let frame = WebSocketFrame::close(Some(1000), "Normal closure");
        let bytes = frame.to_bytes();

        // FIN=1, opcode=8 (close) => 0x88
        assert_eq!(bytes[0], 0x88);
        // Length = 2 (code) + reason length
        assert_eq!(bytes[1] as usize, 2 + "Normal closure".len());
        // Status code 1000 in big-endian: 0x03E8
        assert_eq!(bytes[2], 0x03);
        assert_eq!(bytes[3], 0xE8);
        // Reason
        assert_eq!(&bytes[4..], b"Normal closure");
    }

    #[test]
    fn test_close_frame_no_code() {
        let frame = WebSocketFrame::close(None, "");
        let bytes = frame.to_bytes();

        assert_eq!(bytes[0], 0x88);
        assert_eq!(bytes[1], 0); // empty payload
        assert_eq!(bytes.len(), 2);
    }

    #[test]
    fn test_ping_pong() {
        let ping = WebSocketFrame::ping(b"heartbeat".to_vec());
        assert_eq!(ping.opcode, Opcode::Ping);
        assert!(ping.fin);
        assert_eq!(ping.payload, b"heartbeat");

        let pong = WebSocketFrame::pong(ping.payload.clone());
        assert_eq!(pong.opcode, Opcode::Pong);
        assert!(pong.fin);
        assert_eq!(pong.payload, b"heartbeat");

        // Verify serialization
        let ping_bytes = ping.to_bytes();
        assert_eq!(ping_bytes[0], 0x89); // FIN=1, opcode=9

        let pong_bytes = pong.to_bytes();
        assert_eq!(pong_bytes[0], 0x8A); // FIN=1, opcode=A
    }

    #[test]
    fn test_opcode_from_byte() {
        assert_eq!(Opcode::try_from(0x0).unwrap(), Opcode::Continuation);
        assert_eq!(Opcode::try_from(0x1).unwrap(), Opcode::Text);
        assert_eq!(Opcode::try_from(0x2).unwrap(), Opcode::Binary);
        assert_eq!(Opcode::try_from(0x8).unwrap(), Opcode::Close);
        assert_eq!(Opcode::try_from(0x9).unwrap(), Opcode::Ping);
        assert_eq!(Opcode::try_from(0xA).unwrap(), Opcode::Pong);

        // Reserved opcodes should fail
        assert!(Opcode::try_from(0x3).is_err());
        assert!(Opcode::try_from(0x4).is_err());
        assert!(Opcode::try_from(0x5).is_err());
        assert!(Opcode::try_from(0xB).is_err());
        assert!(Opcode::try_from(0xF).is_err());
    }

    #[test]
    fn test_websocket_message_from_frame() {
        // Text frame
        let mut text_frame = WebSocketFrame::text("Hello");
        let msg = WebSocketMessage::from_frame(&text_frame).unwrap();
        assert!(matches!(msg, WebSocketMessage::Text(s) if s == "Hello"));

        // Binary frame
        let bin_frame = WebSocketFrame::binary(vec![1, 2, 3]);
        let msg = WebSocketMessage::from_frame(&bin_frame).unwrap();
        assert!(matches!(msg, WebSocketMessage::Binary(v) if v == vec![1, 2, 3]));
    }
}
```

### 4.3 Solution de reference

```rust
use std::sync::Arc;
use tokio::io::{AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast;
use tokio_rustls::rustls::{self, pki_types::PrivateKeyDer};
use tokio_rustls::TlsAcceptor;
use sha1::{Sha1, Digest};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};

pub const WS_GUID: &str = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Opcode {
    Continuation = 0x0,
    Text = 0x1,
    Binary = 0x2,
    Close = 0x8,
    Ping = 0x9,
    Pong = 0xA,
}

impl TryFrom<u8> for Opcode {
    type Error = WebSocketError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x0 => Ok(Opcode::Continuation),
            0x1 => Ok(Opcode::Text),
            0x2 => Ok(Opcode::Binary),
            0x8 => Ok(Opcode::Close),
            0x9 => Ok(Opcode::Ping),
            0xA => Ok(Opcode::Pong),
            _ => Err(WebSocketError::InvalidOpcode(value)),
        }
    }
}

#[derive(Debug, Clone)]
pub struct WebSocketFrame {
    pub fin: bool,
    pub opcode: Opcode,
    pub mask: Option<[u8; 4]>,
    pub payload: Vec<u8>,
}

#[derive(Debug, Clone)]
pub enum WebSocketMessage {
    Text(String),
    Binary(Vec<u8>),
    Ping(Vec<u8>),
    Pong(Vec<u8>),
    Close(Option<(u16, String)>),
}

#[derive(Debug)]
pub enum WebSocketError {
    InvalidHandshake(String),
    InvalidFrame(String),
    InvalidOpcode(u8),
    InvalidUtf8,
    MaskRequired,
    ConnectionClosed,
    TlsError(String),
    IoError(std::io::Error),
}

impl From<std::io::Error> for WebSocketError {
    fn from(e: std::io::Error) -> Self {
        WebSocketError::IoError(e)
    }
}

pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

impl WebSocketFrame {
    pub fn text(data: &str) -> Self {
        WebSocketFrame {
            fin: true,
            opcode: Opcode::Text,
            mask: None,
            payload: data.as_bytes().to_vec(),
        }
    }

    pub fn binary(data: Vec<u8>) -> Self {
        WebSocketFrame {
            fin: true,
            opcode: Opcode::Binary,
            mask: None,
            payload: data,
        }
    }

    pub fn ping(data: Vec<u8>) -> Self {
        WebSocketFrame {
            fin: true,
            opcode: Opcode::Ping,
            mask: None,
            payload: data,
        }
    }

    pub fn pong(data: Vec<u8>) -> Self {
        WebSocketFrame {
            fin: true,
            opcode: Opcode::Pong,
            mask: None,
            payload: data,
        }
    }

    pub fn close(code: Option<u16>, reason: &str) -> Self {
        let mut payload = Vec::new();
        if let Some(code) = code {
            payload.extend_from_slice(&code.to_be_bytes());
            payload.extend_from_slice(reason.as_bytes());
        }
        WebSocketFrame {
            fin: true,
            opcode: Opcode::Close,
            mask: None,
            payload,
        }
    }

    pub async fn read<R: tokio::io::AsyncReadExt + Unpin>(
        reader: &mut R
    ) -> Result<Self, WebSocketError> {
        let mut header = [0u8; 2];
        reader.read_exact(&mut header).await?;

        let fin = (header[0] & 0x80) != 0;
        let opcode = Opcode::try_from(header[0] & 0x0F)?;
        let masked = (header[1] & 0x80) != 0;
        let mut payload_len = (header[1] & 0x7F) as u64;

        // Extended payload length
        if payload_len == 126 {
            let mut ext = [0u8; 2];
            reader.read_exact(&mut ext).await?;
            payload_len = u16::from_be_bytes(ext) as u64;
        } else if payload_len == 127 {
            let mut ext = [0u8; 8];
            reader.read_exact(&mut ext).await?;
            payload_len = u64::from_be_bytes(ext);
        }

        // Masking key
        let mask = if masked {
            let mut key = [0u8; 4];
            reader.read_exact(&mut key).await?;
            Some(key)
        } else {
            None
        };

        // Payload
        let mut payload = vec![0u8; payload_len as usize];
        reader.read_exact(&mut payload).await?;

        Ok(WebSocketFrame {
            fin,
            opcode,
            mask,
            payload,
        })
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();

        // First byte: FIN + opcode
        let first_byte = if self.fin { 0x80 } else { 0x00 } | (self.opcode as u8);
        bytes.push(first_byte);

        // Second byte: mask flag + length
        let len = self.payload.len();
        if len < 126 {
            bytes.push(len as u8);
        } else if len < 65536 {
            bytes.push(126);
            bytes.extend_from_slice(&(len as u16).to_be_bytes());
        } else {
            bytes.push(127);
            bytes.extend_from_slice(&(len as u64).to_be_bytes());
        }

        // Payload (no mask for server frames)
        bytes.extend_from_slice(&self.payload);

        bytes
    }

    pub fn unmask(&mut self) {
        if let Some(mask) = self.mask.take() {
            for (i, byte) in self.payload.iter_mut().enumerate() {
                *byte ^= mask[i % 4];
            }
        }
    }
}

pub fn compute_accept_key(key: &str) -> String {
    let mut hasher = Sha1::new();
    hasher.update(key.trim().as_bytes());
    hasher.update(WS_GUID.as_bytes());
    BASE64.encode(hasher.finalize())
}

pub fn parse_handshake(request: &str) -> Result<String, WebSocketError> {
    let lines: Vec<&str> = request.lines().collect();

    // Validate request line
    let first_line = lines.first()
        .ok_or_else(|| WebSocketError::InvalidHandshake("Empty request".to_string()))?;

    if !first_line.starts_with("GET ") {
        return Err(WebSocketError::InvalidHandshake("Must be GET request".to_string()));
    }

    // Parse headers
    let mut upgrade = None;
    let mut connection = None;
    let mut key = None;
    let mut version = None;

    for line in &lines[1..] {
        if line.is_empty() {
            break;
        }
        if let Some((name, value)) = line.split_once(':') {
            let name = name.trim().to_lowercase();
            let value = value.trim();

            match name.as_str() {
                "upgrade" => upgrade = Some(value.to_lowercase()),
                "connection" => connection = Some(value.to_lowercase()),
                "sec-websocket-key" => key = Some(value.to_string()),
                "sec-websocket-version" => version = Some(value.to_string()),
                _ => {}
            }
        }
    }

    // Validate required headers
    if upgrade.as_deref() != Some("websocket") {
        return Err(WebSocketError::InvalidHandshake("Missing Upgrade: websocket".to_string()));
    }

    if !connection.as_deref().map(|c| c.contains("upgrade")).unwrap_or(false) {
        return Err(WebSocketError::InvalidHandshake("Missing Connection: Upgrade".to_string()));
    }

    if version.as_deref() != Some("13") {
        return Err(WebSocketError::InvalidHandshake("Unsupported WebSocket version".to_string()));
    }

    key.ok_or_else(|| WebSocketError::InvalidHandshake("Missing Sec-WebSocket-Key".to_string()))
}

pub fn handshake_response(accept_key: &str) -> String {
    format!(
        "HTTP/1.1 101 Switching Protocols\r\n\
         Upgrade: websocket\r\n\
         Connection: Upgrade\r\n\
         Sec-WebSocket-Accept: {}\r\n\
         \r\n",
        accept_key
    )
}

pub async fn load_tls_config(config: &TlsConfig) -> Result<TlsAcceptor, WebSocketError> {
    use rustls_pemfile::{certs, private_key};
    use std::fs::File;
    use std::io::BufReader as StdBufReader;

    let cert_file = File::open(&config.cert_path)
        .map_err(|e| WebSocketError::TlsError(format!("Cannot open cert: {}", e)))?;
    let key_file = File::open(&config.key_path)
        .map_err(|e| WebSocketError::TlsError(format!("Cannot open key: {}", e)))?;

    let certs: Vec<_> = certs(&mut StdBufReader::new(cert_file))
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| WebSocketError::TlsError(format!("Cannot parse certs: {}", e)))?;

    let key = private_key(&mut StdBufReader::new(key_file))
        .map_err(|e| WebSocketError::TlsError(format!("Cannot parse key: {}", e)))?
        .ok_or_else(|| WebSocketError::TlsError("No private key found".to_string()))?;

    let config = rustls::ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .map_err(|e| WebSocketError::TlsError(format!("TLS config error: {}", e)))?;

    Ok(TlsAcceptor::from(Arc::new(config)))
}

pub struct SecureWebSocketServer {
    address: String,
    port: u16,
    tls_acceptor: TlsAcceptor,
    broadcast_tx: broadcast::Sender<WebSocketMessage>,
}

impl SecureWebSocketServer {
    pub async fn new(
        address: &str,
        port: u16,
        tls_config: TlsConfig,
    ) -> Result<Self, WebSocketError> {
        let tls_acceptor = load_tls_config(&tls_config).await?;
        let (broadcast_tx, _) = broadcast::channel(1024);

        Ok(Self {
            address: address.to_string(),
            port,
            tls_acceptor,
            broadcast_tx,
        })
    }

    pub async fn run(&self) -> Result<(), WebSocketError> {
        let addr = format!("{}:{}", self.address, self.port);
        let listener = TcpListener::bind(&addr).await?;

        loop {
            let (stream, _peer_addr) = listener.accept().await?;

            let tls_stream = match self.tls_acceptor.accept(stream).await {
                Ok(s) => s,
                Err(_) => continue,
            };

            let broadcast_tx = self.broadcast_tx.clone();
            tokio::spawn(async move {
                let _ = handle_websocket_connection(tls_stream, broadcast_tx).await;
            });
        }
    }

    pub fn client_count(&self) -> usize {
        self.broadcast_tx.receiver_count()
    }
}

async fn handle_websocket_connection<S>(
    mut stream: S,
    broadcast_tx: broadcast::Sender<WebSocketMessage>,
) -> Result<(), WebSocketError>
where
    S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin,
{
    // Read handshake request
    let mut request = String::new();
    let mut buf = [0u8; 1];
    loop {
        stream.read_exact(&mut buf).await?;
        request.push(buf[0] as char);
        if request.ends_with("\r\n\r\n") {
            break;
        }
        if request.len() > 4096 {
            return Err(WebSocketError::InvalidHandshake("Request too large".to_string()));
        }
    }

    // Parse and respond to handshake
    let key = parse_handshake(&request)?;
    let accept = compute_accept_key(&key);
    let response = handshake_response(&accept);
    stream.write_all(response.as_bytes()).await?;

    // Subscribe to broadcast
    let mut broadcast_rx = broadcast_tx.subscribe();

    // Split stream for concurrent read/write
    let (reader, mut writer) = tokio::io::split(stream);
    let mut reader = BufReader::new(reader);

    loop {
        tokio::select! {
            // Read frames from client
            frame_result = WebSocketFrame::read(&mut reader) => {
                let mut frame = frame_result?;

                // Client frames MUST be masked
                if frame.mask.is_none() {
                    return Err(WebSocketError::MaskRequired);
                }

                frame.unmask();

                match frame.opcode {
                    Opcode::Text => {
                        let text = String::from_utf8(frame.payload)
                            .map_err(|_| WebSocketError::InvalidUtf8)?;
                        let _ = broadcast_tx.send(WebSocketMessage::Text(text));
                    }
                    Opcode::Binary => {
                        let _ = broadcast_tx.send(WebSocketMessage::Binary(frame.payload));
                    }
                    Opcode::Ping => {
                        let pong = WebSocketFrame::pong(frame.payload);
                        writer.write_all(&pong.to_bytes()).await?;
                    }
                    Opcode::Pong => {
                        // Ignore unsolicited pongs
                    }
                    Opcode::Close => {
                        // Echo close frame
                        let close = WebSocketFrame::close(Some(1000), "");
                        writer.write_all(&close.to_bytes()).await?;
                        return Ok(());
                    }
                    Opcode::Continuation => {
                        // Fragmentation handling (simplified)
                    }
                }
            }

            // Write broadcast messages to client
            msg_result = broadcast_rx.recv() => {
                if let Ok(msg) = msg_result {
                    let frame = match msg {
                        WebSocketMessage::Text(s) => WebSocketFrame::text(&s),
                        WebSocketMessage::Binary(b) => WebSocketFrame::binary(b),
                        _ => continue,
                    };
                    writer.write_all(&frame.to_bytes()).await?;
                }
            }
        }
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de native-tls au lieu de rustls
use tokio_native_tls::TlsAcceptor;
use native_tls::{Identity, TlsAcceptor as NativeTlsAcceptor};

pub async fn load_tls_config_native(config: &TlsConfig) -> Result<TlsAcceptor, WebSocketError> {
    let cert = std::fs::read(&config.cert_path)?;
    let key = std::fs::read(&config.key_path)?;
    let identity = Identity::from_pkcs8(&cert, &key)
        .map_err(|e| WebSocketError::TlsError(e.to_string()))?;
    let acceptor = NativeTlsAcceptor::new(identity)
        .map_err(|e| WebSocketError::TlsError(e.to_string()))?;
    Ok(TlsAcceptor::from(acceptor))
}

// Alternative 2 : Handshake parsing avec regex
use regex::Regex;

pub fn parse_handshake_regex(request: &str) -> Result<String, WebSocketError> {
    let key_re = Regex::new(r"Sec-WebSocket-Key:\s*([A-Za-z0-9+/=]+)").unwrap();
    let cap = key_re.captures(request)
        .ok_or_else(|| WebSocketError::InvalidHandshake("No key".to_string()))?;
    Ok(cap[1].to_string())
}

// Alternative 3 : Frame reading avec bytes crate
use bytes::{Buf, BytesMut};

impl WebSocketFrame {
    pub fn read_from_buf(buf: &mut BytesMut) -> Option<Self> {
        if buf.len() < 2 {
            return None;
        }
        // ... parsing logic using Buf trait
    }
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Mauvais calcul de Sec-WebSocket-Accept
pub fn compute_accept_key_wrong(key: &str) -> String {
    let mut hasher = Sha1::new();
    hasher.update(key.as_bytes());  // MUTANT: pas de GUID!
    BASE64.encode(hasher.finalize())
}
// Pourquoi refusee : Le client rejettera le handshake

// REFUSEE 2 : Pas de demasquage
async fn handle_client_no_unmask<S>(stream: S) {
    loop {
        let frame = WebSocketFrame::read(&mut reader).await?;
        // MUTANT: frame.unmask() oublie!
        let text = String::from_utf8(frame.payload)?;  // Donnees corrompues!
    }
}
// Pourquoi refusee : Payload illisible (XOR avec mask)

// REFUSEE 3 : Frames serveur masquees
impl WebSocketFrame {
    pub fn to_bytes_masked(&self) -> Vec<u8> {
        let mask = rand::random::<[u8; 4]>();
        // MUTANT: serveur envoie frames masquees
        bytes.push(0x80 | len);  // MASK=1
        bytes.extend_from_slice(&mask);
        // ...
    }
}
// Pourquoi refusee : RFC interdit le masking serveur->client

// REFUSEE 4 : Ignorer les Ping
Opcode::Ping => {
    // MUTANT: pas de Pong!
    continue;
}
// Pourquoi refusee : Client timeout apres heartbeat manque
```

### 4.6 Solution bonus de reference

```rust
use std::collections::{HashMap, HashSet};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use tokio::sync::{broadcast, watch, RwLock};
use tokio::time::{interval, timeout};

pub type ClientId = usize;

pub struct ServerConfig {
    pub address: String,
    pub port: u16,
    pub tls_config: TlsConfig,
    pub max_connections: usize,
    pub heartbeat_interval: Duration,
    pub heartbeat_timeout: Duration,
    pub rate_limit: RateLimit,
}

pub struct RateLimit {
    pub max_messages: usize,
    pub window: Duration,
}

pub struct Room {
    pub name: String,
    pub clients: HashSet<ClientId>,
    pub broadcast_tx: broadcast::Sender<WebSocketMessage>,
}

pub struct ClientState {
    pub id: ClientId,
    pub rooms: HashSet<String>,
    pub message_count: AtomicUsize,
    pub last_pong: std::time::Instant,
}

pub struct ProductionWebSocketServer {
    config: ServerConfig,
    rooms: Arc<RwLock<HashMap<String, Room>>>,
    clients: Arc<RwLock<HashMap<ClientId, ClientState>>>,
    next_client_id: AtomicUsize,
    shutdown_tx: watch::Sender<bool>,
    shutdown_rx: watch::Receiver<bool>,
}

impl ProductionWebSocketServer {
    pub async fn new(config: ServerConfig) -> Result<Self, WebSocketError> {
        let (shutdown_tx, shutdown_rx) = watch::channel(false);

        Ok(Self {
            config,
            rooms: Arc::new(RwLock::new(HashMap::new())),
            clients: Arc::new(RwLock::new(HashMap::new())),
            next_client_id: AtomicUsize::new(1),
            shutdown_tx,
            shutdown_rx,
        })
    }

    pub async fn run(&self) -> Result<(), WebSocketError> {
        let tls_acceptor = load_tls_config(&self.config.tls_config).await?;
        let addr = format!("{}:{}", self.config.address, self.config.port);
        let listener = TcpListener::bind(&addr).await?;

        let mut shutdown = self.shutdown_rx.clone();

        loop {
            tokio::select! {
                accept_result = listener.accept() => {
                    let (stream, _) = accept_result?;

                    // Check connection limit
                    if self.client_count().await >= self.config.max_connections {
                        continue;
                    }

                    let tls_stream = match tls_acceptor.accept(stream).await {
                        Ok(s) => s,
                        Err(_) => continue,
                    };

                    let client_id = self.next_client_id.fetch_add(1, Ordering::SeqCst);
                    let clients = Arc::clone(&self.clients);
                    let rooms = Arc::clone(&self.rooms);
                    let config = self.config.clone();
                    let shutdown_rx = self.shutdown_rx.clone();

                    tokio::spawn(async move {
                        let _ = handle_production_connection(
                            tls_stream,
                            client_id,
                            clients,
                            rooms,
                            config,
                            shutdown_rx,
                        ).await;
                    });
                }

                _ = shutdown.changed() => {
                    if *shutdown.borrow() {
                        break;
                    }
                }
            }
        }

        Ok(())
    }

    pub async fn shutdown(&self, timeout_dur: Duration) -> Result<(), WebSocketError> {
        let _ = self.shutdown_tx.send(true);

        // Wait for all clients to disconnect or timeout
        let _ = timeout(timeout_dur, async {
            while self.client_count().await > 0 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }).await;

        Ok(())
    }

    pub async fn join_room(&self, client_id: ClientId, room_name: &str) {
        let mut rooms = self.rooms.write().await;
        let room = rooms.entry(room_name.to_string()).or_insert_with(|| {
            let (tx, _) = broadcast::channel(1024);
            Room {
                name: room_name.to_string(),
                clients: HashSet::new(),
                broadcast_tx: tx,
            }
        });
        room.clients.insert(client_id);

        if let Some(client) = self.clients.write().await.get_mut(&client_id) {
            client.rooms.insert(room_name.to_string());
        }
    }

    pub async fn leave_room(&self, client_id: ClientId, room_name: &str) {
        let mut rooms = self.rooms.write().await;
        if let Some(room) = rooms.get_mut(room_name) {
            room.clients.remove(&client_id);
            if room.clients.is_empty() {
                rooms.remove(room_name);
            }
        }
    }

    pub async fn room_count(&self) -> usize {
        self.rooms.read().await.len()
    }

    pub async fn client_count(&self) -> usize {
        self.clients.read().await.len()
    }
}

async fn handle_production_connection<S>(
    stream: S,
    client_id: ClientId,
    clients: Arc<RwLock<HashMap<ClientId, ClientState>>>,
    rooms: Arc<RwLock<HashMap<String, Room>>>,
    config: ServerConfig,
    mut shutdown_rx: watch::Receiver<bool>,
) -> Result<(), WebSocketError>
where
    S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin,
{
    // ... handshake ...

    // Register client
    {
        let mut clients_lock = clients.write().await;
        clients_lock.insert(client_id, ClientState {
            id: client_id,
            rooms: HashSet::new(),
            message_count: AtomicUsize::new(0),
            last_pong: std::time::Instant::now(),
        });
    }

    let (reader, mut writer) = tokio::io::split(stream);
    let mut reader = BufReader::new(reader);
    let mut heartbeat = interval(config.heartbeat_interval);

    loop {
        tokio::select! {
            // Heartbeat ping
            _ = heartbeat.tick() => {
                let ping = WebSocketFrame::ping(b"ping".to_vec());
                writer.write_all(&ping.to_bytes()).await?;

                // Check for stale connection
                let clients_lock = clients.read().await;
                if let Some(client) = clients_lock.get(&client_id) {
                    if client.last_pong.elapsed() > config.heartbeat_timeout {
                        break; // Client timed out
                    }
                }
            }

            // Read frames
            frame_result = WebSocketFrame::read(&mut reader) => {
                let mut frame = frame_result?;
                frame.unmask();

                // Rate limiting
                {
                    let clients_lock = clients.read().await;
                    if let Some(client) = clients_lock.get(&client_id) {
                        let count = client.message_count.fetch_add(1, Ordering::SeqCst);
                        if count >= config.rate_limit.max_messages {
                            // Rate limited
                            continue;
                        }
                    }
                }

                match frame.opcode {
                    Opcode::Pong => {
                        let mut clients_lock = clients.write().await;
                        if let Some(client) = clients_lock.get_mut(&client_id) {
                            client.last_pong = std::time::Instant::now();
                        }
                    }
                    // ... other opcodes ...
                    _ => {}
                }
            }

            // Shutdown signal
            _ = shutdown_rx.changed() => {
                if *shutdown_rx.borrow() {
                    let close = WebSocketFrame::close(Some(1001), "Server shutdown");
                    let _ = writer.write_all(&close.to_bytes()).await;
                    break;
                }
            }
        }
    }

    // Cleanup
    clients.write().await.remove(&client_id);

    Ok(())
}
```

### 4.9 spec.json

```json
{
  "name": "websocket_tls",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Multi-concepts - WebSocket + TLS",
  "tags": ["networking", "websocket", "tls", "async", "crypto", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "SecureWebSocketServer",
    "prototype": "impl SecureWebSocketServer",
    "return_type": "struct",
    "parameters": [
      {"name": "address", "type": "&str"},
      {"name": "port", "type": "u16"},
      {"name": "tls_config", "type": "TlsConfig"}
    ]
  },

  "dependencies": {
    "tokio": { "version": "1", "features": ["full"] },
    "tokio-rustls": "0.25",
    "rustls": "0.22",
    "rustls-pemfile": "2",
    "sha1": "0.10",
    "base64": "0.21"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "rfc_accept_key",
        "input": "dGhlIHNhbXBsZSBub25jZQ==",
        "expected": "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=",
        "is_trap": false
      },
      {
        "name": "handshake_missing_upgrade",
        "input": "GET / HTTP/1.1\\r\\nConnection: Upgrade\\r\\n\\r\\n",
        "expected": "InvalidHandshake",
        "is_trap": true,
        "trap_explanation": "Upgrade: websocket header requis"
      },
      {
        "name": "frame_mask_required",
        "input": "unmasked_client_frame",
        "expected": "MaskRequired",
        "is_trap": true,
        "trap_explanation": "RFC 6455: client MUST mask"
      },
      {
        "name": "large_payload_64bit",
        "input": "70000_byte_payload",
        "expected": "127_length_indicator",
        "is_trap": true,
        "trap_explanation": "Payloads >65535 utilisent longueur 64-bit"
      },
      {
        "name": "ping_must_pong",
        "input": "Frame Ping 'heartbeat'",
        "expected": "Frame Pong 'heartbeat'",
        "is_trap": true,
        "trap_explanation": "Ping sans Pong = timeout client"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 50,
      "generators": [
        {
          "type": "websocket_frame",
          "params": {
            "opcodes": [1, 2, 8, 9, 10],
            "payload_sizes": [0, 1, 125, 126, 200, 65535, 70000],
            "masked": [true, false]
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["tokio", "tokio-rustls", "rustls", "sha1", "base64"],
    "forbidden_crates": ["tungstenite", "tokio-tungstenite", "ws"],
    "check_security": true,
    "blocking": false
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Handshake) : Mauvais calcul Sec-WebSocket-Accept */
pub fn compute_accept_key_mutant(key: &str) -> String {
    let mut hasher = Sha1::new();
    hasher.update(key.as_bytes());
    // MUTANT: GUID manquant!
    BASE64.encode(hasher.finalize())
}
// Pourquoi c'est faux : Accept = SHA1(Key + GUID), pas juste SHA1(Key)
// Ce qui etait pense : "Le GUID est optionnel"
// Symptome : Client rejette handshake avec "Invalid Sec-WebSocket-Accept"

/* Mutant B (Framing) : Oubli du bit FIN */
impl WebSocketFrame {
    pub fn text_mutant(data: &str) -> Self {
        WebSocketFrame {
            fin: false,  // MUTANT: devrait etre true!
            opcode: Opcode::Text,
            mask: None,
            payload: data.as_bytes().to_vec(),
        }
    }
}
// Pourquoi c'est faux : Client attend des frames de continuation qui n'arrivent jamais
// Ce qui etait pense : "FIN n'est pas important pour les messages simples"
// Symptome : Client bloque en attente de la fin du message

/* Mutant C (Masking) : Pas de demasquage */
async fn handle_client_mutant<S>(stream: S) {
    loop {
        let frame = WebSocketFrame::read(&mut reader).await?;
        // MUTANT: frame.unmask() manquant!
        let text = String::from_utf8(frame.payload)?;  // Payload XORe!
    }
}
// Pourquoi c'est faux : payload[i] ^= mask[i % 4] doit etre inverse
// Ce qui etait pense : "Le masking est gere par TLS"
// Symptome : Tous les messages sont du charabia

/* Mutant D (Control) : Ping sans Pong */
match frame.opcode {
    Opcode::Ping => {
        // MUTANT: pas de reponse Pong!
        println!("Received ping, ignoring...");
    }
    // ...
}
// Pourquoi c'est faux : RFC 6455 Section 5.5.2 requiert Pong
// Ce qui etait pense : "Ping est juste informatif"
// Symptome : Client timeout apres heartbeat_timeout

/* Mutant E (TLS) : Certificat/cle inverses */
pub async fn load_tls_config_mutant(config: &TlsConfig) -> Result<TlsAcceptor, WebSocketError> {
    let cert_file = File::open(&config.key_path)?;  // MUTANT: key au lieu de cert!
    let key_file = File::open(&config.cert_path)?;  // MUTANT: cert au lieu de key!
    // ...
}
// Pourquoi c'est faux : Le certificat n'est pas une cle et vice-versa
// Ce qui etait pense : "L'ordre des fichiers n'importe pas"
// Symptome : TLS handshake echoue avec "invalid certificate"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Protocole WebSocket RFC 6455** : Handshake, framing, opcodes
2. **Cryptographie pratique** : SHA-1, Base64, TLS/rustls
3. **Async Rust avance** : tokio, select!, broadcast channels
4. **Binary protocol parsing** : Big-endian, bit manipulation, XOR
5. **Security mindset** : Masking contre cache poisoning, TLS obligatoire

### 5.2 LDA -- Traduction Litterale

```
FONCTION handle_websocket_connection(stream, broadcast)
DEBUT
    // Phase 1: Handshake HTTP -> WebSocket
    LIRE requete HTTP depuis stream
    EXTRAIRE sec_websocket_key depuis requete

    SI requete invalide OU version != 13 ALORS
        RETOURNER Erreur(InvalidHandshake)
    FIN SI

    CALCULER accept_key = Base64(SHA1(key + GUID))
    ENVOYER reponse HTTP 101 avec accept_key

    // Phase 2: Boucle de messages
    S'ABONNER au canal broadcast

    BOUCLE
        ATTENDRE (frame client OU message broadcast OU shutdown)

        SI frame client ALORS
            SI frame non masquee ALORS
                RETOURNER Erreur(MaskRequired)
            FIN SI

            DEMASQUER frame (XOR avec mask key)

            SELON frame.opcode
                Text -> DIFFUSER message texte
                Binary -> DIFFUSER message binaire
                Ping -> ENVOYER Pong avec meme payload
                Pong -> IGNORER
                Close -> ENVOYER Close, TERMINER
            FIN SELON
        FIN SI

        SI message broadcast ALORS
            SERIALISER en frame WebSocket
            ENVOYER au client
        FIN SI
    FIN BOUCLE
FIN
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : WebSocket Server avec TLS
---
ENTREE : address, port, tls_config
SORTIE : serveur WebSocket securise

1. CHARGER certificats TLS depuis fichiers PEM
2. CREER TlsAcceptor avec configuration rustls
3. BIND sur (address:port)
4. CREER broadcast channel pour messages

5. BOUCLE PRINCIPALE :
   a. ACCEPT connexion TCP
   b. TLS HANDSHAKE via TlsAcceptor
   c. SPAWN tache async pour client :
      i.   LIRE requete HTTP upgrade
      ii.  VALIDER headers WebSocket
      iii. CALCULER Sec-WebSocket-Accept
      iv.  ENVOYER HTTP 101
      v.   BOUCLE MESSAGES :
           - LIRE frame, DEMASQUER
           - TRAITER selon opcode
           - DIFFUSER ou REPONDRE
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Parse WebSocket Frame
---
1. LIRE 2 bytes header

2. EXTRAIRE :
   - FIN = bit 0 du byte 0
   - opcode = bits 4-7 du byte 0
   - MASK = bit 0 du byte 1
   - length = bits 1-7 du byte 1

3. SI length == 126 ALORS
      LIRE 2 bytes supplementaires (big-endian u16)
   SINON SI length == 127 ALORS
      LIRE 8 bytes supplementaires (big-endian u64)
   FIN SI

4. SI MASK == 1 ALORS
      LIRE 4 bytes masking key

5. LIRE payload de taille length

6. RETOURNER WebSocketFrame { fin, opcode, mask, payload }
```

### 5.3 Visualisation ASCII

```
              ARCHITECTURE WEBSOCKET TLS SERVER

    ┌───────────────────────────────────────────────────────┐
    │                    CLIENTS                            │
    │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  │
    │  │ Browser │  │ Mobile  │  │   CLI   │  │   IoT   │  │
    │  │   wss   │  │   wss   │  │ websocat│  │ Device  │  │
    │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘  │
    └───────┼────────────┼────────────┼────────────┼────────┘
            │            │            │            │
            └────────────┴─────┬──────┴────────────┘
                               │
                    ┌──────────▼──────────┐
                    │   TLS TERMINATION   │
                    │   (tokio-rustls)    │
                    │  ┌───────────────┐  │
                    │  │ TlsAcceptor   │  │
                    │  │ cert.pem      │  │
                    │  │ key.pem       │  │
                    │  └───────────────┘  │
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │  WEBSOCKET LAYER    │
                    │                     │
                    │  HTTP Upgrade ─────►│── 101 Switching
                    │                     │
                    │  Frame Parser       │
                    │  ┌───────────────┐  │
                    │  │ FIN│OP │M│LEN│  │
                    │  │ MASK KEY      │  │
                    │  │ PAYLOAD       │  │
                    │  └───────────────┘  │
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │  BROADCAST CHANNEL  │
                    │                     │
                    │  ┌───┐ ┌───┐ ┌───┐  │
                    │  │Tx │►│Rx1│ │Rx2│  │
                    │  └───┘ └───┘ └───┘  │
                    │         │     │     │
                    │         ▼     ▼     │
                    │     Client1 Client2 │
                    └─────────────────────┘


            WEBSOCKET FRAME FORMAT (RFC 6455)

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-------+-+-------------+-------------------------------+
    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
    |N|V|V|V|       |S|             |   (if payload len==126/127)   |
    | |1|2|3|       |K|             |                               |
    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
    |     Extended payload length continued, if payload len == 127  |
    + - - - - - - - - - - - - - - - +-------------------------------+
    |                               |Masking-key, if MASK set to 1  |
    +-------------------------------+-------------------------------+
    | Masking-key (continued)       |          Payload Data         |
    +-------------------------------- - - - - - - - - - - - - - - - +
    :                     Payload Data continued ...                :
    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    |                     Payload Data continued ...                |
    +---------------------------------------------------------------+


            OPCODES WebSocket

    ┌────────┬──────┬────────────────────────────────────┐
    │ Opcode │ Hex  │ Description                        │
    ├────────┼──────┼────────────────────────────────────┤
    │ 0x0    │ 0x0  │ Continuation frame                 │
    │ 0x1    │ 0x1  │ Text frame (UTF-8)                 │
    │ 0x2    │ 0x2  │ Binary frame                       │
    │ 0x3-7  │  -   │ Reserved (non-control)             │
    │ 0x8    │ 0x8  │ Connection Close                   │
    │ 0x9    │ 0x9  │ Ping                               │
    │ 0xA    │ 0xA  │ Pong                               │
    │ 0xB-F  │  -   │ Reserved (control)                 │
    └────────┴──────┴────────────────────────────────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **GUID manquant** | Accept = SHA1(Key) au lieu de SHA1(Key+GUID) | Toujours concatener le GUID RFC |
| **FIN=0 par defaut** | Client attend continuation | FIN=1 pour messages complets |
| **Oubli unmask** | Payload XORe illisible | Toujours demasquer frames client |
| **Ping sans Pong** | Client timeout | Repondre Pong avec meme payload |
| **Server mask** | RFC violation | Jamais masquer frames serveur |
| **Length encoding** | >125 bytes mal encode | 126->16bit, 127->64bit |

### 5.5 Cours Complet

#### 5.5.1 Le protocole WebSocket

WebSocket fournit une communication **bidirectionnelle full-duplex** sur une seule connexion TCP. Contrairement a HTTP request/response, les deux parties peuvent envoyer des messages a tout moment.

```
HTTP classique:
  Client ──request──► Server
  Client ◄─response── Server
  Client ──request──► Server
  Client ◄─response── Server

WebSocket:
  Client ──────────── Server
         ◄──────────►
    Messages dans les deux sens a tout moment
```

#### 5.5.2 Le Handshake (RFC 6455 Section 1.3)

L'upgrade se fait via HTTP :

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

Le serveur repond :

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

Le calcul de `Sec-WebSocket-Accept` :
```rust
// GUID magique de la RFC 6455
const GUID: &str = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

fn compute_accept(key: &str) -> String {
    let concat = format!("{}{}", key.trim(), GUID);
    let hash = sha1::Sha1::digest(concat.as_bytes());
    base64::encode(hash)
}
```

#### 5.5.3 Format des Frames

```rust
// Premier byte
let fin = (byte0 & 0x80) != 0;      // bit 0
let rsv1 = (byte0 & 0x40) != 0;     // bit 1 (reserved)
let rsv2 = (byte0 & 0x20) != 0;     // bit 2 (reserved)
let rsv3 = (byte0 & 0x10) != 0;     // bit 3 (reserved)
let opcode = byte0 & 0x0F;          // bits 4-7

// Deuxieme byte
let mask = (byte1 & 0x80) != 0;     // bit 0
let length = byte1 & 0x7F;          // bits 1-7

// Longueur etendue
if length == 126 {
    // Les 2 bytes suivants sont la longueur (u16 big-endian)
} else if length == 127 {
    // Les 8 bytes suivants sont la longueur (u64 big-endian)
}
```

#### 5.5.4 Masking (RFC 6455 Section 5.3)

Le client DOIT masquer, le serveur NE DOIT PAS masquer.

```rust
fn unmask(payload: &mut [u8], mask: [u8; 4]) {
    for (i, byte) in payload.iter_mut().enumerate() {
        *byte ^= mask[i % 4];
    }
}

// XOR est sa propre inverse : unmask == mask
// a ^ b ^ b == a
```

#### 5.5.5 TLS avec rustls

```rust
use tokio_rustls::rustls::{ServerConfig, pki_types::CertificateDer};

// Charger certificat PEM
let cert_file = File::open("cert.pem")?;
let certs: Vec<CertificateDer> = rustls_pemfile::certs(&mut BufReader::new(cert_file))
    .collect::<Result<Vec<_>, _>>()?;

// Charger cle privee
let key_file = File::open("key.pem")?;
let key = rustls_pemfile::private_key(&mut BufReader::new(key_file))?
    .expect("no private key");

// Configurer TLS
let config = ServerConfig::builder()
    .with_no_client_auth()
    .with_single_cert(certs, key)?;

let acceptor = TlsAcceptor::from(Arc::new(config));
```

### 5.6 Normes avec explications pedagogiques

```
┌─────────────────────────────────────────────────────────────────┐
│ HORS NORME                                                      │
├─────────────────────────────────────────────────────────────────┤
│ // Masquer les frames serveur                                   │
│ impl WebSocketFrame {                                           │
│     fn to_bytes(&self) -> Vec<u8> {                            │
│         let mask = rand::random::<[u8; 4]>();                  │
│         bytes.push(0x80 | len); // MASK=1                      │
│         ...                                                     │
│     }                                                           │
│ }                                                               │
├─────────────────────────────────────────────────────────────────┤
│ CONFORME (pas de masking serveur)                               │
├─────────────────────────────────────────────────────────────────┤
│ impl WebSocketFrame {                                           │
│     fn to_bytes(&self) -> Vec<u8> {                            │
│         bytes.push(len as u8); // MASK=0                       │
│         bytes.extend_from_slice(&self.payload);                │
│         ...                                                     │
│     }                                                           │
│ }                                                               │
├─────────────────────────────────────────────────────────────────┤
│ POURQUOI ?                                                      │
│ - RFC 6455 Section 5.1 : "server MUST NOT mask"                │
│ - Le masking protege contre cache poisoning des proxies        │
│ - Cote serveur, pas de proxy a tromper                         │
└─────────────────────────────────────────────────────────────────┘
```

### 5.7 Simulation avec trace d'execution

**Scenario :** Client envoie "Hello" puis recoit un broadcast

```
┌───────┬─────────────────────────────────────┬────────────────────┬────────────────────┐
│ Etape │ Action                              │ Client             │ Serveur            │
├───────┼─────────────────────────────────────┼────────────────────┼────────────────────┤
│   1   │ TCP connect                         │ connect()          │ accept()           │
│   2   │ TLS handshake                       │ ClientHello        │ ServerHello        │
│   3   │ HTTP Upgrade request                │ GET /chat...       │                    │
│   4   │ Server valide headers               │                    │ parse_handshake()  │
│   5   │ Server calcule accept               │                    │ compute_accept()   │
│   6   │ HTTP 101 response                   │                    │ 101 Switching...   │
│   7   │ Client envoie Text "Hello"          │ [81 85 xx xx ...]  │                    │
│   8   │ Server parse frame                  │                    │ read_frame()       │
│   9   │ Server demasque                     │                    │ frame.unmask()     │
│  10   │ Server broadcast                    │                    │ broadcast_tx.send()│
│  11   │ Server envoie a tous                │ [81 05 48 65 ...]  │ frame.to_bytes()   │
│  12   │ Client recoit "Hello"               │ "Hello"            │                    │
└───────┴─────────────────────────────────────┴────────────────────┴────────────────────┘
```

### 5.8 Mnémotechniques

#### MEME : "Can you hear me?" (Person of Interest)

*Dans Person of Interest, The Machine communique via des canaux secrets et persistants. WebSocket, c'est ce canal : toujours ouvert, bidirectionnel, securise.*

```rust
// The Machine speaks...
broadcast_tx.send(WebSocketMessage::Text("Can you hear me?".to_string()));

// ...and listens
match frame.opcode {
    Opcode::Text => { /* "Yes, I can hear you." */ }
}
```

#### "FUMBLE" = Frame, Unmask, Message, Broadcast, Listen, Echo

Les etapes de traitement d'un message WebSocket :
1. **F**rame parsing (lire header + payload)
2. **U**nmask (XOR avec masking key)
3. **M**essage extraction (Text/Binary/Control)
4. **B**roadcast (diffuser aux autres)
5. **L**isten (attendre reponses)
6. **E**cho (renvoyer si necessaire)

#### "SHA-BASE-GUID" = le trio du handshake

```
Accept = SHA1 + BASE64 + GUID
       = Base64(SHA1(Key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))
```

### 5.9 Applications pratiques

1. **Slack/Discord** : Chat temps reel avec WebSocket
2. **Figma** : Collaboration avec curseurs multi-utilisateurs
3. **Binance/Coinbase** : Market data streams (100K+ msg/sec)
4. **Grafana** : Dashboards temps reel
5. **VS Code Remote** : Terminal over WebSocket
6. **Multiplayer Games** : State synchronization

---

## SECTION 6 : PIEGES -- RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | GUID manquant | Handshake rejete | `SHA1(Key + GUID)` |
| 2 | FIN=0 permanent | Client bloque | `FIN=true` pour msg complets |
| 3 | Pas de unmask | Payload illisible | `payload[i] ^= mask[i%4]` |
| 4 | Ping sans Pong | Client timeout | Repondre Pong immediatement |
| 5 | Server masque | RFC violation | Jamais masquer serveur->client |
| 6 | Mauvais length | Frame corrompue | 126->u16, 127->u64 big-endian |

---

## SECTION 7 : QCM

### Question 1
**Quel est le GUID magique utilise pour calculer Sec-WebSocket-Accept ?**

A) "WEBSOCKET-GUID-2011-RFC-6455"
B) "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
C) "RFC6455-WEBSOCKET-ACCEPT-KEY"
D) "WS-UPGRADE-PROTOCOL-v13"
E) Le GUID est genere aleatoirement
F) Il n'y a pas de GUID, c'est juste SHA1(Key)
G) "00000000-0000-0000-0000-000000000000"
H) Base64 du timestamp
I) MD5 de "websocket"
J) Le client envoie son propre GUID

**Reponse : B**

*Explication : Le GUID "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" est defini dans RFC 6455 Section 1.3. Il est concatene avec Sec-WebSocket-Key avant le hash SHA-1.*

---

### Question 2
**Pourquoi le masking client->serveur est-il obligatoire ?**

A) Pour chiffrer les donnees
B) Pour compresser les donnees
C) Pour proteger contre le cache poisoning des proxies HTTP
D) Pour authentifier le client
E) Pour verifier l'integrite des donnees
F) C'est optionnel en realite
G) Pour le rate limiting
H) Pour la fragmentation
I) Pour TLS
J) Pour le debugging

**Reponse : C**

*Explication : Le masking n'est PAS pour la securite (TLS s'en charge). Il empeche un attaquant de creer des frames qui ressemblent a du HTTP valide et pourraient etre cachees par un proxy intermediaire mal configure.*

---

### Question 3
**Quelle valeur de length indique qu'une longueur 64-bit suit ?**

A) 0
B) 125
C) 126
D) 127
E) 128
F) 255
G) 65535
H) -1
I) 0xFF
J) Toute valeur > 125

**Reponse : D**

*Explication : Length 126 = 16-bit extended length suit. Length 127 = 64-bit extended length suit. 0-125 = longueur reelle.*

---

### Question 4
**Que doit faire le serveur quand il recoit une frame Ping ?**

A) Ignorer
B) Fermer la connexion
C) Renvoyer Ping
D) Renvoyer Pong avec le meme payload
E) Renvoyer Pong sans payload
F) Incrementer un compteur
G) Logger et continuer
H) Renvoyer Close
I) Attendre un timeout
J) Renvoyer Text "pong"

**Reponse : D**

*Explication : RFC 6455 Section 5.5.3 specifie qu'un Pong DOIT etre envoye en reponse a un Ping, avec le meme Application Data (payload).*

---

### Question 5
**Quelle est l'opcode de la frame Close ?**

A) 0x0
B) 0x1
C) 0x2
D) 0x7
E) 0x8
F) 0x9
G) 0xA
H) 0xF
I) 0xFF
J) -1

**Reponse : E**

*Explication : Les opcodes sont : 0x0=Continuation, 0x1=Text, 0x2=Binary, 0x8=Close, 0x9=Ping, 0xA=Pong. 0x3-0x7 et 0xB-0xF sont reserves.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | websocket_tls |
| **Module** | 5.1.5 — WebSocket Protocol & TLS |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 250 (base) + bonus x4 |
| **Concepts cles** | WebSocket RFC 6455, framing, masking, TLS/rustls |
| **Piege principal** | GUID manquant dans accept key / oubli unmask |
| **Prerequis valide** | TCP, HTTP, async Rust, encoding |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.5-a-websocket-tls",
    "generated_at": "2024-01-15T14:00:00Z",

    "metadata": {
      "exercise_id": "5.1.5-a",
      "exercise_name": "websocket_tls",
      "module": "5.1.5",
      "module_name": "WebSocket Protocol & TLS Security",
      "concept": "a",
      "concept_name": "Secure WebSocket Server",
      "type": "code",
      "tier": 2,
      "tier_info": "Multi-concepts",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "********",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 250,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "bonus_icon": "flame",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["5.1.2", "5.1.3", "2.6", "2.4"],
      "domains": ["Net", "Crypto", "Async"],
      "domains_bonus": ["Crypto", "Async", "Algo"],
      "tags": ["networking", "websocket", "tls", "async", "rfc6455", "phase5"],
      "meme_reference": "Can you hear me? (Person of Interest)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_handshake.rs": "/* Section 4.10 */",
      "mutants/mutant_b_framing.rs": "/* Section 4.10 */",
      "mutants/mutant_c_masking.rs": "/* Section 4.10 */",
      "mutants/mutant_d_control.rs": "/* Section 4.10 */",
      "mutants/mutant_e_tls.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_handshake.rs",
        "mutants/mutant_b_framing.rs",
        "mutants/mutant_c_masking.rs",
        "mutants/mutant_d_control.rs",
        "mutants/mutant_e_tls.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "Can you hear me?"*
*Exercise Quality Score: 98/100*
