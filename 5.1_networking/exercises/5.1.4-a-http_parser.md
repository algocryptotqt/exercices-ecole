<thinking>
## Analyse du Concept
- Concept : HTTP/1.1 Parser and Server
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - HTTP/1.1 est le protocole fondamental du web. L'exercice couvre parsing, serialisation, et connexions persistantes.

## Combo Base + Bonus
- Exercice de base : Parser HTTP/1.1 complet avec support GET/POST/PUT/DELETE/HEAD, Content-Length, et connexions keep-alive
- Bonus : Implementation du Transfer-Encoding: chunked (lecture et ecriture) + serveur de fichiers statiques avec MIME types
- Palier bonus : Avance (parsing binaire complexe + etat de connexion)
- Progression logique ? OUI - Base = parsing textuel + serialisation, Bonus = encoding chunk + serveur

## Prerequis & Difficulte
- Prerequis reels : tokio (async I/O), HashMap, String/bytes manipulation, TCP (5.1.2)
- Difficulte estimee : 8/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Matrix" - Le protocole HTTP comme le code de la Matrice
- MEME mnemonique : "There is no spoon" (le parsing decode les "cuilleres" cachees dans le flux)
- Pourquoi c'est fun : Chaque requete HTTP est comme une pilule rouge revelant la vraie nature de la communication web

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Parsing) : Pas de gestion CRLF → header parsing echoue sur \r\n
2. Mutant B (Protocol) : Oubli du header Host obligatoire en HTTP/1.1
3. Mutant C (Body) : Content-Length mal parse → body tronque ou overflow
4. Mutant D (Chunked) : Mauvaise lecture des chunks hex → corruption du body
5. Mutant E (Keep-Alive) : Ignore Connection header → connexions jamais fermees

## Verdict
VALIDE - Exercice pratique couvrant le protocole HTTP/1.1 en profondeur
</thinking>

# Exercice 5.1.4-a : http_parser

**Module :**
5.1.4 — Application Layer Protocols (HTTP)

**Concept :**
a — HTTP/1.1 Request/Response Parser & Server

**Difficulte :**
++++++++-- (8/10)

**Type :**
code

**Tiers :**
2 — Concept composite (parsing + serialisation + state)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types et ownership
- 2.4 — I/O et buffers
- 5.1.2 — TCP Fundamentals
- Module 2.7 — Async/Await (tokio)

**Domaines :**
Net, Parsing, Algo

**Duree estimee :**
180 min

**XP Base :**
225

**Complexite :**
T2 O(n) x S2 O(n) ou n = taille de la requete/reponse

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
src/lib.rs
src/main.rs
Cargo.toml
```

**Dependances autorisees :**
- `tokio` (avec features: `net`, `io-util`, `rt-multi-thread`, `macros`)
- `std::collections::HashMap`
- `serde` + `serde_json` (pour la methode `.json()`)

**Fonctions/methodes interdites :**
- Crates HTTP existantes (hyper, reqwest, actix-web, etc.)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Protocol Matrix"**

*"Tu vois ce flux d'octets ? Certains y voient des caracteres. Moi, je vois GET, POST, headers, status codes... Le protocole HTTP est partout. Il nous entoure. Il est la quand tu regardes par la fenetre de ton navigateur."* — Morpheus, architecte de protocoles

Le protocole HTTP/1.1 (RFC 2616/7230) est le fondement du World Wide Web. Derriere chaque page web, chaque API REST, chaque telechargement, il y a une requete et une reponse HTTP.

**Ta mission :**

Implementer un parser HTTP/1.1 et un serveur web minimal capable de :

1. **Parser les requetes HTTP/1.1** (request-line, headers, body)
2. **Supporter les methodes** GET, POST, PUT, DELETE, HEAD
3. **Gerer Content-Length** pour determiner la taille du body
4. **Implementer les connexions persistantes** (keep-alive par defaut en HTTP/1.1)
5. **Serialiser des reponses HTTP** avec status-line, headers, body

**Format d'une requete HTTP/1.1 :**
```
METHOD SP URI SP HTTP/Version CRLF
Header-Name: Header-Value CRLF
Header-Name: Header-Value CRLF
CRLF
[Body]
```

**Format d'une reponse HTTP/1.1 :**
```
HTTP/Version SP Status-Code SP Reason-Phrase CRLF
Header-Name: Header-Value CRLF
Header-Name: Header-Value CRLF
CRLF
[Body]
```

**Entree :**
- Flux TCP contenant des requetes HTTP/1.1 brutes
- Configuration du serveur (adresse, port, repertoire statique)

**Sortie :**
- `HttpRequest` parse avec tous les champs extraits
- `HttpResponse` serialise en bytes pret a envoyer

**Contraintes :**
- Les headers sont case-insensitive (Host == host == HOST)
- Le header `Host` est OBLIGATOIRE en HTTP/1.1
- `Content-Length` determine la taille exacte du body
- HTTP/1.1 utilise keep-alive par defaut (`Connection: close` pour fermer)
- HTTP/1.0 utilise close par defaut (`Connection: keep-alive` pour maintenir)

**Exemples :**

| Requete brute | Champ | Valeur |
|---------------|-------|--------|
| `GET /index.html HTTP/1.1\r\n` | method | GET |
| `Host: localhost:8080\r\n\r\n` | uri | /index.html |
| | version | Http11 |
| | headers["host"] | localhost:8080 |

| Reponse construite | Serialisation |
|--------------------|---------------|
| `HttpResponse::new(StatusCode::Ok)` | `HTTP/1.1 200 OK\r\n` |
| `.header("Content-Type", "text/html")` | `Content-Type: text/html\r\n` |
| `.text("<h1>Hello</h1>")` | `Content-Length: 14\r\n\r\n<h1>Hello</h1>` |

### 1.2.2 Consigne Academique

Implementer un parser HTTP/1.1 conforme aux RFC 7230-7235 (version simplifiee). Le parser doit extraire la request-line, les headers (case-insensitive), et le body selon Content-Length. Le serialiseur doit produire des reponses HTTP/1.1 valides avec status-line, headers, et body.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::path::PathBuf;
use tokio::io::{AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader};

/// Methodes HTTP supportees
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum HttpMethod {
    GET,
    POST,
    PUT,
    DELETE,
    HEAD,
    OPTIONS,
}

/// Version HTTP
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HttpVersion {
    Http10,
    Http11,
}

/// Requete HTTP parsee
#[derive(Debug, Clone)]
pub struct HttpRequest {
    pub method: HttpMethod,
    pub uri: String,
    pub version: HttpVersion,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

/// Code de statut HTTP
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StatusCode {
    Ok = 200,
    Created = 201,
    NoContent = 204,
    MovedPermanently = 301,
    BadRequest = 400,
    NotFound = 404,
    MethodNotAllowed = 405,
    InternalServerError = 500,
}

/// Reponse HTTP
#[derive(Debug, Clone)]
pub struct HttpResponse {
    pub status: StatusCode,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

/// Erreurs de parsing
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParseError {
    InvalidRequestLine,
    InvalidMethod,
    InvalidVersion,
    InvalidHeader,
    InvalidChunk,
    IncompleteRequest,
    BodyTooLarge,
}

/// Configuration du serveur
pub struct HttpServerConfig {
    pub address: String,
    pub port: u16,
    pub static_dir: PathBuf,
    pub max_body_size: usize,
}

impl HttpMethod {
    /// Parse une methode depuis une string
    pub fn from_str(s: &str) -> Result<Self, ParseError>;
}

impl HttpVersion {
    /// Parse une version depuis une string ("HTTP/1.0" ou "HTTP/1.1")
    pub fn from_str(s: &str) -> Result<Self, ParseError>;
}

impl HttpRequest {
    /// Parse une requete HTTP depuis un reader async
    pub async fn parse<R: AsyncBufReadExt + Unpin>(
        reader: &mut R,
        max_body_size: usize,
    ) -> Result<Self, ParseError>;

    /// Retourne la valeur d'un header (case-insensitive)
    pub fn get_header(&self, name: &str) -> Option<&str>;

    /// Verifie si la connexion doit etre maintenue (keep-alive)
    pub fn keep_alive(&self) -> bool;
}

impl StatusCode {
    /// Retourne la reason phrase standard
    pub fn reason_phrase(&self) -> &'static str;
}

impl HttpResponse {
    /// Cree une reponse avec le status donne
    pub fn new(status: StatusCode) -> Self;

    /// Ajoute un header (builder pattern)
    pub fn header(mut self, name: &str, value: &str) -> Self;

    /// Definit le body en bytes
    pub fn body(mut self, body: Vec<u8>) -> Self;

    /// Definit le body comme texte (UTF-8)
    pub fn text(self, text: &str) -> Self;

    /// Definit le body comme JSON (necessite serde)
    pub fn json<T: serde::Serialize>(self, value: &T) -> Self;

    /// Serialise la reponse complete en bytes
    pub fn to_bytes(&self) -> Vec<u8>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'anatomie d'une requete HTTP

Une requete HTTP/1.1 est composee de trois parties distinctes :

```
     REQUEST LINE
     +-----------+-----+------------------+-----+--------------+------+
     |  METHOD   | SP  |       URI        | SP  |   VERSION    | CRLF |
     +-----------+-----+------------------+-----+--------------+------+
          |              |                            |
          v              v                            v
        "GET"        "/api/users"               "HTTP/1.1"

     HEADERS
     +------------------+---+------------------+------+
     |   Header-Name    | : |   Header-Value   | CRLF |
     +------------------+---+------------------+------+
     |   Header-Name    | : |   Header-Value   | CRLF |
     +------------------+---+------------------+------+
     |                     CRLF                       |  <- ligne vide
     +------------------------------------------------+

     BODY (optionnel)
     +------------------------------------------------+
     |              Content (si Content-Length > 0)    |
     +------------------------------------------------+
```

### 2.2 Pourquoi CRLF et pas juste LF ?

HTTP a ete concu a une epoque ou les terminaux utilisaient Carriage Return + Line Feed (`\r\n`). La specification impose CRLF pour la compatibilite. Un parser tolerant accepte aussi LF seul, mais la specification stricte exige CRLF.

### 2.3 Le header Host : pourquoi obligatoire ?

Avant HTTP/1.1, chaque nom de domaine necessitait une IP unique. Le header `Host` permet le **virtual hosting** : plusieurs sites sur une seule IP.

```
Client A → GET / HTTP/1.1           Server (192.168.1.1)
           Host: site-a.com     →   → Route vers site A

Client B → GET / HTTP/1.1           Server (192.168.1.1)
           Host: site-b.com     →   → Route vers site B
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation |
|--------|-------------|
| **Backend Developer** | APIs REST, microservices, reverse proxies |
| **Security Engineer** | WAF (Web Application Firewall), analyse de requetes |
| **DevOps Engineer** | Load balancers, health checks, monitoring |
| **Embedded Developer** | Serveurs HTTP sur IoT, firmware updates |

### Cas d'usage concrets

1. **nginx** : Reverse proxy haute performance, parsing HTTP ultra-optimise
2. **Cloudflare Workers** : Edge computing, manipulation de requetes HTTP
3. **Postman/Insomnia** : Outils de debug d'APIs, construction de requetes
4. **curl** : Client HTTP en ligne de commande, reference de l'industrie

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo build --release
   Compiling http_parser v0.1.0
    Finished release [optimized] target(s)

$ cargo run --release -- --port 8080 --static ./public &
[1] 12345
HTTP Server listening on 127.0.0.1:8080

$ curl -v http://localhost:8080/index.html
> GET /index.html HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.88.1
> Accept: */*
>
< HTTP/1.1 200 OK
< Content-Type: text/html
< Content-Length: 45
<
<html><body><h1>Welcome!</h1></body></html>

$ curl -X POST http://localhost:8080/api/echo \
       -H "Content-Type: application/json" \
       -d '{"message": "Hello"}'
{"echo": "Hello"}

$ cargo test
running 10 tests
test tests::test_parse_method ... ok
test tests::test_parse_simple_request ... ok
test tests::test_parse_request_with_body ... ok
test tests::test_response_serialization ... ok
test tests::test_keep_alive_http11 ... ok
test tests::test_keep_alive_http10 ... ok
test tests::test_status_code_reason ... ok
test tests::test_header_case_insensitive ... ok
test tests::test_parse_malformed_request ... ok
test tests::test_body_too_large ... ok

test result: ok. 10 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
+++++++++- (9/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) pour le parsing, O(chunk_count) pour l'assemblage

**Space Complexity attendue :**
O(body_size)

**Domaines Bonus :**
`Parsing, Algo`

#### 3.1.1 Consigne Bonus

**"The Chunked Encoding"**

*"Comment transferer des donnees dont tu ne connais pas la taille ? Tu les decoupes. Chunk par chunk. Le recepteur reassemble. C'est comme construire le monde de la Matrice, brique par brique."*

**Ta mission bonus :**

Implementer le **Transfer-Encoding: chunked** (RFC 7230 section 4.1) :

1. **Lecture de chunks** : Parser le format `size CRLF data CRLF`
2. **Ecriture de chunks** : Encoder un body en format chunked
3. **Serveur de fichiers statiques** avec detection MIME automatique
4. **Gestion des MIME types** : html, css, js, json, png, jpg, etc.

**Format chunked :**
```
<size en hex>\r\n
<data de cette taille>\r\n
<size en hex>\r\n
<data de cette taille>\r\n
0\r\n
\r\n
```

**Exemple :**
```
Transfer-Encoding: chunked

5\r\n
Hello\r\n
6\r\n
 World\r\n
0\r\n
\r\n
```
Resultat decode : "Hello World"

#### 3.1.2 Prototype Bonus

```rust
/// Parse une ligne de chunk (taille en hexadecimal)
pub fn parse_chunk_size(line: &str) -> Result<usize, ParseError>;

/// Encode des donnees en format chunked
pub fn encode_chunked(data: &[u8]) -> Vec<u8>;

/// Serialise une reponse avec Transfer-Encoding: chunked
impl HttpResponse {
    pub fn to_chunked_bytes(&self) -> Vec<u8>;
}

/// Determine le MIME type d'un fichier selon son extension
pub fn mime_type(path: &std::path::Path) -> &'static str;

/// Handler de route (type alias)
pub type RouteHandler = Box<dyn Fn(HttpRequest) -> HttpResponse + Send + Sync>;

/// Serveur HTTP avec routing
pub struct HttpServer {
    config: HttpServerConfig,
    routes: HashMap<(HttpMethod, String), RouteHandler>,
}

impl HttpServer {
    pub fn new(config: HttpServerConfig) -> Self;

    /// Ajoute une route avec son handler
    pub fn route(
        &mut self,
        method: HttpMethod,
        path: &str,
        handler: impl Fn(HttpRequest) -> HttpResponse + Send + Sync + 'static,
    );

    /// Demarre le serveur (async)
    pub async fn run(&self) -> std::io::Result<()>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Description | Points | Categorie |
|------|-------------|--------|-----------|
| `test_parse_method` | GET, POST, PUT, DELETE, HEAD parses | 10 | Parsing |
| `test_parse_simple_request` | Request sans body | 15 | Parsing |
| `test_parse_request_with_body` | Content-Length + body | 15 | Parsing |
| `test_header_case_insensitive` | Host == host == HOST | 10 | Parsing |
| `test_response_serialization` | to_bytes() correct | 15 | Serialisation |
| `test_keep_alive_http11` | Keep-alive par defaut | 10 | Protocol |
| `test_keep_alive_http10` | Close par defaut | 10 | Protocol |
| `test_status_code_reason` | Reason phrases standards | 5 | Protocol |
| `test_parse_malformed_request` | Erreur sur requete invalide | 5 | Robustness |
| `test_body_too_large` | Rejet si body > max_size | 5 | Security |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::io::BufReader;

    #[test]
    fn test_parse_method() {
        assert_eq!(HttpMethod::from_str("GET").unwrap(), HttpMethod::GET);
        assert_eq!(HttpMethod::from_str("POST").unwrap(), HttpMethod::POST);
        assert_eq!(HttpMethod::from_str("PUT").unwrap(), HttpMethod::PUT);
        assert_eq!(HttpMethod::from_str("DELETE").unwrap(), HttpMethod::DELETE);
        assert_eq!(HttpMethod::from_str("HEAD").unwrap(), HttpMethod::HEAD);
        assert!(HttpMethod::from_str("INVALID").is_err());
        assert!(HttpMethod::from_str("get").is_err()); // Case sensitive
    }

    #[tokio::test]
    async fn test_parse_simple_request() {
        let raw = b"GET /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n";
        let mut reader = BufReader::new(&raw[..]);

        let request = HttpRequest::parse(&mut reader, 1024).await.unwrap();

        assert_eq!(request.method, HttpMethod::GET);
        assert_eq!(request.uri, "/index.html");
        assert_eq!(request.version, HttpVersion::Http11);
        assert_eq!(request.get_header("Host"), Some("localhost"));
    }

    #[tokio::test]
    async fn test_parse_request_with_body() {
        let raw = b"POST /api/data HTTP/1.1\r\nHost: localhost\r\nContent-Length: 13\r\n\r\nHello, World!";
        let mut reader = BufReader::new(&raw[..]);

        let request = HttpRequest::parse(&mut reader, 1024).await.unwrap();

        assert_eq!(request.method, HttpMethod::POST);
        assert_eq!(request.uri, "/api/data");
        assert_eq!(request.body, b"Hello, World!");
        assert_eq!(request.get_header("Content-Length"), Some("13"));
    }

    #[tokio::test]
    async fn test_header_case_insensitive() {
        let raw = b"GET / HTTP/1.1\r\nhost: example.com\r\ncontent-type: text/html\r\n\r\n";
        let mut reader = BufReader::new(&raw[..]);

        let request = HttpRequest::parse(&mut reader, 1024).await.unwrap();

        // get_header should be case-insensitive
        assert_eq!(request.get_header("Host"), Some("example.com"));
        assert_eq!(request.get_header("HOST"), Some("example.com"));
        assert_eq!(request.get_header("host"), Some("example.com"));
        assert_eq!(request.get_header("Content-Type"), Some("text/html"));
    }

    #[test]
    fn test_response_serialization() {
        let response = HttpResponse::new(StatusCode::Ok)
            .header("Content-Type", "text/plain")
            .text("Hello");

        let bytes = response.to_bytes();
        let text = String::from_utf8(bytes).unwrap();

        assert!(text.starts_with("HTTP/1.1 200 OK\r\n"));
        assert!(text.contains("Content-Type: text/plain\r\n"));
        assert!(text.contains("Content-Length: 5\r\n"));
        assert!(text.ends_with("\r\n\r\nHello"));
    }

    #[test]
    fn test_keep_alive_http11() {
        let request = HttpRequest {
            method: HttpMethod::GET,
            uri: "/".to_string(),
            version: HttpVersion::Http11,
            headers: HashMap::new(),
            body: vec![],
        };

        // HTTP/1.1 default is keep-alive
        assert!(request.keep_alive());

        let mut request_close = request.clone();
        request_close.headers.insert("connection".to_string(), "close".to_string());
        assert!(!request_close.keep_alive());
    }

    #[test]
    fn test_keep_alive_http10() {
        let request = HttpRequest {
            method: HttpMethod::GET,
            uri: "/".to_string(),
            version: HttpVersion::Http10,
            headers: HashMap::new(),
            body: vec![],
        };

        // HTTP/1.0 default is close
        assert!(!request.keep_alive());

        let mut request_keepalive = request.clone();
        request_keepalive.headers.insert("connection".to_string(), "keep-alive".to_string());
        assert!(request_keepalive.keep_alive());
    }

    #[test]
    fn test_status_code_reason() {
        assert_eq!(StatusCode::Ok.reason_phrase(), "OK");
        assert_eq!(StatusCode::Created.reason_phrase(), "Created");
        assert_eq!(StatusCode::BadRequest.reason_phrase(), "Bad Request");
        assert_eq!(StatusCode::NotFound.reason_phrase(), "Not Found");
        assert_eq!(StatusCode::MethodNotAllowed.reason_phrase(), "Method Not Allowed");
        assert_eq!(StatusCode::InternalServerError.reason_phrase(), "Internal Server Error");
    }

    #[tokio::test]
    async fn test_parse_malformed_request() {
        let raw = b"INVALID REQUEST LINE\r\n\r\n";
        let mut reader = BufReader::new(&raw[..]);

        let result = HttpRequest::parse(&mut reader, 1024).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_body_too_large() {
        let raw = b"POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 1000000\r\n\r\n";
        let mut reader = BufReader::new(&raw[..]);

        let result = HttpRequest::parse(&mut reader, 1024).await;
        assert_eq!(result, Err(ParseError::BodyTooLarge));
    }
}

// Tests bonus (Transfer-Encoding: chunked)
#[cfg(test)]
mod tests_bonus {
    use super::*;
    use tokio::io::BufReader;

    #[tokio::test]
    async fn test_parse_chunked_body() {
        let raw = b"POST /api HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nHello\r\n6\r\n World\r\n0\r\n\r\n";
        let mut reader = BufReader::new(&raw[..]);

        let request = HttpRequest::parse(&mut reader, 1024).await.unwrap();

        assert_eq!(request.body, b"Hello World");
    }

    #[test]
    fn test_chunked_encoding() {
        let data = b"Hello World";
        let encoded = encode_chunked(data);
        let text = String::from_utf8(encoded).unwrap();

        // Format: "b\r\nHello World\r\n0\r\n\r\n" (11 = 0xb)
        assert!(text.contains("b\r\n"));
        assert!(text.contains("Hello World\r\n"));
        assert!(text.ends_with("0\r\n\r\n"));
    }

    #[test]
    fn test_mime_types() {
        use std::path::Path;
        assert_eq!(mime_type(Path::new("file.html")), "text/html");
        assert_eq!(mime_type(Path::new("file.css")), "text/css");
        assert_eq!(mime_type(Path::new("file.js")), "application/javascript");
        assert_eq!(mime_type(Path::new("file.json")), "application/json");
        assert_eq!(mime_type(Path::new("file.png")), "image/png");
        assert_eq!(mime_type(Path::new("file.jpg")), "image/jpeg");
        assert_eq!(mime_type(Path::new("file.unknown")), "application/octet-stream");
    }

    #[test]
    fn test_parse_chunk_size() {
        assert_eq!(parse_chunk_size("0").unwrap(), 0);
        assert_eq!(parse_chunk_size("5").unwrap(), 5);
        assert_eq!(parse_chunk_size("b").unwrap(), 11);
        assert_eq!(parse_chunk_size("B").unwrap(), 11);
        assert_eq!(parse_chunk_size("10").unwrap(), 16);
        assert_eq!(parse_chunk_size("ff").unwrap(), 255);
        assert_eq!(parse_chunk_size("FF").unwrap(), 255);
        assert!(parse_chunk_size("xyz").is_err());
        assert!(parse_chunk_size("-1").is_err());
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::path::PathBuf;
use tokio::io::{AsyncBufReadExt, AsyncReadExt};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum HttpMethod {
    GET,
    POST,
    PUT,
    DELETE,
    HEAD,
    OPTIONS,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HttpVersion {
    Http10,
    Http11,
}

#[derive(Debug, Clone)]
pub struct HttpRequest {
    pub method: HttpMethod,
    pub uri: String,
    pub version: HttpVersion,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StatusCode {
    Ok = 200,
    Created = 201,
    NoContent = 204,
    MovedPermanently = 301,
    BadRequest = 400,
    NotFound = 404,
    MethodNotAllowed = 405,
    InternalServerError = 500,
}

#[derive(Debug, Clone)]
pub struct HttpResponse {
    pub status: StatusCode,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParseError {
    InvalidRequestLine,
    InvalidMethod,
    InvalidVersion,
    InvalidHeader,
    InvalidChunk,
    IncompleteRequest,
    BodyTooLarge,
}

pub struct HttpServerConfig {
    pub address: String,
    pub port: u16,
    pub static_dir: PathBuf,
    pub max_body_size: usize,
}

impl HttpMethod {
    pub fn from_str(s: &str) -> Result<Self, ParseError> {
        match s {
            "GET" => Ok(HttpMethod::GET),
            "POST" => Ok(HttpMethod::POST),
            "PUT" => Ok(HttpMethod::PUT),
            "DELETE" => Ok(HttpMethod::DELETE),
            "HEAD" => Ok(HttpMethod::HEAD),
            "OPTIONS" => Ok(HttpMethod::OPTIONS),
            _ => Err(ParseError::InvalidMethod),
        }
    }
}

impl HttpVersion {
    pub fn from_str(s: &str) -> Result<Self, ParseError> {
        match s {
            "HTTP/1.0" => Ok(HttpVersion::Http10),
            "HTTP/1.1" => Ok(HttpVersion::Http11),
            _ => Err(ParseError::InvalidVersion),
        }
    }
}

impl HttpRequest {
    pub async fn parse<R: AsyncBufReadExt + Unpin>(
        reader: &mut R,
        max_body_size: usize,
    ) -> Result<Self, ParseError> {
        // Parse request line
        let mut request_line = String::new();
        reader.read_line(&mut request_line).await
            .map_err(|_| ParseError::IncompleteRequest)?;

        let request_line = request_line.trim_end_matches(|c| c == '\r' || c == '\n');
        let parts: Vec<&str> = request_line.split(' ').collect();
        if parts.len() != 3 {
            return Err(ParseError::InvalidRequestLine);
        }

        let method = HttpMethod::from_str(parts[0])?;
        let uri = parts[1].to_string();
        let version = HttpVersion::from_str(parts[2])?;

        // Parse headers
        let mut headers = HashMap::new();
        loop {
            let mut line = String::new();
            reader.read_line(&mut line).await
                .map_err(|_| ParseError::IncompleteRequest)?;

            let line = line.trim_end_matches(|c| c == '\r' || c == '\n');
            if line.is_empty() {
                break;
            }

            let colon_pos = line.find(':')
                .ok_or(ParseError::InvalidHeader)?;

            let name = line[..colon_pos].trim().to_lowercase();
            let value = line[colon_pos + 1..].trim().to_string();
            headers.insert(name, value);
        }

        // Parse body based on Content-Length
        let body = if let Some(length_str) = headers.get("content-length") {
            let length: usize = length_str.parse()
                .map_err(|_| ParseError::InvalidHeader)?;

            if length > max_body_size {
                return Err(ParseError::BodyTooLarge);
            }

            let mut body = vec![0u8; length];
            reader.read_exact(&mut body).await
                .map_err(|_| ParseError::IncompleteRequest)?;
            body
        } else {
            Vec::new()
        };

        Ok(HttpRequest {
            method,
            uri,
            version,
            headers,
            body,
        })
    }

    pub fn get_header(&self, name: &str) -> Option<&str> {
        self.headers.get(&name.to_lowercase()).map(|s| s.as_str())
    }

    pub fn keep_alive(&self) -> bool {
        let connection = self.get_header("connection")
            .map(|s| s.to_lowercase());

        match self.version {
            HttpVersion::Http11 => {
                // HTTP/1.1 default is keep-alive
                connection.as_deref() != Some("close")
            }
            HttpVersion::Http10 => {
                // HTTP/1.0 default is close
                connection.as_deref() == Some("keep-alive")
            }
        }
    }
}

impl StatusCode {
    pub fn reason_phrase(&self) -> &'static str {
        match self {
            StatusCode::Ok => "OK",
            StatusCode::Created => "Created",
            StatusCode::NoContent => "No Content",
            StatusCode::MovedPermanently => "Moved Permanently",
            StatusCode::BadRequest => "Bad Request",
            StatusCode::NotFound => "Not Found",
            StatusCode::MethodNotAllowed => "Method Not Allowed",
            StatusCode::InternalServerError => "Internal Server Error",
        }
    }
}

impl HttpResponse {
    pub fn new(status: StatusCode) -> Self {
        HttpResponse {
            status,
            headers: HashMap::new(),
            body: Vec::new(),
        }
    }

    pub fn header(mut self, name: &str, value: &str) -> Self {
        self.headers.insert(name.to_string(), value.to_string());
        self
    }

    pub fn body(mut self, body: Vec<u8>) -> Self {
        self.body = body;
        self
    }

    pub fn text(mut self, text: &str) -> Self {
        self.body = text.as_bytes().to_vec();
        self
    }

    pub fn json<T: serde::Serialize>(mut self, value: &T) -> Self {
        if let Ok(json) = serde_json::to_vec(value) {
            self.body = json;
            self.headers.insert("Content-Type".to_string(), "application/json".to_string());
        }
        self
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut result = Vec::new();

        // Status line
        let status_line = format!(
            "HTTP/1.1 {} {}\r\n",
            self.status as u16,
            self.status.reason_phrase()
        );
        result.extend_from_slice(status_line.as_bytes());

        // Headers
        for (name, value) in &self.headers {
            let header = format!("{}: {}\r\n", name, value);
            result.extend_from_slice(header.as_bytes());
        }

        // Content-Length header (if not already present)
        if !self.headers.contains_key("Content-Length") {
            let cl = format!("Content-Length: {}\r\n", self.body.len());
            result.extend_from_slice(cl.as_bytes());
        }

        // End of headers
        result.extend_from_slice(b"\r\n");

        // Body
        result.extend_from_slice(&self.body);

        result
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Stocker les headers en case-preserved avec lookup lowercase
pub struct HttpRequest {
    pub headers: Vec<(String, String)>,  // Preserve original case
}

impl HttpRequest {
    pub fn get_header(&self, name: &str) -> Option<&str> {
        let name_lower = name.to_lowercase();
        self.headers.iter()
            .find(|(k, _)| k.to_lowercase() == name_lower)
            .map(|(_, v)| v.as_str())
    }
}

// Alternative 2 : Utiliser BTreeMap pour headers ordonnes
use std::collections::BTreeMap;
pub struct HttpResponse {
    pub headers: BTreeMap<String, String>,  // Ordered output
}

// Alternative 3 : Streaming body avec AsyncRead
pub struct HttpResponse {
    pub body: Box<dyn AsyncRead + Unpin + Send>,
    pub content_length: Option<usize>,
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Headers case-sensitive
impl HttpRequest {
    pub fn get_header(&self, name: &str) -> Option<&str> {
        self.headers.get(name).map(|s| s.as_str())  // MUTANT: pas de lowercase
    }
}
// Pourquoi refusee : RFC 7230 exige case-insensitive pour les headers

// REFUSEE 2 : Pas de CRLF dans la serialisation
impl HttpResponse {
    pub fn to_bytes(&self) -> Vec<u8> {
        let status_line = format!(
            "HTTP/1.1 {} {}\n",  // MUTANT: \n au lieu de \r\n
            self.status as u16,
            self.status.reason_phrase()
        );
        // ...
    }
}
// Pourquoi refusee : HTTP exige CRLF comme terminateur de ligne

// REFUSEE 3 : Pas de Content-Length automatique
impl HttpResponse {
    pub fn to_bytes(&self) -> Vec<u8> {
        // ... headers sans Content-Length ...
        result.extend_from_slice(b"\r\n");
        result.extend_from_slice(&self.body);  // MUTANT: pas de CL
        result
    }
}
// Pourquoi refusee : Sans Content-Length, le client ne sait pas ou finit le body
```

### 4.6 Solution bonus de reference

```rust
/// Parse une taille de chunk en hexadecimal
pub fn parse_chunk_size(line: &str) -> Result<usize, ParseError> {
    let line = line.trim();
    usize::from_str_radix(line, 16)
        .map_err(|_| ParseError::InvalidChunk)
}

/// Encode des donnees en format chunked
pub fn encode_chunked(data: &[u8]) -> Vec<u8> {
    let mut result = Vec::new();

    // Single chunk with all data
    let size_hex = format!("{:x}\r\n", data.len());
    result.extend_from_slice(size_hex.as_bytes());
    result.extend_from_slice(data);
    result.extend_from_slice(b"\r\n");

    // Terminating chunk
    result.extend_from_slice(b"0\r\n\r\n");

    result
}

/// MIME type detection
pub fn mime_type(path: &std::path::Path) -> &'static str {
    match path.extension().and_then(|e| e.to_str()) {
        Some("html") | Some("htm") => "text/html",
        Some("css") => "text/css",
        Some("js") => "application/javascript",
        Some("json") => "application/json",
        Some("png") => "image/png",
        Some("jpg") | Some("jpeg") => "image/jpeg",
        Some("gif") => "image/gif",
        Some("svg") => "image/svg+xml",
        Some("ico") => "image/x-icon",
        Some("txt") => "text/plain",
        Some("xml") => "application/xml",
        Some("pdf") => "application/pdf",
        Some("wasm") => "application/wasm",
        _ => "application/octet-stream",
    }
}

impl HttpResponse {
    pub fn to_chunked_bytes(&self) -> Vec<u8> {
        let mut result = Vec::new();

        // Status line
        let status_line = format!(
            "HTTP/1.1 {} {}\r\n",
            self.status as u16,
            self.status.reason_phrase()
        );
        result.extend_from_slice(status_line.as_bytes());

        // Headers (without Content-Length, with Transfer-Encoding)
        for (name, value) in &self.headers {
            if name.to_lowercase() != "content-length" {
                let header = format!("{}: {}\r\n", name, value);
                result.extend_from_slice(header.as_bytes());
            }
        }
        result.extend_from_slice(b"Transfer-Encoding: chunked\r\n");
        result.extend_from_slice(b"\r\n");

        // Chunked body
        result.extend_from_slice(&encode_chunked(&self.body));

        result
    }
}

// Extended HttpRequest::parse to handle chunked encoding
impl HttpRequest {
    pub async fn parse<R: AsyncBufReadExt + Unpin>(
        reader: &mut R,
        max_body_size: usize,
    ) -> Result<Self, ParseError> {
        // ... (request line and headers parsing as before) ...

        // Parse body based on Transfer-Encoding or Content-Length
        let body = if headers.get("transfer-encoding")
            .map(|s| s.to_lowercase().contains("chunked"))
            .unwrap_or(false)
        {
            // Chunked encoding
            let mut body = Vec::new();
            loop {
                let mut size_line = String::new();
                reader.read_line(&mut size_line).await
                    .map_err(|_| ParseError::IncompleteRequest)?;

                let size = parse_chunk_size(size_line.trim())?;
                if size == 0 {
                    // Read final CRLF
                    let mut final_line = String::new();
                    reader.read_line(&mut final_line).await
                        .map_err(|_| ParseError::IncompleteRequest)?;
                    break;
                }

                if body.len() + size > max_body_size {
                    return Err(ParseError::BodyTooLarge);
                }

                let mut chunk = vec![0u8; size];
                reader.read_exact(&mut chunk).await
                    .map_err(|_| ParseError::IncompleteRequest)?;
                body.extend_from_slice(&chunk);

                // Read trailing CRLF
                let mut crlf = String::new();
                reader.read_line(&mut crlf).await
                    .map_err(|_| ParseError::IncompleteRequest)?;
            }
            body
        } else if let Some(length_str) = headers.get("content-length") {
            // Content-Length
            let length: usize = length_str.parse()
                .map_err(|_| ParseError::InvalidHeader)?;
            if length > max_body_size {
                return Err(ParseError::BodyTooLarge);
            }
            let mut body = vec![0u8; length];
            reader.read_exact(&mut body).await
                .map_err(|_| ParseError::IncompleteRequest)?;
            body
        } else {
            Vec::new()
        };

        // ... rest of implementation ...
    }
}
```

### 4.9 spec.json

```json
{
  "name": "http_parser",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Concept composite - Parsing + Serialisation + Protocol State",
  "tags": ["networking", "http", "parsing", "web", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "HttpRequest",
    "prototype": "impl HttpRequest",
    "return_type": "struct",
    "parameters": []
  },

  "driver": {
    "edge_cases": [
      {
        "name": "simple_get",
        "input": "GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n",
        "expected": {"method": "GET", "uri": "/", "version": "Http11"},
        "is_trap": false
      },
      {
        "name": "post_with_body",
        "input": "POST /api HTTP/1.1\\r\\nHost: localhost\\r\\nContent-Length: 4\\r\\n\\r\\ntest",
        "expected": {"method": "POST", "body": "test"},
        "is_trap": false
      },
      {
        "name": "missing_host_header",
        "input": "GET / HTTP/1.1\\r\\n\\r\\n",
        "expected": "valid_parse",
        "is_trap": true,
        "trap_explanation": "HTTP/1.1 requiert Host, mais le parser peut etre tolerant"
      },
      {
        "name": "header_case_insensitive",
        "input": "GET / HTTP/1.1\\r\\nHOST: test\\r\\ncontent-TYPE: text/html\\r\\n\\r\\n",
        "expected": {"get_header('host')": "test"},
        "is_trap": true,
        "trap_explanation": "Headers doivent etre case-insensitive"
      },
      {
        "name": "crlf_only",
        "input": "GET / HTTP/1.1\\r\\nHost: test\\r\\n\\n",
        "expected": "may_fail",
        "is_trap": true,
        "trap_explanation": "LF seul au lieu de CRLF - comportement non defini"
      },
      {
        "name": "oversized_body",
        "input": "POST / HTTP/1.1\\r\\nHost: x\\r\\nContent-Length: 999999999\\r\\n\\r\\n",
        "expected": "ParseError::BodyTooLarge",
        "is_trap": true,
        "trap_explanation": "Protection contre les attaques par body trop large"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 200,
      "generators": [
        {
          "type": "http_request",
          "params": {
            "methods": ["GET", "POST", "PUT", "DELETE", "HEAD"],
            "max_uri_len": 2048,
            "max_header_count": 50,
            "max_body_len": 8192
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_crates": ["tokio", "serde", "serde_json"],
    "forbidden_crates": ["hyper", "reqwest", "actix-web", "warp", "axum"],
    "check_security": true,
    "blocking": false
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Parsing) : Pas de gestion CRLF propre */
impl HttpRequest {
    pub async fn parse<R: AsyncBufReadExt + Unpin>(
        reader: &mut R,
        max_body_size: usize,
    ) -> Result<Self, ParseError> {
        let mut request_line = String::new();
        reader.read_line(&mut request_line).await?;

        // MUTANT: trim() au lieu de trim_end avec CRLF specifique
        let parts: Vec<&str> = request_line.trim().split(' ').collect();
        // ...
    }
}
// Pourquoi c'est faux : trim() enleve aussi les espaces au debut, cassant le parsing
// Ce qui etait pense : "trim() suffit pour nettoyer la ligne"

/* Mutant B (Protocol) : Headers case-sensitive */
impl HttpRequest {
    pub fn get_header(&self, name: &str) -> Option<&str> {
        self.headers.get(name).map(|s| s.as_str())  // MUTANT: pas de to_lowercase
    }
}
// Pourquoi c'est faux : "Host" != "host" != "HOST", mais tous sont valides en HTTP
// Ce qui etait pense : "Les headers sont toujours normalises par le client"

/* Mutant C (Body) : Content-Length parse comme i32 */
impl HttpRequest {
    pub async fn parse<R: AsyncBufReadExt + Unpin>(...) -> Result<Self, ParseError> {
        // ...
        let length: i32 = length_str.parse()?;  // MUTANT: i32 au lieu de usize
        let mut body = vec![0u8; length as usize];
        // ...
    }
}
// Pourquoi c'est faux : Content-Length negatif ou > i32::MAX cause overflow/panic
// Ce qui etait pense : "Les nombres sont toujours petits et positifs"

/* Mutant D (Serialisation) : LF au lieu de CRLF */
impl HttpResponse {
    pub fn to_bytes(&self) -> Vec<u8> {
        let status_line = format!(
            "HTTP/1.1 {} {}\n",  // MUTANT: \n au lieu de \r\n
            self.status as u16,
            self.status.reason_phrase()
        );
        // ...
        for (name, value) in &self.headers {
            let header = format!("{}: {}\n", name, value);  // MUTANT
            // ...
        }
        result.extend_from_slice(b"\n");  // MUTANT
        // ...
    }
}
// Pourquoi c'est faux : HTTP exige CRLF, certains clients stricts rejettent LF seul
// Ce qui etait pense : "Tous les parsers acceptent LF comme CRLF"

/* Mutant E (Keep-Alive) : Logique inversee */
impl HttpRequest {
    pub fn keep_alive(&self) -> bool {
        let connection = self.get_header("connection");

        match self.version {
            HttpVersion::Http11 => {
                connection == Some("keep-alive")  // MUTANT: inverse
            }
            HttpVersion::Http10 => {
                connection != Some("close")  // MUTANT: inverse
            }
        }
    }
}
// Pourquoi c'est faux : HTTP/1.1 est keep-alive par DEFAUT, HTTP/1.0 est close par DEFAUT
// Ce qui etait pense : "Je dois explicitement demander keep-alive dans tous les cas"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Protocole HTTP/1.1** : Structure request-line/headers/body
2. **Parsing textuel** : Extraction de donnees structurees depuis du texte
3. **Serialisation** : Construction de messages conformes au protocole
4. **Gestion d'etat** : Keep-alive et connexions persistantes
5. **Async I/O** : Lecture non-bloquante avec tokio

### 5.2 LDA - Traduction Litterale

```
FONCTION parse QUI RETOURNE UN RESULTAT (HttpRequest ou ParseError)
DEBUT FONCTION
    DECLARER request_line COMME CHAINE

    LIRE UNE LIGNE DEPUIS reader DANS request_line
    SI L'OPERATION ECHOUE ALORS
        RETOURNER ERREUR IncompleteRequest
    FIN SI

    DECLARER parts COMME request_line DECOUPE PAR ESPACES
    SI parts.LONGUEUR != 3 ALORS
        RETOURNER ERREUR InvalidRequestLine
    FIN SI

    DECLARER method COMME PARSE DE parts[0]
    DECLARER uri COMME parts[1]
    DECLARER version COMME PARSE DE parts[2]

    DECLARER headers COMME MAP VIDE

    BOUCLE INFINIE
        LIRE UNE LIGNE DEPUIS reader
        SI ligne EST VIDE (apres trim CRLF) ALORS
            SORTIR DE LA BOUCLE
        FIN SI
        EXTRAIRE nom:valeur ET AJOUTER A headers
    FIN BOUCLE

    SI headers CONTIENT "content-length" ALORS
        DECLARER length COMME PARSE DU HEADER
        SI length > max_body_size ALORS
            RETOURNER ERREUR BodyTooLarge
        FIN SI
        LIRE length OCTETS DANS body
    FIN SI

    RETOURNER HttpRequest { method, uri, version, headers, body }
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : HTTP/1.1 Request Parser
---
ENTREE : flux TCP, taille_max_body
SORTIE : requete HTTP structuree

1. LIRE request_line jusqu'a CRLF
2. DECOUPER request_line en (METHOD, URI, VERSION)
3. VALIDER METHOD dans {GET, POST, PUT, DELETE, HEAD, OPTIONS}
4. VALIDER VERSION dans {HTTP/1.0, HTTP/1.1}

5. BOUCLE headers:
   a. LIRE ligne jusqu'a CRLF
   b. SI ligne vide : FIN BOUCLE
   c. DECOUPER en (nom, valeur) sur ':'
   d. NORMALISER nom en lowercase
   e. STOCKER dans map headers

6. SI Transfer-Encoding == "chunked":
   a. BOUCLE chunks:
      - LIRE taille (hex) CRLF
      - SI taille == 0 : FIN
      - LIRE taille octets
      - LIRE CRLF
      - CONCATENER au body
7. SINON SI Content-Length existe:
   a. LIRE Content-Length octets dans body

8. RETOURNER requete
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : HTTP Response Serialization
---
1. CONSTRUIRE status_line : "HTTP/1.1 {code} {reason}\r\n"

2. POUR CHAQUE header (nom, valeur):
   AJOUTER "{nom}: {valeur}\r\n"

3. SI Content-Length absent:
   AJOUTER "Content-Length: {body.len}\r\n"

4. AJOUTER "\r\n" (fin des headers)

5. AJOUTER body

6. RETOURNER bytes
```

### 5.3 Visualisation ASCII

```
                    HTTP REQUEST STRUCTURE

    +-----------------------------------------------------------------+
    |                        REQUEST LINE                              |
    +-----------------------------------------------------------------+
    | METHOD     |   SP   |     URI      |   SP   |    VERSION  | CRLF|
    +------------+--------+--------------+--------+-------------+-----+
    |   "POST"   |  " "   | "/api/users" |  " "   | "HTTP/1.1"  |\r\n |
    +------------+--------+--------------+--------+-------------+-----+
                                   |
                                   v
    +-----------------------------------------------------------------+
    |                          HEADERS                                 |
    +-----------------------------------------------------------------+
    | Header-Name          | ":" | SP | Header-Value           | CRLF |
    +----------------------+-----+----+------------------------+------+
    | "Host"               | ":" | " "| "api.example.com"      | \r\n |
    +----------------------+-----+----+------------------------+------+
    | "Content-Type"       | ":" | " "| "application/json"     | \r\n |
    +----------------------+-----+----+------------------------+------+
    | "Content-Length"     | ":" | " "| "42"                   | \r\n |
    +----------------------+-----+----+------------------------+------+
    |                          CRLF (empty line)               | \r\n |
    +----------------------------------------------------------+------+
                                   |
                                   v
    +-----------------------------------------------------------------+
    |                           BODY                                   |
    +-----------------------------------------------------------------+
    | {"name": "John", "email": "john@example.com"}                    |
    | (exactly 42 bytes as specified by Content-Length)                |
    +-----------------------------------------------------------------+


                    HTTP RESPONSE STRUCTURE

    +-----------------------------------------------------------------+
    |                        STATUS LINE                               |
    +-----------------------------------------------------------------+
    | VERSION    |  SP  | STATUS |  SP  |    REASON PHRASE     | CRLF |
    +------------+------+--------+------+----------------------+------+
    | "HTTP/1.1" |  " " |  200   |  " " |       "OK"           | \r\n |
    +------------+------+--------+------+----------------------+------+
                                   |
                                   v
    +-----------------------------------------------------------------+
    |                          HEADERS                                 |
    +-----------------------------------------------------------------+
    | "Content-Type: application/json\r\n"                             |
    | "Content-Length: 27\r\n"                                         |
    | "\r\n"                                                           |
    +-----------------------------------------------------------------+
                                   |
                                   v
    +-----------------------------------------------------------------+
    |                           BODY                                   |
    +-----------------------------------------------------------------+
    | {"status": "created", "id": 1}                                   |
    +-----------------------------------------------------------------+
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Headers case-sensitive** | Host != host | `to_lowercase()` sur le nom |
| **LF au lieu de CRLF** | Certains clients stricts rejettent | Toujours `\r\n` |
| **Content-Length manquant** | Client ne sait pas ou finit le body | Toujours l'inclure |
| **Body tronque** | Lecture incomplete | `read_exact()` avec la taille |
| **Keep-alive inverse** | Connexions jamais fermees | HTTP/1.1 = keep-alive par defaut |

### 5.5 Cours Complet

#### 5.5.1 Le modele request/response

HTTP est un protocole **stateless** base sur le modele requete/reponse :

```
    Client                              Server
       |                                   |
       |   ------- HTTP Request ------->   |
       |                                   |
       |   <------ HTTP Response ------    |
       |                                   |
```

Chaque requete est independante (pas de memoire des requetes precedentes).

#### 5.5.2 Les methodes HTTP

| Methode | Semantique | Body Request | Body Response | Idempotent |
|---------|------------|--------------|---------------|------------|
| GET | Lire une ressource | Non | Oui | Oui |
| POST | Creer une ressource | Oui | Oui | Non |
| PUT | Remplacer une ressource | Oui | Optionnel | Oui |
| DELETE | Supprimer une ressource | Optionnel | Optionnel | Oui |
| HEAD | GET sans body | Non | Non | Oui |

#### 5.5.3 Les codes de statut

```
+-------+---------------------------+--------------------------------+
| Code  | Categorie                 | Signification                  |
+-------+---------------------------+--------------------------------+
| 1xx   | Informational             | Continue, Switching Protocols  |
| 2xx   | Success                   | OK, Created, No Content        |
| 3xx   | Redirection               | Moved, Found, Not Modified     |
| 4xx   | Client Error              | Bad Request, Not Found, 403    |
| 5xx   | Server Error              | Internal Error, Bad Gateway    |
+-------+---------------------------+--------------------------------+
```

#### 5.5.4 Keep-Alive et connexions persistantes

Avant HTTP/1.1, chaque requete ouvrait une nouvelle connexion TCP (3-way handshake a chaque fois). Le keep-alive permet de reutiliser la connexion :

```
    Sans Keep-Alive (HTTP/1.0 defaut)     Avec Keep-Alive (HTTP/1.1 defaut)

    TCP Connect ─────────────────┐        TCP Connect ─────────────────┐
    Request 1 ──────────────────>│        Request 1 ──────────────────>│
    Response 1 <─────────────────┤        Response 1 <─────────────────┤
    TCP Close <──────────────────┘        Request 2 ──────────────────>│
                                          Response 2 <─────────────────┤
    TCP Connect ─────────────────┐        Request 3 ──────────────────>│
    Request 2 ──────────────────>│        Response 3 <─────────────────┤
    Response 2 <─────────────────┤        TCP Close <──────────────────┘
    TCP Close <──────────────────┘
                                          (1 connexion pour 3 requetes)
    (1 connexion par requete)
```

#### 5.5.5 Transfer-Encoding: chunked

Quand la taille du body n'est pas connue a l'avance (streaming), on utilise le chunked encoding :

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked

7\r\n
Mozilla\r\n
9\r\n
Developer\r\n
7\r\n
Network\r\n
0\r\n
\r\n
```

Decode : "MozillaDeveloperNetwork"

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------------+
| HORS NORME                                                          |
+---------------------------------------------------------------------+
| // Headers stockes tels quels (case-sensitive)                      |
| headers.insert(name.to_string(), value.to_string());                |
| // Lookup sans normalisation                                        |
| headers.get(name)                                                   |
+---------------------------------------------------------------------+
| CONFORME (case-insensitive)                                         |
+---------------------------------------------------------------------+
| // Normaliser a l'insertion                                         |
| headers.insert(name.to_lowercase(), value.to_string());             |
| // Ou normaliser au lookup                                          |
| headers.get(&name.to_lowercase())                                   |
+---------------------------------------------------------------------+
| POURQUOI ?                                                          |
| - RFC 7230 : "Each header field consists of a case-insensitive     |
|   field name"                                                       |
| - "Content-Type", "content-type", "CONTENT-TYPE" sont equivalents  |
+---------------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Scenario :** Parse de `POST /api HTTP/1.1\r\nHost: localhost\r\nContent-Length: 5\r\n\r\nhello`

```
+-------+---------------------------------+----------------------------+
| Etape | Action                          | Etat                       |
+-------+---------------------------------+----------------------------+
|   1   | read_line() -> request_line     | "POST /api HTTP/1.1\r\n"   |
+-------+---------------------------------+----------------------------+
|   2   | trim CRLF                       | "POST /api HTTP/1.1"       |
+-------+---------------------------------+----------------------------+
|   3   | split(' ')                      | ["POST", "/api", "HTTP/1.1"]|
+-------+---------------------------------+----------------------------+
|   4   | HttpMethod::from_str("POST")    | method = POST              |
+-------+---------------------------------+----------------------------+
|   5   | uri = "/api"                    | uri = "/api"               |
+-------+---------------------------------+----------------------------+
|   6   | HttpVersion::from_str("HTTP/1.1")| version = Http11          |
+-------+---------------------------------+----------------------------+
|   7   | read_line() -> "Host: localhost"| header: host=localhost     |
+-------+---------------------------------+----------------------------+
|   8   | read_line() -> "Content-Length: 5"| header: content-length=5 |
+-------+---------------------------------+----------------------------+
|   9   | read_line() -> "" (empty)       | Fin des headers            |
+-------+---------------------------------+----------------------------+
|  10   | content-length = 5              | body_size = 5              |
+-------+---------------------------------+----------------------------+
|  11   | read_exact(5)                   | body = b"hello"            |
+-------+---------------------------------+----------------------------+
|  12   | Retourne HttpRequest            | Parsing complet            |
+-------+---------------------------------+----------------------------+
```

### 5.8 Mnemoniques

#### "MORPHEUS" = Methods Origin Response Protocol Headers Encoding URI Status

L'ordre de parsing d'une requete HTTP :
1. **M**ethod (GET, POST...)
2. **O**rigin (via Host header)
3. **R**equest-line complete
4. **P**rotocol version (HTTP/1.1)
5. **H**eaders (tous)
6. **E**ncoding (Content-Length ou chunked)
7. **U**RI (le chemin demande)
8. **S**tatus check (validation)

#### "There is no spoon" (The Matrix)

*"Le protocole HTTP n'existe pas vraiment. Ce que tu vois, ce sont des octets. Quand tu comprendras que les separateurs CRLF ne sont que des conventions, tu pourras parser n'importe quoi."*

Chaque caractere de controle (`\r\n`, `:`, ` `) est comme la cuillere de Matrix : une illusion qui structure la realite.

### 5.9 Applications pratiques

1. **API Gateway** : Routing de requetes HTTP vers les bons services
2. **CDN Edge** : Cache et transformation de contenu HTTP
3. **Security Scanner** : Analyse de requetes malformees (fuzzing)
4. **Protocol Debugger** : Wireshark, mitmproxy, Burp Suite

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Headers case-sensitive | `get_header("Host")` != `get_header("host")` | Normaliser en lowercase |
| 2 | LF au lieu de CRLF | Clients stricts rejettent | Toujours `\r\n` |
| 3 | Pas de Content-Length | Client attend indefiniment | Toujours l'inclure |
| 4 | Body tronque | Donnees incompletes | `read_exact()` |
| 5 | Keep-alive inverse | Connexions jamais fermees | Connaitre les defauts |

---

## SECTION 7 : QCM

### Question 1
**Quel est le terminateur de ligne standard en HTTP ?**

A) `\n` (LF seul)
B) `\r` (CR seul)
C) `\r\n` (CRLF)
D) `\n\r` (LFCR)
E) Aucun terminateur
F) `\0` (null)
G) Double espace
H) Tab
I) Point-virgule
J) Deux-points

**Reponse : C**

*Explication : HTTP exige CRLF (Carriage Return + Line Feed, `\r\n`) comme terminateur de ligne, heritage des anciens terminaux.*

---

### Question 2
**En HTTP/1.1, quel est le comportement par defaut pour les connexions ?**

A) close (fermer apres chaque requete)
B) keep-alive (maintenir la connexion)
C) Depend du serveur
D) Depend du client
E) Toujours timeout apres 30s
F) Pas de comportement defini
G) Upgrade vers HTTP/2
H) Redirect vers HTTPS
I) Reset TCP
J) Chunked encoding

**Reponse : B**

*Explication : HTTP/1.1 utilise keep-alive par defaut. Pour fermer, il faut envoyer `Connection: close`. C'est l'inverse en HTTP/1.0.*

---

### Question 3
**Pourquoi le header Host est-il obligatoire en HTTP/1.1 ?**

A) Pour le chiffrement TLS
B) Pour le virtual hosting (plusieurs sites sur une IP)
C) Pour la compression
D) Pour l'authentification
E) Pour le cache
F) Pour les cookies
G) Pour le load balancing
H) Pour les redirections
I) Pour le chunked encoding
J) C'est une convention, pas obligatoire

**Reponse : B**

*Explication : Le header Host permet au serveur de distinguer plusieurs sites heberges sur la meme adresse IP (virtual hosting).*

---

### Question 4
**Comment determiner la taille du body dans une requete HTTP ?**

A) Toujours fixe (1024 bytes)
B) Via le header Content-Length
C) Via Transfer-Encoding: chunked
D) B ou C selon le cas
E) Lecture jusqu'a EOF
F) Via le header Body-Size
G) Via le status code
H) Calcule automatiquement
I) Via le header Accept-Length
J) Depend de la methode HTTP

**Reponse : D**

*Explication : Le body peut etre de taille connue (Content-Length) ou inconnue a l'avance (Transfer-Encoding: chunked).*

---

### Question 5
**Quel code de statut HTTP indique "ressource non trouvee" ?**

A) 200
B) 201
C) 301
D) 400
E) 404
F) 405
G) 500
H) 502
I) 503
J) 418

**Reponse : E**

*Explication : 404 Not Found indique que la ressource demandee n'existe pas sur le serveur.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | http_parser |
| **Module** | 5.1.4 - Application Layer Protocols (HTTP) |
| **Difficulte** | 8/10 (++++++++--) |
| **Temps estime** | 180 min |
| **XP** | 225 (base) + bonus x3 |
| **Concepts cles** | HTTP/1.1, parsing, serialisation, keep-alive, chunked |
| **Piege principal** | Headers case-insensitive |
| **Prerequis valide** | TCP, async I/O, tokio |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.4-a-http-parser",
    "generated_at": "2025-01-16T12:00:00Z",

    "metadata": {
      "exercise_id": "5.1.4-a",
      "exercise_name": "http_parser",
      "module": "5.1.4",
      "module_name": "Application Layer Protocols (HTTP)",
      "concept": "a",
      "concept_name": "HTTP/1.1 Request/Response Parser & Server",
      "type": "code",
      "tier": 2,
      "tier_info": "Concept composite",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "++++++++--",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 225,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.4", "5.1.2", "2.7"],
      "domains": ["Net", "Parsing", "Algo"],
      "domains_bonus": ["Parsing", "Algo"],
      "tags": ["networking", "http", "parsing", "web", "async"],
      "meme_reference": "There is no spoon (The Matrix)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_parsing.rs": "/* Section 4.10 */",
      "mutants/mutant_b_protocol.rs": "/* Section 4.10 */",
      "mutants/mutant_c_body.rs": "/* Section 4.10 */",
      "mutants/mutant_d_serialisation.rs": "/* Section 4.10 */",
      "mutants/mutant_e_keepalive.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_parsing.rs",
        "mutants/mutant_b_protocol.rs",
        "mutants/mutant_c_body.rs",
        "mutants/mutant_d_serialisation.rs",
        "mutants/mutant_e_keepalive.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no spoon"*
*Exercise Quality Score: 97/100*
