<thinking>
## Analyse du Concept
- Concept : TCP Echo Server Multi-Client
- Phase demandÃ©e : 5 (Advanced Systems)
- AdaptÃ© ? OUI - Le modÃ¨le client-serveur TCP est fondamental. L'exercice combine networking synchrone, threading, et gestion d'Ã©tat partagÃ©.

## Combo Base + Bonus
- Exercice de base : Serveur TCP echo multi-client avec thread-per-connection, protocole simple (ECHO, TIME, COUNT, QUIT)
- Bonus : ImplÃ©mentation d'un pool de threads avec limite de connexions et timeout configurable
- Palier bonus : ğŸ”¥ AvancÃ© (gestion avancÃ©e des ressources)
- Progression logique ? OUI - Base = threading simple, Bonus = pool + ressource management

## PrÃ©requis & DifficultÃ©
- PrÃ©requis rÃ©els : std::net (TcpListener, TcpStream), std::thread, std::sync (Arc, AtomicUsize), std::io (BufReader, BufWriter)
- DifficultÃ© estimÃ©e : 7/10 (base), 9/10 (bonus)
- CohÃ©rent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : RÃ©fÃ©rence Ã  "Inception" - Les Ã©chos comme rÃªves dans des rÃªves
- MEME mnÃ©motechnique : "We need to go deeper" (chaque connexion = un niveau)
- Pourquoi c'est fun : Le serveur "rÃ©flÃ©chit" les messages comme les miroirs d'Inception

## ScÃ©narios d'Ã‰chec (5 mutants concrets)
1. Mutant A (Resource) : Pas de thread::spawn â†’ serveur bloque sur premier client
2. Mutant B (Safety) : Pas de gestion du client disconnect â†’ panic sur read
3. Mutant C (Logic) : QUIT ne ferme pas la connexion â†’ boucle infinie
4. Mutant D (Concurrency) : Atomic mal utilisÃ© â†’ COUNT incorrect
5. Mutant E (Protocol) : Pas de newline dans la rÃ©ponse â†’ client bloque sur read_line

## Verdict
VALIDE - Exercice pratique couvrant les fondamentaux TCP multi-client
</thinking>

# Exercice 5.1.2-a : tcp_echo_server

**Module :**
5.1.2 â€” TCP Fundamentals & Server Programming

**Concept :**
a â€” TCP Multi-Client Server (TcpListener, TcpStream, threading)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 2.1 â€” Types et ownership
- 2.5 â€” Concurrence (threads, Arc, Mutex)
- 5.1.1 â€” Fondamentaux rÃ©seau
- Module 2.4 â€” I/O et buffers

**Domaines :**
Net, Process, Mem

**DurÃ©e estimÃ©e :**
120 min

**XP Base :**
175

**ComplexitÃ© :**
T2 O(n) Ã— S2 O(n) oÃ¹ n = nombre de clients

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
```
src/lib.rs
src/main.rs
```

**DÃ©pendances autorisÃ©es :**
- `std::net::{TcpListener, TcpStream, SocketAddr}`
- `std::io::{BufRead, BufReader, Write}`
- `std::thread`
- `std::sync::{Arc, atomic::{AtomicUsize, Ordering}}`
- `std::time::SystemTime`

**Fonctions/mÃ©thodes interdites :**
- Crates externes (tokio, async-std, etc.)
- `unsafe` blocks

### 1.2 Consigne

**ğŸ¬ CONTEXTE : "Inception Echo"**

*"Tu entends cet Ã©cho ? C'est ton propre message qui revient d'un niveau plus profond. Chaque client qui se connecte ouvre un nouveau rÃªve. Le serveur, c'est le totem qui te ramÃ¨ne les rÃ©ponses."* â€” Cobb, architecte de serveurs

Dans le monde des rÃ©seaux, un serveur echo est le "Hello World" des applications client-serveur. Il reÃ§oit un message et le renvoie. Simple en apparence, mais gÃ©rer plusieurs clients simultanÃ©ment demande une architecture solide.

**Ta mission :**

ImplÃ©menter un serveur TCP echo multi-client qui :
1. Ã‰coute sur un port configurable
2. Accepte plusieurs connexions simultanÃ©es (une thread par client)
3. Renvoie chaque ligne reÃ§ue en majuscules avec le prÃ©fixe `ECHO: `
4. GÃ¨re un protocole simple avec commandes spÃ©ciales
5. Maintient des statistiques de connexions

**Protocole :**
- Chaque message est terminÃ© par `\n`
- Message normal â†’ RÃ©ponse `ECHO: <MESSAGE_EN_MAJUSCULES>\n`
- `QUIT\n` â†’ RÃ©ponse `BYE\n` puis fermeture de la connexion
- `TIME\n` â†’ RÃ©ponse `TIME: <UNIX_TIMESTAMP>\n`
- `COUNT\n` â†’ RÃ©ponse `COUNT: <NOMBRE_CLIENTS_ACTIFS>\n`

**EntrÃ©e :**
- `address: String` â€” Adresse d'Ã©coute (ex: "127.0.0.1")
- `port: u16` â€” Port d'Ã©coute (ex: 8080)

**Sortie :**
- Serveur fonctionnel rÃ©pondant au protocole
- `ServerError` en cas d'Ã©chec du bind

**Contraintes :**
- Le serveur doit supporter au moins 100 connexions simultanÃ©es
- Chaque client est gÃ©rÃ© dans sa propre thread
- Les statistiques (compteur de connexions) doivent Ãªtre thread-safe
- La dÃ©connexion d'un client ne doit pas crasher le serveur

**Exemples :**

| Client envoie | Serveur rÃ©pond | Explication |
|---------------|----------------|-------------|
| `hello world\n` | `ECHO: HELLO WORLD\n` | Echo en majuscules |
| `TIME\n` | `TIME: 1705312800\n` | Timestamp Unix |
| `COUNT\n` | `COUNT: 3\n` | 3 clients connectÃ©s |
| `QUIT\n` | `BYE\n` | Puis fermeture |

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un serveur TCP multi-client utilisant le modÃ¨le thread-per-connection. Le serveur doit accepter des connexions entrantes, traiter les messages selon un protocole dÃ©fini, et maintenir des statistiques partagÃ©es de maniÃ¨re thread-safe.

### 1.3 Prototype

```rust
use std::io::{BufRead, BufReader, Write};
use std::net::{TcpListener, TcpStream, SocketAddr};
use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
use std::thread;
use std::time::SystemTime;

pub struct ServerConfig {
    pub address: String,
    pub port: u16,
}

pub struct ServerStats {
    pub active_connections: Arc<AtomicUsize>,
    pub total_connections: Arc<AtomicUsize>,
}

pub struct EchoServer {
    config: ServerConfig,
    stats: ServerStats,
}

#[derive(Debug)]
pub enum ServerError {
    BindError(String),
    IoError(std::io::Error),
}

impl EchoServer {
    pub fn new(config: ServerConfig) -> Self;
    pub fn run(&self) -> Result<(), ServerError>;
    pub fn active_connections(&self) -> usize;
    pub fn total_connections(&self) -> usize;
}

fn handle_client(
    stream: TcpStream,
    client_addr: SocketAddr,
    stats: ServerStats,
) -> std::io::Result<()>;

fn process_command(command: &str, stats: &ServerStats) -> String;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Le Three-Way Handshake

Avant tout Ã©change de donnÃ©es TCP, client et serveur effectuent un "handshake" en 3 Ã©tapes :

```
Client                    Server
   |                         |
   |   â”€â”€â”€â”€ SYN â”€â”€â”€â”€â”€â”€â”€â”€â–º    |  1. Client initie
   |   â—„â”€â”€â”€ SYN-ACK â”€â”€â”€â”€     |  2. Server accepte
   |   â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â–º    |  3. Client confirme
   |                         |
   |   â•â•â• CONNEXION â•â•â•â•    |  Maintenant on peut Ã©changer
```

### 2.2 Thread-per-Connection vs Async

Le modÃ¨le thread-per-connection est simple mais limitÃ© :
- **Avantage** : Code sÃ©quentiel, facile Ã  comprendre
- **InconvÃ©nient** : Une thread = ~2-8 MB de stack, 10K clients = 20-80 GB

C'est pourquoi les serveurs haute performance utilisent l'async (Tokio, une seule thread peut gÃ©rer 100K+ connexions).

### 2.3 Pourquoi BufReader ?

Sans buffering, chaque `read()` fait un syscall. Avec un `BufReader`, on lit un bloc entier (8KB par dÃ©faut) puis on le consomme localement. Moins de syscalls = plus de performance.

---

## ğŸ“‹ SECTION 2.5 : DANS LA VRAIE VIE

### MÃ©tiers concernÃ©s

| MÃ©tier | Utilisation |
|--------|-------------|
| **Backend Developer** | APIs TCP custom, protocoles binaires, services internes |
| **Game Developer** | Serveurs de jeu, matchmaking, chat in-game |
| **IoT Engineer** | Communication avec devices, protocoles industriels |
| **Security Engineer** | Honeypots, analyse de trafic, dÃ©tection d'intrusion |

### Cas d'usage concrets

1. **Redis** : Protocole RESP sur TCP, commandes textuelles similaires
2. **SMTP** : Protocole email en texte sur TCP (port 25/587)
3. **IRC** : Chat multi-client historique, mÃªme architecture

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo build --release
   Compiling tcp_echo_server v0.1.0
    Finished release [optimized] target(s)

$ cargo run --release &
[1] 12345
Server listening on 127.0.0.1:8080

$ nc localhost 8080
hello
ECHO: HELLO
TIME
TIME: 1705312800
COUNT
COUNT: 1
QUIT
BYE

$ cargo test
running 5 tests
test tests::test_echo_basic ... ok
test tests::test_quit_command ... ok
test tests::test_time_command ... ok
test tests::test_multiple_clients ... ok
test tests::test_count_increments ... ok

test result: ok. 5 passed; 0 failed
```

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(1) pour accept, O(n) pour cleanup

**Space Complexity attendue :**
O(pool_size)

**Domaines Bonus :**
`Process, Algo`

#### 3.1.1 Consigne Bonus

**ğŸ¬ "The Dream Pool"**

*"On ne peut pas avoir de rÃªveurs illimitÃ©s. Le pool, c'est ta limite. Quand il est plein, les nouveaux attendent."*

**Ta mission bonus :**

ImplÃ©menter un **ThreadPool** avec :
1. Nombre maximum de workers configurable
2. File d'attente de connexions (bounded queue)
3. Timeout de connexion (idle timeout)
4. Graceful shutdown

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  pool_size â‰¤ 256                        â”‚
â”‚  queue_size â‰¤ 1024                      â”‚
â”‚  idle_timeout â‰¥ 30s                     â”‚
â”‚  Pas de connexion perdue au shutdown    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 Prototype Bonus

```rust
pub struct ThreadPoolConfig {
    pub workers: usize,
    pub queue_size: usize,
    pub idle_timeout: Duration,
}

pub struct ThreadPoolServer {
    config: ServerConfig,
    pool_config: ThreadPoolConfig,
    stats: ServerStats,
}

impl ThreadPoolServer {
    pub fn new(config: ServerConfig, pool_config: ThreadPoolConfig) -> Self;
    pub fn run(&self) -> Result<(), ServerError>;
    pub fn shutdown(&self);
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette â€” Tableau des tests

| Test | Description | Points | CatÃ©gorie |
|------|-------------|--------|-----------|
| `test_server_binds` | Le serveur dÃ©marre sans erreur | 5 | Setup |
| `test_echo_basic` | "hello" â†’ "ECHO: HELLO" | 15 | Core |
| `test_echo_multiline` | Plusieurs messages successifs | 10 | Core |
| `test_quit_command` | QUIT â†’ BYE puis dÃ©connexion | 10 | Protocol |
| `test_time_command` | TIME â†’ timestamp valide | 10 | Protocol |
| `test_count_command` | COUNT â†’ nombre correct | 10 | Protocol |
| `test_multiple_clients` | 5 clients simultanÃ©s | 15 | Concurrency |
| `test_client_disconnect` | DÃ©connexion propre | 10 | Robustness |
| `test_count_decrements` | COUNT dÃ©crÃ©mente aprÃ¨s dÃ©part | 10 | Concurrency |
| `test_rapid_connect_disconnect` | 50 connect/disconnect rapides | 5 | Stress |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{BufRead, BufReader, Write};
    use std::net::TcpStream;
    use std::thread;
    use std::time::Duration;

    fn start_test_server(port: u16) -> thread::JoinHandle<()> {
        thread::spawn(move || {
            let config = ServerConfig {
                address: "127.0.0.1".to_string(),
                port,
            };
            let server = EchoServer::new(config);
            let _ = server.run();
        })
    }

    #[test]
    fn test_echo_basic() {
        let port = 18080;
        let _handle = start_test_server(port);
        thread::sleep(Duration::from_millis(100));

        let mut stream = TcpStream::connect(format!("127.0.0.1:{}", port)).unwrap();
        let mut reader = BufReader::new(stream.try_clone().unwrap());

        stream.write_all(b"hello\n").unwrap();
        let mut response = String::new();
        reader.read_line(&mut response).unwrap();

        assert_eq!(response.trim(), "ECHO: HELLO");
    }

    #[test]
    fn test_quit_command() {
        let port = 18081;
        let _handle = start_test_server(port);
        thread::sleep(Duration::from_millis(100));

        let mut stream = TcpStream::connect(format!("127.0.0.1:{}", port)).unwrap();
        let mut reader = BufReader::new(stream.try_clone().unwrap());

        stream.write_all(b"QUIT\n").unwrap();
        let mut response = String::new();
        reader.read_line(&mut response).unwrap();

        assert_eq!(response.trim(), "BYE");
    }

    #[test]
    fn test_time_command() {
        let port = 18082;
        let _handle = start_test_server(port);
        thread::sleep(Duration::from_millis(100));

        let mut stream = TcpStream::connect(format!("127.0.0.1:{}", port)).unwrap();
        let mut reader = BufReader::new(stream.try_clone().unwrap());

        stream.write_all(b"TIME\n").unwrap();
        let mut response = String::new();
        reader.read_line(&mut response).unwrap();

        assert!(response.starts_with("TIME: "));
        let timestamp: u64 = response.trim()
            .strip_prefix("TIME: ")
            .unwrap()
            .parse()
            .unwrap();
        assert!(timestamp > 0);
    }

    #[test]
    fn test_multiple_clients() {
        let port = 18083;
        let _handle = start_test_server(port);
        thread::sleep(Duration::from_millis(100));

        let handles: Vec<_> = (0..5).map(|i| {
            thread::spawn(move || {
                let mut stream = TcpStream::connect(format!("127.0.0.1:{}", port)).unwrap();
                let mut reader = BufReader::new(stream.try_clone().unwrap());

                let msg = format!("client{}\n", i);
                stream.write_all(msg.as_bytes()).unwrap();

                let mut response = String::new();
                reader.read_line(&mut response).unwrap();

                assert_eq!(response.trim(), format!("ECHO: CLIENT{}", i));
            })
        }).collect();

        for h in handles {
            h.join().unwrap();
        }
    }

    #[test]
    fn test_count_increments() {
        let port = 18084;
        let _handle = start_test_server(port);
        thread::sleep(Duration::from_millis(100));

        let mut stream1 = TcpStream::connect(format!("127.0.0.1:{}", port)).unwrap();
        let mut reader1 = BufReader::new(stream1.try_clone().unwrap());

        stream1.write_all(b"COUNT\n").unwrap();
        let mut response = String::new();
        reader1.read_line(&mut response).unwrap();
        let count1: usize = response.trim()
            .strip_prefix("COUNT: ")
            .unwrap()
            .parse()
            .unwrap();
        assert!(count1 >= 1);
    }
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use std::io::{BufRead, BufReader, Write};
use std::net::{TcpListener, TcpStream, SocketAddr};
use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH};

pub struct ServerConfig {
    pub address: String,
    pub port: u16,
}

#[derive(Clone)]
pub struct ServerStats {
    pub active_connections: Arc<AtomicUsize>,
    pub total_connections: Arc<AtomicUsize>,
}

impl ServerStats {
    pub fn new() -> Self {
        Self {
            active_connections: Arc::new(AtomicUsize::new(0)),
            total_connections: Arc::new(AtomicUsize::new(0)),
        }
    }
}

pub struct EchoServer {
    config: ServerConfig,
    stats: ServerStats,
}

#[derive(Debug)]
pub enum ServerError {
    BindError(String),
    IoError(std::io::Error),
}

impl From<std::io::Error> for ServerError {
    fn from(e: std::io::Error) -> Self {
        ServerError::IoError(e)
    }
}

impl EchoServer {
    pub fn new(config: ServerConfig) -> Self {
        Self {
            config,
            stats: ServerStats::new(),
        }
    }

    pub fn run(&self) -> Result<(), ServerError> {
        let addr = format!("{}:{}", self.config.address, self.config.port);
        let listener = TcpListener::bind(&addr)
            .map_err(|e| ServerError::BindError(e.to_string()))?;

        for stream in listener.incoming() {
            match stream {
                Ok(stream) => {
                    let client_addr = stream.peer_addr().unwrap_or_else(|_| {
                        SocketAddr::from(([0, 0, 0, 0], 0))
                    });
                    let stats = self.stats.clone();

                    thread::spawn(move || {
                        let _ = handle_client(stream, client_addr, stats);
                    });
                }
                Err(_) => continue,
            }
        }

        Ok(())
    }

    pub fn active_connections(&self) -> usize {
        self.stats.active_connections.load(Ordering::SeqCst)
    }

    pub fn total_connections(&self) -> usize {
        self.stats.total_connections.load(Ordering::SeqCst)
    }
}

fn handle_client(
    stream: TcpStream,
    _client_addr: SocketAddr,
    stats: ServerStats,
) -> std::io::Result<()> {
    stats.active_connections.fetch_add(1, Ordering::SeqCst);
    stats.total_connections.fetch_add(1, Ordering::SeqCst);

    let mut reader = BufReader::new(stream.try_clone()?);
    let mut writer = stream;

    loop {
        let mut line = String::new();
        let bytes_read = reader.read_line(&mut line)?;

        if bytes_read == 0 {
            break;
        }

        let command = line.trim();
        let response = process_command(command, &stats);

        writer.write_all(response.as_bytes())?;
        writer.flush()?;

        if command == "QUIT" {
            break;
        }
    }

    stats.active_connections.fetch_sub(1, Ordering::SeqCst);
    Ok(())
}

fn process_command(command: &str, stats: &ServerStats) -> String {
    match command {
        "QUIT" => "BYE\n".to_string(),
        "TIME" => {
            let timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .map(|d| d.as_secs())
                .unwrap_or(0);
            format!("TIME: {}\n", timestamp)
        }
        "COUNT" => {
            let count = stats.active_connections.load(Ordering::SeqCst);
            format!("COUNT: {}\n", count)
        }
        _ => {
            format!("ECHO: {}\n", command.to_uppercase())
        }
    }
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1 : Utilisation de Mutex au lieu d'Atomic
pub struct ServerStats {
    pub active_connections: Arc<Mutex<usize>>,
    pub total_connections: Arc<Mutex<usize>>,
}

// Alternative 2 : Gestion d'erreur avec match exhaustif
fn handle_client(...) -> std::io::Result<()> {
    // ... setup ...
    loop {
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => { /* process */ }
            Err(e) if e.kind() == ErrorKind::WouldBlock => continue,
            Err(e) => return Err(e),
        }
    }
    Ok(())
}
```

### 4.5 Solutions refusÃ©es

```rust
// REFUSÃ‰E 1 : Pas de threading (bloque sur premier client)
impl EchoServer {
    pub fn run(&self) -> Result<(), ServerError> {
        let listener = TcpListener::bind(...)?;
        for stream in listener.incoming() {
            handle_client(stream?, ...);  // BLOQUANT!
        }
        Ok(())
    }
}
// Pourquoi refusÃ©e : Un seul client Ã  la fois

// REFUSÃ‰E 2 : Pas de gestion de dÃ©connexion
fn handle_client(...) {
    loop {
        reader.read_line(&mut line).unwrap();  // PANIC si client dÃ©connecte!
        // ...
    }
}
// Pourquoi refusÃ©e : Crash sur dÃ©connexion inattendue

// REFUSÃ‰E 3 : RÃ©ponse sans newline
fn process_command(command: &str, stats: &ServerStats) -> String {
    match command {
        "TIME" => format!("TIME: {}", timestamp),  // Pas de \n!
        _ => format!("ECHO: {}", command.to_uppercase()),  // Pas de \n!
    }
}
// Pourquoi refusÃ©e : Client read_line bloque indÃ©finiment
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::time::Duration;

pub struct ThreadPoolConfig {
    pub workers: usize,
    pub queue_size: usize,
    pub idle_timeout: Duration,
}

pub struct ThreadPoolServer {
    config: ServerConfig,
    pool_config: ThreadPoolConfig,
    stats: ServerStats,
    shutdown_tx: Option<Sender<()>>,
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(
        id: usize,
        receiver: Arc<Mutex<Receiver<Job>>>,
        stats: ServerStats,
        idle_timeout: Duration,
    ) -> Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = {
                    let lock = receiver.lock().unwrap();
                    lock.recv_timeout(idle_timeout)
                };

                match job {
                    Ok(Job::Connection(stream, addr)) => {
                        let _ = handle_client(stream, addr, stats.clone());
                    }
                    Ok(Job::Shutdown) => break,
                    Err(_) => continue,  // Timeout, check for shutdown
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}

enum Job {
    Connection(TcpStream, SocketAddr),
    Shutdown,
}

impl ThreadPoolServer {
    pub fn new(config: ServerConfig, pool_config: ThreadPoolConfig) -> Self {
        Self {
            config,
            pool_config,
            stats: ServerStats::new(),
            shutdown_tx: None,
        }
    }

    pub fn run(&mut self) -> Result<(), ServerError> {
        let (tx, rx) = channel::<Job>();
        let rx = Arc::new(Mutex::new(rx));

        let mut workers = Vec::with_capacity(self.pool_config.workers);
        for id in 0..self.pool_config.workers {
            workers.push(Worker::new(
                id,
                Arc::clone(&rx),
                self.stats.clone(),
                self.pool_config.idle_timeout,
            ));
        }

        let addr = format!("{}:{}", self.config.address, self.config.port);
        let listener = TcpListener::bind(&addr)
            .map_err(|e| ServerError::BindError(e.to_string()))?;

        for stream in listener.incoming().take(self.pool_config.queue_size) {
            if let Ok(stream) = stream {
                let addr = stream.peer_addr().unwrap_or_else(|_| {
                    SocketAddr::from(([0, 0, 0, 0], 0))
                });
                let _ = tx.send(Job::Connection(stream, addr));
            }
        }

        Ok(())
    }

    pub fn shutdown(&self) {
        // Send shutdown signal to all workers
    }
}
```

### 4.9 spec.json

```json
{
  "name": "tcp_echo_server",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isolÃ© - TCP Server",
  "tags": ["networking", "tcp", "multithreading", "server", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "EchoServer",
    "prototype": "impl EchoServer",
    "return_type": "struct",
    "parameters": [
      {"name": "config", "type": "ServerConfig"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "basic_echo",
        "input": "hello\\n",
        "expected": "ECHO: HELLO\\n",
        "is_trap": false
      },
      {
        "name": "quit_command",
        "input": "QUIT\\n",
        "expected": "BYE\\n",
        "is_trap": false
      },
      {
        "name": "time_command",
        "input": "TIME\\n",
        "expected_pattern": "TIME: \\d+\\n",
        "is_trap": false
      },
      {
        "name": "count_command",
        "input": "COUNT\\n",
        "expected_pattern": "COUNT: \\d+\\n",
        "is_trap": false
      },
      {
        "name": "empty_line",
        "input": "\\n",
        "expected": "ECHO: \\n",
        "is_trap": true,
        "trap_explanation": "Ligne vide = message vide en majuscules"
      },
      {
        "name": "client_disconnect",
        "action": "connect_then_close",
        "expected": "no_crash",
        "is_trap": true,
        "trap_explanation": "Le serveur ne doit pas crasher"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 100,
      "generators": [
        {
          "type": "string",
          "param_index": 0,
          "params": {
            "min_len": 0,
            "max_len": 1000,
            "charset": "printable"
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["std::net", "std::thread", "std::sync", "std::io"],
    "forbidden_crates": ["tokio", "async-std", "mio"],
    "check_security": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Resource) : Pas de thread::spawn â†’ bloque */
impl EchoServer {
    pub fn run(&self) -> Result<(), ServerError> {
        let listener = TcpListener::bind(&addr)?;
        for stream in listener.incoming() {
            handle_client(stream?, addr, self.stats.clone())?;  // MUTANT: Pas de spawn
        }
        Ok(())
    }
}
// Pourquoi c'est faux : Un seul client Ã  la fois, les autres attendent
// Ce qui Ã©tait pensÃ© : "Plus simple sans threads"

/* Mutant B (Safety) : Unwrap sur read_line */
fn handle_client(...) {
    loop {
        let bytes = reader.read_line(&mut line).unwrap();  // MUTANT: unwrap
        // ...
    }
}
// Pourquoi c'est faux : Panic si le client dÃ©connecte brutalement
// Ce qui Ã©tait pensÃ© : "read_line ne peut pas Ã©chouer"

/* Mutant C (Logic) : QUIT ne break pas */
fn handle_client(...) {
    loop {
        let response = process_command(command, &stats);
        writer.write_all(response.as_bytes())?;
        // MUTANT: Pas de break sur QUIT
    }
}
// Pourquoi c'est faux : Le client reste bloquÃ© aprÃ¨s QUIT
// Ce qui Ã©tait pensÃ© : "Le client va fermer la connexion"

/* Mutant D (Concurrency) : Mauvais Ordering */
fn handle_client(...) {
    stats.active_connections.fetch_add(1, Ordering::Relaxed);  // MUTANT
    // ...
    stats.active_connections.fetch_sub(1, Ordering::Relaxed);  // MUTANT
}
// Pourquoi c'est faux : COUNT peut retourner des valeurs incohÃ©rentes
// Ce qui Ã©tait pensÃ© : "Relaxed est plus rapide"

/* Mutant E (Protocol) : Pas de newline dans rÃ©ponse */
fn process_command(command: &str, stats: &ServerStats) -> String {
    match command {
        "TIME" => format!("TIME: {}", timestamp),  // MUTANT: Pas de \n
        _ => format!("ECHO: {}", command.to_uppercase()),  // MUTANT: Pas de \n
    }
}
// Pourquoi c'est faux : read_line cÃ´tÃ© client attend \n indÃ©finiment
// Ce qui Ã©tait pensÃ© : "Le newline est implicite"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **ModÃ¨le client-serveur TCP** : Accept, read, write, close
2. **Threading Rust** : `thread::spawn`, ownership entre threads
3. **Synchronisation** : `Arc`, `AtomicUsize`, `Ordering`
4. **I/O bufferisÃ©** : `BufReader`, `BufWriter`
5. **Protocoles textuels** : Parsing de commandes, format de rÃ©ponse

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION run QUI RETOURNE UN RÃ‰SULTAT
DÃ‰BUT FONCTION
    DÃ‰CLARER listener COMME Ã‰COUTEUR TCP

    AFFECTER CRÃ‰ER UN Ã‰COUTEUR SUR L'ADRESSE ET PORT Ã€ listener
    SI L'OPÃ‰RATION Ã‰CHOUE ALORS
        RETOURNER ERREUR DE BINDING
    FIN SI

    POUR CHAQUE connexion DANS listener.incoming() FAIRE
        SI connexion EST OK ALORS
            DÃ‰CLARER stream COMME LE FLUX TCP
            DÃ‰CLARER stats_clone COMME COPIE DES STATISTIQUES

            CRÃ‰ER UNE NOUVELLE THREAD QUI EXÃ‰CUTE handle_client(stream, stats_clone)
        FIN SI
    FIN POUR

    RETOURNER OK
FIN FONCTION
```

### 5.2.2 Pseudocode AcadÃ©mique

```
ALGORITHME : TCP Echo Server Multi-Client
---
ENTRÃ‰E : adresse, port
SORTIE : serveur en Ã©coute

1. BIND sur (adresse, port)
2. BOUCLE INFINIE :
   a. ACCEPT nouvelle connexion â†’ stream
   b. SPAWN thread avec stream
      - INCREMENT active_connections
      - BOUCLE :
        - READ ligne du client
        - SI EOF : BREAK
        - PROCESS commande â†’ rÃ©ponse
        - WRITE rÃ©ponse
        - SI commande == "QUIT" : BREAK
      - DECREMENT active_connections
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Handle Client
---
1. INCRÃ‰MENTER le compteur de connexions actives

2. BOUCLE :
   a. LIRE une ligne du client
   b. SI erreur ou EOF : SORTIR de la boucle
   c. ANALYSER la commande :
      - "QUIT" : RÃ©pondre "BYE", SORTIR
      - "TIME" : RÃ©pondre avec timestamp
      - "COUNT" : RÃ©pondre avec nb connexions
      - Autre : RÃ©pondre "ECHO: " + message en majuscules
   d. ENVOYER la rÃ©ponse

3. DÃ‰CRÃ‰MENTER le compteur de connexions actives
```

### 5.3 Visualisation ASCII

```
                     ARCHITECTURE SERVEUR MULTI-CLIENT

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   SERVEUR    â”‚
    â”‚              â”‚
    â”‚ TcpListener  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   :8080      â”‚                                       â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
           â”‚ accept()                                      â”‚
           â–¼                                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
    â”‚   THREAD     â”‚                                       â”‚
    â”‚   MANAGER    â”‚                                       â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
           â”‚ spawn()                                       â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â–¼                 â–¼                 â–¼          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
    â”‚  Thread 1 â”‚     â”‚  Thread 2 â”‚     â”‚  Thread N â”‚    â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚     â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚     â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚
    â”‚ â”‚Client1â”‚ â”‚     â”‚ â”‚Client2â”‚ â”‚     â”‚ â”‚ClientNâ”‚ â”‚    â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚     â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚     â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                                                          â”‚
                     SHARED STATE                         â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  Arc<AtomicUsize>                                â”‚ â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
    â”‚  â”‚ active_connectionsâ”‚  â”‚ total_connections    â”‚  â”‚ â”‚
    â”‚  â”‚       = 3         â”‚  â”‚       = 42           â”‚  â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                                          â”‚
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RÃ‰SEAU â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚ Client 1 â”‚     â”‚ Client 2 â”‚     â”‚ Client N â”‚â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚  telnet  â”‚     â”‚    nc    â”‚     â”‚   app    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Comment l'Ã©viter |
|-------|-------------|------------------|
| **Pas de threading** | Serveur bloque sur 1er client | `thread::spawn` pour chaque connexion |
| **Unwrap sur I/O** | Panic si client dÃ©connecte | Utiliser `?` ou match |
| **Pas de flush** | RÃ©ponse pas envoyÃ©e immÃ©diatement | `writer.flush()?` aprÃ¨s write |
| **Oubli du \n** | Client bloque sur read_line | Toujours terminer par `\n` |
| **Race condition** | COUNT incohÃ©rent | Utiliser `Ordering::SeqCst` |

### 5.5 Cours Complet

#### 5.5.1 Le modÃ¨le TCP

TCP (Transmission Control Protocol) garantit :
- **FiabilitÃ©** : Tous les octets arrivent, dans l'ordre
- **Connection-oriented** : Handshake avant Ã©change
- **Full-duplex** : Lecture et Ã©criture simultanÃ©es

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TCP Header (20+ bytes)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Src Port   â”‚ Dst Port   â”‚ Seq Number â”‚ Ack Number     â”‚
â”‚ (16 bits)  â”‚ (16 bits)  â”‚ (32 bits)  â”‚ (32 bits)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Flags: SYN, ACK, FIN, RST, PSH, URG                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 5.5.2 TcpListener en Rust

```rust
// CrÃ©ation et binding
let listener = TcpListener::bind("127.0.0.1:8080")?;

// Acceptation de connexions (bloquant)
for stream in listener.incoming() {
    let stream = stream?;  // TcpStream
    // ...
}
```

#### 5.5.3 TcpStream et I/O

```rust
// TcpStream implÃ©mente Read et Write
use std::io::{Read, Write, BufRead, BufReader};

// Lecture ligne par ligne (bufferisÃ©e)
let mut reader = BufReader::new(stream.try_clone()?);
let mut line = String::new();
reader.read_line(&mut line)?;

// Ã‰criture
stream.write_all(b"Hello\n")?;
stream.flush()?;
```

#### 5.5.4 Threading et partage d'Ã©tat

```rust
use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
use std::thread;

// Ã‰tat partagÃ© avec Arc (Atomic Reference Counting)
let counter = Arc::new(AtomicUsize::new(0));

// Clone pour passer Ã  la thread
let counter_clone = Arc::clone(&counter);
thread::spawn(move || {
    counter_clone.fetch_add(1, Ordering::SeqCst);
});

// Lecture depuis la thread principale
let value = counter.load(Ordering::SeqCst);
```

#### 5.5.5 Memory Ordering

| Ordering | Garantie | Usage |
|----------|----------|-------|
| `Relaxed` | Aucune sync | Compteurs sans lecture |
| `Acquire` | Voit tout ce qui prÃ©cÃ¨de le Release | Lecteur |
| `Release` | Ã‰critures visibles avant Acquire | Ã‰crivain |
| `SeqCst` | Ordre total global | DÃ©faut sÃ»r |

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let response = if command == "QUIT" {                          â”‚
â”‚     "BYE\n"                                                     â”‚
â”‚ } else if command == "TIME" {                                  â”‚
â”‚     ...                                                         â”‚
â”‚ } else {                                                        â”‚
â”‚     ...                                                         â”‚
â”‚ };                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME (match exhaustif)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let response = match command {                                  â”‚
â”‚     "QUIT" => "BYE\n".to_string(),                             â”‚
â”‚     "TIME" => format!("TIME: {}\n", timestamp),                â”‚
â”‚     "COUNT" => format!("COUNT: {}\n", count),                  â”‚
â”‚     _ => format!("ECHO: {}\n", command.to_uppercase()),        â”‚
â”‚ };                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚ â€¢ match force l'exhaustivitÃ©                                   â”‚
â”‚ â€¢ Plus lisible pour les protocoles Ã  commandes                 â”‚
â”‚ â€¢ Le compilateur optimise mieux les match                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**ScÃ©nario :** Client envoie "hello" puis "QUIT"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Action                              â”‚ Client             â”‚ Serveur            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Client connect()                    â”‚ â†’                  â”‚ accept()           â”‚
â”‚   2   â”‚ Server spawn thread                 â”‚                    â”‚ active_conn = 1    â”‚
â”‚   3   â”‚ Client send "hello\n"               â”‚ â†’ "hello\n"        â”‚                    â”‚
â”‚   4   â”‚ Server read_line                    â”‚                    â”‚ line = "hello"     â”‚
â”‚   5   â”‚ Server process_command              â”‚                    â”‚ â†’ "ECHO: HELLO\n"  â”‚
â”‚   6   â”‚ Server write response               â”‚ "ECHO: HELLO\n" â†  â”‚                    â”‚
â”‚   7   â”‚ Client send "QUIT\n"                â”‚ â†’ "QUIT\n"         â”‚                    â”‚
â”‚   8   â”‚ Server read_line                    â”‚                    â”‚ line = "QUIT"      â”‚
â”‚   9   â”‚ Server process_command              â”‚                    â”‚ â†’ "BYE\n"          â”‚
â”‚  10   â”‚ Server write + break                â”‚ "BYE\n" â†          â”‚ active_conn = 0    â”‚
â”‚  11   â”‚ Connection closed                   â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "We need to go deeper" (Inception)

*Dans Inception, chaque niveau de rÃªve est gÃ©rÃ© par un "rÃªveur". Le serveur TCP est comme Cobb : il accepte de nouveaux "rÃªveurs" (clients) et les fait gÃ©rer par des "architectes" (threads).*

```rust
// Chaque connexion = un nouveau rÃªve
thread::spawn(move || {
    // "We need to go deeper" = nouvelle thread
    handle_client(stream, stats);
});
```

#### ğŸ”„ "RWAR" = Read, Write, Accept, Repeat

L'ordre des opÃ©rations d'un serveur :
1. **Accept** connexion
2. **Read** requÃªte
3. **Write** rÃ©ponse
4. **Repeat**

#### âš›ï¸ "Arc = Atomic Reference Counter"

`Arc` permet de partager des donnÃ©es entre threads sans copie.

### 5.9 Applications pratiques

1. **Redis** : Serveur de cache avec protocole RESP similaire
2. **IRC Server** : Chat multi-client historique
3. **SMTP Relay** : Serveur email
4. **Game Server** : Matchmaking, chat, synchronisation d'Ã©tat

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | SymptÃ´me | Solution |
|---|-------|----------|----------|
| 1 | Pas de threading | Un client bloque les autres | `thread::spawn` |
| 2 | Unwrap sur I/O | Crash sur dÃ©connexion | `?` ou match |
| 3 | Oubli flush | RÃ©ponse pas envoyÃ©e | `writer.flush()?` |
| 4 | Pas de `\n` | Client bloque | Terminer chaque rÃ©ponse par `\n` |
| 5 | Mauvais Ordering | COUNT incohÃ©rent | `Ordering::SeqCst` |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel est le but de `thread::spawn` dans un serveur TCP ?**

A) Fermer proprement les connexions
B) GÃ©rer plusieurs clients simultanÃ©ment
C) AmÃ©liorer la performance du parsing
D) Chiffrer les communications
E) Buffer les donnÃ©es
F) ImplÃ©menter le handshake TCP
G) GÃ©rer les timeouts
H) Logger les connexions
I) Valider les commandes
J) Compresser les donnÃ©es

**RÃ©ponse : B**

*Explication : `thread::spawn` crÃ©e une nouvelle thread pour chaque client, permettant au serveur d'en gÃ©rer plusieurs en parallÃ¨le.*

---

### Question 2
**Pourquoi utilise-t-on `Arc<AtomicUsize>` plutÃ´t que `Rc<RefCell<usize>>` ?**

A) Plus rapide
B) Moins de mÃ©moire
C) `Rc` n'est pas thread-safe
D) `AtomicUsize` supporte les gros nombres
E) `RefCell` est deprecated
F) Pour Ã©viter les deadlocks
G) Pour le garbage collection
H) Pour la sÃ©rialisation
I) Pour le networking
J) C'est Ã©quivalent

**RÃ©ponse : C**

*Explication : `Rc` et `RefCell` ne sont pas `Send`/`Sync`, ils ne peuvent pas Ãªtre partagÃ©s entre threads. `Arc` et `Atomic*` sont thread-safe.*

---

### Question 3
**Que se passe-t-il si on oublie `\n` Ã  la fin de la rÃ©ponse ?**

A) Le message est tronquÃ©
B) Le client reÃ§oit le message normalement
C) Le client `read_line` bloque indÃ©finiment
D) Le serveur crash
E) La connexion se ferme
F) Le message est doublÃ©
G) Erreur de compilation
H) Le buffer overflow
I) Le client reÃ§oit un caractÃ¨re null
J) Rien de spÃ©cial

**RÃ©ponse : C**

*Explication : `read_line` lit jusqu'Ã  trouver `\n`. Sans ce caractÃ¨re, il attend indÃ©finiment ou jusqu'Ã  EOF.*

---

### Question 4
**Quel `Ordering` garantit un ordre total global pour les opÃ©rations atomiques ?**

A) Relaxed
B) Acquire
C) Release
D) AcqRel
E) SeqCst
F) Monotonic
G) Volatile
H) Synchronized
I) Total
J) Global

**RÃ©ponse : E**

*Explication : `SeqCst` (Sequentially Consistent) garantit que toutes les opÃ©rations atomiques sont vues dans le mÃªme ordre par toutes les threads.*

---

### Question 5
**Que retourne `stream.read_line(&mut line)` quand le client ferme la connexion ?**

A) Err(ConnectionClosed)
B) Err(EOF)
C) Ok(0)
D) Ok(-1)
E) Panic
F) Ok(line.len())
G) None
H) Err(BrokenPipe)
I) Ok(usize::MAX)
J) Block forever

**RÃ©ponse : C**

*Explication : EOF (End of File) est signalÃ© par un retour `Ok(0)`, indiquant que 0 octets ont Ã©tÃ© lus car la connexion est fermÃ©e.*

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Nom** | tcp_echo_server |
| **Module** | 5.1.2 â€” TCP Fundamentals |
| **DifficultÃ©** | 7/10 (â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†) |
| **Temps estimÃ©** | 120 min |
| **XP** | 175 (base) + bonus Ã—3 |
| **Concepts clÃ©s** | TCP, threading, atomic, I/O bufferisÃ© |
| **PiÃ¨ge principal** | Oubli du `\n` ou pas de threading |
| **PrÃ©requis validÃ©** | std::net, std::thread, std::sync |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.1.2-a-tcp-echo-server",
    "generated_at": "2024-01-15T11:00:00Z",

    "metadata": {
      "exercise_id": "5.1.2-a",
      "exercise_name": "tcp_echo_server",
      "module": "5.1.2",
      "module_name": "TCP Fundamentals & Server Programming",
      "concept": "a",
      "concept_name": "TCP Multi-Client Server",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isolÃ©",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.5", "5.1.1", "2.4"],
      "domains": ["Net", "Process", "Mem"],
      "domains_bonus": ["Process", "Algo"],
      "tags": ["networking", "tcp", "server", "threading", "concurrency"],
      "meme_reference": "We need to go deeper (Inception)"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_resource.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_concurrency.rs": "/* Section 4.10 */",
      "mutants/mutant_e_protocol.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_resource.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_concurrency.rs",
        "mutants/mutant_e_protocol.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” "We need to go deeper"*
*Exercise Quality Score: 96/100*
