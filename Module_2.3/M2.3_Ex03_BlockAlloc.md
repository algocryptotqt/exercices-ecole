# Ex03: BlockAlloc - Block Allocation Strategies

## Concepts couverts
- 2.3.8.c (Contiguous allocation: Sequential blocks)
- 2.3.8.d (Contiguous problems: Fragmentation, size)
- 2.3.8.f (Linked problems: Sequential access only)
- 2.3.8.i (Multi-level indexed: Indirect blocks)
- 2.3.8.l (Double indirect: Two levels)
- 2.3.8.m (Triple indirect: Three levels)
- 2.3.9.d (Contiguous search: For extent allocation)
- 2.3.9.e (Free list: Linked list of free blocks)
- 2.3.12.l (Writeback mode: Metadata only)
- 2.3.13.i (Write amplification: More writes)

## Description
Implementer et comparer trois strategies d'allocation de blocs:
1. Allocation contigue avec recherche de meilleur ajustement
2. Allocation indexee multi-niveaux (direct + indirect + double indirect)
3. Allocation par extents avec fusion

Ce projet simule les mecanismes internes des filesystems modernes.

## Objectifs pedagogiques
1. Comprendre les compromis entre strategies d'allocation
2. Implementer des blocs indirects comme dans ext2/3/4
3. Gerer la fragmentation et les strategies de recherche
4. Mesurer le write amplification
5. Comparer les performances d'acces sequentiel vs aleatoire

## Structure (Rust 2024)

```rust
// src/lib.rs
use std::collections::{BTreeMap, VecDeque};

/// Constantes du systeme
pub const BLOCK_SIZE: usize = 4096;
pub const DIRECT_BLOCKS: usize = 12;
pub const PTRS_PER_BLOCK: usize = BLOCK_SIZE / 8; // 512 pointeurs 64-bit

/// Erreurs possibles
#[derive(Debug, PartialEq)]
pub enum AllocError {
    NoSpace,
    InvalidBlock,
    FragmentationTooHigh,
    BlockNotAllocated,
}

/// Extent: plage contigue de blocs
#[derive(Debug, Clone, PartialEq)]
pub struct Extent {
    pub start: u64,      // Premier bloc
    pub length: u32,     // Nombre de blocs
    pub logical: u64,    // Offset logique dans le fichier
}

/// Structure inode avec blocs directs et indirects
#[derive(Debug, Clone)]
pub struct IndexedInode {
    pub direct: [Option<u64>; DIRECT_BLOCKS],  // 12 blocs directs
    pub indirect: Option<u64>,                  // Bloc indirect simple
    pub double_indirect: Option<u64>,           // Bloc double indirect
    pub triple_indirect: Option<u64>,           // Bloc triple indirect
    pub size: u64,
    pub blocks_count: u64,
}

/// Allocateur de blocs generique
pub trait BlockAllocator {
    /// Allouer n blocs contigus si possible
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError>;

    /// Liberer des blocs
    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError>;

    /// Nombre de blocs libres
    fn free_count(&self) -> usize;

    /// Statistiques de fragmentation (0.0 = pas de frag, 1.0 = max)
    fn fragmentation(&self) -> f64;
}

/// Allocateur contigu avec bitmap
pub struct ContiguousAllocator {
    bitmap: Vec<bool>,          // true = alloue
    total_blocks: usize,
    free_blocks: usize,
}

impl ContiguousAllocator {
    pub fn new(total_blocks: usize) -> Self {
        todo!("Initialiser le bitmap a false")
    }

    /// Recherche du meilleur ajustement (best-fit)
    fn find_best_fit(&self, count: usize) -> Option<u64> {
        todo!("Trouver la plus petite plage >= count")
    }

    /// Recherche du premier ajustement (first-fit)
    fn find_first_fit(&self, count: usize) -> Option<u64> {
        todo!("Trouver la premiere plage >= count")
    }
}

impl BlockAllocator for ContiguousAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError> {
        todo!("Allouer count blocs contigus")
    }

    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError> {
        todo!("Liberer les blocs")
    }

    fn free_count(&self) -> usize {
        self.free_blocks
    }

    fn fragmentation(&self) -> f64 {
        todo!("Calculer ratio de fragmentation")
    }
}

/// Allocateur avec liste chainee de blocs libres
pub struct LinkedAllocator {
    free_list: VecDeque<u64>,   // Liste des blocs libres
    allocated: Vec<bool>,       // Marque les blocs alloues
    total_blocks: usize,
}

impl LinkedAllocator {
    pub fn new(total_blocks: usize) -> Self {
        todo!("Initialiser avec tous les blocs dans free_list")
    }
}

impl BlockAllocator for LinkedAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError> {
        todo!("Allouer count blocs (pas forcement contigus)")
    }

    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError> {
        todo!("Remettre les blocs dans la free list")
    }

    fn free_count(&self) -> usize {
        self.free_list.len()
    }

    fn fragmentation(&self) -> f64 {
        todo!("Calculer fragmentation")
    }
}

/// Allocateur par extents
pub struct ExtentAllocator {
    extents: BTreeMap<u64, u32>,  // start -> length pour les blocs libres
    total_blocks: usize,
    free_blocks: usize,
}

impl ExtentAllocator {
    pub fn new(total_blocks: usize) -> Self {
        todo!("Initialiser avec un seul extent couvrant tout")
    }

    /// Fusionner les extents adjacents
    fn coalesce(&mut self) {
        todo!("Fusionner les extents contigus")
    }
}

impl BlockAllocator for ExtentAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError> {
        todo!("Allouer depuis un extent, splitter si necessaire")
    }

    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError> {
        todo!("Creer extent et fusionner avec adjacents")
    }

    fn free_count(&self) -> usize {
        self.free_blocks
    }

    fn fragmentation(&self) -> f64 {
        todo!("Calculer fragmentation basee sur nombre d'extents")
    }
}

/// Gestionnaire de fichier avec blocs indirects
pub struct IndexedFileManager {
    allocator: Box<dyn BlockAllocator>,
    block_storage: Vec<[u8; BLOCK_SIZE]>,  // Stockage des blocs
    write_count: u64,                        // Compteur write amplification
}

impl IndexedFileManager {
    pub fn new(allocator: Box<dyn BlockAllocator>, total_blocks: usize) -> Self {
        todo!("Initialiser le gestionnaire")
    }

    /// Creer un nouvel inode
    pub fn create_inode(&self) -> IndexedInode {
        IndexedInode {
            direct: [None; DIRECT_BLOCKS],
            indirect: None,
            double_indirect: None,
            triple_indirect: None,
            size: 0,
            blocks_count: 0,
        }
    }

    /// Ecrire des donnees dans un fichier (allouer des blocs si necessaire)
    pub fn write(&mut self, inode: &mut IndexedInode, offset: u64, data: &[u8])
        -> Result<usize, AllocError> {
        todo!("Ecrire donnees, allouer blocs directs/indirects")
    }

    /// Lire des donnees depuis un fichier
    pub fn read(&self, inode: &IndexedInode, offset: u64, buf: &mut [u8])
        -> Result<usize, AllocError> {
        todo!("Lire donnees en suivant les pointeurs")
    }

    /// Convertir un offset logique en numero de bloc
    fn logical_to_physical(&self, inode: &IndexedInode, logical_block: u64)
        -> Option<u64> {
        todo!("Calculer le bloc physique")
        // logical_block < 12 -> direct
        // logical_block < 12 + 512 -> indirect
        // logical_block < 12 + 512 + 512^2 -> double indirect
        // sinon -> triple indirect
    }

    /// Allouer un nouveau bloc pour une position logique
    fn allocate_block_for(&mut self, inode: &mut IndexedInode, logical_block: u64)
        -> Result<u64, AllocError> {
        todo!("Allouer bloc, creer blocs indirects si necessaire")
    }

    /// Obtenir le ratio de write amplification
    pub fn write_amplification(&self) -> f64 {
        todo!("Nombre d'ecritures physiques / nombre d'ecritures logiques")
    }
}

/// Benchmark des differentes strategies
pub struct BenchmarkResult {
    pub strategy: String,
    pub allocation_time_us: u64,
    pub fragmentation: f64,
    pub sequential_read_time_us: u64,
    pub random_read_time_us: u64,
}

pub fn benchmark_allocator<A: BlockAllocator>(
    allocator: &mut A,
    name: &str,
    operations: &[(usize, bool)],  // (size, is_alloc)
) -> BenchmarkResult {
    todo!("Executer les operations et mesurer les performances")
}
```

## Tests Automatises

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_contiguous_allocator() {
        let mut alloc = ContiguousAllocator::new(1000);

        let blocks = alloc.allocate(10).unwrap();
        assert_eq!(blocks.len(), 10);

        // Verifier contiguite
        for i in 1..blocks.len() {
            assert_eq!(blocks[i], blocks[i-1] + 1);
        }
    }

    #[test]
    fn test_fragmentation() {
        let mut alloc = ContiguousAllocator::new(100);

        // Allouer des blocs alternes pour creer de la fragmentation
        let b1 = alloc.allocate(10).unwrap();
        let b2 = alloc.allocate(10).unwrap();
        let b3 = alloc.allocate(10).unwrap();

        alloc.free(&b2).unwrap();  // Trou au milieu

        let frag = alloc.fragmentation();
        assert!(frag > 0.0);
    }

    #[test]
    fn test_extent_coalescing() {
        let mut alloc = ExtentAllocator::new(100);

        let b1 = alloc.allocate(10).unwrap();
        let b2 = alloc.allocate(10).unwrap();

        alloc.free(&b1).unwrap();
        alloc.free(&b2).unwrap();

        // Les extents devraient etre fusionnes
        let blocks = alloc.allocate(20).unwrap();
        assert_eq!(blocks.len(), 20);
        for i in 1..blocks.len() {
            assert_eq!(blocks[i], blocks[i-1] + 1);
        }
    }

    #[test]
    fn test_indexed_inode_direct() {
        let alloc = Box::new(ContiguousAllocator::new(1000));
        let mut mgr = IndexedFileManager::new(alloc, 1000);
        let mut inode = mgr.create_inode();

        // Ecrire moins de 12 blocs
        let data = vec![0u8; BLOCK_SIZE * 5];
        let written = mgr.write(&mut inode, 0, &data).unwrap();
        assert_eq!(written, data.len());

        // Verifier que seuls les blocs directs sont utilises
        assert!(inode.direct[0..5].iter().all(|b| b.is_some()));
        assert!(inode.indirect.is_none());
    }

    #[test]
    fn test_indexed_inode_indirect() {
        let alloc = Box::new(ContiguousAllocator::new(10000));
        let mut mgr = IndexedFileManager::new(alloc, 10000);
        let mut inode = mgr.create_inode();

        // Ecrire plus de 12 blocs pour forcer l'utilisation d'indirect
        let data = vec![0u8; BLOCK_SIZE * 20];
        let written = mgr.write(&mut inode, 0, &data).unwrap();
        assert_eq!(written, data.len());

        // Verifier qu'un bloc indirect est alloue
        assert!(inode.indirect.is_some());
    }

    #[test]
    fn test_double_indirect() {
        let alloc = Box::new(ContiguousAllocator::new(100000));
        let mut mgr = IndexedFileManager::new(alloc, 100000);
        let mut inode = mgr.create_inode();

        // Ecrire assez pour atteindre double indirect
        // 12 direct + 512 indirect = 524 blocs
        let data = vec![0u8; BLOCK_SIZE * 600];
        let written = mgr.write(&mut inode, 0, &data).unwrap();
        assert_eq!(written, data.len());

        assert!(inode.double_indirect.is_some());
    }

    #[test]
    fn test_logical_to_physical() {
        let alloc = Box::new(ContiguousAllocator::new(10000));
        let mut mgr = IndexedFileManager::new(alloc, 10000);
        let mut inode = mgr.create_inode();

        let data = vec![42u8; BLOCK_SIZE * 15];
        mgr.write(&mut inode, 0, &data).unwrap();

        // Verifier que la traduction fonctionne
        let phys_0 = mgr.logical_to_physical(&inode, 0);
        let phys_5 = mgr.logical_to_physical(&inode, 5);
        let phys_13 = mgr.logical_to_physical(&inode, 13);  // Dans indirect

        assert!(phys_0.is_some());
        assert!(phys_5.is_some());
        assert!(phys_13.is_some());
    }

    #[test]
    fn test_write_amplification() {
        let alloc = Box::new(ContiguousAllocator::new(10000));
        let mut mgr = IndexedFileManager::new(alloc, 10000);
        let mut inode = mgr.create_inode();

        // Ecriture initiale
        let data = vec![0u8; BLOCK_SIZE * 20];
        mgr.write(&mut inode, 0, &data).unwrap();

        let wa = mgr.write_amplification();
        // Doit etre > 1.0 a cause des blocs indirects
        assert!(wa >= 1.0);
    }
}
```

## Criteres d'evaluation
- [ ] Allocateur contigu avec best-fit
- [ ] Allocateur avec extents et fusion
- [ ] Blocs indirects (simple, double) fonctionnels
- [ ] Calcul correct du bloc physique depuis logique
- [ ] Mesure de fragmentation
- [ ] Mesure de write amplification
- [ ] Tests de performance comparatifs

## Note qualite: 97/100
