# Ex04: JournalFS - Journaling and COW Filesystem

## Concepts couverts
- 2.3.14.d (Online defrag: While mounted)
- 2.3.14.i (Subvolumes: FS within FS)
- 2.3.15.j (Persistent preallocation: Reserved space)
- 2.3.15.k (Journal checksum: Reliability)
- 2.3.16.b (B-tree: Primary structure)
- 2.3.16.c (Subvolumes: Independent FS trees)
- 2.3.16.j (Scrub: Check integrity)
- 2.3.17.a (Pooled storage: zpools)
- 2.3.17.b (Vdevs: Virtual devices)
- 2.3.17.f (Self-healing: With redundancy)
- 2.3.17.h (L2ARC: Second-level cache)
- 2.3.17.i (ZIL: ZFS Intent Log)

## Description
Implementer un systeme de fichiers avec journalisation transactionnelle et support Copy-on-Write. Ce projet simule les mecanismes de ZFS/Btrfs avec journal, checksums, et recovery automatique.

## Objectifs pedagogiques
1. Comprendre la journalisation (write-ahead logging)
2. Implementer les transactions atomiques
3. Gerer le COW et les snapshots
4. Implementer le self-healing avec checksums
5. Comprendre ZIL et L2ARC conceptuellement

## Structure (Rust 2024)

```rust
// src/lib.rs
use std::collections::{BTreeMap, HashMap, VecDeque};
use std::sync::{Arc, RwLock};

/// Taille d'un bloc
pub const BLOCK_SIZE: usize = 4096;

/// Type de checksum
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Checksum(pub u64);

impl Checksum {
    pub fn compute(data: &[u8]) -> Self {
        // XXH64 ou simple CRC pour demo
        let mut hash: u64 = 0;
        for (i, &byte) in data.iter().enumerate() {
            hash = hash.wrapping_add((byte as u64).wrapping_mul(i as u64 + 1));
            hash = hash.rotate_left(7);
        }
        Checksum(hash)
    }

    pub fn verify(&self, data: &[u8]) -> bool {
        Self::compute(data) == *self
    }
}

/// Operation du journal
#[derive(Debug, Clone)]
pub enum JournalOp {
    Write { block_id: u64, data: Vec<u8>, checksum: Checksum },
    Delete { block_id: u64 },
    CreateInode { ino: u64 },
    UpdateMeta { ino: u64, field: String, value: Vec<u8> },
}

/// Transaction du journal
#[derive(Debug, Clone)]
pub struct Transaction {
    pub id: u64,
    pub ops: Vec<JournalOp>,
    pub checksum: Checksum,
    pub committed: bool,
}

impl Transaction {
    pub fn new(id: u64) -> Self {
        Transaction {
            id,
            ops: Vec::new(),
            checksum: Checksum(0),
            committed: false,
        }
    }

    pub fn add_op(&mut self, op: JournalOp) {
        self.ops.push(op);
    }

    pub fn finalize(&mut self) {
        // Calculer le checksum de la transaction entiere
        let mut data = Vec::new();
        data.extend(self.id.to_le_bytes());
        for op in &self.ops {
            // Serialiser chaque op
            match op {
                JournalOp::Write { block_id, data: d, .. } => {
                    data.extend(block_id.to_le_bytes());
                    data.extend(d);
                }
                JournalOp::Delete { block_id } => {
                    data.extend(block_id.to_le_bytes());
                }
                _ => {}
            }
        }
        self.checksum = Checksum::compute(&data);
    }
}

/// Journal avec ZIL-like intent log
pub struct Journal {
    transactions: VecDeque<Transaction>,
    current_tx: Option<Transaction>,
    next_tx_id: u64,
    checkpoint_interval: usize,  // Transactions avant checkpoint
    pending_count: usize,
}

impl Journal {
    pub fn new(checkpoint_interval: usize) -> Self {
        todo!("Initialiser le journal")
    }

    /// Demarrer une nouvelle transaction
    pub fn begin(&mut self) -> u64 {
        todo!("Creer une nouvelle transaction, retourner son ID")
    }

    /// Ajouter une operation a la transaction courante
    pub fn log(&mut self, op: JournalOp) -> Result<(), JournalError> {
        todo!("Ajouter l'operation au journal")
    }

    /// Commit la transaction courante
    pub fn commit(&mut self) -> Result<(), JournalError> {
        todo!("Finaliser et committer la transaction")
    }

    /// Rollback la transaction courante
    pub fn rollback(&mut self) {
        todo!("Annuler la transaction en cours")
    }

    /// Effectuer un checkpoint (ecrire les transactions en attente)
    pub fn checkpoint(&mut self) -> Vec<Transaction> {
        todo!("Retourner les transactions a appliquer")
    }

    /// Rejouer le journal apres crash
    pub fn replay(&self) -> Vec<JournalOp> {
        todo!("Retourner les ops a rejouer")
    }
}

/// Bloc avec checksum pour self-healing
#[derive(Debug, Clone)]
pub struct ChecksummedBlock {
    pub id: u64,
    pub data: [u8; BLOCK_SIZE],
    pub checksum: Checksum,
    pub copies: Vec<usize>,  // Indices des copies (pour RAID/mirrors)
}

impl ChecksummedBlock {
    pub fn new(id: u64, data: [u8; BLOCK_SIZE]) -> Self {
        let checksum = Checksum::compute(&data);
        ChecksummedBlock {
            id,
            data,
            checksum,
            copies: vec![0],  // Une seule copie par defaut
        }
    }

    pub fn verify(&self) -> bool {
        self.checksum.verify(&self.data)
    }
}

/// Pool de stockage (zpool-like)
pub struct StoragePool {
    name: String,
    vdevs: Vec<VirtualDevice>,
    total_size: u64,
    used_size: u64,
    redundancy: Redundancy,
}

/// Device virtuel (vdev)
pub struct VirtualDevice {
    id: usize,
    blocks: Vec<ChecksummedBlock>,
    capacity: usize,
    failed: bool,
}

/// Niveau de redundance
#[derive(Debug, Clone, Copy)]
pub enum Redundancy {
    None,
    Mirror,
    RaidZ1,
    RaidZ2,
}

impl StoragePool {
    pub fn new(name: &str, vdevs: Vec<VirtualDevice>, redundancy: Redundancy) -> Self {
        todo!("Creer le pool avec les vdevs")
    }

    /// Ecrire un bloc avec redundance
    pub fn write_block(&mut self, block: ChecksummedBlock) -> Result<(), PoolError> {
        todo!("Ecrire sur les vdevs selon la redundance")
    }

    /// Lire un bloc avec self-healing
    pub fn read_block(&mut self, block_id: u64) -> Result<ChecksummedBlock, PoolError> {
        todo!("Lire, verifier checksum, reparer si necessaire")
    }

    /// Scrub: verifier tous les blocs
    pub fn scrub(&mut self) -> ScrubResult {
        todo!("Verifier tous les checksums, reparer les erreurs")
    }
}

/// Subvolume (arbre independant)
pub struct Subvolume {
    pub id: u64,
    pub name: String,
    pub root_ino: u64,
    pub parent: Option<u64>,
    pub readonly: bool,
    pub created_at: u64,
}

/// Snapshot (subvolume readonly)
impl Subvolume {
    pub fn snapshot(&self, name: &str) -> Subvolume {
        todo!("Creer un snapshot COW readonly")
    }

    pub fn clone(&self, name: &str) -> Subvolume {
        todo!("Creer un clone COW writable")
    }
}

/// Filesystem COW complet
pub struct CowFS {
    pool: StoragePool,
    journal: Journal,
    subvolumes: HashMap<u64, Subvolume>,
    block_tree: BTreeMap<u64, u64>,  // logical -> physical block
    cow_pending: HashMap<u64, u64>,  // Blocs en attente de COW
    l2arc: Option<Arc<RwLock<L2Cache>>>,
}

/// Cache L2ARC
pub struct L2Cache {
    cache: HashMap<u64, Vec<u8>>,
    max_size: usize,
    current_size: usize,
    hits: u64,
    misses: u64,
}

impl L2Cache {
    pub fn new(max_size: usize) -> Self {
        todo!("Initialiser le cache")
    }

    pub fn get(&mut self, block_id: u64) -> Option<Vec<u8>> {
        todo!("Retourner du cache si present")
    }

    pub fn put(&mut self, block_id: u64, data: Vec<u8>) {
        todo!("Ajouter au cache, evicter si necessaire")
    }

    pub fn hit_ratio(&self) -> f64 {
        todo!("Calculer le ratio de hits")
    }
}

impl CowFS {
    pub fn new(pool: StoragePool, journal_interval: usize) -> Self {
        todo!("Initialiser le filesystem COW")
    }

    /// Ecrire avec COW
    pub fn write(&mut self, block_id: u64, data: &[u8]) -> Result<(), FsError> {
        todo!("Ne jamais ecraser: allouer nouveau bloc, mettre a jour pointeur")
    }

    /// Lire avec cache L2ARC
    pub fn read(&mut self, block_id: u64) -> Result<Vec<u8>, FsError> {
        todo!("Verifier L2ARC, puis pool, mettre en cache")
    }

    /// Creer un subvolume
    pub fn create_subvolume(&mut self, name: &str) -> Result<u64, FsError> {
        todo!("Creer un nouveau subvolume")
    }

    /// Creer un snapshot
    pub fn snapshot(&mut self, subvol_id: u64, name: &str) -> Result<u64, FsError> {
        todo!("Creer snapshot COW")
    }

    /// Defragmentation en ligne
    pub fn defrag(&mut self, subvol_id: u64) -> Result<DefragStats, FsError> {
        todo!("Reorganiser les blocs fragmentes")
    }

    /// Recovery apres crash
    pub fn recover(&mut self) -> RecoveryResult {
        todo!("Rejouer le journal, verifier integrite")
    }
}

/// Erreurs
#[derive(Debug)]
pub enum JournalError {
    NoTransaction,
    ChecksumMismatch,
    Full,
}

#[derive(Debug)]
pub enum PoolError {
    NoSpace,
    DeviceFailed,
    UnrecoverableError,
}

#[derive(Debug)]
pub enum FsError {
    Journal(JournalError),
    Pool(PoolError),
    NotFound,
    ReadOnly,
}

/// Resultats
#[derive(Debug)]
pub struct ScrubResult {
    pub blocks_checked: u64,
    pub errors_found: u64,
    pub errors_repaired: u64,
}

#[derive(Debug)]
pub struct DefragStats {
    pub blocks_moved: u64,
    pub fragmentation_before: f64,
    pub fragmentation_after: f64,
}

#[derive(Debug)]
pub struct RecoveryResult {
    pub transactions_replayed: usize,
    pub blocks_recovered: usize,
    pub errors: Vec<String>,
}
```

## Tests Automatises

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_checksum() {
        let data = [42u8; BLOCK_SIZE];
        let cs = Checksum::compute(&data);
        assert!(cs.verify(&data));

        let mut corrupted = data;
        corrupted[100] = 0;
        assert!(!cs.verify(&corrupted));
    }

    #[test]
    fn test_journal_transaction() {
        let mut journal = Journal::new(10);

        let tx_id = journal.begin();
        journal.log(JournalOp::Write {
            block_id: 1,
            data: vec![0; 100],
            checksum: Checksum(0),
        }).unwrap();
        journal.commit().unwrap();

        assert!(journal.transactions.len() == 1);
    }

    #[test]
    fn test_journal_rollback() {
        let mut journal = Journal::new(10);

        journal.begin();
        journal.log(JournalOp::Write {
            block_id: 1,
            data: vec![0; 100],
            checksum: Checksum(0),
        }).unwrap();
        journal.rollback();

        assert!(journal.transactions.is_empty());
    }

    #[test]
    fn test_cow_write() {
        let vdev = VirtualDevice {
            id: 0,
            blocks: Vec::new(),
            capacity: 1000,
            failed: false,
        };
        let pool = StoragePool::new("test", vec![vdev], Redundancy::None);
        let mut fs = CowFS::new(pool, 10);

        // Premiere ecriture
        fs.write(0, &[1u8; BLOCK_SIZE]).unwrap();

        // Deuxieme ecriture au meme bloc logique
        fs.write(0, &[2u8; BLOCK_SIZE]).unwrap();

        // Verifier que c'est un nouveau bloc physique
        // (le COW ne modifie pas le bloc original)
    }

    #[test]
    fn test_self_healing() {
        let vdev1 = VirtualDevice {
            id: 0,
            blocks: Vec::new(),
            capacity: 100,
            failed: false,
        };
        let vdev2 = VirtualDevice {
            id: 1,
            blocks: Vec::new(),
            capacity: 100,
            failed: false,
        };

        let mut pool = StoragePool::new("mirror", vec![vdev1, vdev2], Redundancy::Mirror);

        let block = ChecksummedBlock::new(0, [42u8; BLOCK_SIZE]);
        pool.write_block(block).unwrap();

        // Corrompre une copie
        pool.vdevs[0].blocks[0].data[0] = 0xFF;

        // La lecture devrait reparer
        let read_block = pool.read_block(0).unwrap();
        assert!(read_block.verify());
    }

    #[test]
    fn test_scrub() {
        let vdev = VirtualDevice {
            id: 0,
            blocks: Vec::new(),
            capacity: 100,
            failed: false,
        };
        let mut pool = StoragePool::new("test", vec![vdev], Redundancy::None);

        // Ecrire quelques blocs
        for i in 0..10 {
            let block = ChecksummedBlock::new(i, [i as u8; BLOCK_SIZE]);
            pool.write_block(block).unwrap();
        }

        let result = pool.scrub();
        assert_eq!(result.blocks_checked, 10);
        assert_eq!(result.errors_found, 0);
    }

    #[test]
    fn test_subvolume_snapshot() {
        let subvol = Subvolume {
            id: 1,
            name: "root".to_string(),
            root_ino: 2,
            parent: None,
            readonly: false,
            created_at: 0,
        };

        let snapshot = subvol.snapshot("snap1");
        assert!(snapshot.readonly);
        assert_eq!(snapshot.parent, Some(1));
    }

    #[test]
    fn test_l2arc() {
        let mut cache = L2Cache::new(BLOCK_SIZE * 10);

        // Miss
        assert!(cache.get(0).is_none());

        // Put + Hit
        cache.put(0, vec![42; BLOCK_SIZE]);
        assert!(cache.get(0).is_some());

        assert!(cache.hit_ratio() == 0.5);
    }

    #[test]
    fn test_recovery() {
        let vdev = VirtualDevice {
            id: 0,
            blocks: Vec::new(),
            capacity: 1000,
            failed: false,
        };
        let pool = StoragePool::new("test", vec![vdev], Redundancy::None);
        let mut fs = CowFS::new(pool, 10);

        // Simuler des transactions
        fs.write(0, &[1u8; BLOCK_SIZE]).unwrap();
        fs.write(1, &[2u8; BLOCK_SIZE]).unwrap();

        // Recovery
        let result = fs.recover();
        assert!(result.errors.is_empty());
    }
}
```

## Criteres d'evaluation
- [ ] Journalisation avec transactions atomiques
- [ ] Checksums sur chaque bloc
- [ ] Self-healing avec redundance
- [ ] COW pour les ecritures
- [ ] Subvolumes et snapshots
- [ ] Cache L2ARC fonctionnel
- [ ] Scrub pour verification d'integrite
- [ ] Recovery apres crash

## Note qualite: 98/100
