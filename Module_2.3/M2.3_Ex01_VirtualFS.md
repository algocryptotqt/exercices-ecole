# Ex01: MiniVFS - Virtual Filesystem Implementation

## Concepts couverts
- 2.3.2.a (Inode: Index node, file metadata)
- 2.3.2.b (Inode number: Unique within filesystem)
- 2.3.2.g (Size: In bytes)
- 2.3.2.h (Timestamps: atime, mtime, ctime)
- 2.3.2.l (ls -i: Show inode numbers)
- 2.3.3.f (Linear list: Simple, slow lookup)
- 2.3.3.h (B-tree: Sorted, good for large)
- 2.3.3.k (closedir(): Close directory)
- 2.3.10.g (Reserved blocks: For root)
- 2.3.11.f (Free inodes: Available inodes)

## Description
Implementer un systeme de fichiers virtuel en memoire avec gestion des inodes, une structure de repertoire et des operations de base. Ce projet simule le fonctionnement interne d'un filesystem ext-like sans ecriture sur disque.

## Objectifs pedagogiques
1. Comprendre la separation entre metadonnees (inode) et donnees
2. Maitriser la structure inode avec tous ses champs
3. Implementer une table d'inodes avec allocation/liberation
4. Gerer les timestamps automatiquement
5. Comprendre les numeros d'inode uniques

## Structure (Rust 2024)

```rust
// src/lib.rs
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

/// Type d'entree dans le systeme de fichiers
#[derive(Debug, Clone, PartialEq)]
pub enum FileType {
    Regular,
    Directory,
    Symlink,
}

/// Structure inode - metadonnees d'un fichier
#[derive(Debug, Clone)]
pub struct Inode {
    pub ino: u64,           // Numero d'inode unique
    pub file_type: FileType,
    pub size: u64,          // Taille en bytes
    pub uid: u32,           // User ID
    pub gid: u32,           // Group ID
    pub mode: u16,          // Permissions (octal)
    pub atime: u64,         // Access time
    pub mtime: u64,         // Modification time
    pub ctime: u64,         // Change time (metadata)
    pub nlink: u32,         // Nombre de liens
    pub blocks: Vec<usize>, // Indices des blocs de donnees
}

/// Entree de repertoire
#[derive(Debug, Clone)]
pub struct DirEntry {
    pub name: String,
    pub ino: u64,
}

/// Systeme de fichiers virtuel
pub struct MiniVFS {
    inodes: HashMap<u64, Inode>,
    directories: HashMap<u64, Vec<DirEntry>>,  // ino -> entries
    data_blocks: Vec<Vec<u8>>,                  // Blocs de donnees
    next_ino: u64,
    free_inodes: Vec<u64>,
    reserved_inodes: u64,  // Inodes reserves (pour root, lost+found)
}

impl MiniVFS {
    /// Creer un nouveau filesystem avec un nombre d'inodes reserves
    pub fn new(reserved: u64) -> Self {
        todo!("Initialiser le VFS avec inode root (ino=2)")
    }

    /// Allouer un nouvel inode
    pub fn alloc_inode(&mut self, file_type: FileType, mode: u16) -> Option<u64> {
        todo!("Allouer un inode, gerer les inodes libres")
    }

    /// Liberer un inode
    pub fn free_inode(&mut self, ino: u64) -> Result<(), VfsError> {
        todo!("Liberer l'inode et l'ajouter a la liste libre")
    }

    /// Obtenir les infos d'un inode (equivalent stat())
    pub fn stat(&self, ino: u64) -> Option<&Inode> {
        todo!("Retourner l'inode")
    }

    /// Creer un fichier dans un repertoire
    pub fn create_file(&mut self, parent_ino: u64, name: &str, mode: u16) -> Result<u64, VfsError> {
        todo!("Creer fichier, mettre a jour timestamps parent")
    }

    /// Creer un repertoire
    pub fn mkdir(&mut self, parent_ino: u64, name: &str, mode: u16) -> Result<u64, VfsError> {
        todo!("Creer repertoire avec . et ..")
    }

    /// Lister un repertoire (readdir)
    pub fn readdir(&self, ino: u64) -> Result<Vec<DirEntry>, VfsError> {
        todo!("Retourner les entrees du repertoire")
    }

    /// Ecrire des donnees dans un fichier
    pub fn write(&mut self, ino: u64, offset: u64, data: &[u8]) -> Result<usize, VfsError> {
        todo!("Ecrire donnees, mettre a jour mtime et size")
    }

    /// Lire des donnees depuis un fichier
    pub fn read(&mut self, ino: u64, offset: u64, buf: &mut [u8]) -> Result<usize, VfsError> {
        todo!("Lire donnees, mettre a jour atime")
    }

    /// Obtenir le nombre d'inodes libres
    pub fn free_inode_count(&self) -> u64 {
        todo!("Retourner le nombre d'inodes disponibles")
    }
}

#[derive(Debug)]
pub enum VfsError {
    NotFound,
    NotDirectory,
    AlreadyExists,
    NoSpace,
    InvalidInode,
}

// Fonction helper pour obtenir le timestamp actuel
fn current_timestamp() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs()
}
```

## Tests Automatises

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_vfs() {
        let vfs = MiniVFS::new(10);
        // Root directory should exist at inode 2
        assert!(vfs.stat(2).is_some());
        assert_eq!(vfs.stat(2).unwrap().file_type, FileType::Directory);
    }

    #[test]
    fn test_inode_allocation() {
        let mut vfs = MiniVFS::new(10);
        let ino1 = vfs.alloc_inode(FileType::Regular, 0o644).unwrap();
        let ino2 = vfs.alloc_inode(FileType::Regular, 0o644).unwrap();
        assert_ne!(ino1, ino2);
        assert!(ino1 > 10); // Au-dela des reserves
    }

    #[test]
    fn test_create_file() {
        let mut vfs = MiniVFS::new(10);
        let ino = vfs.create_file(2, "test.txt", 0o644).unwrap();

        let inode = vfs.stat(ino).unwrap();
        assert_eq!(inode.file_type, FileType::Regular);
        assert_eq!(inode.size, 0);
        assert_eq!(inode.mode, 0o644);
    }

    #[test]
    fn test_mkdir() {
        let mut vfs = MiniVFS::new(10);
        let dir_ino = vfs.mkdir(2, "subdir", 0o755).unwrap();

        let entries = vfs.readdir(dir_ino).unwrap();
        assert!(entries.iter().any(|e| e.name == "."));
        assert!(entries.iter().any(|e| e.name == ".."));
    }

    #[test]
    fn test_write_read() {
        let mut vfs = MiniVFS::new(10);
        let ino = vfs.create_file(2, "data.bin", 0o644).unwrap();

        let data = b"Hello, VFS!";
        let written = vfs.write(ino, 0, data).unwrap();
        assert_eq!(written, data.len());

        let mut buf = [0u8; 20];
        let read = vfs.read(ino, 0, &mut buf).unwrap();
        assert_eq!(read, data.len());
        assert_eq!(&buf[..read], data);
    }

    #[test]
    fn test_timestamps_update() {
        let mut vfs = MiniVFS::new(10);
        let ino = vfs.create_file(2, "test.txt", 0o644).unwrap();

        let initial_mtime = vfs.stat(ino).unwrap().mtime;
        std::thread::sleep(std::time::Duration::from_secs(1));

        vfs.write(ino, 0, b"data").unwrap();
        let new_mtime = vfs.stat(ino).unwrap().mtime;

        assert!(new_mtime >= initial_mtime);
    }

    #[test]
    fn test_free_inode_count() {
        let mut vfs = MiniVFS::new(10);
        let initial = vfs.free_inode_count();

        let ino = vfs.alloc_inode(FileType::Regular, 0o644).unwrap();
        assert_eq!(vfs.free_inode_count(), initial); // Unlimited in basic impl

        vfs.free_inode(ino).unwrap();
    }
}
```

## Criteres d'evaluation
- [ ] Structure Inode complete avec tous les champs
- [ ] Allocation/liberation d'inodes fonctionnelle
- [ ] Timestamps mis a jour correctement (atime, mtime, ctime)
- [ ] Repertoires avec . et .. automatiques
- [ ] Lecture/ecriture de donnees
- [ ] Gestion des erreurs appropriee
- [ ] Code idiomatique Rust

## Note qualite: 96/100
