# Exercice 2.3.1 : minivfs_create

**Module :**
2.3.1 â€” SystÃ¨mes de Fichiers Virtuels

**Concept :**
a â€” ImplÃ©mentation d'un Virtual Filesystem en mÃ©moire

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†â˜† (5/10)

**Type :**
complet

**Tiers :**
3 â€” SynthÃ¨se (tous concepts inode, rÃ©pertoires, timestamps)

**Langage :**
Rust (Edition 2024)

**PrÃ©requis :**
- Structures de donnÃ©es (HashMap, Vec)
- Ownership et borrowing en Rust
- Concepts de base des systÃ¨mes de fichiers
- Gestion des timestamps UNIX

**Domaines :**
FS, Struct, Mem

**DurÃ©e estimÃ©e :**
90 min

**XP Base :**
150

**ComplexitÃ© :**
T3 O(1) amortized pour lookup Ã— S3 O(n) pour stockage inodes

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
```
src/lib.rs
```

**Fonctions autorisÃ©es :**
- `std::collections::HashMap`
- `std::time::{SystemTime, UNIX_EPOCH}`
- `std::vec::Vec`

**Fonctions interdites :**
- AccÃ¨s disque rÃ©el (`std::fs::*`)
- `unsafe` blocks
- Crates externes

### 1.2 Consigne

**Section 2.4.1 â€” Contexte Culturel**

**ğŸ® THE MATRIX â€” "There is no spoon"**

Dans The Matrix, Neo dÃ©couvre que la rÃ©alitÃ© qu'il perÃ§oit n'est qu'une simulation. L'enfant lui dit : "Il n'y a pas de cuillÃ¨re... Ce n'est pas la cuillÃ¨re qui plie, c'est toi."

Un Virtual Filesystem (VFS) fonctionne exactement sur ce principe : **il n'y a pas de disque**. Toutes les donnÃ©es existent uniquement en mÃ©moire RAM, comme une simulation parfaite d'un vrai filesystem. Le programme qui l'utilise ne sait pas (et ne devrait pas savoir) qu'il n'Ã©crit pas rÃ©ellement sur un disque.

Comme Neo qui apprend Ã  manipuler la Matrix, tu vas crÃ©er ta propre "simulation" de filesystem oÃ¹ tu contrÃ´les chaque aspect : les inodes, les rÃ©pertoires, les timestamps. Tu es l'Architecte de cette rÃ©alitÃ© virtuelle.

**L'analogie parfaite :** Un inode est comme le "code source" d'un objet dans la Matrix â€” il contient toutes les mÃ©tadonnÃ©es (taille, permissions, timestamps) sans contenir les donnÃ©es rÃ©elles (qui sont dans les blocs de donnÃ©es, comme les textures d'un objet).

---

**Section 2.4.2 â€” Ã‰noncÃ© AcadÃ©mique**

Un **Virtual Filesystem (VFS)** est une couche d'abstraction qui simule les opÃ©rations d'un systÃ¨me de fichiers en mÃ©moire. Cette architecture est utilisÃ©e dans :
- Les systÃ¨mes d'exploitation (Linux VFS layer)
- Les conteneurs (overlayfs, tmpfs)
- Les tests unitaires de code manipulant des fichiers
- Les systÃ¨mes embarquÃ©s sans stockage persistant

**Ta mission :**

ImplÃ©menter une structure `MiniVFS` en Rust qui simule un filesystem ext-like avec :

1. **Table d'inodes** : Chaque fichier/rÃ©pertoire possÃ¨de un inode unique contenant ses mÃ©tadonnÃ©es
2. **Structure de rÃ©pertoires** : Mapping nom â†’ numÃ©ro d'inode
3. **Blocs de donnÃ©es** : Stockage des contenus de fichiers
4. **Gestion des timestamps** : atime, mtime, ctime mis Ã  jour automatiquement

**EntrÃ©e :**
- `reserved: u64` : Nombre d'inodes rÃ©servÃ©s au systÃ¨me (convention ext: inodes 1-10)

**Sortie :**
- Une instance `MiniVFS` initialisÃ©e avec :
  - L'inode 2 comme rÃ©pertoire racine (convention ext)
  - Les entrÃ©es `.` et `..` dans le rÃ©pertoire racine

**Contraintes :**
- Les numÃ©ros d'inode doivent Ãªtre uniques et > `reserved`
- L'inode 2 est TOUJOURS le rÃ©pertoire racine (convention ext2/3/4)
- Chaque rÃ©pertoire DOIT contenir `.` (soi-mÃªme) et `..` (parent)
- Les timestamps doivent Ãªtre mis Ã  jour automatiquement :
  - `atime` : lors d'une lecture
  - `mtime` : lors d'une modification des donnÃ©es
  - `ctime` : lors d'une modification des mÃ©tadonnÃ©es

**Exemples :**

| OpÃ©ration | RÃ©sultat | Explication |
|-----------|----------|-------------|
| `MiniVFS::new(10)` | VFS avec root ino=2 | 10 inodes rÃ©servÃ©s, root Ã  l'inode 2 |
| `vfs.stat(2)` | `Some(&Inode)` | L'inode root existe toujours |
| `vfs.mkdir(2, "home", 0o755)` | `Ok(11)` | CrÃ©e /home avec inode > reserved |
| `vfs.create_file(2, "test.txt", 0o644)` | `Ok(12)` | CrÃ©e fichier dans root |
| `vfs.readdir(2)` | `[., .., home, test.txt]` | Liste le contenu de root |

### 1.3 Prototype

```rust
/// Type d'entrÃ©e dans le systÃ¨me de fichiers
#[derive(Debug, Clone, PartialEq)]
pub enum FileType {
    Regular,
    Directory,
    Symlink,
}

/// Structure inode - mÃ©tadonnÃ©es d'un fichier
#[derive(Debug, Clone)]
pub struct Inode {
    pub ino: u64,           // NumÃ©ro d'inode unique
    pub file_type: FileType,
    pub size: u64,          // Taille en bytes
    pub uid: u32,           // User ID
    pub gid: u32,           // Group ID
    pub mode: u16,          // Permissions (octal)
    pub atime: u64,         // Access time
    pub mtime: u64,         // Modification time
    pub ctime: u64,         // Change time (metadata)
    pub nlink: u32,         // Nombre de liens
    pub blocks: Vec<usize>, // Indices des blocs de donnÃ©es
}

/// EntrÃ©e de rÃ©pertoire
#[derive(Debug, Clone)]
pub struct DirEntry {
    pub name: String,
    pub ino: u64,
}

/// Erreurs du VFS
#[derive(Debug, PartialEq)]
pub enum VfsError {
    NotFound,
    NotDirectory,
    AlreadyExists,
    NoSpace,
    InvalidInode,
}

/// SystÃ¨me de fichiers virtuel
pub struct MiniVFS {
    // Ã€ implÃ©menter
}

impl MiniVFS {
    /// CrÃ©er un nouveau VFS avec inodes rÃ©servÃ©s
    pub fn new(reserved: u64) -> Self;

    /// Allouer un nouvel inode
    pub fn alloc_inode(&mut self, file_type: FileType, mode: u16) -> Option<u64>;

    /// LibÃ©rer un inode
    pub fn free_inode(&mut self, ino: u64) -> Result<(), VfsError>;

    /// Obtenir les infos d'un inode (Ã©quivalent stat())
    pub fn stat(&self, ino: u64) -> Option<&Inode>;

    /// CrÃ©er un fichier dans un rÃ©pertoire
    pub fn create_file(&mut self, parent_ino: u64, name: &str, mode: u16)
        -> Result<u64, VfsError>;

    /// CrÃ©er un rÃ©pertoire
    pub fn mkdir(&mut self, parent_ino: u64, name: &str, mode: u16)
        -> Result<u64, VfsError>;

    /// Lister un rÃ©pertoire
    pub fn readdir(&self, ino: u64) -> Result<Vec<DirEntry>, VfsError>;

    /// Ã‰crire des donnÃ©es
    pub fn write(&mut self, ino: u64, offset: u64, data: &[u8])
        -> Result<usize, VfsError>;

    /// Lire des donnÃ©es
    pub fn read(&mut self, ino: u64, offset: u64, buf: &mut [u8])
        -> Result<usize, VfsError>;

    /// Nombre d'inodes libres
    pub fn free_inode_count(&self) -> u64;
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Pourquoi l'inode 2 ?

Dans les systÃ¨mes de fichiers Unix (ext2, ext3, ext4), les inodes 1 Ã  10 sont **rÃ©servÃ©s** :
- **Inode 1** : Liste des blocs dÃ©fectueux
- **Inode 2** : RÃ©pertoire racine `/`
- **Inode 3-10** : RÃ©servÃ©s pour le systÃ¨me (ACL, journal, etc.)

Cette convention date des annÃ©es 1970 et du filesystem original de Unix (UFS).

### 2.2 La sÃ©paration mÃ©tadonnÃ©es/donnÃ©es

Un inode ne contient **jamais** le nom du fichier ni ses donnÃ©es. Il contient uniquement :
- Les attributs (permissions, timestamps, taille)
- Les pointeurs vers les blocs de donnÃ©es

Le nom est stockÃ© dans l'**entrÃ©e de rÃ©pertoire** du parent. C'est pourquoi :
- Renommer un fichier ne modifie pas son inode
- Les hard links partagent le mÃªme inode
- `ls -i` affiche le numÃ©ro d'inode

---

## ğŸ“‹ SECTION 2.5 : DANS LA VRAIE VIE

| MÃ©tier | Utilisation du concept |
|--------|------------------------|
| **Kernel Developer** | ImplÃ©mentation du VFS layer de Linux qui abstrait ext4, btrfs, NFS |
| **DevOps/SRE** | Configuration de tmpfs pour /tmp, ramfs pour performances |
| **Game Developer** | Virtual filesystem pour assets packagÃ©s (PAK files) |
| **Embedded Engineer** | Filesystem en RAM pour systÃ¨mes sans stockage persistant |
| **Security Researcher** | Analyse forensique des structures d'inodes |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/

$ cargo test
   Compiling minivfs v0.1.0
    Finished test [unoptimized + debuginfo]
    Running unittests src/lib.rs

running 6 tests
test tests::test_create_vfs ... ok
test tests::test_inode_allocation ... ok
test tests::test_create_file ... ok
test tests::test_mkdir ... ok
test tests::test_write_read ... ok
test tests::test_timestamps_update ... ok

test result: ok. 6 passed; 0 failed; 0 ignored
```

---

## âš¡ SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**RÃ©compense :**
XP Ã—2

**Time Complexity attendue :**
O(log n) pour les opÃ©rations de rÃ©pertoire

**Space Complexity attendue :**
O(n) pour n fichiers

**Domaines Bonus :**
`Struct, Algo`

### 3.1.1 Consigne Bonus

**ğŸ® MATRIX RELOADED â€” B-Tree Indexing**

L'Architecte utilise des structures optimisÃ©es pour gÃ©rer les millions d'humains dans la Matrix. ImplÃ©mente une version optimisÃ©e avec **B-Tree** pour les rÃ©pertoires.

**Ta mission :**

Modifier `MiniVFS` pour utiliser un `BTreeMap` au lieu d'un `Vec` pour les entrÃ©es de rÃ©pertoire, permettant :
- Recherche O(log n) par nom
- Listing triÃ© alphabÃ©tiquement
- Support de rÃ©pertoires avec des milliers d'entrÃ©es

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EntrÃ©es par rÃ©pertoire â‰¤ 10â¶      â”‚
â”‚  Temps lookup : O(log n)           â”‚
â”‚  Listing triÃ© alphabÃ©tiquement     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```rust
use std::collections::BTreeMap;

pub struct MiniVFS {
    inodes: HashMap<u64, Inode>,
    directories: HashMap<u64, BTreeMap<String, u64>>,  // Changement ici
    // ...
}

impl MiniVFS {
    /// Recherche un fichier par nom dans un rÃ©pertoire - O(log n)
    pub fn lookup(&self, parent_ino: u64, name: &str) -> Option<u64>;
}
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Structure rÃ©pertoire | `Vec<DirEntry>` | `BTreeMap<String, u64>` |
| ComplexitÃ© lookup | O(n) | O(log n) |
| Ordre listing | Insertion order | AlphabÃ©tique |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `test_create_vfs` | `MiniVFS::new(10)` | Root inode 2 exists | 10 |
| `test_inode_unique` | Alloc 2 inodes | Different ino | 10 |
| `test_create_file` | `create_file(2, "a.txt", 0o644)` | ino > 10 | 15 |
| `test_mkdir_dots` | `mkdir(2, "sub", 0o755)` | Contains `.` and `..` | 15 |
| `test_write_mtime` | Write then check | mtime updated | 15 |
| `test_read_atime` | Read then check | atime updated | 15 |
| `test_free_inode` | Free then realloc | Reuses ino | 10 |
| `test_error_not_found` | `stat(9999)` | `None` | 10 |

### 4.2 main.rs de test

```rust
use minivfs::*;

fn main() {
    let mut vfs = MiniVFS::new(10);

    // Test crÃ©ation
    let file_ino = vfs.create_file(2, "hello.txt", 0o644)
        .expect("Failed to create file");
    println!("Created file with inode: {}", file_ino);

    // Test Ã©criture
    let data = b"Hello, VFS!";
    let written = vfs.write(file_ino, 0, data).expect("Write failed");
    println!("Wrote {} bytes", written);

    // Test lecture
    let mut buf = [0u8; 32];
    let read = vfs.read(file_ino, 0, &mut buf).expect("Read failed");
    println!("Read {} bytes: {:?}", read, &buf[..read]);

    // Test rÃ©pertoire
    let dir_ino = vfs.mkdir(2, "subdir", 0o755).expect("mkdir failed");
    let entries = vfs.readdir(2).expect("readdir failed");
    println!("Root contains: {:?}", entries.iter().map(|e| &e.name).collect::<Vec<_>>());
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

fn current_timestamp() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

#[derive(Debug, Clone, PartialEq)]
pub enum FileType {
    Regular,
    Directory,
    Symlink,
}

#[derive(Debug, Clone)]
pub struct Inode {
    pub ino: u64,
    pub file_type: FileType,
    pub size: u64,
    pub uid: u32,
    pub gid: u32,
    pub mode: u16,
    pub atime: u64,
    pub mtime: u64,
    pub ctime: u64,
    pub nlink: u32,
    pub blocks: Vec<usize>,
}

#[derive(Debug, Clone)]
pub struct DirEntry {
    pub name: String,
    pub ino: u64,
}

#[derive(Debug, PartialEq)]
pub enum VfsError {
    NotFound,
    NotDirectory,
    AlreadyExists,
    NoSpace,
    InvalidInode,
}

pub struct MiniVFS {
    inodes: HashMap<u64, Inode>,
    directories: HashMap<u64, Vec<DirEntry>>,
    data_blocks: Vec<Vec<u8>>,
    next_ino: u64,
    free_inodes: Vec<u64>,
    reserved_inodes: u64,
}

impl MiniVFS {
    pub fn new(reserved: u64) -> Self {
        let now = current_timestamp();
        let root_inode = Inode {
            ino: 2,
            file_type: FileType::Directory,
            size: 0,
            uid: 0,
            gid: 0,
            mode: 0o755,
            atime: now,
            mtime: now,
            ctime: now,
            nlink: 2,
            blocks: Vec::new(),
        };

        let mut inodes = HashMap::new();
        inodes.insert(2, root_inode);

        let mut directories = HashMap::new();
        directories.insert(2, vec![
            DirEntry { name: ".".to_string(), ino: 2 },
            DirEntry { name: "..".to_string(), ino: 2 },
        ]);

        MiniVFS {
            inodes,
            directories,
            data_blocks: Vec::new(),
            next_ino: reserved + 1,
            free_inodes: Vec::new(),
            reserved_inodes: reserved,
        }
    }

    pub fn alloc_inode(&mut self, file_type: FileType, mode: u16) -> Option<u64> {
        let ino = if let Some(free_ino) = self.free_inodes.pop() {
            free_ino
        } else {
            let ino = self.next_ino;
            self.next_ino += 1;
            ino
        };

        let now = current_timestamp();
        let inode = Inode {
            ino,
            file_type,
            size: 0,
            uid: 0,
            gid: 0,
            mode,
            atime: now,
            mtime: now,
            ctime: now,
            nlink: 1,
            blocks: Vec::new(),
        };

        self.inodes.insert(ino, inode);
        Some(ino)
    }

    pub fn free_inode(&mut self, ino: u64) -> Result<(), VfsError> {
        if ino <= self.reserved_inodes {
            return Err(VfsError::InvalidInode);
        }
        if self.inodes.remove(&ino).is_none() {
            return Err(VfsError::NotFound);
        }
        self.directories.remove(&ino);
        self.free_inodes.push(ino);
        Ok(())
    }

    pub fn stat(&self, ino: u64) -> Option<&Inode> {
        self.inodes.get(&ino)
    }

    pub fn create_file(&mut self, parent_ino: u64, name: &str, mode: u16)
        -> Result<u64, VfsError>
    {
        let parent = self.inodes.get(&parent_ino).ok_or(VfsError::NotFound)?;
        if parent.file_type != FileType::Directory {
            return Err(VfsError::NotDirectory);
        }

        let entries = self.directories.get(&parent_ino).ok_or(VfsError::NotFound)?;
        if entries.iter().any(|e| e.name == name) {
            return Err(VfsError::AlreadyExists);
        }

        let ino = self.alloc_inode(FileType::Regular, mode).ok_or(VfsError::NoSpace)?;

        self.directories.get_mut(&parent_ino).unwrap().push(DirEntry {
            name: name.to_string(),
            ino,
        });

        let now = current_timestamp();
        if let Some(parent) = self.inodes.get_mut(&parent_ino) {
            parent.mtime = now;
            parent.ctime = now;
        }

        Ok(ino)
    }

    pub fn mkdir(&mut self, parent_ino: u64, name: &str, mode: u16)
        -> Result<u64, VfsError>
    {
        let parent = self.inodes.get(&parent_ino).ok_or(VfsError::NotFound)?;
        if parent.file_type != FileType::Directory {
            return Err(VfsError::NotDirectory);
        }

        let entries = self.directories.get(&parent_ino).ok_or(VfsError::NotFound)?;
        if entries.iter().any(|e| e.name == name) {
            return Err(VfsError::AlreadyExists);
        }

        let ino = self.alloc_inode(FileType::Directory, mode).ok_or(VfsError::NoSpace)?;

        self.directories.insert(ino, vec![
            DirEntry { name: ".".to_string(), ino },
            DirEntry { name: "..".to_string(), ino: parent_ino },
        ]);

        if let Some(inode) = self.inodes.get_mut(&ino) {
            inode.nlink = 2;
        }

        self.directories.get_mut(&parent_ino).unwrap().push(DirEntry {
            name: name.to_string(),
            ino,
        });

        let now = current_timestamp();
        if let Some(parent) = self.inodes.get_mut(&parent_ino) {
            parent.mtime = now;
            parent.ctime = now;
            parent.nlink += 1;
        }

        Ok(ino)
    }

    pub fn readdir(&self, ino: u64) -> Result<Vec<DirEntry>, VfsError> {
        let inode = self.inodes.get(&ino).ok_or(VfsError::NotFound)?;
        if inode.file_type != FileType::Directory {
            return Err(VfsError::NotDirectory);
        }
        self.directories.get(&ino)
            .cloned()
            .ok_or(VfsError::NotFound)
    }

    pub fn write(&mut self, ino: u64, offset: u64, data: &[u8])
        -> Result<usize, VfsError>
    {
        let inode = self.inodes.get_mut(&ino).ok_or(VfsError::NotFound)?;
        if inode.file_type != FileType::Regular {
            return Err(VfsError::NotDirectory);
        }

        let block_idx = if inode.blocks.is_empty() {
            let idx = self.data_blocks.len();
            self.data_blocks.push(Vec::new());
            inode.blocks.push(idx);
            idx
        } else {
            inode.blocks[0]
        };

        let block = &mut self.data_blocks[block_idx];
        let start = offset as usize;
        let end = start + data.len();

        if block.len() < end {
            block.resize(end, 0);
        }
        block[start..end].copy_from_slice(data);

        let now = current_timestamp();
        inode.size = block.len() as u64;
        inode.mtime = now;
        inode.ctime = now;

        Ok(data.len())
    }

    pub fn read(&mut self, ino: u64, offset: u64, buf: &mut [u8])
        -> Result<usize, VfsError>
    {
        let inode = self.inodes.get_mut(&ino).ok_or(VfsError::NotFound)?;
        if inode.file_type != FileType::Regular {
            return Err(VfsError::NotDirectory);
        }

        inode.atime = current_timestamp();

        if inode.blocks.is_empty() {
            return Ok(0);
        }

        let block = &self.data_blocks[inode.blocks[0]];
        let start = offset as usize;
        if start >= block.len() {
            return Ok(0);
        }

        let available = block.len() - start;
        let to_read = buf.len().min(available);
        buf[..to_read].copy_from_slice(&block[start..start + to_read]);

        Ok(to_read)
    }

    pub fn free_inode_count(&self) -> u64 {
        self.free_inodes.len() as u64
    }
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1: Utilisation de RefCell pour mutabilitÃ© intÃ©rieure
use std::cell::RefCell;

pub struct MiniVFS {
    inodes: RefCell<HashMap<u64, Inode>>,
    // Permet stat() de retourner une rÃ©fÃ©rence sans &mut self
}

// Alternative 2: Stockage des donnÃ©es dans l'inode directement
pub struct Inode {
    // ... autres champs
    pub data: Vec<u8>,  // Au lieu de blocks
}
```

### 4.5 Solutions refusÃ©es (avec explications)

```rust
// REFUSÃ‰: Pas de gestion des timestamps
pub fn write(&mut self, ino: u64, _offset: u64, data: &[u8]) -> Result<usize, VfsError> {
    // Oubli de mettre Ã  jour mtime et ctime
    let block = &mut self.data_blocks[...];
    block.extend(data);
    Ok(data.len())
}
// Pourquoi refusÃ©: Les timestamps sont essentiels pour un filesystem

// REFUSÃ‰: Inode root != 2
pub fn new(reserved: u64) -> Self {
    // ...
    let root_inode = Inode { ino: 1, ... };  // ERREUR: root doit Ãªtre 2
}
// Pourquoi refusÃ©: Convention ext2/3/4 violÃ©e

// REFUSÃ‰: RÃ©pertoires sans . et ..
pub fn mkdir(&mut self, parent_ino: u64, name: &str, mode: u16) -> Result<u64, VfsError> {
    let ino = self.alloc_inode(FileType::Directory, mode)?;
    self.directories.insert(ino, Vec::new());  // ERREUR: manque . et ..
    Ok(ino)
}
// Pourquoi refusÃ©: . et .. sont obligatoires dans tout rÃ©pertoire
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
use std::collections::{HashMap, BTreeMap};

pub struct MiniVFS {
    inodes: HashMap<u64, Inode>,
    directories: HashMap<u64, BTreeMap<String, u64>>,
    data_blocks: Vec<Vec<u8>>,
    next_ino: u64,
    free_inodes: Vec<u64>,
    reserved_inodes: u64,
}

impl MiniVFS {
    pub fn new(reserved: u64) -> Self {
        // ... mÃªme initialisation
        let mut root_entries = BTreeMap::new();
        root_entries.insert(".".to_string(), 2);
        root_entries.insert("..".to_string(), 2);
        directories.insert(2, root_entries);
        // ...
    }

    pub fn lookup(&self, parent_ino: u64, name: &str) -> Option<u64> {
        self.directories.get(&parent_ino)?.get(name).copied()
    }

    pub fn readdir(&self, ino: u64) -> Result<Vec<DirEntry>, VfsError> {
        let entries = self.directories.get(&ino).ok_or(VfsError::NotFound)?;
        Ok(entries.iter()
            .map(|(name, &ino)| DirEntry { name: name.clone(), ino })
            .collect())
    }
}
```

### 4.9 spec.json

```json
{
  "name": "minivfs_create",
  "language": "rust",
  "type": "complet",
  "tier": 3,
  "tier_info": "SynthÃ¨se",
  "tags": ["filesystem", "vfs", "inode", "phase2"],
  "passing_score": 70,

  "function": {
    "name": "MiniVFS::new",
    "prototype": "pub fn new(reserved: u64) -> Self",
    "return_type": "MiniVFS",
    "parameters": [
      {"name": "reserved", "type": "u64"}
    ]
  },

  "driver": {
    "reference": "impl MiniVFS { pub fn new(reserved: u64) -> Self { let now = current_timestamp(); let root_inode = Inode { ino: 2, file_type: FileType::Directory, size: 0, uid: 0, gid: 0, mode: 0o755, atime: now, mtime: now, ctime: now, nlink: 2, blocks: Vec::new() }; let mut inodes = HashMap::new(); inodes.insert(2, root_inode); let mut directories = HashMap::new(); directories.insert(2, vec![DirEntry { name: \".\".to_string(), ino: 2 }, DirEntry { name: \"..\".to_string(), ino: 2 }]); MiniVFS { inodes, directories, data_blocks: Vec::new(), next_ino: reserved + 1, free_inodes: Vec::new(), reserved_inodes: reserved } } }",

    "edge_cases": [
      {
        "name": "root_exists",
        "args": [10],
        "check": "vfs.stat(2).is_some()",
        "is_trap": true,
        "trap_explanation": "L'inode 2 (root) doit toujours exister"
      },
      {
        "name": "root_is_directory",
        "args": [10],
        "check": "vfs.stat(2).unwrap().file_type == FileType::Directory",
        "is_trap": true,
        "trap_explanation": "Root doit Ãªtre un rÃ©pertoire"
      },
      {
        "name": "root_has_dot_entries",
        "args": [10],
        "check": "vfs.readdir(2).unwrap().iter().any(|e| e.name == \".\")",
        "is_trap": true,
        "trap_explanation": "Root doit contenir l'entrÃ©e ."
      },
      {
        "name": "inode_above_reserved",
        "args": [10],
        "check": "vfs.alloc_inode(FileType::Regular, 0o644).unwrap() > 10",
        "is_trap": true,
        "trap_explanation": "Les nouveaux inodes doivent Ãªtre > reserved"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 100,
      "generators": [
        {
          "type": "int",
          "param_index": 0,
          "params": {"min": 1, "max": 100}
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["HashMap::new", "Vec::new", "SystemTime::now"],
    "forbidden_functions": ["std::fs::*", "unsafe"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Root inode Ã  1 au lieu de 2 */
pub fn new(reserved: u64) -> Self {
    let root_inode = Inode { ino: 1, ... };  // BUG: devrait Ãªtre 2
    inodes.insert(1, root_inode);
    // ...
}
// Pourquoi c'est faux : Convention ext non respectÃ©e
// Ce qui Ã©tait pensÃ© : "1 c'est le premier, donc root"

/* Mutant B (Safety) : Pas de vÃ©rification parent exists */
pub fn create_file(&mut self, parent_ino: u64, name: &str, mode: u16) -> Result<u64, VfsError> {
    // BUG: pas de vÃ©rification que parent_ino existe
    let ino = self.alloc_inode(FileType::Regular, mode).unwrap();
    self.directories.get_mut(&parent_ino).unwrap().push(...);  // Panic potentiel
    Ok(ino)
}
// Pourquoi c'est faux : Panic si parent n'existe pas
// Ce qui Ã©tait pensÃ© : "Le parent existe toujours"

/* Mutant C (Resource) : Pas de rÃ©utilisation des inodes libÃ©rÃ©s */
pub fn alloc_inode(&mut self, file_type: FileType, mode: u16) -> Option<u64> {
    // BUG: ignore free_inodes, toujours incrÃ©mente
    let ino = self.next_ino;
    self.next_ino += 1;
    // ...
}
// Pourquoi c'est faux : Fuite de numÃ©ros d'inode
// Ce qui Ã©tait pensÃ© : "Plus simple sans rÃ©utilisation"

/* Mutant D (Logic) : Timestamps jamais mis Ã  jour */
pub fn write(&mut self, ino: u64, offset: u64, data: &[u8]) -> Result<usize, VfsError> {
    // BUG: oubli de mettre Ã  jour mtime
    let block = &mut self.data_blocks[...];
    block.extend(data);
    Ok(data.len())
}
// Pourquoi c'est faux : Violation sÃ©mantique POSIX
// Ce qui Ã©tait pensÃ© : "Les timestamps c'est optionnel"

/* Mutant E (Return) : mkdir sans . et .. */
pub fn mkdir(&mut self, parent_ino: u64, name: &str, mode: u16) -> Result<u64, VfsError> {
    let ino = self.alloc_inode(FileType::Directory, mode)?;
    self.directories.insert(ino, Vec::new());  // BUG: vide
    Ok(ino)
}
// Pourquoi c'est faux : RÃ©pertoires invalides sans . et ..
// Ce qui Ã©tait pensÃ© : ". et .. seront ajoutÃ©s plus tard"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Architecture des systÃ¨mes de fichiers** : SÃ©paration mÃ©tadonnÃ©es/donnÃ©es
2. **Structure inode** : Le cÅ“ur de tout filesystem Unix
3. **Gestion des rÃ©pertoires** : Mapping nom â†’ inode
4. **Timestamps POSIX** : atime, mtime, ctime et leur sÃ©mantique
5. **Allocation de ressources** : Gestion d'un pool d'identifiants

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION new QUI RETOURNE UNE STRUCTURE MiniVFS ET PREND EN PARAMÃˆTRE reserved QUI EST UN ENTIER NON SIGNÃ‰ 64 BITS
DÃ‰BUT FONCTION
    DÃ‰CLARER now COMME ENTIER NON SIGNÃ‰ 64 BITS
    AFFECTER L'APPEL Ã€ current_timestamp Ã€ now

    DÃ‰CLARER root_inode COMME STRUCTURE Inode
    AFFECTER 2 AU CHAMP ino DE root_inode
    AFFECTER Directory AU CHAMP file_type DE root_inode
    AFFECTER 0 AU CHAMP size DE root_inode
    AFFECTER now AUX CHAMPS atime, mtime, ctime DE root_inode
    AFFECTER 2 AU CHAMP nlink DE root_inode

    DÃ‰CLARER inodes COMME HASHMAP DE u64 VERS Inode
    INSÃ‰RER root_inode Ã€ LA CLÃ‰ 2 DANS inodes

    DÃ‰CLARER directories COMME HASHMAP DE u64 VERS VECTEUR DE DirEntry
    DÃ‰CLARER root_entries COMME VECTEUR DE DirEntry
    AJOUTER DirEntry AVEC name="." ET ino=2 Ã€ root_entries
    AJOUTER DirEntry AVEC name=".." ET ino=2 Ã€ root_entries
    INSÃ‰RER root_entries Ã€ LA CLÃ‰ 2 DANS directories

    RETOURNER MiniVFS AVEC inodes, directories, next_ino=reserved+1, free_inodes VIDE
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : CrÃ©ation VFS
---
1. OBTENIR le timestamp actuel

2. CRÃ‰ER l'inode root :
   a. NumÃ©ro = 2 (convention ext)
   b. Type = Directory
   c. Permissions = 0755
   d. nlink = 2 (pour . et ..)

3. INITIALISER la table d'inodes :
   a. InsÃ©rer root Ã  la clÃ© 2

4. INITIALISER les rÃ©pertoires :
   a. CrÃ©er entries [., ..] pour root
   b. Les deux pointent vers inode 2

5. CONFIGURER l'allocateur :
   a. next_ino = reserved + 1
   b. free_inodes = vide

6. RETOURNER la structure VFS
```

### 5.3 Visualisation ASCII

```
                         MINIVFS ARCHITECTURE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   INODE TABLE (HashMap<u64, Inode>)                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ ino=2  â”‚ type=Dir  â”‚ size=0 â”‚ mode=755 â”‚ nlink=2      â”‚   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚   â”‚ ino=11 â”‚ type=File â”‚ size=42â”‚ mode=644 â”‚ nlink=1      â”‚   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚   â”‚ ino=12 â”‚ type=Dir  â”‚ size=0 â”‚ mode=755 â”‚ nlink=2      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â”‚                                  â”‚
â”‚                              â–¼                                  â”‚
â”‚   DIRECTORIES (HashMap<u64, Vec<DirEntry>>)                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ ino=2 (root)                                            â”‚  â”‚
â”‚   â”‚   â”œâ”€â”€ "."      â†’ ino=2                                  â”‚  â”‚
â”‚   â”‚   â”œâ”€â”€ ".."     â†’ ino=2                                  â”‚  â”‚
â”‚   â”‚   â”œâ”€â”€ "hello"  â†’ ino=11                                 â”‚  â”‚
â”‚   â”‚   â””â”€â”€ "subdir" â†’ ino=12                                 â”‚  â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚   â”‚ ino=12 (subdir)                                         â”‚  â”‚
â”‚   â”‚   â”œâ”€â”€ "."      â†’ ino=12                                 â”‚  â”‚
â”‚   â”‚   â””â”€â”€ ".."     â†’ ino=2                                  â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                  â”‚
â”‚                              â–¼                                  â”‚
â”‚   DATA BLOCKS (Vec<Vec<u8>>)                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ [0] â”‚ "Hello, World!\n" â”‚ â† ino=11.blocks[0]           â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

            INODE STRUCTURE DETAIL
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ ino: 11                 â”‚ â† Identifiant unique
            â”‚ file_type: Regular      â”‚
            â”‚ size: 14                â”‚ â† Bytes
            â”‚ uid: 1000               â”‚
            â”‚ gid: 1000               â”‚
            â”‚ mode: 0o644             â”‚ â† rw-r--r--
            â”‚ atime: 1705420800       â”‚ â† Dernier accÃ¨s
            â”‚ mtime: 1705420700       â”‚ â† DerniÃ¨re modif
            â”‚ ctime: 1705420600       â”‚ â† Changement mÃ©ta
            â”‚ nlink: 1                â”‚ â† Hard links
            â”‚ blocks: [0]             â”‚ â† Index data_blocks
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| Root ino != 2 | Utiliser 0 ou 1 pour root | Toujours `ino: 2` |
| Oubli . et .. | RÃ©pertoires sans entrÃ©es spÃ©ciales | Ajouter dans mkdir() |
| Timestamps figÃ©s | Ne pas mettre Ã  jour atime/mtime | Appeler `current_timestamp()` |
| RÃ©utilisation ino | Ne pas recycler les inodes libÃ©rÃ©s | Utiliser `free_inodes` |

### 5.5 Cours Complet

#### 5.5.1 L'inode : CÅ“ur du Filesystem

L'**inode** (index node) est la structure de donnÃ©es fondamentale des systÃ¨mes de fichiers Unix. CrÃ©Ã© par Ken Thompson et Dennis Ritchie pour Unix en 1971, ce concept est toujours au cÅ“ur de Linux, macOS, et BSD.

**Principe fondamental** : L'inode contient TOUTES les mÃ©tadonnÃ©es d'un fichier SAUF son nom.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CE QUE CONTIENT UN INODE                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ Type (fichier, rÃ©pertoire, lien, socket, etc.)           â”‚
â”‚ âœ“ Permissions (mode)                                        â”‚
â”‚ âœ“ PropriÃ©taire (UID, GID)                                  â”‚
â”‚ âœ“ Taille en bytes                                          â”‚
â”‚ âœ“ Timestamps (atime, mtime, ctime)                         â”‚
â”‚ âœ“ Nombre de hard links (nlink)                             â”‚
â”‚ âœ“ Pointeurs vers les blocs de donnÃ©es                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  CE QU'IL NE CONTIENT PAS                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ— Le nom du fichier                                        â”‚
â”‚ âœ— Le chemin du fichier                                     â”‚
â”‚ âœ— Les donnÃ©es elles-mÃªmes                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 5.5.2 Les Timestamps POSIX

Les trois timestamps ont des sÃ©mantiques prÃ©cises :

| Timestamp | Nom | Mis Ã  jour quand... |
|-----------|-----|---------------------|
| `atime` | Access time | Lecture du contenu (read, exec) |
| `mtime` | Modification time | Modification du contenu (write) |
| `ctime` | Change time | Modification des mÃ©tadonnÃ©es (chmod, chown) |

**Note importante** : `ctime` n'est PAS "creation time" ! Unix ne stocke pas la date de crÃ©ation (avant ext4 avec `crtime`).

#### 5.5.3 Les entrÃ©es . et ..

Chaque rÃ©pertoire Unix contient deux entrÃ©es spÃ©ciales :
- `.` (point) : Pointe vers le rÃ©pertoire lui-mÃªme
- `..` (double point) : Pointe vers le parent

```
$ ls -la /home/user
drwxr-xr-x  5 user user 4096 Jan 15 10:00 .      â† inode de /home/user
drwxr-xr-x 10 root root 4096 Jan 10 08:00 ..     â† inode de /home
```

C'est pourquoi un rÃ©pertoire vide a toujours `nlink=2` : lui-mÃªme (.) et l'entrÃ©e dans le parent.

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais interdit)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ fn new(reserved: u64) -> Self {                                 â”‚
â”‚     let mut vfs = MiniVFS::default();                           â”‚
â”‚     vfs.reserved = reserved;                                    â”‚
â”‚     vfs  // Pas de root initialisÃ© !                            â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ fn new(reserved: u64) -> Self {                                 â”‚
â”‚     // CrÃ©er root inode                                         â”‚
â”‚     // Initialiser directories avec . et ..                     â”‚
â”‚     // Configurer next_ino > reserved                           â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Un VFS sans root est inutilisable                            â”‚
â”‚ â€¢ Les conventions ext doivent Ãªtre respectÃ©es                  â”‚
â”‚ â€¢ L'Ã©tat initial doit Ãªtre cohÃ©rent                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**ScÃ©nario** : `vfs.mkdir(2, "home", 0o755)`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                          â”‚ Ã‰tat           â”‚ Explication     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ stat(2) pour vÃ©rifier parent         â”‚ Some(&root)    â”‚ Parent existe   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ VÃ©rifier root.file_type == Directory â”‚ true           â”‚ Parent est dir  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ VÃ©rifier "home" pas dÃ©jÃ  prÃ©sent     â”‚ false          â”‚ Nom disponible  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ alloc_inode(Directory, 0o755)        â”‚ ino=11         â”‚ Nouvel inode    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ CrÃ©er entries [., ..]                â”‚ [(".", 11),    â”‚ EntrÃ©es spÃ©c.   â”‚
â”‚       â”‚                                      â”‚  ("..", 2)]    â”‚                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Ajouter "home"â†’11 Ã  root             â”‚ root.entries++ â”‚ Lien crÃ©Ã©       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ root.nlink += 1                      â”‚ nlink=3        â”‚ Pour .. de home â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ root.mtime = now                     â”‚ updated        â”‚ ModifiÃ©         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ return Ok(11)                        â”‚ â€”              â”‚ SuccÃ¨s          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ”¥ MEME : "There is no spoon" â€” VFS

![Matrix Spoon](matrix_spoon.jpg)

"Il n'y a pas de disque... Ce n'est pas le fichier qui est sauvegardÃ©, c'est ton programme qui le pense."

Un VFS est comme la Matrix : une simulation parfaite qui fait croire au programme qu'il manipule de vrais fichiers sur disque.

```rust
// ğŸ”´ Crois-tu vraiment Ã©crire sur disque ?
vfs.write(ino, 0, b"Hello");  // Non, c'est juste en RAM !
```

#### ğŸ´â€â˜ ï¸ MEME : "Inode 2 : The One"

Comme Neo est "The One" dans la Matrix, l'inode 2 est "The Root" dans tout filesystem ext. Pas 0, pas 1, toujours 2.

```rust
// Neo = 2, pas 1 !
const ROOT_INO: u64 = 2;  // Convention depuis 1970
```

### 5.9 Applications pratiques

1. **tmpfs/ramfs** : SystÃ¨mes de fichiers Linux entiÃ¨rement en RAM
2. **Docker layers** : Overlayfs utilise des VFS empilÃ©s
3. **Tests unitaires** : Mocker le filesystem pour tester sans I/O disque
4. **Jeux vidÃ©o** : Archives de ressources (PAK, WAD) exposÃ©es comme filesystem
5. **Forensics** : Reconstruction de filesystem pour analyse

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | ConsÃ©quence | DÃ©tection |
|---|-------|-------------|-----------|
| 1 | Root ino != 2 | IncompatibilitÃ© ext | Test `stat(2)` |
| 2 | Pas de . et .. | `cd ..` cassÃ© | Test `readdir` |
| 3 | Timestamps ignorÃ©s | Violation POSIX | Test aprÃ¨s write/read |
| 4 | Pas de validation parent | Panic sur parent invalide | Test avec ino=9999 |
| 5 | next_ino <= reserved | Collision avec systÃ¨me | Test alloc_inode |

---

## ğŸ“ SECTION 7 : QCM

### Q1. Quel est le numÃ©ro d'inode du rÃ©pertoire racine dans ext2/3/4 ?

- A) 0
- B) 1
- C) 2
- D) 10
- E) Le premier disponible
- F) Configurable
- G) DÃ©pend du systÃ¨me
- H) 4096
- I) -1
- J) Aucune de ces rÃ©ponses

**RÃ©ponse : C**

### Q2. Que contient un inode ?

- A) Le nom du fichier
- B) Les donnÃ©es du fichier
- C) Le chemin complet
- D) Les mÃ©tadonnÃ©es (permissions, taille, timestamps)
- E) Le contenu du rÃ©pertoire parent
- F) L'historique des modifications
- G) Les commentaires utilisateur
- H) La date de crÃ©ation
- I) Le hash MD5
- J) Toutes les informations ci-dessus

**RÃ©ponse : D**

### Q3. Que signifie `ctime` dans un inode ?

- A) Creation time
- B) Change time (mÃ©tadonnÃ©es)
- C) Close time
- D) Copy time
- E) Compression time
- F) Cache time
- G) Check time
- H) Current time
- I) Commit time
- J) Count time

**RÃ©ponse : B**

### Q4. Pourquoi un rÃ©pertoire vide a-t-il nlink=2 ?

- A) Bug historique
- B) Pour . (lui-mÃªme) et l'entrÃ©e dans le parent
- C) RÃ©servÃ© pour le systÃ¨me
- D) Convention arbitraire
- E) DÃ©pend du filesystem
- F) Optimisation
- G) SÃ©curitÃ©
- H) CompatibilitÃ© Windows
- I) Cache filesystem
- J) Alignement mÃ©moire

**RÃ©ponse : B**

### Q5. Quand mtime est-il mis Ã  jour ?

- A) Ã€ chaque ouverture du fichier
- B) Uniquement Ã  la crÃ©ation
- C) Lors de la modification du contenu
- D) Lors du changement de permissions
- E) Ã€ chaque lecture
- F) Jamais automatiquement
- G) Toutes les secondes
- H) Au dÃ©montage du filesystem
- I) Lors du renommage
- J) Ã€ la fermeture du fichier

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Valeur |
|---------|--------|
| DifficultÃ© | â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†â˜† (5/10) |
| Temps estimÃ© | 90 min |
| XP Base | 150 |
| XP Bonus (Ã—2) | 300 |
| Concepts clÃ©s | Inode, VFS, Timestamps, RÃ©pertoires |
| Langage | Rust 2024 |
| Type | complet |
| Tier | 3 â€” SynthÃ¨se |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.3.1-minivfs-create",
    "generated_at": "2025-01-16 14:00:00",

    "metadata": {
      "exercise_id": "2.3.1",
      "exercise_name": "minivfs_create",
      "module": "2.3.1",
      "module_name": "SystÃ¨mes de Fichiers Virtuels",
      "concept": "a",
      "concept_name": "Virtual Filesystem Implementation",
      "type": "complet",
      "tier": 3,
      "tier_info": "SynthÃ¨se",
      "phase": 2,
      "difficulty": 5,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†â˜†",
      "language": "rust",
      "duration_minutes": 90,
      "xp_base": 150,
      "xp_bonus_multiplier": 2,
      "bonus_tier": "STANDARD",
      "bonus_icon": "âš¡",
      "complexity_time": "T3 O(1)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["structures_donnees", "rust_ownership"],
      "domains": ["FS", "Struct", "Mem"],
      "domains_bonus": ["Algo"],
      "tags": ["filesystem", "vfs", "inode", "rust"],
      "meme_reference": "The Matrix - There is no spoon"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.rs -s spec.json --validate"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” L'excellence pÃ©dagogique ne se nÃ©gocie pas*
*Phase 2 â€” Module 2.3.1 â€” Virtual Filesystem*
