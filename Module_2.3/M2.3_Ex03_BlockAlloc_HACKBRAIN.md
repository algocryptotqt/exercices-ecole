# Exercice 2.3.3 : block_allocator

**Module :**
2.3.3 â€” StratÃ©gies d'Allocation de Blocs

**Concept :**
a â€” ImplÃ©mentation et comparaison des stratÃ©gies d'allocation (contigu, indexÃ©, extents)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
3 â€” SynthÃ¨se (allocation contiguÃ«, indexÃ©e multi-niveaux, extents)

**Langage :**
Rust (Edition 2024)

**PrÃ©requis :**
- Structures de donnÃ©es (HashMap, BTreeMap, VecDeque)
- Concepts d'allocation mÃ©moire
- SystÃ¨mes de fichiers (inodes, blocs)
- Notions de fragmentation

**Domaines :**
FS, Struct, Algo, Mem

**DurÃ©e estimÃ©e :**
150 min

**XP Base :**
200

**ComplexitÃ© :**
T3 O(n) pour best-fit Ã— S3 O(n) pour stockage

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
```
src/lib.rs
```

**Fonctions autorisÃ©es :**
- `std::collections::{HashMap, BTreeMap, VecDeque}`
- `std::vec::Vec`

**Fonctions interdites :**
- Allocation systÃ¨me directe (`libc::malloc`)
- `unsafe` blocks

### 1.2 Consigne

**Section 2.4.1 â€” Contexte Culturel**

**ğŸ® MINECRAFT â€” Block Placement Strategy**

Dans Minecraft, chaque chunk (16Ã—16Ã—256 blocs) doit stocker des millions de blocs de maniÃ¨re efficace. Le jeu utilise des stratÃ©gies similaires Ã  celles des filesystems :

- **Allocation contiguÃ«** : Comme construire une maison bloc par bloc â€” si tu veux agrandir, tu dois trouver de l'espace adjacent libre
- **Allocation par extents** : Comme les "sections" de chunk â€” des rÃ©gions contiguÃ«s qui peuvent Ãªtre de tailles variables
- **Blocs indirects** : Comme les coffres qui contiennent des coffres qui contiennent des items â€” plusieurs niveaux de "pointeurs"

**L'analogie parfaite :** La **fragmentation** dans un filesystem, c'est comme un monde Minecraft oÃ¹ des joueurs ont construit et dÃ©truit plein de petites structures partout â€” il reste plein de petits espaces vides impossibles Ã  utiliser pour de grandes constructions. La **dÃ©fragmentation**, c'est comme "compacter" tout Ã§a pour rÃ©cupÃ©rer de l'espace contigu.

---

**Section 2.4.2 â€” Ã‰noncÃ© AcadÃ©mique**

Les **stratÃ©gies d'allocation de blocs** sont au cÅ“ur de tout systÃ¨me de fichiers. Elles dÃ©terminent :
- Comment trouver de l'espace libre pour un nouveau fichier
- Comment organiser les blocs d'un fichier (contigus ou dispersÃ©s)
- Comment gÃ©rer la fragmentation au fil du temps

Les trois stratÃ©gies principales sont :

1. **Allocation contiguÃ«** : Tous les blocs d'un fichier sont adjacents
   - Avantage : Lecture sÃ©quentielle trÃ¨s rapide
   - InconvÃ©nient : Fragmentation externe, difficile d'agrandir

2. **Allocation indexÃ©e (ext2/3/4)** : Table de pointeurs dans l'inode
   - Direct : 12 pointeurs directs vers des blocs
   - Indirect : 1 pointeur vers un bloc de pointeurs (512 pointeurs si bloc=4KB, pointeur=8B)
   - Double indirect : 1 pointeur â†’ bloc de pointeurs â†’ blocs de pointeurs
   - Triple indirect : Encore un niveau

3. **Allocation par extents (ext4, btrfs)** : Plages contiguÃ«s (start, length)
   - Avantage : Compact, bon pour gros fichiers sÃ©quentiels
   - NÃ©cessite fusion des extents adjacents

**Ta mission :**

ImplÃ©menter trois allocateurs en Rust :
1. `ContiguousAllocator` : Allocation contiguÃ« avec best-fit
2. `LinkedAllocator` : Liste chaÃ®nÃ©e de blocs libres
3. `ExtentAllocator` : Allocation par extents avec fusion

Plus un gestionnaire de fichiers avec blocs indirects multi-niveaux.

**EntrÃ©e :**
- `total_blocks: usize` : Nombre total de blocs disponibles

**Sortie :**
- Allocateurs fonctionnels implÃ©mentant le trait `BlockAllocator`

**Contraintes :**
- Les blocs sont numÃ©rotÃ©s de 0 Ã  total_blocks-1
- L'allocateur doit tracker la fragmentation
- Les extents doivent fusionner automatiquement
- Le gestionnaire de fichiers doit supporter jusqu'Ã  triple indirect

**Exemples :**

| OpÃ©ration | RÃ©sultat | Explication |
|-----------|----------|-------------|
| `ContiguousAllocator::new(1000)` | Allocateur avec 1000 blocs | Tous libres |
| `alloc.allocate(10)` | `Ok([0,1,2,...,9])` | 10 blocs contigus |
| `alloc.free(&[0,1,2,3,4])` | `Ok(())` | LibÃ¨re 5 blocs |
| `alloc.fragmentation()` | 0.15 | 15% de fragmentation |

### 1.3 Prototype

```rust
use std::collections::{BTreeMap, VecDeque};

pub const BLOCK_SIZE: usize = 4096;
pub const DIRECT_BLOCKS: usize = 12;
pub const PTRS_PER_BLOCK: usize = BLOCK_SIZE / 8; // 512 pointeurs 64-bit

#[derive(Debug, PartialEq)]
pub enum AllocError {
    NoSpace,
    InvalidBlock,
    FragmentationTooHigh,
    BlockNotAllocated,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Extent {
    pub start: u64,
    pub length: u32,
    pub logical: u64,
}

#[derive(Debug, Clone)]
pub struct IndexedInode {
    pub direct: [Option<u64>; DIRECT_BLOCKS],
    pub indirect: Option<u64>,
    pub double_indirect: Option<u64>,
    pub triple_indirect: Option<u64>,
    pub size: u64,
    pub blocks_count: u64,
}

pub trait BlockAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError>;
    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError>;
    fn free_count(&self) -> usize;
    fn fragmentation(&self) -> f64;
}

pub struct ContiguousAllocator { /* ... */ }
pub struct LinkedAllocator { /* ... */ }
pub struct ExtentAllocator { /* ... */ }

pub struct IndexedFileManager { /* ... */ }

impl IndexedFileManager {
    pub fn new(allocator: Box<dyn BlockAllocator>, total_blocks: usize) -> Self;
    pub fn create_inode(&self) -> IndexedInode;
    pub fn write(&mut self, inode: &mut IndexedInode, offset: u64, data: &[u8])
        -> Result<usize, AllocError>;
    pub fn read(&self, inode: &IndexedInode, offset: u64, buf: &mut [u8])
        -> Result<usize, AllocError>;
    pub fn write_amplification(&self) -> f64;
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 La rÃ©volution des extents dans ext4

ext3 utilisait uniquement des blocs indirects. Un fichier de 1GB nÃ©cessitait des centaines de milliers de pointeurs individuels ! ext4 a introduit les **extents** : une seule structure `(start=1000, length=262144)` remplace 262144 pointeurs.

### 2.2 Write Amplification

Quand tu Ã©cris 1 bloc de donnÃ©es, le filesystem peut Ã©crire beaucoup plus :
- Le bloc de donnÃ©es lui-mÃªme
- Mise Ã  jour du bloc indirect (si nouveau bloc)
- Mise Ã  jour du journal
- Mise Ã  jour des mÃ©tadonnÃ©es (mtime, size)

C'est le **write amplification factor** (WAF). Les SSD sont particuliÃ¨rement sensibles Ã  ce phÃ©nomÃ¨ne.

---

## ğŸ“‹ SECTION 2.5 : DANS LA VRAIE VIE

| MÃ©tier | Utilisation du concept |
|--------|------------------------|
| **Filesystem Developer** | ImplÃ©mentation de btrfs, ZFS, ext4 |
| **Database Engineer** | Allocation de pages dans PostgreSQL, MySQL |
| **SSD Firmware Engineer** | Minimisation du write amplification |
| **Game Developer** | Allocation de chunks dans les jeux open-world |
| **Cloud Storage** | StratÃ©gies d'allocation distribuÃ©e |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling block_alloc v0.1.0
    Finished test [unoptimized + debuginfo]
    Running unittests src/lib.rs

running 8 tests
test tests::test_contiguous_allocator ... ok
test tests::test_fragmentation ... ok
test tests::test_extent_coalescing ... ok
test tests::test_indexed_inode_direct ... ok
test tests::test_indexed_inode_indirect ... ok
test tests::test_double_indirect ... ok
test tests::test_logical_to_physical ... ok
test tests::test_write_amplification ... ok

test result: ok. 8 passed; 0 failed; 0 ignored
```

---

## ğŸ”¥ SECTION 3.1 : BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(log n) pour allocation avec B-tree

**Space Complexity attendue :**
O(1) auxiliaire

**Domaines Bonus :**
`Algo, Struct`

### 3.1.1 Consigne Bonus

**ğŸ® MINECRAFT HARDCORE â€” Chunk Optimization**

En mode Hardcore, chaque erreur est fatale. ImplÃ©mente une version optimisÃ©e utilisant un **B-tree** pour les extents libres, garantissant O(log n) pour toutes les opÃ©rations.

**Ta mission :**

1. Utiliser `BTreeMap` pour les extents libres, triÃ©s par taille ET par position
2. ImplÃ©menter une stratÃ©gie **worst-fit** (allouer depuis le plus grand extent)
3. Ajouter la **compaction** : rÃ©organiser les blocs pour Ã©liminer la fragmentation

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Allocation : O(log n)                  â”‚
â”‚  LibÃ©ration avec fusion : O(log n)      â”‚
â”‚  Compaction : O(n)                      â”‚
â”‚  Fragmentation aprÃ¨s compact : 0%       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```rust
pub struct OptimizedExtentAllocator {
    by_size: BTreeMap<u32, BTreeSet<u64>>,   // length -> set of starts
    by_start: BTreeMap<u64, u32>,             // start -> length
    total_blocks: usize,
    free_blocks: usize,
}

impl OptimizedExtentAllocator {
    pub fn compact(&mut self, file_manager: &mut IndexedFileManager)
        -> Result<usize, AllocError>;  // Returns blocks moved
}
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Structure extents | `BTreeMap<u64, u32>` | Double index (taille + position) |
| StratÃ©gie | Best-fit O(n) | Worst-fit O(log n) |
| Compaction | Non | Oui |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `test_contiguous_basic` | alloc(10) | 10 blocs contigus | 10 |
| `test_best_fit` | Alloc/free/alloc pattern | Choisit plus petit fit | 15 |
| `test_extent_coalesce` | free(0-9), free(10-19) | 1 extent [0,20) | 15 |
| `test_direct_blocks` | write 5 blocs | direct[0-4] remplis | 15 |
| `test_indirect_allocation` | write 20 blocs | indirect utilisÃ© | 15 |
| `test_double_indirect` | write 600 blocs | double_indirect utilisÃ© | 15 |
| `test_fragmentation_calc` | Pattern fragmentÃ© | frag > 0.1 | 10 |
| `test_wa_factor` | Ã‰criture avec indirects | WA > 1.0 | 5 |

### 4.2 main.rs de test

```rust
use block_alloc::*;

fn main() {
    // Test allocateur contigu
    let mut alloc = ContiguousAllocator::new(1000);
    let blocks = alloc.allocate(10).expect("Allocation failed");
    println!("Allocated blocks: {:?}", blocks);
    println!("Fragmentation: {:.2}%", alloc.fragmentation() * 100.0);

    // Test gestionnaire de fichiers
    let alloc = Box::new(ContiguousAllocator::new(10000));
    let mut mgr = IndexedFileManager::new(alloc, 10000);
    let mut inode = mgr.create_inode();

    let data = vec![0xABu8; BLOCK_SIZE * 20];
    let written = mgr.write(&mut inode, 0, &data).expect("Write failed");
    println!("Wrote {} bytes", written);
    println!("Blocks used: {}", inode.blocks_count);
    println!("Uses indirect: {}", inode.indirect.is_some());
    println!("Write amplification: {:.2}", mgr.write_amplification());
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use std::collections::{BTreeMap, VecDeque};

pub const BLOCK_SIZE: usize = 4096;
pub const DIRECT_BLOCKS: usize = 12;
pub const PTRS_PER_BLOCK: usize = BLOCK_SIZE / 8;

#[derive(Debug, PartialEq)]
pub enum AllocError {
    NoSpace,
    InvalidBlock,
    FragmentationTooHigh,
    BlockNotAllocated,
}

#[derive(Debug, Clone)]
pub struct IndexedInode {
    pub direct: [Option<u64>; DIRECT_BLOCKS],
    pub indirect: Option<u64>,
    pub double_indirect: Option<u64>,
    pub triple_indirect: Option<u64>,
    pub size: u64,
    pub blocks_count: u64,
}

pub trait BlockAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError>;
    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError>;
    fn free_count(&self) -> usize;
    fn fragmentation(&self) -> f64;
}

// Allocateur contigu avec bitmap
pub struct ContiguousAllocator {
    bitmap: Vec<bool>,
    total_blocks: usize,
    free_blocks: usize,
}

impl ContiguousAllocator {
    pub fn new(total_blocks: usize) -> Self {
        ContiguousAllocator {
            bitmap: vec![false; total_blocks],
            total_blocks,
            free_blocks: total_blocks,
        }
    }

    fn find_best_fit(&self, count: usize) -> Option<u64> {
        let mut best_start: Option<u64> = None;
        let mut best_size = usize::MAX;
        let mut current_start: Option<usize> = None;
        let mut current_size = 0;

        for i in 0..=self.bitmap.len() {
            let is_free = i < self.bitmap.len() && !self.bitmap[i];

            if is_free {
                if current_start.is_none() {
                    current_start = Some(i);
                }
                current_size += 1;
            } else {
                if let Some(start) = current_start {
                    if current_size >= count && current_size < best_size {
                        best_start = Some(start as u64);
                        best_size = current_size;
                    }
                }
                current_start = None;
                current_size = 0;
            }
        }
        best_start
    }
}

impl BlockAllocator for ContiguousAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError> {
        if count > self.free_blocks {
            return Err(AllocError::NoSpace);
        }

        let start = self.find_best_fit(count).ok_or(AllocError::NoSpace)?;
        let blocks: Vec<u64> = (start..start + count as u64).collect();

        for &b in &blocks {
            self.bitmap[b as usize] = true;
        }
        self.free_blocks -= count;

        Ok(blocks)
    }

    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError> {
        for &b in blocks {
            if b as usize >= self.total_blocks {
                return Err(AllocError::InvalidBlock);
            }
            if !self.bitmap[b as usize] {
                return Err(AllocError::BlockNotAllocated);
            }
            self.bitmap[b as usize] = false;
            self.free_blocks += 1;
        }
        Ok(())
    }

    fn free_count(&self) -> usize {
        self.free_blocks
    }

    fn fragmentation(&self) -> f64 {
        if self.free_blocks == 0 {
            return 0.0;
        }

        let mut fragments = 0;
        let mut in_free_region = false;

        for &allocated in &self.bitmap {
            if !allocated {
                if !in_free_region {
                    fragments += 1;
                    in_free_region = true;
                }
            } else {
                in_free_region = false;
            }
        }

        if fragments <= 1 {
            0.0
        } else {
            (fragments as f64 - 1.0) / self.free_blocks as f64
        }
    }
}

// Allocateur par extents
pub struct ExtentAllocator {
    extents: BTreeMap<u64, u32>,
    total_blocks: usize,
    free_blocks: usize,
}

impl ExtentAllocator {
    pub fn new(total_blocks: usize) -> Self {
        let mut extents = BTreeMap::new();
        extents.insert(0, total_blocks as u32);
        ExtentAllocator {
            extents,
            total_blocks,
            free_blocks: total_blocks,
        }
    }

    fn coalesce(&mut self) {
        let mut new_extents = BTreeMap::new();
        let mut iter = self.extents.iter();

        if let Some((&first_start, &first_len)) = iter.next() {
            let mut current_start = first_start;
            let mut current_len = first_len;

            for (&start, &len) in iter {
                if current_start + current_len as u64 == start {
                    current_len += len;
                } else {
                    new_extents.insert(current_start, current_len);
                    current_start = start;
                    current_len = len;
                }
            }
            new_extents.insert(current_start, current_len);
        }

        self.extents = new_extents;
    }
}

impl BlockAllocator for ExtentAllocator {
    fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError> {
        let count_u32 = count as u32;

        let extent_to_use = self.extents.iter()
            .find(|(_, &len)| len >= count_u32)
            .map(|(&start, &len)| (start, len));

        let (start, len) = extent_to_use.ok_or(AllocError::NoSpace)?;

        self.extents.remove(&start);
        if len > count_u32 {
            self.extents.insert(start + count as u64, len - count_u32);
        }

        self.free_blocks -= count;
        Ok((start..start + count as u64).collect())
    }

    fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError> {
        if blocks.is_empty() {
            return Ok(());
        }

        let mut sorted: Vec<u64> = blocks.to_vec();
        sorted.sort();

        let start = sorted[0];
        let len = sorted.len() as u32;

        self.extents.insert(start, len);
        self.free_blocks += blocks.len();
        self.coalesce();

        Ok(())
    }

    fn free_count(&self) -> usize {
        self.free_blocks
    }

    fn fragmentation(&self) -> f64 {
        if self.extents.len() <= 1 {
            0.0
        } else {
            (self.extents.len() as f64 - 1.0) / self.free_blocks as f64
        }
    }
}

// Gestionnaire de fichiers avec blocs indirects
pub struct IndexedFileManager {
    allocator: Box<dyn BlockAllocator>,
    block_storage: Vec<Vec<u8>>,
    write_count: u64,
    logical_writes: u64,
}

impl IndexedFileManager {
    pub fn new(allocator: Box<dyn BlockAllocator>, total_blocks: usize) -> Self {
        IndexedFileManager {
            allocator,
            block_storage: vec![vec![0u8; BLOCK_SIZE]; total_blocks],
            write_count: 0,
            logical_writes: 0,
        }
    }

    pub fn create_inode(&self) -> IndexedInode {
        IndexedInode {
            direct: [None; DIRECT_BLOCKS],
            indirect: None,
            double_indirect: None,
            triple_indirect: None,
            size: 0,
            blocks_count: 0,
        }
    }

    fn logical_to_physical(&self, inode: &IndexedInode, logical_block: u64) -> Option<u64> {
        if logical_block < DIRECT_BLOCKS as u64 {
            return inode.direct[logical_block as usize];
        }

        let indirect_offset = logical_block - DIRECT_BLOCKS as u64;
        if indirect_offset < PTRS_PER_BLOCK as u64 {
            let indirect_block = inode.indirect?;
            let ptrs = self.read_pointers(indirect_block);
            return ptrs.get(indirect_offset as usize).copied().flatten();
        }

        let double_offset = indirect_offset - PTRS_PER_BLOCK as u64;
        if double_offset < (PTRS_PER_BLOCK * PTRS_PER_BLOCK) as u64 {
            let double_block = inode.double_indirect?;
            let first_level = self.read_pointers(double_block);
            let first_idx = (double_offset / PTRS_PER_BLOCK as u64) as usize;
            let second_block = first_level.get(first_idx)?.as_ref()?;
            let second_level = self.read_pointers(*second_block);
            let second_idx = (double_offset % PTRS_PER_BLOCK as u64) as usize;
            return second_level.get(second_idx).copied().flatten();
        }

        None
    }

    fn read_pointers(&self, block: u64) -> Vec<Option<u64>> {
        let data = &self.block_storage[block as usize];
        let mut pointers = Vec::with_capacity(PTRS_PER_BLOCK);
        for i in 0..PTRS_PER_BLOCK {
            let offset = i * 8;
            let ptr = u64::from_le_bytes(data[offset..offset+8].try_into().unwrap());
            pointers.push(if ptr == 0 { None } else { Some(ptr) });
        }
        pointers
    }

    pub fn write(&mut self, inode: &mut IndexedInode, offset: u64, data: &[u8])
        -> Result<usize, AllocError>
    {
        self.logical_writes += 1;
        let start_block = offset / BLOCK_SIZE as u64;
        let mut written = 0;
        let mut current_offset = offset as usize;

        for (i, chunk) in data.chunks(BLOCK_SIZE).enumerate() {
            let logical_block = start_block + i as u64;

            let physical_block = if let Some(pb) = self.logical_to_physical(inode, logical_block) {
                pb
            } else {
                self.allocate_block_for(inode, logical_block)?
            };

            let block_offset = current_offset % BLOCK_SIZE;
            let to_write = chunk.len().min(BLOCK_SIZE - block_offset);

            self.block_storage[physical_block as usize][block_offset..block_offset+to_write]
                .copy_from_slice(&chunk[..to_write]);

            self.write_count += 1;
            written += to_write;
            current_offset += to_write;
        }

        let new_size = offset + written as u64;
        if new_size > inode.size {
            inode.size = new_size;
        }

        Ok(written)
    }

    fn allocate_block_for(&mut self, inode: &mut IndexedInode, logical_block: u64)
        -> Result<u64, AllocError>
    {
        let blocks = self.allocator.allocate(1)?;
        let physical_block = blocks[0];
        inode.blocks_count += 1;

        if logical_block < DIRECT_BLOCKS as u64 {
            inode.direct[logical_block as usize] = Some(physical_block);
        } else if logical_block < DIRECT_BLOCKS as u64 + PTRS_PER_BLOCK as u64 {
            if inode.indirect.is_none() {
                let indirect = self.allocator.allocate(1)?[0];
                inode.indirect = Some(indirect);
                inode.blocks_count += 1;
                self.write_count += 1;
            }
            let idx = (logical_block - DIRECT_BLOCKS as u64) as usize;
            self.write_pointer(inode.indirect.unwrap(), idx, physical_block);
        } else {
            if inode.double_indirect.is_none() {
                let double = self.allocator.allocate(1)?[0];
                inode.double_indirect = Some(double);
                inode.blocks_count += 1;
                self.write_count += 1;
            }
            let offset = logical_block - DIRECT_BLOCKS as u64 - PTRS_PER_BLOCK as u64;
            let first_idx = (offset / PTRS_PER_BLOCK as u64) as usize;
            let second_idx = (offset % PTRS_PER_BLOCK as u64) as usize;

            let first_block = self.get_or_alloc_pointer(inode.double_indirect.unwrap(), first_idx, inode)?;
            self.write_pointer(first_block, second_idx, physical_block);
        }

        Ok(physical_block)
    }

    fn get_or_alloc_pointer(&mut self, block: u64, idx: usize, inode: &mut IndexedInode)
        -> Result<u64, AllocError>
    {
        let ptrs = self.read_pointers(block);
        if let Some(Some(ptr)) = ptrs.get(idx) {
            Ok(*ptr)
        } else {
            let new_block = self.allocator.allocate(1)?[0];
            self.write_pointer(block, idx, new_block);
            inode.blocks_count += 1;
            self.write_count += 1;
            Ok(new_block)
        }
    }

    fn write_pointer(&mut self, block: u64, idx: usize, value: u64) {
        let offset = idx * 8;
        self.block_storage[block as usize][offset..offset+8]
            .copy_from_slice(&value.to_le_bytes());
        self.write_count += 1;
    }

    pub fn read(&self, inode: &IndexedInode, offset: u64, buf: &mut [u8])
        -> Result<usize, AllocError>
    {
        if offset >= inode.size {
            return Ok(0);
        }

        let start_block = offset / BLOCK_SIZE as u64;
        let mut read_total = 0;
        let to_read = buf.len().min((inode.size - offset) as usize);

        for i in 0.. {
            if read_total >= to_read {
                break;
            }

            let logical_block = start_block + i;
            let physical_block = self.logical_to_physical(inode, logical_block)
                .ok_or(AllocError::InvalidBlock)?;

            let block_offset = if i == 0 { (offset % BLOCK_SIZE as u64) as usize } else { 0 };
            let available = BLOCK_SIZE - block_offset;
            let chunk_size = available.min(to_read - read_total);

            buf[read_total..read_total+chunk_size].copy_from_slice(
                &self.block_storage[physical_block as usize][block_offset..block_offset+chunk_size]
            );

            read_total += chunk_size;
        }

        Ok(read_total)
    }

    pub fn write_amplification(&self) -> f64 {
        if self.logical_writes == 0 {
            1.0
        } else {
            self.write_count as f64 / self.logical_writes as f64
        }
    }
}
```

### 4.5 Solutions refusÃ©es (avec explications)

```rust
// REFUSÃ‰: Best-fit qui ne cherche pas le plus petit
fn find_best_fit(&self, count: usize) -> Option<u64> {
    for i in 0..self.bitmap.len() {
        if !self.bitmap[i] {
            return Some(i as u64);  // BUG: first-fit, pas best-fit!
        }
    }
    None
}
// Pourquoi refusÃ©: ImplÃ©mente first-fit au lieu de best-fit

// REFUSÃ‰: Extent sans coalescence
fn free(&mut self, blocks: &[u64]) -> Result<(), AllocError> {
    for &b in blocks {
        self.extents.insert(b, 1);  // BUG: pas de fusion!
    }
    Ok(())
}
// Pourquoi refusÃ©: Fragmentation maximale, pas de fusion d'extents

// REFUSÃ‰: Ignore les blocs indirects
fn allocate_block_for(&mut self, inode: &mut IndexedInode, logical_block: u64)
    -> Result<u64, AllocError>
{
    if logical_block >= DIRECT_BLOCKS as u64 {
        return Err(AllocError::NoSpace);  // BUG: supporte pas indirect!
    }
    // ...
}
// Pourquoi refusÃ©: Limite artificielle Ã  12 blocs par fichier
```

### 4.9 spec.json

```json
{
  "name": "block_allocator",
  "language": "rust",
  "type": "complet",
  "tier": 3,
  "tier_info": "SynthÃ¨se",
  "tags": ["filesystem", "allocation", "extents", "indirect_blocks", "phase2"],
  "passing_score": 70,

  "function": {
    "name": "ContiguousAllocator::new",
    "prototype": "pub fn new(total_blocks: usize) -> Self",
    "return_type": "ContiguousAllocator",
    "parameters": [
      {"name": "total_blocks", "type": "usize"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "allocate_contiguous",
        "setup": "let mut alloc = ContiguousAllocator::new(100);",
        "call": "alloc.allocate(10)",
        "check": "result.unwrap().windows(2).all(|w| w[1] == w[0] + 1)",
        "is_trap": true,
        "trap_explanation": "Les blocs doivent Ãªtre contigus"
      },
      {
        "name": "extent_coalesce",
        "setup": "let mut alloc = ExtentAllocator::new(100); let b1 = alloc.allocate(10).unwrap(); let b2 = alloc.allocate(10).unwrap(); alloc.free(&b1).unwrap(); alloc.free(&b2).unwrap();",
        "call": "alloc.allocate(20)",
        "check": "result.is_ok() && result.unwrap().windows(2).all(|w| w[1] == w[0] + 1)",
        "is_trap": true,
        "trap_explanation": "Les extents adjacents doivent fusionner"
      },
      {
        "name": "indirect_used",
        "setup": "let alloc = Box::new(ContiguousAllocator::new(1000)); let mut mgr = IndexedFileManager::new(alloc, 1000); let mut inode = mgr.create_inode();",
        "call": "mgr.write(&mut inode, 0, &vec![0u8; 4096 * 15])",
        "check": "inode.indirect.is_some()",
        "is_trap": true,
        "trap_explanation": "Plus de 12 blocs doit utiliser indirect"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 100,
      "generators": [
        {
          "type": "int",
          "param_index": 0,
          "params": {"min": 100, "max": 10000}
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["HashMap::new", "BTreeMap::new", "Vec::new"],
    "forbidden_functions": ["unsafe", "libc::malloc"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Off-by-one dans best-fit */
fn find_best_fit(&self, count: usize) -> Option<u64> {
    // BUG: < au lieu de <=
    let best = self.extents.iter()
        .find(|(_, &len)| len > count as u32);  // Devrait Ãªtre >=
    // ...
}
// Pourquoi c'est faux : N'alloue pas si taille exacte
// Ce qui Ã©tait pensÃ© : "Je veux plus grand que count"

/* Mutant B (Safety) : Pas de vÃ©rification d'espace */
fn allocate(&mut self, count: usize) -> Result<Vec<u64>, AllocError> {
    let start = 0;  // BUG: alloue toujours depuis 0
    Ok((start..start + count as u64).collect())
}
// Pourquoi c'est faux : Ã‰crase les allocations existantes
// Ce qui Ã©tait pensÃ© : "Simplifie l'allocation"

/* Mutant C (Resource) : Fuite de blocs indirects */
fn allocate_block_for(&mut self, inode: &mut IndexedInode, logical_block: u64)
    -> Result<u64, AllocError>
{
    if inode.indirect.is_none() {
        let indirect = self.allocator.allocate(1)?[0];
        inode.indirect = Some(indirect);
        // BUG: oublie d'incrÃ©menter blocks_count !
    }
    // ...
}
// Pourquoi c'est faux : blocks_count incorrect, accounting cassÃ©
// Ce qui Ã©tait pensÃ© : "Seuls les blocs data comptent"

/* Mutant D (Logic) : Fragmentation toujours 0 */
fn fragmentation(&self) -> f64 {
    0.0  // BUG: calcul ignorÃ©
}
// Pourquoi c'est faux : MÃ©trique inutile
// Ce qui Ã©tait pensÃ© : "La fragmentation c'est compliquÃ©"

/* Mutant E (Return) : Coalesce inversÃ© */
fn coalesce(&mut self) {
    let extents: Vec<_> = self.extents.iter()
        .map(|(&s, &l)| (s, l)).collect();
    self.extents.clear();
    for (start, len) in extents {
        // BUG: rÃ©insÃ¨re sans fusion
        self.extents.insert(start, len);
    }
}
// Pourquoi c'est faux : Ne fusionne rien, fonction vide
// Ce qui Ã©tait pensÃ© : "Je rÃ©organise les extents"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **StratÃ©gies d'allocation** : Trade-offs entre contiguÃ¯tÃ© et flexibilitÃ©
2. **Blocs indirects** : Architecture multi-niveaux des filesystems Unix
3. **Fragmentation** : Causes, mesure et mitigation
4. **Write amplification** : Impact sur les performances SSD
5. **Structures de donnÃ©es** : BTreeMap pour les extents

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION allocate QUI RETOURNE UN RÃ‰SULTAT CONTENANT UN VECTEUR D'ENTIERS NON SIGNÃ‰S 64 BITS OU UNE ERREUR ET PREND EN PARAMÃˆTRE count QUI EST UN ENTIER NON SIGNÃ‰
DÃ‰BUT FONCTION
    SI count EST SUPÃ‰RIEUR Ã€ free_blocks ALORS
        RETOURNER ERREUR NoSpace
    FIN SI

    DÃ‰CLARER best_start COMME OPTION D'ENTIER NON SIGNÃ‰ 64 BITS
    AFFECTER None Ã€ best_start

    POUR CHAQUE extent DANS extents FAIRE
        SI extent.length EST SUPÃ‰RIEUR OU Ã‰GAL Ã€ count ALORS
            SI best_start EST None OU extent.length EST INFÃ‰RIEUR Ã€ best_size ALORS
                AFFECTER Some(extent.start) Ã€ best_start
                AFFECTER extent.length Ã€ best_size
            FIN SI
        FIN SI
    FIN POUR

    SI best_start EST None ALORS
        RETOURNER ERREUR NoSpace
    FIN SI

    RETIRER L'EXTENT Ã€ LA POSITION best_start DE extents
    SI best_size EST SUPÃ‰RIEUR Ã€ count ALORS
        INSÃ‰RER UN NOUVEL EXTENT (start + count, best_size - count)
    FIN SI

    DÃ‰CRÃ‰MENTER free_blocks DE count
    RETOURNER SUCCÃˆS AVEC LE VECTEUR [best_start, best_start+1, ..., best_start+count-1]
FIN FONCTION
```

### 5.2.2 Logic Flow

```
ALGORITHME : Allocation de bloc pour fichier
---
1. DÃ‰TERMINER le niveau requis :
   - logical_block < 12 â†’ Direct
   - logical_block < 12 + 512 â†’ Indirect
   - logical_block < 12 + 512 + 512Â² â†’ Double indirect
   - sinon â†’ Triple indirect

2. SELON le niveau :

   CAS Direct :
      ALLOUER un bloc physique
      inode.direct[logical_block] = bloc
      RETOURNER bloc

   CAS Indirect :
      SI inode.indirect est None :
         ALLOUER un bloc pour la table indirecte
         inode.indirect = bloc_table
      CALCULER idx = logical_block - 12
      Ã‰CRIRE le pointeur Ã  table[idx]
      RETOURNER bloc

   CAS Double indirect :
      SI inode.double_indirect est None :
         ALLOUER un bloc pour la table double
      CALCULER first_idx et second_idx
      SI table_premier_niveau[first_idx] est None :
         ALLOUER un bloc pour la table second niveau
      Ã‰CRIRE le pointeur final
      RETOURNER bloc
```

### 5.3 Visualisation ASCII

```
                    STRATÃ‰GIES D'ALLOCATION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  ALLOCATION CONTIGUÃ‹                                           â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                    â”‚
â”‚  â”‚ A â”‚ A â”‚ A â”‚   â”‚   â”‚ B â”‚ B â”‚   â”‚ C â”‚ C â”‚                    â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                    â”‚
â”‚  Fichier A: blocs 0-2 (contigus)                              â”‚
â”‚  Fichier B: blocs 5-6 (contigus)                              â”‚
â”‚  âŒ ProblÃ¨me: Trou de 2 blocs inutilisable pour fichier > 2   â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  ALLOCATION PAR EXTENTS                                        â”‚
â”‚  Fichier A: [(start=0, len=3)]                                 â”‚
â”‚  Fichier B: [(start=5, len=2)]                                 â”‚
â”‚  Libre:     [(start=3, len=2), (start=8, len=2)]              â”‚
â”‚                                                                 â”‚
â”‚  AprÃ¨s free(A) puis free(B):                                   â”‚
â”‚  Libre: [(start=0, len=10)]  â† COALESCED!                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    BLOCS INDIRECTS (ext4-style)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  INODE                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚  â”‚ direct[0]  â†’ bloc 100â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [DATA BLOC 100] â”‚
â”‚  â”‚ direct[1]  â†’ bloc 101â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [DATA BLOC 101] â”‚
â”‚  â”‚ ...                  â”‚                                      â”‚
â”‚  â”‚ direct[11] â†’ bloc 111â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [DATA BLOC 111] â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                      â”‚
â”‚  â”‚ indirect   â†’ bloc 200â”‚â”€â”€â”                                   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚                                   â”‚
â”‚  â”‚ double_ind â†’ bloc 300â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â†’â”‚ BLOC INDIRECT 200           â”‚  â”‚
â”‚                               â”‚ â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚                               â”‚ â”‚112â”‚113â”‚114â”‚115â”‚ ... â”‚     â”‚  â”‚
â”‚                               â”‚ â””â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚                               â””â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                   â”‚   â”‚   â”‚   â”‚                â”‚
â”‚                                   â–¼   â–¼   â–¼   â–¼                â”‚
â”‚                               [112][113][114][115] DATA BLOCS  â”‚
â”‚                                                                 â”‚
â”‚  CapacitÃ©:                                                     â”‚
â”‚  - Direct: 12 Ã— 4KB = 48KB                                     â”‚
â”‚  - Indirect: 512 Ã— 4KB = 2MB                                   â”‚
â”‚  - Double: 512 Ã— 512 Ã— 4KB = 1GB                              â”‚
â”‚  - Triple: 512Â³ Ã— 4KB = 512GB                                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    FRAGMENTATION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  Avant fragmentation:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ FREE (100 blocs contigus)                         â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  Fragmentation = 0%                                            â”‚
â”‚                                                                 â”‚
â”‚  AprÃ¨s alloc/free rÃ©pÃ©tÃ©s:                                     â”‚
â”‚  â”Œâ”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”                       â”‚
â”‚  â”‚F1â”‚USEDâ”‚F2â”‚ USED â”‚F3â”‚  FREE  â”‚F4â”‚USâ”‚                       â”‚
â”‚  â””â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”˜                       â”‚
â”‚   2    4   1    6    2     8     3  2                         â”‚
â”‚                                                                 â”‚
â”‚  Blocs libres = 2+1+2+8+3 = 16                                â”‚
â”‚  Fragments = 5                                                 â”‚
â”‚  Fragmentation = (5-1)/16 = 25%                               â”‚
â”‚                                                                 â”‚
â”‚  âŒ Impossible d'allouer 10 blocs contigus malgrÃ© 16 libres!  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| First-fit vs Best-fit | Confusion entre stratÃ©gies | Chercher le PLUS PETIT qui convient |
| Oublier coalesce | Extents jamais fusionnÃ©s | Appeler coalesce() aprÃ¨s chaque free |
| blocks_count faux | Oubli des blocs indirects | IncrÃ©menter pour CHAQUE allocation |
| Calcul offset double | Erreur dans formules | Tester avec 600+ blocs |

### 5.5 Cours Complet

#### 5.5.1 Comparaison des stratÃ©gies d'allocation

| StratÃ©gie | Avantages | InconvÃ©nients | UtilisÃ© par |
|-----------|-----------|---------------|-------------|
| **ContiguÃ«** | Lecture sÃ©quentielle O(1), Simple | Fragmentation externe, Agrandissement difficile | CD-ROM (ISO9660), Anciennes disquettes |
| **ChaÃ®nÃ©e** | Pas de fragmentation externe | Lecture random O(n), FiabilitÃ© | FAT32 |
| **IndexÃ©e** | Random access O(1), Flexible | Overhead pour petits fichiers | ext2/3, NTFS |
| **Extents** | Compact, Bon pour gros fichiers | ComplexitÃ© de gestion | ext4, btrfs, XFS |

#### 5.5.2 Calcul de capacitÃ© avec blocs indirects

Pour des blocs de 4KB et pointeurs de 8 bytes :

```
Pointeurs par bloc = 4096 / 8 = 512

Direct blocks:       12 Ã— 4KB = 48 KB
Single indirect:    512 Ã— 4KB = 2 MB
Double indirect:    512Â² Ã— 4KB = 1 GB
Triple indirect:    512Â³ Ã— 4KB = 512 GB

Taille max fichier â‰ˆ 512 GB + 1 GB + 2 MB + 48 KB â‰ˆ 513 GB
```

ext4 avec blocs 64KB et pointeurs 8B :
```
Pointeurs par bloc = 65536 / 8 = 8192

Taille max â‰ˆ 8192Â³ Ã— 64KB = 32 Exabytes !
```

#### 5.5.3 Write Amplification en dÃ©tail

Quand tu Ã©cris un nouveau bloc dans un fichier qui utilise un indirect :

1. Allouer le bloc de donnÃ©es (1 write)
2. Ã‰crire le bloc de donnÃ©es (1 write)
3. Mettre Ã  jour le bloc indirect (1 write)
4. Mettre Ã  jour le journal (ext4: 1-3 writes)
5. Mettre Ã  jour l'inode (mtime, size) (1 write)

**Total : 5-7 Ã©critures pour 1 Ã©criture logique â†’ WAF = 5-7**

Les SSD sont particuliÃ¨rement sensibles car chaque write use les cellules NAND.

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais incorrect)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ fn coalesce(&mut self) {                                        â”‚
â”‚     // Ne fait rien                                             â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ fn coalesce(&mut self) {                                        â”‚
â”‚     // Parcourir les extents triÃ©s                              â”‚
â”‚     // Fusionner les adjacents                                  â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Sans fusion, fragmentation croÃ®t indÃ©finiment                â”‚
â”‚ â€¢ Allocations de gros blocs deviennent impossibles             â”‚
â”‚ â€¢ Performance dÃ©gradÃ©e                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**ScÃ©nario** : Ã‰crire 20 blocs (>12) dans un fichier vide

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Instruction                          â”‚ inode.indirect â”‚ Explication     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ write bloc 0 â†’ inode.direct[0]       â”‚ None           â”‚ Bloc direct     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ...  â”‚ write blocs 1-11 â†’ direct[1-11]      â”‚ None           â”‚ Blocs directs   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  13   â”‚ write bloc 12 â†’ besoin indirect      â”‚ None           â”‚ DÃ©passe direct  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  14   â”‚ alloc bloc pour indirect table       â”‚ Some(500)      â”‚ Table crÃ©Ã©e     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  15   â”‚ write ptr dans indirect[0]           â”‚ Some(500)      â”‚ Pointeur Ã©crit  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 16-20 â”‚ write blocs 13-19 via indirect       â”‚ Some(500)      â”‚ Via table ind.  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FIN  â”‚ blocks_count = 21                    â”‚ Some(500)      â”‚ 20 data + 1 ind â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ® MEME : "Minecraft Chunks" â€” Allocation par extents

Comme les chunks Minecraft qui stockent des rÃ©gions 16Ã—16, les extents stockent des plages contiguÃ«s. Un chunk corrompu = donnÃ©es perdues pour toute la rÃ©gion.

```rust
// ğŸ® Un extent = un chunk de blocs
struct Extent {
    start: u64,   // CoordonnÃ©es du chunk
    length: u32,  // Taille du chunk
}
```

#### ğŸ’€ MEME : "Inception Levels" â€” Blocs indirects

Comme les niveaux de rÃªve dans Inception :
- **Direct** = RÃ©alitÃ©
- **Indirect** = RÃªve niveau 1
- **Double indirect** = RÃªve niveau 2
- **Triple indirect** = Les Limbes

```rust
// ğŸ’­ Plus on descend, plus c'est lent
let level = if block < 12 { "Reality" }
    else if block < 12 + 512 { "Dream L1" }
    else { "Limbo" };
```

#### ğŸ”¥ MEME : "Tetris Fragmentation"

La fragmentation, c'est comme Tetris mal jouÃ© : des trous partout qui empÃªchent de placer les grandes piÃ¨ces. La dÃ©fragmentation = effacer les lignes pour faire de la place.

### 5.9 Applications pratiques

1. **ext4** : Utilise extents + indirect pour fichiers Ã©normes
2. **btrfs** : Extents avec copy-on-write pour snapshots
3. **ZFS** : Allocation basÃ©e sur des "metaslabs"
4. **Databases** : Pages allouÃ©es similairement aux blocs
5. **SSD firmware** : Garbage collection minimise write amplification

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | ConsÃ©quence | DÃ©tection |
|---|-------|-------------|-----------|
| 1 | First-fit au lieu de best-fit | Fragmentation accÃ©lÃ©rÃ©e | Test pattern alloc/free |
| 2 | Pas de coalesce | Extents jamais fusionnÃ©s | Test free consÃ©cutifs |
| 3 | blocks_count oublie indirect | Accounting incorrect | Comparer avec rÃ©alitÃ© |
| 4 | Formule double indirect | Mauvais bloc accÃ©dÃ© | Test 600+ blocs |
| 5 | Fragmentation = 0 hardcodÃ© | MÃ©trique inutile | Test aprÃ¨s fragmentation |

---

## ğŸ“ SECTION 7 : QCM

### Q1. Combien de blocs un fichier peut-il adresser avec 12 directs + 1 indirect (512 ptrs/bloc) ?

- A) 12
- B) 512
- C) 524
- D) 524288
- E) 12 + 512
- F) 12 Ã— 512
- G) 512Â²
- H) IllimitÃ©
- I) DÃ©pend de la taille du bloc
- J) 4096

**RÃ©ponse : C** (12 + 512 = 524)

### Q2. Quelle stratÃ©gie minimise la fragmentation externe ?

- A) Allocation contiguÃ«
- B) Allocation chaÃ®nÃ©e
- C) Best-fit
- D) First-fit
- E) Worst-fit
- F) Random-fit
- G) Aucune ne l'Ã©limine
- H) Toutes l'Ã©liminent
- I) Extents seulement
- J) Seule la dÃ©fragmentation aide

**RÃ©ponse : B** (chaÃ®nÃ©e n'a pas de fragmentation externe)

### Q3. Que signifie un write amplification factor de 5 ?

- A) Les Ã©critures sont 5Ã— plus rapides
- B) 5 Ã©critures physiques pour 1 Ã©criture logique
- C) Le fichier est 5Ã— plus gros
- D) 5 niveaux d'indirection
- E) 5 copies des donnÃ©es
- F) Compression 5:1
- G) 5 disques en RAID
- H) Cache de 5 blocs
- I) 5% d'overhead
- J) Erreur de calcul

**RÃ©ponse : B**

### Q4. Pourquoi ext4 utilise l'inode 2 pour root et pas 0 ?

- A) Erreur historique
- B) 0 est rÃ©servÃ© pour "pas d'inode"
- C) CompatibilitÃ© Windows
- D) Optimisation de performance
- E) 1 est pour le bootloader
- F) Raison de sÃ©curitÃ©
- G) Standard POSIX
- H) Limites du hardware
- I) Convention arbitraire
- J) B + convention ext historique

**RÃ©ponse : J**

### Q5. Quel est l'avantage principal des extents sur les blocs indirects ?

- A) Plus de niveaux d'indirection
- B) ReprÃ©sentation compacte de fichiers contigus
- C) Meilleure sÃ©curitÃ©
- D) Compatible avec plus de filesystems
- E) Pas besoin de dÃ©fragmentation
- F) Lecture plus rapide
- G) Moins de mÃ©moire utilisÃ©e
- H) Plus simple Ã  implÃ©menter
- I) Fonctionne sans disque
- J) Toutes ces rÃ©ponses

**RÃ©ponse : B**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CritÃ¨re | Valeur |
|---------|--------|
| DifficultÃ© | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| Temps estimÃ© | 150 min |
| XP Base | 200 |
| XP Bonus (Ã—3) | 600 |
| Concepts clÃ©s | Allocation, Extents, Blocs indirects, Fragmentation |
| Langage | Rust 2024 |
| Type | complet |
| Tier | 3 â€” SynthÃ¨se |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "2.3.3-block-allocator",
    "generated_at": "2025-01-16 15:00:00",

    "metadata": {
      "exercise_id": "2.3.3",
      "exercise_name": "block_allocator",
      "module": "2.3.3",
      "module_name": "StratÃ©gies d'Allocation de Blocs",
      "concept": "a",
      "concept_name": "Block Allocation Strategies",
      "type": "complet",
      "tier": 3,
      "tier_info": "SynthÃ¨se",
      "phase": 2,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "duration_minutes": 150,
      "xp_base": 200,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["data_structures", "filesystem_basics"],
      "domains": ["FS", "Struct", "Algo", "Mem"],
      "domains_bonus": ["Algo", "Struct"],
      "tags": ["allocation", "extents", "indirect_blocks", "fragmentation"],
      "meme_reference": "Minecraft Block Placement"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.rs"],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "test": "cargo test",
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” L'excellence pÃ©dagogique ne se nÃ©gocie pas*
*Phase 2 â€” Module 2.3.3 â€” Block Allocation Strategies*
