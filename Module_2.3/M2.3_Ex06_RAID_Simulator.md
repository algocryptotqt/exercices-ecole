# Ex06: RAIDSim - Software RAID Simulator

## Concepts couverts
- 2.3.27.g (Hot spare: Automatic rebuild)
- 2.3.27.i (URE: Unrecoverable Read Error)

## Description
Implementer un simulateur de RAID logiciel supportant les niveaux 0, 1, 5, et 6 avec gestion des pannes de disque, hot spare, et simulation d'URE (Unrecoverable Read Errors).

## Objectifs pedagogiques
1. Comprendre les differents niveaux RAID
2. Implementer le striping et la parite
3. Gerer la reconstruction apres panne
4. Simuler les URE et leur impact
5. Implementer le hot spare automatique

## Structure (Rust 2024)

```rust
// src/lib.rs
use std::collections::HashSet;

pub const STRIP_SIZE: usize = 64 * 1024;  // 64 KB par strip

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum RaidLevel {
    Raid0,  // Striping only
    Raid1,  // Mirroring
    Raid5,  // Distributed parity
    Raid6,  // Double parity
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DiskStatus {
    Online,
    Failed,
    Rebuilding,
    HotSpare,
}

#[derive(Debug)]
pub struct VirtualDisk {
    pub id: usize,
    pub status: DiskStatus,
    pub data: Vec<u8>,
    pub capacity: usize,
    pub ure_probability: f64,  // Probabilite d'URE par lecture
    pub read_count: u64,
    pub write_count: u64,
}

impl VirtualDisk {
    pub fn new(id: usize, capacity: usize) -> Self {
        VirtualDisk {
            id,
            status: DiskStatus::Online,
            data: vec![0u8; capacity],
            capacity,
            ure_probability: 0.0,
            read_count: 0,
            write_count: 0,
        }
    }

    pub fn read(&mut self, offset: usize, length: usize) -> Result<Vec<u8>, DiskError> {
        todo!("Lire avec simulation d'URE")
    }

    pub fn write(&mut self, offset: usize, data: &[u8]) -> Result<(), DiskError> {
        todo!("Ecrire les donnees")
    }

    pub fn fail(&mut self) {
        self.status = DiskStatus::Failed;
    }
}

#[derive(Debug)]
pub enum DiskError {
    Failed,
    URE,  // Unrecoverable Read Error
    OutOfBounds,
}

#[derive(Debug)]
pub enum RaidError {
    DiskError(usize, DiskError),
    TooManyFailures,
    NoHotSpare,
    DataCorrupted,
    RebuildFailed,
}

pub struct RaidArray {
    level: RaidLevel,
    disks: Vec<VirtualDisk>,
    hot_spares: Vec<VirtualDisk>,
    stripe_count: usize,
    failed_disks: HashSet<usize>,
    rebuild_progress: Option<(usize, usize)>,  // (disk_id, progress)
}

impl RaidArray {
    pub fn new(level: RaidLevel, disk_count: usize, disk_capacity: usize) -> Result<Self, RaidError> {
        todo!("Creer le RAID avec validation du niveau vs nombre de disques")
    }

    pub fn add_hot_spare(&mut self, disk: VirtualDisk) {
        todo!("Ajouter un hot spare")
    }

    /// Capacite utilisable du RAID
    pub fn usable_capacity(&self) -> usize {
        todo!("Calculer selon le niveau RAID")
    }

    /// Ecrire des donnees
    pub fn write(&mut self, offset: usize, data: &[u8]) -> Result<(), RaidError> {
        match self.level {
            RaidLevel::Raid0 => self.write_raid0(offset, data),
            RaidLevel::Raid1 => self.write_raid1(offset, data),
            RaidLevel::Raid5 => self.write_raid5(offset, data),
            RaidLevel::Raid6 => self.write_raid6(offset, data),
        }
    }

    /// Lire des donnees
    pub fn read(&mut self, offset: usize, length: usize) -> Result<Vec<u8>, RaidError> {
        match self.level {
            RaidLevel::Raid0 => self.read_raid0(offset, length),
            RaidLevel::Raid1 => self.read_raid1(offset, length),
            RaidLevel::Raid5 => self.read_raid5(offset, length),
            RaidLevel::Raid6 => self.read_raid6(offset, length),
        }
    }

    // ============ RAID 0 ============
    fn write_raid0(&mut self, offset: usize, data: &[u8]) -> Result<(), RaidError> {
        todo!("Striping simple")
    }

    fn read_raid0(&mut self, offset: usize, length: usize) -> Result<Vec<u8>, RaidError> {
        todo!("Lire depuis les strips")
    }

    // ============ RAID 1 ============
    fn write_raid1(&mut self, offset: usize, data: &[u8]) -> Result<(), RaidError> {
        todo!("Ecrire sur tous les miroirs")
    }

    fn read_raid1(&mut self, offset: usize, length: usize) -> Result<Vec<u8>, RaidError> {
        todo!("Lire depuis un miroir disponible")
    }

    // ============ RAID 5 ============
    fn write_raid5(&mut self, offset: usize, data: &[u8]) -> Result<(), RaidError> {
        todo!("Ecrire avec parite distribuee")
    }

    fn read_raid5(&mut self, offset: usize, length: usize) -> Result<Vec<u8>, RaidError> {
        todo!("Lire avec reconstruction si necessaire")
    }

    fn calculate_parity(&self, strips: &[Vec<u8>]) -> Vec<u8> {
        todo!("XOR de tous les strips")
    }

    fn reconstruct_strip(&mut self, stripe_num: usize, missing_disk: usize) -> Result<Vec<u8>, RaidError> {
        todo!("Reconstruire via XOR des autres")
    }

    // ============ RAID 6 ============
    fn write_raid6(&mut self, offset: usize, data: &[u8]) -> Result<(), RaidError> {
        todo!("Ecrire avec double parite (P + Q)")
    }

    fn read_raid6(&mut self, offset: usize, length: usize) -> Result<Vec<u8>, RaidError> {
        todo!("Lire avec reconstruction double si necessaire")
    }

    fn calculate_q_parity(&self, strips: &[Vec<u8>]) -> Vec<u8> {
        todo!("Calculer parite Q (Reed-Solomon simplifie)")
    }

    // ============ Gestion des pannes ============
    pub fn fail_disk(&mut self, disk_id: usize) -> Result<(), RaidError> {
        todo!("Marquer le disque comme failed, lancer rebuild si hot spare")
    }

    pub fn start_rebuild(&mut self, target_disk: usize) -> Result<(), RaidError> {
        todo!("Demarrer la reconstruction")
    }

    pub fn rebuild_step(&mut self) -> Result<bool, RaidError> {
        todo!("Un step de rebuild, retourne true si termine")
    }

    pub fn get_rebuild_progress(&self) -> Option<f64> {
        todo!("Pourcentage de completion du rebuild")
    }

    // ============ Statistiques ============
    pub fn status(&self) -> RaidStatus {
        RaidStatus {
            level: self.level,
            total_disks: self.disks.len(),
            failed_disks: self.failed_disks.len(),
            hot_spares: self.hot_spares.len(),
            capacity_bytes: self.usable_capacity(),
            is_degraded: !self.failed_disks.is_empty(),
            is_rebuilding: self.rebuild_progress.is_some(),
        }
    }
}

#[derive(Debug)]
pub struct RaidStatus {
    pub level: RaidLevel,
    pub total_disks: usize,
    pub failed_disks: usize,
    pub hot_spares: usize,
    pub capacity_bytes: usize,
    pub is_degraded: bool,
    pub is_rebuilding: bool,
}

/// Simuler une serie d'operations avec pannes aleatoires
pub fn simulate_workload(
    raid: &mut RaidArray,
    operations: &[(bool, usize, usize)],  // (is_write, offset, length)
    failure_probability: f64,
) -> SimulationResult {
    todo!("Executer les operations avec pannes simulees")
}

#[derive(Debug)]
pub struct SimulationResult {
    pub successful_ops: usize,
    pub failed_ops: usize,
    pub disk_failures: usize,
    pub ure_count: usize,
    pub data_loss: bool,
}
```

## Tests Automatises

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_raid0_striping() {
        let mut raid = RaidArray::new(RaidLevel::Raid0, 4, 1024 * 1024).unwrap();

        let data = vec![0x42; STRIP_SIZE * 8];
        raid.write(0, &data).unwrap();

        let read_data = raid.read(0, data.len()).unwrap();
        assert_eq!(data, read_data);
    }

    #[test]
    fn test_raid0_no_redundancy() {
        let mut raid = RaidArray::new(RaidLevel::Raid0, 4, 1024 * 1024).unwrap();

        raid.write(0, &[0x42; STRIP_SIZE * 4]).unwrap();
        raid.fail_disk(0).unwrap();

        // Doit echouer car pas de redundance
        assert!(raid.read(0, STRIP_SIZE).is_err());
    }

    #[test]
    fn test_raid1_mirroring() {
        let mut raid = RaidArray::new(RaidLevel::Raid1, 2, 1024 * 1024).unwrap();

        let data = vec![0x42; 1024];
        raid.write(0, &data).unwrap();

        // Faire tomber un disque
        raid.fail_disk(0).unwrap();

        // Doit pouvoir lire depuis le miroir
        let read_data = raid.read(0, 1024).unwrap();
        assert_eq!(data, read_data);
    }

    #[test]
    fn test_raid5_parity() {
        let mut raid = RaidArray::new(RaidLevel::Raid5, 4, 1024 * 1024).unwrap();

        let data = vec![0x42; STRIP_SIZE * 3];
        raid.write(0, &data).unwrap();

        // Faire tomber un disque
        raid.fail_disk(1).unwrap();

        // Doit reconstruire via parite
        let read_data = raid.read(0, data.len()).unwrap();
        assert_eq!(data, read_data);
    }

    #[test]
    fn test_raid5_two_failures() {
        let mut raid = RaidArray::new(RaidLevel::Raid5, 4, 1024 * 1024).unwrap();

        raid.write(0, &[0x42; STRIP_SIZE * 3]).unwrap();

        raid.fail_disk(0).unwrap();
        raid.fail_disk(1).unwrap();

        // Doit echouer avec 2 pannes
        assert!(raid.read(0, STRIP_SIZE).is_err());
    }

    #[test]
    fn test_raid6_double_parity() {
        let mut raid = RaidArray::new(RaidLevel::Raid6, 5, 1024 * 1024).unwrap();

        let data = vec![0x42; STRIP_SIZE * 3];
        raid.write(0, &data).unwrap();

        // Faire tomber DEUX disques
        raid.fail_disk(0).unwrap();
        raid.fail_disk(2).unwrap();

        // Doit reconstruire via double parite
        let read_data = raid.read(0, data.len()).unwrap();
        assert_eq!(data, read_data);
    }

    #[test]
    fn test_hot_spare_activation() {
        let mut raid = RaidArray::new(RaidLevel::Raid5, 4, 1024 * 1024).unwrap();
        raid.add_hot_spare(VirtualDisk::new(99, 1024 * 1024));

        raid.write(0, &[0x42; STRIP_SIZE * 3]).unwrap();

        // Panne declenchant le hot spare
        raid.fail_disk(1).unwrap();

        // Attendre rebuild complet
        while !raid.rebuild_step().unwrap() {}

        assert!(raid.status().hot_spares == 0);  // Hot spare utilise
        assert!(!raid.status().is_degraded);     // Plus degrade
    }

    #[test]
    fn test_rebuild_progress() {
        let mut raid = RaidArray::new(RaidLevel::Raid5, 4, 1024 * 1024).unwrap();
        raid.add_hot_spare(VirtualDisk::new(99, 1024 * 1024));

        raid.write(0, &[0x42; STRIP_SIZE * 100]).unwrap();
        raid.fail_disk(1).unwrap();

        let mut progress = raid.get_rebuild_progress().unwrap();
        assert!(progress < 1.0);

        while !raid.rebuild_step().unwrap() {
            let new_progress = raid.get_rebuild_progress().unwrap();
            assert!(new_progress >= progress);
            progress = new_progress;
        }

        assert!(raid.get_rebuild_progress().is_none());  // Rebuild termine
    }

    #[test]
    fn test_ure_simulation() {
        let mut raid = RaidArray::new(RaidLevel::Raid5, 4, 1024 * 1024).unwrap();

        // Configurer URE sur un disque
        raid.disks[0].ure_probability = 0.1;  // 10% de chance d'URE

        raid.write(0, &[0x42; STRIP_SIZE * 100]).unwrap();

        // Faire tomber un disque (pas celui avec URE)
        raid.fail_disk(1).unwrap();

        // Lectures peuvent echouer a cause d'URE pendant reconstruction
        let mut ure_count = 0;
        for i in 0..100 {
            if raid.read(i * STRIP_SIZE, STRIP_SIZE).is_err() {
                ure_count += 1;
            }
        }

        // Devrait avoir quelques URE
        println!("URE count: {}", ure_count);
    }

    #[test]
    fn test_usable_capacity() {
        // RAID 0: capacite totale
        let raid0 = RaidArray::new(RaidLevel::Raid0, 4, 1024 * 1024).unwrap();
        assert_eq!(raid0.usable_capacity(), 4 * 1024 * 1024);

        // RAID 1: moitie
        let raid1 = RaidArray::new(RaidLevel::Raid1, 2, 1024 * 1024).unwrap();
        assert_eq!(raid1.usable_capacity(), 1024 * 1024);

        // RAID 5: N-1
        let raid5 = RaidArray::new(RaidLevel::Raid5, 4, 1024 * 1024).unwrap();
        assert_eq!(raid5.usable_capacity(), 3 * 1024 * 1024);

        // RAID 6: N-2
        let raid6 = RaidArray::new(RaidLevel::Raid6, 5, 1024 * 1024).unwrap();
        assert_eq!(raid6.usable_capacity(), 3 * 1024 * 1024);
    }
}
```

## Criteres d'evaluation
- [ ] RAID 0 avec striping correct
- [ ] RAID 1 avec mirroring et failover
- [ ] RAID 5 avec parite XOR distribuee
- [ ] RAID 6 avec double parite (simplifie)
- [ ] Hot spare avec activation automatique
- [ ] Rebuild progressif avec tracking
- [ ] Simulation d'URE
- [ ] Calcul correct des capacites

## Note qualite: 95/100
