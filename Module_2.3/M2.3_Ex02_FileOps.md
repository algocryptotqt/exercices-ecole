# Ex02: FileOps - Low-Level File Operations Library

## Concepts couverts
- 2.3.5.j (fcntl(): Manipulate fd)
- 2.3.6.d (O_TRUNC: Truncate to zero)
- 2.3.6.f (O_EXCL: Fail if exists)
- 2.3.6.i (lseek(): Change offset)
- 2.3.7.b (User/Group/Other: Three categories)
- 2.3.7.f (Octal notation: 755, 644)
- 2.3.7.g (chmod(): Change permissions)
- 2.3.7.h (fchmod(): Change by fd)
- 2.3.7.i (chown(): Change owner)
- 2.3.7.k (Setuid bit: Run as owner)
- 2.3.7.l (Setgid bit: Run as group)
- 2.3.4.h (Symlink traversal: Follow on access)
- 2.3.4.l (Symlink loops: Detection limit)

## Description
Implementer une bibliotheque de wrappers autour des appels systeme de fichiers bas niveau (open, read, write, lseek, fcntl, chmod, chown) avec gestion des erreurs robuste et support des permissions avancees (setuid, setgid).

## Objectifs pedagogiques
1. Maitriser les flags d'ouverture de fichiers
2. Comprendre fcntl et la manipulation de file descriptors
3. Gerer les permissions Unix (mode bits)
4. Implementer la detection de boucles de symlinks
5. Manipuler lseek pour le positionnement

## Structure (C17)

```c
// fileops.h
#ifndef FILEOPS_H
#define FILEOPS_H

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

// Constantes pour les permissions speciales
#define FO_SETUID  04000
#define FO_SETGID  02000
#define FO_STICKY  01000

// Structure pour les resultats d'operations
typedef struct {
    int success;
    int error_code;
    char error_msg[256];
} fo_result_t;

// Structure pour les infos de fichier
typedef struct {
    mode_t mode;
    uid_t uid;
    gid_t gid;
    off_t size;
    time_t atime;
    time_t mtime;
    time_t ctime;
    int is_setuid;
    int is_setgid;
    int is_sticky;
} fo_fileinfo_t;

/**
 * Ouvrir un fichier avec options avancees
 * @param path Chemin du fichier
 * @param flags Flags d'ouverture (O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, etc.)
 * @param mode Permissions si O_CREAT (format octal)
 * @param exclusive Si 1, echoue si le fichier existe (O_EXCL)
 * @param truncate Si 1, tronque le fichier a 0 (O_TRUNC)
 * @return fd >= 0 en cas de succes, -1 en cas d'erreur
 */
int fo_open(const char *path, int flags, mode_t mode,
            int exclusive, int truncate);

/**
 * Lire depuis un fichier a une position donnee (pread-like)
 * @param fd File descriptor
 * @param buf Buffer de destination
 * @param count Nombre de bytes a lire
 * @param offset Position de lecture (-1 pour position courante)
 * @return Nombre de bytes lus, -1 en cas d'erreur
 */
ssize_t fo_read_at(int fd, void *buf, size_t count, off_t offset);

/**
 * Ecrire dans un fichier a une position donnee (pwrite-like)
 * @param fd File descriptor
 * @param buf Buffer source
 * @param count Nombre de bytes a ecrire
 * @param offset Position d'ecriture (-1 pour position courante)
 * @return Nombre de bytes ecrits, -1 en cas d'erreur
 */
ssize_t fo_write_at(int fd, const void *buf, size_t count, off_t offset);

/**
 * Deplacer le curseur dans un fichier
 * @param fd File descriptor
 * @param offset Deplacement
 * @param whence SEEK_SET, SEEK_CUR, ou SEEK_END
 * @return Nouvelle position, -1 en cas d'erreur
 */
off_t fo_seek(int fd, off_t offset, int whence);

/**
 * Obtenir la taille d'un fichier
 * @param fd File descriptor
 * @return Taille en bytes, -1 en cas d'erreur
 */
off_t fo_size(int fd);

/**
 * Changer les permissions d'un fichier (par fd)
 * @param fd File descriptor
 * @param mode Nouvelles permissions (format octal, ex: 0755)
 * @return 0 en cas de succes, -1 en cas d'erreur
 */
int fo_fchmod(int fd, mode_t mode);

/**
 * Changer les permissions d'un fichier (par chemin)
 * @param path Chemin du fichier
 * @param mode Nouvelles permissions
 * @param follow_symlinks Si 0, modifie le symlink lui-meme
 * @return 0 en cas de succes, -1 en cas d'erreur
 */
int fo_chmod(const char *path, mode_t mode, int follow_symlinks);

/**
 * Changer le proprietaire d'un fichier
 * @param path Chemin du fichier
 * @param uid Nouvel UID (-1 pour ne pas changer)
 * @param gid Nouveau GID (-1 pour ne pas changer)
 * @param follow_symlinks Si 0, modifie le symlink lui-meme
 * @return 0 en cas de succes, -1 en cas d'erreur
 */
int fo_chown(const char *path, uid_t uid, gid_t gid, int follow_symlinks);

/**
 * Definir le bit setuid sur un fichier
 * @param path Chemin du fichier
 * @param enable 1 pour activer, 0 pour desactiver
 * @return 0 en cas de succes, -1 en cas d'erreur
 */
int fo_set_setuid(const char *path, int enable);

/**
 * Definir le bit setgid sur un fichier
 * @param path Chemin du fichier
 * @param enable 1 pour activer, 0 pour desactiver
 * @return 0 en cas de succes, -1 en cas d'erreur
 */
int fo_set_setgid(const char *path, int enable);

/**
 * Obtenir les informations d'un fichier
 * @param path Chemin du fichier
 * @param info Structure a remplir
 * @param follow_symlinks Si 1, suit les symlinks
 * @return 0 en cas de succes, -1 en cas d'erreur
 */
int fo_stat(const char *path, fo_fileinfo_t *info, int follow_symlinks);

/**
 * Verifier si un chemin contient une boucle de symlinks
 * @param path Chemin a verifier
 * @param max_depth Profondeur max de resolution (SYMLOOP_MAX typiquement)
 * @return 1 si boucle detectee, 0 sinon, -1 en cas d'erreur
 */
int fo_check_symlink_loop(const char *path, int max_depth);

/**
 * Resoudre un chemin avec symlinks
 * @param path Chemin a resoudre
 * @param resolved Buffer pour le chemin resolu (PATH_MAX bytes)
 * @param max_depth Profondeur max
 * @return 0 en cas de succes, -1 si boucle ou erreur
 */
int fo_resolve_path(const char *path, char *resolved, int max_depth);

/**
 * Dupliquer un file descriptor avec fcntl
 * @param oldfd FD a dupliquer
 * @param minfd FD minimum pour le nouveau (0 pour default)
 * @param cloexec Si 1, set FD_CLOEXEC sur le nouveau fd
 * @return Nouveau fd, -1 en cas d'erreur
 */
int fo_dup(int oldfd, int minfd, int cloexec);

/**
 * Obtenir/modifier les flags d'un fd
 * @param fd File descriptor
 * @param get_or_set 0 pour get, 1 pour set
 * @param flags Flags a definir (ignore si get)
 * @return Flags actuels si get, 0 si set succes, -1 en cas d'erreur
 */
int fo_fd_flags(int fd, int get_or_set, int flags);

#endif // FILEOPS_H
```

## Implementation (fileops.c)

```c
// fileops.c
#include "fileops.h"
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>

int fo_open(const char *path, int flags, mode_t mode,
            int exclusive, int truncate) {
    // Combiner les flags optionnels
    int combined_flags = flags;
    if (exclusive) {
        combined_flags |= O_EXCL;
    }
    if (truncate) {
        combined_flags |= O_TRUNC;
    }

    // Appeler open() avec les flags combines
    int fd = open(path, combined_flags, mode);
    if (fd < 0) {
        return -1;  // errno est deja defini par open()
    }
    return fd;
}

ssize_t fo_read_at(int fd, void *buf, size_t count, off_t offset) {
    if (offset >= 0) {
        // Lecture a position specifique (ne modifie pas le curseur)
        return pread(fd, buf, count, offset);
    } else {
        // Lecture a la position courante
        return read(fd, buf, count);
    }
}

ssize_t fo_write_at(int fd, const void *buf, size_t count, off_t offset) {
    if (offset >= 0) {
        // Ecriture a position specifique (ne modifie pas le curseur)
        return pwrite(fd, buf, count, offset);
    } else {
        // Ecriture a la position courante
        return write(fd, buf, count);
    }
}

off_t fo_seek(int fd, off_t offset, int whence) {
    return lseek(fd, offset, whence);
}

off_t fo_size(int fd) {
    // Sauvegarder la position actuelle
    off_t current = lseek(fd, 0, SEEK_CUR);
    if (current < 0) {
        return -1;
    }

    // Aller a la fin pour obtenir la taille
    off_t size = lseek(fd, 0, SEEK_END);
    if (size < 0) {
        return -1;
    }

    // Restaurer la position originale
    if (lseek(fd, current, SEEK_SET) < 0) {
        return -1;
    }

    return size;
}

int fo_fchmod(int fd, mode_t mode) {
    return fchmod(fd, mode);
}

int fo_chmod(const char *path, mode_t mode, int follow_symlinks) {
    if (follow_symlinks) {
        return chmod(path, mode);
    } else {
        // fchmodat avec AT_SYMLINK_NOFOLLOW pour ne pas suivre le symlink
        return fchmodat(AT_FDCWD, path, mode, AT_SYMLINK_NOFOLLOW);
    }
}

int fo_chown(const char *path, uid_t uid, gid_t gid, int follow_symlinks) {
    if (follow_symlinks) {
        return chown(path, uid, gid);
    } else {
        return lchown(path, uid, gid);
    }
}

int fo_set_setuid(const char *path, int enable) {
    struct stat st;
    if (stat(path, &st) < 0) {
        return -1;
    }

    mode_t new_mode;
    if (enable) {
        new_mode = st.st_mode | S_ISUID;
    } else {
        new_mode = st.st_mode & ~S_ISUID;
    }

    return chmod(path, new_mode);
}

int fo_set_setgid(const char *path, int enable) {
    struct stat st;
    if (stat(path, &st) < 0) {
        return -1;
    }

    mode_t new_mode;
    if (enable) {
        new_mode = st.st_mode | S_ISGID;
    } else {
        new_mode = st.st_mode & ~S_ISGID;
    }

    return chmod(path, new_mode);
}

int fo_stat(const char *path, fo_fileinfo_t *info, int follow_symlinks) {
    struct stat st;
    int result;

    if (follow_symlinks) {
        result = stat(path, &st);
    } else {
        result = lstat(path, &st);
    }

    if (result < 0) {
        return -1;
    }

    // Remplir la structure fo_fileinfo_t
    info->mode = st.st_mode;
    info->uid = st.st_uid;
    info->gid = st.st_gid;
    info->size = st.st_size;
    info->atime = st.st_atime;
    info->mtime = st.st_mtime;
    info->ctime = st.st_ctime;

    // Calculer les bits speciaux
    info->is_setuid = (st.st_mode & S_ISUID) ? 1 : 0;
    info->is_setgid = (st.st_mode & S_ISGID) ? 1 : 0;
    info->is_sticky = (st.st_mode & S_ISVTX) ? 1 : 0;

    return 0;
}

int fo_check_symlink_loop(const char *path, int max_depth) {
    char current[PATH_MAX];
    char target[PATH_MAX];
    struct stat st;
    int depth = 0;

    strncpy(current, path, PATH_MAX - 1);
    current[PATH_MAX - 1] = '\0';

    while (depth < max_depth) {
        // Verifier si c'est un symlink
        if (lstat(current, &st) < 0) {
            return -1;  // Erreur
        }

        if (!S_ISLNK(st.st_mode)) {
            // Ce n'est pas un symlink, pas de boucle
            return 0;
        }

        // Lire la cible du symlink
        ssize_t len = readlink(current, target, PATH_MAX - 1);
        if (len < 0) {
            return -1;
        }
        target[len] = '\0';

        // Si chemin relatif, le resoudre par rapport au repertoire du symlink
        if (target[0] != '/') {
            char *last_slash = strrchr(current, '/');
            if (last_slash) {
                *(last_slash + 1) = '\0';
                strncat(current, target, PATH_MAX - strlen(current) - 1);
            } else {
                strncpy(current, target, PATH_MAX - 1);
            }
        } else {
            strncpy(current, target, PATH_MAX - 1);
        }

        depth++;
    }

    // max_depth atteint = boucle probable
    return 1;
}

int fo_resolve_path(const char *path, char *resolved, int max_depth) {
    // Verifier d'abord s'il y a une boucle
    if (fo_check_symlink_loop(path, max_depth) == 1) {
        errno = ELOOP;
        return -1;
    }

    // Utiliser realpath pour resoudre le chemin
    if (realpath(path, resolved) == NULL) {
        return -1;
    }

    return 0;
}

int fo_dup(int oldfd, int minfd, int cloexec) {
    int cmd;
    if (cloexec) {
        cmd = F_DUPFD_CLOEXEC;  // Duplique et set CLOEXEC atomiquement
    } else {
        cmd = F_DUPFD;  // Duplique sans CLOEXEC
    }

    // minfd = valeur minimale pour le nouveau fd
    return fcntl(oldfd, cmd, minfd);
}

int fo_fd_flags(int fd, int get_or_set, int flags) {
    if (get_or_set == 0) {
        // GET: retourne les flags actuels
        return fcntl(fd, F_GETFD);
    } else {
        // SET: definit les nouveaux flags
        if (fcntl(fd, F_SETFD, flags) < 0) {
            return -1;
        }
        return 0;
    }
}
```

## Tests Automatises

```c
// test_fileops.c
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "fileops.h"

void test_open_exclusive() {
    const char *path = "/tmp/test_exclusive.txt";
    unlink(path);

    int fd1 = fo_open(path, O_RDWR | O_CREAT, 0644, 1, 0);
    assert(fd1 >= 0);

    // Doit echouer car fichier existe
    int fd2 = fo_open(path, O_RDWR | O_CREAT, 0644, 1, 0);
    assert(fd2 == -1);

    close(fd1);
    unlink(path);
    printf("test_open_exclusive: PASS\n");
}

void test_seek_and_size() {
    const char *path = "/tmp/test_seek.txt";
    int fd = fo_open(path, O_RDWR | O_CREAT, 0644, 0, 1);
    assert(fd >= 0);

    fo_write_at(fd, "Hello World", 11, 0);

    off_t size = fo_size(fd);
    assert(size == 11);

    off_t pos = fo_seek(fd, 6, SEEK_SET);
    assert(pos == 6);

    char buf[10];
    ssize_t n = fo_read_at(fd, buf, 5, -1);
    assert(n == 5);
    assert(memcmp(buf, "World", 5) == 0);

    close(fd);
    unlink(path);
    printf("test_seek_and_size: PASS\n");
}

void test_permissions() {
    const char *path = "/tmp/test_perms.txt";
    int fd = fo_open(path, O_RDWR | O_CREAT, 0644, 0, 1);
    close(fd);

    // Changer en 755
    assert(fo_chmod(path, 0755, 1) == 0);

    fo_fileinfo_t info;
    assert(fo_stat(path, &info, 1) == 0);
    assert((info.mode & 0777) == 0755);

    unlink(path);
    printf("test_permissions: PASS\n");
}

void test_setuid_setgid() {
    const char *path = "/tmp/test_setuid.txt";
    int fd = fo_open(path, O_RDWR | O_CREAT, 0755, 0, 1);
    close(fd);

    // Note: setuid peut necessiter root
    if (geteuid() == 0) {
        assert(fo_set_setuid(path, 1) == 0);

        fo_fileinfo_t info;
        fo_stat(path, &info, 1);
        assert(info.is_setuid == 1);

        fo_set_setuid(path, 0);
        fo_stat(path, &info, 1);
        assert(info.is_setuid == 0);
    }

    unlink(path);
    printf("test_setuid_setgid: PASS\n");
}

void test_symlink_loop() {
    // Creer une boucle de symlinks
    unlink("/tmp/loop_a");
    unlink("/tmp/loop_b");

    symlink("/tmp/loop_b", "/tmp/loop_a");
    symlink("/tmp/loop_a", "/tmp/loop_b");

    int has_loop = fo_check_symlink_loop("/tmp/loop_a", 40);
    assert(has_loop == 1);

    unlink("/tmp/loop_a");
    unlink("/tmp/loop_b");
    printf("test_symlink_loop: PASS\n");
}

void test_fcntl_dup() {
    int fd = open("/tmp/test_dup.txt", O_RDWR | O_CREAT, 0644);

    int newfd = fo_dup(fd, 100, 1);
    assert(newfd >= 100);

    // Verifier CLOEXEC
    int flags = fo_fd_flags(newfd, 0, 0);
    assert(flags & FD_CLOEXEC);

    close(fd);
    close(newfd);
    unlink("/tmp/test_dup.txt");
    printf("test_fcntl_dup: PASS\n");
}

int main() {
    test_open_exclusive();
    test_seek_and_size();
    test_permissions();
    test_setuid_setgid();
    test_symlink_loop();
    test_fcntl_dup();

    printf("\nAll tests passed!\n");
    return 0;
}
```

## Criteres d'evaluation
- [ ] fo_open avec O_EXCL et O_TRUNC fonctionnels
- [ ] fo_seek et positionnement correct
- [ ] Permissions octal correctement gerees
- [ ] Bits setuid/setgid manipulables
- [ ] Detection de boucles de symlinks
- [ ] fcntl pour duplication de fd
- [ ] Gestion des erreurs avec errno

## Note qualite: 95/100
