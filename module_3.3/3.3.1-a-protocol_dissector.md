# Exercice 3.3.1-a : protocol_dissector

**Module :**
3.3.1 ‚Äî Architecture Web Moderne

**Concept :**
a ‚Äî HTTP Protocol (m√©thodes, headers, status codes, HTTP/2, HTTP/3)

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ (7/10)

**Type :**
complet

**Tiers :**
2 ‚Äî M√©lange (concepts a + b via headers de s√©curit√©)

**Langage :**
Rust Edition 2024

**Pr√©requis :**
Bases Rust, JSON parsing (serde), Expressions r√©guli√®res

**Domaines :**
Net, Crypto, Encodage

**Dur√©e estim√©e :**
180 min (3 heures)

**XP Base :**
350

**Complexit√© :**
T2 O(n) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `protocol_dissector.rs`
**Fonctions autoris√©es :** serde, serde_json, regex, base64
**Fonctions interdites :** reqwest, hyper, curl (pas de vraies requ√™tes r√©seau)

### 1.2 Consigne

**üéÆ "Mr. Robot" ‚Äî Le Packet Sniffer d'Elliot**

*"Control is an illusion. But understanding the protocol? That's power."* ‚Äî Elliot Alderson

Tu es **Elliot Alderson**, hacker de g√©nie et ing√©nieur en cybers√©curit√© chez Allsafe. Ton travail de jour consiste √† prot√©ger les entreprises, mais tu sais que la vraie s√©curit√© commence par comprendre chaque octet qui traverse le r√©seau.

Aujourd'hui, tu dois analyser des requ√™tes HTTP intercept√©es pour d√©tecter les failles de configuration. Comme Elliot qui voit les patterns cach√©s que les autres ignorent, tu dois d√©cortiquer chaque header, chaque status code, chaque anomalie.

**Contexte R√©el :**

L'analyse de protocole HTTP est fondamentale en cybers√©curit√© :
- **Pentesters** : Identifient les headers de s√©curit√© manquants
- **Blue Team** : D√©tectent les requ√™tes malveillantes
- **DevSecOps** : Auditent les configurations de serveur
- **Bug Bounty Hunters** : Trouvent les misconfiguration qui m√®nent √† des vuln√©rabilit√©s

**Ta mission :**

Impl√©menter un analyseur de requ√™tes/r√©ponses HTTP qui :

1. **Parse les requ√™tes HTTP/1.1 brutes** : Extrait m√©thode, URI, headers, body
2. **Parse les r√©ponses HTTP** : Status code, headers, body
3. **D√©tecte les anomalies de s√©curit√©** : Headers manquants, m√©thodes dangereuses, versions expos√©es
4. **Identifie les diff√©rences HTTP/1.1 vs HTTP/2** : Pseudo-headers, multiplexing indicators
5. **G√©n√®re un rapport de conformit√© s√©curit√©** : Score, issues, recommandations

**Entr√©e :**
- `input_json` : String JSON contenant :
  - `raw_request` : Requ√™te HTTP brute (String avec \r\n)
  - `raw_response` : R√©ponse HTTP brute (String avec \r\n)
  - `expected_security_headers` : Liste des headers de s√©curit√© attendus

**Sortie :**
- JSON structur√© avec :
  - `parsed_request` : Requ√™te pars√©e (method, path, version, headers, body)
  - `parsed_response` : R√©ponse pars√©e (status_code, status_text, headers, body)
  - `security_issues` : Liste des probl√®mes d√©tect√©s avec s√©v√©rit√© et CWE
  - `missing_security_headers` : Headers de s√©curit√© manquants
  - `security_score` : Score de 0 √† 100
  - `recommendations` : Liste de recommandations

**Contraintes :**
- Les headers sont case-insensitive (Content-Type == content-type)
- G√©rer les line endings \r\n (CRLF) et \n (LF)
- Les headers multi-lignes (continuation avec espace/tab) doivent √™tre g√©r√©s
- Le body est s√©par√© des headers par une ligne vide (\r\n\r\n)

**Exemples :**

| Cas | Description | Comportement |
|-----|-------------|--------------|
| Request basique | `GET /index.html HTTP/1.1\r\n...` | Parse correctement method, path |
| Server version | `Server: Apache/2.4.1` | Issue: "Server version disclosure" |
| Missing CSP | Pas de Content-Security-Policy | Issue: "Missing CSP header" |
| TRACE enabled | `TRACE /test HTTP/1.1` | Issue HIGH: "TRACE method enabled" |
| X-Frame-Options | Header pr√©sent | Pas d'issue pour clickjacking |

### 1.2.2 Consigne Acad√©mique

Cet exercice impl√©mente un parseur et analyseur de s√©curit√© pour le protocole HTTP/1.1. L'objectif est de comprendre la structure des messages HTTP (requ√™tes et r√©ponses), d'extraire les composants (ligne de requ√™te/statut, headers, body), et d'√©valuer la posture de s√©curit√© bas√©e sur les headers pr√©sents ou absents.

Le syst√®me doit :
1. Parser correctement le format HTTP/1.1 (RFC 7230-7235)
2. Extraire les headers avec gestion du case-insensitivity
3. D√©tecter les probl√®mes de s√©curit√© (CWE mapp√©s)
4. Calculer un score de s√©curit√© objectif
5. G√©n√©rer des recommandations actionnables

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Point d'entr√©e principal
pub fn protocol_dissector(input_json: &str) -> String {
    // Parse input
    let input: DissectorInput = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => return format!(r#"{{"error": "Invalid JSON: {}"}}"#, e),
    };

    // Parse request and response
    let parsed_request = parse_http_request(&input.raw_request);
    let parsed_response = parse_http_response(&input.raw_response);

    // Analyze security
    let analysis = analyze_security(&parsed_request, &parsed_response, &input.expected_security_headers);

    // Build output
    let output = DissectorOutput {
        parsed_request,
        parsed_response,
        security_issues: analysis.issues,
        missing_security_headers: analysis.missing_headers,
        security_score: analysis.score,
        recommendations: analysis.recommendations,
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|e| format!(r#"{{"error": "{}"}}"#, e))
}

// ============ STRUCTURES D'ENTR√âE ============

#[derive(Debug, Deserialize)]
pub struct DissectorInput {
    pub raw_request: String,
    pub raw_response: String,
    #[serde(default)]
    pub expected_security_headers: Vec<String>,
}

// ============ STRUCTURES DE SORTIE ============

#[derive(Debug, Serialize)]
pub struct DissectorOutput {
    pub parsed_request: ParsedRequest,
    pub parsed_response: ParsedResponse,
    pub security_issues: Vec<SecurityIssue>,
    pub missing_security_headers: Vec<String>,
    pub security_score: u32,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Default)]
pub struct ParsedRequest {
    pub method: String,
    pub path: String,
    pub http_version: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
    pub is_valid: bool,
    pub parse_errors: Vec<String>,
}

#[derive(Debug, Serialize, Default)]
pub struct ParsedResponse {
    pub status_code: u16,
    pub status_text: String,
    pub http_version: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
    pub is_valid: bool,
    pub parse_errors: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct SecurityIssue {
    pub severity: String,  // "CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"
    pub issue: String,
    pub cwe: Option<String>,
    pub details: Option<String>,
}

struct SecurityAnalysis {
    issues: Vec<SecurityIssue>,
    missing_headers: Vec<String>,
    score: u32,
    recommendations: Vec<String>,
}

// ============ FONCTIONS √Ä IMPL√âMENTER ============

/// Parse une requ√™te HTTP brute
pub fn parse_http_request(raw: &str) -> ParsedRequest {
    todo!()
}

/// Parse une r√©ponse HTTP brute
pub fn parse_http_response(raw: &str) -> ParsedResponse {
    todo!()
}

/// Analyse la s√©curit√© des requ√™te/r√©ponse
fn analyze_security(
    request: &ParsedRequest,
    response: &ParsedResponse,
    expected_headers: &[String],
) -> SecurityAnalysis {
    todo!()
}

/// Normalise un nom de header (lowercase)
fn normalize_header_name(name: &str) -> String {
    name.trim().to_lowercase()
}

/// V√©rifie si une m√©thode HTTP est dangereuse
fn is_dangerous_method(method: &str) -> bool {
    matches!(method.to_uppercase().as_str(), "TRACE" | "TRACK" | "DEBUG")
}
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Le protocole HTTP a √©t√© invent√© par Tim Berners-Lee en 1991

HTTP (HyperText Transfer Protocol) est le protocole fondamental du Web. Voici son √©volution :

| Version | Ann√©e | Caract√©ristiques |
|---------|-------|------------------|
| HTTP/0.9 | 1991 | Une seule m√©thode (GET), pas de headers |
| HTTP/1.0 | 1996 | Headers, m√©thodes POST/HEAD, status codes |
| HTTP/1.1 | 1997 | Keep-alive, chunked transfer, Host obligatoire |
| HTTP/2 | 2015 | Binaire, multiplexing, server push, HPACK |
| HTTP/3 | 2022 | QUIC (UDP), 0-RTT, meilleure latence |

**Fun fact :** Le status code 418 "I'm a teapot" existe vraiment ! C'est un poisson d'avril de l'IETF (RFC 2324) pour le protocole HTCPCP (Hyper Text Coffee Pot Control Protocol).

---

## üìç SECTION 2.5 : DANS LA VRAIE VIE

### Qui utilise l'analyse de protocole HTTP ?

| M√©tier | Cas d'usage |
|--------|-------------|
| **Pentester** | Analyse des headers pour trouver les misconfigurations (Server version, missing security headers) |
| **SOC Analyst** | D√©tection de requ√™tes malveillantes dans les logs HTTP (SQL injection patterns, path traversal) |
| **DevSecOps** | Audit automatis√© des configurations de serveur web dans le CI/CD |
| **Bug Bounty Hunter** | Recherche de headers manquants pour CORS, CSP, clickjacking |
| **Reverse Engineer** | Analyse de protocoles propri√©taires bas√©s sur HTTP |

**Outils professionnels √©quivalents :**
- Burp Suite (Proxy intercepteur)
- Wireshark (Analyse packets)
- mitmproxy (Man-in-the-middle proxy)
- httpie (Client HTTP CLI)

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
protocol_dissector.rs  main.rs

$ rustc --edition 2024 protocol_dissector.rs main.rs -o test

$ ./test
=== Test 1: Basic GET Request ===
Parsed Method: GET
Parsed Path: /admin
Security Issues: 2
  - HIGH: TRACE method may be enabled
  - MEDIUM: Server version disclosure (Apache/2.4.1)
Missing Headers: ["Content-Security-Policy", "X-Frame-Options"]
Security Score: 45/100
OK

=== Test 2: Secure Response ===
Security Issues: 0
Missing Headers: []
Security Score: 100/100
OK

=== Test 3: Malformed Request ===
Parse Errors: ["Invalid HTTP version format"]
OK

All tests passed!
```

---

## ‚ö° SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficult√© Bonus :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**R√©compense :**
XP √ó2

**Time Complexity attendue :**
O(n)

**Space Complexity attendue :**
O(n)

### 3.1.1 Consigne Bonus

**üéÆ "Mr. Robot" ‚Äî Le Mode Paranoid d'Elliot**

Elliot ne fait confiance √† personne. Son analyseur doit aussi d√©tecter les attaques cach√©es dans les requ√™tes HTTP.

**Ta mission bonus :**

√âtendre l'analyseur pour d√©tecter :

1. **HTTP Request Smuggling indicators** : Content-Length et Transfer-Encoding conflictuels
2. **CRLF Injection** : \r\n dans les valeurs de header
3. **Host Header attacks** : Multiple Host headers, Host mismatch
4. **HTTP/2 Pseudo-headers** : D√©tecter :method, :path, :scheme, :authority

**Entr√©e additionnelle :**
- `detect_smuggling` : boolean pour activer la d√©tection de smuggling
- `http2_mode` : boolean pour parser les pseudo-headers HTTP/2

**Sortie additionnelle :**
- `smuggling_indicators` : Liste des indicateurs de smuggling
- `injection_attempts` : Tentatives d'injection d√©tect√©es

### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Serialize)]
pub struct BonusAnalysis {
    pub smuggling_indicators: Vec<SmugglingIndicator>,
    pub injection_attempts: Vec<InjectionAttempt>,
    pub http2_analysis: Option<Http2Analysis>,
}

#[derive(Debug, Serialize)]
pub struct SmugglingIndicator {
    pub indicator_type: String,  // "CL_TE", "TE_CL", "TE_TE"
    pub description: String,
    pub severity: String,
}

#[derive(Debug, Serialize)]
pub struct InjectionAttempt {
    pub injection_type: String,  // "CRLF", "HOST_HEADER"
    pub location: String,
    pub payload: String,
}
```

### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| D√©tections | Headers manquants, versions | + Smuggling, injections |
| HTTP versions | HTTP/1.1 | + HTTP/2 pseudo-headers |
| Complexit√© | Simple parsing | + Pattern matching avanc√© |
| S√©curit√© | Configuration | + Attaques actives |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Description | Points | R√©sultat Attendu |
|------|-------------|--------|------------------|
| `test_parse_basic_get` | Parse GET /index.html HTTP/1.1 | 5 | method="GET", path="/index.html" |
| `test_parse_post_with_body` | Parse POST avec body JSON | 5 | body pr√©sent, Content-Type d√©tect√© |
| `test_parse_headers_case_insensitive` | Content-Type == content-type | 5 | Headers normalis√©s |
| `test_parse_response_200` | Parse HTTP/1.1 200 OK | 5 | status_code=200 |
| `test_parse_response_404` | Parse 404 Not Found | 5 | status_code=404 |
| `test_detect_server_version` | Server: Apache/2.4.1 | 10 | Issue MEDIUM d√©tect√©e |
| `test_detect_missing_csp` | Pas de CSP header | 10 | missing_headers contient "Content-Security-Policy" |
| `test_detect_missing_xframe` | Pas de X-Frame-Options | 10 | missing_headers contient "X-Frame-Options" |
| `test_detect_trace_method` | TRACE request | 10 | Issue HIGH: TRACE method |
| `test_secure_response_full` | Tous les headers pr√©sents | 10 | score=100, issues=[] |
| `test_multiline_header` | Header avec continuation | 5 | Header correctement pars√© |
| `test_chunked_indicator` | Transfer-Encoding: chunked | 5 | Header d√©tect√© |
| `test_malformed_request` | Requ√™te invalide | 5 | is_valid=false, parse_errors rempli |
| `test_empty_body` | Requ√™te sans body | 5 | body=None |
| `test_score_calculation` | Score coh√©rent | 5 | Score entre 0 et 100 |

**Total : 100 points**

### 4.2 main.rs de test

```rust
use std::collections::HashMap;

mod protocol_dissector;
use protocol_dissector::*;

fn main() {
    let mut passed = 0;
    let mut failed = 0;

    // Test 1: Basic GET Request
    println!("=== Test 1: Basic GET Request ===");
    let input1 = r#"{
        "raw_request": "GET /admin HTTP/1.1\r\nHost: example.com\r\nUser-Agent: Mozilla/5.0\r\n\r\n",
        "raw_response": "HTTP/1.1 200 OK\r\nServer: Apache/2.4.1\r\nContent-Type: text/html\r\n\r\n<html></html>",
        "expected_security_headers": ["Content-Security-Policy", "X-Frame-Options", "X-Content-Type-Options"]
    }"#;

    let result1 = protocol_dissector(input1);
    let output1: serde_json::Value = serde_json::from_str(&result1).unwrap();

    assert_eq!(output1["parsed_request"]["method"], "GET");
    assert_eq!(output1["parsed_request"]["path"], "/admin");
    assert!(output1["security_issues"].as_array().unwrap().len() > 0);
    println!("Method: {}", output1["parsed_request"]["method"]);
    println!("Security Issues: {}", output1["security_issues"].as_array().unwrap().len());
    println!("OK\n");
    passed += 1;

    // Test 2: Secure Response
    println!("=== Test 2: Secure Response ===");
    let input2 = r#"{
        "raw_request": "GET / HTTP/1.1\r\nHost: secure.com\r\n\r\n",
        "raw_response": "HTTP/1.1 200 OK\r\nContent-Security-Policy: default-src 'self'\r\nX-Frame-Options: DENY\r\nX-Content-Type-Options: nosniff\r\nStrict-Transport-Security: max-age=31536000\r\n\r\nOK",
        "expected_security_headers": ["Content-Security-Policy", "X-Frame-Options", "X-Content-Type-Options"]
    }"#;

    let result2 = protocol_dissector(input2);
    let output2: serde_json::Value = serde_json::from_str(&result2).unwrap();

    assert!(output2["missing_security_headers"].as_array().unwrap().is_empty());
    assert!(output2["security_score"].as_u64().unwrap() >= 80);
    println!("Missing Headers: {:?}", output2["missing_security_headers"]);
    println!("Security Score: {}", output2["security_score"]);
    println!("OK\n");
    passed += 1;

    // Test 3: TRACE Method Detection
    println!("=== Test 3: TRACE Method Detection ===");
    let input3 = r#"{
        "raw_request": "TRACE /test HTTP/1.1\r\nHost: example.com\r\n\r\n",
        "raw_response": "HTTP/1.1 200 OK\r\n\r\n",
        "expected_security_headers": []
    }"#;

    let result3 = protocol_dissector(input3);
    let output3: serde_json::Value = serde_json::from_str(&result3).unwrap();

    let issues: Vec<&serde_json::Value> = output3["security_issues"]
        .as_array()
        .unwrap()
        .iter()
        .filter(|i| i["issue"].as_str().unwrap().contains("TRACE"))
        .collect();
    assert!(!issues.is_empty());
    println!("TRACE issue detected: {}", issues[0]["issue"]);
    println!("OK\n");
    passed += 1;

    // Test 4: Malformed Request
    println!("=== Test 4: Malformed Request ===");
    let input4 = r#"{
        "raw_request": "INVALID REQUEST FORMAT",
        "raw_response": "HTTP/1.1 400 Bad Request\r\n\r\n",
        "expected_security_headers": []
    }"#;

    let result4 = protocol_dissector(input4);
    let output4: serde_json::Value = serde_json::from_str(&result4).unwrap();

    assert_eq!(output4["parsed_request"]["is_valid"], false);
    assert!(!output4["parsed_request"]["parse_errors"].as_array().unwrap().is_empty());
    println!("Parse errors: {:?}", output4["parsed_request"]["parse_errors"]);
    println!("OK\n");
    passed += 1;

    // Summary
    println!("================================");
    println!("Tests passed: {}/{}", passed, passed + failed);
    if failed == 0 {
        println!("All tests passed!");
    }
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub fn protocol_dissector(input_json: &str) -> String {
    let input: DissectorInput = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => return format!(r#"{{"error": "Invalid JSON: {}"}}"#, e),
    };

    let parsed_request = parse_http_request(&input.raw_request);
    let parsed_response = parse_http_response(&input.raw_response);
    let analysis = analyze_security(&parsed_request, &parsed_response, &input.expected_security_headers);

    let output = DissectorOutput {
        parsed_request,
        parsed_response,
        security_issues: analysis.issues,
        missing_security_headers: analysis.missing_headers,
        security_score: analysis.score,
        recommendations: analysis.recommendations,
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|e| format!(r#"{{"error": "{}"}}"#, e))
}

#[derive(Debug, Deserialize)]
pub struct DissectorInput {
    pub raw_request: String,
    pub raw_response: String,
    #[serde(default)]
    pub expected_security_headers: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct DissectorOutput {
    pub parsed_request: ParsedRequest,
    pub parsed_response: ParsedResponse,
    pub security_issues: Vec<SecurityIssue>,
    pub missing_security_headers: Vec<String>,
    pub security_score: u32,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Default)]
pub struct ParsedRequest {
    pub method: String,
    pub path: String,
    pub http_version: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
    pub is_valid: bool,
    pub parse_errors: Vec<String>,
}

#[derive(Debug, Serialize, Default)]
pub struct ParsedResponse {
    pub status_code: u16,
    pub status_text: String,
    pub http_version: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
    pub is_valid: bool,
    pub parse_errors: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct SecurityIssue {
    pub severity: String,
    pub issue: String,
    pub cwe: Option<String>,
    pub details: Option<String>,
}

struct SecurityAnalysis {
    issues: Vec<SecurityIssue>,
    missing_headers: Vec<String>,
    score: u32,
    recommendations: Vec<String>,
}

pub fn parse_http_request(raw: &str) -> ParsedRequest {
    let mut result = ParsedRequest::default();

    // Normalize line endings
    let normalized = raw.replace("\r\n", "\n");

    // Split into header section and body
    let parts: Vec<&str> = normalized.splitn(2, "\n\n").collect();
    let header_section = parts.get(0).unwrap_or(&"");
    let body_section = parts.get(1);

    // Parse lines
    let lines: Vec<&str> = header_section.lines().collect();

    if lines.is_empty() {
        result.parse_errors.push("Empty request".to_string());
        return result;
    }

    // Parse request line: METHOD PATH HTTP/VERSION
    let request_line_parts: Vec<&str> = lines[0].split_whitespace().collect();

    if request_line_parts.len() < 3 {
        result.parse_errors.push("Invalid request line format".to_string());
        return result;
    }

    result.method = request_line_parts[0].to_string();
    result.path = request_line_parts[1].to_string();
    result.http_version = request_line_parts[2].replace("HTTP/", "");

    // Validate HTTP version
    if !["1.0", "1.1", "2", "2.0", "3"].contains(&result.http_version.as_str()) {
        result.parse_errors.push(format!("Invalid HTTP version: {}", result.http_version));
    }

    // Parse headers (case-insensitive)
    let mut i = 1;
    while i < lines.len() {
        let line = lines[i];

        // Handle header continuation (starts with space or tab)
        if line.starts_with(' ') || line.starts_with('\t') {
            // Continuation of previous header - append to last value
            if let Some(last_key) = result.headers.keys().last().cloned() {
                if let Some(value) = result.headers.get_mut(&last_key) {
                    value.push(' ');
                    value.push_str(line.trim());
                }
            }
            i += 1;
            continue;
        }

        // Parse header: Name: Value
        if let Some(colon_pos) = line.find(':') {
            let name = normalize_header_name(&line[..colon_pos]);
            let value = line[colon_pos + 1..].trim().to_string();
            result.headers.insert(name, value);
        }

        i += 1;
    }

    // Set body
    if let Some(body) = body_section {
        if !body.is_empty() {
            result.body = Some(body.to_string());
        }
    }

    result.is_valid = result.parse_errors.is_empty();
    result
}

pub fn parse_http_response(raw: &str) -> ParsedResponse {
    let mut result = ParsedResponse::default();

    // Normalize line endings
    let normalized = raw.replace("\r\n", "\n");

    // Split into header section and body
    let parts: Vec<&str> = normalized.splitn(2, "\n\n").collect();
    let header_section = parts.get(0).unwrap_or(&"");
    let body_section = parts.get(1);

    // Parse lines
    let lines: Vec<&str> = header_section.lines().collect();

    if lines.is_empty() {
        result.parse_errors.push("Empty response".to_string());
        return result;
    }

    // Parse status line: HTTP/VERSION STATUS_CODE STATUS_TEXT
    let status_line_parts: Vec<&str> = lines[0].splitn(3, ' ').collect();

    if status_line_parts.len() < 2 {
        result.parse_errors.push("Invalid status line format".to_string());
        return result;
    }

    result.http_version = status_line_parts[0].replace("HTTP/", "");
    result.status_code = status_line_parts[1].parse().unwrap_or(0);
    result.status_text = status_line_parts.get(2).unwrap_or(&"").to_string();

    if result.status_code == 0 {
        result.parse_errors.push("Invalid status code".to_string());
    }

    // Parse headers
    for line in &lines[1..] {
        if let Some(colon_pos) = line.find(':') {
            let name = normalize_header_name(&line[..colon_pos]);
            let value = line[colon_pos + 1..].trim().to_string();
            result.headers.insert(name, value);
        }
    }

    // Set body
    if let Some(body) = body_section {
        if !body.is_empty() {
            result.body = Some(body.to_string());
        }
    }

    result.is_valid = result.parse_errors.is_empty();
    result
}

fn analyze_security(
    request: &ParsedRequest,
    response: &ParsedResponse,
    expected_headers: &[String],
) -> SecurityAnalysis {
    let mut issues = Vec::new();
    let mut missing_headers = Vec::new();
    let mut recommendations = Vec::new();
    let mut penalty = 0u32;

    // Check for dangerous methods
    if is_dangerous_method(&request.method) {
        issues.push(SecurityIssue {
            severity: "HIGH".to_string(),
            issue: format!("{} method enabled - potential XST vulnerability", request.method),
            cwe: Some("CWE-693".to_string()),
            details: Some("TRACE/TRACK methods can be used for Cross-Site Tracing attacks".to_string()),
        });
        penalty += 25;
        recommendations.push(format!("Disable {} method in server configuration", request.method));
    }

    // Check for server version disclosure
    if let Some(server) = response.headers.get("server") {
        if server.contains('/') {
            issues.push(SecurityIssue {
                severity: "MEDIUM".to_string(),
                issue: "Server version disclosure".to_string(),
                cwe: Some("CWE-200".to_string()),
                details: Some(format!("Server header reveals version: {}", server)),
            });
            penalty += 10;
            recommendations.push("Remove version information from Server header".to_string());
        }
    }

    // Check for X-Powered-By disclosure
    if response.headers.contains_key("x-powered-by") {
        issues.push(SecurityIssue {
            severity: "LOW".to_string(),
            issue: "X-Powered-By header present".to_string(),
            cwe: Some("CWE-200".to_string()),
            details: Some("Technology stack disclosure".to_string()),
        });
        penalty += 5;
        recommendations.push("Remove X-Powered-By header".to_string());
    }

    // Check expected security headers
    let security_headers_map: HashMap<&str, (&str, u32)> = [
        ("content-security-policy", ("Prevents XSS and data injection", 15)),
        ("x-frame-options", ("Prevents clickjacking", 10)),
        ("x-content-type-options", ("Prevents MIME sniffing", 10)),
        ("strict-transport-security", ("Enforces HTTPS", 15)),
        ("x-xss-protection", ("Legacy XSS protection", 5)),
        ("referrer-policy", ("Controls referrer information", 5)),
        ("permissions-policy", ("Controls browser features", 5)),
    ].iter().cloned().collect();

    for expected in expected_headers {
        let normalized = normalize_header_name(expected);
        if !response.headers.contains_key(&normalized) {
            missing_headers.push(expected.clone());

            if let Some((desc, pen)) = security_headers_map.get(normalized.as_str()) {
                issues.push(SecurityIssue {
                    severity: if *pen >= 15 { "HIGH" } else if *pen >= 10 { "MEDIUM" } else { "LOW" }.to_string(),
                    issue: format!("Missing {} header", expected),
                    cwe: Some("CWE-693".to_string()),
                    details: Some(desc.to_string()),
                });
                penalty += pen;
                recommendations.push(format!("Add {} header", expected));
            }
        }
    }

    // Calculate score (100 - penalties, minimum 0)
    let score = 100u32.saturating_sub(penalty);

    SecurityAnalysis {
        issues,
        missing_headers,
        score,
        recommendations,
    }
}

fn normalize_header_name(name: &str) -> String {
    name.trim().to_lowercase()
}

fn is_dangerous_method(method: &str) -> bool {
    matches!(method.to_uppercase().as_str(), "TRACE" | "TRACK" | "DEBUG")
}
```

### 4.4 Solutions alternatives accept√©es

```rust
// Alternative 1: Utilisation de regex pour le parsing
use regex::Regex;

pub fn parse_http_request_regex(raw: &str) -> ParsedRequest {
    let mut result = ParsedRequest::default();

    let request_line_re = Regex::new(r"^(\w+)\s+(\S+)\s+HTTP/(\d+\.?\d*)").unwrap();
    let header_re = Regex::new(r"^([^:]+):\s*(.*)$").unwrap();

    let normalized = raw.replace("\r\n", "\n");
    let parts: Vec<&str> = normalized.splitn(2, "\n\n").collect();

    let lines: Vec<&str> = parts[0].lines().collect();

    if let Some(caps) = request_line_re.captures(lines.get(0).unwrap_or(&"")) {
        result.method = caps[1].to_string();
        result.path = caps[2].to_string();
        result.http_version = caps[3].to_string();
        result.is_valid = true;
    } else {
        result.parse_errors.push("Invalid request line".to_string());
    }

    for line in &lines[1..] {
        if let Some(caps) = header_re.captures(line) {
            result.headers.insert(
                caps[1].to_lowercase(),
                caps[2].trim().to_string()
            );
        }
    }

    if let Some(body) = parts.get(1) {
        if !body.is_empty() {
            result.body = Some(body.to_string());
        }
    }

    result
}

// Alternative 2: Parser it√©ratif avec √©tat
pub fn parse_http_request_state_machine(raw: &str) -> ParsedRequest {
    enum ParseState { RequestLine, Headers, Body }

    let mut result = ParsedRequest::default();
    let mut state = ParseState::RequestLine;
    let mut body_lines = Vec::new();

    for line in raw.lines() {
        match state {
            ParseState::RequestLine => {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 3 {
                    result.method = parts[0].to_string();
                    result.path = parts[1].to_string();
                    result.http_version = parts[2].replace("HTTP/", "");
                    result.is_valid = true;
                }
                state = ParseState::Headers;
            }
            ParseState::Headers => {
                if line.trim().is_empty() {
                    state = ParseState::Body;
                } else if let Some(pos) = line.find(':') {
                    result.headers.insert(
                        line[..pos].to_lowercase(),
                        line[pos+1..].trim().to_string()
                    );
                }
            }
            ParseState::Body => {
                body_lines.push(line);
            }
        }
    }

    if !body_lines.is_empty() {
        result.body = Some(body_lines.join("\n"));
    }

    result
}
```

### 4.5 Solutions refus√©es (avec explications)

```rust
// ‚ùå REFUS√â 1: Pas de gestion du case-insensitivity
pub fn parse_headers_wrong(raw: &str) -> HashMap<String, String> {
    let mut headers = HashMap::new();
    for line in raw.lines() {
        if let Some(pos) = line.find(':') {
            // ERREUR: Ne normalise pas le nom du header
            headers.insert(
                line[..pos].to_string(),  // Devrait √™tre .to_lowercase()
                line[pos+1..].trim().to_string()
            );
        }
    }
    headers
}
// Pourquoi refus√©: Les headers HTTP sont case-insensitive selon RFC 7230
// "Content-Type" et "content-type" doivent √™tre trait√©s comme identiques

// ‚ùå REFUS√â 2: Pas de gestion des erreurs de parsing
pub fn parse_request_no_validation(raw: &str) -> ParsedRequest {
    let lines: Vec<&str> = raw.lines().collect();
    let parts: Vec<&str> = lines[0].split_whitespace().collect();
    // ERREUR: Panic si la ligne est vide ou mal form√©e
    ParsedRequest {
        method: parts[0].to_string(),  // IndexError possible
        path: parts[1].to_string(),     // IndexError possible
        http_version: parts[2].to_string(),
        ..Default::default()
    }
}
// Pourquoi refus√©: Pas de gestion des requ√™tes malform√©es, panic possible

// ‚ùå REFUS√â 3: Ignorer les headers multi-lignes
pub fn parse_headers_no_continuation(raw: &str) -> HashMap<String, String> {
    let mut headers = HashMap::new();
    for line in raw.lines() {
        // ERREUR: Ignore les lignes de continuation (commen√ßant par espace/tab)
        if let Some(pos) = line.find(':') {
            headers.insert(line[..pos].to_lowercase(), line[pos+1..].trim().to_string());
        }
    }
    headers
}
// Pourquoi refus√©: RFC 7230 permet les headers sur plusieurs lignes
// avec continuation par espace ou tabulation

// ‚ùå REFUS√â 4: Hardcoder le score sans analyse
pub fn analyze_security_fake(response: &ParsedResponse) -> u32 {
    // ERREUR: Retourne toujours 100 sans vraie analyse
    100
}
// Pourquoi refus√©: Le score doit refl√©ter la vraie posture de s√©curit√©
```

### 4.6 Solution bonus de r√©f√©rence

```rust
#[derive(Debug, Serialize)]
pub struct BonusOutput {
    #[serde(flatten)]
    pub base: DissectorOutput,
    pub bonus_analysis: BonusAnalysis,
}

#[derive(Debug, Serialize)]
pub struct BonusAnalysis {
    pub smuggling_indicators: Vec<SmugglingIndicator>,
    pub injection_attempts: Vec<InjectionAttempt>,
    pub http2_analysis: Option<Http2Analysis>,
}

#[derive(Debug, Serialize)]
pub struct SmugglingIndicator {
    pub indicator_type: String,
    pub description: String,
    pub severity: String,
}

#[derive(Debug, Serialize)]
pub struct InjectionAttempt {
    pub injection_type: String,
    pub location: String,
    pub payload: String,
}

#[derive(Debug, Serialize)]
pub struct Http2Analysis {
    pub pseudo_headers: HashMap<String, String>,
    pub is_valid_http2: bool,
}

pub fn analyze_smuggling(request: &ParsedRequest, response: &ParsedResponse) -> Vec<SmugglingIndicator> {
    let mut indicators = Vec::new();

    let has_cl = request.headers.contains_key("content-length");
    let has_te = request.headers.contains_key("transfer-encoding");

    // CL.TE or TE.CL detection
    if has_cl && has_te {
        indicators.push(SmugglingIndicator {
            indicator_type: "CL_TE_CONFLICT".to_string(),
            description: "Both Content-Length and Transfer-Encoding present".to_string(),
            severity: "CRITICAL".to_string(),
        });
    }

    // Check for obfuscated Transfer-Encoding
    for (key, value) in &request.headers {
        if key.contains("transfer") && key != "transfer-encoding" {
            indicators.push(SmugglingIndicator {
                indicator_type: "TE_OBFUSCATION".to_string(),
                description: format!("Potentially obfuscated Transfer-Encoding: {}", key),
                severity: "HIGH".to_string(),
            });
        }

        // Check for Transfer-Encoding variations
        if key == "transfer-encoding" {
            if value.contains("chunked") && value.len() > 7 {
                indicators.push(SmugglingIndicator {
                    indicator_type: "TE_TE".to_string(),
                    description: format!("Obfuscated chunked encoding: {}", value),
                    severity: "HIGH".to_string(),
                });
            }
        }
    }

    indicators
}

pub fn detect_injections(request: &ParsedRequest) -> Vec<InjectionAttempt> {
    let mut attempts = Vec::new();

    // Check for CRLF in header values
    for (key, value) in &request.headers {
        if value.contains("\r") || value.contains("\n") || value.contains("%0d") || value.contains("%0a") {
            attempts.push(InjectionAttempt {
                injection_type: "CRLF".to_string(),
                location: format!("Header: {}", key),
                payload: value.clone(),
            });
        }
    }

    // Check for multiple Host headers (via header value containing Host:)
    if let Some(host) = request.headers.get("host") {
        if host.contains("Host:") || host.contains("host:") {
            attempts.push(InjectionAttempt {
                injection_type: "HOST_HEADER_INJECTION".to_string(),
                location: "Host header".to_string(),
                payload: host.clone(),
            });
        }
    }

    // Check path for CRLF
    if request.path.contains("%0d") || request.path.contains("%0a") {
        attempts.push(InjectionAttempt {
            injection_type: "CRLF".to_string(),
            location: "Request path".to_string(),
            payload: request.path.clone(),
        });
    }

    attempts
}

pub fn analyze_http2(request: &ParsedRequest) -> Option<Http2Analysis> {
    let pseudo_headers: HashMap<String, String> = request.headers.iter()
        .filter(|(k, _)| k.starts_with(':'))
        .map(|(k, v)| (k.clone(), v.clone()))
        .collect();

    if pseudo_headers.is_empty() {
        return None;
    }

    let required = [":method", ":path", ":scheme"];
    let is_valid = required.iter().all(|h| pseudo_headers.contains_key(*h));

    Some(Http2Analysis {
        pseudo_headers,
        is_valid_http2: is_valid,
    })
}
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "protocol_dissector",
  "language": "rust",
  "version": "2024",
  "type": "code",
  "tier": 2,
  "tier_info": "M√©lange (concepts a + s√©curit√© headers)",
  "tags": ["http", "parsing", "security", "headers", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "protocol_dissector",
    "prototype": "pub fn protocol_dissector(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_protocol_dissector(input_json: &str) -> String { let input: DissectorInput = serde_json::from_str(input_json).unwrap(); let req = parse_http_request(&input.raw_request); let resp = parse_http_response(&input.raw_response); let analysis = analyze_security(&req, &resp, &input.expected_security_headers); serde_json::to_string(&DissectorOutput { parsed_request: req, parsed_response: resp, security_issues: analysis.issues, missing_security_headers: analysis.missing_headers, security_score: analysis.score, recommendations: analysis.recommendations }).unwrap() }",

    "edge_cases": [
      {
        "name": "basic_get_request",
        "args": ["{\"raw_request\": \"GET / HTTP/1.1\\r\\nHost: test.com\\r\\n\\r\\n\", \"raw_response\": \"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"expected_security_headers\": []}"],
        "expected_contains": ["\"method\": \"GET\"", "\"path\": \"/\""],
        "is_trap": false
      },
      {
        "name": "null_input",
        "args": [""],
        "expected_contains": ["error"],
        "is_trap": true,
        "trap_explanation": "Input vide doit retourner une erreur JSON"
      },
      {
        "name": "malformed_request",
        "args": ["{\"raw_request\": \"INVALID\", \"raw_response\": \"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"expected_security_headers\": []}"],
        "expected_contains": ["\"is_valid\": false"],
        "is_trap": true,
        "trap_explanation": "Requ√™te invalide doit √™tre d√©tect√©e"
      },
      {
        "name": "trace_method",
        "args": ["{\"raw_request\": \"TRACE / HTTP/1.1\\r\\nHost: test.com\\r\\n\\r\\n\", \"raw_response\": \"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"expected_security_headers\": []}"],
        "expected_contains": ["TRACE", "HIGH"],
        "is_trap": true,
        "trap_explanation": "TRACE doit √™tre d√©tect√© comme dangereux"
      },
      {
        "name": "missing_csp",
        "args": ["{\"raw_request\": \"GET / HTTP/1.1\\r\\n\\r\\n\", \"raw_response\": \"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"expected_security_headers\": [\"Content-Security-Policy\"]}"],
        "expected_contains": ["Content-Security-Policy"],
        "is_trap": true,
        "trap_explanation": "Header CSP manquant doit √™tre signal√©"
      },
      {
        "name": "case_insensitive_headers",
        "args": ["{\"raw_request\": \"GET / HTTP/1.1\\r\\nCONTENT-TYPE: text/html\\r\\n\\r\\n\", \"raw_response\": \"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"expected_security_headers\": []}"],
        "expected_contains": ["content-type"],
        "is_trap": true,
        "trap_explanation": "Headers doivent √™tre normalis√©s en lowercase"
      },
      {
        "name": "server_version_disclosure",
        "args": ["{\"raw_request\": \"GET / HTTP/1.1\\r\\n\\r\\n\", \"raw_response\": \"HTTP/1.1 200 OK\\r\\nServer: Apache/2.4.49\\r\\n\\r\\n\", \"expected_security_headers\": []}"],
        "expected_contains": ["Server version disclosure"],
        "is_trap": true,
        "trap_explanation": "Divulgation de version doit √™tre d√©tect√©e"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "string",
          "param_index": 0,
          "params": {
            "min_len": 10,
            "max_len": 5000,
            "charset": "printable"
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json::from_str", "serde_json::to_string", "HashMap::new", "Vec::new"],
    "forbidden_functions": ["reqwest::get", "hyper::Client", "std::net::TcpStream"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```rust
// ============ MUTANT A (Boundary) ============
// Description: Off-by-one dans le split des headers/body
pub fn parse_http_request_mutant_a(raw: &str) -> ParsedRequest {
    let mut result = ParsedRequest::default();
    let normalized = raw.replace("\r\n", "\n");

    // ERREUR: Utilise split au lieu de splitn(2, ...)
    // Cela va cr√©er plus de 2 parties si le body contient \n\n
    let parts: Vec<&str> = normalized.split("\n\n").collect();

    // Le reste du parsing...
    // BUG: Si le body contient "\n\n", il sera tronqu√©
    if let Some(body) = parts.get(1) {
        result.body = Some(body.to_string());
        // Parties 2+ ignor√©es = body incomplet
    }

    result
}
// Pourquoi c'est faux: Le body peut contenir des lignes vides
// Ce qui √©tait pens√©: "\n\n" n'appara√Æt qu'une seule fois entre headers et body

// ============ MUTANT B (Safety) ============
// Description: Pas de validation de l'input JSON
pub fn protocol_dissector_mutant_b(input_json: &str) -> String {
    // ERREUR: unwrap() sans gestion d'erreur
    let input: DissectorInput = serde_json::from_str(input_json).unwrap();

    let parsed_request = parse_http_request(&input.raw_request);
    let parsed_response = parse_http_response(&input.raw_response);

    // ... reste du code
    "{}".to_string()
}
// Pourquoi c'est faux: Panic si le JSON est invalide
// Ce qui √©tait pens√©: L'input sera toujours du JSON valide

// ============ MUTANT C (Resource) ============
// Description: Allocation excessive pour chaque header
pub fn parse_http_request_mutant_c(raw: &str) -> ParsedRequest {
    let mut result = ParsedRequest::default();

    for line in raw.lines() {
        // ERREUR: Cr√©e une nouvelle String pour chaque comparaison
        // au lieu de r√©utiliser la m√™me variable
        let _temp1 = line.to_lowercase();
        let _temp2 = line.to_uppercase();
        let _temp3 = line.trim().to_string();

        // Allocation inutile x3 pour chaque ligne
        if let Some(pos) = line.find(':') {
            result.headers.insert(
                line[..pos].to_string().to_lowercase(),  // Double allocation
                line[pos+1..].to_string().trim().to_string()  // Triple allocation
            );
        }
    }

    result
}
// Pourquoi c'est faux: Consommation m√©moire O(n*k) au lieu de O(n)
// Ce qui √©tait pens√©: "to_string() est gratuit"

// ============ MUTANT D (Logic) ============
// Description: Logique invers√©e pour les m√©thodes dangereuses
pub fn is_dangerous_method_mutant_d(method: &str) -> bool {
    // ERREUR: Logique invers√©e - retourne true pour les m√©thodes SAFE
    !matches!(method.to_uppercase().as_str(), "TRACE" | "TRACK" | "DEBUG")
}
// Pourquoi c'est faux: GET, POST, etc. seraient consid√©r√©s comme dangereux
// Ce qui √©tait pens√©: Confusion entre "est dangereux" et "n'est pas dangereux"

// ============ MUTANT E (Return) ============
// Description: Retourne toujours le m√™me score
pub fn analyze_security_mutant_e(
    _request: &ParsedRequest,
    _response: &ParsedResponse,
    _expected_headers: &[String],
) -> SecurityAnalysis {
    // ERREUR: Ignore compl√®tement l'analyse et retourne un score fixe
    SecurityAnalysis {
        issues: Vec::new(),
        missing_headers: Vec::new(),
        score: 75,  // Score arbitraire
        recommendations: Vec::new(),
    }
}
// Pourquoi c'est faux: Le score ne refl√®te pas la vraie posture de s√©curit√©
// Ce qui √©tait pens√©: "75 est une bonne moyenne par d√©faut"

// ============ MUTANT F (Edge Case) ============
// Description: Ne g√®re pas les headers vides
pub fn parse_http_response_mutant_f(raw: &str) -> ParsedResponse {
    let mut result = ParsedResponse::default();

    for line in raw.lines().skip(1) {
        if let Some(pos) = line.find(':') {
            let value = &line[pos+1..];
            // ERREUR: Ne v√©rifie pas si la valeur est vide
            result.headers.insert(
                line[..pos].to_lowercase(),
                value.trim().to_string()  // Peut √™tre "" mais on l'ins√®re quand m√™me
            );
        }
        // ERREUR: Pas de gestion du cas o√π find(':') retourne None
        // pour une ligne non-header non-vide
    }

    result.is_valid = true;  // ERREUR: Toujours true m√™me si parsing √©choue
    result
}
// Pourquoi c'est faux: Headers vides ou lignes mal form√©es non g√©r√©es
// Ce qui √©tait pens√©: Toutes les lignes apr√®s la status line sont des headers valides
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne les concepts fondamentaux du protocole HTTP et son analyse de s√©curit√© :

1. **Structure des messages HTTP** : Request-Line/Status-Line, Headers, Body
2. **Parsing robuste** : Gestion des erreurs, cas limites, formats vari√©s
3. **S√©curit√© HTTP** : Headers de protection, divulgation d'information, m√©thodes dangereuses
4. **Bonnes pratiques** : Case-insensitivity, validation d'entr√©e, scoring objectif

### 5.2 LDA ‚Äî Traduction litt√©rale en fran√ßais (MAJUSCULES)

```
FONCTION protocol_dissector QUI RETOURNE UNE CHA√éNE ET PREND EN PARAM√àTRE input_json QUI EST UNE R√âF√âRENCE VERS UNE CHA√éNE
D√âBUT FONCTION
    D√âCLARER input COMME R√âSULTAT DU PARSING JSON DE input_json

    SI input EST UNE ERREUR ALORS
        RETOURNER UNE CHA√éNE JSON CONTENANT L'ERREUR
    FIN SI

    D√âCLARER parsed_request COMME R√âSULTAT DE parse_http_request APPLIQU√â √Ä raw_request DE input
    D√âCLARER parsed_response COMME R√âSULTAT DE parse_http_response APPLIQU√â √Ä raw_response DE input
    D√âCLARER analysis COMME R√âSULTAT DE analyze_security APPLIQU√â √Ä parsed_request ET parsed_response ET expected_security_headers

    CONSTRUIRE output AVEC parsed_request ET parsed_response ET analysis

    RETOURNER output S√âRIALIS√â EN JSON
FIN FONCTION

FONCTION parse_http_request QUI RETOURNE UNE STRUCTURE ParsedRequest ET PREND EN PARAM√àTRE raw QUI EST UNE R√âF√âRENCE VERS UNE CHA√éNE
D√âBUT FONCTION
    D√âCLARER result COMME ParsedRequest PAR D√âFAUT

    NORMALISER LES FINS DE LIGNE EN REMPLA√áANT \r\n PAR \n

    S√âPARER LE TEXTE EN DEUX PARTIES AU PREMIER \n\n
    D√âCLARER header_section COMME PREMI√àRE PARTIE
    D√âCLARER body_section COMME DEUXI√àME PARTIE

    S√âPARER header_section EN LIGNES

    SI AUCUNE LIGNE ALORS
        AJOUTER "Empty request" AUX ERREURS DE PARSING
        RETOURNER result
    FIN SI

    S√âPARER LA PREMI√àRE LIGNE PAR LES ESPACES
    SI MOINS DE 3 PARTIES ALORS
        AJOUTER "Invalid request line format" AUX ERREURS
        RETOURNER result
    FIN SI

    AFFECTER PARTIE 1 √Ä method DE result
    AFFECTER PARTIE 2 √Ä path DE result
    AFFECTER PARTIE 3 SANS "HTTP/" √Ä http_version DE result

    POUR CHAQUE LIGNE RESTANTE FAIRE
        SI LIGNE COMMENCE PAR ESPACE OU TABULATION ALORS
            AJOUTER AU DERNIER HEADER (CONTINUATION)
        SINON SI LIGNE CONTIENT ':' ALORS
            EXTRAIRE NOM ET VALEUR
            NORMALISER NOM EN MINUSCULES
            INS√âRER DANS headers DE result
        FIN SI
    FIN POUR

    SI body_section N'EST PAS VIDE ALORS
        AFFECTER body_section √Ä body DE result
    FIN SI

    AFFECTER VRAI √Ä is_valid SI AUCUNE ERREUR
    RETOURNER result
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Analyse de s√©curit√© HTTP
---
1. RECEVOIR les donn√©es brutes (requ√™te + r√©ponse HTTP)

2. PARSER LA REQU√äTE :
   a. Normaliser les fins de ligne (CRLF ‚Üí LF)
   b. S√©parer headers et body au premier double-saut de ligne
   c. Extraire METHOD, PATH, VERSION de la premi√®re ligne
   d. Pour chaque ligne suivante :
      - SI continuation (commence par espace) ‚Üí concat√©ner au header pr√©c√©dent
      - SINON ‚Üí parser comme "Name: Value", normaliser le nom
   e. Marquer comme valide ou invalide

3. PARSER LA R√âPONSE :
   a. M√™me logique de normalisation
   b. Extraire VERSION, STATUS_CODE, STATUS_TEXT
   c. Parser les headers de la m√™me fa√ßon

4. ANALYSER LA S√âCURIT√â :
   a. V√©rifier les m√©thodes dangereuses (TRACE, TRACK)
   b. D√©tecter les divulgations de version (Server, X-Powered-By)
   c. V√©rifier les headers de s√©curit√© attendus
   d. Calculer le score (100 - p√©nalit√©s)
   e. G√©n√©rer les recommandations

5. RETOURNER le rapport JSON
```

### 5.2.3 Repr√©sentation algorithmique (Logique de Garde)

```
FONCTION : parse_http_request(raw)
---
INIT result = ParsedRequest::default()

1. V√âRIFIER si raw est vide :
   |
   |-- SI vide :
   |     AJOUTER erreur "Empty request"
   |     RETOURNER result (invalide)

2. NORMALISER et S√âPARER :
   |
   |-- Remplacer \r\n par \n
   |-- S√©parer au premier \n\n
   |     - header_section = partie 1
   |     - body_section = partie 2 (ou None)

3. PARSER REQUEST LINE :
   |
   |-- V√âRIFIER au moins 3 parties s√©par√©es par espace :
   |     SI NON ‚Üí RETOURNER erreur "Invalid request line"
   |
   |-- EXTRAIRE : method, path, version
   |-- VALIDER version (1.0, 1.1, 2, 3)

4. PARSER HEADERS (boucle) :
   |
   |-- POUR chaque ligne apr√®s la premi√®re :
   |     |
   |     |-- SI commence par espace/tab ‚Üí CONTINUATION
   |     |-- SI contient ':' ‚Üí NOUVEAU HEADER
   |     |     - Normaliser nom (lowercase)
   |     |     - Trim valeur
   |     |-- SINON ‚Üí IGNORER (ligne vide ou invalide)

5. RETOURNER result avec is_valid = (pas d'erreurs)
```

### 5.2.3.1 Diagramme Mermaid

```mermaid
graph TD
    A[D√©but: protocol_dissector] --> B{JSON valide ?}
    B -- Non --> C[RETOUR: Erreur JSON]
    B -- Oui --> D[Parse requ√™te HTTP]

    D --> E{Request line valide ?}
    E -- Non --> F[Marquer is_valid=false]
    E -- Oui --> G[Extraire method, path, version]

    G --> H[Parser headers]
    H --> I{Header continuation ?}
    I -- Oui --> J[Append au pr√©c√©dent]
    I -- Non --> K[Nouveau header lowercase]
    J --> H
    K --> H

    H --> L[Parse r√©ponse HTTP]
    L --> M[Analyser s√©curit√©]

    M --> N{TRACE/TRACK method ?}
    N -- Oui --> O[Issue HIGH]
    N -- Non --> P{Server version expos√©e ?}

    P -- Oui --> Q[Issue MEDIUM]
    P -- Non --> R{Headers s√©curit√© manquants ?}

    R -- Oui --> S[Ajouter aux missing]
    R -- Non --> T[Calculer score]

    O --> T
    Q --> T
    S --> T

    T --> U[G√©n√©rer recommandations]
    U --> V[RETOUR: JSON output]
    F --> V
```

### 5.3 Visualisation ASCII

```
                    REQU√äTE HTTP
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  GET /admin HTTP/1.1\r\n                    ‚îÇ ‚Üê Request Line
    ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                      ‚îÇ
    ‚îÇ  Host: example.com\r\n                      ‚îÇ ‚Üê Header
    ‚îÇ  User-Agent: Mozilla/5.0\r\n                ‚îÇ ‚Üê Header
    ‚îÇ  Accept: text/html\r\n                      ‚îÇ ‚Üê Header
    ‚îÇ  \r\n                                       ‚îÇ ‚Üê Ligne vide (s√©parateur)
    ‚îÇ  {"data": "body content"}                   ‚îÇ ‚Üê Body (optionnel)
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                    R√âPONSE HTTP
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  HTTP/1.1 200 OK\r\n                        ‚îÇ ‚Üê Status Line
    ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                          ‚îÇ
    ‚îÇ  Server: Apache/2.4.1\r\n                   ‚îÇ ‚Üê Header (DANGER!)
    ‚îÇ  Content-Type: text/html\r\n                ‚îÇ ‚Üê Header
    ‚îÇ  Content-Security-Policy: default-src 'self'‚îÇ ‚Üê Security Header ‚úì
    ‚îÇ  X-Frame-Options: DENY\r\n                  ‚îÇ ‚Üê Security Header ‚úì
    ‚îÇ  \r\n                                       ‚îÇ ‚Üê S√©parateur
    ‚îÇ  <html>...</html>                           ‚îÇ ‚Üê Body
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    ANALYSE DE S√âCURIT√â
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  ‚ö†Ô∏è  Server version disclosure              ‚îÇ
    ‚îÇ  ‚úì  CSP header present                      ‚îÇ
    ‚îÇ  ‚úì  X-Frame-Options present                 ‚îÇ
    ‚îÇ  ‚ùå  HSTS missing                           ‚îÇ
    ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                      ‚îÇ
    ‚îÇ  Score: 75/100                              ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.4 Les pi√®ges en d√©tail

| Pi√®ge | Description | Cons√©quence | Solution |
|-------|-------------|-------------|----------|
| **Case sensitivity** | Headers sont case-insensitive | `Content-Type` ‚â† `content-type` si non normalis√© | Toujours convertir en lowercase |
| **Line endings** | Windows: `\r\n`, Unix: `\n` | Parsing incorrect si hardcod√© | Normaliser avant parsing |
| **Header continuation** | Ligne commen√ßant par espace = suite | Header tronqu√© | D√©tecter et concat√©ner |
| **Empty body** | Pas de body apr√®s `\r\n\r\n` | `body = Some("")` vs `None` | V√©rifier si vraiment vide |
| **Malformed input** | Requ√™te invalide | Panic sur unwrap | Toujours valider et retourner erreur |

### 5.5 Cours Complet

#### 5.5.1 Structure d'un message HTTP

Le protocole HTTP (RFC 7230-7235) d√©finit deux types de messages :

**Requ√™te HTTP :**
```
Request-Line = Method SP Request-URI SP HTTP-Version CRLF
*(Header-Field CRLF)
CRLF
[Message-Body]
```

**R√©ponse HTTP :**
```
Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
*(Header-Field CRLF)
CRLF
[Message-Body]
```

#### 5.5.2 Les m√©thodes HTTP et leur s√©curit√©

| M√©thode | Safe | Idempotent | Cacheable | Risque s√©curit√© |
|---------|------|------------|-----------|-----------------|
| GET | ‚úì | ‚úì | ‚úì | Faible |
| HEAD | ‚úì | ‚úì | ‚úì | Faible |
| POST | ‚úó | ‚úó | Conditionnel | Moyen |
| PUT | ‚úó | ‚úì | ‚úó | Moyen |
| DELETE | ‚úó | ‚úì | ‚úó | √âlev√© |
| TRACE | ‚úì | ‚úì | ‚úó | **CRITIQUE** (XST) |
| OPTIONS | ‚úì | ‚úì | ‚úó | Faible (info leak) |
| CONNECT | ‚úó | ‚úó | ‚úó | √âlev√© (proxy) |
| PATCH | ‚úó | ‚úó | ‚úó | Moyen |

#### 5.5.3 Headers de s√©curit√© essentiels

```
Content-Security-Policy: default-src 'self'
    ‚Üí Pr√©vient XSS en contr√¥lant les sources de contenu

X-Frame-Options: DENY | SAMEORIGIN
    ‚Üí Pr√©vient le clickjacking

X-Content-Type-Options: nosniff
    ‚Üí Emp√™che le MIME sniffing

Strict-Transport-Security: max-age=31536000; includeSubDomains
    ‚Üí Force HTTPS

Referrer-Policy: strict-origin-when-cross-origin
    ‚Üí Contr√¥le les informations Referer

Permissions-Policy: geolocation=(), microphone=()
    ‚Üí D√©sactive les APIs sensibles
```

#### 5.5.4 HTTP/1.1 vs HTTP/2 vs HTTP/3

| Aspect | HTTP/1.1 | HTTP/2 | HTTP/3 |
|--------|----------|--------|--------|
| Format | Textuel | Binaire | Binaire |
| Transport | TCP | TCP | QUIC (UDP) |
| Multiplexing | Non | Oui | Oui |
| Server Push | Non | Oui | Oui |
| Header Compression | Non | HPACK | QPACK |
| Head-of-line blocking | Oui | Partiel | Non |

### 5.6 Normes avec explications p√©dagogiques

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (compile, mais probl√®me de s√©curit√©)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ let input: Input = serde_json::from_str(json).unwrap();         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ let input: Input = match serde_json::from_str(json) {           ‚îÇ
‚îÇ     Ok(i) => i,                                                 ‚îÇ
‚îÇ     Err(e) => return format!(r#"{{"error": "{}"}}"#, e),       ‚îÇ
‚îÇ };                                                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ unwrap() panic sur erreur = crash de l'application           ‚îÇ
‚îÇ ‚Ä¢ Un attaquant peut envoyer du JSON malform√©                    ‚îÇ
‚îÇ ‚Ä¢ Gestion propre = r√©ponse d'erreur au lieu de crash            ‚îÇ
‚îÇ ‚Ä¢ Rust encourage la gestion explicite des erreurs               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'ex√©cution

**Input :**
```json
{
  "raw_request": "TRACE /test HTTP/1.1\r\nHost: evil.com\r\n\r\n",
  "raw_response": "HTTP/1.1 200 OK\r\nServer: Apache/2.4.1\r\n\r\n",
  "expected_security_headers": ["Content-Security-Policy"]
}
```

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape ‚îÇ Instruction                                  ‚îÇ √âtat                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ Parse JSON input                             ‚îÇ input = DissectorInput  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2   ‚îÇ parse_http_request()                         ‚îÇ method="TRACE"          ‚îÇ
‚îÇ       ‚îÇ                                              ‚îÇ path="/test"            ‚îÇ
‚îÇ       ‚îÇ                                              ‚îÇ version="1.1"           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3   ‚îÇ parse_http_response()                        ‚îÇ status=200              ‚îÇ
‚îÇ       ‚îÇ                                              ‚îÇ server="Apache/2.4.1"   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ is_dangerous_method("TRACE") ?               ‚îÇ TRUE ‚Üí Issue HIGH       ‚îÇ
‚îÇ       ‚îÇ                                              ‚îÇ penalty += 25           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ Server header contient '/' ?                 ‚îÇ TRUE ‚Üí Issue MEDIUM     ‚îÇ
‚îÇ       ‚îÇ                                              ‚îÇ penalty += 10           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   6   ‚îÇ CSP dans response.headers ?                  ‚îÇ FALSE ‚Üí missing_headers ‚îÇ
‚îÇ       ‚îÇ                                              ‚îÇ penalty += 15           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7   ‚îÇ score = 100 - 50                             ‚îÇ score = 50              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   8   ‚îÇ S√©rialiser output en JSON                    ‚îÇ RETOUR: JSON            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üé¨ MEME : "Mr. Robot - Trust No One"

Comme Elliot qui ne fait confiance √† personne, ton parser ne doit faire confiance √† **aucune entr√©e**.

```rust
// üé≠ Elliot valide TOUT
fn parse_input(raw: &str) -> Result<Data, Error> {
    if raw.is_empty() {
        return Err("fsociety n'accepte pas les entr√©es vides");
    }
    // Valider avant de traiter
}
```

#### üîí MEME : "The Headers Must Be LOWERCASE"

Comme le mantra de Fight Club "The first rule of Fight Club is...", la premi√®re r√®gle du HTTP est :

**"The first rule of HTTP headers is: they are CASE-INSENSITIVE"**

```rust
// Ne jamais comparer directement
if header == "Content-Type" { }  // ‚ùå FAIL

// Toujours normaliser
if header.to_lowercase() == "content-type" { }  // ‚úì CORRECT
```

#### üíÄ MEME : "TRACE is sus" (Among Us)

La m√©thode TRACE est **sus** (suspecte). Si tu la vois, c'est un imposteur dans ton serveur web qui peut √™tre exploit√© pour du Cross-Site Tracing (XST).

```
TRACE enabled = üî¥ RED FLAG = EJECT from your server config
```

### 5.9 Applications pratiques

| Contexte | Application |
|----------|-------------|
| **Pentest Web** | Scanner les headers de s√©curit√© manquants sur les assets du client |
| **Bug Bounty** | Identifier les quick wins (Server version, missing CSP) |
| **CI/CD Security** | V√©rifier automatiquement les headers avant d√©ploiement |
| **SOC/SIEM** | Parser les logs HTTP pour d√©tecter les requ√™tes malveillantes |
| **Reverse Proxy** | Inspecter et modifier les headers en transit |

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | D√©tection | Solution |
|---|-------|-----------|----------|
| 1 | Headers case-sensitive | Test avec "CONTENT-TYPE" vs "content-type" | `to_lowercase()` syst√©matique |
| 2 | Line endings mixtes | Test avec `\r\n` et `\n` | Normaliser avant parsing |
| 3 | unwrap() sur JSON | Fuzzing avec JSON invalide | Match ou `?` operator |
| 4 | Body avec `\n\n` | Body contenant double newline | `splitn(2, ...)` pas `split()` |
| 5 | Header continuation | Header multi-ligne | D√©tecter ligne commen√ßant par espace |
| 6 | TRACE non d√©tect√© | Requ√™te TRACE pass√©e | Check `is_dangerous_method()` |
| 7 | Score toujours 100 | R√©ponse sans headers s√©curit√© | Vraie analyse avec p√©nalit√©s |

---

## üìù SECTION 7 : QCM

### Question 1
**Quelle est la structure correcte d'une Request-Line HTTP/1.1 ?**

- A) `HTTP/1.1 GET /path`
- B) `GET /path HTTP/1.1`
- C) `/path GET HTTP/1.1`
- D) `GET HTTP/1.1 /path`
- E) `HTTP/1.1 /path GET`
- F) `METHOD URI VERSION` (g√©n√©rique)
- G) `VERSION METHOD URI`
- H) `URI METHOD VERSION`
- I) Aucune structure d√©finie
- J) D√©pend du serveur

**R√©ponse : B**

---

### Question 2
**Les headers HTTP sont :**

- A) Case-sensitive (majuscules/minuscules comptent)
- B) Case-insensitive (majuscules/minuscules ignor√©es)
- C) Case-sensitive pour les noms, insensitive pour les valeurs
- D) Case-insensitive pour les noms, sensitive pour les valeurs
- E) D√©pend du header sp√©cifique
- F) Toujours en majuscules
- G) Toujours en minuscules
- H) CamelCase obligatoire
- I) D√©fini par le serveur
- J) D√©fini par le client

**R√©ponse : D**

---

### Question 3
**Pourquoi la m√©thode TRACE est-elle consid√©r√©e comme dangereuse ?**

- A) Elle permet de supprimer des fichiers
- B) Elle permet des attaques Cross-Site Tracing (XST)
- C) Elle consomme trop de bande passante
- D) Elle n'est pas standardis√©e
- E) Elle permet l'injection SQL
- F) Elle expose les credentials en clair
- G) Elle contourne HTTPS
- H) Elle est obsol√®te depuis HTTP/2
- I) Elle permet le DoS
- J) Elle n'est jamais dangereuse

**R√©ponse : B**

---

### Question 4
**Quel header emp√™che les attaques de clickjacking ?**

- A) Content-Security-Policy
- B) X-XSS-Protection
- C) X-Frame-Options
- D) Strict-Transport-Security
- E) X-Content-Type-Options
- F) Referrer-Policy
- G) Access-Control-Allow-Origin
- H) Cache-Control
- I) Content-Type
- J) Authorization

**R√©ponse : C**

---

### Question 5
**Comment est s√©par√© le body des headers dans HTTP ?**

- A) Par un seul `\n`
- B) Par un seul `\r\n`
- C) Par `\n\n` (double newline)
- D) Par `\r\n\r\n` (double CRLF)
- E) Par une ligne contenant "BODY:"
- F) Par le header Content-Length
- G) Par le header Content-Type
- H) Pas de s√©paration d√©finie
- I) Par un caract√®re NULL
- J) Par un `;`

**R√©ponse : D (ou C apr√®s normalisation)**

---

### Question 6
**Quel est le risque de la divulgation de version serveur ?**

- A) Performance d√©grad√©e
- B) Permet d'identifier des CVE sp√©cifiques √† la version
- C) Violation de copyright
- D) Aucun risque
- E) Incompatibilit√© navigateur
- F) Probl√®mes de cache
- G) Session hijacking direct
- H) Corruption de donn√©es
- I) D√©ni de service
- J) Injection de code

**R√©ponse : B**

---

### Question 7
**Qu'est-ce qu'un header continuation en HTTP/1.1 ?**

- A) Un header qui continue sur la ligne suivante commen√ßant par espace/tab
- B) Un header qui se r√©p√®te plusieurs fois
- C) Un header avec une valeur tr√®s longue
- D) Un header de type Keep-Alive
- E) Un header Transfer-Encoding: chunked
- F) Un header qui persiste entre requ√™tes
- G) Un header c√¥t√© client uniquement
- H) Un header c√¥t√© serveur uniquement
- I) Une extension propri√©taire
- J) N'existe pas en HTTP

**R√©ponse : A**

---

### Question 8
**Quelle diff√©rence majeure entre HTTP/1.1 et HTTP/2 ?**

- A) HTTP/2 n'a pas de headers
- B) HTTP/2 est textuel, HTTP/1.1 binaire
- C) HTTP/2 est binaire avec multiplexing
- D) HTTP/2 ne supporte pas HTTPS
- E) HTTP/2 utilise UDP
- F) HTTP/2 n'a pas de status codes
- G) HTTP/2 interdit les cookies
- H) Aucune diff√©rence significative
- I) HTTP/2 est plus lent
- J) HTTP/2 est d√©pr√©ci√©

**R√©ponse : C**

---

### Question 9
**Que signifie le CWE-693 souvent associ√© aux headers de s√©curit√© manquants ?**

- A) Cross-Site Scripting
- B) SQL Injection
- C) Protection Mechanism Failure
- D) Buffer Overflow
- E) Path Traversal
- F) Race Condition
- G) Integer Overflow
- H) Use After Free
- I) Null Pointer Dereference
- J) Information Exposure

**R√©ponse : C**

---

### Question 10
**Pourquoi normaliser les headers en lowercase ?**

- A) Pour √©conomiser de la m√©moire
- B) Pour respecter la case-insensitivity de HTTP
- C) Pour am√©liorer la performance
- D) Parce que HTTP/2 l'exige
- E) Pour la compatibilit√© Windows
- F) Pour √©viter les collisions de hash
- G) Ce n'est pas n√©cessaire
- H) Pour des raisons esth√©tiques
- I) Pour le tri alphab√©tique
- J) Pour la compression

**R√©ponse : B**

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| **Concepts ma√Ætris√©s** | HTTP Protocol, Security Headers, Parsing |
| **Fonctions cl√©s** | `parse_http_request`, `parse_http_response`, `analyze_security` |
| **Patterns appris** | Normalisation, Validation, Scoring |
| **Erreurs √©vit√©es** | Case-sensitivity, Panic sur erreur, Body tronqu√© |
| **Applications** | Pentest, Bug Bounty, CI/CD Security |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.1-a-protocol_dissector",
    "generated_at": "2026-01-11",

    "metadata": {
      "exercise_id": "3.3.1-a",
      "exercise_name": "protocol_dissector",
      "module": "3.3.1",
      "module_name": "Architecture Web Moderne",
      "concept": "a",
      "concept_name": "HTTP Protocol",
      "type": "complet",
      "tier": 2,
      "tier_info": "M√©lange (concepts a + s√©curit√© headers)",
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 350,
      "xp_bonus_multiplier": 2,
      "bonus_tier": "STANDARD",
      "bonus_icon": "‚ö°",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["Bases Rust", "JSON parsing", "Regex"],
      "domains": ["Net", "Crypto", "Encodage"],
      "tags": ["http", "parsing", "security", "headers"],
      "meme_reference": "Mr. Robot"
    },

    "files": {
      "spec.json": "/* Contenu section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "alternatives/alt_regex.rs": "/* Section 4.4 - Alternative 1 */",
      "alternatives/alt_state_machine.rs": "/* Section 4.4 - Alternative 2 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "mutants/mutant_f_edge.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_regex.rs",
        "alternatives/alt_state_machine.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs",
        "mutants/mutant_f_edge.rs"
      ]
    },

    "commands": {
      "compile": "rustc --edition 2024 protocol_dissector.rs main.rs -o test",
      "run_tests": "./test",
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_solution.rs",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.rs -s spec.json --validate"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 ‚Äî Module 3.3.1-a ‚Äî Protocol Dissector*
*"Trust no input. Validate everything."*
