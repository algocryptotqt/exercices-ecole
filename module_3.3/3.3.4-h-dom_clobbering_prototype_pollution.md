# Exercice 3.3.4-h : dom_clobbering_prototype_pollution

**Module :**
3.3.4 â€” Cross-Site Scripting AvancÃ©

**Concept :**
h â€” DOM Clobbering & Prototype Pollution

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
code

**Tiers :**
2 â€” MÃ©lange (concepts h + 3.3.8.e + 3.3.8.f)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 3.3.4.a : XSS Payload Craftsman
- JavaScript Object model
- Prototype chain basics

**Domaines :**
Net, Struct, Encodage

**DurÃ©e estimÃ©e :**
240 min (4h)

**XP Base :**
450

**ComplexitÃ© :**
T3 O(nÃ—m) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`dom_clobbering_prototype_pollution.rs`

**Fonctions autorisÃ©es :**
- `serde_json` : parsing JSON
- `regex` : pattern matching
- `std::collections::{HashMap, HashSet}`

**Fonctions interdites :**
- ExÃ©cution JavaScript rÃ©elle
- `unsafe` blocks

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Inception : Going Deeper Into the Object"

*"We need to go deeper."* â€” Cobb

Dans Inception, Cobb et son Ã©quipe plantent des idÃ©es dans les rÃªves, niveau aprÃ¨s niveau. En **Prototype Pollution**, tu plantes des propriÃ©tÃ©s dans la chaÃ®ne prototype, niveau aprÃ¨s niveau, jusqu'Ã  atteindre le "limbo" : l'exÃ©cution de code.

**Le DOM est le rÃªve.**
**L'Object.prototype est le subconscient partagÃ©.**
**Ta pollution est l'idÃ©e qui se propage.**

Comme l'inception d'une idÃ©e qui devient rÃ©alitÃ© pour la victime, une propriÃ©tÃ© polluÃ©e sur `__proto__` devient rÃ©alitÃ© pour TOUS les objets.

**Ta mission :**

Ã‰crire une fonction `dom_clobbering_prototype_pollution` qui analyse du code JavaScript vulnÃ©rable et gÃ©nÃ¨re des exploits pour DOM Clobbering et Prototype Pollution.

**EntrÃ©e :**
- `input_json` : chaÃ®ne JSON contenant :
  - `javascript_code` : code JS Ã  analyser
  - `html_context` : HTML environnant
  - `allowed_html_injection` : bool, si on peut injecter du HTML
  - `postmessage_handler` : code du handler postMessage (optionnel)

**Sortie :**
- JSON avec :
  - `vulnerabilities[]` : liste des vulnÃ©rabilitÃ©s (type, sink, payload, impact)
  - `exploit_chain` : description de la chaÃ®ne d'exploitation
  - `remediation` : corrections recommandÃ©es

**Exemples :**

| VulnÃ©rabilitÃ© | Sink | Payload |
|---------------|------|---------|
| Prototype Pollution | `Object.assign(config, data)` | `{"__proto__": {"admin": true}}` |
| DOM Clobbering | `window.config` | `<form id=config><input name=debug>` |
| PostMessage | `window.onmessage` | `postMessage(payload, '*')` |

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

pub fn dom_clobbering_prototype_pollution(input_json: &str) -> String

#[derive(Debug, Deserialize)]
pub struct DomChallenge {
    pub javascript_code: String,
    pub html_context: String,
    #[serde(default)]
    pub allowed_html_injection: bool,
    #[serde(default)]
    pub postmessage_handler: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct DomAnalysisResult {
    pub vulnerabilities: Vec<Vulnerability>,
    pub exploit_chain: String,
    pub remediation: Remediation,
}

#[derive(Debug, Serialize)]
pub struct Vulnerability {
    pub vuln_type: String,
    pub sink: String,
    pub payload: serde_json::Value,
    pub impact: String,
    pub confidence: String,
}

#[derive(Debug, Serialize)]
pub struct Remediation {
    pub prototype_pollution: String,
    pub dom_clobbering: String,
    pub postmessage: String,
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Prototype Pollution en Production

| AnnÃ©e | CVE | BibliothÃ¨que | Impact |
|-------|-----|--------------|--------|
| 2018 | CVE-2018-16487 | lodash | RCE via merge |
| 2019 | CVE-2019-10744 | lodash | RCE via defaultsDeep |
| 2020 | CVE-2020-7598 | minimist | Pollution via args |
| 2021 | CVE-2021-25928 | jspdf | Pollution via config |

### 2.2 DOM Clobbering Patterns

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DOM CLOBBERING : Comment le DOM "Ã©crase" les variables         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  <img id="x">                                                   â”‚
â”‚      â†“                                                          â”‚
â”‚  window.x === <img> (l'Ã©lÃ©ment DOM)                             â”‚
â”‚                                                                 â”‚
â”‚  <form id="config">                                             â”‚
â”‚    <input name="debug" value="true">                            â”‚
â”‚  </form>                                                        â”‚
â”‚      â†“                                                          â”‚
â”‚  window.config.debug === <input> (HTMLInputElement)             â”‚
â”‚  window.config.debug.value === "true"                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 ChaÃ®ne Prototype JavaScript

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Object.prototype   â”‚ â† Pollution ici
                    â”‚  (__proto__ = null) â”‚   affecte TOUT
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                    â”‚                    â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
    â”‚ config    â”‚        â”‚ user      â”‚       â”‚ settings  â”‚
    â”‚ {debug:?} â”‚        â”‚ {name:?}  â”‚       â”‚ {theme:?} â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Si __proto__.debug = true
    â†’ config.debug = true (hÃ©ritÃ©!)
    â†’ user.debug = true   (hÃ©ritÃ©!)
    â†’ settings.debug = true (hÃ©ritÃ©!)
```

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo run
=== Inception DOM Analysis v1.0 ===

[TEST 1] Prototype Pollution via Object.assign...
Sink: Object.assign(config, e.data)
Payload: {"__proto__": {"debug": true}}
Impact: XSS via eval(config.debugScript)
âœ“ VULNERABLE

[TEST 2] DOM Clobbering via form/input...
Clobberable: window.config
Payload: <form id=config><input name=debug value=true>
âœ“ VULNERABLE

[TEST 3] PostMessage origin bypass...
Handler: window.onmessage = (e) => {...}
Issue: No origin validation
âœ“ VULNERABLE

=== Results: 10/10 tests passed ===
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Detect Object.assign pollution | 15 |
| `T02` | Detect $.extend pollution | 10 |
| `T03` | Detect merge/deepMerge pollution | 10 |
| `T04` | DOM Clobbering via id | 10 |
| `T05` | DOM Clobbering via form/input | 15 |
| `T06` | PostMessage no origin check | 10 |
| `T07` | Exploit chain generation | 15 |
| `T08` | Remediation correcte | 10 |
| `T09` | NULL input | 5 |
| `T10` | No vulnerabilities | 10 |

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use regex::Regex;

#[derive(Debug, Deserialize)]
pub struct DomChallenge {
    pub javascript_code: String,
    pub html_context: String,
    #[serde(default)]
    pub allowed_html_injection: bool,
    #[serde(default)]
    pub postmessage_handler: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct DomAnalysisResult {
    pub vulnerabilities: Vec<Vulnerability>,
    pub exploit_chain: String,
    pub remediation: Remediation,
}

#[derive(Debug, Serialize)]
pub struct Vulnerability {
    pub vuln_type: String,
    pub sink: String,
    pub payload: serde_json::Value,
    pub impact: String,
    pub confidence: String,
}

#[derive(Debug, Serialize)]
pub struct Remediation {
    pub prototype_pollution: String,
    pub dom_clobbering: String,
    pub postmessage: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResult {
    pub error: String,
}

pub fn dom_clobbering_prototype_pollution(input_json: &str) -> String {
    if input_json.trim().is_empty() || input_json.trim() == "null" {
        return serde_json::to_string(&ErrorResult {
            error: "NULL_INPUT".to_string(),
        }).unwrap();
    }

    let challenge: DomChallenge = match serde_json::from_str(input_json) {
        Ok(c) => c,
        Err(e) => return serde_json::to_string(&ErrorResult {
            error: format!("PARSE_ERROR: {}", e),
        }).unwrap(),
    };

    let mut vulnerabilities = Vec::new();

    // Detect Prototype Pollution sinks
    vulnerabilities.extend(detect_prototype_pollution(&challenge.javascript_code));

    // Detect DOM Clobbering opportunities
    if challenge.allowed_html_injection {
        vulnerabilities.extend(detect_dom_clobbering(&challenge));
    }

    // Detect PostMessage vulnerabilities
    if let Some(ref handler) = challenge.postmessage_handler {
        vulnerabilities.extend(detect_postmessage_vuln(handler));
    }

    let exploit_chain = generate_exploit_chain(&vulnerabilities);
    let remediation = generate_remediation();

    let result = DomAnalysisResult {
        vulnerabilities,
        exploit_chain,
        remediation,
    };

    serde_json::to_string_pretty(&result).unwrap()
}

fn detect_prototype_pollution(code: &str) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();

    // Object.assign pattern
    let assign_re = Regex::new(r"Object\.assign\s*\(\s*(\w+)\s*,").unwrap();
    if let Some(caps) = assign_re.captures(code) {
        let target = caps.get(1).map(|m| m.as_str()).unwrap_or("unknown");
        vulns.push(Vulnerability {
            vuln_type: "PROTOTYPE_POLLUTION".to_string(),
            sink: format!("Object.assign({}, ...)", target),
            payload: serde_json::json!({"__proto__": {"polluted": true}}),
            impact: "Property injection on all objects".to_string(),
            confidence: "HIGH".to_string(),
        });
    }

    // $.extend / _.merge patterns
    let merge_patterns = [
        r"\$\.extend\s*\(",
        r"_\.merge\s*\(",
        r"_\.defaultsDeep\s*\(",
        r"deepMerge\s*\(",
    ];

    for pattern in merge_patterns {
        let re = Regex::new(pattern).unwrap();
        if re.is_match(code) {
            vulns.push(Vulnerability {
                vuln_type: "PROTOTYPE_POLLUTION".to_string(),
                sink: pattern.replace(r"\s*\(", "(").replace("\\", ""),
                payload: serde_json::json!({"__proto__": {"isAdmin": true}}),
                impact: "Deep property pollution".to_string(),
                confidence: "HIGH".to_string(),
            });
        }
    }

    // eval with config pattern - escalation to XSS
    if code.contains("eval(") && (code.contains("config") || code.contains("options")) {
        vulns.push(Vulnerability {
            vuln_type: "PROTOTYPE_POLLUTION_TO_XSS".to_string(),
            sink: "eval(config.*)".to_string(),
            payload: serde_json::json!({"__proto__": {"debugScript": "alert(document.domain)"}}),
            impact: "XSS via eval gadget".to_string(),
            confidence: "HIGH".to_string(),
        });
    }

    vulns
}

fn detect_dom_clobbering(challenge: &DomChallenge) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();

    // Find variable references that could be clobbered
    let var_re = Regex::new(r"(?:window\.)?(\w+)(?:\.(\w+))?").unwrap();

    // Common clobberable patterns in the JS code
    let clobberable_vars = ["config", "settings", "options", "data", "user", "admin"];

    for var in clobberable_vars {
        if challenge.javascript_code.contains(var) {
            // Check if there's a truthy check
            let truthy_check = challenge.javascript_code.contains(&format!("if ({}", var)) ||
                               challenge.javascript_code.contains(&format!("if({}", var));

            if truthy_check {
                vulns.push(Vulnerability {
                    vuln_type: "DOM_CLOBBERING".to_string(),
                    sink: format!("window.{}", var),
                    payload: serde_json::json!(format!("<a id={}>", var)),
                    impact: "Variable override via DOM element".to_string(),
                    confidence: "MEDIUM".to_string(),
                });
            }

            // Property access clobbering
            let prop_check = Regex::new(&format!(r"{}\.(\w+)", var)).unwrap();
            if let Some(caps) = prop_check.captures(&challenge.javascript_code) {
                let prop = caps.get(1).map(|m| m.as_str()).unwrap_or("unknown");
                vulns.push(Vulnerability {
                    vuln_type: "DOM_CLOBBERING".to_string(),
                    sink: format!("window.{}.{}", var, prop),
                    payload: serde_json::json!(format!("<form id={}><input name={} value=true>", var, prop)),
                    impact: format!("Property {} clobberable via form/input", prop),
                    confidence: "HIGH".to_string(),
                });
            }
        }
    }

    vulns
}

fn detect_postmessage_vuln(handler: &str) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();

    // Check for origin validation
    let has_origin_check = handler.contains("event.origin") ||
                           handler.contains("e.origin") ||
                           handler.contains(".origin ===") ||
                           handler.contains(".origin ==");

    if !has_origin_check {
        vulns.push(Vulnerability {
            vuln_type: "POSTMESSAGE_NO_ORIGIN_CHECK".to_string(),
            sink: "window.onmessage handler".to_string(),
            payload: serde_json::json!({"exploit": "attacker_iframe.contentWindow.postMessage(payload, '*')"}),
            impact: "Any origin can send messages".to_string(),
            confidence: "HIGH".to_string(),
        });
    }

    // Check for Object.assign in handler (pollution via postMessage)
    if handler.contains("Object.assign") {
        vulns.push(Vulnerability {
            vuln_type: "POSTMESSAGE_PROTOTYPE_POLLUTION".to_string(),
            sink: "Object.assign in postMessage handler".to_string(),
            payload: serde_json::json!({"__proto__": {"polluted": true}}),
            impact: "Prototype pollution via cross-origin message".to_string(),
            confidence: "HIGH".to_string(),
        });
    }

    vulns
}

fn generate_exploit_chain(vulnerabilities: &[Vulnerability]) -> String {
    if vulnerabilities.is_empty() {
        return "No vulnerabilities found".to_string();
    }

    let has_postmessage = vulnerabilities.iter().any(|v| v.vuln_type.contains("POSTMESSAGE"));
    let has_pollution = vulnerabilities.iter().any(|v| v.vuln_type.contains("PROTOTYPE_POLLUTION"));
    let has_xss_gadget = vulnerabilities.iter().any(|v| v.vuln_type.contains("XSS"));

    if has_postmessage && has_pollution && has_xss_gadget {
        return "1. Create attacker page with iframe â†’ 2. postMessage with __proto__ payload â†’ 3. Pollution triggers eval gadget â†’ 4. XSS execution".to_string();
    }

    if has_pollution && has_xss_gadget {
        return "1. Find JSON input point â†’ 2. Send __proto__ pollution payload â†’ 3. Trigger eval/Function gadget â†’ 4. XSS".to_string();
    }

    if has_postmessage {
        return "1. Create attacker page â†’ 2. Embed target in iframe â†’ 3. Send malicious postMessage â†’ 4. Exploit handler".to_string();
    }

    "Manual exploitation required based on specific vulnerability".to_string()
}

fn generate_remediation() -> Remediation {
    Remediation {
        prototype_pollution: "Use Object.create(null) for config objects, or validate keys against ['__proto__', 'constructor', 'prototype'] before merge".to_string(),
        dom_clobbering: "Use let/const declarations, check typeof before use, or use Map instead of plain objects".to_string(),
        postmessage: "Always validate event.origin against allowlist: if (event.origin !== 'https://trusted.com') return;".to_string(),
    }
}
```

### 4.10 Solutions Mutantes (6 minimum)

#### Mutant A (Boundary) : Ignore $.extend

```rust
fn detect_prototype_pollution_mutant_a(code: &str) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();
    // BUG: Only checks Object.assign, misses $.extend, _.merge
    if code.contains("Object.assign") {
        vulns.push(/* ... */);
    }
    vulns
}
// Faux: jQuery $.extend est aussi vulnÃ©rable
```

#### Mutant B (Safety) : Crash sur regex

```rust
fn detect_dom_clobbering_mutant_b(challenge: &DomChallenge) -> Vec<Vulnerability> {
    let re = Regex::new(&challenge.javascript_code).unwrap(); // BUG: user input as regex
    // Panic si le code contient des caractÃ¨res regex invalides
}
```

#### Mutant C (Logic) : Origin check inversÃ©

```rust
fn detect_postmessage_vuln_mutant_c(handler: &str) -> Vec<Vulnerability> {
    // BUG: Rapporte vulnÃ©rable quand origin IS checked
    if handler.contains("event.origin") {
        vulns.push(Vulnerability {
            vuln_type: "POSTMESSAGE_NO_ORIGIN_CHECK".into(),
            // ...
        });
    }
}
```

#### Mutant D (Return) : Toujours "No vulnerabilities"

```rust
fn generate_exploit_chain_mutant_d(_vulnerabilities: &[Vulnerability]) -> String {
    "No vulnerabilities found".to_string() // BUG: Ignore l'analyse
}
```

#### Mutant E (Edge) : Pas de dÃ©tection eval gadget

```rust
fn detect_prototype_pollution_mutant_e(code: &str) -> Vec<Vulnerability> {
    // BUG: Ne cherche pas les gadgets eval/Function
    // Manque la dÃ©tection PROTOTYPE_POLLUTION_TO_XSS
}
```

#### Mutant F (Resource) : Regex catastrophique

```rust
fn detect_dom_clobbering_mutant_f(challenge: &DomChallenge) -> Vec<Vulnerability> {
    // BUG: Regex avec backtracking catastrophique
    let re = Regex::new(r"(\w+\.)*(\w+)").unwrap();
    // O(2^n) sur certains inputs
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Description |
|---------|-------------|
| **Prototype Chain** | Comment JavaScript hÃ©rite via __proto__ |
| **DOM Clobbering** | Comment les Ã©lÃ©ments HTML Ã©crasent window.* |
| **PostMessage** | Dangers des messages cross-origin |
| **Gadget Chaining** | Combiner pollution + eval pour XSS |

### 5.3 Visualisation ASCII

```
PROTOTYPE POLLUTION ATTACK FLOW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Attacker Input                Target Application
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{                             let config = {};
  "__proto__": {              Object.assign(config, userInput);
    "debug": true,
    "script": "alert(1)"      if (config.debug) {
  }                               eval(config.script);  // XSS!
}                             }
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Inception - Deeper Levels"

*"We need to go deeper."*

```
Level 1: JSON Input        {"__proto__": {...}}
Level 2: Object.assign     â†’ Pollution du prototype
Level 3: Object.prototype  â†’ Tous les objets affectÃ©s
Level 4: eval(config.x)    â†’ CODE EXECUTION (limbo)
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel objet est affectÃ© par `{"__proto__": {"x": 1}}`?**
- A) Seulement l'objet courant
- B) Tous les objets JavaScript
- C) Seulement les nouveaux objets
- D) Aucun objet

**RÃ©ponse : B**

### Question 2
**Comment prÃ©venir le DOM Clobbering?**
- A) Utiliser `var` au lieu de `let`
- B) Utiliser `let`/`const` et vÃ©rifier `typeof`
- C) Ajouter un WAF
- D) DÃ©sactiver JavaScript

**RÃ©ponse : B**

### Question 3
**Quelle validation est essentielle pour postMessage?**
- A) Valider la taille du message
- B) Valider `event.origin`
- C) Valider le type de donnÃ©es
- D) Utiliser HTTPS

**RÃ©ponse : B**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.3.4-h-dom-clobbering-prototype-pollution",
    "metadata": {
      "exercise_id": "3.3.4-h",
      "difficulty": 9,
      "language": "rust",
      "duration_minutes": 240,
      "xp_base": 450,
      "meme_reference": "Inception"
    },
    "cwe_mapping": {
      "primary": "CWE-1321",
      "secondary": ["CWE-79", "CWE-346"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” DOM Clobbering & Prototype Pollution*
*"We need to go deeper into the prototype chain"*