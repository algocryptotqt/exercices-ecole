# Exercice 3.3.13-a : api_pentesting_challenge

**Module :**
3.3.13 ‚Äî API Pentesting Challenge

**Concept :**
a ‚Äî API Discovery, Mass Assignment, Rate Limiting, BOLA, API Abuse

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
code

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Module 3.3.2 (REST API Security)
- Module 3.3.3 (GraphQL)
- Module 3.3.7 (Access Control)

**Domaines :**
Net, Struct, Crypto

**Dur√©e estim√©e :**
300 min

**XP Base :**
450

**Complexit√© :**
T3 O(n¬≤) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`api_pentesting_challenge.rs`

**Fonctions autoris√©es :**
- `std::collections::*`
- `serde_json`
- `regex`

**Fonctions interdites :**
- Requ√™tes HTTP r√©elles
- `unsafe` blocks

---

### 1.2 Consigne

#### 1.2.1 üéÆ Contexte Fun ‚Äî "SWORD ART ONLINE" : Hack the System, Break the Rules

**‚öîÔ∏è "In this world, a single blade can take you anywhere you want to go." ‚Äî Kirito**

Dans **Sword Art Online**, Kirito exploite les m√©caniques du jeu pour atteindre des objectifs impossibles. Il d√©couvre des endpoints cach√©s, abuse des syst√®mes de craft (Mass Assignment), et contourne les limites impos√©es (Rate Limiting).

**L'API Pentesting, c'est comme hacker le syst√®me d'Aincrad :**
- **API Discovery** = Explorer les √©tages cach√©s du ch√¢teau
- **Mass Assignment** = Modifier tes stats en ajoutant des champs non document√©s
- **Rate Limiting Bypass** = Utiliser des techniques de duplication pour farm infiniment
- **BOLA** = Acc√©der aux inventaires des autres joueurs
- **Business Logic Abuse** = Exploiter les failles du syst√®me de trading

**Les personnages de ton pentest :**
- **Kirito (Toi)** : Le pentester qui explore et exploite
- **Cardinal System (API)** : Le syst√®me √† auditer
- **Asuna (Documentation)** : L'aide qui r√©v√®le les endpoints
- **Heathcliff (Admin)** : L'endpoint prot√©g√© √† atteindre
- **Kayaba (Vuln√©rabilit√©s)** : Ce qui se cache derri√®re le syst√®me

---

#### 1.2.2 üìö √ânonc√© Acad√©mique

**Contexte technique :**

Les APIs modernes (REST/GraphQL) pr√©sentent des surfaces d'attaque sp√©cifiques document√©es dans l'OWASP API Security Top 10 :

| Rank | Vuln√©rabilit√© | Description |
|------|--------------|-------------|
| API1 | Broken Object Level Authorization (BOLA) | Acc√®s aux objets d'autres utilisateurs |
| API2 | Broken Authentication | Faiblesse d'authentification |
| API3 | Broken Object Property Level Authorization | Mass Assignment |
| API4 | Unrestricted Resource Consumption | Rate Limiting absent |
| API5 | Broken Function Level Authorization | Acc√®s aux endpoints admin |

**Ta mission :**

√âcrire une fonction `api_pentesting_challenge` qui effectue un audit complet d'une API et g√©n√®re des exploits.

**Entr√©e (JSON) :**
```json
{
  "base_url": "https://api.target.com",
  "api_version": "v2",
  "known_endpoints": [
    {"method": "GET", "path": "/api/v2/users"},
    {"method": "POST", "path": "/api/v2/users"},
    {"method": "GET", "path": "/api/v2/orders/{id}"},
    {"method": "PUT", "path": "/api/v2/users/{id}"}
  ],
  "sample_request": {
    "path": "POST /api/v2/users",
    "body": {"username": "test", "email": "test@test.com"},
    "response": {"id": 123, "username": "test", "email": "test@test.com", "role": "user"}
  },
  "authentication": {
    "method": "Bearer JWT",
    "token_sample": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
  },
  "rate_limit": {
    "documented": "100 requests/minute",
    "header_observed": "X-RateLimit-Remaining: 95"
  },
  "discovered_params": ["page", "limit", "sort", "filter"],
  "response_headers": {
    "Access-Control-Allow-Origin": "*",
    "X-Powered-By": "Express"
  }
}
```

**Sortie (JSON) :**
```json
{
  "discovery": {
    "hidden_endpoints": [
      {"method": "GET", "path": "/api/v1/users", "reason": "Old version, potentially less secure"},
      {"method": "GET", "path": "/api/v2/admin/users", "reason": "Admin endpoint discovered via path fuzzing"},
      {"method": "DELETE", "path": "/api/v2/users/{id}", "reason": "Undocumented DELETE method"}
    ],
    "discovery_techniques": [
      "Version downgrade (v2 ‚Üí v1)",
      "Path fuzzing (/admin/, /internal/, /debug/)",
      "Method enumeration (GET, POST, PUT, DELETE, PATCH)",
      "JS file analysis for hardcoded endpoints"
    ]
  },
  "vulnerabilities": [
    {
      "type": "MASS_ASSIGNMENT",
      "owasp_api": "API3",
      "endpoint": "POST /api/v2/users",
      "severity": "HIGH",
      "description": "User role can be modified by adding 'role' field to request",
      "proof_of_concept": {
        "original_request": {"username": "test", "email": "test@test.com"},
        "exploit_request": {"username": "test", "email": "test@test.com", "role": "admin"},
        "expected_result": "User created with admin privileges"
      },
      "remediation": "Whitelist allowed fields server-side, use DTOs"
    },
    {
      "type": "BOLA",
      "owasp_api": "API1",
      "endpoint": "GET /api/v2/orders/{id}",
      "severity": "HIGH",
      "description": "No authorization check on order ID - can access other users' orders",
      "proof_of_concept": {
        "technique": "IDOR via sequential ID enumeration",
        "payload": "GET /api/v2/orders/1 through /api/v2/orders/1000",
        "expected_result": "Access to all user orders"
      },
      "remediation": "Implement proper ownership validation"
    },
    {
      "type": "RATE_LIMIT_BYPASS",
      "owasp_api": "API4",
      "severity": "MEDIUM",
      "description": "Rate limiting can be bypassed via header manipulation",
      "techniques": [
        {
          "name": "X-Forwarded-For rotation",
          "payload": "X-Forwarded-For: <random-ip>",
          "success_rate": "HIGH"
        },
        {
          "name": "API key rotation",
          "payload": "Use multiple API keys",
          "success_rate": "MEDIUM"
        }
      ],
      "remediation": "Rate limit by authenticated user ID, not IP"
    },
    {
      "type": "CORS_MISCONFIGURATION",
      "severity": "MEDIUM",
      "description": "CORS allows any origin with credentials",
      "evidence": "Access-Control-Allow-Origin: *",
      "impact": "Potential credential theft via malicious website",
      "remediation": "Whitelist specific trusted origins"
    }
  ],
  "api_versioning_issues": {
    "old_versions_accessible": ["v1"],
    "security_diff": {
      "v1_vs_v2": "v1 lacks rate limiting and uses weaker authentication"
    }
  },
  "tools_recommended": [
    {"tool": "Kiterunner", "purpose": "API endpoint discovery with smart wordlists"},
    {"tool": "Arjun", "purpose": "Hidden parameter discovery"},
    {"tool": "jwt_tool", "purpose": "JWT vulnerability testing"},
    {"tool": "Burp Suite + Autorize", "purpose": "Authorization testing"}
  ],
  "attack_chain": {
    "name": "Privilege Escalation via Mass Assignment",
    "steps": [
      "1. Register new account with POST /api/v2/users",
      "2. Add 'role': 'admin' to registration request",
      "3. Verify admin access with GET /api/v2/admin/users",
      "4. Access all user data via admin endpoint"
    ],
    "severity": "CRITICAL"
  }
}
```

**Contraintes :**
- Identifier automatiquement les techniques de discovery pertinentes
- G√©n√©rer des PoC exploitables
- Calculer les scores de risque OWASP API
- Proposer des outils et rem√©diations

---

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Point d'entr√©e principal - "Link Start!"
pub fn api_pentesting_challenge(input_json: &str) -> String;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 OWASP API Security Top 10 (2023)

| Position | Vuln√©rabilit√© | Pr√©valence |
|----------|--------------|------------|
| 1 | Broken Object Level Authorization | 75% des APIs |
| 2 | Broken Authentication | 60% |
| 3 | Broken Object Property Level Authorization | 55% |
| 4 | Unrestricted Resource Consumption | 50% |
| 5 | Broken Function Level Authorization | 45% |

### 2.2 Mass Assignment : L'Histoire

En 2012, **Egor Homakov** a hack√© GitHub en exploitant une vuln√©rabilit√© Mass Assignment dans Ruby on Rails. Il s'est ajout√© comme contributeur au repo Rails en modifiant un champ non prot√©g√©.

### 2.5 DANS LA VRAIE VIE

| M√©tier | Utilisation |
|--------|-------------|
| **API Security Engineer** | Design et audit d'APIs |
| **Bug Bounty Hunter** | Target API endpoints |
| **Backend Developer** | Secure API implementation |
| **DevSecOps** | API security testing in CI/CD |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo run
‚öîÔ∏è API Pentesting Challenge - "Link Start!"
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

[DISCOVERY] Hidden Endpoints Found
‚úì /api/v1/users (version downgrade)
‚úì /api/v2/admin/users (admin endpoint)
‚úì DELETE /api/v2/users/{id} (method enum)

[VULNERABILITY 1] Mass Assignment - API3
‚úì Endpoint: POST /api/v2/users
‚úì PoC: Add 'role': 'admin' to request
‚úì Severity: HIGH

[VULNERABILITY 2] BOLA - API1
‚úì Endpoint: GET /api/v2/orders/{id}
‚úì PoC: Sequential ID enumeration
‚úì Severity: HIGH

[VULNERABILITY 3] Rate Limit Bypass - API4
‚úì Technique: X-Forwarded-For rotation
‚úì Severity: MEDIUM

[ATTACK CHAIN] Privilege Escalation
‚úì 4-step chain to admin access
‚úì Severity: CRITICAL

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä Audit Complete: 3 HIGH, 1 MEDIUM
‚öîÔ∏è "I'll clear this game!" - All vulnerabilities identified
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```rust
use serde_json::{json, Value};
use std::collections::HashMap;

pub fn api_pentesting_challenge(input_json: &str) -> String {
    let input: Value = match serde_json::from_str(input_json) {
        Ok(v) => v,
        Err(e) => return json!({"error": e.to_string()}).to_string(),
    };

    let base_url = input["base_url"].as_str().unwrap_or("");
    let api_version = input["api_version"].as_str().unwrap_or("v1");
    let endpoints = input["known_endpoints"].as_array().cloned().unwrap_or_default();
    let sample_request = &input["sample_request"];
    let rate_limit = &input["rate_limit"];
    let response_headers = &input["response_headers"];

    // Discovery
    let discovery = perform_discovery(&endpoints, api_version);

    // Vulnerability Analysis
    let mut vulnerabilities = Vec::new();

    // Check Mass Assignment
    if let Some(mass_assignment) = check_mass_assignment(sample_request) {
        vulnerabilities.push(mass_assignment);
    }

    // Check BOLA
    for endpoint in &endpoints {
        if let Some(bola) = check_bola(endpoint) {
            vulnerabilities.push(bola);
        }
    }

    // Check Rate Limiting
    if let Some(rate_limit_vuln) = check_rate_limiting(rate_limit) {
        vulnerabilities.push(rate_limit_vuln);
    }

    // Check CORS
    if let Some(cors_vuln) = check_cors(response_headers) {
        vulnerabilities.push(cors_vuln);
    }

    // API Versioning Issues
    let versioning_issues = analyze_versioning(api_version);

    // Recommended Tools
    let tools = recommend_tools(&vulnerabilities);

    // Attack Chain
    let attack_chain = generate_attack_chain(&vulnerabilities);

    json!({
        "discovery": discovery,
        "vulnerabilities": vulnerabilities,
        "api_versioning_issues": versioning_issues,
        "tools_recommended": tools,
        "attack_chain": attack_chain
    }).to_string()
}

fn perform_discovery(endpoints: &[Value], version: &str) -> Value {
    let mut hidden_endpoints = Vec::new();
    let mut techniques = Vec::new();

    // Version downgrade
    if version != "v1" {
        let old_version = format!("v{}", version.trim_start_matches('v').parse::<i32>().unwrap_or(2) - 1);
        for ep in endpoints {
            if let Some(path) = ep["path"].as_str() {
                let old_path = path.replace(version, &old_version);
                hidden_endpoints.push(json!({
                    "method": ep["method"],
                    "path": old_path,
                    "reason": "Old version potentially less secure"
                }));
            }
        }
        techniques.push("Version downgrade testing".to_string());
    }

    // Admin endpoint discovery
    for ep in endpoints {
        if let Some(path) = ep["path"].as_str() {
            if path.contains("/users") && !path.contains("/admin") {
                let admin_path = path.replace("/users", "/admin/users");
                hidden_endpoints.push(json!({
                    "method": "GET",
                    "path": admin_path,
                    "reason": "Potential admin endpoint"
                }));
            }
        }
    }
    techniques.push("Path fuzzing for admin endpoints".to_string());

    // Method enumeration
    let methods = ["GET", "POST", "PUT", "DELETE", "PATCH"];
    for ep in endpoints {
        let existing_method = ep["method"].as_str().unwrap_or("");
        for method in methods {
            if method != existing_method {
                // Check if this method might exist
                if let Some(path) = ep["path"].as_str() {
                    if path.contains("{id}") && method == "DELETE" {
                        hidden_endpoints.push(json!({
                            "method": method,
                            "path": path,
                            "reason": "Undocumented HTTP method"
                        }));
                    }
                }
            }
        }
    }
    techniques.push("HTTP method enumeration".to_string());
    techniques.push("JS file analysis for hardcoded endpoints".to_string());

    json!({
        "hidden_endpoints": hidden_endpoints,
        "discovery_techniques": techniques
    })
}

fn check_mass_assignment(sample: &Value) -> Option<Value> {
    let body = &sample["body"];
    let response = &sample["response"];

    // Check if response has more fields than request (potential mass assignment)
    if let (Some(req_obj), Some(resp_obj)) = (body.as_object(), response.as_object()) {
        let response_fields: Vec<&String> = resp_obj.keys().collect();
        let request_fields: Vec<&String> = req_obj.keys().collect();

        let extra_fields: Vec<&&String> = response_fields.iter()
            .filter(|f| !request_fields.contains(f))
            .collect();

        // Check for sensitive fields that could be mass-assigned
        let dangerous_fields = ["role", "admin", "is_admin", "permissions", "verified", "balance"];
        let exploitable_fields: Vec<&str> = extra_fields.iter()
            .filter(|f| dangerous_fields.contains(&f.as_str()))
            .map(|f| f.as_str())
            .collect();

        if !exploitable_fields.is_empty() || extra_fields.iter().any(|f| f.as_str() == "role") {
            let exploit_field = exploitable_fields.first().unwrap_or(&"role");
            let mut exploit_body = req_obj.clone();
            exploit_body.insert(exploit_field.to_string(), json!("admin"));

            return Some(json!({
                "type": "MASS_ASSIGNMENT",
                "owasp_api": "API3",
                "endpoint": sample["path"],
                "severity": "HIGH",
                "description": format!("'{}' field can be set during creation", exploit_field),
                "proof_of_concept": {
                    "original_request": body,
                    "exploit_request": exploit_body,
                    "expected_result": format!("Resource created with elevated '{}' value", exploit_field)
                },
                "remediation": "Implement strict input validation, use allowlist for writable fields"
            }));
        }
    }

    None
}

fn check_bola(endpoint: &Value) -> Option<Value> {
    let path = endpoint["path"].as_str().unwrap_or("");
    let method = endpoint["method"].as_str().unwrap_or("");

    // Check for resource ID in path (potential IDOR/BOLA)
    if path.contains("{id}") && (method == "GET" || method == "PUT" || method == "DELETE") {
        return Some(json!({
            "type": "BOLA",
            "owasp_api": "API1",
            "endpoint": format!("{} {}", method, path),
            "severity": "HIGH",
            "description": "Resource accessed by ID without ownership validation",
            "proof_of_concept": {
                "technique": "Sequential/UUID ID enumeration",
                "payload": format!("{} with IDs 1-1000 or UUID bruteforce", path),
                "expected_result": "Access to other users' resources"
            },
            "remediation": "Validate resource ownership before returning data"
        }));
    }

    None
}

fn check_rate_limiting(rate_limit: &Value) -> Option<Value> {
    let documented = rate_limit["documented"].as_str().unwrap_or("");
    let header = rate_limit["header_observed"].as_str().unwrap_or("");

    if !documented.is_empty() || !header.is_empty() {
        return Some(json!({
            "type": "RATE_LIMIT_BYPASS",
            "owasp_api": "API4",
            "severity": "MEDIUM",
            "description": "Rate limiting potentially bypassable",
            "techniques": [
                {
                    "name": "X-Forwarded-For rotation",
                    "payload": "X-Forwarded-For: <random-ip>",
                    "success_rate": "HIGH"
                },
                {
                    "name": "X-Real-IP manipulation",
                    "payload": "X-Real-IP: <random-ip>",
                    "success_rate": "MEDIUM"
                },
                {
                    "name": "API version switching",
                    "payload": "Use v1 and v2 endpoints alternately",
                    "success_rate": "LOW"
                }
            ],
            "remediation": "Rate limit by authenticated user, not by IP or headers"
        }));
    }

    None
}

fn check_cors(headers: &Value) -> Option<Value> {
    if let Some(origin) = headers["Access-Control-Allow-Origin"].as_str() {
        if origin == "*" {
            return Some(json!({
                "type": "CORS_MISCONFIGURATION",
                "severity": "MEDIUM",
                "description": "CORS allows any origin",
                "evidence": format!("Access-Control-Allow-Origin: {}", origin),
                "impact": "Cross-origin requests from any website allowed",
                "remediation": "Whitelist specific trusted origins"
            }));
        }
    }

    None
}

fn analyze_versioning(current_version: &str) -> Value {
    let version_num: i32 = current_version.trim_start_matches('v').parse().unwrap_or(1);
    let old_versions: Vec<String> = (1..version_num).map(|v| format!("v{}", v)).collect();

    json!({
        "old_versions_accessible": old_versions,
        "security_diff": {
            "recommendation": "Test old API versions for security regressions",
            "common_issues": [
                "Missing rate limiting in older versions",
                "Weaker authentication mechanisms",
                "Missing input validation"
            ]
        }
    })
}

fn recommend_tools(vulnerabilities: &[Value]) -> Vec<Value> {
    let mut tools = vec![
        json!({
            "tool": "Kiterunner",
            "purpose": "API endpoint discovery with smart wordlists"
        }),
        json!({
            "tool": "Arjun",
            "purpose": "Hidden parameter discovery"
        })
    ];

    for vuln in vulnerabilities {
        match vuln["type"].as_str().unwrap_or("") {
            "MASS_ASSIGNMENT" => {
                tools.push(json!({
                    "tool": "Param Miner (Burp)",
                    "purpose": "Discover additional writable parameters"
                }));
            }
            "BOLA" => {
                tools.push(json!({
                    "tool": "Autorize (Burp)",
                    "purpose": "Automated authorization testing"
                }));
            }
            _ => {}
        }
    }

    tools.push(json!({
        "tool": "jwt_tool",
        "purpose": "JWT vulnerability testing"
    }));

    tools
}

fn generate_attack_chain(vulnerabilities: &[Value]) -> Value {
    let has_mass_assignment = vulnerabilities.iter()
        .any(|v| v["type"] == "MASS_ASSIGNMENT");
    let has_bola = vulnerabilities.iter()
        .any(|v| v["type"] == "BOLA");

    if has_mass_assignment {
        return json!({
            "name": "Privilege Escalation via Mass Assignment",
            "steps": [
                "1. Register new account via POST /api/users",
                "2. Include 'role': 'admin' in registration payload",
                "3. Authenticate with new admin account",
                "4. Access admin-only endpoints"
            ],
            "severity": "CRITICAL"
        });
    }

    if has_bola {
        return json!({
            "name": "Data Exfiltration via BOLA",
            "steps": [
                "1. Authenticate as regular user",
                "2. Enumerate resource IDs (1-10000)",
                "3. Access all user resources",
                "4. Extract sensitive data"
            ],
            "severity": "HIGH"
        });
    }

    json!({
        "name": "Reconnaissance",
        "steps": [
            "1. Enumerate all API endpoints",
            "2. Test each for authorization issues",
            "3. Document findings"
        ],
        "severity": "INFO"
    })
}
```

### 4.9 spec.json

```json
{
  "name": "api_pentesting_challenge",
  "language": "rust",
  "version": "edition2024",
  "type": "code",
  "tags": ["security", "api", "owasp", "bola", "mass-assignment"],
  "passing_score": 70,

  "function": {
    "name": "api_pentesting_challenge",
    "prototype": "pub fn api_pentesting_challenge(input_json: &str) -> String",
    "return_type": "String"
  },

  "security_checks": {
    "cwe_mapping": ["CWE-639", "CWE-915", "CWE-770"],
    "owasp_category": "API1-API5"
  }
}
```

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| **Exercice** | 3.3.13-a API Pentesting Challenge |
| **Difficult√©** | ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10) |
| **XP Base** | 450 |
| **Concepts cl√©s** | BOLA, Mass Assignment, Rate Limiting, API Discovery |
| **Temps** | ~5h |

---

*"Link Start!" ‚Äî Chaque API a ses failles cach√©es, comme chaque jeu a ses exploits.*

*HACKBRAIN v5.5.2 ‚Äî L'excellence n'a pas de raccourcis*
