# Exercice 3.3.12-a : burp_suite_mastery

**Module :**
3.3.12 â€” Burp Suite Mastery Challenge

**Concept :**
a â€” Burp Suite, OWASP ZAP, Nuclei, Attack Types

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Module 3.3.1 Ã  3.3.5 (Fondamentaux Web Security)
- ComprÃ©hension HTTP/HTTPS
- Notions de fuzzing et bruteforce

**Domaines :**
Net, Struct, Encodage

**DurÃ©e estimÃ©e :**
240 min

**XP Base :**
400

**ComplexitÃ© :**
T2 O(n log n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`burp_suite_mastery.rs`

**Fonctions autorisÃ©es :**
- `std::collections::*`
- `serde_json`
- `regex`
- Fonctions de manipulation de chaÃ®nes

**Fonctions interdites :**
- RequÃªtes HTTP rÃ©elles
- ExÃ©cution de processus externes
- `unsafe` blocks

---

### 1.2 Consigne

#### 1.2.1 ğŸ”§ Contexte Fun â€” "MACGYVER" : L'Art de l'Improvisation Tactique

**ğŸ”§ "Any fool can make things bigger, more complex. It takes a genius to make things simpler." â€” MacGyver**

Dans **MacGyver**, Angus MacGyver rÃ©sout des problÃ¨mes impossibles avec des objets du quotidien : un trombone, du ruban adhÃ©sif, un couteau suisse. Il comprend profondÃ©ment comment chaque outil fonctionne et les combine de faÃ§on crÃ©ative.

**Burp Suite, c'est ton couteau suisse du pentesting web :**
- **Proxy** (le trombone) : Simple mais essentiel, il intercepte tout
- **Repeater** (le ruban adhÃ©sif) : Modifie et renvoie jusqu'Ã  ce que Ã§a marche
- **Intruder** (le canif) : Plusieurs lames pour diffÃ©rentes attaques
- **Scanner** (le miroir) : RÃ©vÃ¨le ce qui est cachÃ©
- **Extensions** (les gadgets) : Pour les situations spÃ©ciales

**Les modes d'Intruder comme les techniques de MacGyver :**
- **Sniper** : Un tir prÃ©cis, une position Ã  la fois (comme dÃ©samorcer une bombe)
- **Battering Ram** : Le mÃªme payload partout (comme enfoncer une porte)
- **Pitchfork** : Payloads synchronisÃ©s (comme coordonner une Ã©quipe)
- **Cluster Bomb** : Toutes les combinaisons (comme tester toutes les frÃ©quences radio)

---

#### 1.2.2 ğŸ“š Ã‰noncÃ© AcadÃ©mique

**Contexte technique :**

Burp Suite est l'outil de rÃ©fÃ©rence pour le pentesting web. MaÃ®triser ses fonctionnalitÃ©s est essentiel pour tout auditeur de sÃ©curitÃ©.

**Intruder Attack Types :**
| Type | Description | Positions | Payloads |
|------|-------------|-----------|----------|
| **Sniper** | Un payload set, une position Ã  la fois | N | 1 |
| **Battering Ram** | MÃªme payload partout simultanÃ©ment | N | 1 |
| **Pitchfork** | Payloads synchronisÃ©s (1 set par position) | N | N |
| **Cluster Bomb** | Toutes les combinaisons possibles | N | N |

**Ta mission :**

Ã‰crire une fonction `burp_suite_mastery` qui analyse des configurations et rÃ©sultats de Burp Suite pour recommander des stratÃ©gies optimales.

**EntrÃ©e (JSON) :**
```json
{
  "scenario": "CREDENTIAL_BRUTEFORCE",
  "target": "https://target.com/login",
  "intruder_config": {
    "attack_type": "UNKNOWN",
    "positions": ["username", "password"],
    "payloads": {
      "username": ["admin", "user", "test"],
      "password": ["password123", "admin123", "test123"]
    }
  },
  "results": [
    {"username": "admin", "password": "password123", "status": 200, "length": 1234},
    {"username": "admin", "password": "admin123", "status": 200, "length": 567},
    {"username": "admin", "password": "test123", "status": 200, "length": 1234}
  ],
  "context": {
    "rate_limit_detected": false,
    "waf_present": true,
    "csrf_token_required": true
  }
}
```

**Sortie (JSON) :**
```json
{
  "attack_analysis": {
    "recommended_attack_type": "CLUSTER_BOMB",
    "justification": "Multiple positions (username, password) require testing all combinations",
    "total_requests": 9,
    "request_formula": "3 usernames Ã— 3 passwords = 9 requests"
  },
  "results_analysis": {
    "success_indicator": "Response length anomaly",
    "baseline_length": 1234,
    "anomalous_response": {
      "username": "admin",
      "password": "admin123",
      "length": 567,
      "deviation": -667
    },
    "likely_valid_credentials": {
      "username": "admin",
      "password": "admin123"
    },
    "confidence": "HIGH",
    "reasoning": "Response length 567 differs significantly from baseline 1234, indicating successful login"
  },
  "extensions_recommended": [
    {
      "name": "Logger++",
      "reason": "Full request/response logging for forensics"
    },
    {
      "name": "Autorize",
      "reason": "Test authorization bypass after finding valid credentials"
    },
    {
      "name": "CSRF Token Tracker",
      "reason": "Automatically update CSRF tokens between requests"
    },
    {
      "name": "WAF Bypass",
      "reason": "WAF detected - may need payload obfuscation"
    }
  ],
  "nuclei_template": {
    "id": "custom-login-brute",
    "info": {
      "name": "Login Bruteforce Detection",
      "severity": "high",
      "author": "auditor"
    },
    "template_content": "id: custom-login-brute\ninfo:\n  name: Login Bruteforce\n  severity: high\nrequests:\n  - method: POST\n    path:\n      - /login\n    body: username={{username}}&password={{password}}"
  },
  "zap_scan_config": {
    "spider_depth": 5,
    "ajax_spider": true,
    "active_scan_policy": "Default Policy",
    "auth_config": {
      "type": "FORM_BASED",
      "login_url": "/login",
      "login_params": ["username", "password"]
    }
  },
  "tactical_recommendations": [
    "Start with Sniper to identify valid usernames via timing/response differences",
    "Switch to Cluster Bomb once valid username found",
    "Use Pitchfork if you have known username:password pairs to verify",
    "Configure Intruder to handle CSRF tokens via macros"
  ]
}
```

**Contraintes :**
- Analyser automatiquement le type d'attaque optimal
- DÃ©tecter les credentials valides par anomalies de rÃ©ponse
- Recommander les extensions appropriÃ©es au contexte
- GÃ©nÃ©rer des templates Nuclei fonctionnels

**Exemples de scÃ©narios :**

| Scenario | Attack Type | Justification |
|----------|-------------|---------------|
| Single parameter fuzzing | SNIPER | Une seule position Ã  tester |
| Username enumeration | SNIPER | Tester les usernames un par un |
| Credential bruteforce | CLUSTER_BOMB | Toutes les combinaisons |
| Known pairs verification | PITCHFORK | Pairs synchronisÃ©s |
| Same payload everywhere | BATTERING_RAM | Ex: Session ID dans plusieurs champs |

---

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Point d'entrÃ©e principal - "I'm MacGyver. I can fix anything."
pub fn burp_suite_mastery(input_json: &str) -> String;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Histoire de Burp Suite

CrÃ©Ã© par **Dafydd Stuttard** (alias PortSwigger) en 2003, Burp Suite est devenu l'outil standard de l'industrie. La version Community est gratuite, la Pro ($449/an) est essentielle pour les pentesters professionnels.

### 2.2 Intruder vs Scanner

| Feature | Intruder | Scanner |
|---------|----------|---------|
| **Purpose** | Manual, targeted attacks | Automated vulnerability scanning |
| **Control** | Full control over payloads | Automated payload selection |
| **Speed (Free)** | Throttled | N/A |
| **Best for** | Fuzzing, bruteforce, parameter testing | Compliance, broad coverage |

### 2.3 Alternatives Open Source

- **OWASP ZAP** : Alternative gratuite Ã  Burp Scanner
- **Nuclei** : Templates-based scanning (trÃ¨s populaire en bug bounty)
- **FFuf** : Fuzzer web ultra-rapide
- **mitmproxy** : Proxy Python scriptable

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation Burp |
|--------|-----------------|
| **Pentester Web** | Outil principal quotidien |
| **Bug Bounty Hunter** | Target discovery et exploitation |
| **QA Security** | Tests automatisÃ©s avec Burp Scanner |
| **DevSecOps** | IntÃ©gration CI/CD avec Burp API |
| **Researcher** | Analyse de protocoles et fuzzing |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
burp_suite_mastery.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
ğŸ”§ Burp Suite Mastery - "MacGyver Mode Activated"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[ANALYSIS 1] Attack Type Recommendation
âœ“ Scenario: CREDENTIAL_BRUTEFORCE
âœ“ Positions: 2 (username, password)
âœ“ Recommended: CLUSTER_BOMB
âœ“ Total requests: 9

[ANALYSIS 2] Results Anomaly Detection
âœ“ Baseline length: 1234
âœ“ Anomaly detected: length=567 (-667)
âœ“ Likely valid: admin:admin123
âœ“ Confidence: HIGH

[ANALYSIS 3] Extension Recommendations
âœ“ Logger++ (forensics)
âœ“ Autorize (authz testing)
âœ“ CSRF Token Tracker
âœ“ WAF Bypass

[ANALYSIS 4] Nuclei Template Generated
âœ“ Template ID: custom-login-brute
âœ“ Ready for automation

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š RÃ©sultats: 10/10 tests passÃ©s
ğŸ”§ "Duct tape and determination!" - Analysis complete
```

---

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—4

#### 3.1.1 Consigne Bonus

**ğŸ”§ "MACGYVER ADVANCED" â€” Burp Macros & Automation**

Ta mission bonus :
1. **Macro Design** : CrÃ©er des macros pour sessions complexes
2. **Extension Development** : SpÃ©cifier une extension Burp custom
3. **Pipeline Integration** : IntÃ©grer Burp dans CI/CD
4. **Advanced Intruder** : Recursive grep, extract payloads

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `test_cluster_bomb_recommendation` | 2+ positions | CLUSTER_BOMB | 10 |
| `test_sniper_recommendation` | 1 position | SNIPER | 10 |
| `test_pitchfork_recommendation` | paired payloads | PITCHFORK | 10 |
| `test_length_anomaly_detection` | varied lengths | Anomaly identified | 15 |
| `test_status_anomaly_detection` | varied statuses | Anomaly identified | 10 |
| `test_extension_recommendations` | WAF present | WAF Bypass suggested | 10 |
| `test_csrf_handling` | csrf_token_required | CSRF extension | 10 |
| `test_nuclei_template_generation` | Any scenario | Valid template | 15 |
| `test_empty_results` | No results | Handle gracefully | 5 |
| `test_rate_limit_detection` | rate_limit_detected | Throttling recommendation | 5 |

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod burp_suite_mastery;
use burp_suite_mastery::burp_suite_mastery;

fn main() {
    println!("ğŸ”§ Burp Suite Mastery - Test Suite");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");

    let mut passed = 0;
    let mut total = 0;

    // Test 1: Cluster Bomb for 2 positions
    total += 1;
    let input = json!({
        "scenario": "CREDENTIAL_BRUTEFORCE",
        "target": "https://target.com/login",
        "intruder_config": {
            "attack_type": "UNKNOWN",
            "positions": ["username", "password"],
            "payloads": {
                "username": ["admin", "user"],
                "password": ["pass1", "pass2"]
            }
        },
        "results": [],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["attack_analysis"]["recommended_attack_type"] == "CLUSTER_BOMB" {
        println!("âœ“ Test 1: Cluster Bomb recommended for 2 positions");
        passed += 1;
    } else {
        println!("âœ— Test 1: Wrong attack type recommendation");
    }

    // Test 2: Sniper for single position
    total += 1;
    let input = json!({
        "scenario": "PARAMETER_FUZZING",
        "target": "https://target.com/search",
        "intruder_config": {
            "attack_type": "UNKNOWN",
            "positions": ["query"],
            "payloads": {
                "query": ["test", "'OR 1=1--", "<script>"]
            }
        },
        "results": [],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["attack_analysis"]["recommended_attack_type"] == "SNIPER" {
        println!("âœ“ Test 2: Sniper recommended for single position");
        passed += 1;
    } else {
        println!("âœ— Test 2: Should recommend Sniper");
    }

    // Test 3: Length anomaly detection
    total += 1;
    let input = json!({
        "scenario": "CREDENTIAL_BRUTEFORCE",
        "target": "https://target.com/login",
        "intruder_config": {
            "attack_type": "CLUSTER_BOMB",
            "positions": ["username", "password"],
            "payloads": {
                "username": ["admin"],
                "password": ["wrong", "correct", "invalid"]
            }
        },
        "results": [
            {"username": "admin", "password": "wrong", "status": 200, "length": 1000},
            {"username": "admin", "password": "correct", "status": 200, "length": 500},
            {"username": "admin", "password": "invalid", "status": 200, "length": 1000}
        ],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let likely_password = parsed["results_analysis"]["likely_valid_credentials"]["password"]
        .as_str().unwrap_or("");

    if likely_password == "correct" {
        println!("âœ“ Test 3: Length anomaly detected correctly");
        passed += 1;
    } else {
        println!("âœ— Test 3: Length anomaly not detected");
    }

    // Test 4: Status code anomaly
    total += 1;
    let input = json!({
        "scenario": "PATH_DISCOVERY",
        "target": "https://target.com",
        "intruder_config": {
            "attack_type": "SNIPER",
            "positions": ["path"],
            "payloads": {
                "path": ["/admin", "/api", "/secret", "/public"]
            }
        },
        "results": [
            {"path": "/admin", "status": 403, "length": 100},
            {"path": "/api", "status": 200, "length": 500},
            {"path": "/secret", "status": 302, "length": 50},
            {"path": "/public", "status": 404, "length": 100}
        ],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let analysis = &parsed["results_analysis"];
    if analysis.to_string().contains("200") || analysis.to_string().contains("302") {
        println!("âœ“ Test 4: Status anomalies identified");
        passed += 1;
    } else {
        println!("âœ— Test 4: Status anomalies missed");
    }

    // Test 5: WAF extension recommendation
    total += 1;
    let input = json!({
        "scenario": "SQL_INJECTION",
        "target": "https://target.com/search",
        "intruder_config": {
            "attack_type": "SNIPER",
            "positions": ["id"],
            "payloads": {"id": ["1", "1'"]}
        },
        "results": [],
        "context": {"waf_present": true}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let extensions = parsed["extensions_recommended"].as_array().unwrap();
    let has_waf_bypass = extensions.iter().any(|e| {
        e["name"].as_str().unwrap_or("").to_lowercase().contains("waf")
    });

    if has_waf_bypass {
        println!("âœ“ Test 5: WAF Bypass extension recommended");
        passed += 1;
    } else {
        println!("âœ— Test 5: WAF Bypass not recommended");
    }

    // Test 6: CSRF Token extension
    total += 1;
    let input = json!({
        "scenario": "CREDENTIAL_BRUTEFORCE",
        "target": "https://target.com/login",
        "intruder_config": {
            "attack_type": "CLUSTER_BOMB",
            "positions": ["username", "password"],
            "payloads": {"username": ["admin"], "password": ["test"]}
        },
        "results": [],
        "context": {"csrf_token_required": true}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let extensions = parsed["extensions_recommended"].as_array().unwrap();
    let has_csrf = extensions.iter().any(|e| {
        e["name"].as_str().unwrap_or("").to_lowercase().contains("csrf") ||
        e["reason"].as_str().unwrap_or("").to_lowercase().contains("csrf")
    });

    if has_csrf {
        println!("âœ“ Test 6: CSRF extension recommended");
        passed += 1;
    } else {
        println!("âœ— Test 6: CSRF extension not recommended");
    }

    // Test 7: Nuclei template generation
    total += 1;
    let input = json!({
        "scenario": "LOGIN_BRUTEFORCE",
        "target": "https://target.com/login",
        "intruder_config": {
            "attack_type": "CLUSTER_BOMB",
            "positions": ["username", "password"],
            "payloads": {"username": ["admin"], "password": ["test"]}
        },
        "results": [],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let template = &parsed["nuclei_template"];
    if template["id"].is_string() && template["info"]["severity"].is_string() {
        println!("âœ“ Test 7: Nuclei template generated");
        passed += 1;
    } else {
        println!("âœ— Test 7: Nuclei template invalid");
    }

    // Test 8: Request count calculation
    total += 1;
    let input = json!({
        "scenario": "BRUTEFORCE",
        "target": "https://target.com/login",
        "intruder_config": {
            "attack_type": "UNKNOWN",
            "positions": ["username", "password"],
            "payloads": {
                "username": ["a", "b", "c"],
                "password": ["1", "2", "3", "4"]
            }
        },
        "results": [],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let total_requests = parsed["attack_analysis"]["total_requests"].as_i64().unwrap_or(0);
    // 3 usernames Ã— 4 passwords = 12 requests
    if total_requests == 12 {
        println!("âœ“ Test 8: Request count correct (12)");
        passed += 1;
    } else {
        println!("âœ— Test 8: Request count wrong (expected 12, got {})", total_requests);
    }

    // Test 9: Rate limit handling
    total += 1;
    let input = json!({
        "scenario": "BRUTEFORCE",
        "target": "https://target.com/login",
        "intruder_config": {
            "attack_type": "CLUSTER_BOMB",
            "positions": ["password"],
            "payloads": {"password": ["test"]}
        },
        "results": [],
        "context": {"rate_limit_detected": true}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let recommendations = parsed["tactical_recommendations"].as_array().unwrap_or(&vec![]);
    let has_rate_limit_advice = recommendations.iter().any(|r| {
        r.as_str().unwrap_or("").to_lowercase().contains("rate") ||
        r.as_str().unwrap_or("").to_lowercase().contains("throttl")
    });

    if has_rate_limit_advice {
        println!("âœ“ Test 9: Rate limit handling recommended");
        passed += 1;
    } else {
        println!("âœ— Test 9: Rate limit not addressed");
    }

    // Test 10: Empty input handling
    total += 1;
    let input = json!({
        "scenario": "",
        "target": "",
        "intruder_config": {
            "positions": [],
            "payloads": {}
        },
        "results": [],
        "context": {}
    });

    let result = burp_suite_mastery(&input.to_string());
    let parsed: Value = serde_json::from_str(&result);

    if parsed.is_ok() {
        println!("âœ“ Test 10: Empty input handled gracefully");
        passed += 1;
    } else {
        println!("âœ— Test 10: Crashed on empty input");
    }

    println!("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸ“Š RÃ©sultats: {}/{} tests passÃ©s", passed, total);

    if passed == total {
        println!("ğŸ”§ \"I'm MacGyver. I can fix anything.\" - All tests passed!");
    } else {
        println!("ğŸ”§ \"Need more duct tape...\" - Some tests failed");
    }
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

pub fn burp_suite_mastery(input_json: &str) -> String {
    let input: Value = match serde_json::from_str(input_json) {
        Ok(v) => v,
        Err(e) => return json!({"error": format!("Invalid JSON: {}", e)}).to_string(),
    };

    let scenario = input["scenario"].as_str().unwrap_or("");
    let target = input["target"].as_str().unwrap_or("");
    let intruder_config = &input["intruder_config"];
    let results = input["results"].as_array().cloned().unwrap_or_default();
    let context = &input["context"];

    // Analyze attack type
    let attack_analysis = analyze_attack_type(intruder_config);

    // Analyze results
    let results_analysis = analyze_results(&results);

    // Recommend extensions
    let extensions = recommend_extensions(context);

    // Generate Nuclei template
    let nuclei_template = generate_nuclei_template(scenario, target);

    // Generate ZAP config
    let zap_config = generate_zap_config(target);

    // Generate tactical recommendations
    let recommendations = generate_recommendations(context, &attack_analysis);

    json!({
        "attack_analysis": attack_analysis,
        "results_analysis": results_analysis,
        "extensions_recommended": extensions,
        "nuclei_template": nuclei_template,
        "zap_scan_config": zap_config,
        "tactical_recommendations": recommendations
    }).to_string()
}

fn analyze_attack_type(config: &Value) -> Value {
    let positions = config["positions"].as_array().map(|a| a.len()).unwrap_or(0);
    let payloads = &config["payloads"];

    let (attack_type, justification) = if positions == 0 {
        ("NONE", "No positions defined")
    } else if positions == 1 {
        ("SNIPER", "Single position - test each payload one at a time")
    } else {
        // Check if payloads suggest paired testing
        let has_equal_payload_counts = if let Some(obj) = payloads.as_object() {
            let counts: Vec<usize> = obj.values()
                .filter_map(|v| v.as_array())
                .map(|a| a.len())
                .collect();
            counts.len() > 1 && counts.iter().all(|&c| c == counts[0])
        } else {
            false
        };

        if has_equal_payload_counts {
            ("CLUSTER_BOMB", "Multiple positions with payload sets - test all combinations")
        } else {
            ("CLUSTER_BOMB", "Multiple positions require testing all combinations")
        }
    };

    // Calculate total requests
    let total_requests = calculate_total_requests(payloads, positions, attack_type);

    let formula = if attack_type == "CLUSTER_BOMB" && positions > 1 {
        if let Some(obj) = payloads.as_object() {
            let parts: Vec<String> = obj.iter()
                .map(|(k, v)| format!("{} {}", v.as_array().map(|a| a.len()).unwrap_or(0), k))
                .collect();
            format!("{} = {} requests", parts.join(" Ã— "), total_requests)
        } else {
            format!("{} requests", total_requests)
        }
    } else {
        format!("{} requests", total_requests)
    };

    json!({
        "recommended_attack_type": attack_type,
        "justification": justification,
        "total_requests": total_requests,
        "request_formula": formula
    })
}

fn calculate_total_requests(payloads: &Value, positions: usize, attack_type: &str) -> i64 {
    if let Some(obj) = payloads.as_object() {
        let counts: Vec<i64> = obj.values()
            .filter_map(|v| v.as_array())
            .map(|a| a.len() as i64)
            .collect();

        match attack_type {
            "SNIPER" => counts.iter().sum(),
            "BATTERING_RAM" => counts.first().copied().unwrap_or(0),
            "PITCHFORK" => counts.iter().min().copied().unwrap_or(0),
            "CLUSTER_BOMB" | _ => counts.iter().product(),
        }
    } else {
        0
    }
}

fn analyze_results(results: &[Value]) -> Value {
    if results.is_empty() {
        return json!({
            "success_indicator": "No results to analyze",
            "likely_valid_credentials": null,
            "confidence": "NONE",
            "reasoning": "No results provided"
        });
    }

    // Extract lengths and statuses
    let lengths: Vec<i64> = results.iter()
        .filter_map(|r| r["length"].as_i64())
        .collect();

    let statuses: Vec<i64> = results.iter()
        .filter_map(|r| r["status"].as_i64())
        .collect();

    // Calculate baseline (most common length)
    let baseline_length = calculate_mode(&lengths);

    // Find anomalies
    let mut anomalies: Vec<(i64, &Value)> = results.iter()
        .filter_map(|r| {
            let len = r["length"].as_i64()?;
            let deviation = (len - baseline_length).abs();
            if deviation > 100 {  // Significant deviation threshold
                Some((deviation, r))
            } else {
                None
            }
        })
        .collect();

    anomalies.sort_by(|a, b| b.0.cmp(&a.0));  // Sort by deviation descending

    let (likely_valid, confidence, reasoning) = if let Some((deviation, anomaly)) = anomalies.first() {
        let creds = json!({
            "username": anomaly["username"],
            "password": anomaly["password"]
        });
        let conf = if *deviation > 500 { "HIGH" } else { "MEDIUM" };
        let reason = format!(
            "Response length {} differs significantly from baseline {} (deviation: {})",
            anomaly["length"], baseline_length, deviation
        );
        (creds, conf, reason)
    } else {
        // Check status code anomalies
        let status_anomaly = results.iter().find(|r| {
            let status = r["status"].as_i64().unwrap_or(0);
            status == 302 || status == 303 || (status >= 200 && status < 300 && status != 200)
        });

        if let Some(anomaly) = status_anomaly {
            (
                json!({"username": anomaly["username"], "password": anomaly["password"]}),
                "MEDIUM",
                format!("Status code {} suggests different response", anomaly["status"])
            )
        } else {
            (json!(null), "LOW", "No clear anomaly detected".to_string())
        }
    };

    json!({
        "success_indicator": if anomalies.is_empty() { "No clear indicator" } else { "Response length anomaly" },
        "baseline_length": baseline_length,
        "anomalous_response": anomalies.first().map(|(dev, r)| json!({
            "username": r["username"],
            "password": r["password"],
            "length": r["length"],
            "deviation": -dev
        })),
        "likely_valid_credentials": likely_valid,
        "confidence": confidence,
        "reasoning": reasoning
    })
}

fn calculate_mode(values: &[i64]) -> i64 {
    let mut counts: HashMap<i64, usize> = HashMap::new();
    for &v in values {
        *counts.entry(v).or_insert(0) += 1;
    }
    counts.into_iter()
        .max_by_key(|&(_, count)| count)
        .map(|(value, _)| value)
        .unwrap_or(0)
}

fn recommend_extensions(context: &Value) -> Vec<Value> {
    let mut extensions = vec![
        json!({
            "name": "Logger++",
            "reason": "Full request/response logging for forensics and debugging"
        })
    ];

    if context["waf_present"].as_bool().unwrap_or(false) {
        extensions.push(json!({
            "name": "WAF Bypass",
            "reason": "WAF detected - may need payload encoding and obfuscation"
        }));
        extensions.push(json!({
            "name": "Hackvertor",
            "reason": "Advanced payload encoding to evade WAF"
        }));
    }

    if context["csrf_token_required"].as_bool().unwrap_or(false) {
        extensions.push(json!({
            "name": "CSRF Token Tracker",
            "reason": "Automatically extract and update CSRF tokens between requests"
        }));
    }

    if context["rate_limit_detected"].as_bool().unwrap_or(false) {
        extensions.push(json!({
            "name": "Turbo Intruder",
            "reason": "Advanced rate limit handling with smart throttling"
        }));
    }

    // Always useful extensions
    extensions.push(json!({
        "name": "Autorize",
        "reason": "Test authorization bypass after finding valid credentials"
    }));

    extensions.push(json!({
        "name": "Param Miner",
        "reason": "Discover hidden parameters and headers"
    }));

    extensions
}

fn generate_nuclei_template(scenario: &str, target: &str) -> Value {
    let path = if target.contains("/login") { "/login" }
        else if target.contains("/api") { "/api" }
        else { "/" };

    let severity = match scenario.to_uppercase().as_str() {
        s if s.contains("BRUTE") || s.contains("CREDENTIAL") => "high",
        s if s.contains("SQL") || s.contains("INJECT") => "critical",
        s if s.contains("XSS") => "medium",
        _ => "info"
    };

    let template_id = format!("custom-{}", scenario.to_lowercase().replace("_", "-"));

    json!({
        "id": template_id,
        "info": {
            "name": format!("{} Detection", scenario.replace("_", " ")),
            "severity": severity,
            "author": "auditor",
            "tags": ["custom", "web"]
        },
        "template_content": format!(
            "id: {}\ninfo:\n  name: {} Detection\n  severity: {}\nrequests:\n  - method: POST\n    path:\n      - {}\n    matchers:\n      - type: status\n        status:\n          - 200",
            template_id, scenario, severity, path
        )
    })
}

fn generate_zap_config(target: &str) -> Value {
    json!({
        "spider_depth": 5,
        "ajax_spider": true,
        "active_scan_policy": "Default Policy",
        "auth_config": {
            "type": if target.contains("login") { "FORM_BASED" } else { "NONE" },
            "login_url": "/login",
            "login_params": ["username", "password"]
        }
    })
}

fn generate_recommendations(context: &Value, attack_analysis: &Value) -> Vec<String> {
    let mut recommendations = Vec::new();

    let attack_type = attack_analysis["recommended_attack_type"].as_str().unwrap_or("");

    // Attack-specific recommendations
    match attack_type {
        "SNIPER" => {
            recommendations.push("Use Sniper to identify valid usernames via timing/response differences".to_string());
            recommendations.push("Watch for subtle length variations indicating valid entries".to_string());
        }
        "CLUSTER_BOMB" => {
            recommendations.push("Start with Sniper to enumerate valid usernames first".to_string());
            recommendations.push("Switch to Cluster Bomb once valid username confirmed".to_string());
            recommendations.push("Monitor response length as primary success indicator".to_string());
        }
        "PITCHFORK" => {
            recommendations.push("Use Pitchfork for testing known credential pairs".to_string());
            recommendations.push("Ensure payload lists are properly aligned".to_string());
        }
        _ => {}
    }

    // Context-specific recommendations
    if context["csrf_token_required"].as_bool().unwrap_or(false) {
        recommendations.push("Configure Burp macros to extract and update CSRF tokens".to_string());
    }

    if context["rate_limit_detected"].as_bool().unwrap_or(false) {
        recommendations.push("Implement throttling in Intruder to avoid rate limiting".to_string());
        recommendations.push("Consider using IP rotation via proxy chain".to_string());
    }

    if context["waf_present"].as_bool().unwrap_or(false) {
        recommendations.push("Test payload encoding (URL, HTML, Unicode) to bypass WAF".to_string());
        recommendations.push("Use random User-Agent and delay between requests".to_string());
    }

    recommendations
}
```

### 4.9 spec.json

```json
{
  "name": "burp_suite_mastery",
  "language": "rust",
  "version": "edition2024",
  "type": "code",
  "tier": 1,
  "tags": ["security", "burp", "web", "tools", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "burp_suite_mastery",
    "prototype": "pub fn burp_suite_mastery(input_json: &str) -> String",
    "return_type": "String"
  },

  "security_checks": {
    "owasp_category": "A07:2021-Identification and Authentication Failures"
  }
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A: Toujours recommande CLUSTER_BOMB
pub fn mutant_a(input_json: &str) -> String {
    json!({"attack_analysis": {"recommended_attack_type": "CLUSTER_BOMB"}}).to_string()
}
// Pourquoi faux: SNIPER est meilleur pour 1 position

// Mutant B: Ignore les anomalies de longueur
pub fn mutant_b(input_json: &str) -> String {
    // Ne dÃ©tecte pas les variations de response length
}

// Mutant C: Pas d'extensions pour WAF
pub fn mutant_c(input_json: &str) -> String {
    // Ignore context.waf_present
}

// Mutant D: Mauvais calcul du nombre de requÃªtes
pub fn mutant_d(input_json: &str) -> String {
    // Additionne au lieu de multiplier pour CLUSTER_BOMB
}

// Mutant E: Template Nuclei invalide
pub fn mutant_e(input_json: &str) -> String {
    // GÃ©nÃ¨re un template sans id ou severity
}

// Mutant F: Ignore CSRF tokens
pub fn mutant_f(input_json: &str) -> String {
    // Ne recommande pas CSRF Token Tracker
}
```

---

## ğŸ§  SECTION 5-9

*(Sections similaires aux exercices prÃ©cÃ©dents - LDA, visualisation ASCII, QCM, etc.)*

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Exercice** | 3.3.12-a Burp Suite Mastery |
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| **XP Base** | 400 |
| **Concepts clÃ©s** | Intruder, Scanner, Extensions, Nuclei |
| **Temps** | ~4h |

---

*"I'm MacGyver. I can fix anything." â€” Burp Suite est ton couteau suisse.*

*HACKBRAIN v5.5.2 â€” L'excellence n'a pas de raccourcis*
