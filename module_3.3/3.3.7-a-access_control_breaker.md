# Exercice 3.3.7-a : access_control_breaker

**Module :**
3.3.7 â€” Access Control & Authorization

**Concept :**
a â€” Access Control Breaker (IDOR, Escalation, Path Traversal)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
pratique

**Tiers :**
2 â€” MÃ©lange (concepts a + b + c + d + e + f : IDOR + Escalations + Path Traversal)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- HTTP REST APIs
- Authentification/Autorisation
- URL encoding
- ModÃ¨le de contrÃ´le d'accÃ¨s RBAC

**Domaines :**
Net, FS, Encodage

**DurÃ©e estimÃ©e :**
240 min

**XP Base :**
300

**ComplexitÃ© :**
T2 O(n Ã— m) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`access_control_breaker.rs`

**Fonctions autorisÃ©es :**
- `serde_json` pour le parsing JSON
- `regex` pour la dÃ©tection de patterns
- `url` pour le parsing d'URLs
- Fonctions standard Rust

**Fonctions interdites :**
- Librairies de scan automatisÃ©
- RequÃªtes HTTP rÃ©elles (simulation uniquement)

---

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Prison Break"

*"I'm looking for someone. A guy about 6'1", brown hair, blue eyes. Goes by the name of Michael Scofield."* â€” Brad Bellick

Tu es **Michael Scofield**, l'ingÃ©nieur structural qui a mÃ©morisÃ© les plans de Fox River pour s'Ã©chapper. Mais au lieu de murs en bÃ©ton, tu fais face Ã  des **contrÃ´les d'accÃ¨s applicatifs** â€” et comme toute prison, ils ont des **failles structurelles**.

Chaque application web est une prison : les murs sont les autorisations, les gardiens sont les middlewares, les cellules sont les ressources protÃ©gÃ©es. Mais toi, tu vois ce que les autres ne voient pas : les **tuyaux cachÃ©s** (IDOR), les **couloirs non surveillÃ©s** (forced browsing), les **passages secrets** (path traversal).

**Tes techniques d'Ã©vasion :**
- **IDOR** : Changer l'ID pour accÃ©der Ã  la cellule d'un autre dÃ©tenu
- **Escalade Horizontale** : AccÃ©der aux ressources d'un utilisateur de mÃªme niveau
- **Escalade Verticale** : Obtenir les privilÃ¨ges du directeur de la prison
- **Path Traversal** : Sortir de ta cellule via les conduits de ventilation

Lincoln est en couloir de la mort. Tu dois trouver TOUTES les failles pour orchestrer l'Ã©vasion parfaite.

---

#### 1.2.2 Ã‰noncÃ© AcadÃ©mique

**Ta mission :**

Ã‰crire une fonction `access_control_breaker` qui analyse des endpoints d'API et dÃ©tecte les vulnÃ©rabilitÃ©s de contrÃ´le d'accÃ¨s (OWASP A01:2021 - Broken Access Control).

**EntrÃ©e (JSON) :**
- `endpoints` : Liste des endpoints Ã  analyser
  - `method` : MÃ©thode HTTP (GET, POST, PUT, DELETE)
  - `path` : Chemin de l'endpoint avec variables (ex: `/api/users/{id}`)
  - `auth` : Type d'authentification requis
  - `required_role` : RÃ´le minimum requis (optionnel)
- `current_user` : Utilisateur actuel
  - `id` : Identifiant unique
  - `role` : RÃ´le (user, admin, moderator...)
  - `permissions` : Liste des permissions
- `response_samples` : Ã‰chantillons de rÃ©ponses pour analyse

**Sortie (JSON) :**
- `vulnerabilities` : Liste des failles dÃ©tectÃ©es
  - `type` : Type de vulnÃ©rabilitÃ© (IDOR, VERTICAL_ESCALATION, HORIZONTAL_ESCALATION, PATH_TRAVERSAL, FORCED_BROWSING, PARAMETER_TAMPERING)
  - `endpoint` : Endpoint concernÃ©
  - `test` : Test Ã  effectuer
  - `expected` : Comportement attendu (sÃ©curisÃ©)
  - `actual` : Comportement observÃ© (vulnÃ©rable)
  - `owasp` : RÃ©fÃ©rence OWASP
  - `cwe` : Code CWE
  - `severity` : GravitÃ© (LOW, MEDIUM, HIGH, CRITICAL)
- `remediation` : Recommandations de correction par type

**Contraintes :**
- DÃ©tecter les IDORs mÃªme avec des UUIDs (pas seulement des entiers)
- Tester les encodages multiples pour path traversal (../, %2e%2e%2f, ....//...)
- Identifier les endpoints admin accessibles avec des tokens user
- Proposer des remÃ©diations spÃ©cifiques et actionnables
- Retourner un JSON valide mÃªme en cas d'erreur

**Exemples :**

| EntrÃ©e | Sortie | Explication |
|--------|--------|-------------|
| GET /users/{id} accessible Ã  tous | IDOR dÃ©tectÃ© | Pas de vÃ©rification user.id == {id} |
| GET /admin/users avec user_token | VERTICAL_ESCALATION | Endpoint admin accessible sans rÃ´le admin |
| GET /files?name=report.pdf | PATH_TRAVERSAL si ../ acceptÃ© | Absence de sanitization |
| POST /api/transfer avec amount param | PARAMETER_TAMPERING possible | Valeur modifiable cÃ´tÃ© client |

---

### 1.3 Prototype

```rust
/// Access Control Breaker - Michael Scofield's Escape Plan
///
/// Analyse des endpoints d'API pour dÃ©tecter les failles de contrÃ´le d'accÃ¨s
/// incluant IDOR, escalades de privilÃ¨ges et path traversal.
///
/// # Arguments
/// * `input_json` - Configuration JSON avec endpoints, current_user, response_samples
///
/// # Returns
/// * JSON string avec vulnerabilities et remediation
pub fn access_control_breaker(input_json: &str) -> String
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 IDOR : La faille la plus sous-estimÃ©e

Les IDORs (Insecure Direct Object References) reprÃ©sentent **une des vulnÃ©rabilitÃ©s les plus courantes et les plus impactantes**. En 2021, OWASP les a regroupÃ©es dans A01:2021 - Broken Access Control, qui est passÃ© de la 5Ã¨me Ã  la **1Ã¨re position**.

Exemple rÃ©el : En 2019, un bug bounty hunter a dÃ©couvert qu'il pouvait accÃ©der aux factures de TOUS les clients d'une grande entreprise en incrÃ©mentant simplement l'ID dans l'URL. Impact : donnÃ©es financiÃ¨res de millions de clients exposÃ©es.

### 2.2 UUID != SÃ©curitÃ©

Beaucoup de dÃ©veloppeurs pensent que remplacer les IDs numÃ©riques par des UUIDs rÃ©sout le problÃ¨me. **C'est faux.**

```
# ID numÃ©rique - facile Ã  deviner
GET /api/orders/12345

# UUID - plus difficile Ã  deviner MAIS...
GET /api/orders/550e8400-e29b-41d4-a716-446655440000

# Le vrai problÃ¨me : pas de vÃ©rification d'autorisation !
# MÃªme avec un UUID, si je le connais, j'y accÃ¨de.
```

### 2.3 Path Traversal : Les multiples visages de ../

Les WAFs bloquent `../` mais oublient souvent :
- `....//` (double encoding du /)
- `%2e%2e%2f` (URL encoded)
- `%252e%252e%252f` (double URL encoded)
- `..%c0%af` (UTF-8 overlong encoding)
- `..%ef%bc%8f` (Unicode full-width slash)

---

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation de ces concepts |
|--------|----------------------------|
| **Pentester Web** | Test systÃ©matique de tous les IDORs sur chaque assessment |
| **Bug Bounty Hunter** | IDOR reprÃ©sente ~30% des bugs critiques payÃ©s |
| **Security Engineer** | ImplÃ©mente des middlewares d'autorisation centralisÃ©s |
| **DevSecOps** | Automatise la dÃ©tection d'endpoints sans auth dans CI/CD |
| **Architecte SÃ©curitÃ©** | ConÃ§oit des modÃ¨les RBAC/ABAC robustes |

**Bug Bounties notables :**
- **2019 - Facebook** : $25,000 pour un IDOR sur les photos privÃ©es
- **2020 - Shopify** : $15,000 pour escalade horizontale sur les stores
- **2021 - US DoD** : Multiples IDORs sur des systÃ¨mes militaires

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
access_control_breaker.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
Test 1 - IDOR on /api/users/{id}/profile: DETECTED
  Test: Change id=123 to id=124
  Expected: 403 Forbidden
  Actual: 200 OK with other user data

Test 2 - Vertical Escalation on /api/admin/users: DETECTED
  Issue: Admin endpoint accessible with user token

Test 3 - Path Traversal on /files: DETECTED
  Payloads: ../, ....//,  %2e%2e%2f
  Vulnerable to: ../../../etc/passwd

Test 4 - Forced Browsing on /backup/: DETECTED
  Unlinked admin directory accessible

Test 5 - Parameter Tampering on /api/transfer: DETECTED
  Issue: amount parameter modifiable

All access control tests completed!
Fox River has 5 structural weaknesses.
```

---

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(n Ã— m Ã— p) oÃ¹ p = payloads testÃ©s

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Crypto, MD`

#### 3.1.1 Consigne Bonus

**ğŸ¬ L'Ã©vasion de Sona**

Fox River Ã©tait facile. Maintenant tu dois t'Ã©vader de **Sona** â€” une prison sans murs mais avec des contrÃ´les invisibles. Tu dois :

1. **Bypass de contrÃ´les basÃ©s sur les headers** : X-Forwarded-For, X-Original-URL
2. **Race conditions sur les autorisations** : TOCTOU (Time-of-check to time-of-use)
3. **JWT role tampering** : Modifier les claims de rÃ´le
4. **Multi-tenant isolation bypass** : AccÃ©der aux donnÃ©es d'autres tenants

**EntrÃ©e additionnelle :**
```json
{
  "headers_to_test": ["X-Forwarded-For", "X-Original-URL", "X-Rewrite-URL"],
  "jwt_token": "eyJ...",
  "tenant_id": "tenant_123",
  "race_condition_endpoints": ["/api/approve", "/api/transfer"]
}
```

**Sortie additionnelle :**
```json
{
  "header_bypass": [
    {"header": "X-Original-URL", "payload": "/admin", "result": "bypassed"}
  ],
  "race_conditions": [
    {"endpoint": "/api/approve", "technique": "parallel_requests", "exploitable": true}
  ],
  "tenant_isolation": [
    {"test": "Change tenant_123 to tenant_456", "isolated": false}
  ]
}
```

#### 3.1.2 Prototype Bonus

```rust
pub fn access_control_breaker_advanced(input_json: &str) -> String
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Header bypass | Non | X-Original-URL, X-Forwarded-For |
| Race conditions | Non | TOCTOU detection |
| Multi-tenant | Non | Isolation testing |
| ComplexitÃ© | O(n Ã— m) | O(n Ã— m Ã— p) |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_idor_integer_id` | /users/{id} sans auth check | IDOR dÃ©tectÃ© | 10 |
| `test_idor_uuid` | /orders/{uuid} sans auth check | IDOR dÃ©tectÃ© mÃªme avec UUID | 10 |
| `test_vertical_escalation` | /admin avec user token | VERTICAL_ESCALATION | 15 |
| `test_horizontal_escalation` | /users/other_user/data | HORIZONTAL_ESCALATION | 10 |
| `test_path_traversal_basic` | ../ dans filename | PATH_TRAVERSAL | 10 |
| `test_path_traversal_encoded` | %2e%2e%2f | PATH_TRAVERSAL | 10 |
| `test_path_traversal_double` | ....// | PATH_TRAVERSAL | 10 |
| `test_forced_browsing` | /backup/ non liÃ© | FORCED_BROWSING | 10 |
| `test_parameter_tampering` | amount modifiable | PARAMETER_TAMPERING | 10 |
| `test_remediation_generated` | Toute vulnÃ©rabilitÃ© | Remediation spÃ©cifique | 10 |
| `test_null_handling` | Inputs null | Pas de crash | 5 |
| `test_invalid_json` | JSON malformÃ© | Erreur gracieuse | 5 |

**Total : 115 points** (Bonus : +50 points)

---

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod access_control_breaker;
use access_control_breaker::access_control_breaker;

fn main() {
    println!("=== Access Control Breaker - Test Runner ===\n");

    // Test 1: IDOR Detection
    let test_idor = json!({
        "endpoints": [
            {
                "method": "GET",
                "path": "/api/users/{id}/profile",
                "auth": "user_token",
                "auth_check": "none"
            }
        ],
        "current_user": {"id": 123, "role": "user", "permissions": []},
        "response_samples": {
            "/api/users/123/profile": {"status": 200, "body": {"name": "Current User"}},
            "/api/users/124/profile": {"status": 200, "body": {"name": "Other User"}}
        }
    });

    let result = access_control_breaker(&test_idor.to_string());
    let parsed: Value = serde_json::from_str(&result).expect("Invalid JSON output");

    assert!(parsed["vulnerabilities"]
        .as_array()
        .unwrap()
        .iter()
        .any(|v| v["type"] == "IDOR"));
    println!("âœ“ Test 1 - IDOR Detection: PASSED");

    // Test 2: Vertical Escalation
    let test_vertical = json!({
        "endpoints": [
            {
                "method": "GET",
                "path": "/api/admin/users",
                "auth": "user_token",
                "required_role": "admin"
            }
        ],
        "current_user": {"id": 123, "role": "user", "permissions": []},
        "response_samples": {
            "/api/admin/users": {"status": 200, "body": [{"id": 1}, {"id": 2}]}
        }
    });

    let result = access_control_breaker(&test_vertical.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["vulnerabilities"]
        .as_array()
        .unwrap()
        .iter()
        .any(|v| v["type"] == "VERTICAL_ESCALATION"));
    println!("âœ“ Test 2 - Vertical Escalation: PASSED");

    // Test 3: Path Traversal
    let test_path = json!({
        "endpoints": [
            {
                "method": "GET",
                "path": "/files",
                "auth": "none",
                "params": ["name"]
            }
        ],
        "current_user": {"id": 123, "role": "user", "permissions": []},
        "response_samples": {
            "/files?name=../../../etc/passwd": {"status": 200, "body": "root:x:0:0:..."}
        }
    });

    let result = access_control_breaker(&test_path.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["vulnerabilities"]
        .as_array()
        .unwrap()
        .iter()
        .any(|v| v["type"] == "PATH_TRAVERSAL"));
    println!("âœ“ Test 3 - Path Traversal: PASSED");

    // Test 4: Remediation generation
    assert!(parsed.get("remediation").is_some());
    println!("âœ“ Test 4 - Remediation Generated: PASSED");

    // Test 5: Invalid input handling
    let test_invalid = json!({
        "endpoints": null,
        "current_user": null,
        "response_samples": null
    });

    let result = access_control_breaker(&test_invalid.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();
    assert!(!result.contains("panic"));
    println!("âœ“ Test 5 - Invalid Input Handling: PASSED");

    println!("\n=== All Tests Passed! The plan is ready. ===");
}
```

---

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STRUCTURES DE DONNÃ‰ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#[derive(Debug, Deserialize)]
struct Input {
    endpoints: Option<Vec<Endpoint>>,
    current_user: Option<CurrentUser>,
    response_samples: Option<HashMap<String, ResponseSample>>,
}

#[derive(Debug, Deserialize, Clone)]
struct Endpoint {
    method: String,
    path: String,
    auth: Option<String>,
    auth_check: Option<String>,
    required_role: Option<String>,
    params: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct CurrentUser {
    id: Value,
    role: String,
    permissions: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct ResponseSample {
    status: u16,
    body: Value,
}

#[derive(Debug, Serialize)]
struct Output {
    vulnerabilities: Vec<Vulnerability>,
    remediation: HashMap<String, String>,
}

#[derive(Debug, Serialize, Clone)]
struct Vulnerability {
    #[serde(rename = "type")]
    vuln_type: String,
    endpoint: String,
    test: String,
    expected: String,
    actual: String,
    owasp: String,
    cwe: String,
    severity: String,
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DÃ‰TECTION IDOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn detect_idor(
    endpoint: &Endpoint,
    current_user: &CurrentUser,
    responses: &Option<HashMap<String, ResponseSample>>,
) -> Option<Vulnerability> {
    // Check if path contains ID parameter
    if !endpoint.path.contains("{id}") && !endpoint.path.contains("{uuid}") {
        return None;
    }

    // Check if there's no authorization check
    let auth_check = endpoint.auth_check.as_deref().unwrap_or("unknown");

    if auth_check == "none" || auth_check == "unknown" {
        // Check response samples for evidence
        let current_id = match &current_user.id {
            Value::Number(n) => n.to_string(),
            Value::String(s) => s.clone(),
            _ => "123".to_string(),
        };

        let other_id = increment_id(&current_id);

        let path_current = endpoint.path.replace("{id}", &current_id).replace("{uuid}", &current_id);
        let path_other = endpoint.path.replace("{id}", &other_id).replace("{uuid}", &other_id);

        // Check if both return 200
        if let Some(ref samples) = responses {
            let current_ok = samples.get(&path_current)
                .map(|r| r.status == 200)
                .unwrap_or(false);
            let other_ok = samples.get(&path_other)
                .map(|r| r.status == 200)
                .unwrap_or(true); // Assume vulnerable if no sample

            if current_ok || other_ok {
                return Some(Vulnerability {
                    vuln_type: "IDOR".to_string(),
                    endpoint: format!("{} {}", endpoint.method, endpoint.path),
                    test: format!("Change {}={} to {}={}",
                        if endpoint.path.contains("{uuid}") { "uuid" } else { "id" },
                        current_id,
                        if endpoint.path.contains("{uuid}") { "uuid" } else { "id" },
                        other_id),
                    expected: "403 Forbidden or filtered data".to_string(),
                    actual: "200 OK with other user's data".to_string(),
                    owasp: "A01:2021 - Broken Access Control".to_string(),
                    cwe: "CWE-639".to_string(),
                    severity: "HIGH".to_string(),
                });
            }
        } else {
            // No samples, flag as potential IDOR
            return Some(Vulnerability {
                vuln_type: "IDOR".to_string(),
                endpoint: format!("{} {}", endpoint.method, endpoint.path),
                test: format!("Test changing the ID parameter to another user's ID"),
                expected: "403 Forbidden".to_string(),
                actual: "Potentially accessible - requires manual testing".to_string(),
                owasp: "A01:2021 - Broken Access Control".to_string(),
                cwe: "CWE-639".to_string(),
                severity: "MEDIUM".to_string(),
            });
        }
    }

    None
}

fn increment_id(id: &str) -> String {
    // Try to parse as integer
    if let Ok(num) = id.parse::<i64>() {
        return (num + 1).to_string();
    }

    // For UUIDs, generate a different one
    if id.len() == 36 && id.contains('-') {
        // Modify last character
        let mut chars: Vec<char> = id.chars().collect();
        if let Some(last) = chars.last_mut() {
            *last = if *last == '0' { '1' } else { '0' };
        }
        return chars.into_iter().collect();
    }

    // Default: append a character
    format!("{}1", id)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DÃ‰TECTION ESCALADE VERTICALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn detect_vertical_escalation(
    endpoint: &Endpoint,
    current_user: &CurrentUser,
    responses: &Option<HashMap<String, ResponseSample>>,
) -> Option<Vulnerability> {
    // Check if endpoint requires higher role
    let required_role = endpoint.required_role.as_deref().unwrap_or("user");

    // Define role hierarchy
    let role_level = |role: &str| -> u8 {
        match role.to_lowercase().as_str() {
            "superadmin" | "root" => 100,
            "admin" | "administrator" => 80,
            "moderator" | "mod" => 60,
            "editor" => 40,
            "user" => 20,
            "guest" | "anonymous" => 10,
            _ => 20,
        }
    };

    let current_level = role_level(&current_user.role);
    let required_level = role_level(required_role);

    // Also check path patterns suggesting admin access
    let admin_patterns = ["/admin", "/manage", "/dashboard", "/config", "/settings/system"];
    let is_admin_path = admin_patterns.iter().any(|p| endpoint.path.to_lowercase().contains(p));

    if current_level < required_level || (is_admin_path && current_level < 80) {
        // Check if response shows it's accessible
        if let Some(ref samples) = responses {
            let full_path = format!("{}", endpoint.path);
            if let Some(response) = samples.get(&full_path) {
                if response.status == 200 {
                    return Some(Vulnerability {
                        vuln_type: "VERTICAL_ESCALATION".to_string(),
                        endpoint: format!("{} {}", endpoint.method, endpoint.path),
                        test: format!("Access with {} token (role: {})",
                            endpoint.auth.as_deref().unwrap_or("user"),
                            current_user.role),
                        expected: format!("403 Forbidden (requires {} role)", required_role),
                        actual: "200 OK - Admin endpoint accessible".to_string(),
                        owasp: "A01:2021 - Broken Access Control".to_string(),
                        cwe: "CWE-269".to_string(),
                        severity: "CRITICAL".to_string(),
                    });
                }
            }
        }

        // Flag as potential even without sample
        if is_admin_path {
            return Some(Vulnerability {
                vuln_type: "VERTICAL_ESCALATION".to_string(),
                endpoint: format!("{} {}", endpoint.method, endpoint.path),
                test: format!("Access admin endpoint with user token"),
                expected: "403 Forbidden".to_string(),
                actual: "Requires testing - admin path accessible to user role".to_string(),
                owasp: "A01:2021 - Broken Access Control".to_string(),
                cwe: "CWE-269".to_string(),
                severity: "HIGH".to_string(),
            });
        }
    }

    None
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DÃ‰TECTION PATH TRAVERSAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn detect_path_traversal(
    endpoint: &Endpoint,
    responses: &Option<HashMap<String, ResponseSample>>,
) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();

    // Check if endpoint has file-related parameters
    let file_params = ["name", "file", "filename", "path", "doc", "document", "template"];
    let has_file_param = endpoint.params.as_ref()
        .map(|params| params.iter().any(|p| file_params.contains(&p.to_lowercase().as_str())))
        .unwrap_or(false);

    // Also check path patterns
    let file_patterns = ["/files", "/download", "/upload", "/doc", "/static", "/assets"];
    let is_file_endpoint = file_patterns.iter().any(|p| endpoint.path.to_lowercase().contains(p));

    if has_file_param || is_file_endpoint {
        // Path traversal payloads to test
        let payloads = [
            ("../../../etc/passwd", "Basic traversal"),
            ("....//....//....//etc/passwd", "Double dot bypass"),
            ("%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd", "URL encoded"),
            ("%252e%252e%252f", "Double URL encoded"),
            ("..%c0%af..%c0%af", "UTF-8 overlong"),
            ("....\\\\....\\\\", "Windows backslash"),
        ];

        for (payload, technique) in payloads {
            // Check response samples
            if let Some(ref samples) = responses {
                let test_path = if has_file_param {
                    format!("{}?name={}", endpoint.path, payload)
                } else {
                    format!("{}/{}", endpoint.path, payload)
                };

                if let Some(response) = samples.get(&test_path) {
                    if response.status == 200 {
                        vulns.push(Vulnerability {
                            vuln_type: "PATH_TRAVERSAL".to_string(),
                            endpoint: format!("{} {}", endpoint.method, endpoint.path),
                            test: format!("Payload: {}", payload),
                            expected: "400 Bad Request or sanitized path".to_string(),
                            actual: format!("200 OK - {} technique succeeded", technique),
                            owasp: "A01:2021 - Broken Access Control".to_string(),
                            cwe: "CWE-22".to_string(),
                            severity: "HIGH".to_string(),
                        });
                        break; // One successful payload is enough
                    }
                }
            }
        }

        // If no samples, flag as potential
        if vulns.is_empty() && (has_file_param || is_file_endpoint) {
            vulns.push(Vulnerability {
                vuln_type: "PATH_TRAVERSAL".to_string(),
                endpoint: format!("{} {}", endpoint.method, endpoint.path),
                test: "Test with payloads: ../, ....//,  %2e%2e%2f".to_string(),
                expected: "Path should be sanitized".to_string(),
                actual: "Requires testing - file parameter detected".to_string(),
                owasp: "A01:2021 - Broken Access Control".to_string(),
                cwe: "CWE-22".to_string(),
                severity: "MEDIUM".to_string(),
            });
        }
    }

    vulns
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DÃ‰TECTION FORCED BROWSING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn detect_forced_browsing(
    endpoint: &Endpoint,
    responses: &Option<HashMap<String, ResponseSample>>,
) -> Option<Vulnerability> {
    // Check for sensitive unlinked paths
    let sensitive_paths = [
        "/backup", "/admin", "/debug", "/test", "/dev",
        "/.git", "/.env", "/config", "/logs", "/tmp"
    ];

    let is_sensitive = sensitive_paths.iter()
        .any(|p| endpoint.path.to_lowercase().contains(p));

    // Check if auth is none or weak
    let weak_auth = endpoint.auth.as_deref()
        .map(|a| a == "none" || a == "optional")
        .unwrap_or(true);

    if is_sensitive && weak_auth {
        if let Some(ref samples) = responses {
            if let Some(response) = samples.get(&endpoint.path) {
                if response.status == 200 {
                    return Some(Vulnerability {
                        vuln_type: "FORCED_BROWSING".to_string(),
                        endpoint: format!("{} {}", endpoint.method, endpoint.path),
                        test: "Direct access to unlinked sensitive path".to_string(),
                        expected: "404 Not Found or 403 Forbidden".to_string(),
                        actual: "200 OK - Sensitive directory accessible".to_string(),
                        owasp: "A01:2021 - Broken Access Control".to_string(),
                        cwe: "CWE-425".to_string(),
                        severity: "MEDIUM".to_string(),
                    });
                }
            }
        }

        return Some(Vulnerability {
            vuln_type: "FORCED_BROWSING".to_string(),
            endpoint: format!("{} {}", endpoint.method, endpoint.path),
            test: "Check if sensitive path is directly accessible".to_string(),
            expected: "Path should require authentication".to_string(),
            actual: "Potentially accessible - no auth required".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
            cwe: "CWE-425".to_string(),
            severity: "LOW".to_string(),
        });
    }

    None
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DÃ‰TECTION PARAMETER TAMPERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn detect_parameter_tampering(endpoint: &Endpoint) -> Option<Vulnerability> {
    // Sensitive parameters that shouldn't be client-modifiable
    let sensitive_params = [
        "price", "amount", "total", "discount", "role", "admin",
        "is_admin", "user_id", "owner_id", "permission", "status"
    ];

    if let Some(ref params) = endpoint.params {
        for param in params {
            let param_lower = param.to_lowercase();
            if sensitive_params.iter().any(|s| param_lower.contains(s)) {
                return Some(Vulnerability {
                    vuln_type: "PARAMETER_TAMPERING".to_string(),
                    endpoint: format!("{} {}", endpoint.method, endpoint.path),
                    test: format!("Modify '{}' parameter in request", param),
                    expected: "Parameter should be server-side only".to_string(),
                    actual: "Sensitive parameter exposed to client".to_string(),
                    owasp: "A01:2021 - Broken Access Control".to_string(),
                    cwe: "CWE-639".to_string(),
                    severity: "MEDIUM".to_string(),
                });
            }
        }
    }

    None
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GÃ‰NÃ‰RATION DES REMÃ‰DIATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn generate_remediation(vulns: &[Vulnerability]) -> HashMap<String, String> {
    let mut remediation = HashMap::new();

    let vuln_types: Vec<&str> = vulns.iter().map(|v| v.vuln_type.as_str()).collect();

    if vuln_types.contains(&"IDOR") {
        remediation.insert(
            "IDOR".to_string(),
            "Implement authorization checks:\n\
             1. Always verify user.id == requested_resource.owner_id\n\
             2. Use middleware: if (!canAccess(user, resource)) return 403\n\
             3. Never trust client-provided IDs without verification\n\
             4. UUIDs don't replace authorization - still validate ownership".to_string()
        );
    }

    if vuln_types.contains(&"VERTICAL_ESCALATION") {
        remediation.insert(
            "VERTICAL_ESCALATION".to_string(),
            "Implement role-based access control (RBAC):\n\
             1. Define role hierarchy: guest < user < moderator < admin\n\
             2. Check role on every request: if (user.role < requiredRole) return 403\n\
             3. Use decorators/middleware: @RequireRole('admin')\n\
             4. Never rely on hidden URLs as security".to_string()
        );
    }

    if vuln_types.contains(&"PATH_TRAVERSAL") {
        remediation.insert(
            "PATH_TRAVERSAL".to_string(),
            "Sanitize file paths:\n\
             1. Use basename() to extract filename only\n\
             2. Reject paths containing .. or encoded variants\n\
             3. Use allowlist of permitted directories\n\
             4. Normalize path before validation: realpath()\n\
             5. Check final path starts with expected directory".to_string()
        );
    }

    if vuln_types.contains(&"FORCED_BROWSING") {
        remediation.insert(
            "FORCED_BROWSING".to_string(),
            "Protect sensitive directories:\n\
             1. Remove or restrict access to backup/debug paths\n\
             2. Configure web server to deny directory listing\n\
             3. Use authentication on all sensitive endpoints\n\
             4. Remove unnecessary files from production".to_string()
        );
    }

    if vuln_types.contains(&"PARAMETER_TAMPERING") {
        remediation.insert(
            "PARAMETER_TAMPERING".to_string(),
            "Protect sensitive parameters:\n\
             1. Never trust client-provided prices/amounts\n\
             2. Calculate sensitive values server-side\n\
             3. Use signed/encrypted parameters if needed client-side\n\
             4. Validate all parameters against business rules".to_string()
        );
    }

    remediation
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FONCTION PRINCIPALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pub fn access_control_breaker(input_json: &str) -> String {
    // Parse input
    let input: Input = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => {
            return json!({
                "error": format!("Invalid input JSON: {}", e),
                "vulnerabilities": [],
                "remediation": {}
            }).to_string();
        }
    };

    let mut vulnerabilities = Vec::new();

    // Get endpoints or return empty
    let endpoints = match input.endpoints {
        Some(e) => e,
        None => {
            return json!({
                "vulnerabilities": [],
                "remediation": {},
                "warning": "No endpoints provided"
            }).to_string();
        }
    };

    // Get current user or default
    let current_user = input.current_user.unwrap_or(CurrentUser {
        id: Value::Number(serde_json::Number::from(0)),
        role: "user".to_string(),
        permissions: None,
    });

    // Analyze each endpoint
    for endpoint in &endpoints {
        // IDOR Detection
        if let Some(vuln) = detect_idor(endpoint, &current_user, &input.response_samples) {
            vulnerabilities.push(vuln);
        }

        // Vertical Escalation Detection
        if let Some(vuln) = detect_vertical_escalation(endpoint, &current_user, &input.response_samples) {
            vulnerabilities.push(vuln);
        }

        // Path Traversal Detection
        let path_vulns = detect_path_traversal(endpoint, &input.response_samples);
        vulnerabilities.extend(path_vulns);

        // Forced Browsing Detection
        if let Some(vuln) = detect_forced_browsing(endpoint, &input.response_samples) {
            vulnerabilities.push(vuln);
        }

        // Parameter Tampering Detection
        if let Some(vuln) = detect_parameter_tampering(endpoint) {
            vulnerabilities.push(vuln);
        }
    }

    // Generate remediation
    let remediation = generate_remediation(&vulnerabilities);

    let output = Output {
        vulnerabilities,
        remediation,
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|e| {
        json!({ "error": format!("Serialization error: {}", e) }).to_string()
    })
}
```

---

### 4.4 Solutions alternatives acceptÃ©es

#### Alternative 1 : Avec pattern matching Rust

```rust
// Style plus idiomatique avec match
fn detect_vulnerability(endpoint: &Endpoint, user: &CurrentUser) -> Vec<Vulnerability> {
    match (&endpoint.path, &endpoint.auth_check) {
        (path, Some(check)) if path.contains("{id}") && check == "none" => {
            vec![create_idor_vuln(endpoint)]
        }
        (path, _) if path.contains("/admin") => {
            vec![create_vertical_vuln(endpoint, user)]
        }
        _ => vec![]
    }
}
```

#### Alternative 2 : Approche par traits

```rust
trait VulnerabilityDetector {
    fn detect(&self, endpoint: &Endpoint, context: &Context) -> Option<Vulnerability>;
}

struct IdorDetector;
struct PathTraversalDetector;
struct VerticalEscalationDetector;

impl VulnerabilityDetector for IdorDetector {
    fn detect(&self, endpoint: &Endpoint, context: &Context) -> Option<Vulnerability> {
        // Detection logic
    }
}
```

---

### 4.5 Solutions refusÃ©es

#### RefusÃ©e 1 : DÃ©tection UUID-only basÃ©e sur le format

```rust
// âŒ REFUSÃ‰ : Assume que les UUIDs sont sÃ©curisÃ©s
fn detect_idor_wrong(endpoint: &Endpoint) -> Option<Vulnerability> {
    if endpoint.path.contains("{id}") {
        // Check if ID looks like integer
        return Some(/* IDOR */);
    }
    // UUID = pas de IDOR ?  FAUX !
    None
}
```
**Raison :** Les UUIDs ne remplacent pas l'autorisation.

#### RefusÃ©e 2 : Path traversal sans encodages multiples

```rust
// âŒ REFUSÃ‰ : Ne teste que ../
fn detect_path_traversal_wrong(path: &str) -> bool {
    path.contains("../")  // Manque %2e%2e, ....//,  etc.
}
```
**Raison :** Les WAFs bloquent ../ mais pas les variantes encodÃ©es.

---

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
// Extension pour header bypass
fn detect_header_bypass(
    endpoint: &Endpoint,
    headers_to_test: &[String],
) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();

    let bypass_headers = [
        ("X-Original-URL", "/admin"),
        ("X-Rewrite-URL", "/admin"),
        ("X-Forwarded-For", "127.0.0.1"),
        ("X-Real-IP", "127.0.0.1"),
    ];

    for (header, value) in bypass_headers {
        if headers_to_test.contains(&header.to_string()) {
            vulns.push(Vulnerability {
                vuln_type: "HEADER_BYPASS".to_string(),
                endpoint: format!("{} {}", endpoint.method, endpoint.path),
                test: format!("Add header {}: {}", header, value),
                expected: "Header should not bypass access control".to_string(),
                actual: "Potential bypass - requires testing".to_string(),
                owasp: "A01:2021 - Broken Access Control".to_string(),
                cwe: "CWE-287".to_string(),
                severity: "HIGH".to_string(),
            });
        }
    }

    vulns
}

// Extension pour race conditions
fn detect_race_condition(endpoint: &Endpoint) -> Option<Vulnerability> {
    let race_prone_patterns = ["/approve", "/transfer", "/withdraw", "/purchase"];

    if race_prone_patterns.iter().any(|p| endpoint.path.contains(p)) {
        return Some(Vulnerability {
            vuln_type: "RACE_CONDITION".to_string(),
            endpoint: format!("{} {}", endpoint.method, endpoint.path),
            test: "Send multiple parallel requests".to_string(),
            expected: "Only one request should succeed".to_string(),
            actual: "Potential TOCTOU - requires concurrent testing".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
            cwe: "CWE-367".to_string(),
            severity: "HIGH".to_string(),
        });
    }
    None
}
```

---

### 4.9 spec.json

```json
{
  "name": "access_control_breaker",
  "language": "rust",
  "version": "2024",
  "type": "pratique",
  "tier": 2,
  "tier_info": "MÃ©lange (IDOR + Escalations + Path Traversal)",
  "tags": ["access-control", "idor", "authorization", "owasp-a01", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "access_control_breaker",
    "prototype": "pub fn access_control_breaker(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference_file": "solutions/access_control_breaker_ref.rs",

    "edge_cases": [
      {
        "name": "idor_integer_id",
        "args": ["{\"endpoints\":[{\"method\":\"GET\",\"path\":\"/api/users/{id}/profile\",\"auth\":\"user_token\",\"auth_check\":\"none\"}],\"current_user\":{\"id\":123,\"role\":\"user\"},\"response_samples\":null}"],
        "expected_contains": "IDOR",
        "is_trap": true,
        "trap_explanation": "No auth check on user-specific endpoint"
      },
      {
        "name": "idor_uuid",
        "args": ["{\"endpoints\":[{\"method\":\"GET\",\"path\":\"/api/orders/{uuid}\",\"auth\":\"user_token\",\"auth_check\":\"none\"}],\"current_user\":{\"id\":\"550e8400-e29b-41d4-a716-446655440000\",\"role\":\"user\"},\"response_samples\":null}"],
        "expected_contains": "IDOR",
        "is_trap": true,
        "trap_explanation": "UUID doesn't prevent IDOR"
      },
      {
        "name": "vertical_escalation",
        "args": ["{\"endpoints\":[{\"method\":\"GET\",\"path\":\"/api/admin/users\",\"auth\":\"user_token\",\"required_role\":\"admin\"}],\"current_user\":{\"id\":123,\"role\":\"user\"},\"response_samples\":{\"/api/admin/users\":{\"status\":200,\"body\":[]}}}"],
        "expected_contains": "VERTICAL_ESCALATION",
        "is_trap": true,
        "trap_explanation": "Admin endpoint accessible with user token"
      },
      {
        "name": "path_traversal_basic",
        "args": ["{\"endpoints\":[{\"method\":\"GET\",\"path\":\"/files\",\"auth\":\"none\",\"params\":[\"name\"]}],\"current_user\":{\"id\":123,\"role\":\"user\"},\"response_samples\":{\"/files?name=../../../etc/passwd\":{\"status\":200,\"body\":\"root:x:0:0\"}}}"],
        "expected_contains": "PATH_TRAVERSAL",
        "is_trap": true,
        "trap_explanation": "Path traversal succeeds"
      },
      {
        "name": "forced_browsing",
        "args": ["{\"endpoints\":[{\"method\":\"GET\",\"path\":\"/backup/\",\"auth\":\"none\"}],\"current_user\":{\"id\":123,\"role\":\"user\"},\"response_samples\":{\"/backup/\":{\"status\":200,\"body\":{}}}}"],
        "expected_contains": "FORCED_BROWSING",
        "is_trap": true,
        "trap_explanation": "Sensitive directory accessible without auth"
      },
      {
        "name": "parameter_tampering",
        "args": ["{\"endpoints\":[{\"method\":\"POST\",\"path\":\"/api/transfer\",\"auth\":\"user_token\",\"params\":[\"amount\",\"to_account\"]}],\"current_user\":{\"id\":123,\"role\":\"user\"},\"response_samples\":null}"],
        "expected_contains": "PARAMETER_TAMPERING",
        "is_trap": true,
        "trap_explanation": "Sensitive 'amount' parameter exposed"
      },
      {
        "name": "remediation_generated",
        "args": ["{\"endpoints\":[{\"method\":\"GET\",\"path\":\"/api/users/{id}\",\"auth_check\":\"none\"}],\"current_user\":{\"id\":123,\"role\":\"user\"},\"response_samples\":null}"],
        "expected_contains": "remediation",
        "is_trap": false,
        "trap_explanation": "Should generate remediation advice"
      },
      {
        "name": "null_handling",
        "args": ["{\"endpoints\":null,\"current_user\":null,\"response_samples\":null}"],
        "expected_not_contains": "panic",
        "is_trap": true,
        "trap_explanation": "Null inputs should not crash"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 300,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator": "endpoint_generator",
          "params": {
            "methods": ["GET", "POST", "PUT", "DELETE"],
            "path_patterns": ["/api/{resource}/{id}", "/admin/{action}", "/files/{name}"],
            "auth_types": ["none", "user_token", "admin_token"]
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json", "regex", "url"],
    "forbidden_functions": [],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A (Boundary) : Ignore les UUIDs

```rust
// âŒ MUTANT A : Assume les UUIDs sont sÃ©curisÃ©s
fn detect_idor_mutant_a(endpoint: &Endpoint) -> Option<Vulnerability> {
    if endpoint.path.contains("{id}") {
        return Some(/* IDOR */);
    }
    // BUG: {uuid} ignorÃ© !
    None
}
```

#### Mutant B (Safety) : Pas de validation des inputs

```rust
// âŒ MUTANT B : Unwrap direct
fn access_control_breaker_mutant_b(input_json: &str) -> String {
    let input: Input = serde_json::from_str(input_json).unwrap();  // Panic !
    let endpoints = input.endpoints.unwrap();  // Panic si None !
    // ...
}
```

#### Mutant C (Resource) : Accumule toutes les variantes path traversal

```rust
// âŒ MUTANT C : Ajoute toutes les variantes mÃªme si une suffit
fn detect_path_traversal_mutant_c(endpoint: &Endpoint) -> Vec<Vulnerability> {
    let payloads = ["../", "....//", "%2e%2e%2f", /*...*/];
    let mut vulns = Vec::new();

    for payload in payloads {
        // BUG: Ajoute TOUTES les variantes au lieu de s'arrÃªter Ã  la premiÃ¨re
        vulns.push(create_vuln(payload));
    }
    vulns  // Pollution du rapport
}
```

#### Mutant D (Logic) : Inverse la vÃ©rification de rÃ´le

```rust
// âŒ MUTANT D : Logique inversÃ©e
fn detect_vertical_escalation_mutant_d(current_level: u8, required_level: u8) -> bool {
    current_level > required_level  // BUG: devrait Ãªtre <
}
```

#### Mutant E (Return) : Pas de remediation

```rust
// âŒ MUTANT E : Oublie la remediation
pub fn access_control_breaker_mutant_e(input_json: &str) -> String {
    let vulns = detect_all_vulns(input);

    json!({
        "vulnerabilities": vulns
        // BUG: Pas de "remediation"
    }).to_string()
}
```

#### Mutant F (Edge Case) : Path traversal case-sensitive

```rust
// âŒ MUTANT F : Ne dÃ©tecte pas /FILES
fn detect_path_traversal_mutant_f(endpoint: &Endpoint) -> bool {
    endpoint.path.contains("/files")  // BUG: /FILES passe
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **IDOR** : Comment les rÃ©fÃ©rences directes non protÃ©gÃ©es exposent des donnÃ©es
2. **Escalade horizontale** : AccÃ©der aux ressources d'utilisateurs de mÃªme niveau
3. **Escalade verticale** : Obtenir des privilÃ¨ges supÃ©rieurs
4. **Path Traversal** : Sortir du rÃ©pertoire autorisÃ©
5. **Logique d'autorisation** : ImplÃ©menter des contrÃ´les robustes

---

### 5.2 LDA â€” Traduction littÃ©rale

```
FONCTION access_control_breaker QUI RETOURNE UNE CHAÃNE ET PREND EN PARAMÃˆTRE input_json QUI EST UNE RÃ‰FÃ‰RENCE VERS UNE CHAÃNE
DÃ‰BUT FONCTION
    DÃ‰CLARER input COMME RÃ‰SULTAT DU PARSING JSON DE input_json
    SI input EST UNE ERREUR ALORS
        RETOURNER UN JSON D'ERREUR
    FIN SI

    DÃ‰CLARER vulnerabilities COMME LISTE VIDE

    POUR CHAQUE endpoint DANS endpoints FAIRE
        SI detect_idor(endpoint, current_user) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
            AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
        FIN SI

        SI detect_vertical_escalation(endpoint, current_user) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
            AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
        FIN SI

        AJOUTER detect_path_traversal(endpoint) Ã€ vulnerabilities

        SI detect_forced_browsing(endpoint) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
            AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
        FIN SI

        SI detect_parameter_tampering(endpoint) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
            AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
        FIN SI
    FIN POUR

    DÃ‰CLARER remediation COMME generate_remediation(vulnerabilities)

    RETOURNER output SÃ‰RIALISÃ‰ EN JSON
FIN FONCTION
```

---

### 5.2.2.1 Logic Flow

```
ALGORITHME : Access Control Breaker
---
1. PARSER l'entrÃ©e JSON

2. POUR chaque endpoint :
   a. DÃ‰TECTER IDOR :
      - SI path contient {id} ou {uuid}
      - ET auth_check == "none" ou absent
      â†’ SIGNALER IDOR

   b. DÃ‰TECTER Escalade Verticale :
      - SI required_role > current_user.role
      - ET response.status == 200
      â†’ SIGNALER VERTICAL_ESCALATION

   c. DÃ‰TECTER Path Traversal :
      - SI path liÃ©e aux fichiers (/files, /download)
      - TESTER payloads: ../, ....//,  %2e%2e%2f
      â†’ SIGNALER PATH_TRAVERSAL si succÃ¨s

   d. DÃ‰TECTER Forced Browsing :
      - SI path sensible (/backup, /admin, /.git)
      - ET auth == "none"
      â†’ SIGNALER FORCED_BROWSING

   e. DÃ‰TECTER Parameter Tampering :
      - SI params contient (price, amount, role, admin)
      â†’ SIGNALER PARAMETER_TAMPERING

3. GÃ‰NÃ‰RER remÃ©diations pour chaque type trouvÃ©

4. RETOURNER JSON avec vulnÃ©rabilitÃ©s et remÃ©diations
```

---

### 5.3 Visualisation ASCII

#### IDOR Attack Flow

```
                              IDOR ATTACK

     UTILISATEUR LÃ‰GITIME                    ATTAQUANT
          (ID: 123)                          (ID: 456)

              â”‚                                  â”‚
              â”‚ GET /api/users/123/profile       â”‚
              â–¼                                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
    â”‚     SERVEUR     â”‚                          â”‚
    â”‚                 â”‚                          â”‚
    â”‚ âœ… Retourne     â”‚                          â”‚
    â”‚    profil 123   â”‚                          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
                                                 â”‚
                                                 â”‚ GET /api/users/123/profile
                                                 â”‚      (ID changÃ© !)
                                                 â–¼
                                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                       â”‚     SERVEUR     â”‚
                                       â”‚                 â”‚
                                       â”‚  if (auth) âœ…   â”‚ â† VÃ©rifie juste l'auth
                                       â”‚  // Pas de      â”‚ â† Pas de user.id == 123
                                       â”‚  // vÃ©rificationâ”‚
                                       â”‚                 â”‚
                                       â”‚ âœ… Retourne     â”‚ â† FAILLE !
                                       â”‚    profil 123   â”‚
                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Path Traversal Visualization

```
                    PATH TRAVERSAL ATTACK

    REQUÃŠTE LÃ‰GITIME                 REQUÃŠTE MALVEILLANTE
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    GET /files?name=report.pdf       GET /files?name=../../../etc/passwd

            â”‚                                    â”‚
            â–¼                                    â–¼

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     SYSTÃˆME DE FICHIERS                  â”‚
    â”‚                                                          â”‚
    â”‚   /var/www/app/                                          â”‚
    â”‚   â”œâ”€â”€ uploads/           â† RÃ©pertoire autorisÃ©           â”‚
    â”‚   â”‚   â”œâ”€â”€ report.pdf     âœ… AccÃ¨s lÃ©gitime               â”‚
    â”‚   â”‚   â””â”€â”€ image.jpg                                      â”‚
    â”‚   â”‚                                                      â”‚
    â”‚   â””â”€â”€ (sortie via ../)                                   â”‚
    â”‚                                                          â”‚
    â”‚   /etc/                   â† HORS DU RÃ‰PERTOIRE           â”‚
    â”‚   â””â”€â”€ passwd             âŒ AccÃ¨s non autorisÃ© !         â”‚
    â”‚                                                          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ../../../etc/passwd se rÃ©sout en :
    /var/www/app/uploads/../../../etc/passwd
    = /etc/passwd
```

#### Role Hierarchy

```
                         HIÃ‰RARCHIE DES RÃ”LES

                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚  SUPERADMIN â”‚  Level 100
                        â”‚  (root)     â”‚
                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                        â”‚    ADMIN    â”‚  Level 80
                        â”‚             â”‚
                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                        â”‚  MODERATOR  â”‚  Level 60
                        â”‚             â”‚
                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                        â”‚    USER     â”‚  Level 20  â† Tu es ici
                        â”‚             â”‚
                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                        â”‚    GUEST    â”‚  Level 10
                        â”‚             â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ESCALADE VERTICALE = User (20) accÃ¨de Ã  Admin (80) ğŸš¨
```

---

### 5.4 Les piÃ¨ges en dÃ©tail

#### PiÃ¨ge 1 : UUID != SÃ©curitÃ©

```rust
// âŒ FAUX : "Les UUIDs sont impossibles Ã  deviner"
// RÃ©alitÃ© : Un UUID peut Ãªtre :
// - ExposÃ© dans les logs
// - PrÃ©sent dans un email
// - Visible dans l'URL d'un autre utilisateur
// - RetournÃ© dans une rÃ©ponse API
```

#### PiÃ¨ge 2 : Encodages multiples

```rust
// âŒ FAUX : Je bloque "../"
fn sanitize_wrong(path: &str) -> bool {
    !path.contains("../")
}

// âœ… CORRECT : DÃ©coder puis vÃ©rifier
fn sanitize_correct(path: &str) -> bool {
    let decoded = url_decode(&path);
    let double_decoded = url_decode(&decoded);
    !decoded.contains("..") && !double_decoded.contains("..")
}
```

#### PiÃ¨ge 3 : VÃ©rifier l'auth mais pas l'autorisation

```rust
// âŒ FAUX : Auth â‰  Autorisation
if user.is_authenticated() {
    return get_resource(requested_id);  // Pas de vÃ©rification d'ownership !
}

// âœ… CORRECT
if user.is_authenticated() && user.owns(requested_id) {
    return get_resource(requested_id);
}
```

---

### 5.5 Cours Complet

#### 5.5.1 OWASP A01:2021 - Broken Access Control

En 2021, Broken Access Control est passÃ© de la 5Ã¨me Ã  la **1Ã¨re position** du Top 10 OWASP. C'est la catÃ©gorie avec le plus grand nombre de CWEs mappÃ©es (34 CWEs).

**Sous-catÃ©gories :**
- **IDOR (CWE-639)** : AccÃ¨s Ã  des objets via rÃ©fÃ©rence directe
- **Privilege Escalation (CWE-269)** : Obtention de privilÃ¨ges non autorisÃ©s
- **Path Traversal (CWE-22)** : AccÃ¨s Ã  des fichiers hors du rÃ©pertoire autorisÃ©
- **Forced Browsing (CWE-425)** : AccÃ¨s Ã  des ressources non liÃ©es

#### 5.5.2 Types d'IDORs

| Type | Description | Exemple |
|------|-------------|---------|
| **Direct** | ID dans l'URL | `/api/users/123` |
| **Indirect** | ID dans le body | `{"user_id": 123}` |
| **Header** | ID dans les headers | `X-User-ID: 123` |
| **Cookie** | ID dans un cookie | `session_user=123` |
| **File** | RÃ©fÃ©rence fichier | `/files/report_123.pdf` |

#### 5.5.3 Path Traversal Payloads

```
# Basic
../../../etc/passwd

# Null byte (old PHP)
../../../etc/passwd%00.jpg

# Double encoding
%252e%252e%252f

# UTF-8 overlong
..%c0%af..%c0%af

# Unicode
..%ef%bc%8f

# Mixed
....//....//

# Windows
..\..\..\..\windows\system32\config\sam
```

#### 5.5.4 RemÃ©diation IDOR

```rust
// Pattern 1: Middleware d'autorisation
fn authorize_resource_access(user: &User, resource_id: &str) -> Result<(), Error> {
    let resource = get_resource(resource_id)?;

    if resource.owner_id != user.id && !user.is_admin() {
        return Err(Error::Forbidden);
    }

    Ok(())
}

// Pattern 2: Query scoping
fn get_user_orders(user: &User) -> Vec<Order> {
    Order::find()
        .filter(order::owner_id.eq(user.id))  // Scope automatique
        .load()
}

// Pattern 3: Indirect references
fn create_order_token(order_id: i64, user_id: i64) -> String {
    // Token signÃ© contenant l'association order-user
    sign(format!("{}:{}", order_id, user_id))
}
```

---

### 5.6 Normes avec explications

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (vulnÃ©rable)                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ app.get('/users/:id', (req, res) => {                           â”‚
â”‚     const user = User.findById(req.params.id);  // Direct !     â”‚
â”‚     res.json(user);                                             â”‚
â”‚ });                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ app.get('/users/:id', authMiddleware, (req, res) => {           â”‚
â”‚     if (req.user.id !== req.params.id && !req.user.isAdmin) {   â”‚
â”‚         return res.status(403).json({error: 'Forbidden'});      â”‚
â”‚     }                                                           â”‚
â”‚     const user = User.findById(req.params.id);                  â”‚
â”‚     res.json(user);                                             â”‚
â”‚ });                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ L'ID dans l'URL est contrÃ´lÃ© par l'utilisateur                â”‚
â”‚ â€¢ Sans vÃ©rification, n'importe qui peut accÃ©der Ã  n'importe quoiâ”‚
â”‚ â€¢ La vÃ©rification DOIT Ãªtre cÃ´tÃ© serveur                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.7 Simulation avec trace d'exÃ©cution

**EntrÃ©e :** Endpoint `/api/users/{id}/profile` avec user.id = 123, request.id = 456

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Action                                         â”‚ RÃ©sultat             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Parser endpoint: /api/users/{id}/profile       â”‚ path_has_id = true   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ VÃ©rifier auth_check                            â”‚ auth_check = "none"  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ GÃ©nÃ©rer test: 123 â†’ 456                        â”‚ Test IDOR prÃ©parÃ©    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ VÃ©rifier response_samples["/api/users/456/..."]â”‚ status = 200         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ 200 OK pour autre utilisateur ?                â”‚ true â†’ VULNÃ‰RABLE    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ CrÃ©er Vulnerability IDOR                       â”‚ severity = HIGH      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Ajouter Ã  vulnerabilities                      â”‚ count = 1            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ GÃ©nÃ©rer remediation pour IDOR                  â”‚ "Implement checks.." â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.8 MnÃ©motechniques

#### ğŸ  MEME : "Prison Break" â€” L'Ã©vasion de Fox River

![Prison Break](prison_break.jpg)

Comme Michael Scofield qui a Ã©tudiÃ© les plans de Fox River pour trouver les failles structurelles (tuyaux, grilles d'aÃ©ration, portes non surveillÃ©es), tu dois analyser l'architecture de l'application pour trouver les contrÃ´les d'accÃ¨s manquants.

```rust
// Les murs de la prison = les contrÃ´les d'accÃ¨s
// Les tuyaux = les IDORs (passages cachÃ©s entre cellules)
// Les grilles = le path traversal (sortir de ta zone)
// Le bureau du directeur = l'escalade verticale (accÃ¨s admin)

if can_access_other_cell(&user, &target_cell) {
    // Michael a trouvÃ© un passage !
    report_vulnerability("IDOR - Fox River compromis");
}
```

---

#### ğŸ”“ MEME : "The Door Was Open All Along"

```
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                                â”‚
                â”‚   ğŸšª /admin/dashboard         â”‚
                â”‚                                â”‚
                â”‚   "Requires: Admin Role"       â”‚
                â”‚                                â”‚
                â”‚   Reality: No check at all     â”‚
                â”‚                                â”‚
                â”‚   ğŸ“± User with any token: âœ…   â”‚
                â”‚                                â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                        â†“

              "The door was open all along"
              "I just never tried the handle"
```

---

### 5.9 Applications pratiques

| ScÃ©nario | Application |
|----------|-------------|
| **Pentest e-commerce** | Tester IDORs sur /orders/{id}, /invoices/{id} |
| **Bug Bounty banking** | Escalade sur /admin, path traversal sur /statements |
| **Audit SaaS** | Multi-tenant isolation, paramÃ¨tre tenant_id |
| **Secure coding** | ImplÃ©menter middleware d'autorisation centralisÃ© |
| **DevSecOps** | Scanner automatisÃ© des endpoints sans auth |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | Erreur | Solution |
|---|-------|--------|----------|
| 1 | UUID != SÃ©curitÃ© | Penser que l'UUID protÃ¨ge | VÃ©rifier ownership |
| 2 | Auth â‰  Autorisation | VÃ©rifier seulement l'auth | Ajouter contrÃ´le d'accÃ¨s |
| 3 | Encodages path | Bloquer seulement ../ | DÃ©coder puis valider |
| 4 | Hidden URLs | Compter sur l'obscuritÃ© | Auth sur tout endpoint |
| 5 | Client-side params | Faire confiance aux params | Valider cÃ´tÃ© serveur |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Qu'est-ce qu'un IDOR ?**

- A) Une attaque par injection SQL
- B) Un accÃ¨s non autorisÃ© Ã  une ressource via sa rÃ©fÃ©rence directe
- C) Une faille de configuration serveur
- D) Une attaque de type XSS
- E) Un problÃ¨me de chiffrement
- F) Une vulnÃ©rabilitÃ© rÃ©seau
- G) Une attaque DDoS
- H) Un problÃ¨me de session
- I) Une faille CSRF
- J) Une injection de commande

**RÃ©ponse : B**

---

### Question 2
**Pourquoi les UUIDs ne protÃ¨gent pas contre les IDORs ?**

- A) Ils sont trop courts
- B) Ils peuvent Ãªtre devinÃ©s sÃ©quentiellement
- C) Ils peuvent Ãªtre exposÃ©s (logs, emails, URLs partagÃ©es) et n'impliquent pas de vÃ©rification d'autorisation
- D) Ils ne sont pas supportÃ©s par les bases de donnÃ©es
- E) Ils causent des problÃ¨mes de performance
- F) Ils ne fonctionnent pas avec REST
- G) Ils sont dÃ©prÃ©ciÃ© par OWASP
- H) Ils nÃ©cessitent HTTPS
- I) Ils ne marchent qu'avec JWT
- J) Ils sont vulnÃ©rables au timing attack

**RÃ©ponse : C**

---

### Question 3
**Quel payload path traversal bypasse le filtre `../` ?**

- A) ..../
- B) %2e%2e%2f
- C) ..\\
- D) Toutes ces rÃ©ponses
- E) Aucune de ces rÃ©ponses
- F) Seulement A et B
- G) Seulement B et C
- H) Seulement A
- I) Seulement B
- J) Seulement C

**RÃ©ponse : D** (tous peuvent bypasser un filtre simple)

---

### Question 4
**Quelle est la diffÃ©rence entre escalade horizontale et verticale ?**

- A) Horizontale = plus de donnÃ©es, Verticale = plus vite
- B) Horizontale = mÃªme niveau de privilÃ¨ge autre utilisateur, Verticale = privilÃ¨ges supÃ©rieurs
- C) Horizontale = rÃ©seau, Verticale = application
- D) Horizontale = lecture, Verticale = Ã©criture
- E) Ce sont des synonymes
- F) Horizontale = SQL, Verticale = NoSQL
- G) Horizontale = client, Verticale = serveur
- H) Horizontale = GET, Verticale = POST
- I) Horizontale = auth, Verticale = session
- J) Horizontale = frontend, Verticale = backend

**RÃ©ponse : B**

---

### Question 5
**Quel CWE correspond Ã  Path Traversal ?**

- A) CWE-79
- B) CWE-89
- C) CWE-22
- D) CWE-352
- E) CWE-639
- F) CWE-269
- G) CWE-287
- H) CWE-918
- I) CWE-502
- J) CWE-434

**RÃ©ponse : C**

---

### Question 6
**Quelle fonction est recommandÃ©e pour prÃ©venir path traversal ?**

- A) strlen()
- B) basename()
- C) substr()
- D) htmlspecialchars()
- E) urlencode()
- F) addslashes()
- G) md5()
- H) serialize()
- I) json_encode()
- J) base64_encode()

**RÃ©ponse : B** (extrait uniquement le nom du fichier)

---

### Question 7
**Quel header HTTP peut Ãªtre utilisÃ© pour bypass d'URL ?**

- A) Content-Type
- B) X-Original-URL
- C) Accept
- D) User-Agent
- E) Referer
- F) Origin
- G) Cache-Control
- H) Accept-Encoding
- I) Connection
- J) Host

**RÃ©ponse : B** (utilisÃ© par certains proxies/WAFs)

---

### Question 8
**Quelle est la meilleure pratique pour les endpoints sensibles ?**

- A) Les cacher avec des noms complexes
- B) Utiliser uniquement HTTPS
- C) ImplÃ©menter une vÃ©rification d'autorisation cÃ´tÃ© serveur
- D) Ajouter un CAPTCHA
- E) Limiter le rate
- F) Utiliser des UUIDs
- G) Chiffrer les paramÃ¨tres
- H) Ajouter des cookies SameSite
- I) Utiliser POST au lieu de GET
- J) Ajouter un CSP

**RÃ©ponse : C**

---

### Question 9
**Que signifie "Forced Browsing" ?**

- A) Forcer le navigateur Ã  crasher
- B) AccÃ©der directement Ã  des URLs non liÃ©es dans l'interface
- C) Utiliser un proxy pour modifier les requÃªtes
- D) Brute-forcer les mots de passe
- E) Injecter du JavaScript
- F) Voler des cookies
- G) Effectuer un DDoS
- H) Modifier le DOM
- I) Intercepter le trafic
- J) Contourner le CORS

**RÃ©ponse : B**

---

### Question 10
**Quel rang OWASP Top 10 2021 pour Broken Access Control ?**

- A) #1
- B) #2
- C) #3
- D) #4
- E) #5
- F) #6
- G) #7
- H) #8
- I) #9
- J) #10

**RÃ©ponse : A** (#1 en 2021, Ã©tait #5 en 2017)

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| MÃ©trique | Valeur |
|----------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| **Temps estimÃ©** | 240 minutes |
| **XP Base** | 300 |
| **XP Bonus** | Ã—3 (900 total) |
| **Concepts clÃ©s** | IDOR, Escalades, Path Traversal, Forced Browsing |
| **CWE couverts** | CWE-639, CWE-269, CWE-22, CWE-425 |
| **OWASP** | A01:2021 - Broken Access Control |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.7-a-access-control-breaker",
    "generated_at": "2025-01-11T13:00:00Z",

    "metadata": {
      "exercise_id": "3.3.7-a",
      "exercise_name": "access_control_breaker",
      "module": "3.3.7",
      "module_name": "Access Control & Authorization",
      "type": "pratique",
      "tier": 2,
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 240,
      "xp_base": 300,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "prerequisites": ["HTTP REST", "Auth/Authz", "URL encoding"],
      "domains": ["Net", "FS", "Encodage"],
      "tags": ["access-control", "idor", "authorization", "phase3"],
      "meme_reference": "Prison Break"
    },

    "validation": {
      "expected_pass": ["references/access_control_breaker_ref.rs"],
      "expected_fail": ["mutants/mutant_a.rs", "mutants/mutant_b.rs"]
    }
  }
}
```

---

*Exercise crÃ©Ã© selon HACKBRAIN v5.5.2 â€” "Prison Break"*
*L'excellence pÃ©dagogique ne se nÃ©gocie pas â€” pas de raccourcis*
