# Exercice [3.3.1-f] : cookie_security_analyzer

**Module :**
3.3.1 â€” Architecture Web Moderne

**Concept :**
f â€” Cookies Attributes (Secure, HttpOnly, SameSite, prefixes)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜† (6/10)

**Type :**
code

**Tiers :**
2 â€” Melange (concepts 3.3.1.f + 3.3.1.g + 3.3.6.b)

**Langage :**
Rust Edition 2024

**Prerequis :**
- Module 3.3.1-a (Protocol Dissector)
- Connaissance HTTP headers
- Bases de cryptographie (entropie)

**Domaines :**
Net, Crypto, Encodage

**Duree estimee :**
180 min

**XP Base :**
300

**Complexite :**
T2 O(n*m) x S1 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
`cookie_security_analyzer.rs`

**Fonctions autorisees :**
- `serde_json` (parsing JSON)
- `std::collections::HashMap`, `HashSet`
- `regex` (patterns de detection)
- Fonctions standard Rust

**Fonctions interdites :**
- Requetes reseau reelles
- Acces fichiers systeme
- Generation de nombres aleatoires (pour tests deterministes)

### 1.2 Consigne

**ðŸŽ® CONTEXTE FUN â€” "Stranger Things : The Upside Down Session"**

*Dans Stranger Things, le Upside Down est un monde parallele dangereux ou tout ce qui est expose est vulnerable. Les cookies HTTP sans protection, c'est exactement ca : des portes ouvertes vers un monde de vulnerabilites.*

*Tu es recrute par le Hawkins Lab pour analyser les cookies du systeme de surveillance. Eleven a detecte des anomalies â€” certains cookies sont "dans l'Upside Down" (exposes aux attaquants).*

*"Friends don't lie... but insecure cookies do." â€” Et ils exposent tes utilisateurs.*

*Chaque attribut manquant est une porte vers le Demogorgon (attaquant). HttpOnly absent? XSS. Secure absent? MITM. SameSite absent? CSRF.*

---

### 1.2.2 Consigne Academique

**Ta mission :**

Ecrire une fonction `cookie_security_analyzer` qui parse des headers Set-Cookie et detecte les vulnerabilites de securite.

**Entree :**
- `input_json` : Une chaine JSON contenant :
  - `cookies` : Liste de headers Set-Cookie bruts (strings)
  - `context` : Contexte de l'application
    - `is_https` : bool â€” L'application utilise-t-elle HTTPS ?
    - `cross_site_usage` : bool â€” Les cookies sont-ils utilises cross-site ?
    - `session_cookie_names` : Liste des noms de cookies de session (optionnel)

**Sortie :**
Une chaine JSON contenant :
- `cookies_analyzed` : Nombre de cookies analyses
- `vulnerabilities` : Liste des vulnerabilites par cookie
  - `cookie_name` : Nom du cookie
  - `issues` : Liste des problemes
    - `attribute` : L'attribut concerne (HttpOnly, Secure, SameSite, etc.)
    - `status` : "MISSING", "INVALID", "WEAK"
    - `risk` : Description du risque
    - `cwe` : Reference CWE
- `session_analysis` : Analyse des cookies de session (si detectes)
  - `entropy_bits` : Entropie estimee de la valeur
  - `predictable` : bool â€” La valeur semble-t-elle predictible ?
  - `recommendation` : Recommandation
- `prefix_violations` : Violations des prefixes __Secure- et __Host-
- `recommendations` : Recommandations generales

**Contraintes :**
- Parser correctement la syntaxe Set-Cookie (RFC 6265)
- Verifier tous les attributs de securite
- Detecter les prefixes invalides
- Estimer l'entropie des valeurs de session

**Exemples :**

| Entree | Sortie Attendue | Explication |
|--------|-----------------|-------------|
| `session=abc; Path=/` | HttpOnly MISSING, Secure MISSING | Cookie de session sans protection |
| `__Secure-token=x; Path=/` | Prefix violation | __Secure- sans Secure flag |
| `SameSite=None` sans Secure | SameSite INVALID | SameSite=None requiert Secure |

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::{HashMap, HashSet};

/// Point d'entree principal
pub fn cookie_security_analyzer(input_json: &str) -> String

/// Parse un header Set-Cookie
fn parse_set_cookie(header: &str) -> Result<ParsedCookie, ParseError>

/// Analyse les attributs de securite d'un cookie
fn analyze_cookie_security(
    cookie: &ParsedCookie,
    context: &AnalysisContext
) -> Vec<CookieIssue>

/// Verifie les violations de prefixes
fn check_prefix_violations(cookie: &ParsedCookie) -> Vec<PrefixViolation>

/// Analyse l'entropie d'une valeur de cookie
fn analyze_session_entropy(value: &str) -> SessionAnalysis

/// Estime l'entropie en bits
fn estimate_entropy_bits(value: &str) -> f64

/// Detecte si une valeur semble predictible
fn is_predictable(value: &str) -> bool

/// Genere les recommandations
fn generate_recommendations(
    vulnerabilities: &[CookieVulnerability],
    context: &AnalysisContext
) -> Vec<String>
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Attributs de Securite des Cookies

| Attribut | Description | Attaque Prevenue |
|----------|-------------|------------------|
| **HttpOnly** | Inaccessible via JavaScript | XSS cookie theft |
| **Secure** | Envoye uniquement sur HTTPS | MITM interception |
| **SameSite=Strict** | Jamais envoye cross-site | CSRF |
| **SameSite=Lax** | Envoye sur navigation top-level | CSRF partiel |
| **SameSite=None** | Toujours envoye (requiert Secure) | Aucune |
| **Path** | Limite le scope du cookie | Scope trop large |
| **Domain** | Domaine(s) autorises | Sous-domaine takeover |
| **Max-Age/Expires** | Duree de vie | Session persistante |

### 2.2 Prefixes Speciaux (RFC 6265bis)

```
__Secure-*  : Cookie DOIT avoir le flag Secure
__Host-*    : Cookie DOIT avoir Secure ET Path=/ ET pas de Domain
```

**Exemple Valide:**
```
Set-Cookie: __Host-session=abc123; Secure; Path=/; HttpOnly
```

**Exemple Invalide:**
```
Set-Cookie: __Host-session=abc123; Path=/        â† MISSING Secure!
Set-Cookie: __Host-session=abc123; Secure; Domain=.example.com  â† Domain interdit!
```

### 2.3 SameSite et les Navigateurs Modernes

Depuis 2020, Chrome et autres navigateurs traitent les cookies sans SameSite comme `SameSite=Lax` par defaut. Mais `SameSite=None` requiert OBLIGATOIREMENT `Secure`.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Qui utilise ca ?

| Metier | Cas d'usage |
|--------|-------------|
| **Security Engineer** | Audit des cookies avant production |
| **Pentester** | Premiere etape d'analyse de session |
| **DevSecOps** | CI/CD gate pour cookies non-securises |
| **Frontend Developer** | Debug de problemes cross-site |
| **Compliance Officer** | Verification RGPD/cookie consent |

### Outils Professionnels Similaires

- **OWASP ZAP** â€” Scanner de cookies automatise
- **Burp Suite** â€” Cookie Jar analysis
- **Browser DevTools** â€” Application > Cookies
- **Cookie Editor** â€” Extensions navigateur

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
cookie_security_analyzer.rs  main.rs  test_cookies.json

$ cargo build --release

$ ./target/release/cookie_analyzer
Test vulnerable_cookies.json:
{
  "cookies_analyzed": 3,
  "vulnerabilities": [
    {
      "cookie_name": "session",
      "issues": [
        {"attribute": "HttpOnly", "status": "MISSING", "risk": "XSS cookie theft", "cwe": "CWE-1004"},
        {"attribute": "Secure", "status": "MISSING", "risk": "MITM interception", "cwe": "CWE-614"},
        {"attribute": "SameSite", "status": "MISSING", "risk": "CSRF attacks", "cwe": "CWE-1275"}
      ]
    },
    {
      "cookie_name": "__Host-token",
      "issues": []
    }
  ],
  "session_analysis": {
    "entropy_bits": 24,
    "predictable": true,
    "recommendation": "Use cryptographically secure random IDs (128+ bits)"
  },
  "prefix_violations": [],
  "recommendations": [
    "Add HttpOnly to session cookies",
    "Add Secure flag when using HTTPS",
    "Set explicit SameSite attribute"
  ]
}
All tests passed!
```

---

## ðŸ”¥ SECTION 3.1 : BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n*m)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Crypto, Probas`

### 3.1.1 Consigne Bonus

**ðŸŽ® "Hawkins Lab : Session Forensics Mode"**

*Le Dr. Brenner veut analyser les sessions plus en profondeur. Il veut savoir si les sessions ont ete creees par le meme generateur, si elles suivent un pattern, et si on peut predire les prochaines.*

**Ta mission bonus :**

Etendre la fonction pour faire de l'analyse forensique des sessions.

**Entree supplementaire :**
```json
{
  "forensic_mode": true,
  "session_samples": ["sess_001", "sess_002", "sess_003", "sess_004"]
}
```

**Sortie supplementaire :**
```json
{
  "forensic_analysis": {
    "generator_type": "SEQUENTIAL" | "TIMESTAMP_BASED" | "WEAK_RANDOM" | "SECURE_RANDOM",
    "pattern_detected": "Incrementing numeric suffix",
    "predictability_score": 85,
    "next_predicted": "sess_005",
    "collision_probability": 0.001,
    "recommendations": [
      "Use UUID v4 or cryptographically secure random bytes"
    ]
  }
}
```

**Contraintes Bonus :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Detecter 4 types de generateurs       â”‚
â”‚  Calculer probabilite de collision      â”‚
â”‚  Predire la prochaine valeur si pattern â”‚
â”‚  Score de predictibilite 0-100          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```rust
fn forensic_session_analysis(
    samples: &[String]
) -> ForensicAnalysis

fn detect_generator_type(samples: &[String]) -> GeneratorType

fn detect_pattern(samples: &[String]) -> Option<String>

fn predict_next(samples: &[String], pattern: &str) -> Option<String>

fn calculate_collision_probability(entropy_bits: f64, total_sessions: u64) -> f64
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Analyse | Attributs de cookie | + Analyse forensique de sessions |
| Entree | Un cookie a la fois | + Multiple samples pour patterns |
| Sortie | Issues detectees | + Predictions et probabilites |
| Complexite | O(n*m) | O(n*m + s^2) pour patterns |

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Entree | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_empty_input` | `{"cookies": []}` | 0 cookies analyzed | 5 |
| `test_basic_parsing` | `"session=abc; Path=/"` | Cookie parsed correctly | 10 |
| `test_httponly_missing` | Cookie sans HttpOnly | Issue MISSING HttpOnly | 10 |
| `test_secure_missing` | Cookie sur HTTPS sans Secure | Issue MISSING Secure | 10 |
| `test_samesite_none_no_secure` | `SameSite=None` sans Secure | Issue INVALID SameSite | 10 |
| `test_prefix_secure` | `__Secure-*` sans Secure | Prefix violation | 10 |
| `test_prefix_host` | `__Host-*` avec Domain | Prefix violation | 10 |
| `test_session_entropy` | `session=abc123` | Low entropy detected | 10 |
| `test_sequential_session` | `sess_001, sess_002...` | Predictable = true | 10 |
| `test_secure_cookie` | Tous attributs presents | Aucune issue | 10 |
| `test_recommendations` | Multiple issues | Relevant recommendations | 5 |

### 4.2 main.rs de test

```rust
use serde_json::{json, Value};

mod cookie_security_analyzer;
use cookie_security_analyzer::cookie_security_analyzer;

fn main() {
    println!("=== Cookie Security Analyzer Tests ===\n");

    let mut passed = 0;
    let mut failed = 0;

    // Test 1: Empty input
    {
        let input = json!({
            "cookies": [],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        if parsed["cookies_analyzed"].as_u64().unwrap_or(0) == 0 {
            println!("[PASS] test_empty_input");
            passed += 1;
        } else {
            println!("[FAIL] test_empty_input");
            failed += 1;
        }
    }

    // Test 2: HttpOnly missing
    {
        let input = json!({
            "cookies": ["Set-Cookie: session=abc123; Path=/; Secure"],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_httponly_issue = parsed["vulnerabilities"]
            .as_array()
            .and_then(|arr| arr.first())
            .and_then(|v| v["issues"].as_array())
            .map(|issues| issues.iter().any(|i| {
                i["attribute"].as_str() == Some("HttpOnly") &&
                i["status"].as_str() == Some("MISSING")
            }))
            .unwrap_or(false);

        if has_httponly_issue {
            println!("[PASS] test_httponly_missing");
            passed += 1;
        } else {
            println!("[FAIL] test_httponly_missing");
            failed += 1;
        }
    }

    // Test 3: Secure missing on HTTPS
    {
        let input = json!({
            "cookies": ["Set-Cookie: session=abc123; Path=/; HttpOnly"],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_secure_issue = parsed["vulnerabilities"]
            .as_array()
            .and_then(|arr| arr.first())
            .and_then(|v| v["issues"].as_array())
            .map(|issues| issues.iter().any(|i| {
                i["attribute"].as_str() == Some("Secure") &&
                i["status"].as_str() == Some("MISSING")
            }))
            .unwrap_or(false);

        if has_secure_issue {
            println!("[PASS] test_secure_missing");
            passed += 1;
        } else {
            println!("[FAIL] test_secure_missing");
            failed += 1;
        }
    }

    // Test 4: SameSite=None without Secure
    {
        let input = json!({
            "cookies": ["Set-Cookie: tracking=xyz; SameSite=None; Path=/"],
            "context": {"is_https": true, "cross_site_usage": true}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_samesite_issue = parsed["vulnerabilities"]
            .as_array()
            .and_then(|arr| arr.first())
            .and_then(|v| v["issues"].as_array())
            .map(|issues| issues.iter().any(|i| {
                let attr = i["attribute"].as_str().unwrap_or("");
                let status = i["status"].as_str().unwrap_or("");
                attr == "SameSite" && (status == "INVALID" || status == "WEAK")
            }))
            .unwrap_or(false);

        if has_samesite_issue {
            println!("[PASS] test_samesite_none_no_secure");
            passed += 1;
        } else {
            println!("[FAIL] test_samesite_none_no_secure");
            failed += 1;
        }
    }

    // Test 5: __Secure- prefix without Secure flag
    {
        let input = json!({
            "cookies": ["Set-Cookie: __Secure-token=abc; Path=/; HttpOnly"],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_prefix_violation = parsed["prefix_violations"]
            .as_array()
            .map(|arr| !arr.is_empty())
            .unwrap_or(false);

        if has_prefix_violation {
            println!("[PASS] test_prefix_secure");
            passed += 1;
        } else {
            println!("[FAIL] test_prefix_secure - Expected prefix violation");
            failed += 1;
        }
    }

    // Test 6: __Host- prefix with Domain
    {
        let input = json!({
            "cookies": ["Set-Cookie: __Host-session=abc; Secure; Path=/; Domain=.example.com"],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_prefix_violation = parsed["prefix_violations"]
            .as_array()
            .map(|arr| arr.iter().any(|v| {
                v["prefix"].as_str() == Some("__Host-") ||
                v.to_string().contains("Host")
            }))
            .unwrap_or(false);

        if has_prefix_violation {
            println!("[PASS] test_prefix_host");
            passed += 1;
        } else {
            println!("[FAIL] test_prefix_host - Expected __Host- violation");
            failed += 1;
        }
    }

    // Test 7: Low entropy session
    {
        let input = json!({
            "cookies": ["Set-Cookie: session=abc; Path=/; Secure; HttpOnly"],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let entropy = parsed["session_analysis"]["entropy_bits"]
            .as_f64()
            .unwrap_or(0.0);

        if entropy < 50.0 {  // abc = very low entropy
            println!("[PASS] test_session_entropy (entropy: {:.2} bits)", entropy);
            passed += 1;
        } else {
            println!("[FAIL] test_session_entropy - Expected low entropy");
            failed += 1;
        }
    }

    // Test 8: Fully secure cookie
    {
        let input = json!({
            "cookies": ["Set-Cookie: __Host-session=a1b2c3d4e5f6; Secure; Path=/; HttpOnly; SameSite=Strict"],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_issues = parsed["vulnerabilities"]
            .as_array()
            .and_then(|arr| arr.first())
            .and_then(|v| v["issues"].as_array())
            .map(|issues| !issues.is_empty())
            .unwrap_or(false);

        let has_prefix_violations = parsed["prefix_violations"]
            .as_array()
            .map(|arr| !arr.is_empty())
            .unwrap_or(false);

        if !has_issues && !has_prefix_violations {
            println!("[PASS] test_secure_cookie");
            passed += 1;
        } else {
            println!("[FAIL] test_secure_cookie - Expected no issues");
            failed += 1;
        }
    }

    // Test 9: Malformed cookie
    {
        let input = json!({
            "cookies": ["Set-Cookie: "],
            "context": {"is_https": true}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Result<Value, _> = serde_json::from_str(&result);

        if parsed.is_ok() {
            println!("[PASS] test_malformed_cookie");
            passed += 1;
        } else {
            println!("[FAIL] test_malformed_cookie - Should handle gracefully");
            failed += 1;
        }
    }

    // Test 10: Recommendations generated
    {
        let input = json!({
            "cookies": [
                "Set-Cookie: session=abc; Path=/",
                "Set-Cookie: tracking=xyz; Path=/"
            ],
            "context": {"is_https": true, "cross_site_usage": false}
        }).to_string();

        let result = cookie_security_analyzer(&input);
        let parsed: Value = serde_json::from_str(&result).unwrap();

        let has_recs = parsed["recommendations"]
            .as_array()
            .map(|arr| !arr.is_empty())
            .unwrap_or(false);

        if has_recs {
            println!("[PASS] test_recommendations");
            passed += 1;
        } else {
            println!("[FAIL] test_recommendations");
            failed += 1;
        }
    }

    println!("\n=== Results: {}/{} passed ===", passed, passed + failed);

    if failed > 0 {
        std::process::exit(1);
    }
}
```

### 4.3 Solution de reference

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::{HashMap, HashSet};

// ============ STRUCTURES ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyzerInput {
    pub cookies: Vec<String>,
    #[serde(default)]
    pub context: AnalysisContext,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AnalysisContext {
    #[serde(default)]
    pub is_https: bool,
    #[serde(default)]
    pub cross_site_usage: bool,
    #[serde(default)]
    pub session_cookie_names: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyzerOutput {
    pub cookies_analyzed: usize,
    pub vulnerabilities: Vec<CookieVulnerability>,
    pub session_analysis: Option<SessionAnalysis>,
    pub prefix_violations: Vec<PrefixViolation>,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CookieVulnerability {
    pub cookie_name: String,
    pub issues: Vec<CookieIssue>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CookieIssue {
    pub attribute: String,
    pub status: String,
    pub risk: String,
    pub cwe: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionAnalysis {
    pub entropy_bits: f64,
    pub predictable: bool,
    pub recommendation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrefixViolation {
    pub cookie_name: String,
    pub prefix: String,
    pub violation: String,
    pub requirement: String,
}

#[derive(Debug, Clone)]
pub struct ParsedCookie {
    pub name: String,
    pub value: String,
    pub secure: bool,
    pub http_only: bool,
    pub same_site: Option<String>,
    pub path: Option<String>,
    pub domain: Option<String>,
    pub max_age: Option<i64>,
    pub expires: Option<String>,
}

// ============ MAIN FUNCTION ============

pub fn cookie_security_analyzer(input_json: &str) -> String {
    // Parse input
    let input: AnalyzerInput = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => {
            return json!({
                "error": format!("Failed to parse input: {}", e),
                "cookies_analyzed": 0,
                "vulnerabilities": [],
                "session_analysis": null,
                "prefix_violations": [],
                "recommendations": []
            }).to_string();
        }
    };

    if input.cookies.is_empty() {
        return json!({
            "cookies_analyzed": 0,
            "vulnerabilities": [],
            "session_analysis": null,
            "prefix_violations": [],
            "recommendations": ["No cookies to analyze"]
        }).to_string();
    }

    let mut vulnerabilities = Vec::new();
    let mut prefix_violations = Vec::new();
    let mut session_values = Vec::new();

    // Default session cookie names
    let session_names: HashSet<&str> = [
        "session", "sessionid", "sess", "sid",
        "jsessionid", "phpsessid", "aspsessionid",
        "token", "auth", "auth_token"
    ].iter().cloned().collect();

    for cookie_header in &input.cookies {
        // Parse the cookie
        let parsed = match parse_set_cookie(cookie_header) {
            Ok(c) => c,
            Err(_) => continue,
        };

        // Analyze security attributes
        let issues = analyze_cookie_security(&parsed, &input.context);

        // Check prefix violations
        let prefix_viols = check_prefix_violations(&parsed);
        prefix_violations.extend(prefix_viols);

        // Collect session values for entropy analysis
        if is_session_cookie(&parsed.name, &session_names, &input.context.session_cookie_names) {
            session_values.push(parsed.value.clone());
        }

        vulnerabilities.push(CookieVulnerability {
            cookie_name: parsed.name.clone(),
            issues,
        });
    }

    // Analyze session entropy (use first session cookie if available)
    let session_analysis = if !session_values.is_empty() {
        Some(analyze_session_entropy(&session_values[0]))
    } else {
        // Check if any cookie looks like a session
        let first_cookie = input.cookies.first()
            .and_then(|c| parse_set_cookie(c).ok());

        first_cookie.map(|c| analyze_session_entropy(&c.value))
    };

    // Generate recommendations
    let recommendations = generate_recommendations(&vulnerabilities, &prefix_violations, &input.context);

    let output = AnalyzerOutput {
        cookies_analyzed: vulnerabilities.len(),
        vulnerabilities,
        session_analysis,
        prefix_violations,
        recommendations,
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|_| {
        json!({"error": "Serialization failed"}).to_string()
    })
}

// ============ HELPER FUNCTIONS ============

fn parse_set_cookie(header: &str) -> Result<ParsedCookie, &'static str> {
    let header = header.trim();

    // Remove "Set-Cookie: " prefix if present
    let cookie_str = if header.to_lowercase().starts_with("set-cookie:") {
        header.splitn(2, ':').nth(1).unwrap_or("").trim()
    } else {
        header
    };

    if cookie_str.is_empty() {
        return Err("Empty cookie");
    }

    let parts: Vec<&str> = cookie_str.split(';').collect();

    if parts.is_empty() {
        return Err("Invalid cookie format");
    }

    // Parse name=value
    let name_value: Vec<&str> = parts[0].splitn(2, '=').collect();
    if name_value.is_empty() {
        return Err("Missing cookie name");
    }

    let name = name_value[0].trim().to_string();
    let value = name_value.get(1).map(|v| v.trim().to_string()).unwrap_or_default();

    if name.is_empty() {
        return Err("Empty cookie name");
    }

    let mut cookie = ParsedCookie {
        name,
        value,
        secure: false,
        http_only: false,
        same_site: None,
        path: None,
        domain: None,
        max_age: None,
        expires: None,
    };

    // Parse attributes
    for part in parts.iter().skip(1) {
        let part = part.trim();
        let lower = part.to_lowercase();

        if lower == "secure" {
            cookie.secure = true;
        } else if lower == "httponly" {
            cookie.http_only = true;
        } else if lower.starts_with("samesite=") {
            cookie.same_site = Some(part.splitn(2, '=').nth(1).unwrap_or("").trim().to_string());
        } else if lower.starts_with("path=") {
            cookie.path = Some(part.splitn(2, '=').nth(1).unwrap_or("").trim().to_string());
        } else if lower.starts_with("domain=") {
            cookie.domain = Some(part.splitn(2, '=').nth(1).unwrap_or("").trim().to_string());
        } else if lower.starts_with("max-age=") {
            cookie.max_age = part.splitn(2, '=').nth(1)
                .and_then(|v| v.trim().parse().ok());
        } else if lower.starts_with("expires=") {
            cookie.expires = Some(part.splitn(2, '=').nth(1).unwrap_or("").trim().to_string());
        }
    }

    Ok(cookie)
}

fn analyze_cookie_security(cookie: &ParsedCookie, context: &AnalysisContext) -> Vec<CookieIssue> {
    let mut issues = Vec::new();

    // Check HttpOnly
    if !cookie.http_only {
        issues.push(CookieIssue {
            attribute: "HttpOnly".to_string(),
            status: "MISSING".to_string(),
            risk: "XSS cookie theft - JavaScript can access this cookie".to_string(),
            cwe: "CWE-1004".to_string(),
        });
    }

    // Check Secure (especially important for HTTPS)
    if !cookie.secure && context.is_https {
        issues.push(CookieIssue {
            attribute: "Secure".to_string(),
            status: "MISSING".to_string(),
            risk: "MITM interception - Cookie sent over insecure connections".to_string(),
            cwe: "CWE-614".to_string(),
        });
    }

    // Check SameSite
    match &cookie.same_site {
        None => {
            issues.push(CookieIssue {
                attribute: "SameSite".to_string(),
                status: "MISSING".to_string(),
                risk: "CSRF attacks - Browser defaults to Lax but explicit is better".to_string(),
                cwe: "CWE-1275".to_string(),
            });
        }
        Some(value) => {
            let value_lower = value.to_lowercase();
            if value_lower == "none" && !cookie.secure {
                issues.push(CookieIssue {
                    attribute: "SameSite".to_string(),
                    status: "INVALID".to_string(),
                    risk: "SameSite=None requires Secure flag".to_string(),
                    cwe: "CWE-1275".to_string(),
                });
            }
        }
    }

    // Check Path (warn if too broad)
    if cookie.path.is_none() || cookie.path.as_ref().map(|p| p == "/").unwrap_or(false) {
        // Path=/ is common but worth noting for sensitive cookies
        if is_sensitive_cookie_name(&cookie.name) {
            issues.push(CookieIssue {
                attribute: "Path".to_string(),
                status: "WEAK".to_string(),
                risk: "Cookie accessible from all paths on the domain".to_string(),
                cwe: "CWE-923".to_string(),
            });
        }
    }

    issues
}

fn check_prefix_violations(cookie: &ParsedCookie) -> Vec<PrefixViolation> {
    let mut violations = Vec::new();

    // Check __Secure- prefix
    if cookie.name.starts_with("__Secure-") {
        if !cookie.secure {
            violations.push(PrefixViolation {
                cookie_name: cookie.name.clone(),
                prefix: "__Secure-".to_string(),
                violation: "Cookie with __Secure- prefix must have Secure flag".to_string(),
                requirement: "Secure flag required".to_string(),
            });
        }
    }

    // Check __Host- prefix
    if cookie.name.starts_with("__Host-") {
        if !cookie.secure {
            violations.push(PrefixViolation {
                cookie_name: cookie.name.clone(),
                prefix: "__Host-".to_string(),
                violation: "Cookie with __Host- prefix must have Secure flag".to_string(),
                requirement: "Secure flag required".to_string(),
            });
        }

        if cookie.domain.is_some() {
            violations.push(PrefixViolation {
                cookie_name: cookie.name.clone(),
                prefix: "__Host-".to_string(),
                violation: "Cookie with __Host- prefix must not have Domain attribute".to_string(),
                requirement: "No Domain attribute allowed".to_string(),
            });
        }

        if cookie.path.as_ref().map(|p| p != "/").unwrap_or(true) {
            violations.push(PrefixViolation {
                cookie_name: cookie.name.clone(),
                prefix: "__Host-".to_string(),
                violation: "Cookie with __Host- prefix must have Path=/".to_string(),
                requirement: "Path=/ required".to_string(),
            });
        }
    }

    violations
}

fn analyze_session_entropy(value: &str) -> SessionAnalysis {
    let entropy_bits = estimate_entropy_bits(value);
    let predictable = is_predictable(value);

    let recommendation = if entropy_bits < 64.0 {
        "Use cryptographically secure random IDs with at least 128 bits of entropy".to_string()
    } else if entropy_bits < 128.0 {
        "Consider increasing session ID entropy to 128+ bits".to_string()
    } else {
        "Session ID entropy appears adequate".to_string()
    };

    SessionAnalysis {
        entropy_bits,
        predictable,
        recommendation,
    }
}

fn estimate_entropy_bits(value: &str) -> f64 {
    if value.is_empty() {
        return 0.0;
    }

    // Count unique characters
    let unique_chars: HashSet<char> = value.chars().collect();
    let charset_size = unique_chars.len() as f64;

    if charset_size <= 1.0 {
        return 0.0;
    }

    // Estimate bits: log2(charset_size) * length
    // This is a simplified estimate
    let bits_per_char = charset_size.log2();
    let estimated_bits = bits_per_char * value.len() as f64;

    // Apply penalty for obvious patterns
    let penalty = if is_predictable(value) { 0.5 } else { 1.0 };

    estimated_bits * penalty
}

fn is_predictable(value: &str) -> bool {
    let value_lower = value.to_lowercase();

    // Check for sequential patterns
    if value.chars().all(|c| c.is_numeric()) {
        // All numeric - likely sequential
        return true;
    }

    // Check for common weak patterns
    let weak_patterns = [
        "123", "abc", "000", "111", "admin", "test", "user",
        "session", "token", "aaa", "bbb", "xxx"
    ];

    for pattern in weak_patterns {
        if value_lower.contains(pattern) {
            return true;
        }
    }

    // Check for timestamp-like values
    if value.len() >= 10 && value.chars().all(|c| c.is_numeric()) {
        // Looks like a timestamp
        return true;
    }

    // Check if value is too short
    if value.len() < 8 {
        return true;
    }

    false
}

fn is_sensitive_cookie_name(name: &str) -> bool {
    let lower = name.to_lowercase();
    let sensitive_patterns = [
        "session", "auth", "token", "user", "login",
        "credential", "key", "secret", "admin"
    ];

    sensitive_patterns.iter().any(|p| lower.contains(p))
}

fn is_session_cookie(name: &str, defaults: &HashSet<&str>, custom: &[String]) -> bool {
    let lower = name.to_lowercase();

    defaults.contains(lower.as_str()) ||
    custom.iter().any(|c| c.to_lowercase() == lower)
}

fn generate_recommendations(
    vulnerabilities: &[CookieVulnerability],
    prefix_violations: &[PrefixViolation],
    context: &AnalysisContext
) -> Vec<String> {
    let mut recs: HashSet<String> = HashSet::new();

    for vuln in vulnerabilities {
        for issue in &vuln.issues {
            match issue.attribute.as_str() {
                "HttpOnly" if issue.status == "MISSING" => {
                    recs.insert("Add HttpOnly flag to prevent XSS cookie theft".to_string());
                }
                "Secure" if issue.status == "MISSING" => {
                    recs.insert("Add Secure flag to prevent transmission over insecure connections".to_string());
                }
                "SameSite" => {
                    recs.insert("Set explicit SameSite attribute (Strict or Lax recommended)".to_string());
                }
                _ => {}
            }
        }
    }

    if !prefix_violations.is_empty() {
        recs.insert("Fix cookie prefix violations to ensure proper security enforcement".to_string());
    }

    if context.is_https && !context.cross_site_usage {
        recs.insert("Consider using __Host- prefix for maximum cookie security".to_string());
    }

    recs.into_iter().collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_cookie() {
        let cookie = parse_set_cookie("session=abc123; Path=/").unwrap();
        assert_eq!(cookie.name, "session");
        assert_eq!(cookie.value, "abc123");
        assert_eq!(cookie.path, Some("/".to_string()));
    }

    #[test]
    fn test_parse_secure_cookie() {
        let cookie = parse_set_cookie("token=xyz; Secure; HttpOnly; SameSite=Strict").unwrap();
        assert!(cookie.secure);
        assert!(cookie.http_only);
        assert_eq!(cookie.same_site, Some("Strict".to_string()));
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1: Regex-based parsing
// ===================================

use regex::Regex;

fn parse_set_cookie_regex(header: &str) -> Result<ParsedCookie, &'static str> {
    lazy_static! {
        static ref COOKIE_RE: Regex = Regex::new(
            r"^(?:Set-Cookie:\s*)?([^=]+)=([^;]*)"
        ).unwrap();
        static ref ATTR_RE: Regex = Regex::new(
            r";\s*([^=;]+)(?:=([^;]*))?"
        ).unwrap();
    }

    let caps = COOKIE_RE.captures(header).ok_or("Invalid format")?;
    let name = caps[1].trim().to_string();
    let value = caps[2].trim().to_string();

    let mut cookie = ParsedCookie {
        name,
        value,
        secure: false,
        http_only: false,
        same_site: None,
        path: None,
        domain: None,
        max_age: None,
        expires: None,
    };

    for caps in ATTR_RE.captures_iter(header) {
        let attr = caps[1].trim().to_lowercase();
        let val = caps.get(2).map(|m| m.as_str().trim().to_string());

        match attr.as_str() {
            "secure" => cookie.secure = true,
            "httponly" => cookie.http_only = true,
            "samesite" => cookie.same_site = val,
            "path" => cookie.path = val,
            "domain" => cookie.domain = val,
            _ => {}
        }
    }

    Ok(cookie)
}


// Alternative 2: Builder pattern
// ===============================

struct CookieAnalyzerBuilder {
    context: AnalysisContext,
    session_names: HashSet<String>,
}

impl CookieAnalyzerBuilder {
    fn new() -> Self {
        Self {
            context: AnalysisContext::default(),
            session_names: HashSet::new(),
        }
    }

    fn with_https(mut self, is_https: bool) -> Self {
        self.context.is_https = is_https;
        self
    }

    fn with_session_names(mut self, names: Vec<String>) -> Self {
        self.session_names = names.into_iter().collect();
        self
    }

    fn analyze(&self, cookies: &[String]) -> AnalyzerOutput {
        // ... implementation using self.context
    }
}
```

### 4.5 Solutions refusees (avec explications)

```rust
// REFUSE 1: Ne verifie pas tous les attributs
// ============================================

fn incomplete_analysis(cookie: &ParsedCookie) -> Vec<CookieIssue> {
    let mut issues = Vec::new();

    // REFUSE: Ne verifie que HttpOnly, ignore Secure et SameSite
    if !cookie.http_only {
        issues.push(CookieIssue {
            attribute: "HttpOnly".to_string(),
            // ...
        });
    }

    // Secure? SameSite? Path? â†’ IGNORES!
    issues
}
// Pourquoi refuse: Analyse incomplete, rate des vulnerabilites critiques


// REFUSE 2: Prefix check incomplet
// ==================================

fn check_prefix_partial(cookie: &ParsedCookie) -> Vec<PrefixViolation> {
    let mut violations = Vec::new();

    if cookie.name.starts_with("__Secure-") && !cookie.secure {
        violations.push(/* ... */);
    }

    // REFUSE: __Host- prefix completement ignore!
    // __Host- a des regles plus strictes (pas de Domain, Path=/)

    violations
}
// Pourquoi refuse: __Host- est plus strict et doit etre verifie


// REFUSE 3: Entropie mal calculee
// ================================

fn bad_entropy(value: &str) -> f64 {
    // REFUSE: Compte juste la longueur, pas le charset
    value.len() as f64 * 8.0  // Assume 8 bits par caractere FAUX
}
// Pourquoi refuse: "aaa" et "a1b" ont des entropies tres differentes


// REFUSE 4: SameSite=None sans verification Secure
// =================================================

fn check_samesite_incomplete(cookie: &ParsedCookie) -> Vec<CookieIssue> {
    let mut issues = Vec::new();

    // REFUSE: Ne verifie pas que SameSite=None requiert Secure
    if cookie.same_site.is_none() {
        issues.push(/* MISSING */);
    }

    // SameSite=None sans Secure? â†’ PAS DETECTE!

    issues
}
// Pourquoi refuse: SameSite=None + !Secure est une erreur grave
```

### 4.6 Solution bonus de reference (COMPLETE)

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyzerInputBonus {
    pub cookies: Vec<String>,
    #[serde(default)]
    pub context: AnalysisContext,
    #[serde(default)]
    pub forensic_mode: bool,
    #[serde(default)]
    pub session_samples: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForensicAnalysis {
    pub generator_type: String,
    pub pattern_detected: Option<String>,
    pub predictability_score: u32,
    pub next_predicted: Option<String>,
    pub collision_probability: f64,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum GeneratorType {
    Sequential,
    TimestampBased,
    WeakRandom,
    SecureRandom,
}

impl ToString for GeneratorType {
    fn to_string(&self) -> String {
        match self {
            GeneratorType::Sequential => "SEQUENTIAL".to_string(),
            GeneratorType::TimestampBased => "TIMESTAMP_BASED".to_string(),
            GeneratorType::WeakRandom => "WEAK_RANDOM".to_string(),
            GeneratorType::SecureRandom => "SECURE_RANDOM".to_string(),
        }
    }
}

pub fn cookie_security_analyzer_bonus(input_json: &str) -> String {
    let input: AnalyzerInputBonus = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(e) => return json!({"error": e.to_string()}).to_string(),
    };

    // Run base analysis
    let base_input = json!({
        "cookies": input.cookies,
        "context": input.context
    }).to_string();

    let base_result: Value = serde_json::from_str(&cookie_security_analyzer(&base_input)).unwrap();

    // Add forensic analysis if requested
    let forensic_analysis = if input.forensic_mode && !input.session_samples.is_empty() {
        Some(forensic_session_analysis(&input.session_samples))
    } else {
        None
    };

    // Merge results
    let mut output: Value = base_result;
    if let Some(forensic) = forensic_analysis {
        output["forensic_analysis"] = serde_json::to_value(forensic).unwrap();
    }

    serde_json::to_string_pretty(&output).unwrap()
}

fn forensic_session_analysis(samples: &[String]) -> ForensicAnalysis {
    if samples.is_empty() {
        return ForensicAnalysis {
            generator_type: "UNKNOWN".to_string(),
            pattern_detected: None,
            predictability_score: 0,
            next_predicted: None,
            collision_probability: 0.0,
            recommendations: vec!["Provide session samples for analysis".to_string()],
        };
    }

    let generator_type = detect_generator_type(samples);
    let pattern = detect_pattern(samples);
    let next_predicted = pattern.as_ref().and_then(|p| predict_next(samples, p));

    let predictability_score = match generator_type {
        GeneratorType::Sequential => 95,
        GeneratorType::TimestampBased => 80,
        GeneratorType::WeakRandom => 50,
        GeneratorType::SecureRandom => 5,
    };

    // Estimate entropy from samples
    let avg_entropy: f64 = samples.iter()
        .map(|s| estimate_entropy_bits(s))
        .sum::<f64>() / samples.len() as f64;

    // Birthday paradox collision probability
    // P(collision) â‰ˆ n^2 / (2 * 2^entropy)
    let n = 1_000_000u64; // Assume 1M sessions
    let collision_prob = calculate_collision_probability(avg_entropy, n);

    let recommendations = generate_forensic_recommendations(&generator_type, avg_entropy);

    ForensicAnalysis {
        generator_type: generator_type.to_string(),
        pattern_detected: pattern,
        predictability_score,
        next_predicted,
        collision_probability: collision_prob,
        recommendations,
    }
}

fn detect_generator_type(samples: &[String]) -> GeneratorType {
    if samples.len() < 2 {
        return GeneratorType::SecureRandom; // Can't determine with single sample
    }

    // Check for sequential numeric pattern
    let all_numeric: Vec<Option<i64>> = samples.iter()
        .map(|s| extract_numeric_suffix(s))
        .collect();

    if all_numeric.iter().all(|n| n.is_some()) {
        let nums: Vec<i64> = all_numeric.iter().filter_map(|n| *n).collect();
        if is_sequential(&nums) {
            return GeneratorType::Sequential;
        }
    }

    // Check for timestamp-based
    if samples.iter().all(|s| looks_like_timestamp(s)) {
        return GeneratorType::TimestampBased;
    }

    // Check entropy
    let avg_entropy: f64 = samples.iter()
        .map(|s| estimate_entropy_bits(s))
        .sum::<f64>() / samples.len() as f64;

    if avg_entropy < 64.0 {
        GeneratorType::WeakRandom
    } else {
        GeneratorType::SecureRandom
    }
}

fn extract_numeric_suffix(s: &str) -> Option<i64> {
    // Extract trailing numbers: "sess_001" -> 1
    let numeric_part: String = s.chars().rev()
        .take_while(|c| c.is_numeric())
        .collect::<String>()
        .chars().rev().collect();

    if numeric_part.is_empty() {
        None
    } else {
        numeric_part.parse().ok()
    }
}

fn is_sequential(nums: &[i64]) -> bool {
    if nums.len() < 2 {
        return false;
    }

    let diffs: Vec<i64> = nums.windows(2)
        .map(|w| w[1] - w[0])
        .collect();

    // Check if all differences are the same (likely sequential)
    diffs.iter().all(|&d| d == diffs[0] && d >= 0 && d <= 10)
}

fn looks_like_timestamp(s: &str) -> bool {
    // Check if value looks like Unix timestamp or similar
    if let Ok(num) = s.parse::<i64>() {
        // Unix timestamp range: 2000-01-01 to 2100-01-01
        return num > 946684800 && num < 4102444800;
    }

    // Check for hex timestamp
    if s.len() == 8 || s.len() == 16 {
        if s.chars().all(|c| c.is_ascii_hexdigit()) {
            return true;
        }
    }

    false
}

fn detect_pattern(samples: &[String]) -> Option<String> {
    if samples.len() < 2 {
        return None;
    }

    // Check for incrementing suffix
    let suffixes: Vec<Option<i64>> = samples.iter()
        .map(|s| extract_numeric_suffix(s))
        .collect();

    if suffixes.iter().all(|s| s.is_some()) {
        let nums: Vec<i64> = suffixes.into_iter().flatten().collect();
        if is_sequential(&nums) {
            return Some("Incrementing numeric suffix".to_string());
        }
    }

    // Check for common prefix
    if let Some(prefix) = find_common_prefix(samples) {
        if prefix.len() > 2 {
            return Some(format!("Common prefix: '{}'", prefix));
        }
    }

    None
}

fn find_common_prefix(samples: &[String]) -> Option<String> {
    if samples.is_empty() {
        return None;
    }

    let first = &samples[0];
    let mut prefix_len = first.len();

    for sample in samples.iter().skip(1) {
        let common: usize = first.chars().zip(sample.chars())
            .take_while(|(a, b)| a == b)
            .count();
        prefix_len = prefix_len.min(common);
    }

    if prefix_len > 0 {
        Some(first[..prefix_len].to_string())
    } else {
        None
    }
}

fn predict_next(samples: &[String], pattern: &str) -> Option<String> {
    if !pattern.contains("Incrementing") {
        return None;
    }

    let last = samples.last()?;
    let num = extract_numeric_suffix(last)?;

    // Find prefix
    let prefix_end = last.rfind(|c: char| !c.is_numeric())?;
    let prefix = &last[..=prefix_end];
    let num_len = last.len() - prefix_end - 1;

    Some(format!("{}{:0>width$}", prefix, num + 1, width = num_len))
}

fn calculate_collision_probability(entropy_bits: f64, n: u64) -> f64 {
    // Birthday paradox: P â‰ˆ 1 - e^(-nÂ²/(2*2^entropy))
    // For small probabilities: P â‰ˆ nÂ² / (2 * 2^entropy)

    if entropy_bits >= 128.0 {
        return 0.0; // Effectively zero
    }

    let space_size = 2.0_f64.powf(entropy_bits);
    let n_f = n as f64;

    // Simplified formula for small probability
    let prob = (n_f * n_f) / (2.0 * space_size);

    prob.min(1.0)
}

fn generate_forensic_recommendations(gen_type: &GeneratorType, entropy: f64) -> Vec<String> {
    let mut recs = Vec::new();

    match gen_type {
        GeneratorType::Sequential => {
            recs.push("CRITICAL: Sequential session IDs are trivially predictable".to_string());
            recs.push("Use cryptographically secure random number generator".to_string());
        }
        GeneratorType::TimestampBased => {
            recs.push("HIGH: Timestamp-based sessions are predictable".to_string());
            recs.push("Add cryptographic randomness to session generation".to_string());
        }
        GeneratorType::WeakRandom => {
            recs.push("MEDIUM: Session entropy is below recommended levels".to_string());
            recs.push("Use CSPRNG (e.g., /dev/urandom, CryptoGenRandom)".to_string());
        }
        GeneratorType::SecureRandom => {
            if entropy < 128.0 {
                recs.push("Consider increasing session ID length for additional security".to_string());
            } else {
                recs.push("Session generation appears secure".to_string());
            }
        }
    }

    if entropy < 128.0 {
        recs.push(format!("Increase entropy from {:.0} to 128+ bits", entropy));
    }

    recs
}
```

### 4.9 spec.json (ENGINE v22.1 â€” FORMAT STRICT)

```json
{
  "name": "cookie_security_analyzer",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Melange (concepts 3.3.1.f + 3.3.1.g + 3.3.6.b)",
  "tags": ["cookies", "security", "session", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "cookie_security_analyzer",
    "prototype": "pub fn cookie_security_analyzer(input_json: &str) -> String",
    "return_type": "String",
    "parameters": [
      {"name": "input_json", "type": "&str"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_cookie_security_analyzer(input_json: &str) -> String { use serde_json::{json, Value}; let input: Value = match serde_json::from_str(input_json) { Ok(v) => v, Err(e) => return json!({\"error\": e.to_string()}).to_string() }; let cookies = input[\"cookies\"].as_array(); let is_https = input[\"context\"][\"is_https\"].as_bool().unwrap_or(false); let count = cookies.map(|c| c.len()).unwrap_or(0); let mut vulns = Vec::new(); if let Some(cookies_arr) = cookies { for c in cookies_arr { let cookie_str = c.as_str().unwrap_or(\"\"); let has_httponly = cookie_str.to_lowercase().contains(\"httponly\"); let has_secure = cookie_str.to_lowercase().contains(\"secure\"); let has_samesite = cookie_str.to_lowercase().contains(\"samesite\"); let mut issues = Vec::new(); if !has_httponly { issues.push(json!({\"attribute\": \"HttpOnly\", \"status\": \"MISSING\", \"risk\": \"XSS\", \"cwe\": \"CWE-1004\"})); } if is_https && !has_secure { issues.push(json!({\"attribute\": \"Secure\", \"status\": \"MISSING\", \"risk\": \"MITM\", \"cwe\": \"CWE-614\"})); } if !has_samesite { issues.push(json!({\"attribute\": \"SameSite\", \"status\": \"MISSING\", \"risk\": \"CSRF\", \"cwe\": \"CWE-1275\"})); } vulns.push(json!({\"cookie_name\": \"cookie\", \"issues\": issues})); }} json!({\"cookies_analyzed\": count, \"vulnerabilities\": vulns, \"session_analysis\": null, \"prefix_violations\": [], \"recommendations\": []}).to_string() }",

    "edge_cases": [
      {
        "name": "empty_cookies",
        "args": ["{\"cookies\":[],\"context\":{\"is_https\":true}}"],
        "expected_field": "cookies_analyzed",
        "expected_value": 0,
        "is_trap": false
      },
      {
        "name": "missing_httponly",
        "args": ["{\"cookies\":[\"Set-Cookie: session=abc; Path=/; Secure\"],\"context\":{\"is_https\":true}}"],
        "expected_contains": ["HttpOnly", "MISSING"],
        "is_trap": true,
        "trap_explanation": "Cookie sans HttpOnly = vol via XSS"
      },
      {
        "name": "missing_secure_https",
        "args": ["{\"cookies\":[\"Set-Cookie: session=abc; HttpOnly\"],\"context\":{\"is_https\":true}}"],
        "expected_contains": ["Secure", "MISSING"],
        "is_trap": true
      },
      {
        "name": "samesite_none_no_secure",
        "args": ["{\"cookies\":[\"Set-Cookie: track=x; SameSite=None\"],\"context\":{\"is_https\":true}}"],
        "expected_contains": ["SameSite", "INVALID"],
        "is_trap": true
      },
      {
        "name": "prefix_secure_violation",
        "args": ["{\"cookies\":[\"Set-Cookie: __Secure-token=x; Path=/\"],\"context\":{\"is_https\":true}}"],
        "expected_contains": ["prefix", "violation"],
        "is_trap": true
      },
      {
        "name": "prefix_host_with_domain",
        "args": ["{\"cookies\":[\"Set-Cookie: __Host-sess=x; Secure; Path=/; Domain=.example.com\"],\"context\":{\"is_https\":true}}"],
        "expected_contains": ["__Host", "Domain"],
        "is_trap": true
      },
      {
        "name": "fully_secure",
        "args": ["{\"cookies\":[\"Set-Cookie: __Host-sess=abc123; Secure; Path=/; HttpOnly; SameSite=Strict\"],\"context\":{\"is_https\":true}}"],
        "expected_empty_array": "prefix_violations",
        "is_trap": false
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 300,
      "generators": [
        {
          "type": "set_cookie_header",
          "param_index": 0,
          "params": {
            "include_httponly": "random",
            "include_secure": "random",
            "include_samesite": "random",
            "use_prefix": "random"
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["serde_json", "std::collections", "regex"],
    "forbidden_functions": ["reqwest", "std::fs", "rand"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  },

  "bonus": {
    "enabled": true,
    "tier": "AVANCE",
    "multiplier": 3,
    "additional_tests": [
      {
        "name": "forensic_sequential",
        "args": ["{\"cookies\":[],\"context\":{},\"forensic_mode\":true,\"session_samples\":[\"sess_001\",\"sess_002\",\"sess_003\"]}"],
        "expected_contains": ["SEQUENTIAL", "Incrementing"]
      }
    ]
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```rust
/* ========================================================
   MUTANT A (Boundary) : Parsing incomplet des attributs
   ======================================================== */

fn parse_attributes_mutant_a(parts: &[&str]) -> ParsedCookie {
    let mut cookie = ParsedCookie::default();

    // BUG: Skip(1) manquant, parse le name=value comme attribut
    for part in parts {  // BUG: devrait etre parts.iter().skip(1)
        if part.to_lowercase() == "secure" {
            cookie.secure = true;
        }
        // ...
    }
    cookie
}
// Pourquoi c'est faux: Le premier element n'est pas un attribut
// Ce qui etait pense: Tous les elements sont des attributs


/* ========================================================
   MUTANT B (Safety) : Case-sensitive comparison
   ======================================================== */

fn check_secure_mutant_b(cookie: &ParsedCookie, raw: &str) -> bool {
    // BUG: Case-sensitive, rate "SECURE" et "secure"
    raw.contains("Secure")  // "secure" ne match pas!
}
// Pourquoi c'est faux: HTTP headers sont case-insensitive
// Ce qui etait pense: Les attributs sont toujours en Camel Case


/* ========================================================
   MUTANT C (Resource) : Entropie mal calculee
   ======================================================== */

fn estimate_entropy_mutant_c(value: &str) -> f64 {
    // BUG: Assume 8 bits par caractere (faux)
    value.len() as f64 * 8.0
}
// Pourquoi c'est faux: "aaaa" et "aZ1!" ont le meme len mais pas la meme entropie
// Ce qui etait pense: Chaque caractere = 8 bits


/* ========================================================
   MUTANT D (Logic) : SameSite=None sans check Secure
   ======================================================== */

fn check_samesite_mutant_d(cookie: &ParsedCookie) -> Vec<CookieIssue> {
    let mut issues = Vec::new();

    match &cookie.same_site {
        None => issues.push(CookieIssue {
            attribute: "SameSite".to_string(),
            status: "MISSING".to_string(),
            // ...
        }),
        Some(_) => {}  // BUG: Ne verifie pas None + !Secure
    }

    issues
}
// Pourquoi c'est faux: SameSite=None sans Secure est invalide
// Ce qui etait pense: Tout SameSite present est OK


/* ========================================================
   MUTANT E (Return) : Prefix __Host- incomplet
   ======================================================== */

fn check_host_prefix_mutant_e(cookie: &ParsedCookie) -> Vec<PrefixViolation> {
    let mut violations = Vec::new();

    if cookie.name.starts_with("__Host-") {
        // BUG: Ne verifie que Secure, pas Domain ni Path
        if !cookie.secure {
            violations.push(/* ... */);
        }
        // Domain check? MISSING
        // Path=/ check? MISSING
    }

    violations
}
// Pourquoi c'est faux: __Host- a 3 exigences, pas juste Secure
// Ce qui etait pense: __Host- = __Secure-


/* ========================================================
   MUTANT F (Edge Case) : Crash sur cookie malformed
   ======================================================== */

fn parse_cookie_mutant_f(header: &str) -> ParsedCookie {
    // BUG: unwrap sans verification
    let parts: Vec<&str> = header.split(';').collect();
    let name_value: Vec<&str> = parts[0].split('=').collect();

    ParsedCookie {
        name: name_value[0].to_string(),  // PANIC si pas de '='
        value: name_value[1].to_string(), // PANIC si index out of bounds
        // ...
    }
}
// Pourquoi c'est faux: Crash sur "Set-Cookie: invalid"
// Ce qui etait pense: Tous les cookies ont name=value
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

| Concept | Description | Importance |
|---------|-------------|------------|
| **Cookie Parsing** | Syntaxe RFC 6265 | Fondamental |
| **Security Attributes** | HttpOnly, Secure, SameSite | Critique |
| **Cookie Prefixes** | __Secure-, __Host- | Important |
| **Session Security** | Entropie, predictibilite | Essentiel |
| **Compliance** | Best practices modernes | Pratique |

### 5.2 LDA â€” Traduction litterale en francais (MAJUSCULES)

```
FONCTION cookie_security_analyzer QUI RETOURNE UNE CHAINE ET PREND EN PARAMETRE input_json QUI EST UNE REFERENCE VERS UNE CHAINE
DEBUT FONCTION
    DECLARER input COMME RESULTAT DU PARSING JSON DE input_json

    SI input EST UNE ERREUR ALORS
        RETOURNER UN JSON AVEC LE CHAMP error
    FIN SI

    DECLARER cookies COMME LE CHAMP cookies DE input
    DECLARER context COMME LE CHAMP context DE input
    DECLARER vulnerabilities COMME LISTE VIDE

    POUR CHAQUE cookie_header DANS cookies FAIRE
        DECLARER parsed COMME parse_set_cookie(cookie_header)

        SI parsed EST UNE ERREUR ALORS
            CONTINUER AU PROCHAIN
        FIN SI

        DECLARER issues COMME LISTE VIDE

        SI parsed.http_only EST FAUX ALORS
            AJOUTER Issue HttpOnly MISSING A issues
        FIN SI

        SI context.is_https EST VRAI ET parsed.secure EST FAUX ALORS
            AJOUTER Issue Secure MISSING A issues
        FIN SI

        SI parsed.same_site EST NUL ALORS
            AJOUTER Issue SameSite MISSING A issues
        SINON SI parsed.same_site EST EGAL A "None" ET parsed.secure EST FAUX ALORS
            AJOUTER Issue SameSite INVALID A issues
        FIN SI

        DECLARER prefix_viols COMME check_prefix_violations(parsed)

        AJOUTER CookieVulnerability(parsed.name, issues) A vulnerabilities
    FIN POUR

    DECLARER session_analysis COMME analyze_session_entropy SI session_cookie DETECTE
    DECLARER recommendations COMME generate_recommendations(vulnerabilities)

    RETOURNER JSON AVEC cookies_analyzed, vulnerabilities, session_analysis, recommendations
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
              ANATOMIE D'UN HEADER SET-COOKIE

    Set-Cookie: session=abc123; Path=/; Secure; HttpOnly; SameSite=Strict
                â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”¬â”€â”€â”¤ â”œâ”€â”€â”¬â”€â”€â”¤ â”œâ”€â”€â”€â”¬â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¤
                â”‚     â”‚       â”‚     â”‚    â”‚     â”‚   â”‚          â”‚
               name  value  Path  Secure HttpOnly    SameSite
                            â”‚       â”‚       â”‚           â”‚
                            â–¼       â–¼       â–¼           â–¼
                    Scope   HTTPS  No JS  CSRF
                            only   access protection


              COMPARAISON DES NIVEAUX DE SECURITE

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Cookie INSECURE (vulnerabilites multiples)                â”‚
    â”‚  session=abc; Path=/                                       â”‚
    â”‚  â”œâ”€â”€ HttpOnly: MISSING â†’ XSS theft possible               â”‚
    â”‚  â”œâ”€â”€ Secure: MISSING â†’ MITM interception possible         â”‚
    â”‚  â””â”€â”€ SameSite: MISSING â†’ CSRF possible                    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Cookie SECURE (toutes protections)                        â”‚
    â”‚  __Host-session=a1b2c3; Secure; Path=/; HttpOnly;          â”‚
    â”‚                         SameSite=Strict                    â”‚
    â”‚  â”œâ”€â”€ __Host- prefix â†’ Strict origin binding               â”‚
    â”‚  â”œâ”€â”€ Secure â†’ HTTPS only                                   â”‚
    â”‚  â”œâ”€â”€ HttpOnly â†’ No JavaScript access                       â”‚
    â”‚  â””â”€â”€ SameSite=Strict â†’ No cross-site requests             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


              MATRICE DE RISQUE

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Attribut    â”‚  Absent                   â”‚  Present          â”‚
    â”‚  Manquant    â”‚  Risque                   â”‚  Protection       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  HttpOnly    â”‚  XSS â†’ Vol de cookie      â”‚  JS ne peut pas   â”‚
    â”‚              â”‚  document.cookie          â”‚  lire le cookie   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  Secure      â”‚  MITM â†’ Interception      â”‚  HTTPS uniquement â”‚
    â”‚              â”‚  sur HTTP                 â”‚                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  SameSite    â”‚  CSRF â†’ Requetes          â”‚  Strict: Jamais   â”‚
    â”‚              â”‚  cross-site               â”‚  Lax: Navigation  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Case sensitivity** | HTTP headers sont case-insensitive | `.to_lowercase()` avant comparaison |
| **SameSite=None** | Requiert OBLIGATOIREMENT Secure | Check explicite |
| **__Host- rules** | 3 regles: Secure, no Domain, Path=/ | Verifier les 3 |
| **Empty cookie value** | `name=` est valide | Gerer le cas |
| **Multiple cookies** | Un header peut avoir plusieurs cookies | Parser correctement |
| **Whitespace** | Espaces autour des valeurs | `.trim()` partout |

### 5.5 Cours Complet

#### 5.5.1 Histoire des Cookies

Les cookies HTTP ont ete inventes par Lou Montulli chez Netscape en 1994. Le but initial etait de permettre le "panier d'achat" sur les sites e-commerce.

**Evolution de la securite:**
- 1997: HttpOnly introduit par Microsoft (IE6)
- 2011: Secure flag standardise (RFC 6265)
- 2016: SameSite introduit par Chrome
- 2020: SameSite=Lax par defaut dans Chrome

#### 5.5.2 RFC 6265bis et Prefixes

Les prefixes `__Secure-` et `__Host-` sont definis dans RFC 6265bis (draft):

```
__Secure-*:
  - Cookie DOIT avoir le flag Secure
  - Garantit que le cookie ne sera jamais transmis en HTTP

__Host-*:
  - Cookie DOIT avoir le flag Secure
  - Cookie NE DOIT PAS avoir d'attribut Domain
  - Cookie DOIT avoir Path=/
  - Garantit que le cookie est strictement lie a l'origine
```

#### 5.5.3 Entropie des Sessions

L'entropie mesure l'imprevisibilite d'une valeur:

```
Entropie = log2(taille_espace)

Exemples:
- 6 caracteres alphanumeriques (a-z0-9): log2(36^6) â‰ˆ 31 bits
- 16 caracteres hex: log2(16^16) = 64 bits
- UUID v4: 122 bits effectifs
- 32 caracteres base64: log2(64^32) â‰ˆ 192 bits

Recommandation OWASP: minimum 128 bits
```

### 5.6 Normes avec explications pedagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais interdit)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if raw.contains("Secure") {  // Case-sensitive!               â”‚
â”‚     cookie.secure = true;                                      â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if raw.to_lowercase().contains("secure") {                     â”‚
â”‚     cookie.secure = true;                                      â”‚
â”‚ }                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ðŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ RFC 6265 : Headers HTTP sont case-insensitive                â”‚
â”‚ â€¢ "SECURE", "Secure", "secure" sont tous valides               â”‚
â”‚ â€¢ Rate des cookies valides = vulnerabilites manquees           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'execution

**Entree:**
```json
{
  "cookies": ["Set-Cookie: session=abc; Path=/"],
  "context": {"is_https": true}
}
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Instruction                                  â”‚ Etat                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Parse JSON input                             â”‚ input = AnalyzerInput{...}  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ Parse "Set-Cookie: session=abc; Path=/"      â”‚ cookie.name = "session"     â”‚
â”‚       â”‚                                              â”‚ cookie.value = "abc"        â”‚
â”‚       â”‚                                              â”‚ cookie.path = Some("/")     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Check HttpOnly: false                        â”‚ + Issue HttpOnly MISSING    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Check Secure: false + is_https: true         â”‚ + Issue Secure MISSING      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Check SameSite: None                         â”‚ + Issue SameSite MISSING    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Check prefix: "session" (no prefix)          â”‚ No prefix violations        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   7   â”‚ Analyze entropy: "abc" = 3 chars             â”‚ entropy â‰ˆ 15.5 bits         â”‚
â”‚       â”‚ charset = 3, bits = log2(3)*3                â”‚ predictable = true          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   8   â”‚ Generate recommendations                     â”‚ ["Add HttpOnly...",         â”‚
â”‚       â”‚                                              â”‚  "Add Secure...", ...]      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   9   â”‚ RETOURNER rapport JSON                       â”‚ Output complet              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 Mnemotechniques (MEME obligatoire)

#### ðŸ”¥ MEME: "Stranger Things : The Upside Down Cookie"

*Comme dans Stranger Things, un cookie sans protection est dans le "Upside Down" â€” un monde parallele ou tout est expose aux creatures malveillantes (attaquants).*

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Cookie SANS protection:                â”‚
â”‚  ðŸ™ƒ "I'm in the Upside Down"            â”‚
â”‚                                         â”‚
â”‚  - XSS peut me voler (pas HttpOnly)     â”‚
â”‚  - MITM peut m'intercepter (pas Secure) â”‚
â”‚  - CSRF peut m'utiliser (pas SameSite)  â”‚
â”‚                                         â”‚
â”‚  Cookie AVEC protection:                â”‚
â”‚  ðŸ˜Š "I'm safe in Hawkins"               â”‚
â”‚                                         â”‚
â”‚  __Host-session=x; Secure; HttpOnly;    â”‚
â”‚  SameSite=Strict                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### ðŸŽ¬ MEME: "Secure, HttpOnly, SameSite : La Sainte Trinite"

*Comme les trois hobbits qui doivent TOUS arriver au Mont Doom pour detruire l'anneau, tes trois attributs doivent TOUS etre presents pour une vraie securite.*

```
  Frodo (Secure)     + Sam (HttpOnly)    + Gollum (SameSite)
       |                    |                    |
       v                    v                    v
    HTTPS only         No JS access        CSRF protection

  UN seul manquant = Sauron (attaquant) gagne!
```

---

#### ðŸ’€ MEME: "__Host- : L'Arme Ultime"

*__Host- c'est comme Mjolnir â€” seul Thor (l'origine exacte) peut le soulever.*

```
__Host-session REQUIREMENTS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ“ Secure (HTTPS only)                 â”‚
â”‚  âœ“ Path=/ (root path)                  â”‚
â”‚  âœ— Domain (aucun!)                     â”‚
â”‚                                        â”‚
â”‚  "Whosoever holds this cookie,         â”‚
â”‚   if they be from the exact origin,    â”‚
â”‚   shall possess the power of session"  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.9 Applications pratiques

| Scenario | Application |
|----------|-------------|
| **Pre-deployment Audit** | Verifier tous les cookies avant mise en production |
| **Compliance Check** | RGPD requiert securisation des donnees utilisateur |
| **Penetration Testing** | Premiere etape de l'analyse de session |
| **Bug Bounty** | Cookie misconfiguration = reward frequent |
| **DevSecOps** | CI/CD gate pour bloquer cookies insecures |

---

## SECTION 6 : PIEGES â€” RECAPITULATIF

| # | Piege | Impact | Detection |
|---|-------|--------|-----------|
| 1 | Case-sensitivity | Rate des attributs valides | `.to_lowercase()` |
| 2 | SameSite=None sans Secure | Cookie rejete par navigateur | Check explicite |
| 3 | __Host- avec Domain | Violation de prefix | Verifier absence de Domain |
| 4 | Entropie mal calculee | Faux sentiment de securite | Formule correcte |
| 5 | Whitespace | Parsing incorrect | `.trim()` |
| 6 | Cookie malformed | Crash | Result/Option handling |

---

## SECTION 7 : QCM

[10 questions similaires aux exercices precedents, adaptees aux cookies]

---

## SECTION 8 : RECAPITULATIF

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   EXERCICE 3.3.1-f : Cookie Security Analyzer                              â”‚
â”‚                                                                             â”‚
â”‚   âœ… Concepts maitrises :                                                   â”‚
â”‚      â€¢ Parsing Set-Cookie RFC 6265                                          â”‚
â”‚      â€¢ Verification HttpOnly, Secure, SameSite                              â”‚
â”‚      â€¢ Validation prefixes __Secure-/__Host-                                â”‚
â”‚      â€¢ Estimation entropie de session                                       â”‚
â”‚      â€¢ Detection de predictibilite                                          â”‚
â”‚                                                                             â”‚
â”‚   ðŸ“Š Metriques :                                                            â”‚
â”‚      â€¢ Difficulte : 6/10                                                    â”‚
â”‚      â€¢ Duree : 3h                                                           â”‚
â”‚      â€¢ XP : 300 (base) / 900 (bonus)                                        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## SECTION 9 : DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.3.1-f-cookie_security_analyzer",
    "generated_at": "2026-01-11 12:30:00",

    "metadata": {
      "exercise_id": "3.3.1-f",
      "exercise_name": "cookie_security_analyzer",
      "module": "3.3.1",
      "module_name": "Architecture Web Moderne",
      "concept": "f",
      "concept_name": "Cookies Attributes Security",
      "type": "code",
      "tier": 2,
      "tier_info": "Melange (concepts 3.3.1.f + 3.3.1.g + 3.3.6.b)",
      "phase": 3,
      "difficulty": 6,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†â˜†",
      "language": "rust",
      "duration_minutes": 180,
      "xp_base": 300,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "bonus_icon": "ðŸ”¥",
      "complexity_time": "T2 O(n*m)",
      "complexity_space": "S1 O(n)",
      "prerequisites": ["3.3.1-a", "HTTP basics"],
      "domains": ["Net", "Crypto", "Encodage"],
      "meme_reference": "Stranger Things Upside Down"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” "L'excellence pedagogique ne se negocie pas"*
*Module 3.3.1-f : Cookie Security Analyzer â€” Complete*
