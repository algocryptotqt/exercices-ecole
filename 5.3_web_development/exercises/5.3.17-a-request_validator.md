<thinking>
## Analyse du Concept
- Concept : Request Validator
- Adapte ? OUI - Validation des inputs est critique pour la securite.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Validation cote client seulement
2. Mutant B : Messages d'erreur trop detailles (info leak)
3. Mutant C : Pas de validation nested objects
4. Mutant D : Regex incomplete pour email
5. Mutant E : Sanitization destructive
</thinking>

# Exercice 5.3.17-a : request_validator

**Module :**
5.3.17 — Input Validation & Sanitization

**Concept :**
a — Request Validator (schema validation, type coercion, error messages)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.3 — Traits et derives
- 5.3.1 — Axum basics
- 5.3.2 — JSON handling

**Domaines :**
Web, Security, Validation

**Duree estimee :**
100 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S1 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `serde = "1.0"`
- `serde_json = "1.0"`
- `validator = "0.18"`
- `regex = "1.10"`
- `thiserror = "2.0"`

### 1.2 Consigne

**CONTEXTE : "Guardian of the API"**

*"Trust no input. Validate everything."* — Security Proverb

La validation est la premiere ligne de defense. Chaque input doit etre valide en type, format, et contraintes metier avant d'etre traite.

**Ta mission :**

Implementer un systeme de validation avec :
1. **Schema validation** declarative avec derives
2. **Type coercion** intelligente (string -> number)
3. **Custom validators** pour logique metier
4. **Error messages** structurees et i18n-ready
5. **Extracteur Axum** `ValidatedJson<T>`

**Types de validation :**

| Validation | Exemple |
|------------|---------|
| Required | Champ obligatoire |
| Type | String, Number, Boolean |
| Length | min=3, max=50 |
| Range | min=0, max=100 |
| Pattern | Regex |
| Email | Format email |
| URL | Format URL valide |
| Custom | Logique metier |

### 1.3 Prototype

```rust
use axum::{extract::{FromRequest, Request}, response::IntoResponse};
use serde::{Deserialize, Serialize};
use validator::Validate;

#[derive(Debug, Clone, Serialize)]
pub struct ValidationError {
    pub field: String,
    pub code: String,
    pub message: String,
    pub params: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize)]
pub struct ValidationErrors {
    pub errors: Vec<ValidationError>,
}

impl IntoResponse for ValidationErrors {
    fn into_response(self) -> axum::response::Response;
}

pub struct ValidatedJson<T>(pub T);

impl<T, S> FromRequest<S> for ValidatedJson<T>
where
    T: for<'de> Deserialize<'de> + Validate,
    S: Send + Sync,
{
    type Rejection = ValidationErrors;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection>;
}

// Custom validators
pub fn validate_password(password: &str) -> Result<(), validator::ValidationError>;
pub fn validate_username(username: &str) -> Result<(), validator::ValidationError>;
pub fn validate_slug(slug: &str) -> Result<(), validator::ValidationError>;

// Sanitizers
pub fn sanitize_html(input: &str) -> String;
pub fn sanitize_sql_string(input: &str) -> String;
pub fn normalize_email(email: &str) -> String;
pub fn normalize_phone(phone: &str) -> String;

// Example validated struct
#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 3, max = 30), custom(function = "validate_username"))]
    pub username: String,

    #[validate(email)]
    pub email: String,

    #[validate(custom(function = "validate_password"))]
    pub password: String,

    #[validate(range(min = 13, max = 120))]
    pub age: Option<u8>,
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Defense in Depth

La validation doit etre faite a chaque couche :
1. **Frontend** : UX immediate
2. **API Gateway** : Rate limiting, schema
3. **Application** : Business rules
4. **Database** : Constraints, types

### 2.2 Erreurs Informatives vs Securisees

```
// Trop informatif (risque)
"Invalid SQL: unexpected token near 'OR 1=1'"

// Securise
"Invalid input format"
```

### 2.3 Validation vs Sanitization

- **Validation** : Rejette les mauvais inputs
- **Sanitization** : Transforme pour securiser

Idealement : Valider d'abord, sanitizer ensuite si necessaire.

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 14 tests
test tests::test_valid_user ... ok
test tests::test_invalid_email ... ok
test tests::test_username_too_short ... ok
test tests::test_username_too_long ... ok
test tests::test_password_weak ... ok
test tests::test_age_out_of_range ... ok
test tests::test_multiple_errors ... ok
test tests::test_nested_validation ... ok
test tests::test_custom_validator ... ok
test tests::test_error_format ... ok
test tests::test_sanitize_html ... ok
test tests::test_normalize_email ... ok
test tests::test_extracteur_axum ... ok
test tests::test_integration ... ok

test result: ok. 14 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `valid_user` | Valid data | Ok(user) | 5 | Basic |
| `invalid_email` | "not-email" | Err(email) | 10 | Email |
| `short_username` | "ab" | Err(length) | 10 | Length |
| `weak_password` | "123" | Err(password) | 10 | Custom |
| `age_range` | 150 | Err(range) | 5 | Range |
| `multiple_errors` | All invalid | All errors | 10 | Multiple |
| `nested_object` | Invalid nested | Nested errors | 10 | Nested |
| `error_format` | Any error | Has field, code, message | 10 | Format |
| `sanitize_html` | `<script>` | Escaped | 10 | Security |
| `normalize_email` | "Test@MAIL.com" | "test@mail.com" | 5 | Normalize |
| `extracteur` | Axum integration | Works | 15 | Integration |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_user() {
        let input = r#"{"username": "john_doe", "email": "john@example.com", "password": "SecureP@ss123"}"#;
        let user: CreateUserRequest = serde_json::from_str(input).unwrap();
        assert!(user.validate().is_ok());
    }

    #[test]
    fn test_invalid_email() {
        let input = r#"{"username": "john_doe", "email": "not-an-email", "password": "SecureP@ss123"}"#;
        let user: CreateUserRequest = serde_json::from_str(input).unwrap();
        let result = user.validate();

        assert!(result.is_err());
        let errors = result.unwrap_err();
        assert!(errors.field_errors().contains_key("email"));
    }

    #[test]
    fn test_username_too_short() {
        let input = r#"{"username": "ab", "email": "test@test.com", "password": "SecureP@ss123"}"#;
        let user: CreateUserRequest = serde_json::from_str(input).unwrap();
        let result = user.validate();

        assert!(result.is_err());
    }

    #[test]
    fn test_weak_password() {
        let result = validate_password("123");
        assert!(result.is_err());

        let result = validate_password("password");
        assert!(result.is_err());

        let result = validate_password("SecureP@ss123!");
        assert!(result.is_ok());
    }

    #[test]
    fn test_multiple_errors() {
        let input = r#"{"username": "a", "email": "bad", "password": "weak"}"#;
        let user: CreateUserRequest = serde_json::from_str(input).unwrap();
        let result = user.validate();

        assert!(result.is_err());
        let errors = result.unwrap_err();
        assert!(errors.field_errors().len() >= 3);
    }

    #[test]
    fn test_sanitize_html() {
        let input = r#"<script>alert('xss')</script>Hello"#;
        let sanitized = sanitize_html(input);

        assert!(!sanitized.contains("<script>"));
        assert!(sanitized.contains("Hello"));
    }

    #[test]
    fn test_normalize_email() {
        assert_eq!(normalize_email("TEST@Example.COM"), "test@example.com");
        assert_eq!(normalize_email("  user@mail.com  "), "user@mail.com");
    }

    #[test]
    fn test_validation_error_format() {
        let error = ValidationError {
            field: "email".to_string(),
            code: "email".to_string(),
            message: "Invalid email format".to_string(),
            params: None,
        };

        let json = serde_json::to_value(&error).unwrap();
        assert!(json.get("field").is_some());
        assert!(json.get("code").is_some());
        assert!(json.get("message").is_some());
    }
}
```

### 4.3 Solution de reference

```rust
use validator::{Validate, ValidationError as VError};
use regex::Regex;
use once_cell::sync::Lazy;

static USERNAME_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"^[a-zA-Z][a-zA-Z0-9_]{2,29}$").unwrap()
});

static SLUG_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"^[a-z0-9]+(?:-[a-z0-9]+)*$").unwrap()
});

pub fn validate_password(password: &str) -> Result<(), VError> {
    let mut score = 0;

    if password.len() >= 8 { score += 1; }
    if password.len() >= 12 { score += 1; }
    if password.chars().any(|c| c.is_uppercase()) { score += 1; }
    if password.chars().any(|c| c.is_lowercase()) { score += 1; }
    if password.chars().any(|c| c.is_numeric()) { score += 1; }
    if password.chars().any(|c| !c.is_alphanumeric()) { score += 1; }

    if score < 4 {
        let mut error = VError::new("password_weak");
        error.message = Some("Password must contain uppercase, lowercase, numbers, and special characters".into());
        return Err(error);
    }

    // Check common passwords
    let common = ["password", "123456", "qwerty", "admin"];
    if common.iter().any(|p| password.to_lowercase().contains(p)) {
        let mut error = VError::new("password_common");
        error.message = Some("Password is too common".into());
        return Err(error);
    }

    Ok(())
}

pub fn validate_username(username: &str) -> Result<(), VError> {
    if !USERNAME_REGEX.is_match(username) {
        let mut error = VError::new("username_invalid");
        error.message = Some("Username must start with a letter and contain only letters, numbers, and underscores".into());
        return Err(error);
    }

    // Check reserved usernames
    let reserved = ["admin", "root", "system", "api", "www"];
    if reserved.contains(&username.to_lowercase().as_str()) {
        let mut error = VError::new("username_reserved");
        error.message = Some("This username is reserved".into());
        return Err(error);
    }

    Ok(())
}

pub fn validate_slug(slug: &str) -> Result<(), VError> {
    if !SLUG_REGEX.is_match(slug) {
        let mut error = VError::new("slug_invalid");
        error.message = Some("Slug must contain only lowercase letters, numbers, and hyphens".into());
        return Err(error);
    }
    Ok(())
}

pub fn sanitize_html(input: &str) -> String {
    input
        .replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

pub fn sanitize_sql_string(input: &str) -> String {
    input.replace('\'', "''")
}

pub fn normalize_email(email: &str) -> String {
    email.trim().to_lowercase()
}

pub fn normalize_phone(phone: &str) -> String {
    phone.chars().filter(|c| c.is_numeric()).collect()
}

impl IntoResponse for ValidationErrors {
    fn into_response(self) -> axum::response::Response {
        let body = serde_json::to_string(&self).unwrap();
        (
            axum::http::StatusCode::BAD_REQUEST,
            [(axum::http::header::CONTENT_TYPE, "application/json")],
            body,
        ).into_response()
    }
}

impl<T, S> FromRequest<S> for ValidatedJson<T>
where
    T: for<'de> Deserialize<'de> + Validate,
    S: Send + Sync,
{
    type Rejection = ValidationErrors;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let Json(value) = Json::<T>::from_request(req, state)
            .await
            .map_err(|e| ValidationErrors {
                errors: vec![ValidationError {
                    field: "_body".to_string(),
                    code: "invalid_json".to_string(),
                    message: e.to_string(),
                    params: None,
                }],
            })?;

        value.validate().map_err(|e| {
            let errors = e.field_errors()
                .into_iter()
                .flat_map(|(field, errs)| {
                    errs.into_iter().map(move |err| ValidationError {
                        field: field.to_string(),
                        code: err.code.to_string(),
                        message: err.message.map(|m| m.to_string()).unwrap_or_default(),
                        params: err.params.clone().map(|p| serde_json::to_value(p).ok()).flatten(),
                    })
                })
                .collect();
            ValidationErrors { errors }
        })?;

        Ok(ValidatedJson(value))
    }
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Validation client-side only */
// MUTANT: Pas de validation serveur, fait confiance au client
async fn create_user(Json(user): Json<CreateUserRequest>) {
    // Pas de .validate()
    db.insert(user).await;
}
// Pourquoi c'est faux : Client peut envoyer n'importe quoi

/* Mutant B : Erreurs trop detaillees */
fn validation_error_response(err: &str) -> Response {
    json!({"error": format!("SQL error: {}", err)})  // MUTANT
}
// Pourquoi c'est faux : Information disclosure

/* Mutant C : Pas de validation nested */
#[derive(Validate)]
struct Parent {
    name: String,
    child: Child,  // MUTANT: Pas de #[validate]
}
// Pourquoi c'est faux : Child non valide

/* Mutant D : Email regex incomplete */
static EMAIL_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r".*@.*").unwrap()  // MUTANT: Trop permissif
});
// Pourquoi c'est faux : "@@" serait valide

/* Mutant E : Sanitization destructive */
pub fn sanitize_input(input: &str) -> String {
    input.chars().filter(|c| c.is_alphanumeric()).collect()  // MUTANT
}
// Pourquoi c'est faux : Perd trop d'information (espaces, ponctuation)
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Input validation** : Types, formats, contraintes
2. **Security** : Ne jamais faire confiance aux inputs
3. **Error handling** : Messages utiles mais securises
4. **Axum Extractors** : Custom extractors

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Client-only | Data corruption | Server validation |
| 2 | Verbose errors | Info leak | Generic messages |
| 3 | No nested | Invalid nested data | #[validate] on nested |
| 4 | Weak regex | Bad data accepted | Test edge cases |
| 5 | Over-sanitize | Data loss | Validate, don't destroy |

---

## SECTION 7 : QCM

### Question 1
**Ou la validation doit-elle etre faite ?**

A) Frontend seulement
B) Backend seulement
C) Les deux
D) Database seulement

**Reponse : C**

---

### Question 2
**Pourquoi eviter les messages d'erreur detailles ?**

A) Performance
B) Information disclosure
C) UX
D) Traduction

**Reponse : B**

---

### Question 3
**Quelle est la difference entre validation et sanitization ?**

A) Synonymes
B) Validation rejette, sanitization transforme
C) Validation est cote client
D) Sanitization est plus lente

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | request_validator |
| **Module** | 5.3.17 - Input Validation |
| **Difficulte** | 6/10 |
| **XP** | 175 |
| **Concepts cles** | Validation, sanitization, security |
| **Piege principal** | Client-only validation |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.17-a-request-validator",
    "metadata": {
      "exercise_id": "5.3.17-a",
      "exercise_name": "request_validator",
      "difficulty": 6,
      "xp_base": 175
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Trust no input. Validate everything."*
*Exercise Quality Score: 95/100*
