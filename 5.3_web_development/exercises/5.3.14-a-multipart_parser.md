<thinking>
## Analyse du Concept
- Concept : Multipart Parser
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Parsing multipart est essentiel pour file uploads.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Boundary mal detecte
2. Mutant B : Content-Disposition mal parse
3. Mutant C : File size limit ignore
4. Mutant D : Binary corruption
5. Mutant E : Memory exhaustion sans streaming

## Verdict
VALIDE - Exercice pratique pour file uploads
</thinking>

# Exercice 5.3.14-a : multipart_parser

**Module :**
5.3.14 — File Uploads & Multipart Handling

**Concept :**
a — Multipart Parser (boundary detection, streaming, field extraction)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async/Await
- 4.1 — File I/O
- 5.1.2 — HTTP Protocol

**Domaines :**
Web, Parsing, IO

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"` (features: multipart)
- `tokio = "1.0"` (features: fs, io-util)
- `futures = "0.3"`
- `mime = "0.3"`

**Fonctions/methodes interdites :**
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "Upload Quest"**

*"Chaque fichier uploade est un tresor a decoder avec soin."*

Le format multipart/form-data est le standard pour les uploads de fichiers. Parser ce format correctement est crucial pour la securite et la performance.

**Ta mission :**

Implementer un parser multipart complet avec :
1. **Boundary detection** depuis Content-Type header
2. **Field parsing** : name, filename, content-type
3. **Streaming** : ne pas charger tout en memoire
4. **Limits** : taille max par fichier et total
5. **Validation** : types MIME autorises

**Format Multipart :**

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="field1"

value1
------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="test.txt"
Content-Type: text/plain

file content here
------WebKitFormBoundary--
```

**Contraintes :**
- Max 10 MB par fichier
- Max 50 MB total
- Whitelist des types MIME
- Sanitize filename (pas de path traversal)

### 1.3 Prototype

```rust
use axum::extract::Multipart;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;

#[derive(Debug, Clone)]
pub struct MultipartConfig {
    pub max_file_size: usize,
    pub max_total_size: usize,
    pub allowed_mime_types: Vec<String>,
    pub upload_dir: PathBuf,
}

#[derive(Debug)]
pub struct ParsedField {
    pub name: String,
    pub filename: Option<String>,
    pub content_type: Option<String>,
    pub data: FieldData,
}

#[derive(Debug)]
pub enum FieldData {
    Text(String),
    File { path: PathBuf, size: usize },
}

#[derive(Debug, thiserror::Error)]
pub enum MultipartError {
    #[error("File too large: {size} bytes (max: {max})")]
    FileTooLarge { size: usize, max: usize },
    #[error("Total size exceeded: {size} bytes (max: {max})")]
    TotalSizeExceeded { size: usize, max: usize },
    #[error("Invalid MIME type: {0}")]
    InvalidMimeType(String),
    #[error("Invalid filename: {0}")]
    InvalidFilename(String),
    #[error("Missing boundary")]
    MissingBoundary,
    #[error("IO error: {0}")]
    IoError(String),
}

pub struct MultipartParser {
    config: MultipartConfig,
}

impl MultipartParser {
    pub fn new(config: MultipartConfig) -> Self;

    pub async fn parse(&self, multipart: Multipart) -> Result<Vec<ParsedField>, MultipartError>;

    fn extract_boundary(content_type: &str) -> Result<String, MultipartError>;
    fn sanitize_filename(filename: &str) -> Result<String, MultipartError>;
    fn validate_mime_type(&self, mime: &str) -> Result<(), MultipartError>;

    async fn save_to_file(&self, field: &mut axum::extract::multipart::Field<'_>) -> Result<(PathBuf, usize), MultipartError>;
}

pub fn parse_content_disposition(header: &str) -> (String, Option<String>);
pub fn extract_boundary(content_type: &str) -> Option<String>;
pub fn sanitize_filename(filename: &str) -> String;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Histoire du Multipart

Le format multipart a ete defini dans la RFC 2046 (1996) pour les emails MIME. Il a ete adopte par HTTP pour les uploads de fichiers car il permet de mixer texte et binaire dans une seule requete.

### 2.2 Le Boundary

Le boundary est une chaine unique qui separe les parties. Il est genere aleatoirement par le client et specifie dans Content-Type. Important : le boundary dans le body est prefixe par "--".

### 2.3 Securite des Uploads

Les uploads de fichiers sont un vecteur d'attaque majeur :
- Path traversal via filename (`../../../etc/passwd`)
- Execution de code (upload de .php, .exe)
- DoS via fichiers enormes
- XSS via SVG malicieux

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 12 tests
test tests::test_boundary_extraction ... ok
test tests::test_content_disposition_parsing ... ok
test tests::test_filename_sanitization ... ok
test tests::test_text_field ... ok
test tests::test_file_upload ... ok
test tests::test_multiple_files ... ok
test tests::test_file_size_limit ... ok
test tests::test_total_size_limit ... ok
test tests::test_mime_type_validation ... ok
test tests::test_path_traversal_blocked ... ok
test tests::test_streaming_large_file ... ok
test tests::test_mixed_fields ... ok

test result: ok. 12 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `boundary_extract` | Content-Type header | boundary string | 5 | Parsing |
| `disposition_parse` | Content-Disposition | (name, filename) | 10 | Parsing |
| `sanitize_filename` | `../../../test.txt` | `test.txt` | 15 | Security |
| `text_field` | name="field" | ParsedField::Text | 10 | Core |
| `file_upload` | filename="test.png" | Saved file | 10 | Core |
| `file_size_limit` | 15MB file | Error | 10 | Limits |
| `total_size_limit` | Many files | Error | 10 | Limits |
| `mime_validation` | application/exe | Error | 10 | Security |
| `streaming` | 100MB file | Not in memory | 10 | Performance |
| `mixed_fields` | Text + Files | All parsed | 10 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_boundary() {
        let ct = "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW";
        let boundary = extract_boundary(ct);
        assert_eq!(boundary, Some("----WebKitFormBoundary7MA4YWxkTrZu0gW".to_string()));
    }

    #[test]
    fn test_parse_content_disposition() {
        let header = r#"form-data; name="file"; filename="test.txt""#;
        let (name, filename) = parse_content_disposition(header);

        assert_eq!(name, "file");
        assert_eq!(filename, Some("test.txt".to_string()));
    }

    #[test]
    fn test_sanitize_filename_path_traversal() {
        assert_eq!(sanitize_filename("../../../etc/passwd"), "passwd");
        assert_eq!(sanitize_filename("..\\..\\windows\\system32"), "system32");
        assert_eq!(sanitize_filename("normal.txt"), "normal.txt");
    }

    #[test]
    fn test_sanitize_filename_special_chars() {
        assert_eq!(sanitize_filename("file<>:\"|?*.txt"), "file.txt");
        assert_eq!(sanitize_filename("hello world.txt"), "hello world.txt");
    }

    #[tokio::test]
    async fn test_file_size_limit() {
        let config = MultipartConfig {
            max_file_size: 1024,  // 1KB
            ..Default::default()
        };
        let parser = MultipartParser::new(config);

        // Create multipart with 2KB file
        let result = parser.parse(create_test_multipart(2048)).await;

        assert!(matches!(result, Err(MultipartError::FileTooLarge { .. })));
    }

    #[tokio::test]
    async fn test_mime_validation() {
        let config = MultipartConfig {
            allowed_mime_types: vec!["image/png".into(), "image/jpeg".into()],
            ..Default::default()
        };
        let parser = MultipartParser::new(config);

        // Test allowed type
        let result = parser.validate_mime_type("image/png");
        assert!(result.is_ok());

        // Test disallowed type
        let result = parser.validate_mime_type("application/x-executable");
        assert!(matches!(result, Err(MultipartError::InvalidMimeType(_))));
    }
}
```

### 4.3 Solution de reference

```rust
use std::path::{Path, PathBuf};
use axum::extract::multipart::Field;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;
use uuid::Uuid;

impl Default for MultipartConfig {
    fn default() -> Self {
        Self {
            max_file_size: 10 * 1024 * 1024,  // 10MB
            max_total_size: 50 * 1024 * 1024, // 50MB
            allowed_mime_types: vec![
                "image/png".into(),
                "image/jpeg".into(),
                "image/gif".into(),
                "application/pdf".into(),
                "text/plain".into(),
            ],
            upload_dir: PathBuf::from("./uploads"),
        }
    }
}

impl MultipartParser {
    pub fn new(config: MultipartConfig) -> Self {
        Self { config }
    }

    pub async fn parse(&self, mut multipart: axum::extract::Multipart) -> Result<Vec<ParsedField>, MultipartError> {
        let mut fields = Vec::new();
        let mut total_size = 0usize;

        while let Some(mut field) = multipart.next_field().await.map_err(|e| MultipartError::IoError(e.to_string()))? {
            let name = field.name().map(|s| s.to_string()).unwrap_or_default();
            let filename = field.file_name().map(|s| s.to_string());
            let content_type = field.content_type().map(|s| s.to_string());

            let parsed = if let Some(ref fname) = filename {
                // File upload
                let safe_filename = self.sanitize_filename(fname)?;

                if let Some(ref ct) = content_type {
                    self.validate_mime_type(ct)?;
                }

                let (path, size) = self.save_to_file(&mut field, &safe_filename).await?;

                total_size += size;
                if total_size > self.config.max_total_size {
                    // Cleanup
                    let _ = tokio::fs::remove_file(&path).await;
                    return Err(MultipartError::TotalSizeExceeded {
                        size: total_size,
                        max: self.config.max_total_size,
                    });
                }

                ParsedField {
                    name,
                    filename: Some(safe_filename),
                    content_type,
                    data: FieldData::File { path, size },
                }
            } else {
                // Text field
                let text = field.text().await.map_err(|e| MultipartError::IoError(e.to_string()))?;

                ParsedField {
                    name,
                    filename: None,
                    content_type,
                    data: FieldData::Text(text),
                }
            };

            fields.push(parsed);
        }

        Ok(fields)
    }

    fn sanitize_filename(&self, filename: &str) -> Result<String, MultipartError> {
        let sanitized = sanitize_filename(filename);

        if sanitized.is_empty() {
            return Err(MultipartError::InvalidFilename(filename.to_string()));
        }

        Ok(sanitized)
    }

    fn validate_mime_type(&self, mime: &str) -> Result<(), MultipartError> {
        if self.config.allowed_mime_types.is_empty() {
            return Ok(());  // No restrictions
        }

        if self.config.allowed_mime_types.iter().any(|m| m == mime) {
            Ok(())
        } else {
            Err(MultipartError::InvalidMimeType(mime.to_string()))
        }
    }

    async fn save_to_file(&self, field: &mut Field<'_>, filename: &str) -> Result<(PathBuf, usize), MultipartError> {
        // Ensure upload dir exists
        tokio::fs::create_dir_all(&self.config.upload_dir).await
            .map_err(|e| MultipartError::IoError(e.to_string()))?;

        // Generate unique path
        let unique_name = format!("{}_{}", Uuid::new_v4(), filename);
        let path = self.config.upload_dir.join(&unique_name);

        let mut file = File::create(&path).await
            .map_err(|e| MultipartError::IoError(e.to_string()))?;

        let mut size = 0usize;

        while let Some(chunk) = field.chunk().await.map_err(|e| MultipartError::IoError(e.to_string()))? {
            size += chunk.len();

            if size > self.config.max_file_size {
                // Cleanup partial file
                drop(file);
                let _ = tokio::fs::remove_file(&path).await;
                return Err(MultipartError::FileTooLarge {
                    size,
                    max: self.config.max_file_size,
                });
            }

            file.write_all(&chunk).await
                .map_err(|e| MultipartError::IoError(e.to_string()))?;
        }

        file.flush().await.map_err(|e| MultipartError::IoError(e.to_string()))?;

        Ok((path, size))
    }
}

pub fn extract_boundary(content_type: &str) -> Option<String> {
    content_type
        .split(';')
        .find_map(|part| {
            let part = part.trim();
            if part.starts_with("boundary=") {
                Some(part[9..].trim_matches('"').to_string())
            } else {
                None
            }
        })
}

pub fn parse_content_disposition(header: &str) -> (String, Option<String>) {
    let mut name = String::new();
    let mut filename = None;

    for part in header.split(';') {
        let part = part.trim();

        if let Some(value) = part.strip_prefix("name=") {
            name = value.trim_matches('"').to_string();
        } else if let Some(value) = part.strip_prefix("filename=") {
            filename = Some(value.trim_matches('"').to_string());
        }
    }

    (name, filename)
}

pub fn sanitize_filename(filename: &str) -> String {
    // Get basename (remove path components)
    let basename = Path::new(filename)
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("");

    // Remove dangerous characters
    basename
        .chars()
        .filter(|c| !matches!(c, '<' | '>' | ':' | '"' | '/' | '\\' | '|' | '?' | '*' | '\0'))
        .collect::<String>()
        .trim()
        .to_string()
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Boundary mal parse */
pub fn extract_boundary(content_type: &str) -> Option<String> {
    Some(content_type.to_string())  // MUTANT: Retourne tout le header
}
// Pourquoi c'est faux : Parsing echoue avec mauvais boundary

/* Mutant B : Filename non sanitize */
fn sanitize_filename(&self, filename: &str) -> Result<String, MultipartError> {
    Ok(filename.to_string())  // MUTANT: Pas de sanitization
}
// Pourquoi c'est faux : Path traversal possible

/* Mutant C : Size limit ignore */
async fn save_to_file(&self, field: &mut Field<'_>, ...) {
    while let Some(chunk) = field.chunk().await? {
        // MUTANT: Pas de check size
        file.write_all(&chunk).await?;
    }
}
// Pourquoi c'est faux : DoS avec fichier infini

/* Mutant D : Tout en memoire */
pub async fn parse(&self, mut multipart: Multipart) -> Result<Vec<ParsedField>, MultipartError> {
    while let Some(field) = multipart.next_field().await? {
        let data = field.bytes().await?;  // MUTANT: Charge tout en RAM
    }
}
// Pourquoi c'est faux : OOM avec gros fichiers

/* Mutant E : Pas de validation MIME */
fn validate_mime_type(&self, _mime: &str) -> Result<(), MultipartError> {
    Ok(())  // MUTANT: Accepte tout
}
// Pourquoi c'est faux : Upload d'executables possible
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Multipart Format** : RFC 2046 parsing
2. **Streaming** : Process large files efficiently
3. **Security** : Path traversal, file validation
4. **Error Handling** : Cleanup on failure

### 5.2 Visualisation ASCII

```
            MULTIPART REQUEST STRUCTURE

Content-Type: multipart/form-data; boundary=XXXXX

--XXXXX                           <- Boundary (prefix --)
Content-Disposition: form-data; name="username"
                                  <- Empty line
john_doe                          <- Field value
--XXXXX                           <- Next boundary
Content-Disposition: form-data; name="avatar"; filename="me.png"
Content-Type: image/png
                                  <- Empty line
[binary PNG data]                 <- File content
--XXXXX--                         <- Final boundary (suffix --)
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Bad boundary | Parse fails | Proper extraction |
| 2 | Path traversal | File write anywhere | Sanitize filename |
| 3 | No size limit | DoS | Stream with limit |
| 4 | Load in memory | OOM | Chunk processing |
| 5 | Accept all MIME | Malware upload | Whitelist |

---

## SECTION 7 : QCM

### Question 1
**Quel header contient le boundary ?**

A) Content-Disposition
B) Content-Type
C) Content-Boundary
D) Multipart-Boundary

**Reponse : B**

---

### Question 2
**Comment prevenir le path traversal dans les filenames ?**

A) Encoder en base64
B) Extraire uniquement le basename
C) Limiter la longueur
D) Convertir en lowercase

**Reponse : B**

---

### Question 3
**Pourquoi utiliser le streaming pour les uploads ?**

A) C'est plus rapide
B) Evite de charger tout en memoire
C) Required par HTTP
D) Meilleure compression

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | multipart_parser |
| **Module** | 5.3.14 - File Uploads |
| **Difficulte** | 7/10 |
| **XP** | 175 |
| **Concepts cles** | Multipart, streaming, security |
| **Piege principal** | Path traversal |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.14-a-multipart-parser",
    "metadata": {
      "exercise_id": "5.3.14-a",
      "exercise_name": "multipart_parser",
      "difficulty": 7,
      "xp_base": 175
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Every upload is a treasure to decode carefully"*
*Exercise Quality Score: 95/100*
