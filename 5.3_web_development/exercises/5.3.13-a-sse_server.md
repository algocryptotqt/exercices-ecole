<thinking>
## Analyse du Concept
- Concept : SSE Server (Server-Sent Events)
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - SSE est essentiel pour les notifications push unidirectionnelles.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Format SSE incorrect (pas de "data:")
2. Mutant B : Pas de reconnexion avec Last-Event-ID
3. Mutant C : Keep-alive manquant
4. Mutant D : Event type non specifie
5. Mutant E : Stream non termine proprement

## Verdict
VALIDE - Exercice complementaire a WebSocket pour cas unidirectionnels
</thinking>

# Exercice 5.3.13-a : sse_server

**Module :**
5.3.13 — Server-Sent Events for Push Notifications

**Concept :**
a — SSE Server (event stream, reconnection, event types)

**Difficulte :**
5/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async/Await et Tokio
- 5.1.2 — HTTP Protocol
- 5.3.1 — Axum basics

**Domaines :**
Web, Realtime, Streaming

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `tokio = "1.0"` (features: sync, time)
- `tokio-stream = "0.1"`
- `futures = "0.3"`
- `serde = "1.0"`
- `serde_json = "1.0"`

### 1.2 Consigne

**CONTEXTE : "Breaking News Stream"**

*"This just in... Server-Sent Events are simpler than WebSocket for one-way data!"*

Quand tu as besoin d'envoyer des updates du serveur vers le client sans reponse, SSE est plus simple que WebSocket.

**Ta mission :**

Implementer un serveur SSE complet avec :
1. **Event stream** au format SSE standard
2. **Event IDs** pour la reconnexion
3. **Event types** pour categoriser les events
4. **Keep-alive** comments pour maintenir la connexion
5. **Reconnection** support avec Last-Event-ID

**Format SSE :**

```
event: notification
id: 123
data: {"type": "alert", "message": "Hello"}

: keep-alive comment

event: update
id: 124
data: {"count": 42}
data: {"continued": true}

```

**Contraintes :**
- Content-Type: text/event-stream
- Chaque event termine par double newline
- Keep-alive toutes les 15 secondes
- Support multi-line data

### 1.3 Prototype

```rust
use axum::response::sse::{Event, Sse};
use tokio_stream::Stream;
use std::convert::Infallible;

#[derive(Debug, Clone)]
pub struct SseEvent {
    pub id: Option<String>,
    pub event_type: Option<String>,
    pub data: String,
    pub retry: Option<u64>,
}

pub struct SseService {
    events: broadcast::Sender<SseEvent>,
    last_event_id: AtomicU64,
}

impl SseService {
    pub fn new() -> Self;

    pub fn send(&self, event: SseEvent);
    pub fn send_data(&self, data: impl Serialize);
    pub fn send_typed(&self, event_type: &str, data: impl Serialize);

    pub fn subscribe(&self) -> impl Stream<Item = Result<Event, Infallible>>;
    pub fn subscribe_from(&self, last_event_id: Option<u64>) -> impl Stream<Item = Result<Event, Infallible>>;
}

pub async fn sse_handler(
    State(service): State<Arc<SseService>>,
    headers: HeaderMap,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>>;

impl SseEvent {
    pub fn new(data: impl Into<String>) -> Self;
    pub fn with_id(self, id: impl Into<String>) -> Self;
    pub fn with_event(self, event_type: impl Into<String>) -> Self;
    pub fn with_retry(self, ms: u64) -> Self;

    pub fn to_sse_event(&self) -> Event;
}

pub fn format_sse(event: &SseEvent) -> String;
pub fn parse_last_event_id(headers: &HeaderMap) -> Option<u64>;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 SSE vs WebSocket

| SSE | WebSocket |
|-----|-----------|
| Unidirectionnel (serveur -> client) | Bidirectionnel |
| HTTP standard | Protocol specifique |
| Reconnexion automatique | Manual |
| Text only | Text + Binary |
| Simpler | More complex |

### 2.2 Le Format SSE

```
event: eventname     <- Type d'event (optionnel)
id: 123              <- ID pour reconnexion (optionnel)
retry: 3000          <- Delai reconnexion en ms (optionnel)
data: line1          <- Donnees (peut etre multi-ligne)
data: line2
                     <- Double newline = fin d'event
```

### 2.3 Reconnexion Automatique

Le navigateur se reconnecte automatiquement avec le header `Last-Event-ID` contenant le dernier ID recu. Le serveur peut renvoyer les events manques.

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 10 tests
test tests::test_event_creation ... ok
test tests::test_event_formatting ... ok
test tests::test_multiline_data ... ok
test tests::test_broadcast ... ok
test tests::test_keep_alive ... ok
test tests::test_last_event_id ... ok
test tests::test_reconnection ... ok
test tests::test_event_types ... ok
test tests::test_retry_field ... ok
test tests::test_content_type ... ok

test result: ok. 10 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `format_basic` | SseEvent::new("hello") | "data: hello\n\n" | 10 | Format |
| `format_with_id` | event.with_id("123") | Includes "id: 123\n" | 10 | Format |
| `format_with_type` | event.with_event("alert") | Includes "event: alert\n" | 10 | Format |
| `multiline_data` | "line1\nline2" | "data: line1\ndata: line2\n\n" | 10 | Format |
| `broadcast` | Send to subscribers | All receive | 15 | Core |
| `keep_alive` | 15 sec interval | Comment sent | 10 | Connection |
| `last_event_id` | Reconnect header | Events since ID | 15 | Reconnection |
| `content_type` | GET /events | text/event-stream | 10 | Headers |
| `retry_field` | with_retry(3000) | "retry: 3000\n" | 5 | Format |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_basic_event() {
        let event = SseEvent::new("hello world");
        let formatted = format_sse(&event);

        assert_eq!(formatted, "data: hello world\n\n");
    }

    #[test]
    fn test_format_with_id() {
        let event = SseEvent::new("data").with_id("123");
        let formatted = format_sse(&event);

        assert!(formatted.contains("id: 123\n"));
        assert!(formatted.contains("data: data\n"));
    }

    #[test]
    fn test_format_with_event_type() {
        let event = SseEvent::new("payload").with_event("notification");
        let formatted = format_sse(&event);

        assert!(formatted.contains("event: notification\n"));
    }

    #[test]
    fn test_multiline_data() {
        let event = SseEvent::new("line1\nline2\nline3");
        let formatted = format_sse(&event);

        assert_eq!(formatted, "data: line1\ndata: line2\ndata: line3\n\n");
    }

    #[tokio::test]
    async fn test_broadcast() {
        let service = SseService::new();
        let mut rx1 = service.subscribe();
        let mut rx2 = service.subscribe();

        service.send(SseEvent::new("test"));

        // Both should receive
        assert!(rx1.next().await.is_some());
        assert!(rx2.next().await.is_some());
    }

    #[test]
    fn test_parse_last_event_id() {
        let mut headers = HeaderMap::new();
        headers.insert("Last-Event-ID", "42".parse().unwrap());

        let id = parse_last_event_id(&headers);
        assert_eq!(id, Some(42));
    }
}
```

### 4.3 Solution de reference

```rust
use axum::response::sse::{Event, KeepAlive, Sse};
use std::convert::Infallible;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::broadcast;
use tokio_stream::{wrappers::BroadcastStream, Stream, StreamExt};

#[derive(Debug, Clone)]
pub struct SseEvent {
    pub id: Option<String>,
    pub event_type: Option<String>,
    pub data: String,
    pub retry: Option<u64>,
}

impl SseEvent {
    pub fn new(data: impl Into<String>) -> Self {
        Self {
            id: None,
            event_type: None,
            data: data.into(),
            retry: None,
        }
    }

    pub fn with_id(mut self, id: impl Into<String>) -> Self {
        self.id = Some(id.into());
        self
    }

    pub fn with_event(mut self, event_type: impl Into<String>) -> Self {
        self.event_type = Some(event_type.into());
        self
    }

    pub fn with_retry(mut self, ms: u64) -> Self {
        self.retry = Some(ms);
        self
    }

    pub fn to_sse_event(&self) -> Event {
        let mut event = Event::default().data(&self.data);

        if let Some(ref id) = self.id {
            event = event.id(id);
        }
        if let Some(ref event_type) = self.event_type {
            event = event.event(event_type);
        }
        if let Some(retry) = self.retry {
            event = event.retry(Duration::from_millis(retry));
        }

        event
    }
}

pub fn format_sse(event: &SseEvent) -> String {
    let mut output = String::new();

    if let Some(ref event_type) = event.event_type {
        output.push_str(&format!("event: {}\n", event_type));
    }

    if let Some(ref id) = event.id {
        output.push_str(&format!("id: {}\n", id));
    }

    if let Some(retry) = event.retry {
        output.push_str(&format!("retry: {}\n", retry));
    }

    // Handle multi-line data
    for line in event.data.lines() {
        output.push_str(&format!("data: {}\n", line));
    }

    output.push('\n');  // Double newline to end event
    output
}

pub struct SseService {
    events: broadcast::Sender<SseEvent>,
    last_event_id: AtomicU64,
    event_history: Arc<tokio::sync::RwLock<Vec<SseEvent>>>,
}

impl SseService {
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(100);
        Self {
            events: tx,
            last_event_id: AtomicU64::new(0),
            event_history: Arc::new(tokio::sync::RwLock::new(Vec::new())),
        }
    }

    pub fn send(&self, mut event: SseEvent) {
        let id = self.last_event_id.fetch_add(1, Ordering::SeqCst);
        event.id = Some(id.to_string());

        // Store for replay
        let history = Arc::clone(&self.event_history);
        let event_clone = event.clone();
        tokio::spawn(async move {
            let mut history = history.write().await;
            history.push(event_clone);
            // Keep last 100 events
            if history.len() > 100 {
                history.remove(0);
            }
        });

        let _ = self.events.send(event);
    }

    pub fn send_data<T: serde::Serialize>(&self, data: T) {
        let json = serde_json::to_string(&data).unwrap();
        self.send(SseEvent::new(json));
    }

    pub fn send_typed<T: serde::Serialize>(&self, event_type: &str, data: T) {
        let json = serde_json::to_string(&data).unwrap();
        self.send(SseEvent::new(json).with_event(event_type));
    }

    pub fn subscribe(&self) -> impl Stream<Item = Result<Event, Infallible>> {
        let rx = self.events.subscribe();
        BroadcastStream::new(rx)
            .filter_map(|result| async move {
                result.ok().map(|e| Ok(e.to_sse_event()))
            })
    }

    pub async fn subscribe_from(&self, last_event_id: Option<u64>) -> impl Stream<Item = Result<Event, Infallible>> {
        let mut replay_events = Vec::new();

        if let Some(last_id) = last_event_id {
            let history = self.event_history.read().await;
            for event in history.iter() {
                if let Some(ref id) = event.id {
                    if let Ok(event_id) = id.parse::<u64>() {
                        if event_id > last_id {
                            replay_events.push(event.clone());
                        }
                    }
                }
            }
        }

        let replay_stream = tokio_stream::iter(replay_events)
            .map(|e| Ok(e.to_sse_event()));

        let live_stream = self.subscribe();

        replay_stream.chain(live_stream)
    }
}

pub fn parse_last_event_id(headers: &http::HeaderMap) -> Option<u64> {
    headers
        .get("Last-Event-ID")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.parse().ok())
}

pub async fn sse_handler(
    axum::extract::State(service): axum::extract::State<Arc<SseService>>,
    headers: http::HeaderMap,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    let last_id = parse_last_event_id(&headers);
    let stream = service.subscribe_from(last_id).await;

    Sse::new(stream).keep_alive(KeepAlive::default())
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Format SSE incorrect */
pub fn format_sse(event: &SseEvent) -> String {
    format!("{}\n", event.data)  // MUTANT: Pas de "data:" prefix
}
// Pourquoi c'est faux : Navigateur ne parse pas

/* Mutant B : Pas de replay sur reconnexion */
pub async fn subscribe_from(&self, _last_event_id: Option<u64>) -> impl Stream<...> {
    self.subscribe()  // MUTANT: Ignore last_event_id
}
// Pourquoi c'est faux : Events perdus pendant deconnexion

/* Mutant C : Pas de keep-alive */
pub async fn sse_handler(...) -> Sse<...> {
    Sse::new(stream)  // MUTANT: Pas de keep_alive()
}
// Pourquoi c'est faux : Connexion fermee par timeout

/* Mutant D : Event type ignore */
pub fn format_sse(event: &SseEvent) -> String {
    // MUTANT: N'inclut pas event_type
    format!("data: {}\n\n", event.data)
}
// Pourquoi c'est faux : Client ne peut pas filtrer par type

/* Mutant E : Pas de double newline */
pub fn format_sse(event: &SseEvent) -> String {
    format!("data: {}\n", event.data)  // MUTANT: Single newline
}
// Pourquoi c'est faux : Event jamais termine, buffering infini
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **SSE Protocol** : Format text/event-stream
2. **Reconnection** : Last-Event-ID handling
3. **Streaming** : Async streams en Rust
4. **Event Types** : Categorisation des events

### 5.2 Visualisation ASCII

```
            SSE CONNECTION FLOW

Client                               Server
   |                                    |
   |---GET /events ------------------>|
   |   Accept: text/event-stream      |
   |                                    |
   |<--200 OK-------------------------|
   |   Content-Type: text/event-stream|
   |                                    |
   |<--event: notification ------------|
   |   id: 1                          |
   |   data: {"msg": "Hello"}         |
   |                                    |
   |<--: keep-alive ------------------|
   |                                    |
   |<--event: update -----------------|
   |   id: 2                          |
   |   data: {"count": 42}            |
   |                                    |
   X   (connection lost)               |
   |                                    |
   |---GET /events ------------------>|
   |   Last-Event-ID: 2               |
   |                                    |
   |<--event: update -----------------|
   |   id: 3  (events since 2)        |
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | No "data:" prefix | Events ignores | Proper format |
| 2 | No replay | Lost events | Track history |
| 3 | No keep-alive | Connection drops | Periodic comments |
| 4 | No event type | Can't filter | Include event field |
| 5 | Single newline | Never completes | Double \n\n |

---

## SECTION 7 : QCM

### Question 1
**Quel Content-Type pour SSE ?**

A) application/json
B) text/plain
C) text/event-stream
D) application/stream

**Reponse : C**

---

### Question 2
**Comment terminer un event SSE ?**

A) Single newline
B) Double newline
C) EOF
D) "END" keyword

**Reponse : B**

---

### Question 3
**Quel header le client envoie pour la reconnexion ?**

A) Reconnect-ID
B) Last-Event-ID
C) Resume-From
D) Event-Offset

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | sse_server |
| **Module** | 5.3.13 - Server-Sent Events |
| **Difficulte** | 5/10 |
| **XP** | 150 |
| **Concepts cles** | SSE format, reconnection, streaming |
| **Piege principal** | Double newline manquant |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.13-a-sse-server",
    "metadata": {
      "exercise_id": "5.3.13-a",
      "exercise_name": "sse_server",
      "difficulty": 5,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "This just in... SSE is simpler!"*
*Exercise Quality Score: 94/100*
