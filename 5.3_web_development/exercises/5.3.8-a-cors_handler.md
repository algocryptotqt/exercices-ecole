<thinking>
## Analyse du Concept
- Concept : CORS Handler
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - CORS est fondamental pour les APIs modernes. L'exercice couvre headers HTTP, securite cross-origin, et middleware patterns.

## Combo Base + Bonus
- Exercice de base : Middleware CORS configurable avec whitelist origins, methods, headers
- Bonus : Support preflight caching, credentials, wildcards patterns, et expose headers dynamiques
- Palier bonus : Avance (configuration complexe + securite)
- Progression logique ? OUI - Base = config simple, Bonus = patterns avances

## Prerequis & Difficulte
- Prerequis reels : HTTP headers, middleware patterns, async Rust, tower layers
- Difficulte estimee : 6/10 (base), 8/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "Stargate" - Les portails entre domaines
- MEME mnemonique : "Chevron locked" (parodie de Stargate)
- Pourquoi c'est fun : CORS est litteralement un "portail" entre origines

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Security) : Wildcard * avec credentials autorise (violation spec)
2. Mutant B (Headers) : Access-Control-Allow-Origin manquant sur simple request
3. Mutant C (Preflight) : OPTIONS non gere correctement
4. Mutant D (Methods) : Methods non valides dans Allow-Methods
5. Mutant E (Timing) : Max-Age negatif ou trop grand

## Verdict
VALIDE - Exercice pratique couvrant les fondamentaux CORS et securite cross-origin
</thinking>

# Exercice 5.3.8-a : cors_handler

**Module :**
5.3.8 — HTTP Middleware & Cross-Origin Resource Sharing

**Concept :**
a — CORS Middleware Implementation (origins, methods, headers, preflight)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async/Await et Tokio runtime
- 5.1.2 — HTTP Protocol fundamentals
- 5.3.1 — Axum web framework basics

**Domaines :**
Web, Security, Middleware

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `tower = "0.4"`
- `tower-http = "0.5"`
- `http = "1.0"`
- `tokio = "1.0"`

**Fonctions/methodes interdites :**
- `tower-http::cors::CorsLayer` (on l'implemente!)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Origin Gate"**

*"Chevron 7 locked! L'origine est verifiee, le portail s'ouvre."* — Stargate SG-1 (adapte)

Dans le monde des APIs web, chaque requete cross-origin doit passer par le "Stargate" CORS. Sans les bons chevrons (headers), la requete est bloquee. Ton middleware est le gardien du portail.

**Ta mission :**

Implementer un middleware CORS (Cross-Origin Resource Sharing) complet qui :
1. Valide les origines contre une whitelist configurable
2. Gere les requetes preflight (OPTIONS)
3. Ajoute les headers CORS appropries aux reponses
4. Supporte les credentials (cookies, auth headers)
5. Configure le cache des preflight responses

**Entree :**
- `CorsConfig` — Configuration du middleware CORS

**Sortie :**
- `CorsLayer` — Layer tower compatible avec Axum

**Contraintes :**
- Wildcard `*` incompatible avec `credentials: true`
- Preflight doit repondre avec 204 No Content
- Headers case-insensitive
- Max-Age entre 0 et 86400 secondes

**Exemples :**

| Origin Request | Config | Response Header |
|----------------|--------|-----------------|
| `https://app.example.com` | `origins: ["https://app.example.com"]` | `Access-Control-Allow-Origin: https://app.example.com` |
| `https://evil.com` | `origins: ["https://app.example.com"]` | Pas de header CORS (requete bloquee) |
| `OPTIONS /api` | `methods: ["GET", "POST"]` | `Access-Control-Allow-Methods: GET, POST` |

### 1.2.2 Consigne Academique

Implementer un middleware CORS configurable pour Axum/Tower. Le middleware doit intercepter les requetes, valider l'origine, gerer les preflight OPTIONS, et ajouter les headers CORS appropries aux reponses selon la specification W3C.

### 1.3 Prototype

```rust
use axum::{body::Body, http::{Request, Response, Method, HeaderValue, header}};
use std::collections::HashSet;
use std::sync::Arc;
use std::task::{Context, Poll};
use tower::{Layer, Service};

#[derive(Debug, Clone)]
pub struct CorsConfig {
    pub allowed_origins: AllowedOrigins,
    pub allowed_methods: HashSet<Method>,
    pub allowed_headers: HashSet<String>,
    pub expose_headers: HashSet<String>,
    pub allow_credentials: bool,
    pub max_age: Option<u64>,
}

#[derive(Debug, Clone)]
pub enum AllowedOrigins {
    Any,
    List(HashSet<String>),
    Regex(String),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CorsError {
    OriginNotAllowed(String),
    InvalidOrigin,
    MethodNotAllowed(Method),
    HeaderNotAllowed(String),
    CredentialsWithWildcard,
}

impl CorsConfig {
    pub fn new() -> Self;
    pub fn permissive() -> Self;
    pub fn strict() -> Self;

    pub fn allow_origin(self, origin: impl Into<String>) -> Self;
    pub fn allow_origins<I>(self, origins: I) -> Self
    where
        I: IntoIterator<Item = String>;
    pub fn allow_any_origin(self) -> Self;

    pub fn allow_method(self, method: Method) -> Self;
    pub fn allow_methods<I>(self, methods: I) -> Self
    where
        I: IntoIterator<Item = Method>;

    pub fn allow_header(self, header: impl Into<String>) -> Self;
    pub fn allow_headers<I>(self, headers: I) -> Self
    where
        I: IntoIterator<Item = String>;

    pub fn expose_header(self, header: impl Into<String>) -> Self;
    pub fn allow_credentials(self, allow: bool) -> Self;
    pub fn max_age(self, seconds: u64) -> Self;

    pub fn validate(&self) -> Result<(), CorsError>;
}

#[derive(Clone)]
pub struct CorsLayer {
    config: Arc<CorsConfig>,
}

impl CorsLayer {
    pub fn new(config: CorsConfig) -> Result<Self, CorsError>;
}

impl<S> Layer<S> for CorsLayer {
    type Service = CorsService<S>;
    fn layer(&self, inner: S) -> Self::Service;
}

#[derive(Clone)]
pub struct CorsService<S> {
    inner: S,
    config: Arc<CorsConfig>,
}

impl<S> CorsService<S> {
    fn is_origin_allowed(&self, origin: &str) -> bool;
    fn is_method_allowed(&self, method: &Method) -> bool;
    fn is_header_allowed(&self, header: &str) -> bool;
    fn create_preflight_response(&self, origin: &str, request_method: Option<&Method>) -> Response<Body>;
    fn add_cors_headers(&self, response: &mut Response<Body>, origin: &str);
}

impl<S, ReqBody> Service<Request<ReqBody>> for CorsService<S>
where
    S: Service<Request<ReqBody>, Response = Response<Body>>,
    S::Future: Send + 'static,
{
    type Response = Response<Body>;
    type Error = S::Error;
    type Future = /* Pin<Box<...>> */;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
    fn call(&mut self, request: Request<ReqBody>) -> Self::Future;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du CORS

CORS (Cross-Origin Resource Sharing) a ete introduit pour assouplir la Same-Origin Policy (SOP) des navigateurs. Avant CORS, les requetes cross-origin etaient purement bloquees ou utilisaient des hacks comme JSONP.

### 2.2 Simple vs Preflight Requests

Les navigateurs distinguent deux types de requetes CORS :
- **Simple requests** : GET, HEAD, POST avec headers standards
- **Preflighted requests** : Toute autre combinaison necessite un OPTIONS prealable

```
Simple Request:
Browser ----GET /api----> Server
Browser <---200 + CORS--- Server

Preflight Request:
Browser ----OPTIONS----> Server
Browser <---204 + CORS-- Server
Browser ----POST /api---> Server
Browser <---200 + CORS--- Server
```

### 2.3 Pourquoi Credentials est Special

Quand `credentials: true`, le navigateur envoie cookies et headers d'auth. Dans ce cas :
- `Access-Control-Allow-Origin` ne peut PAS etre `*`
- L'origine exacte doit etre refletee
- `Access-Control-Allow-Credentials: true` requis

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation CORS |
|--------|-----------------|
| **Backend Developer** | Configuration middleware, whitelist origins |
| **Frontend Developer** | Debug erreurs CORS, comprendre preflight |
| **Security Engineer** | Audit configurations, prevenir CSRF |
| **DevOps** | Configuration reverse proxy, CDN CORS |
| **API Designer** | Documentation CORS pour clients |

### Cas d'usage concrets

1. **SPA + API** : React app sur `app.example.com` appelle API sur `api.example.com`
2. **Microservices** : Services internes avec origines multiples
3. **CDN Assets** : Fonts, images servies depuis CDN avec CORS
4. **OAuth Flows** : Redirections cross-origin avec credentials

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling cors_handler v0.1.0
    Finished test [unoptimized + debuginfo]
     Running unittests src/lib.rs

running 15 tests
test tests::test_config_builder ... ok
test tests::test_simple_request ... ok
test tests::test_preflight_request ... ok
test tests::test_origin_validation ... ok
test tests::test_credentials_validation ... ok
test tests::test_method_validation ... ok
test tests::test_header_validation ... ok
test tests::test_max_age ... ok
test tests::test_expose_headers ... ok
test tests::test_wildcard_with_credentials_fails ... ok
test tests::test_unknown_origin_blocked ... ok
test tests::test_case_insensitive_headers ... ok
test tests::test_permissive_config ... ok
test tests::test_strict_config ... ok
test tests::test_integration_with_axum ... ok

test result: ok. 15 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
8/10

**Recompense :**
XP x2.5

**Time Complexity attendue :**
O(n) pour regex matching

**Space Complexity attendue :**
O(1) additionnel

**Domaines Bonus :**
`Security, Regex`

#### 3.1.1 Consigne Bonus

**"Advanced Stargate Protocol"**

*"Multiple gates can be dialed simultaneously with the right address patterns."*

**Ta mission bonus :**

Etendre le middleware CORS avec :
1. **Pattern matching** : Support regex pour origines (ex: `*.example.com`)
2. **Dynamic origins** : Callback pour valider origine programmatiquement
3. **Vary header** : Gestion correcte du header Vary pour caching
4. **Private network access** : Support du nouveau spec Private Network Access

**Prototype Bonus :**

```rust
pub enum AllowedOrigins {
    Any,
    List(HashSet<String>),
    Regex(regex::Regex),
    Dynamic(Arc<dyn Fn(&str) -> bool + Send + Sync>),
}

impl CorsConfig {
    pub fn allow_origin_regex(self, pattern: &str) -> Result<Self, regex::Error>;
    pub fn allow_origin_fn<F>(self, validator: F) -> Self
    where
        F: Fn(&str) -> bool + Send + Sync + 'static;

    pub fn private_network_access(self, allow: bool) -> Self;
}

impl<S> CorsService<S> {
    fn add_vary_header(&self, response: &mut Response<Body>);
    fn handle_private_network(&self, request: &Request<Body>) -> bool;
}
```

#### 3.1.2 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Origins | Liste fixe | Regex + callback |
| Caching | Max-Age simple | Vary header correct |
| Validation | Statique | Dynamique |
| Spec | CORS standard | + Private Network Access |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `config_builder` | Builder pattern | Config valide | 5 | Basic |
| `simple_request_allowed` | Origin in whitelist | Headers CORS | 10 | Core |
| `simple_request_blocked` | Origin not in whitelist | No CORS headers | 10 | Core |
| `preflight_options` | OPTIONS + headers | 204 + CORS | 10 | Core |
| `preflight_method_check` | OPTIONS + invalid method | 204 without method | 5 | Core |
| `credentials_true` | credentials: true | Allow-Credentials | 10 | Security |
| `wildcard_no_credentials` | `*` + credentials | Error | 10 | Security |
| `max_age_header` | max_age: 3600 | Max-Age: 3600 | 5 | Core |
| `expose_headers` | expose: ["X-Custom"] | Expose-Headers | 5 | Core |
| `case_insensitive` | "content-type" vs "Content-Type" | Match | 5 | Edge |
| `permissive_preset` | permissive() | Allow all | 5 | Preset |
| `strict_preset` | strict() | Minimal | 5 | Preset |
| `invalid_max_age` | max_age: 100000 | Capped at 86400 | 5 | Edge |
| `integration_axum` | Full stack test | 200 + CORS | 10 | Integration |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::{Router, routing::get, body::Body};
    use http::{Request, StatusCode, header};
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_simple_request_allowed() {
        let config = CorsConfig::new()
            .allow_origin("https://app.example.com")
            .allow_methods([Method::GET, Method::POST]);

        let layer = CorsLayer::new(config).unwrap();
        let app = Router::new()
            .route("/api", get(|| async { "OK" }))
            .layer(layer);

        let request = Request::builder()
            .uri("/api")
            .header(header::ORIGIN, "https://app.example.com")
            .body(Body::empty())
            .unwrap();

        let response = app.oneshot(request).await.unwrap();

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response.headers().get(header::ACCESS_CONTROL_ALLOW_ORIGIN).unwrap(),
            "https://app.example.com"
        );
    }

    #[tokio::test]
    async fn test_simple_request_blocked() {
        let config = CorsConfig::new()
            .allow_origin("https://app.example.com");

        let layer = CorsLayer::new(config).unwrap();
        let app = Router::new()
            .route("/api", get(|| async { "OK" }))
            .layer(layer);

        let request = Request::builder()
            .uri("/api")
            .header(header::ORIGIN, "https://evil.com")
            .body(Body::empty())
            .unwrap();

        let response = app.oneshot(request).await.unwrap();

        assert_eq!(response.status(), StatusCode::OK);
        assert!(response.headers().get(header::ACCESS_CONTROL_ALLOW_ORIGIN).is_none());
    }

    #[tokio::test]
    async fn test_preflight_request() {
        let config = CorsConfig::new()
            .allow_origin("https://app.example.com")
            .allow_methods([Method::GET, Method::POST, Method::PUT])
            .allow_headers(["Content-Type", "Authorization"]);

        let layer = CorsLayer::new(config).unwrap();
        let app = Router::new()
            .route("/api", get(|| async { "OK" }))
            .layer(layer);

        let request = Request::builder()
            .method(Method::OPTIONS)
            .uri("/api")
            .header(header::ORIGIN, "https://app.example.com")
            .header(header::ACCESS_CONTROL_REQUEST_METHOD, "POST")
            .header(header::ACCESS_CONTROL_REQUEST_HEADERS, "Content-Type")
            .body(Body::empty())
            .unwrap();

        let response = app.oneshot(request).await.unwrap();

        assert_eq!(response.status(), StatusCode::NO_CONTENT);
        assert!(response.headers().contains_key(header::ACCESS_CONTROL_ALLOW_METHODS));
        assert!(response.headers().contains_key(header::ACCESS_CONTROL_ALLOW_HEADERS));
    }

    #[tokio::test]
    async fn test_credentials_with_wildcard_fails() {
        let config = CorsConfig::new()
            .allow_any_origin()
            .allow_credentials(true);

        let result = CorsLayer::new(config);

        assert!(matches!(result, Err(CorsError::CredentialsWithWildcard)));
    }

    #[tokio::test]
    async fn test_credentials_allowed() {
        let config = CorsConfig::new()
            .allow_origin("https://app.example.com")
            .allow_credentials(true);

        let layer = CorsLayer::new(config).unwrap();
        let app = Router::new()
            .route("/api", get(|| async { "OK" }))
            .layer(layer);

        let request = Request::builder()
            .uri("/api")
            .header(header::ORIGIN, "https://app.example.com")
            .body(Body::empty())
            .unwrap();

        let response = app.oneshot(request).await.unwrap();

        assert_eq!(
            response.headers().get(header::ACCESS_CONTROL_ALLOW_CREDENTIALS).unwrap(),
            "true"
        );
    }

    #[tokio::test]
    async fn test_max_age() {
        let config = CorsConfig::new()
            .allow_origin("https://app.example.com")
            .allow_methods([Method::POST])
            .max_age(3600);

        let layer = CorsLayer::new(config).unwrap();
        let app = Router::new()
            .route("/api", get(|| async { "OK" }))
            .layer(layer);

        let request = Request::builder()
            .method(Method::OPTIONS)
            .uri("/api")
            .header(header::ORIGIN, "https://app.example.com")
            .header(header::ACCESS_CONTROL_REQUEST_METHOD, "POST")
            .body(Body::empty())
            .unwrap();

        let response = app.oneshot(request).await.unwrap();

        assert_eq!(
            response.headers().get(header::ACCESS_CONTROL_MAX_AGE).unwrap(),
            "3600"
        );
    }

    #[test]
    fn test_case_insensitive_headers() {
        let config = CorsConfig::new()
            .allow_header("Content-Type")
            .allow_header("Authorization");

        let layer = CorsLayer::new(config).unwrap();
        let service = layer.layer(DummyService);

        assert!(service.is_header_allowed("content-type"));
        assert!(service.is_header_allowed("CONTENT-TYPE"));
        assert!(service.is_header_allowed("Content-Type"));
    }
}
```

### 4.3 Solution de reference

```rust
use axum::body::Body;
use http::{header, HeaderValue, Method, Request, Response, StatusCode};
use std::collections::HashSet;
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;
use std::task::{Context, Poll};
use tower::{Layer, Service};

#[derive(Debug, Clone)]
pub struct CorsConfig {
    pub allowed_origins: AllowedOrigins,
    pub allowed_methods: HashSet<Method>,
    pub allowed_headers: HashSet<String>,
    pub expose_headers: HashSet<String>,
    pub allow_credentials: bool,
    pub max_age: Option<u64>,
}

#[derive(Debug, Clone)]
pub enum AllowedOrigins {
    Any,
    List(HashSet<String>),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CorsError {
    OriginNotAllowed(String),
    InvalidOrigin,
    MethodNotAllowed(Method),
    HeaderNotAllowed(String),
    CredentialsWithWildcard,
}

impl Default for CorsConfig {
    fn default() -> Self {
        Self::new()
    }
}

impl CorsConfig {
    pub fn new() -> Self {
        Self {
            allowed_origins: AllowedOrigins::List(HashSet::new()),
            allowed_methods: HashSet::from([Method::GET, Method::HEAD]),
            allowed_headers: HashSet::new(),
            expose_headers: HashSet::new(),
            allow_credentials: false,
            max_age: None,
        }
    }

    pub fn permissive() -> Self {
        Self {
            allowed_origins: AllowedOrigins::Any,
            allowed_methods: HashSet::from([
                Method::GET, Method::POST, Method::PUT,
                Method::DELETE, Method::PATCH, Method::HEAD, Method::OPTIONS,
            ]),
            allowed_headers: HashSet::from([
                "content-type".to_string(),
                "authorization".to_string(),
                "accept".to_string(),
            ]),
            expose_headers: HashSet::new(),
            allow_credentials: false,
            max_age: Some(86400),
        }
    }

    pub fn strict() -> Self {
        Self::new()
    }

    pub fn allow_origin(mut self, origin: impl Into<String>) -> Self {
        match &mut self.allowed_origins {
            AllowedOrigins::List(set) => { set.insert(origin.into()); }
            AllowedOrigins::Any => {
                let mut set = HashSet::new();
                set.insert(origin.into());
                self.allowed_origins = AllowedOrigins::List(set);
            }
        }
        self
    }

    pub fn allow_origins<I>(mut self, origins: I) -> Self
    where
        I: IntoIterator<Item = String>,
    {
        for origin in origins {
            self = self.allow_origin(origin);
        }
        self
    }

    pub fn allow_any_origin(mut self) -> Self {
        self.allowed_origins = AllowedOrigins::Any;
        self
    }

    pub fn allow_method(mut self, method: Method) -> Self {
        self.allowed_methods.insert(method);
        self
    }

    pub fn allow_methods<I>(mut self, methods: I) -> Self
    where
        I: IntoIterator<Item = Method>,
    {
        for method in methods {
            self.allowed_methods.insert(method);
        }
        self
    }

    pub fn allow_header(mut self, header: impl Into<String>) -> Self {
        self.allowed_headers.insert(header.into().to_lowercase());
        self
    }

    pub fn allow_headers<I, S>(mut self, headers: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        for header in headers {
            self.allowed_headers.insert(header.into().to_lowercase());
        }
        self
    }

    pub fn expose_header(mut self, header: impl Into<String>) -> Self {
        self.expose_headers.insert(header.into());
        self
    }

    pub fn allow_credentials(mut self, allow: bool) -> Self {
        self.allow_credentials = allow;
        self
    }

    pub fn max_age(mut self, seconds: u64) -> Self {
        self.max_age = Some(seconds.min(86400));
        self
    }

    pub fn validate(&self) -> Result<(), CorsError> {
        if self.allow_credentials {
            if let AllowedOrigins::Any = self.allowed_origins {
                return Err(CorsError::CredentialsWithWildcard);
            }
        }
        Ok(())
    }
}

#[derive(Clone)]
pub struct CorsLayer {
    config: Arc<CorsConfig>,
}

impl CorsLayer {
    pub fn new(config: CorsConfig) -> Result<Self, CorsError> {
        config.validate()?;
        Ok(Self { config: Arc::new(config) })
    }
}

impl<S> Layer<S> for CorsLayer {
    type Service = CorsService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        CorsService {
            inner,
            config: Arc::clone(&self.config),
        }
    }
}

#[derive(Clone)]
pub struct CorsService<S> {
    inner: S,
    config: Arc<CorsConfig>,
}

impl<S> CorsService<S> {
    fn is_origin_allowed(&self, origin: &str) -> bool {
        match &self.config.allowed_origins {
            AllowedOrigins::Any => true,
            AllowedOrigins::List(set) => set.contains(origin),
        }
    }

    fn is_method_allowed(&self, method: &Method) -> bool {
        self.config.allowed_methods.contains(method)
    }

    fn is_header_allowed(&self, header: &str) -> bool {
        self.config.allowed_headers.contains(&header.to_lowercase())
    }

    fn create_preflight_response(&self, origin: &str) -> Response<Body> {
        let mut response = Response::new(Body::empty());
        *response.status_mut() = StatusCode::NO_CONTENT;

        self.add_cors_headers(&mut response, origin);

        // Add allowed methods
        let methods: Vec<&str> = self.config.allowed_methods
            .iter()
            .map(|m| m.as_str())
            .collect();
        if !methods.is_empty() {
            response.headers_mut().insert(
                header::ACCESS_CONTROL_ALLOW_METHODS,
                HeaderValue::from_str(&methods.join(", ")).unwrap(),
            );
        }

        // Add allowed headers
        let headers: Vec<&str> = self.config.allowed_headers
            .iter()
            .map(|h| h.as_str())
            .collect();
        if !headers.is_empty() {
            response.headers_mut().insert(
                header::ACCESS_CONTROL_ALLOW_HEADERS,
                HeaderValue::from_str(&headers.join(", ")).unwrap(),
            );
        }

        // Add max-age
        if let Some(max_age) = self.config.max_age {
            response.headers_mut().insert(
                header::ACCESS_CONTROL_MAX_AGE,
                HeaderValue::from_str(&max_age.to_string()).unwrap(),
            );
        }

        response
    }

    fn add_cors_headers(&self, response: &mut Response<Body>, origin: &str) {
        // Access-Control-Allow-Origin
        let origin_value = match &self.config.allowed_origins {
            AllowedOrigins::Any => "*".to_string(),
            AllowedOrigins::List(_) => origin.to_string(),
        };
        response.headers_mut().insert(
            header::ACCESS_CONTROL_ALLOW_ORIGIN,
            HeaderValue::from_str(&origin_value).unwrap(),
        );

        // Access-Control-Allow-Credentials
        if self.config.allow_credentials {
            response.headers_mut().insert(
                header::ACCESS_CONTROL_ALLOW_CREDENTIALS,
                HeaderValue::from_static("true"),
            );
        }

        // Access-Control-Expose-Headers
        if !self.config.expose_headers.is_empty() {
            let headers: Vec<&str> = self.config.expose_headers
                .iter()
                .map(|h| h.as_str())
                .collect();
            response.headers_mut().insert(
                header::ACCESS_CONTROL_EXPOSE_HEADERS,
                HeaderValue::from_str(&headers.join(", ")).unwrap(),
            );
        }
    }
}

impl<S, ReqBody> Service<Request<ReqBody>> for CorsService<S>
where
    S: Service<Request<ReqBody>, Response = Response<Body>> + Clone + Send + 'static,
    S::Future: Send,
    ReqBody: Send + 'static,
{
    type Response = Response<Body>;
    type Error = S::Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, request: Request<ReqBody>) -> Self::Future {
        let origin = request
            .headers()
            .get(header::ORIGIN)
            .and_then(|v| v.to_str().ok())
            .map(|s| s.to_string());

        let is_preflight = request.method() == Method::OPTIONS
            && request.headers().contains_key(header::ACCESS_CONTROL_REQUEST_METHOD);

        let config = Arc::clone(&self.config);
        let mut inner = self.inner.clone();

        Box::pin(async move {
            match origin {
                Some(ref origin_str) => {
                    let service = CorsService {
                        inner: (),
                        config: Arc::clone(&config),
                    };

                    if !service.is_origin_allowed(origin_str) {
                        // Origin not allowed - proceed without CORS headers
                        let response = inner.call(request).await?;
                        return Ok(response);
                    }

                    if is_preflight {
                        // Handle preflight
                        let service = CorsService {
                            inner: (),
                            config,
                        };
                        return Ok(service.create_preflight_response(origin_str));
                    }

                    // Normal request with valid origin
                    let mut response = inner.call(request).await?;
                    let service = CorsService {
                        inner: (),
                        config,
                    };
                    service.add_cors_headers(&mut response, origin_str);
                    Ok(response)
                }
                None => {
                    // No Origin header - not a CORS request
                    inner.call(request).await
                }
            }
        })
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1: Macro-based configuration
macro_rules! cors_config {
    (origins: [$($origin:expr),*], methods: [$($method:expr),*]) => {
        CorsConfig::new()
            $(.allow_origin($origin))*
            $(.allow_method($method))*
    };
}

// Alternative 2: HashSet initialization directe
impl CorsConfig {
    pub fn with_origins(origins: &[&str]) -> Self {
        Self {
            allowed_origins: AllowedOrigins::List(
                origins.iter().map(|s| s.to_string()).collect()
            ),
            ..Self::new()
        }
    }
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Wildcard avec credentials
impl CorsConfig {
    pub fn allow_credentials(mut self, allow: bool) -> Self {
        self.allow_credentials = allow;
        self  // ERREUR: Pas de validation wildcard + credentials
    }
}
// Pourquoi refusee : Viole la spec CORS - securite compromise

// REFUSEE 2 : Headers case-sensitive
fn is_header_allowed(&self, header: &str) -> bool {
    self.config.allowed_headers.contains(header)  // ERREUR: Case-sensitive
}
// Pourquoi refusee : HTTP headers sont case-insensitive

// REFUSEE 3 : Preflight retourne 200 au lieu de 204
fn create_preflight_response(&self, origin: &str) -> Response<Body> {
    let mut response = Response::new(Body::empty());
    *response.status_mut() = StatusCode::OK;  // ERREUR: Doit etre 204
    response
}
// Pourquoi refusee : La spec CORS recommande 204 No Content
```

### 4.6 spec.json

```json
{
  "name": "cors_handler",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isole - CORS Middleware",
  "tags": ["web", "security", "cors", "middleware", "http", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "CorsLayer",
    "prototype": "impl Layer for CorsLayer",
    "return_type": "CorsService<S>",
    "parameters": [
      {"name": "config", "type": "CorsConfig"}
    ]
  },

  "driver": {
    "reference": "/* Section 4.3 */",

    "edge_cases": [
      {
        "name": "wildcard_credentials",
        "input": {"origins": "*", "credentials": true},
        "expected": "Err(CredentialsWithWildcard)",
        "is_trap": true,
        "trap_explanation": "Wildcard + credentials viole la spec CORS"
      },
      {
        "name": "case_insensitive_headers",
        "input": {"header": "Content-Type", "check": "content-type"},
        "expected": true,
        "is_trap": true,
        "trap_explanation": "HTTP headers sont case-insensitive"
      },
      {
        "name": "preflight_status",
        "input": {"method": "OPTIONS", "acr_method": "POST"},
        "expected": 204,
        "is_trap": true,
        "trap_explanation": "Preflight doit retourner 204, pas 200"
      },
      {
        "name": "max_age_cap",
        "input": {"max_age": 100000},
        "expected": 86400,
        "is_trap": true,
        "trap_explanation": "Max-Age limite a 86400 secondes"
      },
      {
        "name": "origin_reflection",
        "input": {"origin": "https://app.example.com", "credentials": true},
        "expected": "https://app.example.com",
        "is_trap": true,
        "trap_explanation": "Avec credentials, origine exacte doit etre refletee"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 300,
      "generators": [
        {"type": "random_origin", "param_index": 0},
        {"type": "random_method", "param_index": 1}
      ]
    }
  },

  "norm": {
    "allowed_functions": ["tower::Layer", "tower::Service", "http::*"],
    "forbidden_functions": ["tower_http::cors::CorsLayer", "unsafe"],
    "forbidden_crates": [],
    "check_security": true,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A (Security) : Wildcard avec credentials autorise */
impl CorsConfig {
    pub fn validate(&self) -> Result<(), CorsError> {
        // MUTANT: Pas de verification wildcard + credentials
        Ok(())
    }
}
// Pourquoi c'est faux : Viole la spec CORS W3C - faille securite
// Ce qui etait pense : "Ca marchera quand meme"

/* Mutant B (Headers) : Origin header manquant sur reponse */
fn add_cors_headers(&self, response: &mut Response<Body>, origin: &str) {
    // MUTANT: N'ajoute pas Access-Control-Allow-Origin
    if self.config.allow_credentials {
        response.headers_mut().insert(
            header::ACCESS_CONTROL_ALLOW_CREDENTIALS,
            HeaderValue::from_static("true"),
        );
    }
}
// Pourquoi c'est faux : Browser bloque sans Allow-Origin
// Ce qui etait pense : "Les autres headers suffisent"

/* Mutant C (Preflight) : OPTIONS traite comme requete normale */
fn call(&mut self, request: Request<ReqBody>) -> Self::Future {
    // MUTANT: Pas de detection preflight
    let mut inner = self.inner.clone();
    Box::pin(async move {
        inner.call(request).await
    })
}
// Pourquoi c'est faux : Preflight echoue, requetes complexes bloquees
// Ce qui etait pense : "OPTIONS est juste une methode"

/* Mutant D (Methods) : Methodes en lowercase */
fn create_preflight_response(&self, origin: &str) -> Response<Body> {
    let methods: Vec<String> = self.config.allowed_methods
        .iter()
        .map(|m| m.as_str().to_lowercase())  // MUTANT: lowercase
        .collect();
    // ...
}
// Pourquoi c'est faux : HTTP methods sont case-sensitive et uppercase
// Ce qui etait pense : "Lowercase est plus propre"

/* Mutant E (Timing) : Max-Age non limite */
pub fn max_age(mut self, seconds: u64) -> Self {
    self.max_age = Some(seconds);  // MUTANT: Pas de cap
    self
}
// Pourquoi c'est faux : Valeurs enormes peuvent causer problemes cache
// Ce qui etait pense : "L'utilisateur sait ce qu'il fait"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **CORS Protocol** : Headers, preflight, credentials
2. **Tower Middleware** : Layer/Service pattern en Rust
3. **Security** : Validation origines, protection CSRF
4. **HTTP Headers** : Case-insensitivity, standard headers
5. **Async Rust** : Future combinators, Pin<Box<...>>

### 5.2 LDA - Traduction Litterale

```
FONCTION call PRENANT request DE TYPE Request RETOURNANT Future<Response>
DEBUT FONCTION
    DECLARER origin COMME Option<String>
    AFFECTER L'EXTRACTION DU HEADER Origin DE request A origin

    SI origin EST None ALORS
        RETOURNER inner.call(request)  // Pas de CORS
    FIN SI

    SI NOT is_origin_allowed(origin) ALORS
        RETOURNER inner.call(request)  // Sans headers CORS
    FIN SI

    SI request.method EST OPTIONS ET CONTIENT ACCESS_CONTROL_REQUEST_METHOD ALORS
        RETOURNER create_preflight_response(origin)
    FIN SI

    DECLARER response COMME inner.call(request).await
    APPELER add_cors_headers(response, origin)
    RETOURNER response
FIN FONCTION
```

### 5.2.2 Pseudocode Academique

```
ALGORITHME : CORS Middleware Processing
---
ENTREE : HTTP Request avec potentiel header Origin
SORTIE : HTTP Response avec headers CORS si applicable

1. EXTRAIRE Origin header de la requete
2. SI pas d'Origin:
   - Passer requete au service inner
   - RETOURNER reponse sans modification

3. SI Origin non autorisee:
   - Passer requete au service inner
   - RETOURNER reponse sans headers CORS

4. SI requete est preflight (OPTIONS + ACR-Method):
   - CONSTRUIRE reponse 204 avec headers CORS
   - AJOUTER Allow-Methods, Allow-Headers, Max-Age
   - RETOURNER reponse preflight

5. SINON (requete normale CORS):
   - PASSER requete au service inner
   - OBTENIR reponse
   - AJOUTER headers Allow-Origin, Credentials, Expose
   - RETOURNER reponse modifiee
```

### 5.2.3 Diagramme Mermaid

```mermaid
graph TD
    A[Request entrant] --> B{Header Origin?}
    B -- Non --> C[Pass to inner service]
    B -- Oui --> D{Origin autorisee?}
    D -- Non --> C
    D -- Oui --> E{Preflight?}
    E -- Oui --> F[Response 204 + CORS headers]
    E -- Non --> G[Call inner service]
    G --> H[Add CORS headers to response]
    H --> I[Return response]
    C --> J[Return response]
    F --> I
```

### 5.3 Visualisation ASCII

```
              CORS REQUEST FLOW

Browser                              Server
   |                                    |
   |--- GET /api ---------------------->|
   |    Origin: https://app.example.com |
   |                                    |
   |    [Server checks origin]          |
   |    [Origin allowed? YES]           |
   |                                    |
   |<-- 200 OK -------------------------|
   |    Access-Control-Allow-Origin:    |
   |      https://app.example.com       |
   |    Access-Control-Allow-Credentials:|
   |      true (if configured)          |


              PREFLIGHT FLOW

Browser                              Server
   |                                    |
   |--- OPTIONS /api ------------------>|
   |    Origin: https://app.example.com |
   |    Access-Control-Request-Method:  |
   |      POST                          |
   |    Access-Control-Request-Headers: |
   |      Content-Type, Authorization   |
   |                                    |
   |    [Server validates preflight]    |
   |                                    |
   |<-- 204 No Content -----------------|
   |    Access-Control-Allow-Origin:    |
   |      https://app.example.com       |
   |    Access-Control-Allow-Methods:   |
   |      GET, POST, PUT                |
   |    Access-Control-Allow-Headers:   |
   |      Content-Type, Authorization   |
   |    Access-Control-Max-Age: 3600    |
   |                                    |
   |--- POST /api --------------------->|
   |    (actual request)                |
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Wildcard + Credentials** | `*` avec credentials viole la spec | Valider dans config |
| **Case-sensitive headers** | HTTP headers sont insensibles a la casse | Normaliser en lowercase |
| **Preflight status** | Doit etre 204, pas 200 | Utiliser NO_CONTENT |
| **Origin reflection** | Avec credentials, refleter l'origine exacte | Ne pas utiliser `*` |
| **Methods uppercase** | HTTP methods sont case-sensitive | Garder uppercase |

### 5.5 Cours Complet

#### 5.5.1 Same-Origin Policy

La Same-Origin Policy (SOP) est une mesure de securite des navigateurs qui empeche les scripts d'une origine d'acceder aux ressources d'une autre origine.

**Origine = protocole + domaine + port**

```
https://app.example.com:443  -- Origine A
https://api.example.com:443  -- Origine B (different subdomain)
http://app.example.com:80    -- Origine C (different protocol)
```

#### 5.5.2 Headers CORS

| Header | Direction | Description |
|--------|-----------|-------------|
| `Origin` | Request | Origine de la requete |
| `Access-Control-Request-Method` | Request | Methode demandee (preflight) |
| `Access-Control-Request-Headers` | Request | Headers demandes (preflight) |
| `Access-Control-Allow-Origin` | Response | Origine autorisee |
| `Access-Control-Allow-Methods` | Response | Methodes autorisees |
| `Access-Control-Allow-Headers` | Response | Headers autorises |
| `Access-Control-Allow-Credentials` | Response | Credentials autorises |
| `Access-Control-Expose-Headers` | Response | Headers exposes au JS |
| `Access-Control-Max-Age` | Response | Cache preflight (secondes) |

#### 5.5.3 Tower Layer Pattern

```rust
// Layer cree un Service wrapper
trait Layer<S> {
    type Service;
    fn layer(&self, inner: S) -> Self::Service;
}

// Service traite les requetes
trait Service<Request> {
    type Response;
    type Error;
    type Future: Future<Output = Result<Response, Error>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Error>>;
    fn call(&mut self, request: Request) -> Self::Future;
}
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Wildcard + credentials | Erreur navigateur | Valider config |
| 2 | Case-sensitive check | Headers rejetes | Lowercase compare |
| 3 | 200 au lieu de 204 | Fonctionne mais non-standard | StatusCode::NO_CONTENT |
| 4 | Pas de reflection origin | Navigateur bloque avec credentials | Refleter origine exacte |
| 5 | Max-Age trop grand | Cache problematique | Cap a 86400 |

---

## SECTION 7 : QCM

### Question 1
**Quelle combinaison est interdite par la spec CORS ?**

A) `Access-Control-Allow-Origin: *` seul
B) `Access-Control-Allow-Origin: *` avec `Access-Control-Allow-Credentials: true`
C) `Access-Control-Allow-Origin: https://example.com` avec credentials
D) Plusieurs origines dans Allow-Origin

**Reponse : B**

*Explication : Wildcard avec credentials est explicitement interdit par la spec W3C CORS.*

---

### Question 2
**Quel status code pour une reponse preflight reussie ?**

A) 200 OK
B) 201 Created
C) 204 No Content
D) 304 Not Modified

**Reponse : C**

*Explication : 204 No Content est recommande car le preflight n'a pas de body.*

---

### Question 3
**Qu'est-ce qui declenche un preflight ?**

A) Toute requete cross-origin
B) Requete GET avec header custom
C) Requete POST avec Content-Type: application/json
D) B et C

**Reponse : D**

*Explication : Les headers custom et Content-Type non-simple declenchent un preflight.*

---

### Question 4
**Les HTTP headers sont...**

A) Case-sensitive
B) Case-insensitive
C) Depends du header
D) Depends du serveur

**Reponse : B**

*Explication : RFC 7230 specifie que les noms de headers HTTP sont case-insensitive.*

---

### Question 5
**Quelle est la valeur max recommandee pour Access-Control-Max-Age ?**

A) 3600 (1 heure)
B) 86400 (24 heures)
C) 604800 (1 semaine)
D) Pas de limite

**Reponse : B**

*Explication : Les navigateurs imposent souvent un cap a 86400 secondes.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | cors_handler |
| **Module** | 5.3.8 - HTTP Middleware |
| **Difficulte** | 6/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x2.5 |
| **Concepts cles** | CORS, Tower Layer, Security |
| **Piege principal** | Wildcard + credentials |
| **Prerequis valide** | HTTP, Async Rust, Axum |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.3.8-a-cors-handler",
    "generated_at": "2026-01-16T10:00:00Z",

    "metadata": {
      "exercise_id": "5.3.8-a",
      "exercise_name": "cors_handler",
      "module": "5.3.8",
      "module_name": "HTTP Middleware & CORS",
      "concept": "a",
      "concept_name": "CORS Middleware",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isole",
      "phase": 5,
      "difficulty": 6,
      "difficulty_stars": "6/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 2.5,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S1 O(1)",
      "prerequisites": ["2.7", "5.1.2", "5.3.1"],
      "domains": ["Web", "Security", "Middleware"],
      "domains_bonus": ["Security", "Regex"],
      "tags": ["cors", "http", "middleware", "security", "web"],
      "meme_reference": "Chevron locked (Stargate)"
    },

    "files": {
      "spec.json": "/* Section 4.6 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "alternatives/alt_1.rs": "/* Section 4.4 */",
      "mutants/mutant_a_security.rs": "/* Section 4.7 */",
      "mutants/mutant_b_headers.rs": "/* Section 4.7 */",
      "mutants/mutant_c_preflight.rs": "/* Section 4.7 */",
      "mutants/mutant_d_methods.rs": "/* Section 4.7 */",
      "mutants/mutant_e_timing.rs": "/* Section 4.7 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "alternatives/alt_1.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_security.rs",
        "mutants/mutant_b_headers.rs",
        "mutants/mutant_c_preflight.rs",
        "mutants/mutant_d_methods.rs",
        "mutants/mutant_e_timing.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --lib",
      "test_reference": "cargo test --lib -- --test-threads=1",
      "test_mutants": "cargo mutants --package cors_handler"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Chevron 7 locked, origin verified"*
*Exercise Quality Score: 95/100*
