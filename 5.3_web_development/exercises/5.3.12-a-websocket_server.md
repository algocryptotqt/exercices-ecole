<thinking>
## Analyse du Concept
- Concept : WebSocket Server
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - WebSocket est fondamental pour le temps reel.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Pas de ping/pong heartbeat
2. Mutant B : Messages broadcast mal geres
3. Mutant C : Cleanup connexions mortes manquant
4. Mutant D : Pas de gestion Close frame
5. Mutant E : Buffer overflow sur gros messages

## Verdict
VALIDE - Exercice temps reel essentiel
</thinking>

# Exercice 5.3.12-a : websocket_server

**Module :**
5.3.12 — Real-Time Communication with WebSocket

**Concept :**
a — WebSocket Server (upgrade, messages, ping/pong, rooms)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async/Await et Tokio
- 5.1.3 — TCP/WebSocket protocols
- 5.3.1 — Axum basics

**Domaines :**
Web, Realtime, Async

**Duree estimee :**
150 min

**XP Base :**
200

**Complexite :**
T3 O(n*m) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"` (features: ws)
- `tokio = "1.0"` (features: sync, time)
- `tokio-tungstenite = "0.21"`
- `futures = "0.3"`
- `serde = "1.0"`
- `serde_json = "1.0"`

**Fonctions/methodes interdites :**
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Matrix Reloaded"**

*"Le One peut voir la Matrix en temps reel. Toi aussi, avec WebSocket."*

Dans la Matrix, tout est connecte en temps reel. WebSocket permet cette connexion bidirectionnelle persistante entre client et serveur.

**Ta mission :**

Implementer un serveur WebSocket complet avec :
1. **Upgrade HTTP -> WS** handshake
2. **Message handling** : text, binary, ping/pong
3. **Room/channel system** : join, leave, broadcast
4. **Heartbeat** : detection connexions mortes
5. **Graceful shutdown** : fermeture propre des connexions

**Entree :**
- `WebSocketUpgrade` extracteur Axum
- Messages clients (JSON)

**Sortie :**
- Messages serveur (JSON)
- Broadcast aux rooms

**Contraintes :**
- Ping toutes les 30 secondes
- Timeout si pas de pong en 90 secondes
- Maximum 100 clients par room
- Messages max 64KB

**Protocol :**

```json
// Client -> Server
{"type": "join", "room": "general"}
{"type": "leave", "room": "general"}
{"type": "message", "room": "general", "content": "Hello!"}
{"type": "ping"}

// Server -> Client
{"type": "joined", "room": "general", "members": 5}
{"type": "left", "room": "general"}
{"type": "message", "room": "general", "from": "user123", "content": "Hello!"}
{"type": "pong"}
{"type": "error", "message": "Room full"}
```

### 1.3 Prototype

```rust
use axum::extract::ws::{WebSocket, WebSocketUpgrade, Message};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::{broadcast, mpsc, RwLock};

#[derive(Debug, Clone)]
pub struct WebSocketConfig {
    pub ping_interval: Duration,
    pub pong_timeout: Duration,
    pub max_message_size: usize,
    pub max_clients_per_room: usize,
}

pub struct WebSocketServer {
    rooms: Arc<RwLock<HashMap<String, Room>>>,
    clients: Arc<RwLock<HashMap<Uuid, ClientHandle>>>,
    config: WebSocketConfig,
}

pub struct Room {
    name: String,
    members: HashSet<Uuid>,
    tx: broadcast::Sender<ServerMessage>,
}

pub struct ClientHandle {
    id: Uuid,
    tx: mpsc::UnboundedSender<Message>,
    rooms: HashSet<String>,
    last_pong: Instant,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ClientMessage {
    Join { room: String },
    Leave { room: String },
    Message { room: String, content: String },
    Ping,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ServerMessage {
    Joined { room: String, members: usize },
    Left { room: String },
    Message { room: String, from: String, content: String },
    Pong,
    Error { message: String },
    UserJoined { room: String, user_id: String },
    UserLeft { room: String, user_id: String },
}

impl WebSocketServer {
    pub fn new(config: WebSocketConfig) -> Self;

    pub async fn handle_connection(&self, socket: WebSocket, client_id: Uuid);

    async fn handle_message(&self, client_id: Uuid, msg: ClientMessage) -> Option<ServerMessage>;

    async fn join_room(&self, client_id: Uuid, room: &str) -> Result<usize, String>;
    async fn leave_room(&self, client_id: Uuid, room: &str);
    async fn broadcast_to_room(&self, room: &str, message: ServerMessage, exclude: Option<Uuid>);

    async fn cleanup_client(&self, client_id: Uuid);
    async fn start_heartbeat(&self, client_id: Uuid);
}

pub async fn ws_handler(
    ws: WebSocketUpgrade,
    State(server): State<Arc<WebSocketServer>>,
) -> impl IntoResponse;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 WebSocket vs HTTP

| HTTP | WebSocket |
|------|-----------|
| Request-Response | Bidirectionnel |
| Nouvelle connexion par requete | Connexion persistante |
| Headers a chaque fois | Handshake unique |
| Polling necessaire | Push natif |

### 2.2 Le Handshake

```
Client:
GET /ws HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==

Server:
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

### 2.3 Message Types

- **Text** : UTF-8 string (JSON, plain text)
- **Binary** : Arbitrary bytes (images, protobuf)
- **Ping** : Keepalive request
- **Pong** : Keepalive response
- **Close** : Connection termination

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 14 tests
test tests::test_server_creation ... ok
test tests::test_client_connect ... ok
test tests::test_join_room ... ok
test tests::test_leave_room ... ok
test tests::test_broadcast_message ... ok
test tests::test_room_limit ... ok
test tests::test_ping_pong ... ok
test tests::test_heartbeat_timeout ... ok
test tests::test_cleanup_on_disconnect ... ok
test tests::test_message_size_limit ... ok
test tests::test_multiple_rooms ... ok
test tests::test_user_join_notification ... ok
test tests::test_user_leave_notification ... ok
test tests::test_graceful_shutdown ... ok

test result: ok. 14 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `connect` | WS upgrade | 101 Switching | 5 | Basic |
| `join_room` | Join message | Joined response | 10 | Core |
| `leave_room` | Leave message | Left response | 5 | Core |
| `broadcast` | Message in room | All receive | 15 | Core |
| `room_limit` | 101st client | Error | 10 | Edge |
| `ping_pong` | Ping message | Pong response | 5 | Heartbeat |
| `heartbeat_timeout` | No pong | Disconnected | 10 | Heartbeat |
| `cleanup` | Client disconnect | Removed from rooms | 10 | Cleanup |
| `message_limit` | 65KB message | Error | 10 | Edge |
| `multiple_rooms` | Join 3 rooms | All joined | 5 | Core |
| `notifications` | User joins | Others notified | 10 | Core |
| `graceful_shutdown` | Server stop | Clean close | 5 | Integration |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{timeout, Duration};

    #[tokio::test]
    async fn test_join_room() {
        let server = WebSocketServer::new(WebSocketConfig::default());
        let client_id = Uuid::new_v4();

        let result = server.join_room(client_id, "general").await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 1);
    }

    #[tokio::test]
    async fn test_broadcast_message() {
        let server = WebSocketServer::new(WebSocketConfig::default());

        let client1 = Uuid::new_v4();
        let client2 = Uuid::new_v4();
        let client3 = Uuid::new_v4();

        server.join_room(client1, "general").await.unwrap();
        server.join_room(client2, "general").await.unwrap();
        server.join_room(client3, "other").await.unwrap();

        let msg = ServerMessage::Message {
            room: "general".into(),
            from: client1.to_string(),
            content: "Hello!".into(),
        };

        server.broadcast_to_room("general", msg, Some(client1)).await;

        // client2 should receive, client3 should not
    }

    #[tokio::test]
    async fn test_room_limit() {
        let config = WebSocketConfig {
            max_clients_per_room: 2,
            ..Default::default()
        };
        let server = WebSocketServer::new(config);

        let c1 = Uuid::new_v4();
        let c2 = Uuid::new_v4();
        let c3 = Uuid::new_v4();

        assert!(server.join_room(c1, "room").await.is_ok());
        assert!(server.join_room(c2, "room").await.is_ok());
        assert!(server.join_room(c3, "room").await.is_err());
    }

    #[tokio::test]
    async fn test_cleanup_on_disconnect() {
        let server = WebSocketServer::new(WebSocketConfig::default());
        let client_id = Uuid::new_v4();

        server.join_room(client_id, "room1").await.unwrap();
        server.join_room(client_id, "room2").await.unwrap();

        server.cleanup_client(client_id).await;

        // Verify client removed from all rooms
        let rooms = server.rooms.read().await;
        for room in rooms.values() {
            assert!(!room.members.contains(&client_id));
        }
    }
}
```

### 4.3 Solution de reference

```rust
use axum::extract::ws::{Message, WebSocket};
use futures::{SinkExt, StreamExt};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{broadcast, mpsc, RwLock};
use uuid::Uuid;

impl Default for WebSocketConfig {
    fn default() -> Self {
        Self {
            ping_interval: Duration::from_secs(30),
            pong_timeout: Duration::from_secs(90),
            max_message_size: 65536,
            max_clients_per_room: 100,
        }
    }
}

impl WebSocketServer {
    pub fn new(config: WebSocketConfig) -> Self {
        Self {
            rooms: Arc::new(RwLock::new(HashMap::new())),
            clients: Arc::new(RwLock::new(HashMap::new())),
            config,
        }
    }

    pub async fn handle_connection(&self, socket: WebSocket, client_id: Uuid) {
        let (mut sender, mut receiver) = socket.split();
        let (tx, mut rx) = mpsc::unbounded_channel();

        // Register client
        {
            let mut clients = self.clients.write().await;
            clients.insert(client_id, ClientHandle {
                id: client_id,
                tx: tx.clone(),
                rooms: HashSet::new(),
                last_pong: Instant::now(),
            });
        }

        // Spawn sender task
        let send_task = tokio::spawn(async move {
            while let Some(msg) = rx.recv().await {
                if sender.send(msg).await.is_err() {
                    break;
                }
            }
        });

        // Spawn heartbeat task
        let heartbeat_task = self.start_heartbeat(client_id, tx.clone());

        // Handle incoming messages
        while let Some(Ok(msg)) = receiver.next().await {
            match msg {
                Message::Text(text) => {
                    if text.len() > self.config.max_message_size {
                        let _ = tx.send(Message::Text(
                            serde_json::to_string(&ServerMessage::Error {
                                message: "Message too large".into()
                            }).unwrap()
                        ));
                        continue;
                    }

                    if let Ok(client_msg) = serde_json::from_str::<ClientMessage>(&text) {
                        if let Some(response) = self.handle_message(client_id, client_msg).await {
                            let _ = tx.send(Message::Text(
                                serde_json::to_string(&response).unwrap()
                            ));
                        }
                    }
                }
                Message::Pong(_) => {
                    let mut clients = self.clients.write().await;
                    if let Some(client) = clients.get_mut(&client_id) {
                        client.last_pong = Instant::now();
                    }
                }
                Message::Close(_) => break,
                _ => {}
            }
        }

        // Cleanup
        heartbeat_task.abort();
        send_task.abort();
        self.cleanup_client(client_id).await;
    }

    async fn handle_message(&self, client_id: Uuid, msg: ClientMessage) -> Option<ServerMessage> {
        match msg {
            ClientMessage::Join { room } => {
                match self.join_room(client_id, &room).await {
                    Ok(members) => Some(ServerMessage::Joined { room, members }),
                    Err(e) => Some(ServerMessage::Error { message: e }),
                }
            }
            ClientMessage::Leave { room } => {
                self.leave_room(client_id, &room).await;
                Some(ServerMessage::Left { room })
            }
            ClientMessage::Message { room, content } => {
                let msg = ServerMessage::Message {
                    room: room.clone(),
                    from: client_id.to_string(),
                    content,
                };
                self.broadcast_to_room(&room, msg, Some(client_id)).await;
                None
            }
            ClientMessage::Ping => Some(ServerMessage::Pong),
        }
    }

    async fn join_room(&self, client_id: Uuid, room_name: &str) -> Result<usize, String> {
        let mut rooms = self.rooms.write().await;

        let room = rooms.entry(room_name.to_string()).or_insert_with(|| {
            let (tx, _) = broadcast::channel(100);
            Room {
                name: room_name.to_string(),
                members: HashSet::new(),
                tx,
            }
        });

        if room.members.len() >= self.config.max_clients_per_room {
            return Err("Room is full".into());
        }

        room.members.insert(client_id);
        let count = room.members.len();

        // Update client's room list
        let mut clients = self.clients.write().await;
        if let Some(client) = clients.get_mut(&client_id) {
            client.rooms.insert(room_name.to_string());
        }

        // Notify others
        drop(rooms);
        drop(clients);
        self.broadcast_to_room(room_name, ServerMessage::UserJoined {
            room: room_name.to_string(),
            user_id: client_id.to_string(),
        }, Some(client_id)).await;

        Ok(count)
    }

    async fn leave_room(&self, client_id: Uuid, room_name: &str) {
        let mut rooms = self.rooms.write().await;

        if let Some(room) = rooms.get_mut(room_name) {
            room.members.remove(&client_id);

            // Remove empty rooms
            if room.members.is_empty() {
                rooms.remove(room_name);
            }
        }

        // Update client's room list
        let mut clients = self.clients.write().await;
        if let Some(client) = clients.get_mut(&client_id) {
            client.rooms.remove(room_name);
        }

        // Notify others
        drop(rooms);
        drop(clients);
        self.broadcast_to_room(room_name, ServerMessage::UserLeft {
            room: room_name.to_string(),
            user_id: client_id.to_string(),
        }, None).await;
    }

    async fn broadcast_to_room(&self, room_name: &str, message: ServerMessage, exclude: Option<Uuid>) {
        let rooms = self.rooms.read().await;
        let clients = self.clients.read().await;

        if let Some(room) = rooms.get(room_name) {
            let json = serde_json::to_string(&message).unwrap();
            for member_id in &room.members {
                if exclude == Some(*member_id) {
                    continue;
                }
                if let Some(client) = clients.get(member_id) {
                    let _ = client.tx.send(Message::Text(json.clone()));
                }
            }
        }
    }

    async fn cleanup_client(&self, client_id: Uuid) {
        let rooms_to_leave: Vec<String>;
        {
            let clients = self.clients.read().await;
            rooms_to_leave = clients.get(&client_id)
                .map(|c| c.rooms.iter().cloned().collect())
                .unwrap_or_default();
        }

        for room in rooms_to_leave {
            self.leave_room(client_id, &room).await;
        }

        let mut clients = self.clients.write().await;
        clients.remove(&client_id);
    }

    fn start_heartbeat(&self, client_id: Uuid, tx: mpsc::UnboundedSender<Message>) -> tokio::task::JoinHandle<()> {
        let config = self.config.clone();
        let clients = Arc::clone(&self.clients);

        tokio::spawn(async move {
            let mut interval = tokio::time::interval(config.ping_interval);

            loop {
                interval.tick().await;

                // Send ping
                if tx.send(Message::Ping(vec![])).is_err() {
                    break;
                }

                // Check last pong
                let clients_guard = clients.read().await;
                if let Some(client) = clients_guard.get(&client_id) {
                    if client.last_pong.elapsed() > config.pong_timeout {
                        let _ = tx.send(Message::Close(None));
                        break;
                    }
                }
            }
        })
    }
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Pas de heartbeat */
fn start_heartbeat(&self, _client_id: Uuid, _tx: mpsc::UnboundedSender<Message>) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async {})  // MUTANT: Ne fait rien
}
// Pourquoi c'est faux : Connexions mortes jamais detectees

/* Mutant B : Broadcast a tous y compris sender */
async fn broadcast_to_room(&self, room_name: &str, message: ServerMessage, _exclude: Option<Uuid>) {
    // MUTANT: Ignore exclude parameter
    for member_id in &room.members {
        // Envoie a tous
    }
}
// Pourquoi c'est faux : Sender recoit son propre message

/* Mutant C : Pas de cleanup */
async fn cleanup_client(&self, _client_id: Uuid) {
    // MUTANT: Ne fait rien
}
// Pourquoi c'est faux : Memory leak, ghost members in rooms

/* Mutant D : Ignore Close frame */
Message::Close(_) => {
    // MUTANT: Continue au lieu de break
    continue;
}
// Pourquoi c'est faux : Connexion zombie

/* Mutant E : Pas de limite taille message */
Message::Text(text) => {
    // MUTANT: Pas de check text.len()
    let client_msg = serde_json::from_str(&text)?;
}
// Pourquoi c'est faux : DoS possible avec gros messages
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **WebSocket Protocol** : Upgrade, frames, opcodes
2. **Async Patterns** : mpsc, broadcast channels
3. **Connection Management** : Heartbeat, cleanup
4. **Room Pattern** : Pub/sub, broadcasting

### 5.2 Visualisation ASCII

```
            WEBSOCKET SERVER ARCHITECTURE

┌─────────────────────────────────────────────────────────┐
│                    WebSocket Server                      │
│  ┌─────────────────────────────────────────────────┐    │
│  │                    Rooms                         │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐      │    │
│  │  │ general  │  │  gaming  │  │  support │      │    │
│  │  │ [C1,C2]  │  │ [C3,C4]  │  │   [C5]   │      │    │
│  │  └──────────┘  └──────────┘  └──────────┘      │    │
│  └─────────────────────────────────────────────────┘    │
│                          │                               │
│  ┌─────────────────────────────────────────────────┐    │
│  │                   Clients                        │    │
│  │  ┌────┐  ┌────┐  ┌────┐  ┌────┐  ┌────┐       │    │
│  │  │ C1 │  │ C2 │  │ C3 │  │ C4 │  │ C5 │       │    │
│  │  │ tx │  │ tx │  │ tx │  │ tx │  │ tx │       │    │
│  │  └────┘  └────┘  └────┘  └────┘  └────┘       │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
         │        │        │        │        │
         ▼        ▼        ▼        ▼        ▼
      Client1  Client2  Client3  Client4  Client5
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | No heartbeat | Dead connections persist | Ping/pong loop |
| 2 | Self-broadcast | Echo messages | Exclude sender |
| 3 | No cleanup | Memory leak | Remove on disconnect |
| 4 | Ignore Close | Zombie connections | Break on Close |
| 5 | No size limit | DoS vulnerability | Check message size |

---

## SECTION 7 : QCM

### Question 1
**Quel status code pour un WebSocket upgrade reussi ?**

A) 200 OK
B) 101 Switching Protocols
C) 204 No Content
D) 301 Moved Permanently

**Reponse : B**

---

### Question 2
**Quel message utilise pour verifier qu'une connexion est vivante ?**

A) Text "heartbeat"
B) Binary check
C) Ping/Pong frames
D) HTTP GET

**Reponse : C**

---

### Question 3
**Pourquoi utiliser un broadcast channel pour les rooms ?**

A) C'est plus rapide
B) Permet d'envoyer a plusieurs receivers
C) Consomme moins de memoire
D) Required par le protocole

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | websocket_server |
| **Module** | 5.3.12 - Real-Time Communication |
| **Difficulte** | 7/10 |
| **XP** | 200 |
| **Concepts cles** | WebSocket, channels, rooms |
| **Piege principal** | Connexions mortes non detectees |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.12-a-websocket-server",
    "metadata": {
      "exercise_id": "5.3.12-a",
      "exercise_name": "websocket_server",
      "module": "5.3.12",
      "difficulty": 7,
      "xp_base": 200
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "See the Matrix in real-time"*
*Exercise Quality Score: 96/100*
