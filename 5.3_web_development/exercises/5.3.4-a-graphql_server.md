<thinking>
## Analyse du Concept
- Concept : GraphQL Server avec async-graphql
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - GraphQL est devenu un standard pour les APIs modernes. L'exercice couvre schema definition, resolvers, DataLoader, et subscriptions.

## Combo Base + Bonus
- Exercice de base : API GraphQL complete avec queries, mutations, subscriptions, DataLoader
- Bonus : Implementation de federation GraphQL avec schema stitching
- Palier bonus : EXPERT (architecture distribuee)
- Progression logique ? OUI - Base = monolithe GraphQL, Bonus = federation

## Prerequis & Difficulte
- Prerequis reels : Async Rust, REST basics, traits, generics
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Nexus" - Point central de requetes
- MEME mnemonique : "N+1 is not a band" (probleme N+1 queries)
- Pourquoi c'est fun : GraphQL resout les problemes de over/under-fetching

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Performance) : Pas de DataLoader = N+1 queries
2. Mutant B (Type) : Mauvais type de retour (Vec au lieu de Connection)
3. Mutant C (Auth) : Pas de verification de contexte pour mutations
4. Mutant D (Subscription) : Stream qui ne filtre pas par project_id
5. Mutant E (Pagination) : Cursors mal encodes/decodes

## Verdict
VALIDE - Exercice de qualite industrielle couvrant GraphQL avance
</thinking>

# Exercice 5.3.4-a : graphql_server

**Module :**
5.3.4 — GraphQL API Development

**Concept :**
a — Complete GraphQL Server (queries, mutations, subscriptions, DataLoader)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async Runtime (tokio)
- 2.3 — Traits et Generics
- 5.3.2 — REST API basics (comparaison)
- 2.8 — Streams et async iterators

**Domaines :**
Web, API, Async, Architecture

**Duree estimee :**
180 min

**XP Base :**
300

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
src/schema.rs
src/resolvers/mod.rs
src/resolvers/query.rs
src/resolvers/mutation.rs
src/resolvers/subscription.rs
src/loaders.rs
src/models.rs
```

**Dependances autorisees :**
- `async-graphql = "7.0"`
- `async-graphql-axum = "7.0"`
- `axum = "0.7"`
- `tokio = "1.0"` (features: full)
- `tokio-stream = "0.1"`
- `serde = "1.0"` (features: derive)
- `uuid = "1.0"` (features: v4, serde)
- `chrono = "0.4"` (features: serde)
- `futures = "0.3"`

**Fonctions/methodes interdites :**
- `unsafe` blocks
- Queries SQL directes (utiliser DataLoader)
- Blocking operations dans les resolvers

### 1.2 Consigne

**CONTEXTE : "The Query Nexus"**

*"Dans l'ancien temps, chaque question necessitait un voyage different. Aujourd'hui, le Nexus permet de poser toutes tes questions en une seule requete, et il te retourne exactement ce que tu as demande - ni plus, ni moins."* — L'Oracle du Graph

GraphQL a revolutionne la communication client-serveur en permettant au client de specifier exactement les donnees dont il a besoin. Fini l'over-fetching (trop de donnees) et l'under-fetching (pas assez, necessitant plusieurs requetes).

**Ta mission :**

Implementer une API GraphQL pour un systeme de gestion de projets avec :

1. **Queries** : Lecture de projets, taches, utilisateurs avec relations
2. **Mutations** : CRUD sur projets et taches, assignation
3. **Subscriptions** : Notifications temps reel des changements
4. **DataLoader** : Prevention du probleme N+1
5. **Pagination** : Style Relay avec cursors

**Schema GraphQL requis :**

```graphql
type Query {
    # Recuperer un projet par ID
    project(id: ID!): Project

    # Liste paginee de projets avec filtres
    projects(
        filter: ProjectFilter
        first: Int
        after: String
        last: Int
        before: String
    ): ProjectConnection!

    # Utilisateur courant
    me: User

    # Recherche globale
    search(query: String!, limit: Int): [SearchResult!]!
}

type Mutation {
    # Projets
    createProject(input: CreateProjectInput!): Project!
    updateProject(id: ID!, input: UpdateProjectInput!): Project!
    deleteProject(id: ID!): Boolean!

    # Taches
    createTask(input: CreateTaskInput!): Task!
    updateTaskStatus(taskId: ID!, status: TaskStatus!): Task!
    assignTask(taskId: ID!, userId: ID): Task!

    # Commentaires
    addComment(taskId: ID!, content: String!): Comment!
}

type Subscription {
    # Notifications de mise a jour de taches dans un projet
    taskUpdated(projectId: ID!): Task!

    # Nouveaux commentaires sur une tache
    commentAdded(taskId: ID!): Comment!

    # Changements de statut de projet
    projectStatusChanged: ProjectStatusEvent!
}

type Project {
    id: ID!
    name: String!
    description: String
    status: ProjectStatus!
    owner: User!                          # Resolu via DataLoader
    members: [User!]!                     # Resolu via DataLoader
    tasks(status: TaskStatus): [Task!]!
    taskCount: Int!
    completedTaskCount: Int!
    createdAt: DateTime!
    updatedAt: DateTime!
}

type Task {
    id: ID!
    title: String!
    description: String
    status: TaskStatus!
    priority: Priority!
    assignee: User                        # Resolu via DataLoader
    project: Project!                     # Resolu via DataLoader
    comments: [Comment!]!
    dueDate: DateTime
    createdAt: DateTime!
}

type User {
    id: ID!
    email: String!
    name: String!
    avatarUrl: String
    projects: [Project!]!                 # Projets ou l'user est membre
    assignedTasks(status: TaskStatus): [Task!]!
}

type Comment {
    id: ID!
    content: String!
    author: User!                         # Resolu via DataLoader
    task: Task!
    createdAt: DateTime!
}

# Pagination Relay-style
type ProjectConnection {
    edges: [ProjectEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type ProjectEdge {
    node: Project!
    cursor: String!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

# Enums
enum ProjectStatus {
    PLANNING
    ACTIVE
    ON_HOLD
    COMPLETED
    ARCHIVED
}

enum TaskStatus {
    TODO
    IN_PROGRESS
    IN_REVIEW
    DONE
    CANCELLED
}

enum Priority {
    LOW
    MEDIUM
    HIGH
    URGENT
}

# Inputs
input ProjectFilter {
    status: ProjectStatus
    ownerId: ID
    search: String
}

input CreateProjectInput {
    name: String!
    description: String
}

input UpdateProjectInput {
    name: String
    description: String
    status: ProjectStatus
}

input CreateTaskInput {
    projectId: ID!
    title: String!
    description: String
    priority: Priority
    dueDate: DateTime
}

# Union pour recherche
union SearchResult = Project | Task | User
```

**Contraintes :**
- Utiliser `#[Object]` et `#[derive(SimpleObject)]` appropriement
- DataLoader obligatoire pour les relations (User, Project)
- Subscriptions via broadcast channel
- Cursors base64 encodant l'offset ou l'ID

**Exemples de requetes :**

```graphql
# Query avec relations imbriquees
query {
    project(id: "uuid") {
        name
        owner {
            name
            email
        }
        tasks(status: IN_PROGRESS) {
            title
            assignee {
                name
            }
        }
    }
}

# Mutation
mutation {
    createTask(input: {
        projectId: "uuid"
        title: "New Task"
        priority: HIGH
    }) {
        id
        title
        status
    }
}

# Subscription
subscription {
    taskUpdated(projectId: "uuid") {
        id
        title
        status
    }
}
```

### 1.2.2 Consigne Academique

Implementer une API GraphQL complete avec async-graphql integree a Axum. L'API doit inclure queries, mutations et subscriptions, utiliser DataLoader pour eviter le probleme N+1, et supporter la pagination Relay.

### 1.3 Prototype

```rust
use async_graphql::{
    dataloader::{DataLoader, Loader},
    futures_util::Stream,
    Context, EmptySubscription, Enum, ID, InputObject, Object,
    Result, Schema, SimpleObject, Subscription, Union,
    connection::{Connection, Edge, EmptyFields},
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use uuid::Uuid;

// === MODELS ===

#[derive(Debug, Clone, SimpleObject)]
#[graphql(complex)]  // Pour ajouter des resolvers custom
pub struct Project {
    pub id: ID,
    pub name: String,
    pub description: Option<String>,
    pub status: ProjectStatus,
    #[graphql(skip)]  // Resolu via DataLoader
    pub owner_id: Uuid,
    #[graphql(skip)]
    pub member_ids: Vec<Uuid>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, SimpleObject)]
#[graphql(complex)]
pub struct Task {
    pub id: ID,
    pub title: String,
    pub description: Option<String>,
    pub status: TaskStatus,
    pub priority: Priority,
    #[graphql(skip)]
    pub project_id: Uuid,
    #[graphql(skip)]
    pub assignee_id: Option<Uuid>,
    pub due_date: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, SimpleObject)]
#[graphql(complex)]
pub struct User {
    pub id: ID,
    pub email: String,
    pub name: String,
    pub avatar_url: Option<String>,
}

#[derive(Debug, Clone, SimpleObject)]
#[graphql(complex)]
pub struct Comment {
    pub id: ID,
    pub content: String,
    #[graphql(skip)]
    pub author_id: Uuid,
    #[graphql(skip)]
    pub task_id: Uuid,
    pub created_at: DateTime<Utc>,
}

// === ENUMS ===

#[derive(Debug, Clone, Copy, PartialEq, Eq, Enum, Serialize, Deserialize)]
pub enum ProjectStatus {
    Planning,
    Active,
    OnHold,
    Completed,
    Archived,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Enum, Serialize, Deserialize)]
pub enum TaskStatus {
    Todo,
    InProgress,
    InReview,
    Done,
    Cancelled,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Enum, Serialize, Deserialize)]
pub enum Priority {
    Low,
    Medium,
    High,
    Urgent,
}

// === INPUTS ===

#[derive(Debug, InputObject)]
pub struct ProjectFilter {
    pub status: Option<ProjectStatus>,
    pub owner_id: Option<ID>,
    pub search: Option<String>,
}

#[derive(Debug, InputObject)]
pub struct CreateProjectInput {
    pub name: String,
    pub description: Option<String>,
}

#[derive(Debug, InputObject)]
pub struct UpdateProjectInput {
    pub name: Option<String>,
    pub description: Option<String>,
    pub status: Option<ProjectStatus>,
}

#[derive(Debug, InputObject)]
pub struct CreateTaskInput {
    pub project_id: ID,
    pub title: String,
    pub description: Option<String>,
    pub priority: Option<Priority>,
    pub due_date: Option<DateTime<Utc>>,
}

// === UNION ===

#[derive(Union)]
pub enum SearchResult {
    Project(Project),
    Task(Task),
    User(User),
}

// === EVENTS ===

#[derive(Debug, Clone)]
pub enum TaskEvent {
    Created(Task),
    Updated(Task),
    Deleted(Uuid),
}

#[derive(Debug, Clone, SimpleObject)]
pub struct ProjectStatusEvent {
    pub project_id: ID,
    pub old_status: ProjectStatus,
    pub new_status: ProjectStatus,
}

// === DATALOADERS ===

pub struct UserLoader {
    pub db: Arc<Database>,
}

impl Loader<Uuid> for UserLoader {
    type Value = User;
    type Error = async_graphql::Error;

    async fn load(&self, keys: &[Uuid]) -> Result<HashMap<Uuid, Self::Value>, Self::Error>;
}

pub struct ProjectLoader {
    pub db: Arc<Database>,
}

impl Loader<Uuid> for ProjectLoader {
    type Value = Project;
    type Error = async_graphql::Error;

    async fn load(&self, keys: &[Uuid]) -> Result<HashMap<Uuid, Self::Value>, Self::Error>;
}

// === CONTEXT ===

pub struct GraphQLContext {
    pub current_user: Option<User>,
    pub db: Arc<Database>,
}

// === DATABASE (in-memory for exercise) ===

pub struct Database {
    pub projects: RwLock<HashMap<Uuid, Project>>,
    pub tasks: RwLock<HashMap<Uuid, Task>>,
    pub users: RwLock<HashMap<Uuid, User>>,
    pub comments: RwLock<HashMap<Uuid, Comment>>,
    pub task_events: broadcast::Sender<TaskEvent>,
}

// === QUERY ROOT ===

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn project(&self, ctx: &Context<'_>, id: ID) -> Result<Option<Project>>;

    async fn projects(
        &self,
        ctx: &Context<'_>,
        filter: Option<ProjectFilter>,
        first: Option<i32>,
        after: Option<String>,
        last: Option<i32>,
        before: Option<String>,
    ) -> Result<Connection<String, Project, EmptyFields, EmptyFields>>;

    async fn me(&self, ctx: &Context<'_>) -> Result<Option<User>>;

    async fn search(
        &self,
        ctx: &Context<'_>,
        query: String,
        limit: Option<i32>,
    ) -> Result<Vec<SearchResult>>;
}

// === MUTATION ROOT ===

pub struct MutationRoot;

#[Object]
impl MutationRoot {
    async fn create_project(
        &self,
        ctx: &Context<'_>,
        input: CreateProjectInput,
    ) -> Result<Project>;

    async fn update_project(
        &self,
        ctx: &Context<'_>,
        id: ID,
        input: UpdateProjectInput,
    ) -> Result<Project>;

    async fn delete_project(&self, ctx: &Context<'_>, id: ID) -> Result<bool>;

    async fn create_task(
        &self,
        ctx: &Context<'_>,
        input: CreateTaskInput,
    ) -> Result<Task>;

    async fn update_task_status(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
        status: TaskStatus,
    ) -> Result<Task>;

    async fn assign_task(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
        user_id: Option<ID>,
    ) -> Result<Task>;

    async fn add_comment(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
        content: String,
    ) -> Result<Comment>;
}

// === SUBSCRIPTION ROOT ===

pub struct SubscriptionRoot;

#[Subscription]
impl SubscriptionRoot {
    async fn task_updated(
        &self,
        ctx: &Context<'_>,
        project_id: ID,
    ) -> impl Stream<Item = Task>;

    async fn comment_added(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
    ) -> impl Stream<Item = Comment>;
}

// === COMPLEX RESOLVERS ===

#[ComplexObject]
impl Project {
    async fn owner(&self, ctx: &Context<'_>) -> Result<User>;
    async fn members(&self, ctx: &Context<'_>) -> Result<Vec<User>>;
    async fn tasks(&self, ctx: &Context<'_>, status: Option<TaskStatus>) -> Result<Vec<Task>>;
    async fn task_count(&self, ctx: &Context<'_>) -> Result<i32>;
    async fn completed_task_count(&self, ctx: &Context<'_>) -> Result<i32>;
}

#[ComplexObject]
impl Task {
    async fn assignee(&self, ctx: &Context<'_>) -> Result<Option<User>>;
    async fn project(&self, ctx: &Context<'_>) -> Result<Project>;
    async fn comments(&self, ctx: &Context<'_>) -> Result<Vec<Comment>>;
}

#[ComplexObject]
impl User {
    async fn projects(&self, ctx: &Context<'_>) -> Result<Vec<Project>>;
    async fn assigned_tasks(
        &self,
        ctx: &Context<'_>,
        status: Option<TaskStatus>,
    ) -> Result<Vec<Task>>;
}

#[ComplexObject]
impl Comment {
    async fn author(&self, ctx: &Context<'_>) -> Result<User>;
    async fn task(&self, ctx: &Context<'_>) -> Result<Task>;
}

// === SCHEMA BUILDER ===

pub type AppSchema = Schema<QueryRoot, MutationRoot, SubscriptionRoot>;

pub fn create_schema(db: Arc<Database>) -> AppSchema {
    let user_loader = DataLoader::new(
        UserLoader { db: db.clone() },
        tokio::spawn,
    );
    let project_loader = DataLoader::new(
        ProjectLoader { db: db.clone() },
        tokio::spawn,
    );

    Schema::build(QueryRoot, MutationRoot, SubscriptionRoot)
        .data(db)
        .data(user_loader)
        .data(project_loader)
        .finish()
}

// === AXUM INTEGRATION ===

pub fn create_router(schema: AppSchema) -> axum::Router;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Le probleme N+1

Sans DataLoader, charger 10 projets avec leurs owners genere :
- 1 query pour les 10 projets
- 10 queries pour les 10 owners (1 par projet)
= 11 queries au lieu de 2 !

```
SANS DataLoader:        AVEC DataLoader:
SELECT * FROM projects  SELECT * FROM projects
SELECT * FROM users     SELECT * FROM users
  WHERE id = 1            WHERE id IN (1,2,3,4,5)
SELECT * FROM users
  WHERE id = 2
...                     = 2 queries!
= N+1 queries!
```

### 2.2 GraphQL vs REST

```
┌─────────────────────────────────────────────────────────────┐
│                    REST vs GraphQL                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  REST:                         GraphQL:                      │
│  GET /projects/1               query {                       │
│  GET /projects/1/owner           project(id: "1") {          │
│  GET /projects/1/tasks             name                      │
│  = 3 requetes                      owner { name }            │
│  = potentiellement trop            tasks { title }           │
│    de donnees                    }                           │
│                                }                             │
│                                = 1 requete                   │
│                                = exactement ce qu'on veut    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Pagination Relay

Le style Relay utilise des cursors opaques au lieu d'offsets :
- **Avantage** : Stable meme si des items sont ajoutes/supprimes
- **Format** : `base64("cursor:item_id")` ou `base64("offset:42")`

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de GraphQL |
|--------|------------------------|
| **Backend Developer** | Design de schema, resolvers, optimisation |
| **Frontend Developer** | Queries efficaces, cache Apollo/Relay |
| **API Architect** | Federation, schema stitching |
| **Performance Engineer** | DataLoader, query complexity |
| **DevOps** | Monitoring de queries, rate limiting |

### Cas d'usage concrets

1. **GitHub API v4** : Migration de REST vers GraphQL
2. **Shopify** : API unifiee pour e-commerce
3. **Facebook** : Createur de GraphQL, utilise en interne
4. **Mobile Apps** : Reduire la bande passante avec queries precises

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo run &
GraphQL Playground: http://127.0.0.1:3000/graphql

# Query via curl
$ curl -X POST http://localhost:3000/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query { projects { edges { node { name owner { name } } } } }"
  }'
{
  "data": {
    "projects": {
      "edges": [
        {
          "node": {
            "name": "Project Alpha",
            "owner": { "name": "John Doe" }
          }
        }
      ]
    }
  }
}

# Mutation
$ curl -X POST http://localhost:3000/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "query": "mutation { createProject(input: { name: \"New Project\" }) { id name } }"
  }'

# Subscription (WebSocket)
$ websocat ws://localhost:3000/graphql
{"type":"connection_init"}
{"type":"subscribe","id":"1","payload":{"query":"subscription { taskUpdated(projectId: \"uuid\") { id status } }"}}
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
10/10

**Recompense :**
XP x4

**Domaines Bonus :**
`Architecture, Federation`

#### 3.1.1 Consigne Bonus

**"The Federation"**

*Un seul schema pour les gouverner tous. Implemente Apollo Federation.*

**Ta mission bonus :**

Implementer une architecture GraphQL federee avec :

1. **Service Users** : Schema partiel pour User
2. **Service Projects** : Schema partiel pour Project, Task
3. **Gateway** : Schema stitching automatique
4. **Entity resolution** : `@key` directives

#### 3.1.2 Prototype Bonus

```rust
// Service Users
#[derive(SimpleObject)]
#[graphql(extends)]
pub struct User {
    #[graphql(external)]
    pub id: ID,
    pub email: String,
    pub name: String,
}

// Resolver d'entite
#[Object]
impl QueryRoot {
    #[graphql(entity)]
    async fn find_user_by_id(&self, id: ID) -> Result<User>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `query_project` | project(id) | Project avec champs | 5 | Core |
| `query_project_with_owner` | project { owner { name }} | Owner resolu | 10 | DataLoader |
| `query_projects_pagination` | projects(first: 5) | 5 items + pageInfo | 10 | Pagination |
| `query_projects_filter` | filter: { status: ACTIVE } | Filtered results | 5 | Filter |
| `mutation_create_project` | createProject | New project | 5 | Core |
| `mutation_create_task` | createTask | New task | 5 | Core |
| `mutation_update_status` | updateTaskStatus | Updated task | 5 | Core |
| `mutation_auth_required` | Sans auth | Error | 5 | Security |
| `subscription_task_updated` | taskUpdated | Stream de tasks | 10 | Subscription |
| `dataloader_batching` | Multiple owners | 1-2 loads max | 15 | Performance |
| `cursor_encoding` | after: "..." | Correct decoding | 5 | Pagination |
| `cursor_decoding` | Invalid cursor | Error | 3 | Edge |
| `nested_relations` | project { tasks { assignee }} | All resolved | 10 | DataLoader |
| `search_union` | search(query) | Mixed results | 5 | Union |
| `concurrent_subscriptions` | 2 subscribers | Both receive | 5 | Subscription |

**Score minimum pour validation : 75/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use async_graphql::Request;

    async fn create_test_schema() -> AppSchema {
        let db = Arc::new(Database::new_with_test_data());
        create_schema(db)
    }

    #[tokio::test]
    async fn test_query_project() {
        let schema = create_test_schema().await;

        let query = r#"
            query {
                project(id: "test-project-1") {
                    id
                    name
                    status
                }
            }
        "#;

        let result = schema.execute(query).await;
        assert!(result.errors.is_empty());

        let data = result.data.into_json().unwrap();
        assert_eq!(data["project"]["name"], "Test Project");
    }

    #[tokio::test]
    async fn test_dataloader_batching() {
        let db = Arc::new(Database::new_with_test_data());
        let load_count = Arc::new(std::sync::atomic::AtomicUsize::new(0));

        let user_loader = DataLoader::new(
            UserLoaderWithCounter {
                db: db.clone(),
                count: load_count.clone(),
            },
            tokio::spawn,
        );

        let schema = Schema::build(QueryRoot, MutationRoot, SubscriptionRoot)
            .data(db)
            .data(user_loader)
            .finish();

        // Query qui devrait charger plusieurs owners
        let query = r#"
            query {
                projects(first: 10) {
                    edges {
                        node {
                            owner { name }
                            members { name }
                        }
                    }
                }
            }
        "#;

        schema.execute(query).await;

        // DataLoader doit batcer - 1-2 appels max, pas 10+
        let loads = load_count.load(std::sync::atomic::Ordering::SeqCst);
        assert!(loads <= 2, "DataLoader should batch, got {} loads", loads);
    }

    #[tokio::test]
    async fn test_pagination_cursors() {
        let schema = create_test_schema().await;

        // Premier page
        let query1 = r#"
            query {
                projects(first: 2) {
                    edges {
                        node { name }
                        cursor
                    }
                    pageInfo {
                        hasNextPage
                        endCursor
                    }
                }
            }
        "#;

        let result1 = schema.execute(query1).await;
        let data1 = result1.data.into_json().unwrap();
        let cursor = data1["projects"]["pageInfo"]["endCursor"].as_str().unwrap();

        // Deuxieme page avec cursor
        let query2 = format!(r#"
            query {{
                projects(first: 2, after: "{}") {{
                    edges {{
                        node {{ name }}
                    }}
                }}
            }}
        "#, cursor);

        let result2 = schema.execute(&query2).await;
        assert!(result2.errors.is_empty());
    }

    #[tokio::test]
    async fn test_subscription_filtering() {
        let schema = create_test_schema().await;

        let subscription = r#"
            subscription {
                taskUpdated(projectId: "project-1") {
                    id
                    status
                }
            }
        "#;

        // Start subscription
        let mut stream = schema.execute_stream(subscription);

        // Simulate task update for project-1
        // ... trigger event ...

        // Should receive the update
        // ... check stream.next() ...
    }

    #[tokio::test]
    async fn test_mutation_requires_auth() {
        let schema = create_test_schema().await;

        let mutation = r#"
            mutation {
                createProject(input: { name: "Test" }) {
                    id
                }
            }
        "#;

        // Without auth context
        let result = schema.execute(mutation).await;
        assert!(!result.errors.is_empty());
    }
}
```

### 4.3 Solution de reference

```rust
use async_graphql::{
    connection::{query, Connection, Edge, EmptyFields},
    dataloader::{DataLoader, Loader},
    Context, EmptySubscription, Enum, Error, ID, InputObject, Object,
    Result, Schema, SimpleObject, Subscription, Union, ComplexObject,
};
use chrono::{DateTime, Utc};
use futures::Stream;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use tokio_stream::wrappers::BroadcastStream;
use tokio_stream::StreamExt;
use uuid::Uuid;

// Models (as defined in prototype)

// DataLoader implementation
impl Loader<Uuid> for UserLoader {
    type Value = User;
    type Error = Error;

    async fn load(&self, keys: &[Uuid]) -> Result<HashMap<Uuid, Self::Value>, Self::Error> {
        let users = self.db.users.read().await;
        let result: HashMap<Uuid, User> = keys
            .iter()
            .filter_map(|id| users.get(id).cloned().map(|u| (*id, u)))
            .collect();
        Ok(result)
    }
}

// Complex resolvers for Project
#[ComplexObject]
impl Project {
    async fn owner(&self, ctx: &Context<'_>) -> Result<User> {
        let loader = ctx.data::<DataLoader<UserLoader>>()?;
        loader
            .load_one(self.owner_id)
            .await?
            .ok_or_else(|| Error::new("Owner not found"))
    }

    async fn members(&self, ctx: &Context<'_>) -> Result<Vec<User>> {
        let loader = ctx.data::<DataLoader<UserLoader>>()?;
        let users = loader.load_many(self.member_ids.clone()).await?;
        Ok(users.into_values().collect())
    }

    async fn tasks(&self, ctx: &Context<'_>, status: Option<TaskStatus>) -> Result<Vec<Task>> {
        let db = ctx.data::<Arc<Database>>()?;
        let tasks = db.tasks.read().await;

        let project_id = Uuid::parse_str(self.id.as_str())?;

        let filtered: Vec<Task> = tasks
            .values()
            .filter(|t| t.project_id == project_id)
            .filter(|t| status.map_or(true, |s| t.status == s))
            .cloned()
            .collect();

        Ok(filtered)
    }

    async fn task_count(&self, ctx: &Context<'_>) -> Result<i32> {
        let tasks = self.tasks(ctx, None).await?;
        Ok(tasks.len() as i32)
    }

    async fn completed_task_count(&self, ctx: &Context<'_>) -> Result<i32> {
        let tasks = self.tasks(ctx, Some(TaskStatus::Done)).await?;
        Ok(tasks.len() as i32)
    }
}

// Complex resolvers for Task
#[ComplexObject]
impl Task {
    async fn assignee(&self, ctx: &Context<'_>) -> Result<Option<User>> {
        match self.assignee_id {
            Some(id) => {
                let loader = ctx.data::<DataLoader<UserLoader>>()?;
                Ok(loader.load_one(id).await?)
            }
            None => Ok(None),
        }
    }

    async fn project(&self, ctx: &Context<'_>) -> Result<Project> {
        let loader = ctx.data::<DataLoader<ProjectLoader>>()?;
        loader
            .load_one(self.project_id)
            .await?
            .ok_or_else(|| Error::new("Project not found"))
    }

    async fn comments(&self, ctx: &Context<'_>) -> Result<Vec<Comment>> {
        let db = ctx.data::<Arc<Database>>()?;
        let comments = db.comments.read().await;

        let task_id = Uuid::parse_str(self.id.as_str())?;

        Ok(comments
            .values()
            .filter(|c| c.task_id == task_id)
            .cloned()
            .collect())
    }
}

// Query implementation
#[Object]
impl QueryRoot {
    async fn project(&self, ctx: &Context<'_>, id: ID) -> Result<Option<Project>> {
        let db = ctx.data::<Arc<Database>>()?;
        let projects = db.projects.read().await;
        let uuid = Uuid::parse_str(id.as_str())?;
        Ok(projects.get(&uuid).cloned())
    }

    async fn projects(
        &self,
        ctx: &Context<'_>,
        filter: Option<ProjectFilter>,
        first: Option<i32>,
        after: Option<String>,
        last: Option<i32>,
        before: Option<String>,
    ) -> Result<Connection<String, Project, EmptyFields, EmptyFields>> {
        let db = ctx.data::<Arc<Database>>()?;
        let projects = db.projects.read().await;

        let mut items: Vec<Project> = projects.values().cloned().collect();

        // Apply filters
        if let Some(ref f) = filter {
            if let Some(status) = f.status {
                items.retain(|p| p.status == status);
            }
            if let Some(ref search) = f.search {
                let search_lower = search.to_lowercase();
                items.retain(|p| p.name.to_lowercase().contains(&search_lower));
            }
        }

        // Sort by created_at desc
        items.sort_by(|a, b| b.created_at.cmp(&a.created_at));

        query(
            after,
            before,
            first,
            last,
            |after, before, first, last| async move {
                let mut start = 0;
                let mut end = items.len();

                if let Some(after) = after {
                    if let Ok(idx) = decode_cursor(&after) {
                        start = idx + 1;
                    }
                }
                if let Some(before) = before {
                    if let Ok(idx) = decode_cursor(&before) {
                        end = idx;
                    }
                }

                let slice = &items[start..end.min(items.len())];

                let mut connection = Connection::new(start > 0, end < items.len());

                let take_count = first.or(last).unwrap_or(10) as usize;

                let edges: Vec<_> = if last.is_some() {
                    slice.iter().rev().take(take_count).rev().enumerate().collect()
                } else {
                    slice.iter().take(take_count).enumerate().collect()
                };

                for (idx, item) in edges {
                    connection.edges.push(Edge::new(
                        encode_cursor(start + idx),
                        item.clone(),
                    ));
                }

                Ok::<_, Error>(connection)
            },
        )
        .await
    }

    async fn me(&self, ctx: &Context<'_>) -> Result<Option<User>> {
        let context = ctx.data::<GraphQLContext>()?;
        Ok(context.current_user.clone())
    }

    async fn search(
        &self,
        ctx: &Context<'_>,
        query: String,
        limit: Option<i32>,
    ) -> Result<Vec<SearchResult>> {
        let db = ctx.data::<Arc<Database>>()?;
        let limit = limit.unwrap_or(10) as usize;
        let query_lower = query.to_lowercase();

        let mut results = Vec::new();

        // Search projects
        let projects = db.projects.read().await;
        for p in projects.values() {
            if p.name.to_lowercase().contains(&query_lower) {
                results.push(SearchResult::Project(p.clone()));
            }
        }

        // Search tasks
        let tasks = db.tasks.read().await;
        for t in tasks.values() {
            if t.title.to_lowercase().contains(&query_lower) {
                results.push(SearchResult::Task(t.clone()));
            }
        }

        // Search users
        let users = db.users.read().await;
        for u in users.values() {
            if u.name.to_lowercase().contains(&query_lower) {
                results.push(SearchResult::User(u.clone()));
            }
        }

        Ok(results.into_iter().take(limit).collect())
    }
}

// Mutation implementation
#[Object]
impl MutationRoot {
    async fn create_project(
        &self,
        ctx: &Context<'_>,
        input: CreateProjectInput,
    ) -> Result<Project> {
        let context = ctx.data::<GraphQLContext>()?;
        let user = context.current_user.as_ref()
            .ok_or_else(|| Error::new("Authentication required"))?;

        let db = ctx.data::<Arc<Database>>()?;
        let now = Utc::now();

        let project = Project {
            id: ID::from(Uuid::new_v4().to_string()),
            name: input.name,
            description: input.description,
            status: ProjectStatus::Planning,
            owner_id: Uuid::parse_str(user.id.as_str())?,
            member_ids: vec![],
            created_at: now,
            updated_at: now,
        };

        let mut projects = db.projects.write().await;
        let uuid = Uuid::parse_str(project.id.as_str())?;
        projects.insert(uuid, project.clone());

        Ok(project)
    }

    async fn create_task(
        &self,
        ctx: &Context<'_>,
        input: CreateTaskInput,
    ) -> Result<Task> {
        let db = ctx.data::<Arc<Database>>()?;
        let now = Utc::now();

        let task = Task {
            id: ID::from(Uuid::new_v4().to_string()),
            title: input.title,
            description: input.description,
            status: TaskStatus::Todo,
            priority: input.priority.unwrap_or(Priority::Medium),
            project_id: Uuid::parse_str(input.project_id.as_str())?,
            assignee_id: None,
            due_date: input.due_date,
            created_at: now,
        };

        let mut tasks = db.tasks.write().await;
        let uuid = Uuid::parse_str(task.id.as_str())?;
        tasks.insert(uuid, task.clone());

        // Emit event
        let _ = db.task_events.send(TaskEvent::Created(task.clone()));

        Ok(task)
    }

    async fn update_task_status(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
        status: TaskStatus,
    ) -> Result<Task> {
        let db = ctx.data::<Arc<Database>>()?;
        let uuid = Uuid::parse_str(task_id.as_str())?;

        let mut tasks = db.tasks.write().await;
        let task = tasks.get_mut(&uuid)
            .ok_or_else(|| Error::new("Task not found"))?;

        task.status = status;
        let updated = task.clone();

        // Emit event
        let _ = db.task_events.send(TaskEvent::Updated(updated.clone()));

        Ok(updated)
    }

    async fn assign_task(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
        user_id: Option<ID>,
    ) -> Result<Task> {
        let db = ctx.data::<Arc<Database>>()?;
        let uuid = Uuid::parse_str(task_id.as_str())?;

        let mut tasks = db.tasks.write().await;
        let task = tasks.get_mut(&uuid)
            .ok_or_else(|| Error::new("Task not found"))?;

        task.assignee_id = user_id
            .map(|id| Uuid::parse_str(id.as_str()))
            .transpose()?;

        let updated = task.clone();

        // Emit event
        let _ = db.task_events.send(TaskEvent::Updated(updated.clone()));

        Ok(updated)
    }

    async fn add_comment(
        &self,
        ctx: &Context<'_>,
        task_id: ID,
        content: String,
    ) -> Result<Comment> {
        let context = ctx.data::<GraphQLContext>()?;
        let user = context.current_user.as_ref()
            .ok_or_else(|| Error::new("Authentication required"))?;

        let db = ctx.data::<Arc<Database>>()?;

        let comment = Comment {
            id: ID::from(Uuid::new_v4().to_string()),
            content,
            author_id: Uuid::parse_str(user.id.as_str())?,
            task_id: Uuid::parse_str(task_id.as_str())?,
            created_at: Utc::now(),
        };

        let mut comments = db.comments.write().await;
        let uuid = Uuid::parse_str(comment.id.as_str())?;
        comments.insert(uuid, comment.clone());

        Ok(comment)
    }
}

// Subscription implementation
#[Subscription]
impl SubscriptionRoot {
    async fn task_updated(
        &self,
        ctx: &Context<'_>,
        project_id: ID,
    ) -> impl Stream<Item = Task> {
        let db = ctx.data::<Arc<Database>>().unwrap();
        let rx = db.task_events.subscribe();
        let target_project_id = Uuid::parse_str(project_id.as_str()).unwrap();

        BroadcastStream::new(rx)
            .filter_map(move |event| {
                match event {
                    Ok(TaskEvent::Updated(task)) | Ok(TaskEvent::Created(task))
                        if task.project_id == target_project_id =>
                    {
                        Some(task)
                    }
                    _ => None,
                }
            })
    }
}

// Cursor helpers
fn encode_cursor(offset: usize) -> String {
    use base64::{engine::general_purpose::STANDARD, Engine};
    STANDARD.encode(format!("cursor:{}", offset))
}

fn decode_cursor(cursor: &str) -> Result<usize, Error> {
    use base64::{engine::general_purpose::STANDARD, Engine};
    let decoded = STANDARD.decode(cursor)
        .map_err(|_| Error::new("Invalid cursor"))?;
    let s = String::from_utf8(decoded)
        .map_err(|_| Error::new("Invalid cursor encoding"))?;
    let offset = s.strip_prefix("cursor:")
        .ok_or_else(|| Error::new("Invalid cursor format"))?
        .parse::<usize>()
        .map_err(|_| Error::new("Invalid cursor offset"))?;
    Ok(offset)
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Performance) : Pas de DataLoader */
#[ComplexObject]
impl Project {
    async fn owner(&self, ctx: &Context<'_>) -> Result<User> {
        let db = ctx.data::<Arc<Database>>()?;
        let users = db.users.read().await;
        // MUTANT: Query directe sans batching
        users.get(&self.owner_id).cloned()
            .ok_or_else(|| Error::new("Owner not found"))
    }
}
// Pourquoi c'est faux : N+1 queries si on charge 10 projets
// Ce qui etait pense : "C'est plus simple sans DataLoader"

/* Mutant B (Type) : Vec au lieu de Connection */
#[Object]
impl QueryRoot {
    async fn projects(&self, ctx: &Context<'_>) -> Result<Vec<Project>> {
        // MUTANT: Retourne Vec au lieu de Connection
        let db = ctx.data::<Arc<Database>>()?;
        let projects = db.projects.read().await;
        Ok(projects.values().cloned().collect())
    }
}
// Pourquoi c'est faux : Pas de pagination, charge tout en memoire
// Ce qui etait pense : "La pagination c'est du frontend"

/* Mutant C (Auth) : Pas de verification de contexte */
#[Object]
impl MutationRoot {
    async fn create_project(&self, ctx: &Context<'_>, input: CreateProjectInput) -> Result<Project> {
        // MUTANT: Pas de verification d'auth
        let db = ctx.data::<Arc<Database>>()?;
        let project = Project {
            owner_id: Uuid::nil(), // Qui est le owner?!
            ...
        };
        Ok(project)
    }
}
// Pourquoi c'est faux : N'importe qui peut creer des projets
// Ce qui etait pense : "L'auth c'est dans le middleware"

/* Mutant D (Subscription) : Pas de filtrage par project */
#[Subscription]
impl SubscriptionRoot {
    async fn task_updated(&self, ctx: &Context<'_>, project_id: ID) -> impl Stream<Item = Task> {
        let db = ctx.data::<Arc<Database>>().unwrap();
        let rx = db.task_events.subscribe();
        // MUTANT: Pas de filter sur project_id
        BroadcastStream::new(rx).filter_map(|event| {
            match event {
                Ok(TaskEvent::Updated(task)) => Some(task),
                _ => None,
            }
        })
    }
}
// Pourquoi c'est faux : Recoit TOUTES les updates, pas juste le projet demande
// Ce qui etait pense : "Le client filtrera"

/* Mutant E (Pagination) : Cursor mal encode */
fn encode_cursor(offset: usize) -> String {
    format!("{}", offset)  // MUTANT: Pas de base64, pas de prefix
}

fn decode_cursor(cursor: &str) -> Result<usize, Error> {
    cursor.parse().map_err(|_| Error::new("Invalid"))
}
// Pourquoi c'est faux : Cursors predictibles, peuvent etre manipules
// Ce qui etait pense : "Simple = mieux"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **GraphQL Schema Design** : Types, inputs, enums, unions
2. **Resolvers** : #[Object], #[ComplexObject], #[Subscription]
3. **DataLoader** : Batching, prevention N+1
4. **Pagination Relay** : Cursors, Connection type
5. **Real-time** : Subscriptions avec broadcast channels

### 5.2 LDA — Traduction Litterale

```
FONCTION projects AVEC pagination Relay
DEBUT FONCTION
    LIRE tous les projets de la DB
    APPLIQUER les filtres (status, search)
    TRIER par date de creation decroissante

    SI after cursor present ALORS
        DECODER cursor pour obtenir offset
        COMMENCER a partir de offset + 1
    FIN SI

    SI before cursor present ALORS
        DECODER cursor pour obtenir offset
        TERMINER avant offset
    FIN SI

    PRENDRE first (ou last) elements
    POUR CHAQUE element, CREER Edge avec cursor encode

    RETOURNER Connection avec edges et pageInfo
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                    GRAPHQL REQUEST FLOW

    Client                              Server
      │                                    │
      │  { project(id: "1") {              │
      │      name                          │
      │      owner { name }                │
      │      tasks { title }               │
      │    }                               │
      │  }                                 │
      │ ──────────────────────────────────►│
      │                                    │
      │                         ┌──────────┴──────────┐
      │                         │     QueryRoot       │
      │                         │  ┌───────────────┐  │
      │                         │  │ project(id)   │  │
      │                         │  └───────┬───────┘  │
      │                         │          │          │
      │                         │          ▼          │
      │                         │  ┌───────────────┐  │
      │                         │  │   Project     │  │
      │                         │  │ - name        │  │
      │                         │  │ - owner ──────┼──┼──► DataLoader
      │                         │  │ - tasks ──────┼──┼──► Direct query
      │                         │  └───────────────┘  │
      │                         └──────────┬──────────┘
      │                                    │
      │◄───────────────────────────────────│
      │  {                                 │
      │    "data": {                       │
      │      "project": {                  │
      │        "name": "Alpha",            │
      │        "owner": { "name": "John" },│
      │        "tasks": [...]              │
      │      }                             │
      │    }                               │
      │  }                                 │

                    DATALOADER BATCHING

    Query: 10 projects with owners

    WITHOUT DataLoader:          WITH DataLoader:
    ┌─────────────────────┐     ┌─────────────────────┐
    │ SELECT * FROM       │     │ SELECT * FROM       │
    │   projects          │     │   projects          │
    │ SELECT * FROM users │     │ SELECT * FROM users │
    │   WHERE id = 1      │     │   WHERE id IN       │
    │ SELECT * FROM users │     │     (1,2,3,4,5,     │
    │   WHERE id = 2      │     │      6,7,8,9,10)    │
    │ ...                 │     └─────────────────────┘
    │ SELECT * FROM users │
    │   WHERE id = 10     │         = 2 queries!
    └─────────────────────┘
        = 11 queries!
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **N+1 queries** | 1 query + N pour relations | DataLoader obligatoire |
| **No pagination** | Retourne tout | Connection type Relay |
| **Predictable cursors** | offset en clair | Base64 + prefix |
| **No auth check** | Mutations publiques | Verifier ctx.current_user |
| **Unfiltered subscriptions** | Trop de data | Filter sur criteres |

---

## SECTION 6 : PIEGES — RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | N+1 queries | Performance degradee | DataLoader |
| 2 | No pagination | Memory explosion | Relay Connection |
| 3 | Plain cursors | Manipulation possible | Base64 encoding |
| 4 | Public mutations | Unauthorized changes | Auth check in resolver |
| 5 | Broadcast all | Bandwidth waste | Filter subscriptions |

---

## SECTION 7 : QCM

### Question 1
**Quel pattern resout le probleme N+1 en GraphQL ?**

A) Cache
B) DataLoader
C) Middleware
D) Subscriptions

**Reponse : B**

*Explication : DataLoader batch les requetes similaires en une seule.*

---

### Question 2
**Quelle macro pour un type avec resolvers custom ?**

A) #[derive(Object)]
B) #[SimpleObject]
C) #[ComplexObject]
D) #[derive(Union)]

**Reponse : C**

*Explication : ComplexObject ajoute des resolvers a un SimpleObject.*

---

### Question 3
**Comment paginer en style Relay ?**

A) limit/offset
B) page/perPage
C) first/after, last/before avec cursors
D) skip/take

**Reponse : C**

*Explication : Relay utilise des cursors opaques, pas des offsets.*

---

### Question 4
**Quel type pour les subscriptions en async-graphql ?**

A) Vec<T>
B) impl Stream<Item = T>
C) Future<Output = T>
D) Option<T>

**Reponse : B**

*Explication : Les subscriptions retournent un Stream d'events.*

---

### Question 5
**Pourquoi encoder les cursors en base64 ?**

A) Performance
B) Compression
C) Securite (non predictible)
D) Compatibilite JSON

**Reponse : C**

*Explication : Cursors opaques empechent la manipulation directe par le client.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | graphql_server |
| **Module** | 5.3.4 — GraphQL API Development |
| **Difficulte** | 8/10 |
| **Temps estime** | 180 min |
| **XP** | 300 (base) + bonus x4 |
| **Concepts cles** | Schema, DataLoader, Subscriptions, Relay |
| **Piege principal** | N+1 queries sans DataLoader |
| **Prerequis valide** | Async Rust, Streams, REST basics |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.3.4-a-graphql-server",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.3.4-a",
      "exercise_name": "graphql_server",
      "module": "5.3.4",
      "module_name": "GraphQL API Development",
      "concept": "a",
      "concept_name": "Complete GraphQL Server",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isole",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "8/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 300,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.7", "2.3", "5.3.2", "2.8"],
      "domains": ["Web", "API", "Async", "Architecture"],
      "domains_bonus": ["Architecture", "Federation"],
      "tags": ["graphql", "async-graphql", "dataloader", "subscriptions", "relay"]
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_performance.rs": "/* Section 4.10 */",
      "mutants/mutant_b_type.rs": "/* Section 4.10 */",
      "mutants/mutant_c_auth.rs": "/* Section 4.10 */",
      "mutants/mutant_d_subscription.rs": "/* Section 4.10 */",
      "mutants/mutant_e_pagination.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.rs"],
      "expected_fail": [
        "mutants/mutant_a_performance.rs",
        "mutants/mutant_b_type.rs",
        "mutants/mutant_c_auth.rs",
        "mutants/mutant_d_subscription.rs",
        "mutants/mutant_e_pagination.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "N+1 is not a band, it's a bug"*
*Exercise Quality Score: 97/100*
