<thinking>
## Analyse du Concept
- Concept : Cache Control
- Adapte ? OUI - HTTP caching est essentiel pour les performances.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Cache public de donnees privees
2. Mutant B : ETag mal calcule
3. Mutant C : Stale-while-revalidate mal implemente
4. Mutant D : Vary header manquant
5. Mutant E : no-store vs no-cache confusion
</thinking>

# Exercice 5.3.16-a : cache_control

**Module :**
5.3.16 — HTTP Caching & Cache-Control Headers

**Concept :**
a — Cache Control Middleware (directives, ETags, conditional requests)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.1.2 — HTTP Protocol
- 5.3.1 — Axum basics

**Domaines :**
Web, Performance, Caching

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(1) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `tower = "0.4"`
- `http = "1.0"`
- `sha2 = "0.10"`

### 1.2 Consigne

**CONTEXTE : "The Caching Chronicles"**

*"Le meilleur request est celui qu'on ne fait pas."* — Web Performance Wisdom

Le caching HTTP peut reduire la latence de 90% et la bande passante de 80%. Mais mal configure, il peut servir des donnees obsoletes ou privees.

**Ta mission :**

Implementer un middleware de cache control avec :
1. **Cache-Control directives** : public, private, no-cache, no-store, max-age
2. **ETag generation** basee sur le contenu
3. **Conditional requests** : If-None-Match, If-Modified-Since
4. **Vary header** pour caching contextuel
5. **Stale-while-revalidate** pour freshness

**Directives Cache-Control :**

| Directive | Effet |
|-----------|-------|
| public | CDN/proxy peuvent cacher |
| private | Navigateur only |
| no-cache | Revalider avant utilisation |
| no-store | Ne jamais stocker |
| max-age=N | Frais pendant N secondes |
| s-maxage=N | max-age pour CDN |
| stale-while-revalidate=N | Servir stale pendant revalidation |

### 1.3 Prototype

```rust
use http::{header, Response, StatusCode};
use sha2::{Sha256, Digest};

#[derive(Debug, Clone, Default)]
pub struct CachePolicy {
    pub public: bool,
    pub private: bool,
    pub no_cache: bool,
    pub no_store: bool,
    pub max_age: Option<u32>,
    pub s_maxage: Option<u32>,
    pub stale_while_revalidate: Option<u32>,
    pub must_revalidate: bool,
    pub vary: Vec<String>,
}

impl CachePolicy {
    pub fn no_store() -> Self;
    pub fn private_cache(max_age: u32) -> Self;
    pub fn public_cache(max_age: u32) -> Self;
    pub fn stale_while_revalidate(max_age: u32, stale: u32) -> Self;

    pub fn to_header_value(&self) -> String;
}

pub struct CacheLayer {
    policy: CachePolicy,
}

impl CacheLayer {
    pub fn new(policy: CachePolicy) -> Self;
}

impl<S> tower::Layer<S> for CacheLayer {
    type Service = CacheService<S>;
    fn layer(&self, inner: S) -> Self::Service;
}

pub struct CacheService<S> {
    inner: S,
    policy: CachePolicy,
}

impl<S> CacheService<S> {
    fn add_cache_headers(&self, response: &mut Response<Body>);
    fn handle_conditional(&self, request: &Request, etag: &str) -> Option<Response<Body>>;
}

pub fn calculate_etag(content: &[u8]) -> String;
pub fn weak_etag(content: &[u8]) -> String;
pub fn parse_if_none_match(header: &str) -> Vec<String>;
pub fn etags_match(client_etag: &str, server_etag: &str) -> bool;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Hierarchie de Cache

```
Browser Cache (local)
    ↓
CDN/Edge Cache (CloudFlare, etc.)
    ↓
Reverse Proxy Cache (nginx, Varnish)
    ↓
Application Cache (Redis)
    ↓
Origin Server
```

### 2.2 no-cache vs no-store

- **no-cache** : Peut cacher, mais DOIT revalider avant utilisation
- **no-store** : Ne JAMAIS cacher (donnees sensibles)

Erreur commune : utiliser no-cache pour empecher le caching (utilisez no-store).

### 2.3 ETag Types

- **Strong ETag** : `"abc123"` - Byte-for-byte identical
- **Weak ETag** : `W/"abc123"` - Semantically equivalent

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 14 tests
test tests::test_no_store_policy ... ok
test tests::test_public_cache ... ok
test tests::test_private_cache ... ok
test tests::test_max_age ... ok
test tests::test_stale_while_revalidate ... ok
test tests::test_etag_calculation ... ok
test tests::test_weak_etag ... ok
test tests::test_if_none_match ... ok
test tests::test_304_response ... ok
test tests::test_vary_header ... ok
test tests::test_multiple_directives ... ok
test tests::test_etag_matching ... ok
test tests::test_cache_header_format ... ok
test tests::test_conditional_request ... ok

test result: ok. 14 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `no_store_format` | no_store() | "no-store" | 5 | Basic |
| `public_cache` | public_cache(3600) | "public, max-age=3600" | 10 | Core |
| `private_cache` | private_cache(300) | "private, max-age=300" | 10 | Core |
| `stale_while` | stale(3600, 60) | "...stale-while-revalidate=60" | 10 | Advanced |
| `etag_calc` | content bytes | Strong ETag | 10 | ETag |
| `weak_etag` | content bytes | W/"..." | 5 | ETag |
| `304_response` | Matching ETag | 304 Not Modified | 15 | Conditional |
| `vary_header` | vary: ["Accept"] | Vary: Accept | 10 | Headers |
| `multiple_vary` | vary: ["Accept", "Encoding"] | Vary: Accept, Encoding | 5 | Headers |
| `etag_match_strong` | "abc" vs "abc" | true | 5 | Matching |
| `etag_match_weak` | W/"a" vs W/"a" | true | 5 | Matching |
| `integration` | Full flow | Works | 10 | Integration |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_no_store_policy() {
        let policy = CachePolicy::no_store();
        assert_eq!(policy.to_header_value(), "no-store");
    }

    #[test]
    fn test_public_cache() {
        let policy = CachePolicy::public_cache(3600);
        let header = policy.to_header_value();

        assert!(header.contains("public"));
        assert!(header.contains("max-age=3600"));
    }

    #[test]
    fn test_private_cache() {
        let policy = CachePolicy::private_cache(300);
        let header = policy.to_header_value();

        assert!(header.contains("private"));
        assert!(!header.contains("public"));
    }

    #[test]
    fn test_stale_while_revalidate() {
        let policy = CachePolicy::stale_while_revalidate(3600, 60);
        let header = policy.to_header_value();

        assert!(header.contains("max-age=3600"));
        assert!(header.contains("stale-while-revalidate=60"));
    }

    #[test]
    fn test_etag_calculation() {
        let content = b"Hello, World!";
        let etag = calculate_etag(content);

        assert!(etag.starts_with('"'));
        assert!(etag.ends_with('"'));

        // Same content = same ETag
        let etag2 = calculate_etag(content);
        assert_eq!(etag, etag2);

        // Different content = different ETag
        let etag3 = calculate_etag(b"Different");
        assert_ne!(etag, etag3);
    }

    #[test]
    fn test_weak_etag() {
        let content = b"Hello";
        let etag = weak_etag(content);

        assert!(etag.starts_with("W/\""));
    }

    #[test]
    fn test_parse_if_none_match() {
        let header = r#""abc", "def", W/"ghi""#;
        let etags = parse_if_none_match(header);

        assert_eq!(etags.len(), 3);
        assert!(etags.contains(&"\"abc\"".to_string()));
    }

    #[test]
    fn test_etag_matching() {
        // Strong match
        assert!(etags_match("\"abc\"", "\"abc\""));
        assert!(!etags_match("\"abc\"", "\"def\""));

        // Weak match
        assert!(etags_match("W/\"abc\"", "W/\"abc\""));

        // Wildcard
        assert!(etags_match("*", "\"anything\""));
    }

    #[test]
    fn test_vary_header() {
        let mut policy = CachePolicy::public_cache(3600);
        policy.vary = vec!["Accept".to_string(), "Accept-Encoding".to_string()];

        // Vary should be separate header, not in Cache-Control
        assert!(policy.vary.len() == 2);
    }
}
```

### 4.3 Solution de reference

```rust
use sha2::{Sha256, Digest};
use base64::{Engine, engine::general_purpose::STANDARD};

impl CachePolicy {
    pub fn no_store() -> Self {
        Self {
            no_store: true,
            ..Default::default()
        }
    }

    pub fn private_cache(max_age: u32) -> Self {
        Self {
            private: true,
            max_age: Some(max_age),
            ..Default::default()
        }
    }

    pub fn public_cache(max_age: u32) -> Self {
        Self {
            public: true,
            max_age: Some(max_age),
            ..Default::default()
        }
    }

    pub fn stale_while_revalidate(max_age: u32, stale: u32) -> Self {
        Self {
            public: true,
            max_age: Some(max_age),
            stale_while_revalidate: Some(stale),
            ..Default::default()
        }
    }

    pub fn to_header_value(&self) -> String {
        let mut parts = Vec::new();

        if self.no_store {
            parts.push("no-store".to_string());
        }
        if self.no_cache {
            parts.push("no-cache".to_string());
        }
        if self.public {
            parts.push("public".to_string());
        }
        if self.private {
            parts.push("private".to_string());
        }
        if let Some(max_age) = self.max_age {
            parts.push(format!("max-age={}", max_age));
        }
        if let Some(s_maxage) = self.s_maxage {
            parts.push(format!("s-maxage={}", s_maxage));
        }
        if let Some(stale) = self.stale_while_revalidate {
            parts.push(format!("stale-while-revalidate={}", stale));
        }
        if self.must_revalidate {
            parts.push("must-revalidate".to_string());
        }

        parts.join(", ")
    }
}

pub fn calculate_etag(content: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(content);
    let hash = hasher.finalize();
    let b64 = STANDARD.encode(&hash[..16]);  // Use first 16 bytes
    format!("\"{}\"", b64)
}

pub fn weak_etag(content: &[u8]) -> String {
    let strong = calculate_etag(content);
    format!("W/{}", strong)
}

pub fn parse_if_none_match(header: &str) -> Vec<String> {
    header
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect()
}

pub fn etags_match(client_etag: &str, server_etag: &str) -> bool {
    if client_etag == "*" {
        return true;
    }

    // Strip W/ prefix for weak comparison
    let client_clean = client_etag.trim_start_matches("W/");
    let server_clean = server_etag.trim_start_matches("W/");

    client_clean == server_clean
}

impl<S, ReqBody> Service<Request<ReqBody>> for CacheService<S>
where
    S: Service<Request<ReqBody>, Response = Response<Body>>,
{
    fn call(&mut self, request: Request<ReqBody>) -> Self::Future {
        let if_none_match = request
            .headers()
            .get(header::IF_NONE_MATCH)
            .and_then(|v| v.to_str().ok())
            .map(|s| s.to_string());

        // ... handle request, check conditional, add headers
    }
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Cache public de donnees privees */
pub fn for_user_data() -> CachePolicy {
    CachePolicy::public_cache(3600)  // MUTANT: Should be private
}
// Pourquoi c'est faux : CDN cache des donnees utilisateur

/* Mutant B : ETag non deterministe */
pub fn calculate_etag(_content: &[u8]) -> String {
    format!("\"{}\"", uuid::Uuid::new_v4())  // MUTANT: Random
}
// Pourquoi c'est faux : Meme contenu = ETags differents, jamais de 304

/* Mutant C : no-cache au lieu de no-store */
pub fn for_sensitive_data() -> CachePolicy {
    Self { no_cache: true, ..Default::default() }  // MUTANT: Should be no_store
}
// Pourquoi c'est faux : no-cache peut encore stocker

/* Mutant D : Vary manquant */
fn add_cache_headers(&self, response: &mut Response<Body>) {
    // MUTANT: N'ajoute pas Vary
    response.headers_mut().insert(
        header::CACHE_CONTROL,
        self.policy.to_header_value().parse().unwrap(),
    );
}
// Pourquoi c'est faux : Cache corruption avec Accept-Encoding variable

/* Mutant E : ETag match toujours vrai */
pub fn etags_match(_client: &str, _server: &str) -> bool {
    true  // MUTANT
}
// Pourquoi c'est faux : 304 retourne pour contenu different
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Cache-Control directives** : Semantic et combinaisons
2. **ETags** : Generation et validation
3. **Conditional requests** : If-None-Match, 304
4. **Vary header** : Content negotiation caching

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Public for private | Data leak via CDN | Use private |
| 2 | Random ETag | Never 304 | Hash-based |
| 3 | no-cache vs no-store | Still cached | Use no-store |
| 4 | Missing Vary | Wrong content cached | Add Vary |
| 5 | Bad ETag match | Wrong 304s | Proper comparison |

---

## SECTION 7 : QCM

### Question 1
**Quelle directive empeche TOUT caching ?**

A) no-cache
B) no-store
C) private
D) must-revalidate

**Reponse : B**

---

### Question 2
**Que signifie un status 304 ?**

A) Contenu modifie
B) Contenu non modifie
C) Erreur cache
D) Cache expire

**Reponse : B**

---

### Question 3
**A quoi sert le header Vary ?**

A) Varier la reponse
B) Indiquer les headers qui affectent le cache
C) Definir la variation max
D) Alternative au ETag

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | cache_control |
| **Module** | 5.3.16 - HTTP Caching |
| **Difficulte** | 6/10 |
| **XP** | 150 |
| **Concepts cles** | Cache-Control, ETag, 304 |
| **Piege principal** | public vs private confusion |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.16-a-cache-control",
    "metadata": {
      "exercise_id": "5.3.16-a",
      "exercise_name": "cache_control",
      "difficulty": 6,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "The best request is one you don't make"*
*Exercise Quality Score: 95/100*
