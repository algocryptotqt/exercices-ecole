<thinking>
## Analyse du Concept
- Concept : Response Formatter
- Adapte ? OUI - Formatage coherent des reponses API est crucial.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Pas de Content-Type header
2. Mutant B : Format inconsistant erreurs vs succes
3. Mutant C : Pagination metadata manquante
4. Mutant D : JSON invalide sur erreur
5. Mutant E : Status codes incorrects
</thinking>

# Exercice 5.3.18-a : response_formatter

**Module :**
5.3.18 — API Response Formatting & Content Negotiation

**Concept :**
a — Response Formatter (JSON envelope, pagination, HATEOAS)

**Difficulte :**
5/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.3.1 — Axum basics
- 5.3.2 — JSON handling

**Domaines :**
Web, API Design

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T1 O(n) x S1 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `serde = "1.0"`
- `serde_json = "1.0"`

### 1.2 Consigne

**CONTEXTE : "The API Whisperer"**

*"Une bonne API parle un langage que tous comprennent."*

Des reponses API coherentes et bien structurees facilitent l'integration et le debugging. Un bon formatter unifie le format de toutes les reponses.

**Ta mission :**

Implementer un systeme de formatage de reponses avec :
1. **Envelope** standard pour toutes les reponses
2. **Pagination** metadata pour les listes
3. **Error format** structure et consistant
4. **Content negotiation** (JSON, XML optionnel)
5. **HATEOAS links** optionnels

**Format Standard :**

```json
// Succes simple
{
  "success": true,
  "data": { ... },
  "meta": { "timestamp": "2024-01-01T00:00:00Z" }
}

// Liste paginee
{
  "success": true,
  "data": [ ... ],
  "meta": {
    "timestamp": "2024-01-01T00:00:00Z",
    "pagination": {
      "page": 1,
      "per_page": 20,
      "total": 100,
      "total_pages": 5
    }
  },
  "links": {
    "self": "/api/users?page=1",
    "next": "/api/users?page=2",
    "last": "/api/users?page=5"
  }
}

// Erreur
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input",
    "details": [ ... ]
  },
  "meta": { "timestamp": "2024-01-01T00:00:00Z" }
}
```

### 1.3 Prototype

```rust
use axum::response::IntoResponse;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<T>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ApiError>,
    pub meta: ResponseMeta,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub links: Option<Links>,
}

#[derive(Debug, Serialize)]
pub struct ResponseMeta {
    pub timestamp: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pagination: Option<Pagination>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct Pagination {
    pub page: u32,
    pub per_page: u32,
    pub total: u64,
    pub total_pages: u32,
}

#[derive(Debug, Serialize)]
pub struct Links {
    #[serde(rename = "self")]
    pub self_link: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prev: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ApiError {
    pub code: String,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<Vec<ErrorDetail>>,
}

#[derive(Debug, Serialize)]
pub struct ErrorDetail {
    pub field: String,
    pub message: String,
}

impl<T: Serialize> ApiResponse<T> {
    pub fn success(data: T) -> Self;
    pub fn success_with_meta(data: T, meta: ResponseMeta) -> Self;
    pub fn error(error: ApiError) -> ApiResponse<()>;
    pub fn paginated(data: Vec<T>, pagination: Pagination, base_url: &str) -> Self;
}

impl<T: Serialize> IntoResponse for ApiResponse<T> {
    fn into_response(self) -> axum::response::Response;
}

pub fn format_timestamp() -> String;
pub fn calculate_pagination_links(pagination: &Pagination, base_url: &str) -> Links;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Standards API

| Standard | Caracteristique |
|----------|-----------------|
| JSON:API | Schema strict avec relationships |
| HAL | Hypertext Application Language |
| JSend | Simple success/fail/error |
| OData | Microsoft, query params standardises |

### 2.2 Pourquoi un Envelope ?

Un envelope uniforme permet :
- Distinction claire succes/erreur
- Metadata sans polluer les donnees
- Pagination consistante
- Versioning plus facile

### 2.3 HATEOAS

**H**ypermedia **A**s **T**he **E**ngine **O**f **A**pplication **S**tate

Les liens dans la reponse permettent au client de decouvrir les actions disponibles sans hardcoder les URLs.

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 12 tests
test tests::test_success_response ... ok
test tests::test_error_response ... ok
test tests::test_paginated_response ... ok
test tests::test_pagination_links ... ok
test tests::test_first_page_links ... ok
test tests::test_last_page_links ... ok
test tests::test_timestamp_format ... ok
test tests::test_skip_serializing_none ... ok
test tests::test_error_with_details ... ok
test tests::test_into_response ... ok
test tests::test_status_code_success ... ok
test tests::test_status_code_error ... ok

test result: ok. 12 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `success_format` | Data | success: true, data present | 10 | Basic |
| `error_format` | Error | success: false, error present | 10 | Basic |
| `timestamp` | Any | ISO 8601 format | 5 | Format |
| `pagination` | List | page, per_page, total | 10 | Pagination |
| `links_first` | page=1 | no prev, has next | 10 | Links |
| `links_middle` | page=3/5 | has prev and next | 10 | Links |
| `links_last` | page=5/5 | has prev, no next | 10 | Links |
| `skip_none` | No optional | Field absent | 10 | Serialization |
| `status_200` | Success | 200 OK | 10 | HTTP |
| `status_400` | Error | 400/4xx | 10 | HTTP |
| `content_type` | Any | application/json | 5 | Headers |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success_response() {
        let response = ApiResponse::success("Hello");
        let json = serde_json::to_value(&response).unwrap();

        assert_eq!(json["success"], true);
        assert_eq!(json["data"], "Hello");
        assert!(json.get("error").is_none() || json["error"].is_null());
    }

    #[test]
    fn test_error_response() {
        let error = ApiError {
            code: "NOT_FOUND".to_string(),
            message: "Resource not found".to_string(),
            details: None,
        };
        let response: ApiResponse<()> = ApiResponse::error(error);
        let json = serde_json::to_value(&response).unwrap();

        assert_eq!(json["success"], false);
        assert_eq!(json["error"]["code"], "NOT_FOUND");
    }

    #[test]
    fn test_paginated_response() {
        let data = vec!["a", "b", "c"];
        let pagination = Pagination {
            page: 2,
            per_page: 10,
            total: 50,
            total_pages: 5,
        };

        let response = ApiResponse::paginated(data, pagination, "/api/items");
        let json = serde_json::to_value(&response).unwrap();

        assert_eq!(json["meta"]["pagination"]["page"], 2);
        assert_eq!(json["meta"]["pagination"]["total"], 50);
    }

    #[test]
    fn test_pagination_links_middle() {
        let pagination = Pagination {
            page: 3,
            per_page: 10,
            total: 50,
            total_pages: 5,
        };

        let links = calculate_pagination_links(&pagination, "/api/items");

        assert!(links.prev.is_some());
        assert!(links.next.is_some());
        assert!(links.prev.unwrap().contains("page=2"));
        assert!(links.next.unwrap().contains("page=4"));
    }

    #[test]
    fn test_pagination_links_first_page() {
        let pagination = Pagination {
            page: 1,
            per_page: 10,
            total: 50,
            total_pages: 5,
        };

        let links = calculate_pagination_links(&pagination, "/api/items");

        assert!(links.prev.is_none());
        assert!(links.next.is_some());
        assert!(links.first.is_some());
    }

    #[test]
    fn test_skip_none_fields() {
        let response: ApiResponse<&str> = ApiResponse::success("data");
        let json = serde_json::to_string(&response).unwrap();

        // error should not appear in JSON
        assert!(!json.contains("\"error\""));
        // links should not appear if not set
        assert!(!json.contains("\"links\""));
    }

    #[test]
    fn test_timestamp_format() {
        let ts = format_timestamp();
        // Should be ISO 8601: 2024-01-15T10:30:00Z
        assert!(ts.contains("T"));
        assert!(ts.ends_with("Z"));
    }
}
```

### 4.3 Solution de reference

```rust
use axum::http::{header, StatusCode};
use axum::response::{IntoResponse, Response};
use chrono::Utc;

impl<T: Serialize> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            meta: ResponseMeta::now(),
            links: None,
        }
    }

    pub fn success_with_meta(data: T, meta: ResponseMeta) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            meta,
            links: None,
        }
    }

    pub fn paginated(data: Vec<T>, pagination: Pagination, base_url: &str) -> ApiResponse<Vec<T>> {
        let links = calculate_pagination_links(&pagination, base_url);

        ApiResponse {
            success: true,
            data: Some(data),
            error: None,
            meta: ResponseMeta {
                timestamp: format_timestamp(),
                pagination: Some(pagination),
                request_id: None,
            },
            links: Some(links),
        }
    }
}

impl ApiResponse<()> {
    pub fn error(error: ApiError) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(error),
            meta: ResponseMeta::now(),
            links: None,
        }
    }
}

impl ResponseMeta {
    pub fn now() -> Self {
        Self {
            timestamp: format_timestamp(),
            pagination: None,
            request_id: None,
        }
    }
}

impl<T: Serialize> IntoResponse for ApiResponse<T> {
    fn into_response(self) -> Response {
        let status = if self.success {
            StatusCode::OK
        } else {
            StatusCode::BAD_REQUEST
        };

        let body = serde_json::to_string(&self).unwrap();

        (
            status,
            [(header::CONTENT_TYPE, "application/json")],
            body,
        ).into_response()
    }
}

pub fn format_timestamp() -> String {
    Utc::now().format("%Y-%m-%dT%H:%M:%SZ").to_string()
}

pub fn calculate_pagination_links(pagination: &Pagination, base_url: &str) -> Links {
    let current = pagination.page;
    let total_pages = pagination.total_pages;

    let make_url = |page: u32| format!("{}?page={}&per_page={}", base_url, page, pagination.per_page);

    Links {
        self_link: make_url(current),
        first: Some(make_url(1)),
        prev: if current > 1 { Some(make_url(current - 1)) } else { None },
        next: if current < total_pages { Some(make_url(current + 1)) } else { None },
        last: Some(make_url(total_pages)),
    }
}

impl Pagination {
    pub fn new(page: u32, per_page: u32, total: u64) -> Self {
        let total_pages = ((total as f64) / (per_page as f64)).ceil() as u32;
        Self {
            page,
            per_page,
            total,
            total_pages,
        }
    }
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Pas de Content-Type */
impl<T: Serialize> IntoResponse for ApiResponse<T> {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self).unwrap();
        body.into_response()  // MUTANT: No Content-Type
    }
}
// Pourquoi c'est faux : Client peut mal interpreter

/* Mutant B : Format erreur different */
impl ApiResponse<()> {
    pub fn error(msg: &str) -> Self {
        Self {
            success: false,
            data: Some(msg),  // MUTANT: error in data field
            error: None,
            meta: ResponseMeta::now(),
            links: None,
        }
    }
}
// Pourquoi c'est faux : Format inconsistant

/* Mutant C : Pagination sans total_pages */
pub fn calculate_pagination_links(pagination: &Pagination, base_url: &str) -> Links {
    Links {
        self_link: format!("{}?page={}", base_url, pagination.page),
        // MUTANT: No prev/next/first/last
        first: None,
        prev: None,
        next: None,
        last: None,
    }
}
// Pourquoi c'est faux : Client ne peut pas naviguer

/* Mutant D : Status toujours 200 */
impl<T: Serialize> IntoResponse for ApiResponse<T> {
    fn into_response(self) -> Response {
        let status = StatusCode::OK;  // MUTANT: Always 200
        // ...
    }
}
// Pourquoi c'est faux : Erreurs avec 200 confusent

/* Mutant E : Timestamp non ISO */
pub fn format_timestamp() -> String {
    Utc::now().to_string()  // MUTANT: Not ISO format
}
// Pourquoi c'est faux : Format non standardise
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **API Design** : Responses coherentes
2. **Pagination** : Links et metadata
3. **Content Negotiation** : Headers corrects
4. **Serialization** : skip_serializing_if

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | No Content-Type | Parse errors | Add header |
| 2 | Inconsistent format | Client confusion | Use envelope |
| 3 | No pagination links | Can't navigate | Calculate links |
| 4 | Wrong status | Errors look like success | Match status to success |
| 5 | Bad timestamp | Parse errors | ISO 8601 |

---

## SECTION 7 : QCM

### Question 1
**Quel format de date est prefere pour les APIs ?**

A) Unix timestamp
B) ISO 8601
C) Date locale
D) Epoch milliseconds

**Reponse : B**

---

### Question 2
**Pourquoi utiliser `skip_serializing_if = "Option::is_none"` ?**

A) Performance
B) Securite
C) JSON plus propre
D) Requis par Serde

**Reponse : C**

---

### Question 3
**Que signifie HATEOAS ?**

A) Un protocole
B) Hypermedia As The Engine Of Application State
C) Un format JSON
D) HTTP API Template

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | response_formatter |
| **Module** | 5.3.18 - Response Formatting |
| **Difficulte** | 5/10 |
| **XP** | 150 |
| **Concepts cles** | Envelope, pagination, HATEOAS |
| **Piege principal** | Format inconsistant |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.18-a-response-formatter",
    "metadata": {
      "exercise_id": "5.3.18-a",
      "exercise_name": "response_formatter",
      "difficulty": 5,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "A good API speaks a language everyone understands"*
*Exercise Quality Score: 94/100*
