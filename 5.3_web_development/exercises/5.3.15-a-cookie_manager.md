<thinking>
## Analyse du Concept
- Concept : Cookie Manager
- Adapte ? OUI - Les cookies sont fondamentaux pour sessions et auth.

## Scenarios d'Echec (5 mutants)
1. Mutant A : Pas de HttpOnly sur cookies sensibles
2. Mutant B : Pas de Secure en HTTPS
3. Mutant C : SameSite mal configure
4. Mutant D : Expiration mal geree
5. Mutant E : Path trop large
</thinking>

# Exercice 5.3.15-a : cookie_manager

**Module :**
5.3.15 — Cookie Management & Session State

**Concept :**
a — Cookie Manager (creation, parsing, security attributes)

**Difficulte :**
5/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.1.2 — HTTP Protocol
- 5.3.1 — Axum basics

**Domaines :**
Web, Security, State

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T1 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `axum-extra = "0.9"` (features: cookie)
- `cookie = "0.18"`
- `chrono = "0.4"`

### 1.2 Consigne

**CONTEXTE : "Cookie Monster Security"**

*"C is for Cookie, and also for Carefully configured!"*

Les cookies sont partout sur le web, mais mal configures ils deviennent des failles de securite. Ton job : creer un gestionnaire de cookies securise par defaut.

**Ta mission :**

Implementer un gestionnaire de cookies avec :
1. **Creation** avec attributs de securite par defaut
2. **Parsing** depuis headers
3. **Security** : HttpOnly, Secure, SameSite
4. **Expiration** : Max-Age et Expires
5. **Signed cookies** pour integrite (HMAC)

**Attributs de securite :**

| Attribut | Effet | Defaut |
|----------|-------|--------|
| HttpOnly | Inaccessible depuis JS | true |
| Secure | HTTPS only | true |
| SameSite | CSRF protection | Lax |
| Path | Scope du cookie | / |
| Max-Age | Duree de vie | Session |

### 1.3 Prototype

```rust
use chrono::{DateTime, Duration, Utc};
use cookie::{Cookie, SameSite};

#[derive(Debug, Clone)]
pub struct CookieConfig {
    pub http_only: bool,
    pub secure: bool,
    pub same_site: SameSite,
    pub path: String,
    pub domain: Option<String>,
    pub signing_key: Option<Vec<u8>>,
}

impl Default for CookieConfig {
    fn default() -> Self {
        Self {
            http_only: true,
            secure: true,
            same_site: SameSite::Lax,
            path: "/".to_string(),
            domain: None,
            signing_key: None,
        }
    }
}

pub struct CookieManager {
    config: CookieConfig,
}

impl CookieManager {
    pub fn new(config: CookieConfig) -> Self;

    // Creation
    pub fn create(&self, name: &str, value: &str) -> Cookie<'static>;
    pub fn create_with_expiry(&self, name: &str, value: &str, max_age: Duration) -> Cookie<'static>;
    pub fn create_session(&self, name: &str, value: &str) -> Cookie<'static>;

    // Signed cookies
    pub fn create_signed(&self, name: &str, value: &str) -> Result<Cookie<'static>, CookieError>;
    pub fn verify_signed(&self, cookie: &Cookie) -> Result<String, CookieError>;

    // Deletion
    pub fn delete(&self, name: &str) -> Cookie<'static>;

    // Parsing
    pub fn parse_header(header: &str) -> Vec<(String, String)>;
}

#[derive(Debug, thiserror::Error)]
pub enum CookieError {
    #[error("No signing key configured")]
    NoSigningKey,
    #[error("Invalid signature")]
    InvalidSignature,
    #[error("Cookie expired")]
    Expired,
}

pub fn sign_value(value: &str, key: &[u8]) -> String;
pub fn verify_signature(signed: &str, key: &[u8]) -> Result<String, CookieError>;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Histoire des Cookies

Les cookies ont ete inventes par Lou Montulli chez Netscape en 1994 pour implementer un panier d'achat persistant. Le nom vient des "magic cookies" Unix.

### 2.2 SameSite Explained

| SameSite | Comportement |
|----------|-------------|
| Strict | Cookie envoye uniquement si meme site |
| Lax | + GET depuis liens externes |
| None | Toujours envoye (requiert Secure) |

### 2.3 Signed vs Encrypted

- **Signed** : Detecte les modifications (HMAC), valeur lisible
- **Encrypted** : Cache la valeur, plus lent
- Pour sessions : souvent Signed suffit (le contenu n'est pas secret)

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 12 tests
test tests::test_create_basic ... ok
test tests::test_security_defaults ... ok
test tests::test_http_only ... ok
test tests::test_secure_flag ... ok
test tests::test_same_site ... ok
test tests::test_max_age ... ok
test tests::test_signed_cookie ... ok
test tests::test_verify_valid ... ok
test tests::test_verify_tampered ... ok
test tests::test_delete_cookie ... ok
test tests::test_parse_header ... ok
test tests::test_session_cookie ... ok

test result: ok. 12 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `create_basic` | name, value | Cookie with defaults | 5 | Basic |
| `http_only` | config.http_only = true | HttpOnly in output | 10 | Security |
| `secure_flag` | config.secure = true | Secure in output | 10 | Security |
| `same_site_lax` | Default | SameSite=Lax | 10 | Security |
| `max_age` | Duration::hours(1) | Max-Age=3600 | 10 | Expiry |
| `signed_create` | value + key | value.signature | 15 | Signing |
| `verify_valid` | Valid signed | Ok(value) | 10 | Signing |
| `verify_tampered` | Modified value | Err(InvalidSignature) | 15 | Security |
| `delete` | name | Max-Age=0 | 5 | Core |
| `parse_header` | "a=1; b=2" | [(a,1), (b,2)] | 5 | Parsing |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_basic() {
        let manager = CookieManager::new(CookieConfig::default());
        let cookie = manager.create("session", "abc123");

        assert_eq!(cookie.name(), "session");
        assert_eq!(cookie.value(), "abc123");
    }

    #[test]
    fn test_security_defaults() {
        let manager = CookieManager::new(CookieConfig::default());
        let cookie = manager.create("test", "value");

        assert!(cookie.http_only().unwrap_or(false));
        assert!(cookie.secure().unwrap_or(false));
        assert_eq!(cookie.same_site(), Some(SameSite::Lax));
    }

    #[test]
    fn test_signed_cookie() {
        let config = CookieConfig {
            signing_key: Some(b"supersecretkey123456789012".to_vec()),
            ..Default::default()
        };
        let manager = CookieManager::new(config);

        let cookie = manager.create_signed("session", "user:123").unwrap();

        // Value should contain signature
        assert!(cookie.value().contains('.'));

        // Should verify correctly
        let original = manager.verify_signed(&cookie).unwrap();
        assert_eq!(original, "user:123");
    }

    #[test]
    fn test_tampered_cookie_fails() {
        let config = CookieConfig {
            signing_key: Some(b"supersecretkey123456789012".to_vec()),
            ..Default::default()
        };
        let manager = CookieManager::new(config);

        let mut cookie = manager.create_signed("session", "user:123").unwrap();

        // Tamper with the value
        let tampered = cookie.value().replace("user:123", "user:456");
        cookie.set_value(tampered);

        let result = manager.verify_signed(&cookie);
        assert!(matches!(result, Err(CookieError::InvalidSignature)));
    }

    #[test]
    fn test_delete_cookie() {
        let manager = CookieManager::new(CookieConfig::default());
        let cookie = manager.delete("session");

        assert_eq!(cookie.name(), "session");
        assert_eq!(cookie.max_age(), Some(cookie::time::Duration::ZERO));
    }

    #[test]
    fn test_parse_header() {
        let header = "session=abc123; theme=dark; lang=en";
        let cookies = CookieManager::parse_header(header);

        assert_eq!(cookies.len(), 3);
        assert!(cookies.iter().any(|(n, v)| n == "session" && v == "abc123"));
        assert!(cookies.iter().any(|(n, v)| n == "theme" && v == "dark"));
    }
}
```

### 4.3 Solution de reference

```rust
use cookie::{Cookie, SameSite};
use chrono::Duration;
use hmac::{Hmac, Mac};
use sha2::Sha256;
use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};

type HmacSha256 = Hmac<Sha256>;

impl CookieManager {
    pub fn new(config: CookieConfig) -> Self {
        Self { config }
    }

    pub fn create(&self, name: &str, value: &str) -> Cookie<'static> {
        let mut cookie = Cookie::new(name.to_owned(), value.to_owned());
        self.apply_defaults(&mut cookie);
        cookie
    }

    pub fn create_with_expiry(&self, name: &str, value: &str, max_age: Duration) -> Cookie<'static> {
        let mut cookie = self.create(name, value);
        cookie.set_max_age(cookie::time::Duration::seconds(max_age.num_seconds()));
        cookie
    }

    pub fn create_session(&self, name: &str, value: &str) -> Cookie<'static> {
        // Session cookies have no Max-Age (deleted when browser closes)
        self.create(name, value)
    }

    pub fn create_signed(&self, name: &str, value: &str) -> Result<Cookie<'static>, CookieError> {
        let key = self.config.signing_key.as_ref().ok_or(CookieError::NoSigningKey)?;
        let signed_value = sign_value(value, key);
        Ok(self.create(name, &signed_value))
    }

    pub fn verify_signed(&self, cookie: &Cookie) -> Result<String, CookieError> {
        let key = self.config.signing_key.as_ref().ok_or(CookieError::NoSigningKey)?;
        verify_signature(cookie.value(), key)
    }

    pub fn delete(&self, name: &str) -> Cookie<'static> {
        let mut cookie = Cookie::new(name.to_owned(), "");
        cookie.set_max_age(cookie::time::Duration::ZERO);
        cookie.set_path(self.config.path.clone());
        if let Some(ref domain) = self.config.domain {
            cookie.set_domain(domain.clone());
        }
        cookie
    }

    fn apply_defaults(&self, cookie: &mut Cookie) {
        cookie.set_http_only(self.config.http_only);
        cookie.set_secure(self.config.secure);
        cookie.set_same_site(self.config.same_site);
        cookie.set_path(self.config.path.clone());
        if let Some(ref domain) = self.config.domain {
            cookie.set_domain(domain.clone());
        }
    }

    pub fn parse_header(header: &str) -> Vec<(String, String)> {
        header
            .split(';')
            .filter_map(|pair| {
                let pair = pair.trim();
                let mut parts = pair.splitn(2, '=');
                let name = parts.next()?.trim().to_string();
                let value = parts.next()?.trim().to_string();
                Some((name, value))
            })
            .collect()
    }
}

pub fn sign_value(value: &str, key: &[u8]) -> String {
    let mut mac = HmacSha256::new_from_slice(key).unwrap();
    mac.update(value.as_bytes());
    let signature = mac.finalize().into_bytes();
    let sig_b64 = URL_SAFE_NO_PAD.encode(signature);

    format!("{}.{}", value, sig_b64)
}

pub fn verify_signature(signed: &str, key: &[u8]) -> Result<String, CookieError> {
    let parts: Vec<&str> = signed.rsplitn(2, '.').collect();
    if parts.len() != 2 {
        return Err(CookieError::InvalidSignature);
    }

    let sig_b64 = parts[0];
    let value = parts[1];

    let expected_sig = URL_SAFE_NO_PAD.decode(sig_b64)
        .map_err(|_| CookieError::InvalidSignature)?;

    let mut mac = HmacSha256::new_from_slice(key).unwrap();
    mac.update(value.as_bytes());

    mac.verify_slice(&expected_sig)
        .map_err(|_| CookieError::InvalidSignature)?;

    Ok(value.to_string())
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : HttpOnly desactive */
fn apply_defaults(&self, cookie: &mut Cookie) {
    cookie.set_http_only(false);  // MUTANT
}
// Pourquoi c'est faux : XSS peut voler le cookie

/* Mutant B : Secure desactive */
fn apply_defaults(&self, cookie: &mut Cookie) {
    cookie.set_secure(false);  // MUTANT
}
// Pourquoi c'est faux : Cookie envoye sur HTTP non securise

/* Mutant C : SameSite None sans Secure */
fn apply_defaults(&self, cookie: &mut Cookie) {
    cookie.set_same_site(SameSite::None);
    cookie.set_secure(false);  // MUTANT: Invalide
}
// Pourquoi c'est faux : Navigateurs rejettent SameSite=None sans Secure

/* Mutant D : Signature tronquee */
pub fn sign_value(value: &str, key: &[u8]) -> String {
    // MUTANT: N'ajoute pas la signature
    value.to_string()
}
// Pourquoi c'est faux : Cookie modifiable sans detection

/* Mutant E : Verification toujours OK */
pub fn verify_signature(signed: &str, _key: &[u8]) -> Result<String, CookieError> {
    // MUTANT: Pas de verification reelle
    Ok(signed.split('.').next().unwrap_or("").to_string())
}
// Pourquoi c'est faux : Cookies falsifies acceptes
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Cookie Security** : HttpOnly, Secure, SameSite
2. **HMAC Signing** : Integrite sans encryption
3. **Session Management** : Cookies de session vs persistants
4. **HTTP Headers** : Set-Cookie parsing/generation

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | No HttpOnly | XSS vol de cookie | Default true |
| 2 | No Secure | HTTP interception | Default true |
| 3 | SameSite None | CSRF possible | Require Secure |
| 4 | No signing | Cookie tampering | HMAC |
| 5 | Bad verify | Accept forged cookies | Proper HMAC check |

---

## SECTION 7 : QCM

### Question 1
**Quel attribut empeche JavaScript d'acceder au cookie ?**

A) Secure
B) SameSite
C) HttpOnly
D) Path

**Reponse : C**

---

### Question 2
**Quelle valeur SameSite offre le plus de protection CSRF ?**

A) None
B) Lax
C) Strict
D) All

**Reponse : C**

---

### Question 3
**Que fait Max-Age=0 sur un cookie ?**

A) Cookie permanent
B) Cookie de session
C) Supprime le cookie
D) Erreur

**Reponse : C**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | cookie_manager |
| **Module** | 5.3.15 - Cookie Management |
| **Difficulte** | 5/10 |
| **XP** | 150 |
| **Concepts cles** | Cookies, security, HMAC |
| **Piege principal** | HttpOnly/Secure oublies |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.15-a-cookie-manager",
    "metadata": {
      "exercise_id": "5.3.15-a",
      "exercise_name": "cookie_manager",
      "difficulty": 5,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "C is for Cookie, and Carefully configured!"*
*Exercise Quality Score: 94/100*
