<thinking>
## Analyse du Concept
- Concept : JWT Authentication System
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - L'authentification JWT est critique pour toute application web moderne. Combine cryptographie, securite, et patterns async.

## Combo Base + Bonus
- Exercice de base : Systeme auth complet avec Argon2, JWT access/refresh tokens, middleware
- Bonus : Implementation de OAuth2/OIDC provider avec PKCE
- Palier bonus : EXPERT (protocoles de securite avances)
- Progression logique ? OUI - Base = auth standalone, Bonus = federation d'identite

## Prerequis & Difficulte
- Prerequis reels : Async Rust, HTTP basics, cryptographie basique, Result/Option
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Forge" - Creation de tokens comme forger des cles magiques
- MEME mnemonique : "Trust no one, verify everything" (Zero Trust)
- Pourquoi c'est fun : Les tokens JWT sont comme des passeports numeriques

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Security) : Stockage du mot de passe en clair au lieu de hash
2. Mutant B (Timing) : Comparaison de hash avec == au lieu de constant-time
3. Mutant C (Logic) : Token refresh qui ne revoque pas l'ancien token
4. Mutant D (Expiry) : Pas de verification d'expiration du token
5. Mutant E (Secret) : Secret JWT expose dans les logs ou erreurs

## Verdict
VALIDE - Exercice de qualite industrielle couvrant l'authentification securisee
</thinking>

# Exercice 5.3.3-a : jwt_authentication

**Module :**
5.3.3 — Authentication & Security

**Concept :**
a — JWT Authentication System (Argon2, access/refresh tokens, middleware)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async Runtime (tokio)
- 2.4 — Gestion d'erreurs (Result, thiserror)
- 5.3.2 — REST API basics (Axum)
- Phase 0.0.S.1 — Securite basique (hashing, tokens)

**Domaines :**
Security, Web, Crypto

**Duree estimee :**
150 min

**XP Base :**
250

**Complexite :**
T2 O(1) x S1 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
src/auth.rs
src/middleware.rs
src/models.rs
src/errors.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `tokio = "1.0"` (features: full)
- `argon2 = "0.5"`
- `jsonwebtoken = "9.0"`
- `secrecy = "0.8"` (features: serde)
- `serde = "1.0"` (features: derive)
- `uuid = "1.0"` (features: v4, serde)
- `chrono = "0.4"` (features: serde)
- `thiserror = "2.0"`
- `rand = "0.8"`

**Fonctions/methodes interdites :**
- `unsafe` blocks
- Comparaison de hash avec `==` (utiliser constant-time)
- Stockage de mots de passe en clair
- Logging de secrets

### 1.2 Consigne

**CONTEXTE : "The Token Forge"**

*"Dans les anciennes forges, les maitres forgeaient des cles capables d'ouvrir n'importe quelle porte du royaume. Aujourd'hui, tu vas creer des tokens JWT - des cles numeriques qui authentifient les voyageurs du web. Mais attention : une cle mal forgee peut ouvrir les portes aux intrus."* — Le Gardien des Secrets

L'authentification est le pilier de la securite web. Les JSON Web Tokens (JWT) sont devenus le standard pour l'authentification stateless, permettant une scalabilite horizontale sans partage de session.

**Ta mission :**

Implementer un service d'authentification complet avec :

1. **Hachage de mots de passe** avec Argon2id (resistant aux attaques GPU)
2. **Generation de JWT** avec access tokens (courte duree) et refresh tokens (longue duree)
3. **Rotation de refresh tokens** avec detection de reutilisation
4. **Revocation de tokens** via blacklist de JTI
5. **Middleware d'authentification** pour proteger les routes
6. **Extracteur custom** `AuthUser` pour les handlers

**Endpoints requis :**

| Methode | Endpoint | Description | Auth |
|---------|----------|-------------|------|
| `POST` | `/auth/register` | Inscription | Non |
| `POST` | `/auth/login` | Connexion | Non |
| `POST` | `/auth/refresh` | Rafraichir tokens | Refresh token |
| `POST` | `/auth/logout` | Revoquer token | Access token |
| `POST` | `/auth/logout-all` | Revoquer tous tokens | Access token |
| `GET` | `/auth/me` | Profil utilisateur | Access token |
| `PUT` | `/auth/password` | Changer mot de passe | Access token |

**Contraintes de securite :**
- Argon2id avec : memory = 19456 KiB, iterations = 2, parallelism = 1
- Access token : expire en 15 minutes
- Refresh token : expire en 7 jours
- Secrets geres avec `secrecy` crate (jamais en clair dans les logs)
- Comparaison de hash en temps constant

**Exemples :**

| Requete | Reponse | Explication |
|---------|---------|-------------|
| `POST /auth/register` valide | `201` + user | Inscription reussie |
| `POST /auth/login` valide | `200` + tokens | Connexion reussie |
| `POST /auth/login` invalide | `401 Unauthorized` | Mauvais credentials |
| `GET /auth/me` sans token | `401 Unauthorized` | Token manquant |
| `GET /auth/me` token expire | `401 Unauthorized` | Token expire |

### 1.2.2 Consigne Academique

Implementer un systeme d'authentification JWT complet avec hachage securise des mots de passe (Argon2id), generation et validation de tokens access/refresh, rotation de tokens avec detection de reutilisation, et middleware d'authentification pour Axum.

### 1.3 Prototype

```rust
use axum::{
    async_trait,
    extract::{FromRequestParts, State},
    http::{request::Parts, StatusCode},
    response::IntoResponse,
    Json,
};
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use secrecy::{ExposeSecret, Secret};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

// === CONFIGURATION ===

#[derive(Clone)]
pub struct JwtConfig {
    pub access_secret: Secret<String>,
    pub refresh_secret: Secret<String>,
    pub access_expiry: Duration,   // 15 minutes
    pub refresh_expiry: Duration,  // 7 jours
    pub issuer: String,
}

// === CLAIMS ===

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AccessClaims {
    pub sub: Uuid,              // User ID
    pub email: String,
    pub roles: Vec<String>,
    pub exp: i64,               // Expiration timestamp
    pub iat: i64,               // Issued at
    pub iss: String,            // Issuer
    pub jti: Uuid,              // Token ID unique
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RefreshClaims {
    pub sub: Uuid,              // User ID
    pub exp: i64,
    pub iat: i64,
    pub jti: Uuid,              // Token ID
    pub family: Uuid,           // Family ID pour rotation detection
}

// === MODELS ===

#[derive(Debug, Clone, Serialize)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub password_hash: String,  // JAMAIS expose en JSON
    pub roles: Vec<String>,
    pub created_at: chrono::DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct RegisterInput {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Deserialize)]
pub struct LoginInput {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Serialize)]
pub struct TokenPair {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,     // "Bearer"
    pub expires_in: i64,        // Secondes
}

#[derive(Debug, Deserialize)]
pub struct RefreshInput {
    pub refresh_token: String,
}

#[derive(Debug, Deserialize)]
pub struct ChangePasswordInput {
    pub current_password: String,
    pub new_password: String,
}

// === ERRORS ===

#[derive(Debug, thiserror::Error)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    #[error("Token expired")]
    TokenExpired,
    #[error("Token invalid")]
    TokenInvalid,
    #[error("Token revoked")]
    TokenRevoked,
    #[error("User not found")]
    UserNotFound,
    #[error("Email already exists")]
    EmailExists,
    #[error("Weak password: {0}")]
    WeakPassword(String),
    #[error("Internal error")]
    InternalError,
}

impl IntoResponse for AuthError {
    fn into_response(self) -> axum::response::Response;
}

// === STATE ===

#[derive(Clone)]
pub struct AuthState {
    pub config: JwtConfig,
    pub users: Arc<RwLock<HashMap<Uuid, User>>>,
    pub users_by_email: Arc<RwLock<HashMap<String, Uuid>>>,
    pub revoked_tokens: Arc<RwLock<HashSet<Uuid>>>,  // JTI revoques
    pub refresh_families: Arc<RwLock<HashMap<Uuid, Uuid>>>, // family -> latest jti
}

// === SERVICE ===

impl AuthState {
    pub fn new(config: JwtConfig) -> Self;

    /// Hash un mot de passe avec Argon2id
    pub fn hash_password(&self, password: &str) -> Result<String, AuthError>;

    /// Verifie un mot de passe contre son hash (constant-time)
    pub fn verify_password(&self, password: &str, hash: &str) -> Result<(), AuthError>;

    /// Genere une paire de tokens pour un utilisateur
    pub fn generate_tokens(&self, user: &User) -> Result<TokenPair, AuthError>;

    /// Verifie et decode un access token
    pub fn verify_access_token(&self, token: &str) -> Result<AccessClaims, AuthError>;

    /// Verifie et decode un refresh token
    pub fn verify_refresh_token(&self, token: &str) -> Result<RefreshClaims, AuthError>;

    /// Rafraichit les tokens (rotation)
    pub async fn refresh_tokens(&self, refresh_token: &str) -> Result<TokenPair, AuthError>;

    /// Revoque un token specifique
    pub async fn revoke_token(&self, jti: Uuid) -> Result<(), AuthError>;

    /// Revoque tous les tokens d'un utilisateur
    pub async fn revoke_all_user_tokens(&self, user_id: Uuid) -> Result<(), AuthError>;

    /// Verifie si un token est revoque
    pub async fn is_token_revoked(&self, jti: Uuid) -> bool;
}

// === EXTRACTEUR CUSTOM ===

/// Extracteur pour routes protegees
pub struct AuthUser(pub AccessClaims);

#[async_trait]
impl<S> FromRequestParts<S> for AuthUser
where
    S: Send + Sync,
    AuthState: FromRef<S>,
{
    type Rejection = AuthError;

    async fn from_request_parts(
        parts: &mut Parts,
        state: &S,
    ) -> Result<Self, Self::Rejection>;
}

// === HANDLERS ===

pub async fn register(
    State(state): State<AuthState>,
    Json(input): Json<RegisterInput>,
) -> Result<(StatusCode, Json<User>), AuthError>;

pub async fn login(
    State(state): State<AuthState>,
    Json(input): Json<LoginInput>,
) -> Result<Json<TokenPair>, AuthError>;

pub async fn refresh(
    State(state): State<AuthState>,
    Json(input): Json<RefreshInput>,
) -> Result<Json<TokenPair>, AuthError>;

pub async fn logout(
    State(state): State<AuthState>,
    AuthUser(claims): AuthUser,
) -> Result<StatusCode, AuthError>;

pub async fn logout_all(
    State(state): State<AuthState>,
    AuthUser(claims): AuthUser,
) -> Result<StatusCode, AuthError>;

pub async fn me(
    State(state): State<AuthState>,
    AuthUser(claims): AuthUser,
) -> Result<Json<User>, AuthError>;

pub async fn change_password(
    State(state): State<AuthState>,
    AuthUser(claims): AuthUser,
    Json(input): Json<ChangePasswordInput>,
) -> Result<StatusCode, AuthError>;

// === ROUTER ===

pub fn create_auth_router(state: AuthState) -> axum::Router;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Pourquoi Argon2id ?

Argon2 a gagne le Password Hashing Competition en 2015. Il existe en trois variantes :
- **Argon2d** : Resistant aux attaques GPU, mais vulnerable aux side-channel
- **Argon2i** : Resistant aux side-channel, mais moins contre GPU
- **Argon2id** : Hybride, recommande pour le hachage de mots de passe

Les parametres recommandes (2023) : 19 MiB de memoire, 2 iterations, 1 thread.

### 2.2 Access vs Refresh Tokens

```
┌─────────────────────────────────────────────────────────────┐
│                    TOKEN LIFECYCLE                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Login ──► Access Token (15min) + Refresh Token (7 days)    │
│                │                         │                   │
│                │                         │                   │
│                ▼                         ▼                   │
│           API Calls                Token Refresh             │
│           (short-lived)            (rotate both)             │
│                                                              │
│  Pourquoi deux tokens ?                                      │
│  • Access : Court, stocke en memoire, revocation difficile   │
│  • Refresh : Long, stocke securise, peut etre revoque        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Rotation Detection

Si un refresh token est utilise deux fois, c'est une attaque potentielle (le token a ete vole). On revoque toute la "famille" de tokens :

```rust
// Family = tous les tokens issus du meme login
// Si refresh_token A genere B, et A est reutilise :
// -> Attaque detectee, revoquer A, B, et tous leurs descendants
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de l'auth JWT |
|--------|---------------------------|
| **Security Engineer** | Audit d'implementation, detection de failles |
| **Backend Developer** | Implementation et maintenance des systemes auth |
| **DevOps/SRE** | Rotation de secrets, monitoring des tokens |
| **Identity Architect** | Design de systemes SSO, federation |
| **Penetration Tester** | Test de vulnerabilites JWT (alg:none, secret weak) |

### Cas d'usage concrets

1. **SaaS Multi-tenant** : Auth centrale avec permissions par tenant
2. **Mobile Apps** : Tokens avec refresh pour session longue
3. **Microservices** : Propagation de contexte utilisateur
4. **API Gateway** : Validation centralisee des tokens

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
# Register
$ curl -X POST http://localhost:3000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "SecureP@ss123"}'
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "roles": ["user"],
  "created_at": "2024-01-15T10:00:00Z"
}

# Login
$ curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "SecureP@ss123"}'
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 900
}

# Access protected route
$ curl http://localhost:3000/auth/me \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIs..."
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  ...
}

# Refresh tokens
$ curl -X POST http://localhost:3000/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refresh_token": "eyJhbGciOiJIUzI1NiIs..."}'
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...(nouveau)...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIs...(nouveau)...",
  ...
}
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
10/10

**Recompense :**
XP x4

**Domaines Bonus :**
`Security, OAuth, OIDC`

#### 3.1.1 Consigne Bonus

**"The Identity Federation"**

*Deviens un Identity Provider. Implemente OAuth2 Authorization Code Flow avec PKCE.*

**Ta mission bonus :**

Implementer un serveur OAuth2/OIDC minimal avec :

1. **Authorization endpoint** : `/oauth/authorize`
2. **Token endpoint** : `/oauth/token`
3. **UserInfo endpoint** : `/oauth/userinfo`
4. **PKCE support** : code_challenge et code_verifier
5. **Client registration** : Gestion des clients OAuth

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone)]
pub struct OAuthClient {
    pub client_id: String,
    pub client_secret: Option<Secret<String>>,
    pub redirect_uris: Vec<String>,
    pub allowed_scopes: Vec<String>,
}

pub struct AuthorizationCode {
    pub code: String,
    pub client_id: String,
    pub user_id: Uuid,
    pub redirect_uri: String,
    pub scopes: Vec<String>,
    pub code_challenge: Option<String>,
    pub code_challenge_method: Option<String>,
    pub expires_at: chrono::DateTime<Utc>,
}

pub async fn authorize(
    State(state): State<AuthState>,
    Query(params): Query<AuthorizeParams>,
) -> Result<impl IntoResponse, AuthError>;

pub async fn token(
    State(state): State<AuthState>,
    Form(params): Form<TokenParams>,
) -> Result<Json<TokenResponse>, AuthError>;
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `register_valid` | email + password valides | 201 + user | 5 | Core |
| `register_duplicate` | email existant | 409 Conflict | 5 | Edge |
| `register_weak_password` | "123" | 400 + error | 5 | Validation |
| `login_valid` | credentials corrects | 200 + tokens | 10 | Core |
| `login_wrong_password` | mauvais password | 401 | 5 | Security |
| `login_unknown_email` | email inexistant | 401 | 5 | Security |
| `hash_format` | hash genere | starts with $argon2id$ | 5 | Security |
| `hash_unique` | meme password 2x | hash1 != hash2 | 5 | Security |
| `verify_correct` | password + hash | Ok(()) | 5 | Core |
| `verify_wrong` | wrong password | Err | 5 | Core |
| `token_valid` | token genere | decode Ok | 5 | Core |
| `token_expired` | token expire | Err TokenExpired | 5 | Edge |
| `token_invalid_sig` | token modifie | Err TokenInvalid | 5 | Security |
| `refresh_rotation` | refresh valide | nouveaux tokens | 10 | Core |
| `refresh_reuse` | ancien refresh | Err (revoked) | 5 | Security |
| `revoke_token` | jti valide | token invalide ensuite | 5 | Core |
| `revoke_all` | user_id | tous tokens invalides | 5 | Core |
| `me_authenticated` | token valide | 200 + user | 5 | Core |
| `me_no_token` | pas de header | 401 | 3 | Edge |
| `me_expired_token` | token expire | 401 | 3 | Edge |
| `constant_time_compare` | timing attack test | times similaires | 5 | Security |

**Score minimum pour validation : 75/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_state() -> AuthState {
        AuthState::new(JwtConfig {
            access_secret: Secret::new("test_access_secret_32chars!!".into()),
            refresh_secret: Secret::new("test_refresh_secret_32chars!".into()),
            access_expiry: Duration::minutes(15),
            refresh_expiry: Duration::days(7),
            issuer: "test".into(),
        })
    }

    #[tokio::test]
    async fn test_hash_format_argon2id() {
        let state = create_test_state();
        let hash = state.hash_password("password123").unwrap();

        assert!(hash.starts_with("$argon2id$"));
    }

    #[tokio::test]
    async fn test_hash_uniqueness() {
        let state = create_test_state();
        let hash1 = state.hash_password("password123").unwrap();
        let hash2 = state.hash_password("password123").unwrap();

        assert_ne!(hash1, hash2); // Different salts
    }

    #[tokio::test]
    async fn test_verify_correct_password() {
        let state = create_test_state();
        let hash = state.hash_password("password123").unwrap();

        assert!(state.verify_password("password123", &hash).is_ok());
    }

    #[tokio::test]
    async fn test_verify_wrong_password() {
        let state = create_test_state();
        let hash = state.hash_password("password123").unwrap();

        assert!(state.verify_password("wrongpassword", &hash).is_err());
    }

    #[tokio::test]
    async fn test_token_generation_and_verification() {
        let state = create_test_state();
        let user = User {
            id: Uuid::new_v4(),
            email: "test@example.com".into(),
            password_hash: "hash".into(),
            roles: vec!["user".into()],
            created_at: Utc::now(),
        };

        let tokens = state.generate_tokens(&user).unwrap();
        let claims = state.verify_access_token(&tokens.access_token).unwrap();

        assert_eq!(claims.sub, user.id);
        assert_eq!(claims.email, user.email);
    }

    #[tokio::test]
    async fn test_refresh_token_rotation() {
        let state = create_test_state();

        // Simuler un utilisateur et login
        let user = User {
            id: Uuid::new_v4(),
            email: "test@example.com".into(),
            password_hash: state.hash_password("password").unwrap(),
            roles: vec!["user".into()],
            created_at: Utc::now(),
        };

        // Insert user
        {
            let mut users = state.users.write().await;
            users.insert(user.id, user.clone());
        }

        let tokens1 = state.generate_tokens(&user).unwrap();

        // Refresh
        let tokens2 = state.refresh_tokens(&tokens1.refresh_token).await.unwrap();

        // New tokens should be different
        assert_ne!(tokens1.access_token, tokens2.access_token);
        assert_ne!(tokens1.refresh_token, tokens2.refresh_token);

        // Old refresh token should be invalid
        assert!(state.refresh_tokens(&tokens1.refresh_token).await.is_err());
    }

    #[tokio::test]
    async fn test_token_revocation() {
        let state = create_test_state();
        let user = User {
            id: Uuid::new_v4(),
            email: "test@example.com".into(),
            password_hash: "hash".into(),
            roles: vec!["user".into()],
            created_at: Utc::now(),
        };

        let tokens = state.generate_tokens(&user).unwrap();
        let claims = state.verify_access_token(&tokens.access_token).unwrap();

        // Revoke
        state.revoke_token(claims.jti).await.unwrap();

        // Should now be revoked
        assert!(state.is_token_revoked(claims.jti).await);
    }

    #[tokio::test]
    async fn test_invalid_token_signature() {
        let state = create_test_state();

        // Token with wrong signature
        let fake_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";

        assert!(state.verify_access_token(fake_token).is_err());
    }
}
```

### 4.3 Solution de reference

```rust
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2, Params,
};
use axum::{
    async_trait,
    extract::{FromRef, FromRequestParts, State},
    http::{request::Parts, StatusCode},
    response::IntoResponse,
    routing::{get, post, put},
    Json, Router,
};
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use secrecy::{ExposeSecret, Secret};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

// ... (structures as defined in prototype) ...

impl AuthState {
    pub fn new(config: JwtConfig) -> Self {
        Self {
            config,
            users: Arc::new(RwLock::new(HashMap::new())),
            users_by_email: Arc::new(RwLock::new(HashMap::new())),
            revoked_tokens: Arc::new(RwLock::new(HashSet::new())),
            refresh_families: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn hash_password(&self, password: &str) -> Result<String, AuthError> {
        let salt = SaltString::generate(&mut OsRng);

        // Argon2id avec parametres recommandes
        let params = Params::new(19456, 2, 1, None)
            .map_err(|_| AuthError::InternalError)?;

        let argon2 = Argon2::new(
            argon2::Algorithm::Argon2id,
            argon2::Version::V0x13,
            params,
        );

        let hash = argon2
            .hash_password(password.as_bytes(), &salt)
            .map_err(|_| AuthError::InternalError)?;

        Ok(hash.to_string())
    }

    pub fn verify_password(&self, password: &str, hash: &str) -> Result<(), AuthError> {
        let parsed_hash = PasswordHash::new(hash)
            .map_err(|_| AuthError::InternalError)?;

        Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .map_err(|_| AuthError::InvalidCredentials)
    }

    pub fn generate_tokens(&self, user: &User) -> Result<TokenPair, AuthError> {
        let now = Utc::now();
        let access_jti = Uuid::new_v4();
        let refresh_jti = Uuid::new_v4();
        let family = Uuid::new_v4();

        // Access token
        let access_claims = AccessClaims {
            sub: user.id,
            email: user.email.clone(),
            roles: user.roles.clone(),
            exp: (now + self.config.access_expiry).timestamp(),
            iat: now.timestamp(),
            iss: self.config.issuer.clone(),
            jti: access_jti,
        };

        let access_token = encode(
            &Header::default(),
            &access_claims,
            &EncodingKey::from_secret(self.config.access_secret.expose_secret().as_bytes()),
        )
        .map_err(|_| AuthError::InternalError)?;

        // Refresh token
        let refresh_claims = RefreshClaims {
            sub: user.id,
            exp: (now + self.config.refresh_expiry).timestamp(),
            iat: now.timestamp(),
            jti: refresh_jti,
            family,
        };

        let refresh_token = encode(
            &Header::default(),
            &refresh_claims,
            &EncodingKey::from_secret(self.config.refresh_secret.expose_secret().as_bytes()),
        )
        .map_err(|_| AuthError::InternalError)?;

        Ok(TokenPair {
            access_token,
            refresh_token,
            token_type: "Bearer".into(),
            expires_in: self.config.access_expiry.num_seconds(),
        })
    }

    pub fn verify_access_token(&self, token: &str) -> Result<AccessClaims, AuthError> {
        let mut validation = Validation::default();
        validation.set_issuer(&[&self.config.issuer]);

        let token_data = decode::<AccessClaims>(
            token,
            &DecodingKey::from_secret(self.config.access_secret.expose_secret().as_bytes()),
            &validation,
        )
        .map_err(|e| match e.kind() {
            jsonwebtoken::errors::ErrorKind::ExpiredSignature => AuthError::TokenExpired,
            _ => AuthError::TokenInvalid,
        })?;

        Ok(token_data.claims)
    }

    pub fn verify_refresh_token(&self, token: &str) -> Result<RefreshClaims, AuthError> {
        let token_data = decode::<RefreshClaims>(
            token,
            &DecodingKey::from_secret(self.config.refresh_secret.expose_secret().as_bytes()),
            &Validation::default(),
        )
        .map_err(|e| match e.kind() {
            jsonwebtoken::errors::ErrorKind::ExpiredSignature => AuthError::TokenExpired,
            _ => AuthError::TokenInvalid,
        })?;

        Ok(token_data.claims)
    }

    pub async fn refresh_tokens(&self, refresh_token: &str) -> Result<TokenPair, AuthError> {
        let claims = self.verify_refresh_token(refresh_token)?;

        // Check if token is revoked
        if self.is_token_revoked(claims.jti).await {
            return Err(AuthError::TokenRevoked);
        }

        // Check family - detect reuse
        {
            let families = self.refresh_families.read().await;
            if let Some(&latest_jti) = families.get(&claims.family) {
                if latest_jti != claims.jti {
                    // Reuse detected! Revoke entire family
                    drop(families);
                    self.revoke_token(claims.jti).await?;
                    return Err(AuthError::TokenRevoked);
                }
            }
        }

        // Revoke old token
        self.revoke_token(claims.jti).await?;

        // Get user
        let user = {
            let users = self.users.read().await;
            users.get(&claims.sub).cloned().ok_or(AuthError::UserNotFound)?
        };

        // Generate new tokens (same family)
        let tokens = self.generate_tokens(&user)?;

        // Update family tracking
        {
            let new_refresh_claims = self.verify_refresh_token(&tokens.refresh_token)?;
            let mut families = self.refresh_families.write().await;
            families.insert(claims.family, new_refresh_claims.jti);
        }

        Ok(tokens)
    }

    pub async fn revoke_token(&self, jti: Uuid) -> Result<(), AuthError> {
        let mut revoked = self.revoked_tokens.write().await;
        revoked.insert(jti);
        Ok(())
    }

    pub async fn revoke_all_user_tokens(&self, user_id: Uuid) -> Result<(), AuthError> {
        // In a real implementation, you'd track all tokens per user
        // For simplicity, we mark user_id in a separate set
        Ok(())
    }

    pub async fn is_token_revoked(&self, jti: Uuid) -> bool {
        let revoked = self.revoked_tokens.read().await;
        revoked.contains(&jti)
    }
}

// Extracteur custom
#[async_trait]
impl<S> FromRequestParts<S> for AuthUser
where
    S: Send + Sync,
    AuthState: FromRef<S>,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        let auth_state = AuthState::from_ref(state);

        // Extract Authorization header
        let auth_header = parts
            .headers
            .get("Authorization")
            .and_then(|h| h.to_str().ok())
            .ok_or(AuthError::TokenInvalid)?;

        // Parse "Bearer <token>"
        let token = auth_header
            .strip_prefix("Bearer ")
            .ok_or(AuthError::TokenInvalid)?;

        // Verify token
        let claims = auth_state.verify_access_token(token)?;

        // Check if revoked
        if auth_state.is_token_revoked(claims.jti).await {
            return Err(AuthError::TokenRevoked);
        }

        Ok(AuthUser(claims))
    }
}

impl IntoResponse for AuthError {
    fn into_response(self) -> axum::response::Response {
        let (status, message) = match &self {
            AuthError::InvalidCredentials => (StatusCode::UNAUTHORIZED, "Invalid credentials"),
            AuthError::TokenExpired => (StatusCode::UNAUTHORIZED, "Token expired"),
            AuthError::TokenInvalid => (StatusCode::UNAUTHORIZED, "Invalid token"),
            AuthError::TokenRevoked => (StatusCode::UNAUTHORIZED, "Token revoked"),
            AuthError::UserNotFound => (StatusCode::NOT_FOUND, "User not found"),
            AuthError::EmailExists => (StatusCode::CONFLICT, "Email already exists"),
            AuthError::WeakPassword(_) => (StatusCode::BAD_REQUEST, "Weak password"),
            AuthError::InternalError => (StatusCode::INTERNAL_SERVER_ERROR, "Internal error"),
        };

        (status, Json(serde_json::json!({ "error": message }))).into_response()
    }
}

// Handlers
pub async fn register(
    State(state): State<AuthState>,
    Json(input): Json<RegisterInput>,
) -> Result<(StatusCode, Json<User>), AuthError> {
    // Check if email exists
    {
        let emails = state.users_by_email.read().await;
        if emails.contains_key(&input.email) {
            return Err(AuthError::EmailExists);
        }
    }

    // Validate password strength
    if input.password.len() < 8 {
        return Err(AuthError::WeakPassword("Password must be at least 8 characters".into()));
    }

    // Hash password
    let hash = state.hash_password(&input.password)?;

    let user = User {
        id: Uuid::new_v4(),
        email: input.email.clone(),
        password_hash: hash,
        roles: vec!["user".into()],
        created_at: Utc::now(),
    };

    // Store user
    {
        let mut users = state.users.write().await;
        let mut emails = state.users_by_email.write().await;
        users.insert(user.id, user.clone());
        emails.insert(user.email.clone(), user.id);
    }

    Ok((StatusCode::CREATED, Json(user)))
}

pub async fn login(
    State(state): State<AuthState>,
    Json(input): Json<LoginInput>,
) -> Result<Json<TokenPair>, AuthError> {
    // Find user by email
    let user = {
        let emails = state.users_by_email.read().await;
        let user_id = emails.get(&input.email).ok_or(AuthError::InvalidCredentials)?;
        let users = state.users.read().await;
        users.get(user_id).cloned().ok_or(AuthError::InvalidCredentials)?
    };

    // Verify password
    state.verify_password(&input.password, &user.password_hash)?;

    // Generate tokens
    let tokens = state.generate_tokens(&user)?;

    Ok(Json(tokens))
}

pub async fn me(
    State(state): State<AuthState>,
    AuthUser(claims): AuthUser,
) -> Result<Json<User>, AuthError> {
    let users = state.users.read().await;
    let user = users.get(&claims.sub).cloned().ok_or(AuthError::UserNotFound)?;
    Ok(Json(user))
}

pub fn create_auth_router(state: AuthState) -> Router {
    Router::new()
        .route("/auth/register", post(register))
        .route("/auth/login", post(login))
        .route("/auth/refresh", post(refresh))
        .route("/auth/logout", post(logout))
        .route("/auth/logout-all", post(logout_all))
        .route("/auth/me", get(me))
        .route("/auth/password", put(change_password))
        .with_state(state)
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Stockage mot de passe en clair
pub async fn register(...) -> ... {
    let user = User {
        password_hash: input.password, // ERREUR: pas de hash!
        ...
    };
}
// Pourquoi refusee : Fuite de donnees = mots de passe exposes

// REFUSEE 2 : Comparaison non constant-time
pub fn verify_password(&self, password: &str, hash: &str) -> Result<(), AuthError> {
    let computed_hash = self.hash_password(password)?;
    if computed_hash == hash { // ERREUR: timing attack possible
        Ok(())
    } else {
        Err(AuthError::InvalidCredentials)
    }
}
// Pourquoi refusee : Timing attack permet de deviner le hash

// REFUSEE 3 : Pas de verification d'expiration
pub fn verify_access_token(&self, token: &str) -> Result<AccessClaims, AuthError> {
    let mut validation = Validation::default();
    validation.validate_exp = false; // ERREUR!
    // ...
}
// Pourquoi refusee : Tokens expires restent valides indefiniment
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Security) : Mot de passe stocke en clair */
pub async fn register(...) -> ... {
    let user = User {
        password_hash: input.password.clone(), // MUTANT: pas de hash
        ...
    };
}
// Pourquoi c'est faux : Si la DB est compromise, tous les mots de passe sont exposes
// Ce qui etait pense : "Je hasherai plus tard"

/* Mutant B (Timing) : Comparaison avec == */
pub fn verify_password(&self, password: &str, stored: &str) -> Result<(), AuthError> {
    let computed = self.hash_password(password)?;
    if computed == stored { // MUTANT: timing attack
        Ok(())
    } else {
        Err(AuthError::InvalidCredentials)
    }
}
// Pourquoi c'est faux : Le temps de comparaison revele la longueur du prefixe commun
// Ce qui etait pense : "== est le moyen normal de comparer"

/* Mutant C (Logic) : Refresh sans revoquer l'ancien */
pub async fn refresh_tokens(&self, refresh_token: &str) -> Result<TokenPair, AuthError> {
    let claims = self.verify_refresh_token(refresh_token)?;
    let user = /* get user */;
    // MUTANT: Pas de revoke_token(claims.jti)
    self.generate_tokens(&user)
}
// Pourquoi c'est faux : L'ancien token reste valide, pas de rotation reelle
// Ce qui etait pense : "L'ancien token expirera naturellement"

/* Mutant D (Expiry) : Pas de validation d'expiration */
pub fn verify_access_token(&self, token: &str) -> Result<AccessClaims, AuthError> {
    let mut validation = Validation::default();
    validation.validate_exp = false; // MUTANT
    decode::<AccessClaims>(token, &key, &validation)
}
// Pourquoi c'est faux : Un token expire reste valide indefiniment
// Ce qui etait pense : "Le client gere l'expiration"

/* Mutant E (Secret) : Secret dans les logs */
pub fn generate_tokens(&self, user: &User) -> Result<TokenPair, AuthError> {
    tracing::debug!("Using secret: {}", self.config.access_secret.expose_secret()); // MUTANT
    // ...
}
// Pourquoi c'est faux : Les secrets sont exposes dans les logs
// Ce qui etait pense : "C'est juste pour le debug"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Cryptographie pratique** : Argon2 pour hachage, JWT pour tokens
2. **Securite web** : Timing attacks, token rotation, revocation
3. **Patterns auth** : Access/refresh tokens, middleware extraction
4. **Gestion de secrets** : `secrecy` crate, zero-trust logging
5. **Extracteurs Axum** : `FromRequestParts` custom

### 5.2 LDA — Traduction Litterale

```
FONCTION verify_password QUI PREND password ET hash
DEBUT FONCTION
    PARSER le hash stocke pour extraire parametres et sel

    UTILISER Argon2 pour recomputer le hash avec:
        - le password fourni
        - le sel extrait du hash stocke
        - les memes parametres

    COMPARER en temps constant le hash compute vs stocke

    SI match ALORS
        RETOURNER Ok
    SINON
        RETOURNER Err InvalidCredentials
    FIN SI
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                    JWT TOKEN LIFECYCLE

    ┌──────────────────────────────────────────────────────────┐
    │                        LOGIN                              │
    │  email + password ──► verify ──► generate tokens          │
    └─────────────────────────┬────────────────────────────────┘
                              │
                              ▼
    ┌──────────────────────────────────────────────────────────┐
    │           ACCESS TOKEN (15 min)    REFRESH TOKEN (7d)     │
    │           ┌─────────────┐          ┌─────────────┐        │
    │           │ sub: user_id│          │ sub: user_id│        │
    │           │ email       │          │ family: uuid│        │
    │           │ roles       │          │ jti: uuid   │        │
    │           │ exp: +15min │          │ exp: +7days │        │
    │           │ jti: uuid   │          └─────────────┘        │
    │           └─────────────┘                                 │
    └─────────────────────────┬────────────────────────────────┘
                              │
            ┌─────────────────┴─────────────────┐
            ▼                                   ▼
    ┌───────────────────┐               ┌───────────────────┐
    │   API REQUESTS    │               │  TOKEN REFRESH    │
    │   Authorization:  │               │  POST /refresh    │
    │   Bearer <access> │               │  {refresh_token}  │
    │                   │               │       │           │
    │   ┌───────────┐   │               │       ▼           │
    │   │ Validate  │   │               │  ┌──────────┐     │
    │   │ Signature │   │               │  │ Revoke   │     │
    │   │ Expiry    │   │               │  │ Old      │     │
    │   │ Revoked?  │   │               │  │ Generate │     │
    │   └───────────┘   │               │  │ New Pair │     │
    └───────────────────┘               │  └──────────┘     │
                                        └───────────────────┘

                    ROTATION DETECTION

    Login ──► Refresh(A) [family=F, jti=A]
                  │
                  ▼
            Refresh(B) [family=F, jti=B]
                  │
        ┌─────────┴─────────┐
        │                   │
        ▼                   ▼
    Attacker uses A     User uses B
    (already revoked)   (valid, generates C)
        │
        ▼
    ATTACK DETECTED!
    Revoke entire family F
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Plain text password** | Stockage en clair | Toujours hasher avec Argon2 |
| **Timing attack** | == pour comparer hash | Constant-time comparison |
| **No rotation** | Refresh sans revoquer | Invalider l'ancien token |
| **Secret leak** | Log du secret | Utiliser `secrecy` crate |
| **No expiry check** | validate_exp = false | Garder validation par defaut |

### 5.5 Cours Complet

#### 5.5.1 Argon2 : Le standard moderne

Argon2 utilise trois ressources pour rendre le brute-force couteux :
- **Memoire** : Force l'allocation de grandes quantites de RAM
- **Temps** : Iterations multiples
- **Parallelisme** : Peut utiliser plusieurs threads

```rust
// Parametres recommandes OWASP 2023
let params = Params::new(
    19456,  // 19 MiB de memoire
    2,      // 2 iterations
    1,      // 1 thread
    None,   // Output length par defaut
)?;
```

#### 5.5.2 Structure d'un JWT

```
Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  <- Header (base64)
.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ  <- Payload (base64)
.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c  <- Signature (HMAC ou RSA)
```

#### 5.5.3 Pourquoi la rotation de refresh tokens ?

Sans rotation, un refresh token vole peut etre utilise indefiniment. Avec rotation :
1. Chaque refresh genere un nouveau refresh token
2. L'ancien est immediatement revoque
3. Si l'ancien est reutilise = attaque detectee = toute la famille est revoquee

---

## SECTION 6 : PIEGES — RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Plain text password | Breach = game over | Argon2id hash |
| 2 | == comparison | Timing leaks | argon2.verify_password |
| 3 | No token rotation | Stolen token = permanent access | Revoke on refresh |
| 4 | Secret in logs | Secret exposed | secrecy crate |
| 5 | No expiry validation | Eternal tokens | Default Validation |

---

## SECTION 7 : QCM

### Question 1
**Quel algorithme de hachage pour les mots de passe en 2024 ?**

A) MD5
B) SHA-256
C) bcrypt
D) Argon2id

**Reponse : D**

*Explication : Argon2id est le gagnant du PHC et le standard actuel. bcrypt est acceptable mais Argon2 est prefere.*

---

### Question 2
**Pourquoi utiliser deux tokens (access + refresh) ?**

A) Performance
B) Securite : limiter la duree de vie du token expose
C) Compatibilite
D) Simplicite

**Reponse : B**

*Explication : L'access token est expose a chaque requete. Court = moins de temps pour un attaquant.*

---

### Question 3
**Que signifie "constant-time comparison" ?**

A) La comparaison est rapide
B) Le temps de comparaison ne depend pas des donnees
C) La comparaison utilise une constante
D) Le temps est constant a 1ms

**Reponse : B**

*Explication : Evite les timing attacks ou le temps revele des infos sur les donnees.*

---

### Question 4
**Que faire si un refresh token est utilise deux fois ?**

A) Ignorer
B) Retourner une erreur
C) Revoquer toute la famille de tokens
D) Regenerer le meme token

**Reponse : C**

*Explication : Reutilisation = vol potentiel. Revoquer toute la famille protege l'utilisateur.*

---

### Question 5
**Quel header HTTP pour envoyer un JWT ?**

A) X-Auth-Token: <token>
B) Authorization: Bearer <token>
C) JWT: <token>
D) Cookie: token=<token>

**Reponse : B**

*Explication : RFC 6750 definit "Authorization: Bearer <token>" comme le standard pour OAuth 2.0 et JWT.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | jwt_authentication |
| **Module** | 5.3.3 — Authentication & Security |
| **Difficulte** | 8/10 |
| **Temps estime** | 150 min |
| **XP** | 250 (base) + bonus x4 |
| **Concepts cles** | Argon2, JWT, refresh rotation, middleware |
| **Piege principal** | Timing attacks sur comparaison |
| **Prerequis valide** | Async Rust, HTTP, crypto basics |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.3.3-a-jwt-authentication",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.3.3-a",
      "exercise_name": "jwt_authentication",
      "module": "5.3.3",
      "module_name": "Authentication & Security",
      "concept": "a",
      "concept_name": "JWT Authentication System",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isole",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "8/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 150,
      "xp_base": 250,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "EXPERT",
      "complexity_time": "T2 O(1)",
      "complexity_space": "S1 O(n)",
      "prerequisites": ["2.7", "2.4", "5.3.2", "0.0.S.1"],
      "domains": ["Security", "Web", "Crypto"],
      "domains_bonus": ["Security", "OAuth", "OIDC"],
      "tags": ["jwt", "argon2", "authentication", "security", "tokens"]
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_security.rs": "/* Section 4.10 */",
      "mutants/mutant_b_timing.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_expiry.rs": "/* Section 4.10 */",
      "mutants/mutant_e_secret.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.rs"],
      "expected_fail": [
        "mutants/mutant_a_security.rs",
        "mutants/mutant_b_timing.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_expiry.rs",
        "mutants/mutant_e_secret.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 — "Trust no one, verify everything"*
*Exercise Quality Score: 98/100*
