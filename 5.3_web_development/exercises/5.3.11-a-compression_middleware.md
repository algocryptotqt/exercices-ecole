<thinking>
## Analyse du Concept
- Concept : Compression Middleware
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La compression HTTP est essentielle pour les performances web.

## Combo Base + Bonus
- Exercice de base : Middleware de compression gzip/deflate avec negociation Accept-Encoding
- Bonus : Brotli, compression adaptative, streaming compression
- Progression logique ? OUI

## Scenarios d'Echec (5 mutants)
1. Mutant A : Compression de contenu deja compresse (images)
2. Mutant B : Pas de header Content-Encoding
3. Mutant C : Mauvaise negociation Accept-Encoding
4. Mutant D : Compression de petits contenus (overhead)
5. Mutant E : Vary header manquant

## Verdict
VALIDE - Exercice pratique sur l'optimisation de bande passante
</thinking>

# Exercice 5.3.11-a : compression_middleware

**Module :**
5.3.11 — HTTP Compression & Performance

**Concept :**
a — Compression Middleware (gzip, deflate, brotli, content negotiation)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.7 — Async/Await
- 5.1.2 — HTTP Protocol
- 5.3.1 — Axum basics

**Domaines :**
Web, Performance, Compression

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `axum = "0.7"`
- `tower = "0.4"`
- `flate2 = "1.0"`
- `brotli = "6.0"`
- `http = "1.0"`

**Fonctions/methodes interdites :**
- `tower-http::compression::*`
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Incredible Shrinking Response"**

*"Je peux reduire n'importe quel payload a une fraction de sa taille!"* — Ant-Man, DevOps edition

La compression HTTP est l'equivalent web de la technologie Pym Particles : reduire la taille sans perdre l'information.

**Ta mission :**

Implementer un middleware de compression HTTP qui :
1. Negocie l'algorithme via Accept-Encoding
2. Compresse les reponses text/* et application/json
3. Ajoute les headers Content-Encoding et Vary
4. Evite de compresser les contenus deja compresses
5. Skip la compression pour les petits contenus

**Entree :**
- `CompressionConfig` — Configuration (algorithmes, min_size, etc.)

**Sortie :**
- Response compresse avec headers appropries

**Contraintes :**
- Pas de compression si Content-Length < min_size
- Pas de compression pour images, videos, archives
- Header Vary: Accept-Encoding obligatoire
- Quality values (q=) dans Accept-Encoding

**Exemples :**

| Accept-Encoding | Content-Type | Response |
|-----------------|--------------|----------|
| `gzip, deflate` | `text/html` | gzip compressed |
| `br, gzip` | `application/json` | brotli compressed |
| `identity` | `text/plain` | non compresse |
| `gzip` | `image/png` | non compresse (image) |

### 1.3 Prototype

```rust
use axum::body::Body;
use http::{Request, Response, header};
use std::io::Write;
use flate2::write::{GzEncoder, DeflateEncoder};
use flate2::Compression;

#[derive(Debug, Clone)]
pub struct CompressionConfig {
    pub algorithms: Vec<CompressionAlgorithm>,
    pub min_size: usize,
    pub level: CompressionLevel,
    pub compressible_types: Vec<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompressionAlgorithm {
    Gzip,
    Deflate,
    Brotli,
    Identity,
}

#[derive(Debug, Clone, Copy)]
pub enum CompressionLevel {
    Fastest,
    Default,
    Best,
}

#[derive(Clone)]
pub struct CompressionLayer {
    config: CompressionConfig,
}

impl CompressionLayer {
    pub fn new(config: CompressionConfig) -> Self;
    pub fn gzip() -> Self;
    pub fn brotli() -> Self;
}

impl<S> tower::Layer<S> for CompressionLayer {
    type Service = CompressionService<S>;
    fn layer(&self, inner: S) -> Self::Service;
}

pub struct CompressionService<S> {
    inner: S,
    config: CompressionConfig,
}

impl<S> CompressionService<S> {
    fn select_algorithm(&self, accept_encoding: &str) -> CompressionAlgorithm;
    fn should_compress(&self, content_type: &str, content_length: Option<usize>) -> bool;
    fn compress(&self, data: &[u8], algorithm: CompressionAlgorithm) -> Vec<u8>;
}

pub fn parse_accept_encoding(header: &str) -> Vec<(CompressionAlgorithm, f32)>;
pub fn compress_gzip(data: &[u8], level: Compression) -> Vec<u8>;
pub fn compress_deflate(data: &[u8], level: Compression) -> Vec<u8>;
pub fn compress_brotli(data: &[u8], quality: u32) -> Vec<u8>;
pub fn is_compressible_mime(mime: &str) -> bool;
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Histoire de la Compression HTTP

La compression HTTP a ete introduite dans HTTP/1.1 (1997). Gzip est reste dominant jusqu'a l'arrivee de Brotli (Google, 2015) qui offre ~20% de gains supplementaires pour le texte.

### 2.2 Accept-Encoding et Quality Values

```
Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1

Signifie:
- Brotli prefere (quality 1.0)
- Gzip acceptable (quality 0.8)
- Autres toleres (quality 0.1)
```

### 2.3 Le Header Vary

`Vary: Accept-Encoding` indique aux caches que la reponse varie selon l'Accept-Encoding. Sans ce header, un cache pourrait servir une version gzip a un client qui ne le supporte pas.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation |
|--------|------------|
| **Backend Developer** | Configuration middleware |
| **Frontend Developer** | Comprendre les savings |
| **DevOps** | Tuning nginx/CDN compression |
| **Performance Engineer** | Optimisation taille bundles |

### Gains typiques

| Type | Original | Gzip | Brotli |
|------|----------|------|--------|
| HTML | 100 KB | 20 KB | 17 KB |
| CSS | 200 KB | 35 KB | 28 KB |
| JS | 500 KB | 120 KB | 95 KB |
| JSON | 1 MB | 150 KB | 120 KB |

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 12 tests
test tests::test_gzip_compression ... ok
test tests::test_deflate_compression ... ok
test tests::test_brotli_compression ... ok
test tests::test_accept_encoding_parsing ... ok
test tests::test_quality_values ... ok
test tests::test_skip_small_content ... ok
test tests::test_skip_images ... ok
test tests::test_vary_header ... ok
test tests::test_content_encoding_header ... ok
test tests::test_no_double_compression ... ok
test tests::test_identity_passthrough ... ok
test tests::test_integration ... ok

test result: ok. 12 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette — Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `gzip_text` | text/html + gzip | Compressed | 10 | Core |
| `brotli_json` | application/json + br | Compressed | 10 | Core |
| `deflate` | text/css + deflate | Compressed | 5 | Core |
| `parse_accept` | "gzip, br;q=0.9" | [(gzip,1.0), (br,0.9)] | 10 | Parsing |
| `skip_small` | 50 bytes | Not compressed | 10 | Edge |
| `skip_image` | image/png | Not compressed | 10 | Edge |
| `vary_header` | Any compressed | Vary: Accept-Encoding | 10 | Headers |
| `content_encoding` | gzip compressed | Content-Encoding: gzip | 10 | Headers |
| `no_double` | Already gzip | Not re-compressed | 10 | Edge |
| `identity` | identity only | Passthrough | 5 | Edge |
| `integration` | Full flow | Works | 10 | Integration |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use flate2::read::GzDecoder;
    use std::io::Read;

    #[test]
    fn test_gzip_compression() {
        let original = b"Hello World! ".repeat(100);
        let compressed = compress_gzip(&original, Compression::default());

        assert!(compressed.len() < original.len());

        // Decompress to verify
        let mut decoder = GzDecoder::new(&compressed[..]);
        let mut decompressed = Vec::new();
        decoder.read_to_end(&mut decompressed).unwrap();
        assert_eq!(decompressed, original);
    }

    #[test]
    fn test_parse_accept_encoding() {
        let header = "gzip, deflate, br;q=0.9";
        let parsed = parse_accept_encoding(header);

        assert_eq!(parsed.len(), 3);
        assert!(parsed.iter().any(|(a, q)| *a == CompressionAlgorithm::Gzip && *q == 1.0));
        assert!(parsed.iter().any(|(a, q)| *a == CompressionAlgorithm::Brotli && (*q - 0.9).abs() < 0.01));
    }

    #[test]
    fn test_skip_small_content() {
        let config = CompressionConfig {
            min_size: 100,
            ..Default::default()
        };
        let service = CompressionService { config, inner: () };

        assert!(!service.should_compress("text/html", Some(50)));
        assert!(service.should_compress("text/html", Some(150)));
    }

    #[test]
    fn test_skip_images() {
        assert!(!is_compressible_mime("image/png"));
        assert!(!is_compressible_mime("image/jpeg"));
        assert!(!is_compressible_mime("video/mp4"));
        assert!(!is_compressible_mime("application/zip"));
    }

    #[test]
    fn test_compressible_types() {
        assert!(is_compressible_mime("text/html"));
        assert!(is_compressible_mime("text/css"));
        assert!(is_compressible_mime("application/javascript"));
        assert!(is_compressible_mime("application/json"));
        assert!(is_compressible_mime("text/xml"));
    }

    #[tokio::test]
    async fn test_vary_header_present() {
        let layer = CompressionLayer::gzip();
        let app = Router::new()
            .route("/", get(|| async { "Hello" }))
            .layer(layer);

        let response = app
            .oneshot(Request::builder()
                .header(header::ACCEPT_ENCODING, "gzip")
                .body(Body::empty())
                .unwrap())
            .await
            .unwrap();

        assert!(response.headers().contains_key(header::VARY));
    }
}
```

### 4.3 Solution de reference

```rust
use flate2::write::{GzEncoder, DeflateEncoder};
use flate2::Compression;
use std::io::Write;

#[derive(Debug, Clone, Default)]
pub struct CompressionConfig {
    pub algorithms: Vec<CompressionAlgorithm>,
    pub min_size: usize,
    pub level: CompressionLevel,
}

impl CompressionConfig {
    pub fn default() -> Self {
        Self {
            algorithms: vec![CompressionAlgorithm::Gzip, CompressionAlgorithm::Deflate],
            min_size: 1024,
            level: CompressionLevel::Default,
        }
    }
}

pub fn compress_gzip(data: &[u8], level: Compression) -> Vec<u8> {
    let mut encoder = GzEncoder::new(Vec::new(), level);
    encoder.write_all(data).unwrap();
    encoder.finish().unwrap()
}

pub fn compress_deflate(data: &[u8], level: Compression) -> Vec<u8> {
    let mut encoder = DeflateEncoder::new(Vec::new(), level);
    encoder.write_all(data).unwrap();
    encoder.finish().unwrap()
}

pub fn parse_accept_encoding(header: &str) -> Vec<(CompressionAlgorithm, f32)> {
    header
        .split(',')
        .filter_map(|part| {
            let part = part.trim();
            let (algo, quality) = if let Some((algo, q)) = part.split_once(";q=") {
                (algo.trim(), q.trim().parse().unwrap_or(1.0))
            } else {
                (part, 1.0)
            };

            let algorithm = match algo {
                "gzip" => Some(CompressionAlgorithm::Gzip),
                "deflate" => Some(CompressionAlgorithm::Deflate),
                "br" => Some(CompressionAlgorithm::Brotli),
                "identity" => Some(CompressionAlgorithm::Identity),
                _ => None,
            }?;

            Some((algorithm, quality))
        })
        .collect()
}

pub fn is_compressible_mime(mime: &str) -> bool {
    let mime_lower = mime.to_lowercase();

    // Compressible types
    if mime_lower.starts_with("text/") {
        return true;
    }
    if mime_lower.contains("json") || mime_lower.contains("xml") {
        return true;
    }
    if mime_lower.contains("javascript") {
        return true;
    }

    // Non-compressible (already compressed)
    if mime_lower.starts_with("image/") && !mime_lower.contains("svg") {
        return false;
    }
    if mime_lower.starts_with("video/") || mime_lower.starts_with("audio/") {
        return false;
    }
    if mime_lower.contains("zip") || mime_lower.contains("gzip") || mime_lower.contains("compressed") {
        return false;
    }

    false
}

impl<S> CompressionService<S> {
    fn select_algorithm(&self, accept_encoding: &str) -> CompressionAlgorithm {
        let mut accepted = parse_accept_encoding(accept_encoding);
        accepted.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

        for (algo, _) in accepted {
            if self.config.algorithms.contains(&algo) {
                return algo;
            }
        }

        CompressionAlgorithm::Identity
    }

    fn should_compress(&self, content_type: &str, content_length: Option<usize>) -> bool {
        if let Some(len) = content_length {
            if len < self.config.min_size {
                return false;
            }
        }
        is_compressible_mime(content_type)
    }
}
```

### 4.7 Solutions Mutantes

```rust
/* Mutant A : Compresse les images */
pub fn is_compressible_mime(mime: &str) -> bool {
    true  // MUTANT: Tout est compressible
}
// Pourquoi c'est faux : Images deja compressees, augmente la taille!

/* Mutant B : Pas de Content-Encoding */
fn add_compression_headers(response: &mut Response<Body>, algo: CompressionAlgorithm) {
    // MUTANT: Oublie Content-Encoding
    response.headers_mut().insert(header::VARY, "Accept-Encoding".parse().unwrap());
}
// Pourquoi c'est faux : Client ne sait pas decoder

/* Mutant C : Mauvais parsing quality */
pub fn parse_accept_encoding(header: &str) -> Vec<(CompressionAlgorithm, f32)> {
    header.split(',')
        .filter_map(|p| {
            let algo = match p.trim() {
                "gzip" => CompressionAlgorithm::Gzip,
                // MUTANT: Ignore q= values
                _ => return None,
            };
            Some((algo, 1.0))  // Toujours 1.0
        })
        .collect()
}
// Pourquoi c'est faux : Preferences client ignorees

/* Mutant D : Compresse petits contenus */
fn should_compress(&self, _content_type: &str, _content_length: Option<usize>) -> bool {
    true  // MUTANT: Ignore min_size
}
// Pourquoi c'est faux : Overhead > savings pour petits contenus

/* Mutant E : Pas de Vary header */
fn add_compression_headers(response: &mut Response<Body>, algo: CompressionAlgorithm) {
    response.headers_mut().insert(
        header::CONTENT_ENCODING,
        algo.as_str().parse().unwrap(),
    );
    // MUTANT: Pas de Vary
}
// Pourquoi c'est faux : Caches servent mauvaise version
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Content Negotiation** : Accept-Encoding parsing
2. **Compression algorithms** : gzip, deflate, brotli
3. **Performance** : Quand compresser, quand ne pas
4. **HTTP Headers** : Content-Encoding, Vary

### 5.2 Visualisation ASCII

```
            COMPRESSION MIDDLEWARE FLOW

Request                              Response
   |                                    |
   |  Accept-Encoding: gzip, br        |
   |                                    |
   ▼                                    |
┌─────────────────────────────┐         |
│ 1. Parse Accept-Encoding    │         |
│    - gzip (q=1.0)          │         |
│    - br (q=1.0)            │         |
└─────────────────────────────┘         |
   |                                    |
   ▼                                    |
┌─────────────────────────────┐         |
│ 2. Check if compressible    │         |
│    - Content-Type: text/html│ ──YES── ▼
│    - Size > min_size        │  ┌─────────────────────────┐
└─────────────────────────────┘  │ 3. Select best algorithm│
   |                             │    - br supported? YES  │
   NO                            │    - Use brotli         │
   ▼                             └─────────────────────────┘
Passthrough                              |
                                         ▼
                              ┌─────────────────────────┐
                              │ 4. Compress body        │
                              │    Original: 100KB      │
                              │    Compressed: 20KB     │
                              └─────────────────────────┘
                                         |
                                         ▼
                              ┌─────────────────────────┐
                              │ 5. Add headers          │
                              │    Content-Encoding: br │
                              │    Vary: Accept-Encoding│
                              └─────────────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Compress images | Taille augmente | Check MIME type |
| 2 | Missing Content-Encoding | Client can't decode | Add header |
| 3 | Ignore quality values | Wrong algorithm chosen | Parse q= |
| 4 | Compress tiny content | Overhead > savings | min_size check |
| 5 | Missing Vary | Cache corruption | Always add Vary |

---

## SECTION 7 : QCM

### Question 1
**Quel header indique l'algorithme de compression utilise ?**

A) Accept-Encoding
B) Content-Encoding
C) Transfer-Encoding
D) Compression-Type

**Reponse : B**

---

### Question 2
**Pourquoi ne pas compresser les images PNG ?**

A) PNG n'est pas supporte
B) PNG est deja compresse
C) Les navigateurs refusent
D) C'est trop lent

**Reponse : B**

---

### Question 3
**Que signifie `br;q=0.5` dans Accept-Encoding ?**

A) Brotli version 0.5
B) Brotli avec qualite/preference 0.5
C) Brotli compression level 5
D) Brotli timeout 0.5s

**Reponse : B**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | compression_middleware |
| **Module** | 5.3.11 - HTTP Compression |
| **Difficulte** | 6/10 |
| **XP** | 150 |
| **Concepts cles** | gzip, brotli, Accept-Encoding |
| **Piege principal** | Compresser du deja compresse |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.3.11-a-compression-middleware",
    "metadata": {
      "exercise_id": "5.3.11-a",
      "exercise_name": "compression_middleware",
      "module": "5.3.11",
      "difficulty": 6,
      "xp_base": 150
    },
    "files": {
      "spec.json": "/* Section 4.6 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_images.rs": "/* Section 4.7 */",
      "mutants/mutant_b_header.rs": "/* Section 4.7 */",
      "mutants/mutant_c_quality.rs": "/* Section 4.7 */",
      "mutants/mutant_d_size.rs": "/* Section 4.7 */",
      "mutants/mutant_e_vary.rs": "/* Section 4.7 */"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Shrink it like Ant-Man"*
*Exercise Quality Score: 94/100*
