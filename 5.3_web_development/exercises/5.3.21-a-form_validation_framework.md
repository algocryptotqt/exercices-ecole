<thinking>
## Analyse du Concept
- Concept : Form Validation Framework
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La validation de formulaires est essentielle pour toute application web securisee. L'exercice combine validation structurelle, regles metier, et sanitization.

## Combo Base + Bonus
- Exercice de base : Framework de validation de formulaires avec regles declaratives, messages d'erreur, et validation composable
- Bonus : Implementation d'un DSL macro pour declarer les validations de maniere fluide
- Palier bonus : Avance (macros procedurales + composition)
- Progression logique ? OUI - Base = validation simple, Bonus = DSL declaratif

## Prerequis & Difficulte
- Prerequis reels : Traits, generiques, Result/Option, serde, derive macros
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Terminator" - "I'll validate back"
- MEME mnemonique : "Trust no input" (Never trust user input)
- Pourquoi c'est fun : Les formulaires sont le premier rempart contre les donnees invalides

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Longueur max non verifiee (buffer overflow potential)
2. Mutant B (Safety) : Email regex trop permissive (accepte "a@b")
3. Mutant C (Logic) : Validation court-circuitee (retourne Ok au premier champ valide)
4. Mutant D (Edge) : Unicode mal gere dans les longueurs (compte bytes au lieu de chars)
5. Mutant E (Return) : Erreurs non accumulees (retourne seulement la premiere erreur)

## Verdict
VALIDE - Exercice de qualite industrielle couvrant la validation web
</thinking>

# Exercice 5.3.21-a : form_validation_framework

**Module :**
5.3.21 - Web Form Processing

**Concept :**
a - Form Validation Framework (validation declarative, regles composables)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
1 - Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 - Types primitifs et ownership
- 2.3 - Traits (Validate, FromStr)
- 2.4 - Gestion d'erreurs (Result, Option)
- 5.3.8 - Axum extractors et handlers

**Domaines :**
Web, Validation, Security

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `serde = "1.0"` (features: derive)
- `regex = "1.10"`
- `thiserror = "2.0"`

**Fonctions/methodes interdites :**
- Crates de validation externes (`validator`, etc.)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Validator"**

*"Je validerai. Chaque champ. Chaque caractere. Et je reviendrai avec tous les messages d'erreur."* - T-800, probablement

Dans le monde du developpement web, les formulaires sont la porte d'entree des donnees utilisateur. Sans validation rigoureuse, c'est la porte ouverte aux injections, corruptions de donnees, et comportements inattendus.

**Ta mission :**

Implementer un framework de validation de formulaires qui permet de :
1. Definir des regles de validation declaratives
2. Composer plusieurs validateurs
3. Accumuler toutes les erreurs (pas seulement la premiere)
4. Fournir des messages d'erreur clairs et localisables
5. Supporter la validation conditionnelle

**Entree :**
- Structures de donnees avec attributs de validation
- Champs de formulaire a valider

**Sortie :**
- `ValidationResult<T>` - Resultat avec donnees validees ou erreurs
- `Vec<ValidationError>` - Liste complete des erreurs

**Contraintes :**
- Les erreurs doivent etre accumulees, pas court-circuitees
- Support des types String, nombres, Option, Vec
- Messages d'erreur avec contexte (nom du champ, valeur attendue)
- Validation Unicode-aware (longueurs en caracteres, pas bytes)

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `validate_email("user@example.com")` | `Ok(())` | Email valide |
| `validate_email("invalid")` | `Err(InvalidEmail)` | Pas de @ ni domaine |
| `validate_length("ab", 3, 10)` | `Err(TooShort)` | Moins de 3 caracteres |
| `validate_form(user_input)` | `Err([...errors])` | Toutes les erreurs |

### 1.2.2 Consigne Academique

Implementer un framework de validation de formulaires avec regles declaratives. Le framework doit supporter la validation de champs individuels, la composition de validateurs, et l'accumulation d'erreurs multiples avec messages descriptifs.

### 1.3 Prototype

```rust
use std::collections::HashMap;

/// Resultat d'une validation avec erreurs accumulees
pub type ValidationResult<T> = Result<T, Vec<ValidationError>>;

/// Erreur de validation avec contexte
#[derive(Debug, Clone, PartialEq)]
pub struct ValidationError {
    pub field: String,
    pub code: ErrorCode,
    pub message: String,
    pub params: HashMap<String, String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ErrorCode {
    Required,
    TooShort,
    TooLong,
    InvalidFormat,
    InvalidEmail,
    InvalidUrl,
    OutOfRange,
    InvalidPattern,
    Custom(String),
}

/// Trait de validation pour tout type
pub trait Validate {
    fn validate(&self) -> ValidationResult<()>;
}

/// Builder de regles de validation
pub struct Validator<T> {
    rules: Vec<Box<dyn ValidationRule<T>>>,
    field_name: String,
}

pub trait ValidationRule<T>: Send + Sync {
    fn validate(&self, value: &T, field: &str) -> Option<ValidationError>;
}

impl<T> Validator<T> {
    pub fn new(field_name: &str) -> Self;
    pub fn required(self) -> Self where T: Default + PartialEq;
    pub fn min_length(self, min: usize) -> Self where T: AsRef<str>;
    pub fn max_length(self, max: usize) -> Self where T: AsRef<str>;
    pub fn pattern(self, regex: &str) -> Self where T: AsRef<str>;
    pub fn email(self) -> Self where T: AsRef<str>;
    pub fn url(self) -> Self where T: AsRef<str>;
    pub fn range<R: Into<f64>>(self, min: R, max: R) -> Self where T: Into<f64> + Copy;
    pub fn custom<F>(self, f: F) -> Self where F: Fn(&T) -> Option<String> + Send + Sync + 'static;
    pub fn validate(&self, value: &T) -> ValidationResult<()>;
}

/// Validateur de formulaire complet
pub struct FormValidator {
    errors: Vec<ValidationError>,
}

impl FormValidator {
    pub fn new() -> Self;
    pub fn field<T>(&mut self, name: &str, value: &T, validator: &Validator<T>) -> &mut Self;
    pub fn validate(self) -> ValidationResult<()>;
    pub fn errors(&self) -> &[ValidationError];
}

/// Fonctions de validation standalone
pub fn validate_email(email: &str) -> Result<(), ValidationError>;
pub fn validate_url(url: &str) -> Result<(), ValidationError>;
pub fn validate_length(s: &str, min: usize, max: usize) -> Result<(), ValidationError>;
pub fn validate_pattern(s: &str, pattern: &str) -> Result<(), ValidationError>;
pub fn validate_range<T: PartialOrd>(value: T, min: T, max: T) -> Result<(), ValidationError>;

/// Derive macro simulation (structure validable)
#[derive(Debug, Clone)]
pub struct UserRegistration {
    pub username: String,
    pub email: String,
    pub password: String,
    pub age: Option<u8>,
}

impl Validate for UserRegistration {
    fn validate(&self) -> ValidationResult<()>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 OWASP et Input Validation

L'OWASP (Open Web Application Security Project) classe l'injection et la validation insuffisante parmi les risques majeurs. La validation cote serveur est obligatoire - la validation cote client n'est que du "nice to have".

### 2.2 Fail Fast vs Fail Complete

Deux philosophies de validation :
- **Fail Fast** : S'arrete a la premiere erreur (plus performant)
- **Fail Complete** : Accumule toutes les erreurs (meilleure UX)

Notre framework utilise Fail Complete pour une meilleure experience utilisateur.

### 2.3 Unicode et Longueurs

```rust
// PIEGE CLASSIQUE
let s = "cafe";  // 5 bytes mais 4 caracteres
s.len();         // 5 (bytes)
s.chars().count(); // 4 (caracteres)

// Avec emojis
let emoji = "Hello!";  // L'emoji peut faire 4 bytes
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de la validation |
|--------|------------------------------|
| **Backend Developer** | Validation API, sanitization, contraintes DB |
| **Frontend Developer** | Validation formulaires, feedback utilisateur |
| **Security Engineer** | Prevention injections, audit des inputs |
| **QA Engineer** | Tests de validation, fuzzing, edge cases |

### Cas d'usage concrets

1. **Inscription utilisateur** : Email, mot de passe fort, age legal
2. **Paiement e-commerce** : Carte valide, CVV, adresse
3. **Upload fichiers** : Type MIME, taille max, extension

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling form_validation_framework v0.1.0
    Finished test [unoptimized + debuginfo]
     Running unittests src/lib.rs

running 15 tests
test tests::test_email_validation ... ok
test tests::test_length_validation ... ok
test tests::test_pattern_validation ... ok
test tests::test_range_validation ... ok
test tests::test_required_validation ... ok
test tests::test_url_validation ... ok
test tests::test_composed_validators ... ok
test tests::test_accumulate_errors ... ok
test tests::test_unicode_length ... ok
test tests::test_form_validator ... ok
test tests::test_user_registration_valid ... ok
test tests::test_user_registration_invalid ... ok
test tests::test_custom_validator ... ok
test tests::test_optional_field ... ok
test tests::test_error_messages ... ok

test result: ok. 15 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) ou n = nombre de champs

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Macros, DSL`

#### 3.1.1 Consigne Bonus

**"The Macro Validator"**

Implementer un DSL macro pour declarer les validations de maniere fluide :

```rust
#[derive(Validate)]
pub struct User {
    #[validate(required, min_length = 3, max_length = 20)]
    pub username: String,

    #[validate(email)]
    pub email: String,

    #[validate(min_length = 8, pattern = r"[A-Z].*[0-9]")]
    pub password: String,

    #[validate(range(min = 18, max = 120))]
    pub age: Option<u8>,
}
```

#### 3.1.2 Prototype Bonus

```rust
/// Macro derive pour validation automatique
pub use form_validation_derive::Validate;

/// Attributs de validation supportes
/// - required : champ obligatoire
/// - min_length = N : longueur minimale
/// - max_length = N : longueur maximale
/// - email : format email
/// - url : format URL
/// - pattern = "regex" : pattern custom
/// - range(min = N, max = M) : plage numerique
/// - custom = "function_name" : validateur custom
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `email_valid` | `"user@example.com"` | `Ok(())` | 5 | Basic |
| `email_invalid_no_at` | `"userexample.com"` | `Err(InvalidEmail)` | 5 | Edge |
| `email_invalid_no_domain` | `"user@"` | `Err(InvalidEmail)` | 5 | Edge |
| `length_min_ok` | `"abc", min=3` | `Ok(())` | 5 | Basic |
| `length_min_fail` | `"ab", min=3` | `Err(TooShort)` | 5 | Edge |
| `length_max_ok` | `"abc", max=5` | `Ok(())` | 5 | Basic |
| `length_max_fail` | `"abcdef", max=5` | `Err(TooLong)` | 5 | Edge |
| `unicode_length` | `"cafe", min=4` | `Ok(())` | 10 | Unicode |
| `pattern_valid` | `"ABC123", [A-Z]+[0-9]+` | `Ok(())` | 5 | Basic |
| `pattern_invalid` | `"abc", [A-Z]+` | `Err(InvalidPattern)` | 5 | Edge |
| `range_in` | `25, 18..120` | `Ok(())` | 5 | Basic |
| `range_under` | `15, 18..120` | `Err(OutOfRange)` | 5 | Edge |
| `range_over` | `150, 18..120` | `Err(OutOfRange)` | 5 | Edge |
| `required_present` | `"value"` | `Ok(())` | 5 | Basic |
| `required_empty` | `""` | `Err(Required)` | 5 | Edge |
| `accumulate_errors` | invalid form | `Err([err1, err2])` | 10 | Core |
| `form_all_valid` | valid form | `Ok(())` | 10 | Core |
| `custom_validator` | custom fn | works | 5 | Advanced |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_email_validation() {
        assert!(validate_email("user@example.com").is_ok());
        assert!(validate_email("user.name+tag@example.co.uk").is_ok());
        assert!(validate_email("invalid").is_err());
        assert!(validate_email("user@").is_err());
        assert!(validate_email("@example.com").is_err());
    }

    #[test]
    fn test_length_validation() {
        assert!(validate_length("abc", 1, 10).is_ok());
        assert!(validate_length("ab", 3, 10).is_err());
        assert!(validate_length("abcdefghijk", 1, 10).is_err());
    }

    #[test]
    fn test_unicode_length() {
        // "cafe" avec accent = 4 caracteres, potentiellement 5 bytes
        assert!(validate_length("cafe", 4, 10).is_ok());
        // Emoji
        assert!(validate_length("Hi!", 3, 10).is_ok());
    }

    #[test]
    fn test_pattern_validation() {
        assert!(validate_pattern("ABC123", r"^[A-Z]+[0-9]+$").is_ok());
        assert!(validate_pattern("abc", r"^[A-Z]+$").is_err());
    }

    #[test]
    fn test_range_validation() {
        assert!(validate_range(25, 18, 120).is_ok());
        assert!(validate_range(15, 18, 120).is_err());
        assert!(validate_range(150, 18, 120).is_err());
        assert!(validate_range(18, 18, 120).is_ok()); // Inclusive
        assert!(validate_range(120, 18, 120).is_ok()); // Inclusive
    }

    #[test]
    fn test_validator_builder() {
        let validator = Validator::<String>::new("username")
            .required()
            .min_length(3)
            .max_length(20);

        assert!(validator.validate(&"john".to_string()).is_ok());
        assert!(validator.validate(&"jo".to_string()).is_err());
        assert!(validator.validate(&"".to_string()).is_err());
    }

    #[test]
    fn test_form_validator_accumulates() {
        let username_v = Validator::<String>::new("username").required().min_length(3);
        let email_v = Validator::<String>::new("email").email();

        let mut form = FormValidator::new();
        form.field("username", &"ab".to_string(), &username_v)
            .field("email", &"invalid".to_string(), &email_v);

        let result = form.validate();
        assert!(result.is_err());
        let errors = result.unwrap_err();
        assert_eq!(errors.len(), 2); // Both fields have errors
    }

    #[test]
    fn test_user_registration_valid() {
        let user = UserRegistration {
            username: "johndoe".to_string(),
            email: "john@example.com".to_string(),
            password: "SecurePass123!".to_string(),
            age: Some(25),
        };
        assert!(user.validate().is_ok());
    }

    #[test]
    fn test_user_registration_invalid() {
        let user = UserRegistration {
            username: "jo".to_string(), // Too short
            email: "invalid".to_string(), // Invalid email
            password: "weak".to_string(), // Too short, no uppercase/number
            age: Some(15), // Under 18
        };
        let result = user.validate();
        assert!(result.is_err());
        let errors = result.unwrap_err();
        assert!(errors.len() >= 3); // Multiple errors accumulated
    }

    #[test]
    fn test_error_messages() {
        let err = validate_length("ab", 3, 10).unwrap_err();
        assert!(err.message.contains("3")); // Should mention minimum
        assert_eq!(err.code, ErrorCode::TooShort);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use regex::Regex;
use thiserror::Error;

pub type ValidationResult<T> = Result<T, Vec<ValidationError>>;

#[derive(Debug, Clone, PartialEq)]
pub struct ValidationError {
    pub field: String,
    pub code: ErrorCode,
    pub message: String,
    pub params: HashMap<String, String>,
}

impl ValidationError {
    pub fn new(field: &str, code: ErrorCode, message: &str) -> Self {
        Self {
            field: field.to_string(),
            code,
            message: message.to_string(),
            params: HashMap::new(),
        }
    }

    pub fn with_param(mut self, key: &str, value: &str) -> Self {
        self.params.insert(key.to_string(), value.to_string());
        self
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum ErrorCode {
    Required,
    TooShort,
    TooLong,
    InvalidFormat,
    InvalidEmail,
    InvalidUrl,
    OutOfRange,
    InvalidPattern,
    Custom(String),
}

pub trait Validate {
    fn validate(&self) -> ValidationResult<()>;
}

pub trait ValidationRule<T>: Send + Sync {
    fn validate(&self, value: &T, field: &str) -> Option<ValidationError>;
}

// Required rule
struct RequiredRule;
impl ValidationRule<String> for RequiredRule {
    fn validate(&self, value: &String, field: &str) -> Option<ValidationError> {
        if value.is_empty() {
            Some(ValidationError::new(field, ErrorCode::Required,
                &format!("{} is required", field)))
        } else {
            None
        }
    }
}

// Min length rule
struct MinLengthRule(usize);
impl ValidationRule<String> for MinLengthRule {
    fn validate(&self, value: &String, field: &str) -> Option<ValidationError> {
        // Use chars().count() for Unicode-aware length
        if value.chars().count() < self.0 {
            Some(ValidationError::new(field, ErrorCode::TooShort,
                &format!("{} must be at least {} characters", field, self.0))
                .with_param("min", &self.0.to_string()))
        } else {
            None
        }
    }
}

// Max length rule
struct MaxLengthRule(usize);
impl ValidationRule<String> for MaxLengthRule {
    fn validate(&self, value: &String, field: &str) -> Option<ValidationError> {
        if value.chars().count() > self.0 {
            Some(ValidationError::new(field, ErrorCode::TooLong,
                &format!("{} must be at most {} characters", field, self.0))
                .with_param("max", &self.0.to_string()))
        } else {
            None
        }
    }
}

// Email rule
struct EmailRule;
impl ValidationRule<String> for EmailRule {
    fn validate(&self, value: &String, field: &str) -> Option<ValidationError> {
        let email_regex = Regex::new(
            r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        ).unwrap();

        if !email_regex.is_match(value) {
            Some(ValidationError::new(field, ErrorCode::InvalidEmail,
                &format!("{} must be a valid email address", field)))
        } else {
            None
        }
    }
}

// Pattern rule
struct PatternRule(Regex);
impl ValidationRule<String> for PatternRule {
    fn validate(&self, value: &String, field: &str) -> Option<ValidationError> {
        if !self.0.is_match(value) {
            Some(ValidationError::new(field, ErrorCode::InvalidPattern,
                &format!("{} does not match required pattern", field)))
        } else {
            None
        }
    }
}

pub struct Validator<T> {
    rules: Vec<Box<dyn ValidationRule<T>>>,
    field_name: String,
}

impl Validator<String> {
    pub fn new(field_name: &str) -> Self {
        Self {
            rules: Vec::new(),
            field_name: field_name.to_string(),
        }
    }

    pub fn required(mut self) -> Self {
        self.rules.push(Box::new(RequiredRule));
        self
    }

    pub fn min_length(mut self, min: usize) -> Self {
        self.rules.push(Box::new(MinLengthRule(min)));
        self
    }

    pub fn max_length(mut self, max: usize) -> Self {
        self.rules.push(Box::new(MaxLengthRule(max)));
        self
    }

    pub fn email(mut self) -> Self {
        self.rules.push(Box::new(EmailRule));
        self
    }

    pub fn pattern(mut self, regex: &str) -> Self {
        if let Ok(re) = Regex::new(regex) {
            self.rules.push(Box::new(PatternRule(re)));
        }
        self
    }

    pub fn validate(&self, value: &String) -> ValidationResult<()> {
        let errors: Vec<ValidationError> = self.rules
            .iter()
            .filter_map(|rule| rule.validate(value, &self.field_name))
            .collect();

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

pub struct FormValidator {
    errors: Vec<ValidationError>,
}

impl FormValidator {
    pub fn new() -> Self {
        Self { errors: Vec::new() }
    }

    pub fn field(&mut self, _name: &str, value: &String, validator: &Validator<String>) -> &mut Self {
        if let Err(errs) = validator.validate(value) {
            self.errors.extend(errs);
        }
        self
    }

    pub fn validate(self) -> ValidationResult<()> {
        if self.errors.is_empty() {
            Ok(())
        } else {
            Err(self.errors)
        }
    }
}

pub fn validate_email(email: &str) -> Result<(), ValidationError> {
    let regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").unwrap();
    if regex.is_match(email) {
        Ok(())
    } else {
        Err(ValidationError::new("email", ErrorCode::InvalidEmail, "Invalid email format"))
    }
}

pub fn validate_length(s: &str, min: usize, max: usize) -> Result<(), ValidationError> {
    let len = s.chars().count();
    if len < min {
        Err(ValidationError::new("field", ErrorCode::TooShort,
            &format!("Must be at least {} characters", min)))
    } else if len > max {
        Err(ValidationError::new("field", ErrorCode::TooLong,
            &format!("Must be at most {} characters", max)))
    } else {
        Ok(())
    }
}

pub fn validate_pattern(s: &str, pattern: &str) -> Result<(), ValidationError> {
    let regex = Regex::new(pattern).map_err(|_|
        ValidationError::new("field", ErrorCode::InvalidPattern, "Invalid pattern"))?;
    if regex.is_match(s) {
        Ok(())
    } else {
        Err(ValidationError::new("field", ErrorCode::InvalidPattern, "Does not match pattern"))
    }
}

pub fn validate_range<T: PartialOrd + std::fmt::Display>(value: T, min: T, max: T) -> Result<(), ValidationError> {
    if value < min || value > max {
        Err(ValidationError::new("field", ErrorCode::OutOfRange,
            &format!("Must be between {} and {}", min, max)))
    } else {
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct UserRegistration {
    pub username: String,
    pub email: String,
    pub password: String,
    pub age: Option<u8>,
}

impl Validate for UserRegistration {
    fn validate(&self) -> ValidationResult<()> {
        let mut errors = Vec::new();

        // Username: required, 3-20 chars
        let username_validator = Validator::new("username")
            .required()
            .min_length(3)
            .max_length(20);
        if let Err(errs) = username_validator.validate(&self.username) {
            errors.extend(errs);
        }

        // Email: required, valid format
        let email_validator = Validator::new("email")
            .required()
            .email();
        if let Err(errs) = email_validator.validate(&self.email) {
            errors.extend(errs);
        }

        // Password: required, min 8 chars
        let password_validator = Validator::new("password")
            .required()
            .min_length(8);
        if let Err(errs) = password_validator.validate(&self.password) {
            errors.extend(errs);
        }

        // Age: if present, 18-120
        if let Some(age) = self.age {
            if let Err(err) = validate_range(age, 18, 120) {
                errors.push(ValidationError::new("age", ErrorCode::OutOfRange,
                    "Age must be between 18 and 120"));
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}
```

### 4.9 spec.json

```json
{
  "name": "form_validation_framework",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isole - Form Validation",
  "tags": ["web", "validation", "forms", "security", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "Validator",
    "prototype": "impl Validator<T>",
    "return_type": "ValidationResult<()>",
    "parameters": [
      {"name": "value", "type": "&T"},
      {"name": "rules", "type": "Vec<ValidationRule>"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "unicode_length",
        "input": "cafe",
        "expected_length": 4,
        "is_trap": true,
        "trap_explanation": "Utiliser chars().count() pas len()"
      },
      {
        "name": "email_edge",
        "input": "a@b",
        "expected": "Err(InvalidEmail)",
        "is_trap": true,
        "trap_explanation": "Domaine trop court"
      },
      {
        "name": "accumulate_errors",
        "description": "Multiple invalid fields",
        "expected": "All errors returned",
        "is_trap": true,
        "trap_explanation": "Ne pas short-circuit"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": ["random_strings", "unicode_strings", "email_variants"]
    }
  },

  "norm": {
    "allowed_functions": ["regex::Regex", "chars", "count"],
    "forbidden_functions": ["unsafe"],
    "forbidden_crates": ["validator"],
    "check_security": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Utilise len() au lieu de chars().count() */
fn validate_min_length(value: &str, min: usize) -> bool {
    value.len() >= min  // MUTANT: bytes au lieu de caracteres
}
// Pourquoi c'est faux : "cafe" a 4 chars mais 5 bytes
// Ce qui etait pense : "len() c'est la longueur"

/* Mutant B (Safety) : Email regex trop permissive */
fn validate_email(email: &str) -> bool {
    email.contains('@')  // MUTANT: pas de validation domaine
}
// Pourquoi c'est faux : "user@" serait valide
// Ce qui etait pense : "Le @ suffit pour un email"

/* Mutant C (Logic) : Short-circuit au lieu d'accumuler */
fn validate_form(fields: &[&str]) -> Result<(), ValidationError> {
    for field in fields {
        if let Err(e) = validate_field(field) {
            return Err(e);  // MUTANT: retourne a la premiere erreur
        }
    }
    Ok(())
}
// Pourquoi c'est faux : L'utilisateur ne voit qu'une erreur a la fois
// Ce qui etait pense : "Plus performant de s'arreter tot"

/* Mutant D (Edge) : Range non inclusive */
fn validate_range(value: i32, min: i32, max: i32) -> bool {
    value > min && value < max  // MUTANT: exclut les bornes
}
// Pourquoi c'est faux : 18 ne serait pas valide pour range 18-120
// Ce qui etait pense : "Between signifie entre, pas aux bornes"

/* Mutant E (Return) : Ignore les erreurs des champs optionnels */
fn validate_optional<T>(value: &Option<T>) -> ValidationResult<()> {
    Ok(())  // MUTANT: ne valide pas si present
}
// Pourquoi c'est faux : Un age de 5 serait accepte
// Ce qui etait pense : "Optionnel = pas de validation"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Validation declarative** : Regles composables et reutilisables
2. **Accumulation d'erreurs** : Pattern Fail Complete pour UX
3. **Unicode-awareness** : Gestion correcte des caracteres multi-bytes
4. **Type safety** : Generiques et traits pour validation typee
5. **Builder pattern** : API fluide pour construction de validateurs

### 5.2 LDA - Traduction Litterale

```
FONCTION validate_form QUI RETOURNE UN RESULTAT
DEBUT FONCTION
    DECLARER errors COMME LISTE VIDE DE ValidationError

    POUR CHAQUE champ DANS formulaire FAIRE
        SI validator.validate(champ) ECHOUE ALORS
            AJOUTER erreurs A errors
        FIN SI
    FIN POUR

    SI errors EST VIDE ALORS
        RETOURNER Ok
    SINON
        RETOURNER Err(errors)
    FIN SI
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                    FORM VALIDATION PIPELINE

    Input Form               Validators              Result
    +-------------+     +------------------+     +-------------+
    | username: x |---->| RequiredRule     |     |             |
    | email: y    |     | MinLengthRule(3) |---->| Ok(())      |
    | password: z |     | MaxLengthRule(20)|     |     or      |
    | age: n      |     | EmailRule        |     | Err([...])  |
    +-------------+     | PatternRule      |     +-------------+
                        | RangeRule        |
                        +------------------+
                               |
                               v
                    +--------------------+
                    | Accumulate Errors  |
                    | (don't short-circ) |
                    +--------------------+
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **bytes vs chars** | `len()` compte les bytes | Utiliser `chars().count()` |
| **Email simple** | Juste verifier `@` | Regex complete avec domaine |
| **Short-circuit** | S'arreter a la 1ere erreur | Collecter toutes les erreurs |
| **Range exclusive** | `<` au lieu de `<=` | Bornes inclusives |
| **Optional ignored** | Ne pas valider si Some | Valider la valeur interne |

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | bytes vs chars | Emojis comptent 4x | `chars().count()` |
| 2 | Email permissif | "a@b" accepte | Regex avec domaine complet |
| 3 | Short-circuit | 1 seule erreur affichee | Accumuler toutes les erreurs |
| 4 | Range exclusive | 18 refuse pour 18-120 | `>=` et `<=` |
| 5 | Optional bypass | Age 5 accepte | Valider si `Some(v)` |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la bonne facon de compter la longueur d'une chaine Unicode en Rust ?**

A) `s.len()`
B) `s.chars().count()`
C) `s.bytes().count()`
D) `s.as_bytes().len()`

**Reponse : B**

*Explication : `chars().count()` compte les caracteres Unicode (code points), tandis que `len()` compte les bytes.*

---

### Question 2
**Pourquoi accumuler toutes les erreurs de validation ?**

A) C'est plus performant
B) C'est plus simple a implementer
C) Meilleure experience utilisateur
D) Requis par les standards HTTP

**Reponse : C**

*Explication : L'utilisateur peut corriger toutes les erreurs en une fois au lieu de soumettre plusieurs fois.*

---

### Question 3
**Quelle regex est la plus appropriee pour valider un email ?**

A) `.*@.*`
B) `.+@.+`
C) `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
D) `\w+@\w+`

**Reponse : C**

*Explication : Elle verifie le format complet avec domaine et TLD d'au moins 2 caracteres.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | form_validation_framework |
| **Module** | 5.3.21 - Web Form Processing |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x3 |
| **Concepts cles** | Validation, Unicode, Accumulation d'erreurs |
| **Piege principal** | bytes vs chars pour longueurs Unicode |
| **Prerequis valide** | Traits, generiques, Result/Option |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.3.21-a-form-validation-framework",
    "generated_at": "2026-01-16T10:00:00Z",

    "metadata": {
      "exercise_id": "5.3.21-a",
      "exercise_name": "form_validation_framework",
      "module": "5.3.21",
      "module_name": "Web Form Processing",
      "concept": "a",
      "concept_name": "Form Validation Framework",
      "type": "code",
      "tier": 1,
      "phase": 5,
      "difficulty": 7,
      "language": "rust",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_bytes.rs": "/* Section 4.10 */",
      "mutants/mutant_b_email.rs": "/* Section 4.10 */",
      "mutants/mutant_c_shortcircuit.rs": "/* Section 4.10 */",
      "mutants/mutant_d_range.rs": "/* Section 4.10 */",
      "mutants/mutant_e_optional.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.rs"],
      "expected_fail": [
        "mutants/mutant_a_bytes.rs",
        "mutants/mutant_b_email.rs",
        "mutants/mutant_c_shortcircuit.rs",
        "mutants/mutant_d_range.rs",
        "mutants/mutant_e_optional.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Trust no input, validate everything"*
*Exercise Quality Score: 95/100*
