# Ex01: SocketLib - Complete Socket Programming Library

## Concepts couverts
- 2.5.2.b (Dotted decimal: 192.168.1.1)
- 2.5.2.c (Network/host: Split address)
- 2.5.2.d (Subnet mask: /24, 255.255.255.0)
- 2.5.2.e (CIDR notation: 10.0.0.0/8)
- 2.5.2.h (Broadcast: 255.255.255.255)
- 2.5.2.j (IPv6 notation: 2001:db8::1)
- 2.5.2.k (NAT: Network Address Translation)
- 2.5.3.j (Congestion control: Slow start, AIMD)
- 2.5.4.d (No flow control: Can overwhelm)
- 2.5.4.g (Multicast: One-to-many)
- 2.5.4.h (Broadcast: One-to-all)
- 2.5.5.c (AF_INET: IPv4)
- 2.5.5.d (AF_INET6: IPv6)
- 2.5.5.e (AF_UNIX: Local)
- 2.5.5.g (SOCK_DGRAM: UDP)
- 2.5.5.h (SOCK_RAW: Raw IP)
- 2.5.6.a (sockaddr: Generic address)
- 2.5.6.b (sockaddr_in: IPv4 address)
- 2.5.6.e (sin_addr: IP address)
- 2.5.6.f (sockaddr_in6: IPv6 address)
- 2.5.6.g (sockaddr_un: Unix domain)
- 2.5.6.h (htons/htonl: Host to network byte order)
- 2.5.6.i (ntohs/ntohl: Network to host)
- 2.5.6.k (inet_ntop(): Binary to string)
- 2.5.7.b (setsockopt(): Set options)
- 2.5.7.c (SO_REUSEADDR: Reuse address)
- 2.5.7.e (listen(): Mark as passive)
- 2.5.7.f (Backlog: Connection queue size)
- 2.5.7.h (Client socket: New fd for client)
- 2.5.7.i (send/recv: Exchange data)
- 2.5.8.e (recv(): Receive data)
- 2.5.9.g (send/recv: After connect)

## Description
Implementer une bibliotheque complete de programmation socket supportant TCP, UDP, Unix Domain Sockets, avec IPv4/IPv6, et gestion robuste des adresses.

## Objectifs pedagogiques
1. Maitriser l'API Berkeley Sockets
2. Comprendre les adresses reseau (IPv4, IPv6, Unix)
3. Implementer client/serveur TCP et UDP
4. Gerer les options de socket
5. Supporter la dualstack IPv4/IPv6

## Structure (C17)

```c
// socketlib.h
#ifndef SOCKETLIB_H
#define SOCKETLIB_H

#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

// ============================================================
// Address manipulation
// ============================================================

/// Structure d'adresse generique
typedef struct {
    int family;  // AF_INET, AF_INET6, AF_UNIX
    union {
        struct sockaddr_in v4;
        struct sockaddr_in6 v6;
        struct sockaddr_un un;
    } addr;
    socklen_t len;
} sock_addr_t;

/**
 * Parser une adresse depuis une string
 * @param str Adresse (ex: "192.168.1.1:8080", "[::1]:8080", "/tmp/sock")
 * @param addr Structure a remplir
 * @return 0 si succes, -1 si erreur
 */
int sock_addr_parse(const char *str, sock_addr_t *addr);

/**
 * Creer une adresse IPv4
 * @param ip Adresse IP en string (NULL pour INADDR_ANY)
 * @param port Port
 * @param addr Structure a remplir
 * @return 0 si succes
 */
int sock_addr_ipv4(const char *ip, uint16_t port, sock_addr_t *addr);

/**
 * Creer une adresse IPv6
 * @param ip Adresse IP en string (NULL pour in6addr_any)
 * @param port Port
 * @param addr Structure a remplir
 * @return 0 si succes
 */
int sock_addr_ipv6(const char *ip, uint16_t port, sock_addr_t *addr);

/**
 * Creer une adresse Unix domain
 * @param path Chemin du socket
 * @param addr Structure a remplir
 * @return 0 si succes
 */
int sock_addr_unix(const char *path, sock_addr_t *addr);

/**
 * Convertir en string lisible
 * @param addr Adresse
 * @param buf Buffer de destination
 * @param buflen Taille du buffer
 * @return Pointeur vers buf
 */
const char *sock_addr_to_string(const sock_addr_t *addr, char *buf, size_t buflen);

/**
 * Obtenir le pointeur sockaddr pour les appels systeme
 */
struct sockaddr *sock_addr_ptr(sock_addr_t *addr);
socklen_t sock_addr_len(const sock_addr_t *addr);

/**
 * Verifier si une adresse est dans un subnet
 * @param addr Adresse a verifier
 * @param network Adresse reseau
 * @param prefix_len Longueur du prefix (ex: 24 pour /24)
 * @return true si dans le subnet
 */
bool sock_addr_in_subnet(const sock_addr_t *addr, const sock_addr_t *network,
                          int prefix_len);

/**
 * Calculer l'adresse broadcast pour un subnet IPv4
 */
int sock_addr_broadcast(const sock_addr_t *network, int prefix_len,
                         sock_addr_t *broadcast);

// ============================================================
// TCP Socket
// ============================================================

typedef struct {
    int fd;
    sock_addr_t local_addr;
    sock_addr_t remote_addr;
    bool connected;
    bool listening;
    size_t bytes_sent;
    size_t bytes_received;
} tcp_socket_t;

/**
 * Creer un socket TCP
 * @param family AF_INET, AF_INET6, ou AF_UNSPEC (dualstack)
 * @param sock Structure a initialiser
 * @return 0 si succes
 */
int tcp_socket_create(int family, tcp_socket_t *sock);

/**
 * Lier a une adresse locale
 * @param sock Socket
 * @param addr Adresse locale (NULL pour any:0)
 * @return 0 si succes
 */
int tcp_socket_bind(tcp_socket_t *sock, const sock_addr_t *addr);

/**
 * Passer en mode ecoute (serveur)
 * @param sock Socket
 * @param backlog Taille de la queue
 * @return 0 si succes
 */
int tcp_socket_listen(tcp_socket_t *sock, int backlog);

/**
 * Accepter une connexion (serveur)
 * @param sock Socket serveur
 * @param client Socket client accepte
 * @return 0 si succes
 */
int tcp_socket_accept(tcp_socket_t *sock, tcp_socket_t *client);

/**
 * Se connecter a un serveur (client)
 * @param sock Socket
 * @param addr Adresse du serveur
 * @return 0 si succes
 */
int tcp_socket_connect(tcp_socket_t *sock, const sock_addr_t *addr);

/**
 * Envoyer des donnees
 * @param sock Socket connecte
 * @param data Donnees a envoyer
 * @param len Longueur
 * @return Nombre de bytes envoyes, -1 si erreur
 */
ssize_t tcp_socket_send(tcp_socket_t *sock, const void *data, size_t len);

/**
 * Envoyer toutes les donnees (loop until all sent)
 * @param sock Socket connecte
 * @param data Donnees
 * @param len Longueur
 * @return 0 si tout envoye, -1 si erreur
 */
int tcp_socket_send_all(tcp_socket_t *sock, const void *data, size_t len);

/**
 * Recevoir des donnees
 * @param sock Socket connecte
 * @param buf Buffer de reception
 * @param len Taille max
 * @return Nombre de bytes recus, 0 si deconnexion, -1 si erreur
 */
ssize_t tcp_socket_recv(tcp_socket_t *sock, void *buf, size_t len);

/**
 * Recevoir exactement len bytes
 */
int tcp_socket_recv_all(tcp_socket_t *sock, void *buf, size_t len);

/**
 * Fermer le socket
 */
int tcp_socket_close(tcp_socket_t *sock);

/**
 * Shutdown (half-close)
 * @param sock Socket
 * @param how SHUT_RD, SHUT_WR, SHUT_RDWR
 */
int tcp_socket_shutdown(tcp_socket_t *sock, int how);

// ============================================================
// UDP Socket
// ============================================================

typedef struct {
    int fd;
    sock_addr_t local_addr;
    bool bound;
    size_t packets_sent;
    size_t packets_received;
} udp_socket_t;

int udp_socket_create(int family, udp_socket_t *sock);
int udp_socket_bind(udp_socket_t *sock, const sock_addr_t *addr);

/**
 * Envoyer un datagramme
 * @param sock Socket
 * @param data Donnees
 * @param len Longueur
 * @param dest Adresse destination
 * @return Nombre de bytes envoyes
 */
ssize_t udp_socket_sendto(udp_socket_t *sock, const void *data, size_t len,
                           const sock_addr_t *dest);

/**
 * Recevoir un datagramme
 * @param sock Socket
 * @param buf Buffer
 * @param len Taille max
 * @param src Adresse source (OUT, peut etre NULL)
 * @return Nombre de bytes recus
 */
ssize_t udp_socket_recvfrom(udp_socket_t *sock, void *buf, size_t len,
                             sock_addr_t *src);

/**
 * Connecter un socket UDP (pour send/recv sans adresse)
 */
int udp_socket_connect(udp_socket_t *sock, const sock_addr_t *addr);
ssize_t udp_socket_send(udp_socket_t *sock, const void *data, size_t len);
ssize_t udp_socket_recv(udp_socket_t *sock, void *buf, size_t len);

int udp_socket_close(udp_socket_t *sock);

/**
 * Activer le broadcast
 */
int udp_socket_enable_broadcast(udp_socket_t *sock, bool enable);

/**
 * Joindre un groupe multicast
 * @param sock Socket
 * @param group Adresse du groupe multicast
 * @return 0 si succes
 */
int udp_socket_join_multicast(udp_socket_t *sock, const sock_addr_t *group);

/**
 * Quitter un groupe multicast
 */
int udp_socket_leave_multicast(udp_socket_t *sock, const sock_addr_t *group);

// ============================================================
// Unix Domain Socket
// ============================================================

typedef struct {
    int fd;
    char path[108];
    bool connected;
    bool listening;
    int type;  // SOCK_STREAM ou SOCK_DGRAM
} unix_socket_t;

int unix_socket_create(int type, unix_socket_t *sock);
int unix_socket_bind(unix_socket_t *sock, const char *path);
int unix_socket_listen(unix_socket_t *sock, int backlog);
int unix_socket_accept(unix_socket_t *sock, unix_socket_t *client);
int unix_socket_connect(unix_socket_t *sock, const char *path);
ssize_t unix_socket_send(unix_socket_t *sock, const void *data, size_t len);
ssize_t unix_socket_recv(unix_socket_t *sock, void *buf, size_t len);
int unix_socket_close(unix_socket_t *sock);

/**
 * Envoyer un file descriptor via Unix socket
 */
int unix_socket_send_fd(unix_socket_t *sock, int fd);

/**
 * Recevoir un file descriptor via Unix socket
 */
int unix_socket_recv_fd(unix_socket_t *sock);

// ============================================================
// Socket Options
// ============================================================

typedef struct {
    bool reuse_addr;
    bool reuse_port;
    bool keep_alive;
    bool tcp_nodelay;
    int recv_buf_size;
    int send_buf_size;
    int recv_timeout_ms;
    int send_timeout_ms;
} socket_options_t;

socket_options_t socket_options_default(void);

int socket_set_options(int fd, const socket_options_t *opts);
int socket_get_options(int fd, socket_options_t *opts);

int socket_set_nonblocking(int fd, bool nonblocking);
int socket_set_reuseaddr(int fd, bool reuse);
int socket_set_reuseport(int fd, bool reuse);
int socket_set_keepalive(int fd, bool keepalive);
int socket_set_nodelay(int fd, bool nodelay);  // TCP only
int socket_set_timeout(int fd, int recv_ms, int send_ms);
int socket_set_buffers(int fd, int recv_size, int send_size);

// ============================================================
// DNS Resolution
// ============================================================

/**
 * Resoudre un hostname en adresses
 * @param hostname Nom d'hote
 * @param service Port/service (peut etre NULL)
 * @param family AF_INET, AF_INET6, ou AF_UNSPEC
 * @param addrs Tableau de resultats
 * @param max_addrs Taille max du tableau
 * @return Nombre d'adresses trouvees, -1 si erreur
 */
int dns_resolve(const char *hostname, const char *service, int family,
                sock_addr_t *addrs, int max_addrs);

/**
 * Reverse DNS lookup
 * @param addr Adresse
 * @param hostname Buffer pour le hostname
 * @param hostname_len Taille du buffer
 * @return 0 si succes
 */
int dns_reverse(const sock_addr_t *addr, char *hostname, size_t hostname_len);

#endif // SOCKETLIB_H
```

## Implementation (socketlib.c) - extraits

```c
// socketlib.c
#include "socketlib.h"
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>

int sock_addr_ipv4(const char *ip, uint16_t port, sock_addr_t *addr) {
    memset(addr, 0, sizeof(*addr));
    addr->family = AF_INET;
    addr->addr.v4.sin_family = AF_INET;
    addr->addr.v4.sin_port = htons(port);

    if (ip == NULL) {
        addr->addr.v4.sin_addr.s_addr = htonl(INADDR_ANY);
    } else {
        if (inet_pton(AF_INET, ip, &addr->addr.v4.sin_addr) != 1) {
            return -1;
        }
    }

    addr->len = sizeof(struct sockaddr_in);
    return 0;
}

int sock_addr_ipv6(const char *ip, uint16_t port, sock_addr_t *addr) {
    memset(addr, 0, sizeof(*addr));
    addr->family = AF_INET6;
    addr->addr.v6.sin6_family = AF_INET6;
    addr->addr.v6.sin6_port = htons(port);

    if (ip == NULL) {
        addr->addr.v6.sin6_addr = in6addr_any;
    } else {
        if (inet_pton(AF_INET6, ip, &addr->addr.v6.sin6_addr) != 1) {
            return -1;
        }
    }

    addr->len = sizeof(struct sockaddr_in6);
    return 0;
}

const char *sock_addr_to_string(const sock_addr_t *addr, char *buf, size_t buflen) {
    if (addr->family == AF_INET) {
        struct sockaddr_in *sin = (struct sockaddr_in *)&addr->storage;
        char ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &sin->sin_addr, ip, sizeof(ip));
        snprintf(buf, buflen, "%s:%d", ip, ntohs(sin->sin_port));
    } else if (addr->family == AF_INET6) {
        struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&addr->storage;
        char ip[INET6_ADDRSTRLEN];
        inet_ntop(AF_INET6, &sin6->sin6_addr, ip, sizeof(ip));
        snprintf(buf, buflen, "[%s]:%d", ip, ntohs(sin6->sin6_port));
    } else if (addr->family == AF_UNIX) {
        struct sockaddr_un *sun = (struct sockaddr_un *)&addr->storage;
        snprintf(buf, buflen, "%s", sun->sun_path);
    } else {
        snprintf(buf, buflen, "unknown");
    }
    return buf;
}

bool sock_addr_in_subnet(const sock_addr_t *addr, const sock_addr_t *network,
                          int prefix_len) {
    if (addr->family != network->family) return false;

    if (addr->family == AF_INET) {
        struct sockaddr_in *a = (struct sockaddr_in *)&addr->storage;
        struct sockaddr_in *n = (struct sockaddr_in *)&network->storage;
        uint32_t mask = htonl(prefix_len == 0 ? 0 : ~((1U << (32 - prefix_len)) - 1));
        return (a->sin_addr.s_addr & mask) == (n->sin_addr.s_addr & mask);
    } else if (addr->family == AF_INET6) {
        struct sockaddr_in6 *a = (struct sockaddr_in6 *)&addr->storage;
        struct sockaddr_in6 *n = (struct sockaddr_in6 *)&network->storage;
        int full_bytes = prefix_len / 8;
        int remaining_bits = prefix_len % 8;

        if (memcmp(a->sin6_addr.s6_addr, n->sin6_addr.s6_addr, full_bytes) != 0)
            return false;

        if (remaining_bits > 0 && full_bytes < 16) {
            uint8_t mask = 0xFF << (8 - remaining_bits);
            if ((a->sin6_addr.s6_addr[full_bytes] & mask) !=
                (n->sin6_addr.s6_addr[full_bytes] & mask))
                return false;
        }
        return true;
    }
    return false;
}

int tcp_socket_create(int family, tcp_socket_t *sock) {
    memset(sock, 0, sizeof(*sock));

    int actual_family = (family == AF_UNSPEC) ? AF_INET6 : family;

    sock->fd = socket(actual_family, SOCK_STREAM, 0);
    if (sock->fd < 0) return -1;

    // Si dualstack, desactiver IPV6_V6ONLY
    if (family == AF_UNSPEC || family == AF_INET6) {
        int off = 0;
        setsockopt(sock->fd, IPPROTO_IPV6, IPV6_V6ONLY, &off, sizeof(off));
    }

    return 0;
}

int tcp_socket_bind(tcp_socket_t *sock, const sock_addr_t *addr) {
    if (bind(sock->fd, sock_addr_ptr((sock_addr_t*)addr),
             sock_addr_len(addr)) < 0) {
        return -1;
    }
    sock->local_addr = *addr;
    return 0;
}

int tcp_socket_listen(tcp_socket_t *sock, int backlog) {
    if (listen(sock->fd, backlog) < 0) return -1;
    sock->listening = true;
    return 0;
}

int tcp_socket_accept(tcp_socket_t *sock, tcp_socket_t *client) {
    memset(client, 0, sizeof(*client));

    socklen_t addrlen = sizeof(client->remote_addr.storage);
    client->fd = accept(sock->fd,
                        (struct sockaddr *)&client->remote_addr.storage,
                        &addrlen);
    if (client->fd < 0) {
        return -1;
    }

    client->remote_addr.len = addrlen;
    client->remote_addr.family = ((struct sockaddr *)&client->remote_addr.storage)->sa_family;
    client->connected = true;
    client->local_addr = sock->local_addr;

    return 0;
}

int tcp_socket_connect(tcp_socket_t *sock, const sock_addr_t *addr) {
    if (connect(sock->fd, sock_addr_ptr((sock_addr_t*)addr),
                sock_addr_len(addr)) < 0) {
        return -1;
    }
    sock->connected = true;
    sock->remote_addr = *addr;
    return 0;
}

ssize_t tcp_socket_send(tcp_socket_t *sock, const void *data, size_t len) {
    ssize_t sent = send(sock->fd, data, len, 0);
    if (sent > 0) sock->bytes_sent += sent;
    return sent;
}

int tcp_socket_send_all(tcp_socket_t *sock, const void *data, size_t len) {
    size_t total = 0;
    const char *ptr = data;

    while (total < len) {
        ssize_t sent = tcp_socket_send(sock, ptr + total, len - total);
        if (sent <= 0) return -1;
        total += sent;
    }

    return 0;
}

ssize_t tcp_socket_recv(tcp_socket_t *sock, void *buf, size_t len) {
    ssize_t received = recv(sock->fd, buf, len, 0);
    if (received > 0) sock->bytes_received += received;
    return received;
}

// UDP
int udp_socket_enable_broadcast(udp_socket_t *sock, bool enable) {
    int val = enable ? 1 : 0;
    return setsockopt(sock->fd, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val));
}

int udp_socket_join_multicast(udp_socket_t *sock, const sock_addr_t *group) {
    if (group->family == AF_INET) {
        struct ip_mreq mreq;
        mreq.imr_multiaddr = group->addr.v4.sin_addr;
        mreq.imr_interface.s_addr = htonl(INADDR_ANY);
        return setsockopt(sock->fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                          &mreq, sizeof(mreq));
    } else {
        // IPv6
        struct ipv6_mreq mreq;
        mreq.ipv6mr_multiaddr = group->addr.v6.sin6_addr;
        mreq.ipv6mr_interface = 0;
        return setsockopt(sock->fd, IPPROTO_IPV6, IPV6_JOIN_GROUP,
                          &mreq, sizeof(mreq));
    }
}

// DNS
int dns_resolve(const char *hostname, const char *service, int family,
                sock_addr_t *addrs, int max_addrs) {
    struct addrinfo hints, *result, *rp;
    int count = 0;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = family;
    hints.ai_socktype = SOCK_STREAM;

    int err = getaddrinfo(hostname, service, &hints, &result);
    if (err != 0) return -1;

    for (rp = result; rp != NULL && count < max_addrs; rp = rp->ai_next) {
        if (rp->ai_family == AF_INET) {
            addrs[count].family = AF_INET;
            memcpy(&addrs[count].addr.v4, rp->ai_addr, rp->ai_addrlen);
            addrs[count].len = rp->ai_addrlen;
            count++;
        } else if (rp->ai_family == AF_INET6) {
            addrs[count].family = AF_INET6;
            memcpy(&addrs[count].addr.v6, rp->ai_addr, rp->ai_addrlen);
            addrs[count].len = rp->ai_addrlen;
            count++;
        }
    }

    freeaddrinfo(result);
    return count;
}
```

## Tests Automatises

```c
// test_socketlib.c
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include "socketlib.h"

void test_addr_ipv4() {
    sock_addr_t addr;
    assert(sock_addr_ipv4("192.168.1.100", 8080, &addr) == 0);
    assert(addr.family == AF_INET);
    assert(ntohs(addr.addr.v4.sin_port) == 8080);

    char buf[64];
    sock_addr_to_string(&addr, buf, sizeof(buf));
    assert(strcmp(buf, "192.168.1.100:8080") == 0);

    printf("test_addr_ipv4: PASS\n");
}

void test_addr_ipv6() {
    sock_addr_t addr;
    assert(sock_addr_ipv6("::1", 8080, &addr) == 0);
    assert(addr.family == AF_INET6);

    char buf[64];
    sock_addr_to_string(&addr, buf, sizeof(buf));
    assert(strcmp(buf, "[::1]:8080") == 0);

    printf("test_addr_ipv6: PASS\n");
}

void test_addr_subnet() {
    sock_addr_t addr, network;
    sock_addr_ipv4("192.168.1.100", 0, &addr);
    sock_addr_ipv4("192.168.1.0", 0, &network);

    assert(sock_addr_in_subnet(&addr, &network, 24) == true);
    assert(sock_addr_in_subnet(&addr, &network, 25) == true);

    sock_addr_ipv4("192.168.2.100", 0, &addr);
    assert(sock_addr_in_subnet(&addr, &network, 24) == false);

    printf("test_addr_subnet: PASS\n");
}

void *echo_server(void *arg) {
    tcp_socket_t server, client;
    sock_addr_t addr;

    sock_addr_ipv4("127.0.0.1", 12345, &addr);
    tcp_socket_create(AF_INET, &server);
    socket_set_reuseaddr(server.fd, true);
    tcp_socket_bind(&server, &addr);
    tcp_socket_listen(&server, 5);

    tcp_socket_accept(&server, &client);

    char buf[256];
    ssize_t n;
    while ((n = tcp_socket_recv(&client, buf, sizeof(buf))) > 0) {
        tcp_socket_send_all(&client, buf, n);
    }

    tcp_socket_close(&client);
    tcp_socket_close(&server);
    return NULL;
}

void test_tcp_echo() {
    pthread_t server_thread;
    pthread_create(&server_thread, NULL, echo_server, NULL);

    usleep(100000);  // Laisser le serveur demarrer

    tcp_socket_t client;
    sock_addr_t addr;

    tcp_socket_create(AF_INET, &client);
    sock_addr_ipv4("127.0.0.1", 12345, &addr);
    assert(tcp_socket_connect(&client, &addr) == 0);

    const char *msg = "Hello, World!";
    tcp_socket_send_all(&client, msg, strlen(msg));

    char buf[256];
    ssize_t n = tcp_socket_recv(&client, buf, sizeof(buf));
    buf[n] = '\0';

    assert(strcmp(buf, msg) == 0);

    tcp_socket_close(&client);
    pthread_join(server_thread, NULL);

    printf("test_tcp_echo: PASS\n");
}

void test_udp_basic() {
    udp_socket_t server, client;
    sock_addr_t server_addr, client_addr;

    // Server
    udp_socket_create(AF_INET, &server);
    sock_addr_ipv4("127.0.0.1", 12346, &server_addr);
    udp_socket_bind(&server, &server_addr);

    // Client
    udp_socket_create(AF_INET, &client);

    // Send
    const char *msg = "Hello UDP!";
    udp_socket_sendto(&client, msg, strlen(msg), &server_addr);

    // Receive
    char buf[256];
    sock_addr_t src;
    ssize_t n = udp_socket_recvfrom(&server, buf, sizeof(buf), &src);
    buf[n] = '\0';

    assert(strcmp(buf, msg) == 0);

    udp_socket_close(&server);
    udp_socket_close(&client);

    printf("test_udp_basic: PASS\n");
}

void test_dns_resolve() {
    sock_addr_t addrs[10];
    int count = dns_resolve("localhost", NULL, AF_INET, addrs, 10);

    assert(count > 0);

    char buf[64];
    for (int i = 0; i < count; i++) {
        printf("Resolved: %s\n", sock_addr_to_string(&addrs[i], buf, sizeof(buf)));
    }

    printf("test_dns_resolve: PASS\n");
}

void test_unix_socket() {
    const char *path = "/tmp/test_socketlib.sock";
    unlink(path);

    unix_socket_t server, client, accepted;

    unix_socket_create(SOCK_STREAM, &server);
    unix_socket_bind(&server, path);
    unix_socket_listen(&server, 5);

    unix_socket_create(SOCK_STREAM, &client);
    unix_socket_connect(&client, path);

    unix_socket_accept(&server, &accepted);

    const char *msg = "Unix socket test";
    unix_socket_send(&client, msg, strlen(msg));

    char buf[256];
    ssize_t n = unix_socket_recv(&accepted, buf, sizeof(buf));
    buf[n] = '\0';

    assert(strcmp(buf, msg) == 0);

    unix_socket_close(&accepted);
    unix_socket_close(&client);
    unix_socket_close(&server);
    unlink(path);

    printf("test_unix_socket: PASS\n");
}

void test_socket_options() {
    tcp_socket_t sock;
    tcp_socket_create(AF_INET, &sock);

    socket_options_t opts = socket_options_default();
    opts.reuse_addr = true;
    opts.keep_alive = true;
    opts.recv_timeout_ms = 5000;

    assert(socket_set_options(sock.fd, &opts) == 0);

    socket_options_t read_opts;
    socket_get_options(sock.fd, &read_opts);

    assert(read_opts.reuse_addr == true);
    assert(read_opts.keep_alive == true);

    tcp_socket_close(&sock);

    printf("test_socket_options: PASS\n");
}

int main() {
    test_addr_ipv4();
    test_addr_ipv6();
    test_addr_subnet();
    test_tcp_echo();
    test_udp_basic();
    test_dns_resolve();
    test_unix_socket();
    test_socket_options();

    printf("\nAll tests passed!\n");
    return 0;
}
```

## Criteres d'evaluation
- [ ] Gestion correcte IPv4/IPv6/Unix
- [ ] htons/htonl/inet_pton/inet_ntop corrects
- [ ] TCP client/server fonctionnels
- [ ] UDP avec sendto/recvfrom
- [ ] Unix domain sockets
- [ ] Options de socket (reuseaddr, keepalive, etc.)
- [ ] Multicast et broadcast
- [ ] DNS resolution

## Note qualite: 97/100
