# Ex05: Network Protocols - ARP, ICMP, DHCP, DNS

## Concepts couverts
- 2.5.21.b (IP to MAC: Mapping)
- 2.5.21.d (ARP reply: Unicast response)
- 2.5.21.f (ARP spoofing: Security issue)
- 2.5.21.g (Gratuitous ARP: Announcement)
- 2.5.22.a (ICMP: Internet Control Message Protocol)
- 2.5.22.b (Echo request: Ping)
- 2.5.22.c (Echo reply: Pong)
- 2.5.22.d (Destination unreachable: Error message)
- 2.5.22.e (Time exceeded: TTL expired)
- 2.5.22.g (Path MTU discovery: Using ICMP)
- 2.5.23.a (DHCP: Dynamic Host Configuration)
- 2.5.23.b (DORA: Discover, Offer, Request, Acknowledge)
- 2.5.23.d (Renewal: Extend lease)
- 2.5.23.f (DHCP relay: Across subnets)
- 2.5.24.c (DNS message: Header, question, answer)
- 2.5.24.i (DNS over UDP/TCP: Port 53)

## Description
Implementer des simulateurs et analyseurs pour les protocoles reseau fondamentaux: ARP, ICMP, DHCP et DNS. Ce projet permet de comprendre en profondeur le fonctionnement de ces protocoles de la couche 2 a la couche 7.

## Objectifs pedagogiques
1. Comprendre le protocole ARP et la resolution d'adresses
2. Maitriser les differents types de messages ICMP
3. Implementer un client DHCP basique
4. Parser et construire des messages DNS
5. Comprendre les implications de securite de chaque protocole

## Structure (Rust 2024)

```rust
// src/lib.rs
use std::net::{Ipv4Addr, UdpSocket};
use std::time::Duration;

// ============================================================
// ARP Protocol
// ============================================================

pub mod arp {
    use super::*;

    /// Hardware types
    pub const HARDWARE_ETHERNET: u16 = 1;

    /// Protocol types
    pub const PROTOCOL_IPV4: u16 = 0x0800;

    /// ARP operations
    pub const ARP_REQUEST: u16 = 1;
    pub const ARP_REPLY: u16 = 2;
    pub const RARP_REQUEST: u16 = 3;
    pub const RARP_REPLY: u16 = 4;

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct MacAddress(pub [u8; 6]);

    impl MacAddress {
        pub const BROADCAST: Self = Self([0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
        pub const ZERO: Self = Self([0, 0, 0, 0, 0, 0]);

        pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
            if bytes.len() >= 6 {
                let mut mac = [0u8; 6];
                mac.copy_from_slice(&bytes[..6]);
                Some(Self(mac))
            } else {
                None
            }
        }

        pub fn to_string(&self) -> String {
            format!("{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
                    self.0[0], self.0[1], self.0[2],
                    self.0[3], self.0[4], self.0[5])
        }

        pub fn parse(s: &str) -> Option<Self> {
            let parts: Vec<&str> = s.split(':').collect();
            if parts.len() != 6 { return None; }

            let mut mac = [0u8; 6];
            for (i, part) in parts.iter().enumerate() {
                mac[i] = u8::from_str_radix(part, 16).ok()?;
            }
            Some(Self(mac))
        }
    }

    /// Paquet ARP
    #[derive(Debug, Clone)]
    pub struct ArpPacket {
        pub hardware_type: u16,
        pub protocol_type: u16,
        pub hardware_size: u8,
        pub protocol_size: u8,
        pub opcode: u16,
        pub sender_mac: MacAddress,
        pub sender_ip: Ipv4Addr,
        pub target_mac: MacAddress,
        pub target_ip: Ipv4Addr,
    }

    impl ArpPacket {
        /// Creer un ARP Request
        pub fn request(sender_mac: MacAddress, sender_ip: Ipv4Addr, target_ip: Ipv4Addr) -> Self {
            Self {
                hardware_type: HARDWARE_ETHERNET,
                protocol_type: PROTOCOL_IPV4,
                hardware_size: 6,
                protocol_size: 4,
                opcode: ARP_REQUEST,
                sender_mac,
                sender_ip,
                target_mac: MacAddress::ZERO,  // Inconnu
                target_ip,
            }
        }

        /// Creer un ARP Reply
        pub fn reply(sender_mac: MacAddress, sender_ip: Ipv4Addr,
                     target_mac: MacAddress, target_ip: Ipv4Addr) -> Self {
            Self {
                hardware_type: HARDWARE_ETHERNET,
                protocol_type: PROTOCOL_IPV4,
                hardware_size: 6,
                protocol_size: 4,
                opcode: ARP_REPLY,
                sender_mac,
                sender_ip,
                target_mac,
                target_ip,
            }
        }

        /// Creer un Gratuitous ARP (annonce)
        /// Utilise pour annoncer sa propre adresse IP
        pub fn gratuitous(mac: MacAddress, ip: Ipv4Addr) -> Self {
            Self {
                hardware_type: HARDWARE_ETHERNET,
                protocol_type: PROTOCOL_IPV4,
                hardware_size: 6,
                protocol_size: 4,
                opcode: ARP_REQUEST,
                sender_mac: mac,
                sender_ip: ip,
                target_mac: MacAddress::ZERO,
                target_ip: ip,  // Target = Sender pour gratuitous
            }
        }

        /// Serialiser en bytes
        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = Vec::with_capacity(28);
            bytes.extend_from_slice(&self.hardware_type.to_be_bytes());
            bytes.extend_from_slice(&self.protocol_type.to_be_bytes());
            bytes.push(self.hardware_size);
            bytes.push(self.protocol_size);
            bytes.extend_from_slice(&self.opcode.to_be_bytes());
            bytes.extend_from_slice(&self.sender_mac.0);
            bytes.extend_from_slice(&self.sender_ip.octets());
            bytes.extend_from_slice(&self.target_mac.0);
            bytes.extend_from_slice(&self.target_ip.octets());
            bytes
        }

        /// Parser depuis bytes
        pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
            if bytes.len() < 28 { return None; }

            Some(Self {
                hardware_type: u16::from_be_bytes([bytes[0], bytes[1]]),
                protocol_type: u16::from_be_bytes([bytes[2], bytes[3]]),
                hardware_size: bytes[4],
                protocol_size: bytes[5],
                opcode: u16::from_be_bytes([bytes[6], bytes[7]]),
                sender_mac: MacAddress::from_bytes(&bytes[8..14])?,
                sender_ip: Ipv4Addr::new(bytes[14], bytes[15], bytes[16], bytes[17]),
                target_mac: MacAddress::from_bytes(&bytes[18..24])?,
                target_ip: Ipv4Addr::new(bytes[24], bytes[25], bytes[26], bytes[27]),
            })
        }

        /// Verifier si c'est un ARP Request
        pub fn is_request(&self) -> bool {
            self.opcode == ARP_REQUEST
        }

        /// Verifier si c'est un Gratuitous ARP
        pub fn is_gratuitous(&self) -> bool {
            self.sender_ip == self.target_ip
        }
    }

    /// Cache ARP
    pub struct ArpCache {
        entries: std::collections::HashMap<Ipv4Addr, (MacAddress, std::time::Instant)>,
        ttl: Duration,
    }

    impl ArpCache {
        pub fn new(ttl: Duration) -> Self {
            Self {
                entries: std::collections::HashMap::new(),
                ttl,
            }
        }

        pub fn insert(&mut self, ip: Ipv4Addr, mac: MacAddress) {
            self.entries.insert(ip, (mac, std::time::Instant::now()));
        }

        pub fn get(&self, ip: &Ipv4Addr) -> Option<MacAddress> {
            self.entries.get(ip).and_then(|(mac, time)| {
                if time.elapsed() < self.ttl {
                    Some(*mac)
                } else {
                    None
                }
            })
        }

        pub fn remove_expired(&mut self) {
            self.entries.retain(|_, (_, time)| time.elapsed() < self.ttl);
        }
    }

    /// Detecteur d'ARP Spoofing
    pub struct ArpSpoofDetector {
        known_mappings: std::collections::HashMap<Ipv4Addr, MacAddress>,
        alerts: Vec<ArpSpoofAlert>,
    }

    #[derive(Debug, Clone)]
    pub struct ArpSpoofAlert {
        pub ip: Ipv4Addr,
        pub original_mac: MacAddress,
        pub new_mac: MacAddress,
        pub timestamp: std::time::Instant,
    }

    impl ArpSpoofDetector {
        pub fn new() -> Self {
            Self {
                known_mappings: std::collections::HashMap::new(),
                alerts: Vec::new(),
            }
        }

        pub fn process_packet(&mut self, packet: &ArpPacket) -> Option<ArpSpoofAlert> {
            let ip = packet.sender_ip;
            let mac = packet.sender_mac;

            if let Some(&existing_mac) = self.known_mappings.get(&ip) {
                if existing_mac != mac {
                    // Possible ARP spoofing!
                    let alert = ArpSpoofAlert {
                        ip,
                        original_mac: existing_mac,
                        new_mac: mac,
                        timestamp: std::time::Instant::now(),
                    };
                    self.alerts.push(alert.clone());
                    return Some(alert);
                }
            } else {
                self.known_mappings.insert(ip, mac);
            }
            None
        }

        pub fn get_alerts(&self) -> &[ArpSpoofAlert] {
            &self.alerts
        }
    }
}

// ============================================================
// ICMP Protocol
// ============================================================

pub mod icmp {
    use super::*;

    /// ICMP Types
    pub const ECHO_REPLY: u8 = 0;
    pub const DEST_UNREACHABLE: u8 = 3;
    pub const SOURCE_QUENCH: u8 = 4;
    pub const REDIRECT: u8 = 5;
    pub const ECHO_REQUEST: u8 = 8;
    pub const TIME_EXCEEDED: u8 = 11;
    pub const PARAMETER_PROBLEM: u8 = 12;
    pub const TIMESTAMP_REQUEST: u8 = 13;
    pub const TIMESTAMP_REPLY: u8 = 14;

    /// ICMP Destination Unreachable Codes
    pub const NETWORK_UNREACHABLE: u8 = 0;
    pub const HOST_UNREACHABLE: u8 = 1;
    pub const PROTOCOL_UNREACHABLE: u8 = 2;
    pub const PORT_UNREACHABLE: u8 = 3;
    pub const FRAGMENTATION_NEEDED: u8 = 4;  // Pour Path MTU Discovery
    pub const SOURCE_ROUTE_FAILED: u8 = 5;

    /// ICMP Time Exceeded Codes
    pub const TTL_EXCEEDED: u8 = 0;  // TTL expired in transit
    pub const FRAGMENT_REASSEMBLY_EXCEEDED: u8 = 1;

    #[derive(Debug, Clone)]
    pub struct IcmpPacket {
        pub icmp_type: u8,
        pub code: u8,
        pub checksum: u16,
        pub payload: IcmpPayload,
    }

    #[derive(Debug, Clone)]
    pub enum IcmpPayload {
        EchoRequest { id: u16, seq: u16, data: Vec<u8> },
        EchoReply { id: u16, seq: u16, data: Vec<u8> },
        DestUnreachable { next_hop_mtu: u16, original_header: Vec<u8> },
        TimeExceeded { original_header: Vec<u8> },
        Redirect { gateway: Ipv4Addr, original_header: Vec<u8> },
        Raw(Vec<u8>),
    }

    impl IcmpPacket {
        pub fn echo_request(id: u16, seq: u16, data: Vec<u8>) -> Self {
            let mut packet = Self {
                icmp_type: ECHO_REQUEST,
                code: 0,
                checksum: 0,
                payload: IcmpPayload::EchoRequest { id, seq, data },
            };
            packet.checksum = packet.calculate_checksum();
            packet
        }

        pub fn echo_reply(id: u16, seq: u16, data: Vec<u8>) -> Self {
            let mut packet = Self {
                icmp_type: ECHO_REPLY,
                code: 0,
                checksum: 0,
                payload: IcmpPayload::EchoReply { id, seq, data },
            };
            packet.checksum = packet.calculate_checksum();
            packet
        }

        pub fn dest_unreachable(code: u8, next_hop_mtu: u16, original_header: Vec<u8>) -> Self {
            let mut packet = Self {
                icmp_type: DEST_UNREACHABLE,
                code,
                checksum: 0,
                payload: IcmpPayload::DestUnreachable { next_hop_mtu, original_header },
            };
            packet.checksum = packet.calculate_checksum();
            packet
        }

        pub fn time_exceeded(code: u8, original_header: Vec<u8>) -> Self {
            let mut packet = Self {
                icmp_type: TIME_EXCEEDED,
                code,
                checksum: 0,
                payload: IcmpPayload::TimeExceeded { original_header },
            };
            packet.checksum = packet.calculate_checksum();
            packet
        }

        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = vec![self.icmp_type, self.code];
            bytes.extend_from_slice(&self.checksum.to_be_bytes());

            match &self.payload {
                IcmpPayload::EchoRequest { id, seq, data } |
                IcmpPayload::EchoReply { id, seq, data } => {
                    bytes.extend_from_slice(&id.to_be_bytes());
                    bytes.extend_from_slice(&seq.to_be_bytes());
                    bytes.extend_from_slice(data);
                }
                IcmpPayload::DestUnreachable { next_hop_mtu, original_header } => {
                    bytes.extend_from_slice(&[0, 0]); // Unused
                    bytes.extend_from_slice(&next_hop_mtu.to_be_bytes());
                    bytes.extend_from_slice(original_header);
                }
                IcmpPayload::TimeExceeded { original_header } => {
                    bytes.extend_from_slice(&[0, 0, 0, 0]); // Unused
                    bytes.extend_from_slice(original_header);
                }
                IcmpPayload::Redirect { gateway, original_header } => {
                    bytes.extend_from_slice(&gateway.octets());
                    bytes.extend_from_slice(original_header);
                }
                IcmpPayload::Raw(data) => {
                    bytes.extend_from_slice(data);
                }
            }

            bytes
        }

        pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
            if bytes.len() < 8 { return None; }

            let icmp_type = bytes[0];
            let code = bytes[1];
            let checksum = u16::from_be_bytes([bytes[2], bytes[3]]);

            let payload = match icmp_type {
                ECHO_REQUEST | ECHO_REPLY => {
                    let id = u16::from_be_bytes([bytes[4], bytes[5]]);
                    let seq = u16::from_be_bytes([bytes[6], bytes[7]]);
                    let data = bytes[8..].to_vec();
                    if icmp_type == ECHO_REQUEST {
                        IcmpPayload::EchoRequest { id, seq, data }
                    } else {
                        IcmpPayload::EchoReply { id, seq, data }
                    }
                }
                DEST_UNREACHABLE => {
                    let next_hop_mtu = u16::from_be_bytes([bytes[6], bytes[7]]);
                    let original_header = bytes[8..].to_vec();
                    IcmpPayload::DestUnreachable { next_hop_mtu, original_header }
                }
                TIME_EXCEEDED => {
                    let original_header = bytes[8..].to_vec();
                    IcmpPayload::TimeExceeded { original_header }
                }
                REDIRECT => {
                    let gateway = Ipv4Addr::new(bytes[4], bytes[5], bytes[6], bytes[7]);
                    let original_header = bytes[8..].to_vec();
                    IcmpPayload::Redirect { gateway, original_header }
                }
                _ => IcmpPayload::Raw(bytes[4..].to_vec()),
            };

            Some(Self { icmp_type, code, checksum, payload })
        }

        fn calculate_checksum(&self) -> u16 {
            let bytes = self.to_bytes();
            internet_checksum(&bytes)
        }

        /// Verifier le checksum
        pub fn verify_checksum(&self) -> bool {
            let mut bytes = self.to_bytes();
            // Remettre le checksum a 0 et recalculer
            bytes[2] = 0;
            bytes[3] = 0;
            internet_checksum(&bytes) == self.checksum
        }
    }

    /// Traceroute implementation
    #[derive(Debug)]
    pub struct TracerouteHop {
        pub ttl: u8,
        pub ip: Option<Ipv4Addr>,
        pub rtt: Option<Duration>,
        pub icmp_type: Option<u8>,
    }

    pub struct Traceroute {
        pub target: Ipv4Addr,
        pub max_hops: u8,
        pub timeout: Duration,
        pub hops: Vec<TracerouteHop>,
    }

    impl Traceroute {
        pub fn new(target: Ipv4Addr, max_hops: u8, timeout: Duration) -> Self {
            Self {
                target,
                max_hops,
                timeout,
                hops: Vec::new(),
            }
        }

        /// Note: Real implementation would use raw sockets
        pub fn trace(&mut self) {
            for ttl in 1..=self.max_hops {
                // Simplified - real implementation sends ICMP with varying TTL
                // and processes TIME_EXCEEDED or ECHO_REPLY responses
                self.hops.push(TracerouteHop {
                    ttl,
                    ip: None,
                    rtt: None,
                    icmp_type: None,
                });
            }
        }
    }

    /// Path MTU Discovery
    pub struct PathMtuDiscovery {
        pub target: Ipv4Addr,
        pub discovered_mtu: u16,
    }

    impl PathMtuDiscovery {
        pub fn new(target: Ipv4Addr) -> Self {
            Self {
                target,
                discovered_mtu: 1500, // Default Ethernet MTU
            }
        }

        /// Note: Real implementation sends packets with DF bit
        /// and processes DEST_UNREACHABLE with code FRAGMENTATION_NEEDED
        pub fn discover(&mut self) -> u16 {
            // Start with max and decrease based on ICMP responses
            self.discovered_mtu
        }
    }

    fn internet_checksum(data: &[u8]) -> u16 {
        let mut sum: u32 = 0;
        let mut i = 0;

        while i < data.len() - 1 {
            sum += u16::from_be_bytes([data[i], data[i + 1]]) as u32;
            i += 2;
        }

        if data.len() % 2 == 1 {
            sum += (data[data.len() - 1] as u32) << 8;
        }

        while sum >> 16 != 0 {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }

        !(sum as u16)
    }
}

// ============================================================
// DHCP Protocol
// ============================================================

pub mod dhcp {
    use super::*;

    /// DHCP Message Types (Option 53)
    pub const DHCP_DISCOVER: u8 = 1;
    pub const DHCP_OFFER: u8 = 2;
    pub const DHCP_REQUEST: u8 = 3;
    pub const DHCP_DECLINE: u8 = 4;
    pub const DHCP_ACK: u8 = 5;
    pub const DHCP_NAK: u8 = 6;
    pub const DHCP_RELEASE: u8 = 7;
    pub const DHCP_INFORM: u8 = 8;

    /// DHCP Options
    pub const OPT_SUBNET_MASK: u8 = 1;
    pub const OPT_ROUTER: u8 = 3;
    pub const OPT_DNS_SERVER: u8 = 6;
    pub const OPT_HOSTNAME: u8 = 12;
    pub const OPT_DOMAIN_NAME: u8 = 15;
    pub const OPT_BROADCAST: u8 = 28;
    pub const OPT_REQUESTED_IP: u8 = 50;
    pub const OPT_LEASE_TIME: u8 = 51;
    pub const OPT_MESSAGE_TYPE: u8 = 53;
    pub const OPT_SERVER_ID: u8 = 54;
    pub const OPT_PARAMETER_LIST: u8 = 55;
    pub const OPT_RENEWAL_TIME: u8 = 58;
    pub const OPT_REBINDING_TIME: u8 = 59;
    pub const OPT_CLIENT_ID: u8 = 61;
    pub const OPT_END: u8 = 255;

    /// Magic cookie
    pub const DHCP_MAGIC_COOKIE: [u8; 4] = [99, 130, 83, 99];

    /// DHCP Ports
    pub const DHCP_SERVER_PORT: u16 = 67;
    pub const DHCP_CLIENT_PORT: u16 = 68;

    #[derive(Debug, Clone)]
    pub struct DhcpMessage {
        pub op: u8,           // 1 = BOOTREQUEST, 2 = BOOTREPLY
        pub htype: u8,        // Hardware type (1 = Ethernet)
        pub hlen: u8,         // Hardware address length (6 for Ethernet)
        pub hops: u8,         // Relay hops
        pub xid: u32,         // Transaction ID
        pub secs: u16,        // Seconds elapsed
        pub flags: u16,       // Flags (0x8000 = broadcast)
        pub ciaddr: Ipv4Addr, // Client IP (if known)
        pub yiaddr: Ipv4Addr, // Your (client) IP (from server)
        pub siaddr: Ipv4Addr, // Server IP
        pub giaddr: Ipv4Addr, // Gateway/relay agent IP
        pub chaddr: [u8; 16], // Client hardware address
        pub sname: [u8; 64],  // Server hostname
        pub file: [u8; 128],  // Boot filename
        pub options: Vec<DhcpOption>,
    }

    #[derive(Debug, Clone)]
    pub struct DhcpOption {
        pub code: u8,
        pub data: Vec<u8>,
    }

    impl DhcpOption {
        pub fn message_type(msg_type: u8) -> Self {
            Self { code: OPT_MESSAGE_TYPE, data: vec![msg_type] }
        }

        pub fn requested_ip(ip: Ipv4Addr) -> Self {
            Self { code: OPT_REQUESTED_IP, data: ip.octets().to_vec() }
        }

        pub fn server_id(ip: Ipv4Addr) -> Self {
            Self { code: OPT_SERVER_ID, data: ip.octets().to_vec() }
        }

        pub fn parameter_request_list(params: &[u8]) -> Self {
            Self { code: OPT_PARAMETER_LIST, data: params.to_vec() }
        }

        pub fn client_id(mac: &[u8; 6]) -> Self {
            let mut data = vec![1]; // Type: Ethernet
            data.extend_from_slice(mac);
            Self { code: OPT_CLIENT_ID, data }
        }

        pub fn as_ipv4(&self) -> Option<Ipv4Addr> {
            if self.data.len() >= 4 {
                Some(Ipv4Addr::new(self.data[0], self.data[1], self.data[2], self.data[3]))
            } else {
                None
            }
        }

        pub fn as_u32(&self) -> Option<u32> {
            if self.data.len() >= 4 {
                Some(u32::from_be_bytes([self.data[0], self.data[1], self.data[2], self.data[3]]))
            } else {
                None
            }
        }
    }

    impl DhcpMessage {
        /// Creer un DHCP Discover
        pub fn discover(mac: &[u8; 6], xid: u32) -> Self {
            let mut msg = Self::new_request(mac, xid);
            msg.options.push(DhcpOption::message_type(DHCP_DISCOVER));
            msg.options.push(DhcpOption::parameter_request_list(&[
                OPT_SUBNET_MASK, OPT_ROUTER, OPT_DNS_SERVER, OPT_DOMAIN_NAME, OPT_LEASE_TIME
            ]));
            msg.options.push(DhcpOption::client_id(mac));
            msg
        }

        /// Creer un DHCP Request
        pub fn request(mac: &[u8; 6], xid: u32, requested_ip: Ipv4Addr, server_ip: Ipv4Addr) -> Self {
            let mut msg = Self::new_request(mac, xid);
            msg.options.push(DhcpOption::message_type(DHCP_REQUEST));
            msg.options.push(DhcpOption::requested_ip(requested_ip));
            msg.options.push(DhcpOption::server_id(server_ip));
            msg.options.push(DhcpOption::client_id(mac));
            msg
        }

        /// Creer un DHCP Release
        pub fn release(mac: &[u8; 6], xid: u32, client_ip: Ipv4Addr, server_ip: Ipv4Addr) -> Self {
            let mut msg = Self::new_request(mac, xid);
            msg.ciaddr = client_ip;
            msg.options.push(DhcpOption::message_type(DHCP_RELEASE));
            msg.options.push(DhcpOption::server_id(server_ip));
            msg.options.push(DhcpOption::client_id(mac));
            msg
        }

        fn new_request(mac: &[u8; 6], xid: u32) -> Self {
            let mut chaddr = [0u8; 16];
            chaddr[..6].copy_from_slice(mac);

            Self {
                op: 1, // BOOTREQUEST
                htype: 1,
                hlen: 6,
                hops: 0,
                xid,
                secs: 0,
                flags: 0x8000, // Broadcast flag
                ciaddr: Ipv4Addr::UNSPECIFIED,
                yiaddr: Ipv4Addr::UNSPECIFIED,
                siaddr: Ipv4Addr::UNSPECIFIED,
                giaddr: Ipv4Addr::UNSPECIFIED,
                chaddr,
                sname: [0; 64],
                file: [0; 128],
                options: Vec::new(),
            }
        }

        /// Obtenir le type de message
        pub fn message_type(&self) -> Option<u8> {
            self.options.iter()
                .find(|opt| opt.code == OPT_MESSAGE_TYPE)
                .and_then(|opt| opt.data.first().copied())
        }

        /// Obtenir une option
        pub fn get_option(&self, code: u8) -> Option<&DhcpOption> {
            self.options.iter().find(|opt| opt.code == code)
        }

        /// Serialiser en bytes
        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = Vec::with_capacity(576);

            bytes.push(self.op);
            bytes.push(self.htype);
            bytes.push(self.hlen);
            bytes.push(self.hops);
            bytes.extend_from_slice(&self.xid.to_be_bytes());
            bytes.extend_from_slice(&self.secs.to_be_bytes());
            bytes.extend_from_slice(&self.flags.to_be_bytes());
            bytes.extend_from_slice(&self.ciaddr.octets());
            bytes.extend_from_slice(&self.yiaddr.octets());
            bytes.extend_from_slice(&self.siaddr.octets());
            bytes.extend_from_slice(&self.giaddr.octets());
            bytes.extend_from_slice(&self.chaddr);
            bytes.extend_from_slice(&self.sname);
            bytes.extend_from_slice(&self.file);

            // Magic cookie
            bytes.extend_from_slice(&DHCP_MAGIC_COOKIE);

            // Options
            for opt in &self.options {
                bytes.push(opt.code);
                bytes.push(opt.data.len() as u8);
                bytes.extend_from_slice(&opt.data);
            }
            bytes.push(OPT_END);

            // Pad to minimum 300 bytes
            while bytes.len() < 300 {
                bytes.push(0);
            }

            bytes
        }

        /// Parser depuis bytes
        pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
            if bytes.len() < 240 { return None; }

            let mut chaddr = [0u8; 16];
            chaddr.copy_from_slice(&bytes[28..44]);

            let mut sname = [0u8; 64];
            sname.copy_from_slice(&bytes[44..108]);

            let mut file = [0u8; 128];
            file.copy_from_slice(&bytes[108..236]);

            // Verifier magic cookie
            if &bytes[236..240] != DHCP_MAGIC_COOKIE {
                return None;
            }

            // Parser options
            let mut options = Vec::new();
            let mut i = 240;
            while i < bytes.len() {
                let code = bytes[i];
                if code == OPT_END { break; }
                if code == 0 { i += 1; continue; } // Padding

                if i + 1 >= bytes.len() { break; }
                let len = bytes[i + 1] as usize;
                if i + 2 + len > bytes.len() { break; }

                options.push(DhcpOption {
                    code,
                    data: bytes[i + 2..i + 2 + len].to_vec(),
                });
                i += 2 + len;
            }

            Some(Self {
                op: bytes[0],
                htype: bytes[1],
                hlen: bytes[2],
                hops: bytes[3],
                xid: u32::from_be_bytes([bytes[4], bytes[5], bytes[6], bytes[7]]),
                secs: u16::from_be_bytes([bytes[8], bytes[9]]),
                flags: u16::from_be_bytes([bytes[10], bytes[11]]),
                ciaddr: Ipv4Addr::new(bytes[12], bytes[13], bytes[14], bytes[15]),
                yiaddr: Ipv4Addr::new(bytes[16], bytes[17], bytes[18], bytes[19]),
                siaddr: Ipv4Addr::new(bytes[20], bytes[21], bytes[22], bytes[23]),
                giaddr: Ipv4Addr::new(bytes[24], bytes[25], bytes[26], bytes[27]),
                chaddr,
                sname,
                file,
                options,
            })
        }
    }

    /// DHCP Client state machine
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum DhcpState {
        Init,
        Selecting,
        Requesting,
        Bound,
        Renewing,
        Rebinding,
    }

    pub struct DhcpClient {
        pub state: DhcpState,
        pub mac: [u8; 6],
        pub xid: u32,
        pub offered_ip: Option<Ipv4Addr>,
        pub server_ip: Option<Ipv4Addr>,
        pub lease_time: Option<u32>,
        pub subnet_mask: Option<Ipv4Addr>,
        pub router: Option<Ipv4Addr>,
        pub dns_servers: Vec<Ipv4Addr>,
    }

    impl DhcpClient {
        pub fn new(mac: [u8; 6]) -> Self {
            Self {
                state: DhcpState::Init,
                mac,
                xid: rand::random(),
                offered_ip: None,
                server_ip: None,
                lease_time: None,
                subnet_mask: None,
                router: None,
                dns_servers: Vec::new(),
            }
        }

        /// Commencer le processus DORA
        pub fn start_discover(&mut self) -> DhcpMessage {
            self.state = DhcpState::Selecting;
            self.xid = rand::random();
            DhcpMessage::discover(&self.mac, self.xid)
        }

        /// Traiter une reponse
        pub fn process_response(&mut self, msg: &DhcpMessage) -> Option<DhcpMessage> {
            if msg.xid != self.xid { return None; }

            match (self.state, msg.message_type()?) {
                (DhcpState::Selecting, DHCP_OFFER) => {
                    self.offered_ip = Some(msg.yiaddr);
                    self.server_ip = msg.get_option(OPT_SERVER_ID)
                        .and_then(|o| o.as_ipv4());

                    self.state = DhcpState::Requesting;

                    // Envoyer Request
                    Some(DhcpMessage::request(
                        &self.mac,
                        self.xid,
                        msg.yiaddr,
                        self.server_ip?
                    ))
                }
                (DhcpState::Requesting, DHCP_ACK) => {
                    self.state = DhcpState::Bound;

                    // Extraire les informations
                    self.lease_time = msg.get_option(OPT_LEASE_TIME)
                        .and_then(|o| o.as_u32());
                    self.subnet_mask = msg.get_option(OPT_SUBNET_MASK)
                        .and_then(|o| o.as_ipv4());
                    self.router = msg.get_option(OPT_ROUTER)
                        .and_then(|o| o.as_ipv4());

                    if let Some(dns_opt) = msg.get_option(OPT_DNS_SERVER) {
                        for chunk in dns_opt.data.chunks(4) {
                            if chunk.len() == 4 {
                                self.dns_servers.push(Ipv4Addr::new(
                                    chunk[0], chunk[1], chunk[2], chunk[3]
                                ));
                            }
                        }
                    }

                    None // Complete!
                }
                (DhcpState::Requesting, DHCP_NAK) => {
                    self.state = DhcpState::Init;
                    None
                }
                (DhcpState::Bound, _) if self.needs_renewal() => {
                    self.state = DhcpState::Renewing;
                    self.xid = rand::random();
                    Some(DhcpMessage::request(
                        &self.mac,
                        self.xid,
                        self.offered_ip?,
                        self.server_ip?
                    ))
                }
                _ => None,
            }
        }

        fn needs_renewal(&self) -> bool {
            // Simplified - real implementation tracks time
            false
        }
    }

    /// DHCP Relay Agent
    pub struct DhcpRelay {
        pub server_ip: Ipv4Addr,
        pub relay_ip: Ipv4Addr, // This relay's IP
    }

    impl DhcpRelay {
        pub fn new(server_ip: Ipv4Addr, relay_ip: Ipv4Addr) -> Self {
            Self { server_ip, relay_ip }
        }

        /// Relay un message client vers le serveur
        pub fn relay_to_server(&self, mut msg: DhcpMessage) -> DhcpMessage {
            msg.giaddr = self.relay_ip;
            msg.hops += 1;
            msg
        }

        /// Relay une reponse serveur vers le client
        pub fn relay_to_client(&self, msg: DhcpMessage) -> DhcpMessage {
            msg
        }
    }
}

// ============================================================
// DNS Protocol
// ============================================================

pub mod dns {
    use super::*;

    /// DNS Record Types
    pub const TYPE_A: u16 = 1;
    pub const TYPE_NS: u16 = 2;
    pub const TYPE_CNAME: u16 = 5;
    pub const TYPE_SOA: u16 = 6;
    pub const TYPE_PTR: u16 = 12;
    pub const TYPE_MX: u16 = 15;
    pub const TYPE_TXT: u16 = 16;
    pub const TYPE_AAAA: u16 = 28;
    pub const TYPE_SRV: u16 = 33;

    /// DNS Classes
    pub const CLASS_IN: u16 = 1;

    /// DNS Response Codes
    pub const RCODE_NOERROR: u8 = 0;
    pub const RCODE_FORMERR: u8 = 1;
    pub const RCODE_SERVFAIL: u8 = 2;
    pub const RCODE_NXDOMAIN: u8 = 3;
    pub const RCODE_NOTIMPL: u8 = 4;
    pub const RCODE_REFUSED: u8 = 5;

    /// DNS Ports
    pub const DNS_PORT: u16 = 53;

    #[derive(Debug, Clone)]
    pub struct DnsHeader {
        pub id: u16,
        pub flags: u16,
        pub qd_count: u16, // Question count
        pub an_count: u16, // Answer count
        pub ns_count: u16, // Authority count
        pub ar_count: u16, // Additional count
    }

    impl DnsHeader {
        pub fn query(id: u16) -> Self {
            Self {
                id,
                flags: 0x0100, // RD (recursion desired)
                qd_count: 1,
                an_count: 0,
                ns_count: 0,
                ar_count: 0,
            }
        }

        pub fn is_response(&self) -> bool {
            self.flags & 0x8000 != 0
        }

        pub fn rcode(&self) -> u8 {
            (self.flags & 0x000F) as u8
        }

        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = Vec::with_capacity(12);
            bytes.extend_from_slice(&self.id.to_be_bytes());
            bytes.extend_from_slice(&self.flags.to_be_bytes());
            bytes.extend_from_slice(&self.qd_count.to_be_bytes());
            bytes.extend_from_slice(&self.an_count.to_be_bytes());
            bytes.extend_from_slice(&self.ns_count.to_be_bytes());
            bytes.extend_from_slice(&self.ar_count.to_be_bytes());
            bytes
        }

        pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
            if bytes.len() < 12 { return None; }
            Some(Self {
                id: u16::from_be_bytes([bytes[0], bytes[1]]),
                flags: u16::from_be_bytes([bytes[2], bytes[3]]),
                qd_count: u16::from_be_bytes([bytes[4], bytes[5]]),
                an_count: u16::from_be_bytes([bytes[6], bytes[7]]),
                ns_count: u16::from_be_bytes([bytes[8], bytes[9]]),
                ar_count: u16::from_be_bytes([bytes[10], bytes[11]]),
            })
        }
    }

    #[derive(Debug, Clone)]
    pub struct DnsQuestion {
        pub name: String,
        pub qtype: u16,
        pub qclass: u16,
    }

    impl DnsQuestion {
        pub fn new(name: &str, qtype: u16) -> Self {
            Self {
                name: name.to_string(),
                qtype,
                qclass: CLASS_IN,
            }
        }

        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = Vec::new();

            // Encode name as labels
            for label in self.name.split('.') {
                bytes.push(label.len() as u8);
                bytes.extend_from_slice(label.as_bytes());
            }
            bytes.push(0); // End of name

            bytes.extend_from_slice(&self.qtype.to_be_bytes());
            bytes.extend_from_slice(&self.qclass.to_be_bytes());
            bytes
        }
    }

    #[derive(Debug, Clone)]
    pub struct DnsRecord {
        pub name: String,
        pub rtype: u16,
        pub rclass: u16,
        pub ttl: u32,
        pub rdata: DnsRdata,
    }

    #[derive(Debug, Clone)]
    pub enum DnsRdata {
        A(Ipv4Addr),
        AAAA([u8; 16]),
        CNAME(String),
        NS(String),
        MX { priority: u16, exchange: String },
        TXT(String),
        PTR(String),
        Raw(Vec<u8>),
    }

    #[derive(Debug, Clone)]
    pub struct DnsMessage {
        pub header: DnsHeader,
        pub questions: Vec<DnsQuestion>,
        pub answers: Vec<DnsRecord>,
        pub authority: Vec<DnsRecord>,
        pub additional: Vec<DnsRecord>,
    }

    impl DnsMessage {
        /// Creer une requete DNS
        pub fn query(name: &str, qtype: u16) -> Self {
            Self {
                header: DnsHeader::query(rand::random()),
                questions: vec![DnsQuestion::new(name, qtype)],
                answers: Vec::new(),
                authority: Vec::new(),
                additional: Vec::new(),
            }
        }

        /// Serialiser en bytes
        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = self.header.to_bytes();

            for q in &self.questions {
                bytes.extend_from_slice(&q.to_bytes());
            }

            // Pour les reponses, il faudrait aussi serialiser
            // answers, authority, additional

            bytes
        }

        /// Parser depuis bytes
        pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
            let header = DnsHeader::from_bytes(bytes)?;
            let mut offset = 12;

            let mut questions = Vec::new();
            for _ in 0..header.qd_count {
                let (q, len) = Self::parse_question(bytes, offset)?;
                questions.push(q);
                offset += len;
            }

            let mut answers = Vec::new();
            for _ in 0..header.an_count {
                let (r, len) = Self::parse_record(bytes, offset)?;
                answers.push(r);
                offset += len;
            }

            let mut authority = Vec::new();
            for _ in 0..header.ns_count {
                let (r, len) = Self::parse_record(bytes, offset)?;
                authority.push(r);
                offset += len;
            }

            let mut additional = Vec::new();
            for _ in 0..header.ar_count {
                if let Some((r, len)) = Self::parse_record(bytes, offset) {
                    additional.push(r);
                    offset += len;
                } else {
                    break;
                }
            }

            Some(Self { header, questions, answers, authority, additional })
        }

        fn parse_question(bytes: &[u8], offset: usize) -> Option<(DnsQuestion, usize)> {
            let (name, name_len) = Self::parse_name(bytes, offset)?;
            let o = offset + name_len;
            if o + 4 > bytes.len() { return None; }

            let qtype = u16::from_be_bytes([bytes[o], bytes[o + 1]]);
            let qclass = u16::from_be_bytes([bytes[o + 2], bytes[o + 3]]);

            Some((DnsQuestion { name, qtype, qclass }, name_len + 4))
        }

        fn parse_record(bytes: &[u8], offset: usize) -> Option<(DnsRecord, usize)> {
            let (name, name_len) = Self::parse_name(bytes, offset)?;
            let o = offset + name_len;
            if o + 10 > bytes.len() { return None; }

            let rtype = u16::from_be_bytes([bytes[o], bytes[o + 1]]);
            let rclass = u16::from_be_bytes([bytes[o + 2], bytes[o + 3]]);
            let ttl = u32::from_be_bytes([bytes[o + 4], bytes[o + 5], bytes[o + 6], bytes[o + 7]]);
            let rdlength = u16::from_be_bytes([bytes[o + 8], bytes[o + 9]]) as usize;

            let rdata_start = o + 10;
            if rdata_start + rdlength > bytes.len() { return None; }

            let rdata = match rtype {
                TYPE_A if rdlength == 4 => {
                    DnsRdata::A(Ipv4Addr::new(
                        bytes[rdata_start], bytes[rdata_start + 1],
                        bytes[rdata_start + 2], bytes[rdata_start + 3]
                    ))
                }
                TYPE_AAAA if rdlength == 16 => {
                    let mut addr = [0u8; 16];
                    addr.copy_from_slice(&bytes[rdata_start..rdata_start + 16]);
                    DnsRdata::AAAA(addr)
                }
                TYPE_CNAME | TYPE_NS | TYPE_PTR => {
                    let (name, _) = Self::parse_name(bytes, rdata_start)?;
                    match rtype {
                        TYPE_CNAME => DnsRdata::CNAME(name),
                        TYPE_NS => DnsRdata::NS(name),
                        TYPE_PTR => DnsRdata::PTR(name),
                        _ => unreachable!(),
                    }
                }
                TYPE_MX if rdlength >= 3 => {
                    let priority = u16::from_be_bytes([bytes[rdata_start], bytes[rdata_start + 1]]);
                    let (exchange, _) = Self::parse_name(bytes, rdata_start + 2)?;
                    DnsRdata::MX { priority, exchange }
                }
                TYPE_TXT => {
                    // TXT records have length-prefixed strings
                    let len = bytes[rdata_start] as usize;
                    if rdata_start + 1 + len <= bytes.len() {
                        let text = String::from_utf8_lossy(
                            &bytes[rdata_start + 1..rdata_start + 1 + len]
                        ).to_string();
                        DnsRdata::TXT(text)
                    } else {
                        DnsRdata::Raw(bytes[rdata_start..rdata_start + rdlength].to_vec())
                    }
                }
                _ => DnsRdata::Raw(bytes[rdata_start..rdata_start + rdlength].to_vec()),
            };

            Some((DnsRecord { name, rtype, rclass, ttl, rdata }, name_len + 10 + rdlength))
        }

        fn parse_name(bytes: &[u8], mut offset: usize) -> Option<(String, usize)> {
            let mut name = String::new();
            let start_offset = offset;
            let mut jumped = false;
            let mut jump_offset = 0;

            loop {
                if offset >= bytes.len() { return None; }

                let len = bytes[offset];
                if len == 0 {
                    if !jumped { offset += 1; }
                    break;
                }

                // Compression pointer?
                if len & 0xC0 == 0xC0 {
                    if offset + 1 >= bytes.len() { return None; }
                    let pointer = ((len as usize & 0x3F) << 8) | bytes[offset + 1] as usize;
                    if !jumped {
                        jump_offset = offset + 2;
                        jumped = true;
                    }
                    offset = pointer;
                    continue;
                }

                offset += 1;
                if offset + len as usize > bytes.len() { return None; }

                if !name.is_empty() { name.push('.'); }
                name.push_str(&String::from_utf8_lossy(&bytes[offset..offset + len as usize]));
                offset += len as usize;
            }

            let consumed = if jumped { jump_offset - start_offset } else { offset - start_offset };
            Some((name, consumed))
        }
    }

    /// DNS Client simple
    pub struct DnsClient {
        server: std::net::SocketAddr,
        timeout: Duration,
    }

    impl DnsClient {
        pub fn new(server: Ipv4Addr) -> Self {
            Self {
                server: std::net::SocketAddr::new(server.into(), DNS_PORT),
                timeout: Duration::from_secs(5),
            }
        }

        /// Resoudre un nom de domaine
        pub fn resolve(&self, name: &str) -> std::io::Result<Vec<Ipv4Addr>> {
            let query = DnsMessage::query(name, TYPE_A);
            let query_bytes = query.to_bytes();

            // UDP query
            let socket = UdpSocket::bind("0.0.0.0:0")?;
            socket.set_read_timeout(Some(self.timeout))?;
            socket.send_to(&query_bytes, self.server)?;

            let mut buf = [0u8; 512];
            let (len, _) = socket.recv_from(&mut buf)?;

            let response = DnsMessage::from_bytes(&buf[..len])
                .ok_or_else(|| std::io::Error::new(
                    std::io::ErrorKind::InvalidData, "Invalid DNS response"
                ))?;

            if response.header.id != query.header.id {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData, "ID mismatch"
                ));
            }

            let addrs: Vec<Ipv4Addr> = response.answers.iter()
                .filter_map(|r| {
                    if let DnsRdata::A(ip) = r.rdata {
                        Some(ip)
                    } else {
                        None
                    }
                })
                .collect();

            Ok(addrs)
        }

        /// Reverse DNS lookup
        pub fn reverse_lookup(&self, ip: Ipv4Addr) -> std::io::Result<String> {
            // Construire le nom PTR
            let octets = ip.octets();
            let ptr_name = format!("{}.{}.{}.{}.in-addr.arpa",
                                   octets[3], octets[2], octets[1], octets[0]);

            let query = DnsMessage::query(&ptr_name, TYPE_PTR);
            let query_bytes = query.to_bytes();

            let socket = UdpSocket::bind("0.0.0.0:0")?;
            socket.set_read_timeout(Some(self.timeout))?;
            socket.send_to(&query_bytes, self.server)?;

            let mut buf = [0u8; 512];
            let (len, _) = socket.recv_from(&mut buf)?;

            let response = DnsMessage::from_bytes(&buf[..len])
                .ok_or_else(|| std::io::Error::new(
                    std::io::ErrorKind::InvalidData, "Invalid DNS response"
                ))?;

            response.answers.iter()
                .find_map(|r| {
                    if let DnsRdata::PTR(name) = &r.rdata {
                        Some(name.clone())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| std::io::Error::new(
                    std::io::ErrorKind::NotFound, "No PTR record"
                ))
        }
    }

    /// Pour DNS sur TCP (messages > 512 bytes)
    pub fn dns_over_tcp(server: Ipv4Addr, query: &DnsMessage) -> std::io::Result<DnsMessage> {
        use std::io::{Read, Write};
        use std::net::TcpStream;

        let query_bytes = query.to_bytes();
        let len = query_bytes.len() as u16;

        let mut stream = TcpStream::connect((server, DNS_PORT))?;

        // TCP DNS prefix avec la longueur
        stream.write_all(&len.to_be_bytes())?;
        stream.write_all(&query_bytes)?;

        // Lire la reponse
        let mut len_buf = [0u8; 2];
        stream.read_exact(&mut len_buf)?;
        let response_len = u16::from_be_bytes(len_buf) as usize;

        let mut response_buf = vec![0u8; response_len];
        stream.read_exact(&mut response_buf)?;

        DnsMessage::from_bytes(&response_buf)
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::InvalidData, "Invalid DNS response"
            ))
    }
}

// Module re-exports
pub use arp::*;
pub use icmp::*;
pub use dhcp::*;
pub use dns::*;
```

## Tests Automatises

```rust
// tests/protocol_tests.rs
use network_protocols::*;
use std::net::Ipv4Addr;

// ============================================================
// ARP Tests
// ============================================================

#[test]
fn test_arp_request_creation() {
    let mac = arp::MacAddress([0x00, 0x11, 0x22, 0x33, 0x44, 0x55]);
    let sender_ip = Ipv4Addr::new(192, 168, 1, 100);
    let target_ip = Ipv4Addr::new(192, 168, 1, 1);

    let packet = arp::ArpPacket::request(mac, sender_ip, target_ip);

    assert_eq!(packet.opcode, arp::ARP_REQUEST);
    assert_eq!(packet.sender_mac, mac);
    assert_eq!(packet.sender_ip, sender_ip);
    assert_eq!(packet.target_ip, target_ip);
    assert!(packet.is_request());
}

#[test]
fn test_arp_serialization() {
    let mac = arp::MacAddress([0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]);
    let packet = arp::ArpPacket::request(
        mac,
        Ipv4Addr::new(10, 0, 0, 1),
        Ipv4Addr::new(10, 0, 0, 2)
    );

    let bytes = packet.to_bytes();
    assert_eq!(bytes.len(), 28);

    let parsed = arp::ArpPacket::from_bytes(&bytes).unwrap();
    assert_eq!(parsed.opcode, packet.opcode);
    assert_eq!(parsed.sender_mac, mac);
}

#[test]
fn test_gratuitous_arp() {
    let mac = arp::MacAddress([0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);
    let ip = Ipv4Addr::new(192, 168, 1, 50);

    let packet = arp::ArpPacket::gratuitous(mac, ip);

    assert!(packet.is_gratuitous());
    assert_eq!(packet.sender_ip, packet.target_ip);
}

#[test]
fn test_arp_cache() {
    let mut cache = arp::ArpCache::new(std::time::Duration::from_secs(60));

    let ip = Ipv4Addr::new(192, 168, 1, 1);
    let mac = arp::MacAddress([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]);

    cache.insert(ip, mac);
    assert_eq!(cache.get(&ip), Some(mac));

    let unknown_ip = Ipv4Addr::new(192, 168, 1, 2);
    assert_eq!(cache.get(&unknown_ip), None);
}

#[test]
fn test_arp_spoof_detection() {
    let mut detector = arp::ArpSpoofDetector::new();

    let ip = Ipv4Addr::new(192, 168, 1, 1);
    let mac1 = arp::MacAddress([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]);
    let mac2 = arp::MacAddress([0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]);

    // Premier paquet - normal
    let packet1 = arp::ArpPacket::reply(mac1, ip, arp::MacAddress::ZERO, Ipv4Addr::UNSPECIFIED);
    assert!(detector.process_packet(&packet1).is_none());

    // Deuxieme paquet avec MAC differente - spoof!
    let packet2 = arp::ArpPacket::reply(mac2, ip, arp::MacAddress::ZERO, Ipv4Addr::UNSPECIFIED);
    let alert = detector.process_packet(&packet2);

    assert!(alert.is_some());
    let alert = alert.unwrap();
    assert_eq!(alert.ip, ip);
    assert_eq!(alert.original_mac, mac1);
    assert_eq!(alert.new_mac, mac2);
}

// ============================================================
// ICMP Tests
// ============================================================

#[test]
fn test_icmp_echo_request() {
    let packet = icmp::IcmpPacket::echo_request(1234, 1, vec![0u8; 32]);

    assert_eq!(packet.icmp_type, icmp::ECHO_REQUEST);
    assert_eq!(packet.code, 0);
    assert!(packet.verify_checksum());
}

#[test]
fn test_icmp_serialization() {
    let packet = icmp::IcmpPacket::echo_request(5678, 42, b"Hello".to_vec());
    let bytes = packet.to_bytes();

    let parsed = icmp::IcmpPacket::from_bytes(&bytes).unwrap();
    assert_eq!(parsed.icmp_type, icmp::ECHO_REQUEST);

    if let icmp::IcmpPayload::EchoRequest { id, seq, data } = parsed.payload {
        assert_eq!(id, 5678);
        assert_eq!(seq, 42);
        assert_eq!(data, b"Hello");
    } else {
        panic!("Wrong payload type");
    }
}

#[test]
fn test_icmp_dest_unreachable() {
    let original = vec![0u8; 64];
    let packet = icmp::IcmpPacket::dest_unreachable(
        icmp::FRAGMENTATION_NEEDED,
        1400,
        original.clone()
    );

    assert_eq!(packet.icmp_type, icmp::DEST_UNREACHABLE);
    assert_eq!(packet.code, icmp::FRAGMENTATION_NEEDED);

    if let icmp::IcmpPayload::DestUnreachable { next_hop_mtu, .. } = packet.payload {
        assert_eq!(next_hop_mtu, 1400);
    }
}

#[test]
fn test_icmp_time_exceeded() {
    let packet = icmp::IcmpPacket::time_exceeded(icmp::TTL_EXCEEDED, vec![0u8; 28]);

    assert_eq!(packet.icmp_type, icmp::TIME_EXCEEDED);
    assert_eq!(packet.code, icmp::TTL_EXCEEDED);
}

// ============================================================
// DHCP Tests
// ============================================================

#[test]
fn test_dhcp_discover() {
    let mac = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55];
    let msg = dhcp::DhcpMessage::discover(&mac, 12345);

    assert_eq!(msg.op, 1); // BOOTREQUEST
    assert_eq!(msg.xid, 12345);
    assert_eq!(msg.message_type(), Some(dhcp::DHCP_DISCOVER));
}

#[test]
fn test_dhcp_serialization() {
    let mac = [0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF];
    let msg = dhcp::DhcpMessage::discover(&mac, 99999);

    let bytes = msg.to_bytes();
    assert!(bytes.len() >= 300); // Minimum DHCP message size

    // Verifier magic cookie
    assert_eq!(&bytes[236..240], &dhcp::DHCP_MAGIC_COOKIE);

    let parsed = dhcp::DhcpMessage::from_bytes(&bytes).unwrap();
    assert_eq!(parsed.xid, 99999);
    assert_eq!(parsed.message_type(), Some(dhcp::DHCP_DISCOVER));
}

#[test]
fn test_dhcp_client_dora() {
    let mac = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55];
    let mut client = dhcp::DhcpClient::new(mac);

    // Discover
    let discover = client.start_discover();
    assert_eq!(client.state, dhcp::DhcpState::Selecting);
    assert_eq!(discover.message_type(), Some(dhcp::DHCP_DISCOVER));

    // Simuler une reponse Offer
    let mut offer = dhcp::DhcpMessage::from_bytes(&discover.to_bytes()).unwrap();
    offer.op = 2; // BOOTREPLY
    offer.yiaddr = Ipv4Addr::new(192, 168, 1, 100);
    offer.options = vec![
        dhcp::DhcpOption::message_type(dhcp::DHCP_OFFER),
        dhcp::DhcpOption::server_id(Ipv4Addr::new(192, 168, 1, 1)),
    ];

    let request = client.process_response(&offer);
    assert!(request.is_some());
    assert_eq!(client.state, dhcp::DhcpState::Requesting);

    // Simuler ACK
    let mut ack = dhcp::DhcpMessage::from_bytes(&discover.to_bytes()).unwrap();
    ack.op = 2;
    ack.yiaddr = Ipv4Addr::new(192, 168, 1, 100);
    ack.xid = client.xid;
    ack.options = vec![
        dhcp::DhcpOption::message_type(dhcp::DHCP_ACK),
        dhcp::DhcpOption { code: dhcp::OPT_LEASE_TIME, data: 86400u32.to_be_bytes().to_vec() },
        dhcp::DhcpOption { code: dhcp::OPT_SUBNET_MASK, data: vec![255, 255, 255, 0] },
        dhcp::DhcpOption { code: dhcp::OPT_ROUTER, data: vec![192, 168, 1, 1] },
    ];

    let result = client.process_response(&ack);
    assert!(result.is_none()); // Complete
    assert_eq!(client.state, dhcp::DhcpState::Bound);
    assert_eq!(client.offered_ip, Some(Ipv4Addr::new(192, 168, 1, 100)));
}

// ============================================================
// DNS Tests
// ============================================================

#[test]
fn test_dns_query_creation() {
    let query = dns::DnsMessage::query("example.com", dns::TYPE_A);

    assert!(!query.header.is_response());
    assert_eq!(query.header.qd_count, 1);
    assert_eq!(query.questions[0].name, "example.com");
    assert_eq!(query.questions[0].qtype, dns::TYPE_A);
}

#[test]
fn test_dns_header_serialization() {
    let header = dns::DnsHeader::query(0x1234);
    let bytes = header.to_bytes();

    assert_eq!(bytes.len(), 12);
    assert_eq!(bytes[0], 0x12);
    assert_eq!(bytes[1], 0x34);

    let parsed = dns::DnsHeader::from_bytes(&bytes).unwrap();
    assert_eq!(parsed.id, 0x1234);
}

#[test]
fn test_dns_name_encoding() {
    let question = dns::DnsQuestion::new("www.example.com", dns::TYPE_A);
    let bytes = question.to_bytes();

    // Format: 3www7example3com0
    assert_eq!(bytes[0], 3);
    assert_eq!(&bytes[1..4], b"www");
    assert_eq!(bytes[4], 7);
    assert_eq!(&bytes[5..12], b"example");
    assert_eq!(bytes[12], 3);
    assert_eq!(&bytes[13..16], b"com");
    assert_eq!(bytes[16], 0); // End of name
}

#[test]
fn test_dns_message_serialization() {
    let query = dns::DnsMessage::query("test.local", dns::TYPE_A);
    let bytes = query.to_bytes();

    // Should be parseable
    let parsed = dns::DnsMessage::from_bytes(&bytes).unwrap();
    assert_eq!(parsed.header.id, query.header.id);
    assert_eq!(parsed.questions.len(), 1);
    assert_eq!(parsed.questions[0].name, "test.local");
}

#[test]
fn test_dns_response_parsing() {
    // Construire une reponse DNS simple
    let mut response_bytes = Vec::new();

    // Header
    response_bytes.extend_from_slice(&[
        0x12, 0x34, // ID
        0x81, 0x80, // Flags: response, RD, RA
        0x00, 0x01, // QDCOUNT
        0x00, 0x01, // ANCOUNT
        0x00, 0x00, // NSCOUNT
        0x00, 0x00, // ARCOUNT
    ]);

    // Question: test.local
    response_bytes.extend_from_slice(&[4, b't', b'e', b's', b't', 5, b'l', b'o', b'c', b'a', b'l', 0]);
    response_bytes.extend_from_slice(&[0x00, 0x01, 0x00, 0x01]); // TYPE A, CLASS IN

    // Answer: pointer to question name, TYPE A, CLASS IN, TTL 300, RDLENGTH 4, RDATA
    response_bytes.extend_from_slice(&[0xC0, 0x0C]); // Compression pointer to offset 12
    response_bytes.extend_from_slice(&[0x00, 0x01]); // TYPE A
    response_bytes.extend_from_slice(&[0x00, 0x01]); // CLASS IN
    response_bytes.extend_from_slice(&[0x00, 0x00, 0x01, 0x2C]); // TTL 300
    response_bytes.extend_from_slice(&[0x00, 0x04]); // RDLENGTH 4
    response_bytes.extend_from_slice(&[192, 168, 1, 100]); // RDATA

    let response = dns::DnsMessage::from_bytes(&response_bytes).unwrap();

    assert!(response.header.is_response());
    assert_eq!(response.header.rcode(), 0);
    assert_eq!(response.answers.len(), 1);

    if let dns::DnsRdata::A(ip) = response.answers[0].rdata {
        assert_eq!(ip, Ipv4Addr::new(192, 168, 1, 100));
    } else {
        panic!("Expected A record");
    }
}

// Integration test (requires network)
#[test]
#[ignore]
fn test_dns_real_query() {
    let client = dns::DnsClient::new(Ipv4Addr::new(8, 8, 8, 8)); // Google DNS

    let result = client.resolve("google.com");
    assert!(result.is_ok());

    let addrs = result.unwrap();
    assert!(!addrs.is_empty());
    println!("google.com resolved to: {:?}", addrs);
}
```

## Criteres d'evaluation
- [ ] ARP: creation request/reply/gratuitous
- [ ] ARP: serialisation/deserialisation correcte
- [ ] ARP spoof detection: detecte les changements de MAC
- [ ] ICMP: tous les types (echo, dest unreachable, time exceeded)
- [ ] ICMP: checksum correct
- [ ] DHCP: messages DORA complets
- [ ] DHCP: parsing des options
- [ ] DHCP client state machine
- [ ] DNS: header et question encoding
- [ ] DNS: compression pointer parsing
- [ ] DNS: support UDP port 53

## Note qualite: 97/100
