# Exercice 3.1.3-a : archiviste_passe

**Module :** 3.1.3 ‚Äî Chiffrement Sym√©trique
**Concept :** a ‚Äî Chiffrements Historiques et OTP
**Difficult√© :** ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ (7/10)
**Type :** complet
**Tiers :** 1 ‚Äî Concept isol√©
**Langage :** Python 3.14
**Pr√©requis :** Bases de programmation, notions de statistiques
**Domaines :** Crypto, Encodage
**Dur√©e estim√©e :** 75 min
**XP Base :** 175
**Complexit√© :** T2 O(n√ó26) √ó S1 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `archiviste_passe.py`
**Autoris√© :** collections, string, json, math
**Interdit :** cryptography, pycrypto, Crypto.*

### 1.2 Consigne

**üéÆ "The Imitation Game" + "Indiana Jones"**

*"Parfois ce sont les personnes dont on n'imagine rien qui font les choses qu'on n'imagine pas."* ‚Äî Alan Turing

Tu es **Dr. Helena Turing**, cryptanalyste et arch√©ologue num√©rique. Des **archives secr√®tes de la Seconde Guerre mondiale** ont √©t√© d√©couvertes dans un bunker oubli√© en Bavi√®re. Les documents sont chiffr√©s avec diverses m√©thodes ‚Äî du simple C√©sar aux syst√®mes plus sophistiqu√©s.

Ton mentor, le Professeur Kasiski (descendant du c√©l√®bre cryptanalyste), t'a laiss√© ses notes : *"La fr√©quence des lettres est le talon d'Achille de tout chiffrement classique. Mais m√©fie-toi de l'OTP mal utilis√© ‚Äî c'est le seul que m√™me Enigma ne pouvait battre... sauf quand les op√©rateurs faisaient des erreurs."*

**Ta mission :**

1. **Casser des chiffrements C√©sar** via analyse fr√©quentielle ou force brute
2. **Casser des chiffrements Vigen√®re** via Kasiski et index de co√Øncidence
3. **Exploiter des OTP r√©utilis√©s** (many-time pad attack)
4. **Impl√©menter le chiffrement parfait** de Shannon (OTP correct)

**Entr√©e :** `input_data: str` ‚Äî JSON avec textes chiffr√©s
**Sortie :** `str` ‚Äî JSON avec textes d√©chiffr√©s et analyses

### 1.2.2 Consigne Acad√©mique

Impl√©menter l'analyse cryptographique de chiffrements classiques :
- **C√©sar** : substitution monoalphab√©tique avec d√©calage fixe
- **Vigen√®re** : substitution polyalphab√©tique avec cl√© r√©p√©t√©e
- **OTP (One-Time Pad)** : XOR avec cl√© al√©atoire de m√™me longueur
- **Analyse fr√©quentielle** : exploiter la distribution statistique des lettres
- **Attaque Kasiski** : d√©tecter la longueur de cl√© Vigen√®re

### 1.3 Prototype

```python
def archiviste_passe(input_data: str) -> str:
    """Analyse et casse des chiffrements historiques."""
    pass

# Helpers attendus
def caesar_decrypt(ciphertext: str, shift: int) -> str: ...
def caesar_crack_frequency(ciphertext: str) -> tuple[str, int]: ...
def vigenere_decrypt(ciphertext: str, key: str) -> str: ...
def kasiski_examination(ciphertext: str) -> list[int]: ...
def index_of_coincidence(text: str) -> float: ...
def otp_encrypt(plaintext: bytes, key: bytes) -> bytes: ...
def many_time_pad_attack(c1: bytes, c2: bytes) -> bytes: ...
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### L'histoire tragique de Mary Stuart

En 1586, **Mary Stuart** (reine d'√âcosse) a √©t√© ex√©cut√©e √† cause d'un chiffrement polyalphab√©tique cass√©. Son code secret a √©t√© d√©chiffr√© par **Thomas Phelippes**, r√©v√©lant son complot contre √âlisabeth I.

### Le g√©nie de Babbage (avant Kasiski!)

**Charles Babbage** avait cass√© le chiffrement de Vigen√®re d√®s 1854, mais n'a jamais publi√©. **Friedrich Kasiski** a red√©couvert la m√©thode en 1863 et lui a donn√© son nom.

### L'erreur fatale du Venona

Pendant la Guerre Froide, les Sovi√©tiques ont r√©utilis√© des pages d'OTP par erreur. Le projet **VENONA** de la NSA a exploit√© ces r√©utilisations pour d√©chiffrer des messages espions pendant 40 ans !

### 2.5 DANS LA VRAIE VIE

- **Forensics Analyst** : Analyse de malware utilisant XOR simple
- **CTF Player** : Crypto challenges classiques
- **Security Historian** : Analyse de communications historiques
- **Pentest** : Reconnaissance de chiffrements faibles

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ python3 archiviste_passe.py
Test C√©sar 'KHOOR ZRUOG': HELLO WORLD (shift=3) ‚úì
Test Vigen√®re 'LXFOPVEFRNHR': ATTACKATDAWN (key=LEMON) ‚úì
Test Kasiski: longueur cl√© = 5 ‚úì
Test OTP r√©utilis√©: XOR r√©cup√©r√© ‚úì
Tous les tests passent!
```

---

## ‚ö° SECTION 3.1 : BONUS AVANC√â (OPTIONNEL)

**Difficult√© :** üî• (10/10) | **XP :** √ó3

Impl√©menter :
- **Attaque par dictionnaire** sur Vigen√®re (mots probables)
- **Hill Cipher** (matrices 2√ó2, 3√ó3) + cassage par known-plaintext
- **Autokey Cipher** : variante de Vigen√®re plus r√©sistante
- **Playfair** : digrammes avec grille 5√ó5

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points | Trap |
|------|-------|----------|--------|------|
| caesar_basic | KHOOR ZRUOG | HELLO WORLD, shift=3 | 10 | Non |
| caesar_negative | EBIIL TLOIA | HELLO WORLD, shift=-3 | 10 | Oui |
| caesar_frequency | Long text | Correct plaintext | 15 | Non |
| vigenere_basic | LXFOPVEFRNHR + LEMON | ATTACKATDAWN | 15 | Non |
| kasiski_detect | Repeated key text | Correct key length | 15 | Non |
| ioc_english | Random English | ~0.065 | 10 | Non |
| otp_encrypt | msg + key | Correct XOR | 10 | Non |
| otp_reuse | c1, c2 same key | m1 XOR m2 | 15 | Oui |

### 4.2 main.py de test

```python
import json
from archiviste_passe import archiviste_passe

def test_caesar():
    inp = json.dumps({
        "ciphertexts": [{"id": 1, "text": "KHOOR ZRUOG", "hint": "caesar"}]
    })
    result = json.loads(archiviste_passe(inp))
    assert result["decryptions"][0]["plaintext"] == "HELLO WORLD"
    assert result["decryptions"][0]["key"] == 3
    print("Test C√©sar: OK")

def test_vigenere():
    inp = json.dumps({
        "ciphertexts": [{"id": 1, "text": "LXFOPVEFRNHR", "hint": "vigenere", "key": "LEMON"}]
    })
    result = json.loads(archiviste_passe(inp))
    assert result["decryptions"][0]["plaintext"] == "ATTACKATDAWN"
    print("Test Vigen√®re: OK")

def test_otp_reuse():
    # c1 = m1 XOR k, c2 = m2 XOR k => c1 XOR c2 = m1 XOR m2
    m1 = b"HELLO"
    m2 = b"WORLD"
    k = b"ABCDE"
    c1 = bytes(a ^ b for a, b in zip(m1, k))
    c2 = bytes(a ^ b for a, b in zip(m2, k))
    inp = json.dumps({
        "otp_reuse": {"c1_hex": c1.hex(), "c2_hex": c2.hex()}
    })
    result = json.loads(archiviste_passe(inp))
    xored = bytes.fromhex(result["otp_analysis"]["m1_xor_m2_hex"])
    assert xored == bytes(a ^ b for a, b in zip(m1, m2))
    print("Test OTP r√©utilis√©: OK")

if __name__ == "__main__":
    test_caesar()
    test_vigenere()
    test_otp_reuse()
    print("Tous les tests passent!")
```

### 4.3 Solution de r√©f√©rence

```python
import json
from collections import Counter
import string

# Fr√©quences anglaises (source: Wikipedia)
ENGLISH_FREQ = {
    'E': 12.70, 'T': 9.06, 'A': 8.17, 'O': 7.51, 'I': 6.97, 'N': 6.75,
    'S': 6.33, 'H': 6.09, 'R': 5.99, 'D': 4.25, 'L': 4.03, 'C': 2.78,
    'U': 2.76, 'M': 2.41, 'W': 2.36, 'F': 2.23, 'G': 2.02, 'Y': 1.97,
    'P': 1.93, 'B': 1.29, 'V': 0.98, 'K': 0.77, 'J': 0.15, 'X': 0.15,
    'Q': 0.10, 'Z': 0.07
}

def caesar_decrypt(ciphertext: str, shift: int) -> str:
    result = []
    for c in ciphertext.upper():
        if c in string.ascii_uppercase:
            result.append(chr((ord(c) - ord('A') - shift) % 26 + ord('A')))
        else:
            result.append(c)
    return ''.join(result)

def frequency_score(text: str) -> float:
    """Score bas√© sur la corr√©lation avec les fr√©quences anglaises."""
    text = ''.join(c for c in text.upper() if c in string.ascii_uppercase)
    if not text:
        return 0
    counts = Counter(text)
    total = len(text)
    score = 0
    for letter, expected in ENGLISH_FREQ.items():
        observed = counts.get(letter, 0) / total * 100
        score += observed * expected  # Corr√©lation
    return score

def caesar_crack_frequency(ciphertext: str) -> tuple[str, int]:
    """Casse C√©sar par analyse fr√©quentielle."""
    best_score = -1
    best_shift = 0
    best_text = ""
    for shift in range(26):
        decrypted = caesar_decrypt(ciphertext, shift)
        score = frequency_score(decrypted)
        if score > best_score:
            best_score = score
            best_shift = shift
            best_text = decrypted
    return best_text, best_shift

def vigenere_decrypt(ciphertext: str, key: str) -> str:
    """D√©chiffre Vigen√®re avec une cl√© connue."""
    result = []
    key = key.upper()
    key_index = 0
    for c in ciphertext.upper():
        if c in string.ascii_uppercase:
            shift = ord(key[key_index % len(key)]) - ord('A')
            result.append(chr((ord(c) - ord('A') - shift) % 26 + ord('A')))
            key_index += 1
        else:
            result.append(c)
    return ''.join(result)

def index_of_coincidence(text: str) -> float:
    """Calcule l'IC d'un texte (anglais ~0.065, al√©atoire ~0.038)."""
    text = ''.join(c for c in text.upper() if c in string.ascii_uppercase)
    n = len(text)
    if n <= 1:
        return 0
    counts = Counter(text)
    ic = sum(c * (c - 1) for c in counts.values()) / (n * (n - 1))
    return ic

def kasiski_examination(ciphertext: str) -> list[int]:
    """Trouve les longueurs de cl√© probables via r√©p√©titions."""
    from math import gcd
    from functools import reduce

    text = ''.join(c for c in ciphertext.upper() if c in string.ascii_uppercase)
    distances = []

    # Chercher les trigrammes r√©p√©t√©s
    for length in range(3, 6):
        seen = {}
        for i in range(len(text) - length + 1):
            ngram = text[i:i+length]
            if ngram in seen:
                distances.append(i - seen[ngram])
            seen[ngram] = i

    if not distances:
        return [1]

    # Factoriser les distances
    factors = Counter()
    for d in distances:
        for f in range(2, min(d + 1, 20)):
            if d % f == 0:
                factors[f] += 1

    # Retourner les facteurs les plus fr√©quents
    return [f for f, _ in factors.most_common(5)]

def otp_encrypt(plaintext: bytes, key: bytes) -> bytes:
    """OTP = XOR avec cl√© de m√™me longueur."""
    if len(key) < len(plaintext):
        raise ValueError("OTP key must be at least as long as plaintext")
    return bytes(p ^ k for p, k in zip(plaintext, key))

def many_time_pad_attack(c1: bytes, c2: bytes) -> bytes:
    """Si c1 = m1 XOR k et c2 = m2 XOR k, retourne m1 XOR m2."""
    return bytes(a ^ b for a, b in zip(c1, c2))

def archiviste_passe(input_data: str) -> str:
    data = json.loads(input_data)
    result = {"decryptions": [], "frequency_analysis": None, "otp_analysis": None}

    # Traiter les textes chiffr√©s
    for ct in data.get("ciphertexts", []):
        hint = ct.get("hint", "").lower()
        text = ct.get("text", "")

        if "caesar" in hint:
            if "key" in ct:
                plaintext = caesar_decrypt(text, ct["key"])
                key = ct["key"]
            else:
                plaintext, key = caesar_crack_frequency(text)
            result["decryptions"].append({
                "id": ct["id"],
                "plaintext": plaintext,
                "method": "caesar",
                "key": key
            })

        elif "vigenere" in hint:
            if "key" in ct:
                plaintext = vigenere_decrypt(text, ct["key"])
                result["decryptions"].append({
                    "id": ct["id"],
                    "plaintext": plaintext,
                    "method": "vigenere",
                    "key": ct["key"]
                })
            else:
                # Kasiski pour trouver la longueur
                key_lengths = kasiski_examination(text)
                result["decryptions"].append({
                    "id": ct["id"],
                    "probable_key_lengths": key_lengths,
                    "method": "vigenere_analysis"
                })

    # Analyse fr√©quentielle
    if "frequency_analysis_target" in data:
        target = data["frequency_analysis_target"]
        letters = ''.join(c for c in target.upper() if c in string.ascii_uppercase)
        counts = Counter(letters)
        total = len(letters)
        result["frequency_analysis"] = {
            "letter_frequencies": {k: round(v / total * 100, 2) for k, v in counts.most_common()},
            "index_of_coincidence": round(index_of_coincidence(target), 4)
        }

    # Attaque OTP r√©utilis√©
    if "otp_reuse" in data:
        c1 = bytes.fromhex(data["otp_reuse"]["c1_hex"])
        c2 = bytes.fromhex(data["otp_reuse"]["c2_hex"])
        xored = many_time_pad_attack(c1, c2)
        result["otp_analysis"] = {
            "m1_xor_m2_hex": xored.hex(),
            "warning": "XOR of plaintexts recovered - key reuse detected"
        }

    return json.dumps(result)
```

### 4.10 Solutions Mutantes

```python
# Mutant A: C√©sar sans gestion de la casse
def caesar_decrypt_mutant_a(text, shift):
    return ''.join(chr((ord(c) - ord('A') - shift) % 26 + ord('A')) for c in text)
    # ‚ùå Crash si caract√®re non-majuscule

# Mutant B: Vigen√®re avec key_index qui ne s'incr√©mente pas
def vigenere_decrypt_mutant_b(text, key):
    result = []
    key_index = 0
    for c in text.upper():
        if c in string.ascii_uppercase:
            shift = ord(key[key_index % len(key)]) - ord('A')
            result.append(chr((ord(c) - shift) % 26 + ord('A')))
            # ‚ùå MANQUE: key_index += 1
    # Utilise toujours key[0]!

# Mutant C: IC avec division par z√©ro
def ioc_mutant_c(text):
    counts = Counter(text)
    n = len(text)
    return sum(c * (c-1) for c in counts.values()) / (n * (n-1))
    # ‚ùå Division par z√©ro si n <= 1

# Mutant D: OTP sans v√©rification de longueur
def otp_encrypt_mutant_d(plaintext, key):
    return bytes(p ^ k for p, k in zip(plaintext, key))
    # ‚ùå Tronque silencieusement si key trop courte

# Mutant E: Kasiski retournant toujours [1]
def kasiski_mutant_e(text):
    return [1]  # ‚ùå Ne fait pas l'analyse
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Substitution monoalphab√©tique** (C√©sar) : m√™me lettre ‚Üí m√™me substitut
2. **Substitution polyalphab√©tique** (Vigen√®re) : cl√© r√©p√©t√©e change la substitution
3. **OTP (One-Time Pad)** : s√©curit√© parfaite de Shannon si la cl√© est unique
4. **Analyse fr√©quentielle** : exploiter les statistiques du langage
5. **Kasiski** : d√©tecter la p√©riodicit√© pour trouver la longueur de cl√©

### 5.2 LDA

```
FONCTION caesar_crack_frequency(ciphertext)
D√âBUT
    AFFECTER -1 √Ä meilleur_score
    POUR shift ALLANT DE 0 √Ä 25 FAIRE
        D√âCLARER texte COMME caesar_decrypt(ciphertext, shift)
        D√âCLARER score COMME frequency_score(texte)
        SI score EST SUP√âRIEUR √Ä meilleur_score ALORS
            AFFECTER score √Ä meilleur_score
            AFFECTER shift √Ä meilleur_shift
        FIN SI
    FIN POUR
    RETOURNER (texte_d√©chiffr√©, meilleur_shift)
FIN
```

### 5.3 Visualisation ASCII

**Chiffrement de C√©sar (shift=3)**

```
Alphabet clair:    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                   ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì
Alphabet chiffr√©:  D E F G H I J K L M N O P Q R S T U V W X Y Z A B C

HELLO ‚Üí KHOOR
```

**Analyse Fr√©quentielle**

```
Fr√©quences en anglais:
E ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 12.7%
T ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  9.1%
A ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  8.2%
O ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  7.5%
...
Z ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  0.1%

Si dans le texte chiffr√©, 'K' appara√Æt 12.7% ‚Üí K est probablement E
‚Üí shift = K - E = 10 - 4 = 6
```

**OTP R√©utilis√© (Many-Time Pad)**

```
m‚ÇÅ = "HELLO"     k = "XMCKL"     c‚ÇÅ = m‚ÇÅ ‚äï k = 0x00 0x01 ...
m‚ÇÇ = "WORLD"     k = "XMCKL"     c‚ÇÇ = m‚ÇÇ ‚äï k = 0x01 0x02 ...

c‚ÇÅ ‚äï c‚ÇÇ = (m‚ÇÅ ‚äï k) ‚äï (m‚ÇÇ ‚äï k) = m‚ÇÅ ‚äï m‚ÇÇ  ‚Üê LA CL√â S'ANNULE!

Avec m‚ÇÅ ‚äï m‚ÇÇ et un peu de crib-dragging, on reconstruit les messages.
```

### 5.4 Pi√®ges

| Pi√®ge | Impact | Solution |
|-------|--------|----------|
| Non-lettres dans C√©sar | Caract√®res corrompus | Pr√©server les non-lettres |
| key_index ne s'incr√©mente pas | Vigen√®re devient C√©sar | Toujours incr√©menter sur lettre |
| OTP cl√© trop courte | Troncation silencieuse | V√©rifier len(key) >= len(msg) |
| IC sur texte court | Division par z√©ro | V√©rifier n > 1 |

### 5.8 Mn√©motechniques

**üéÆ MEME : "You shall not pass!" ‚Äî OTP mal utilis√©**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Gandalf (OTP): "ONE KEY SHALL NOT PASS... TWICE!"         ‚îÇ
‚îÇ                                                            ‚îÇ
‚îÇ  Soviets: *r√©utilisent une page d'OTP*                    ‚îÇ
‚îÇ  NSA: "This is VENONA! I saw you reuse that key."         ‚îÇ
‚îÇ                                                            ‚îÇ
‚îÇ  40 ans de messages d√©chiffr√©s plus tard...                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**üé¨ MEME : "The Imitation Game"**

```
Alan Turing: "Je peux casser n'importe quel chiffrement
             bas√© sur les statistiques du langage."

Vigen√®re: "Mais je suis polyalphab√©tique!"

Turing: "Kasiski a entr√© dans le chat...
         Ta cl√© se r√©p√®te. GG."
```

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| Pi√®ge | Pr√©vention |
|-------|------------|
| Non-lettres | Pr√©server ou filtrer explicitement |
| Cl√© Vigen√®re non-incr√©ment√©e | Incr√©menter sur chaque lettre |
| OTP courte | V√©rifier len(key) >= len(plaintext) |
| IC division par z√©ro | V√©rifier n > 1 |

---

## üìù SECTION 7 : QCM

**Q1:** Quel est le shift de C√©sar pour "KHOOR" ‚Üí "HELLO"?
A) 3 ‚úì  B) -3  C) 23  D) 7

**Q2:** Pourquoi OTP est-il "parfait" selon Shannon?
A) Cl√© tr√®s longue  B) Entropie maximale, pas d'information sur m ‚úì  C) Difficile √† impl√©menter  D) Utilise AES

**Q3:** Kasiski exploite quoi?
A) Fr√©quences  B) R√©p√©titions dues √† la cl√© p√©riodique ‚úì  C) Mots connus  D) Faiblesse de XOR

**Q4:** IC de l'anglais ‚âà ?
A) 0.038  B) 0.050  C) 0.065 ‚úì  D) 0.100

**Q5:** Si c1 = m1‚äïk et c2 = m2‚äïk, que vaut c1‚äïc2?
A) k  B) m1  C) m2  D) m1‚äïm2 ‚úì

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.3-a : archiviste_passe |
| Concepts | C√©sar, Vigen√®re, OTP, Kasiski, IC |
| Difficult√© | 7/10 |
| XP | 175 / 525 (bonus) |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.1.3-a-archiviste_passe",
    "metadata": {
      "exercise_id": "3.1.3-a",
      "difficulty": 7,
      "language": "python",
      "xp_base": 175,
      "bonus_tier": "AVANC√â",
      "domains": ["Crypto", "Encodage"]
    }
  }
}
```

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
