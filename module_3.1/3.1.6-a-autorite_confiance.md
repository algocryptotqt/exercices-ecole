# Exercice 3.1.6-a : autorite_confiance

**Module :** 3.1.6 â€” Infrastructure Ã  ClÃ©s Publiques (PKI)

**Concept :** a â€” Certificats X.509 et chaÃ®ne de confiance

**DifficultÃ© :** â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :** complet

**Tiers :** 1 â€” Concept isolÃ©

**Langage :** Python 3.14

**PrÃ©requis :** 3.1.4-a, 3.1.5-a (RSA, fonctions de hachage)

**Domaines :** Crypto, Net

**DurÃ©e estimÃ©e :** 120 min

**XP Base :** 275

**ComplexitÃ© :** T3 O(nÂ·chain_length) Ã— S2 O(cert_size)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `autorite_confiance.py`
**AutorisÃ© :** cryptography, pyOpenSSL, datetime
**Interdit :** Appels externes Ã  openssl CLI

### 1.2 Consigne

**ğŸ® "Inception" â€” Les Niveaux de Confiance**

*"Nous devons aller plus profond..."* â€” Dom Cobb

Tu es **Dom Cobb**, expert en extraction de secrets. Mais cette fois, tu dois construire des rÃªves plutÃ´t que de les infiltrer. Chaque niveau de rÃªve est comme un niveau de la chaÃ®ne de certificats : **Root CA â†’ Intermediate â†’ Leaf**.

*"Le totem de confiance, c'est la signature du CA. Sans elle, tu ne sais pas si tu es dans le rÃªve de quelqu'un d'autre ou dans la rÃ©alitÃ©."*

**Mal** a compromis un Intermediate CA. Ta mission : dÃ©tecter les certificats frauduleux et maintenir l'intÃ©gritÃ© de la chaÃ®ne de confiance.

**Ta mission :**

1. **Parser des certificats X.509** et extraire les champs critiques
2. **Valider une chaÃ®ne de certificats** (signatures, dates, extensions)
3. **VÃ©rifier la rÃ©vocation** via CRL et OCSP
4. **Comprendre Certificate Transparency** (SCT)
5. **GÃ©nÃ©rer des CSR** et simuler le workflow CA

### 1.3 Prototype

```python
def autorite_confiance(input_json: str) -> str:
    """Point d'entrÃ©e principal"""
    pass

# Parsing et extraction
def parse_certificate(cert_pem: str) -> dict:
    """Parse un certificat X.509 et extrait les champs"""
    pass

def extract_extensions(cert) -> dict:
    """Extrait les extensions X.509v3"""
    pass

# Validation de chaÃ®ne
def validate_certificate_chain(leaf_pem: str, intermediates: list[str],
                              trusted_roots: list[str],
                              current_time: datetime = None) -> dict:
    """Valide une chaÃ®ne de certificats complÃ¨te"""
    pass

def verify_signature(cert, issuer_cert) -> bool:
    """VÃ©rifie la signature d'un certificat par son Ã©metteur"""
    pass

# RÃ©vocation
def check_revocation_crl(cert_pem: str, crl_pem: str) -> dict:
    """VÃ©rifie la rÃ©vocation via CRL"""
    pass

def check_revocation_ocsp(cert_pem: str, issuer_pem: str, ocsp_url: str) -> dict:
    """VÃ©rifie la rÃ©vocation via OCSP"""
    pass

# Certificate Transparency
def verify_sct(cert_pem: str, sct_list: list) -> dict:
    """VÃ©rifie les Signed Certificate Timestamps"""
    pass

# CSR et gÃ©nÃ©ration
def generate_csr(common_name: str, san_list: list[str],
                key_type: str = 'rsa', key_size: int = 2048) -> dict:
    """GÃ©nÃ¨re une CSR"""
    pass

def sign_certificate(csr_pem: str, ca_cert_pem: str, ca_key_pem: str,
                    validity_days: int = 365) -> str:
    """Signe une CSR avec un CA"""
    pass
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### DigiNotar Disaster (2011)

Un CA nÃ©erlandais compromis a Ã©mis des certificats frauduleux pour google.com. UtilisÃ©s pour intercepter le trafic de 300,000 utilisateurs iraniens. DigiNotar a fait faillite en quelques semaines.

### Let's Encrypt Revolution

LancÃ© en 2015, Let's Encrypt a rÃ©volutionnÃ© PKI en offrant des certificats gratuits et automatisÃ©s. Aujourd'hui, plus de 300 millions de sites l'utilisent.

### Certificate Transparency

AprÃ¨s les scandales des CAs compromis, Google a imposÃ© CT en 2018. Chaque certificat doit Ãªtre loguÃ© dans des registres publics auditÃ©s, permettant de dÃ©tecter les certificats frauduleux.

### 2.5 DANS LA VRAIE VIE

- **PKI Administrator** : GÃ©rer l'infrastructure de certificats d'entreprise
- **Security Engineer** : Configurer mTLS pour microservices
- **Compliance** : S'assurer de la conformitÃ© des certificats

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ python autorite_confiance.py
Certificate parsed: CN=example.com, expires 2025-01-01 âœ“
Chain validation: Root â†’ Intermediate â†’ Leaf: VALID âœ“
CRL check: Not revoked âœ“
OCSP check: Good âœ“
SCT verification: 3 valid SCTs from recognized logs âœ“
CSR generated for api.example.com âœ“
Tous les tests passent!
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```python
from cryptography import x509
from cryptography.x509.oid import NameOID, ExtensionOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
from cryptography.hazmat.backends import default_backend
from datetime import datetime, timezone, timedelta
import json

def parse_certificate(cert_pem: str) -> dict:
    """Parse un certificat X.509 et extrait les champs critiques."""
    cert = x509.load_pem_x509_certificate(cert_pem.encode())

    # Subject
    subject = {}
    for attr in cert.subject:
        subject[attr.oid._name] = attr.value

    # Issuer
    issuer = {}
    for attr in cert.issuer:
        issuer[attr.oid._name] = attr.value

    # Public key info
    pub_key = cert.public_key()
    if isinstance(pub_key, rsa.RSAPublicKey):
        key_info = {
            'algorithm': 'RSA',
            'size': pub_key.key_size
        }
    elif isinstance(pub_key, ec.EllipticCurvePublicKey):
        key_info = {
            'algorithm': 'ECDSA',
            'curve': pub_key.curve.name
        }
    else:
        key_info = {'algorithm': 'Unknown'}

    # Extensions
    extensions = extract_extensions(cert)

    return {
        'version': cert.version.value + 1,  # X.509v3 = value 2
        'serial_number': format(cert.serial_number, 'x'),
        'subject': subject,
        'issuer': issuer,
        'validity': {
            'not_before': cert.not_valid_before_utc.isoformat(),
            'not_after': cert.not_valid_after_utc.isoformat()
        },
        'public_key': key_info,
        'signature_algorithm': cert.signature_algorithm_oid._name,
        'extensions': extensions
    }


def extract_extensions(cert) -> dict:
    """Extrait les extensions X.509v3 importantes."""
    extensions = {}

    try:
        # Basic Constraints
        bc = cert.extensions.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS)
        extensions['basic_constraints'] = {
            'ca': bc.value.ca,
            'path_length': bc.value.path_length,
            'critical': bc.critical
        }
    except x509.ExtensionNotFound:
        pass

    try:
        # Key Usage
        ku = cert.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
        usages = []
        if ku.value.digital_signature: usages.append('digitalSignature')
        if ku.value.key_encipherment: usages.append('keyEncipherment')
        if ku.value.key_cert_sign: usages.append('keyCertSign')
        if ku.value.crl_sign: usages.append('cRLSign')
        extensions['key_usage'] = usages
    except x509.ExtensionNotFound:
        pass

    try:
        # Extended Key Usage
        eku = cert.extensions.get_extension_for_oid(ExtensionOID.EXTENDED_KEY_USAGE)
        extensions['extended_key_usage'] = [oid._name for oid in eku.value]
    except x509.ExtensionNotFound:
        pass

    try:
        # Subject Alternative Name
        san = cert.extensions.get_extension_for_oid(ExtensionOID.SUBJECT_ALTERNATIVE_NAME)
        names = []
        for name in san.value:
            if isinstance(name, x509.DNSName):
                names.append(f"DNS:{name.value}")
            elif isinstance(name, x509.IPAddress):
                names.append(f"IP:{name.value}")
        extensions['subject_alt_name'] = names
    except x509.ExtensionNotFound:
        pass

    try:
        # Authority Information Access (OCSP, CA Issuers)
        aia = cert.extensions.get_extension_for_oid(ExtensionOID.AUTHORITY_INFORMATION_ACCESS)
        aia_info = {}
        for desc in aia.value:
            if desc.access_method == x509.oid.AuthorityInformationAccessOID.OCSP:
                aia_info['ocsp'] = desc.access_location.value
            elif desc.access_method == x509.oid.AuthorityInformationAccessOID.CA_ISSUERS:
                aia_info['ca_issuers'] = desc.access_location.value
        extensions['authority_info_access'] = aia_info
    except x509.ExtensionNotFound:
        pass

    return extensions


def verify_signature(cert, issuer_cert) -> bool:
    """VÃ©rifie que cert est signÃ© par issuer_cert."""
    try:
        issuer_public_key = issuer_cert.public_key()

        if isinstance(issuer_public_key, rsa.RSAPublicKey):
            issuer_public_key.verify(
                cert.signature,
                cert.tbs_certificate_bytes,
                padding.PKCS1v15(),
                cert.signature_hash_algorithm
            )
        elif isinstance(issuer_public_key, ec.EllipticCurvePublicKey):
            issuer_public_key.verify(
                cert.signature,
                cert.tbs_certificate_bytes,
                ec.ECDSA(cert.signature_hash_algorithm)
            )
        return True
    except Exception:
        return False


def validate_certificate_chain(leaf_pem: str, intermediates: list[str],
                               trusted_roots: list[str],
                               current_time: datetime = None) -> dict:
    """
    Valide une chaÃ®ne de certificats complÃ¨te.

    VÃ©rifie:
    1. Signatures (chaque cert signÃ© par le suivant)
    2. Dates de validitÃ©
    3. Basic Constraints (CA:TRUE pour intermediates/root)
    4. Key Usage
    5. Path length constraints
    """
    if current_time is None:
        current_time = datetime.now(timezone.utc)

    # Charger tous les certificats
    leaf = x509.load_pem_x509_certificate(leaf_pem.encode())
    intermediate_certs = [x509.load_pem_x509_certificate(p.encode()) for p in intermediates]
    root_certs = [x509.load_pem_x509_certificate(p.encode()) for p in trusted_roots]

    chain = [leaf] + intermediate_certs
    checks = []
    valid = True

    # 1. VÃ©rifier les dates de validitÃ©
    for i, cert in enumerate(chain):
        name = "leaf" if i == 0 else f"intermediate_{i}"
        if current_time < cert.not_valid_before_utc:
            checks.append({'check': f'{name}_not_yet_valid', 'passed': False})
            valid = False
        elif current_time > cert.not_valid_after_utc:
            checks.append({'check': f'{name}_expired', 'passed': False})
            valid = False
        else:
            checks.append({'check': f'{name}_validity', 'passed': True})

    # 2. VÃ©rifier les signatures dans la chaÃ®ne
    for i in range(len(chain) - 1):
        child = chain[i]
        parent = chain[i + 1]
        if verify_signature(child, parent):
            checks.append({'check': f'signature_{i}_to_{i+1}', 'passed': True})
        else:
            checks.append({'check': f'signature_{i}_to_{i+1}', 'passed': False})
            valid = False

    # 3. VÃ©rifier que le dernier intermediate est signÃ© par un root trusted
    if intermediate_certs:
        last_intermediate = chain[-1]
        root_found = False
        for root in root_certs:
            if verify_signature(last_intermediate, root):
                root_found = True
                checks.append({'check': 'root_signature', 'passed': True, 'root_cn': root.subject.get_attributes_for_oid(NameOID.COMMON_NAME)[0].value})
                break
        if not root_found:
            checks.append({'check': 'root_signature', 'passed': False})
            valid = False
    else:
        # Leaf directement signÃ© par root
        root_found = False
        for root in root_certs:
            if verify_signature(leaf, root):
                root_found = True
                checks.append({'check': 'root_signature', 'passed': True})
                break
        if not root_found:
            checks.append({'check': 'root_signature', 'passed': False})
            valid = False

    # 4. VÃ©rifier Basic Constraints des CAs
    for i, cert in enumerate(intermediate_certs):
        try:
            bc = cert.extensions.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS)
            if bc.value.ca:
                checks.append({'check': f'intermediate_{i}_is_ca', 'passed': True})
            else:
                checks.append({'check': f'intermediate_{i}_is_ca', 'passed': False})
                valid = False
        except x509.ExtensionNotFound:
            checks.append({'check': f'intermediate_{i}_basic_constraints_missing', 'passed': False})
            valid = False

    # 5. VÃ©rifier Key Usage pour les CAs
    for i, cert in enumerate(intermediate_certs):
        try:
            ku = cert.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
            if ku.value.key_cert_sign:
                checks.append({'check': f'intermediate_{i}_keyCertSign', 'passed': True})
            else:
                checks.append({'check': f'intermediate_{i}_keyCertSign', 'passed': False})
                valid = False
        except x509.ExtensionNotFound:
            pass  # Key Usage optionnel

    return {
        'valid': valid,
        'checks': checks,
        'chain_length': len(chain) + 1  # +1 for root
    }


def generate_csr(common_name: str, san_list: list[str],
                 key_type: str = 'rsa', key_size: int = 2048) -> dict:
    """GÃ©nÃ¨re une CSR avec clÃ© privÃ©e."""
    # GÃ©nÃ©rer la clÃ©
    if key_type == 'rsa':
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend()
        )
    elif key_type == 'ecdsa':
        private_key = ec.generate_private_key(
            ec.SECP256R1(),
            backend=default_backend()
        )
    else:
        raise ValueError(f"Key type not supported: {key_type}")

    # Construire la CSR
    subject = x509.Name([
        x509.NameAttribute(NameOID.COMMON_NAME, common_name),
    ])

    # Subject Alternative Names
    san_entries = []
    for san in san_list:
        if san.startswith('IP:'):
            import ipaddress
            san_entries.append(x509.IPAddress(ipaddress.ip_address(san[3:])))
        else:
            san_entries.append(x509.DNSName(san))

    builder = x509.CertificateSigningRequestBuilder()
    builder = builder.subject_name(subject)

    if san_entries:
        builder = builder.add_extension(
            x509.SubjectAlternativeName(san_entries),
            critical=False
        )

    csr = builder.sign(private_key, hashes.SHA256(), default_backend())

    # Exporter
    csr_pem = csr.public_bytes(serialization.Encoding.PEM).decode()
    key_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    ).decode()

    return {
        'csr_pem': csr_pem,
        'private_key_pem': key_pem,
        'subject': common_name,
        'san': san_list
    }


def autorite_confiance(input_json: str) -> str:
    """Point d'entrÃ©e principal."""
    data = json.loads(input_json)
    results = {}

    # Parse certificate
    if 'certificate_analysis' in data:
        results['certificates'] = []
        for item in data['certificate_analysis']:
            parsed = parse_certificate(item['cert_pem'])
            results['certificates'].append(parsed)

    # Chain validation
    if 'chain_validation' in data:
        cv = data['chain_validation']
        current_time = datetime.fromisoformat(cv['current_time']) if 'current_time' in cv else None
        results['chain_validation'] = validate_certificate_chain(
            cv['leaf_pem'],
            cv.get('intermediates', []),
            cv['trusted_roots'],
            current_time
        )

    # CSR generation
    if 'csr_generation' in data:
        csr_req = data['csr_generation']
        results['csr'] = generate_csr(
            csr_req['common_name'],
            csr_req.get('san', []),
            csr_req.get('key_type', 'rsa'),
            csr_req.get('key_size', 2048)
        )

    return json.dumps(results, indent=2, default=str)
```

### 4.10 Solutions Mutantes

```python
# Mutant A (Safety): Pas de vÃ©rification de date
def validate_certificate_chain_mutant_a(leaf_pem, intermediates, roots, current_time=None):
    # âŒ Ne vÃ©rifie pas les dates de validitÃ©!
    # Certificat expirÃ© acceptÃ©
    ...

# Mutant B (Logic): Accepte CA:FALSE pour intermediate
def validate_certificate_chain_mutant_b(leaf_pem, intermediates, roots, current_time=None):
    ...
    # âŒ Ne vÃ©rifie pas Basic Constraints CA=TRUE
    # Un leaf cert pourrait signer d'autres certs!

# Mutant C (Boundary): Ne vÃ©rifie pas path length
def validate_certificate_chain_mutant_c(leaf_pem, intermediates, roots, current_time=None):
    ...
    # âŒ Ignore path_length constraint
    # ChaÃ®ne trop longue acceptÃ©e

# Mutant D (Resource): Signature vÃ©rifiÃ©e contre le mauvais cert
def verify_signature_mutant_d(cert, issuer_cert):
    # âŒ VÃ©rifie avec cert au lieu de issuer_cert!
    public_key = cert.public_key()  # ERREUR!
    ...

# Mutant E (Return): CSR sans SAN
def generate_csr_mutant_e(common_name, san_list, key_type='rsa', key_size=2048):
    # âŒ Ignore san_list!
    # Certificat ne protÃ©gera pas les sous-domaines
    ...
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

- **Structure X.509** : Champs, extensions, OIDs
- **ChaÃ®ne de confiance** : Root â†’ Intermediate â†’ Leaf
- **Validation** : Signatures, dates, contraintes
- **RÃ©vocation** : CRL, OCSP, CT
- **Workflow CA** : CSR â†’ Signature â†’ Certificat

### 5.3 Visualisation ASCII

```
HIÃ‰RARCHIE PKI
==============

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ROOT CA                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Subject: CN=Root CA                                            â”‚   â”‚
â”‚  â”‚  Issuer: CN=Root CA (self-signed)                               â”‚   â”‚
â”‚  â”‚  Basic Constraints: CA:TRUE, pathLen:1                          â”‚   â”‚
â”‚  â”‚  Key Usage: keyCertSign, cRLSign                                â”‚   â”‚
â”‚  â”‚  Validity: 20 years                                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                â”‚                                         â”‚
â”‚                                â”‚ signs                                   â”‚
â”‚                                â–¼                                         â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚                      â”‚ INTERMEDIATE CA  â”‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Subject: CN=Intermediate CA                                    â”‚   â”‚
â”‚  â”‚  Issuer: CN=Root CA                                             â”‚   â”‚
â”‚  â”‚  Basic Constraints: CA:TRUE, pathLen:0                          â”‚   â”‚
â”‚  â”‚  Key Usage: keyCertSign, cRLSign                                â”‚   â”‚
â”‚  â”‚  Validity: 10 years                                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                â”‚                                         â”‚
â”‚                                â”‚ signs                                   â”‚
â”‚                                â–¼                                         â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚                      â”‚  LEAF CERT       â”‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Subject: CN=www.example.com                                    â”‚   â”‚
â”‚  â”‚  Issuer: CN=Intermediate CA                                     â”‚   â”‚
â”‚  â”‚  Basic Constraints: CA:FALSE                                    â”‚   â”‚
â”‚  â”‚  Key Usage: digitalSignature, keyEncipherment                   â”‚   â”‚
â”‚  â”‚  Extended Key Usage: serverAuth, clientAuth                     â”‚   â”‚
â”‚  â”‚  SAN: DNS:www.example.com, DNS:example.com                      â”‚   â”‚
â”‚  â”‚  Validity: 1 year                                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


CERTIFICATE TRANSPARENCY
========================

                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      CA signs    â”‚  New Cert   â”‚
    certificate â”€â”€â”¤  for        â”‚
                  â”‚ example.com â”‚
                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚               â”‚               â”‚
         â–¼               â–¼               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ CT Log 1 â”‚   â”‚ CT Log 2 â”‚   â”‚ CT Log 3 â”‚
   â”‚ (Google) â”‚   â”‚ (Sectigo)â”‚   â”‚ (Let's)  â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
        â”‚              â”‚              â”‚
        â”‚   SCT        â”‚   SCT        â”‚   SCT
        â”‚  (Signed     â”‚  (Signed     â”‚  (Signed
        â”‚  Certificate â”‚  Certificate â”‚  Certificate
        â”‚  Timestamp)  â”‚  Timestamp)  â”‚  Timestamp)
        â”‚              â”‚              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Certificate with   â”‚
            â”‚  embedded SCTs      â”‚
            â”‚  (â‰¥2 required)      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
              Browser validates
              SCTs against known
              CT log public keys


VALIDATION WORKFLOW
===================

Browser receives certificate:

1. BUILD CHAIN
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Leaf  â”‚ â”€â”€â–º â”‚ Intermediate â”‚ â”€â”€â–º â”‚  Root    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. VERIFY SIGNATURES (bottom-up)
   Leaf.signature verified by Intermediate.publicKey? âœ“
   Intermediate.signature verified by Root.publicKey? âœ“

3. CHECK VALIDITY
   Current time within [notBefore, notAfter]? âœ“

4. CHECK EXTENSIONS
   Intermediate: CA:TRUE, keyCertSign? âœ“
   Leaf: CA:FALSE, serverAuth? âœ“
   pathLen constraints respected? âœ“

5. CHECK REVOCATION
   CRL: Leaf serial not in list? âœ“
   OCSP: Response = "good"? âœ“

6. CHECK CT
   â‰¥2 valid SCTs from recognized logs? âœ“

7. CHECK NAME
   example.com matches SAN DNS:example.com? âœ“

ALL CHECKS PASS â†’ ğŸ”’ VALID
```

### 5.8 MnÃ©motechniques

**ğŸ® MEME : "Inception - Deeper Levels"**

Comme dans Inception oÃ¹ chaque niveau de rÃªve nÃ©cessite un "totem" pour vÃ©rifier la rÃ©alitÃ©, chaque niveau de la chaÃ®ne de certificats a une signature qui prouve son authenticitÃ©.

```python
def validate_chain(cert_chain):
    """Tu es dans le rÃªve de qui?"""
    for i, cert in enumerate(cert_chain):
        # Le totem: la signature du niveau supÃ©rieur
        if not verify_signature(cert, cert_chain[i+1]):
            return "Tu es dans le limbo! Signature invalide."
    return "Tu es dans la rÃ©alitÃ©. ChaÃ®ne valide."
```

---

**ğŸŒ€ MEME : "Mal's Rogue Certificate"**

Mal a crÃ©Ã© un faux souvenir â€” comme un CA compromis qui Ã©met des certificats frauduleux. CT est lÃ  pour attraper ces "faux souvenirs" avant qu'ils ne causent des dÃ©gÃ¢ts.

---

## ğŸ“ SECTION 7 : QCM

**Q1:** Que signifie CA:TRUE dans Basic Constraints?
A) Certificat approuvÃ©  B) Peut signer d'autres certificats âœ“  C) Certificat valide  D) Ã‰mis par CA officiel

**Q2:** Pourquoi utiliser un Intermediate CA plutÃ´t que le Root directement?
A) Plus rapide  B) Moins cher  C) Root reste hors-ligne = plus sÃ»r âœ“  D) Plus de validitÃ©

**Q3:** Que vÃ©rifie Certificate Transparency?
A) ValiditÃ© du cert  B) Que le cert est publiquement loggÃ© âœ“  C) RÃ©vocation  D) Performance

**Q4:** Quelle extension liste les domaines protÃ©gÃ©s?
A) Key Usage  B) Basic Constraints  C) Subject Alternative Name âœ“  D) Extended Key Usage

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| Exercice | 3.1.6-a : autorite_confiance |
| Concepts | X.509, chaÃ®ne de confiance, CT, CSR |
| DifficultÃ© | 8/10 |
| XP | 275 |

---

*Exercice gÃ©nÃ©rÃ© par HACKBRAIN v5.5.2*
