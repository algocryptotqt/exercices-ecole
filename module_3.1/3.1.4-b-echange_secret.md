# Exercice 3.1.4-b : echange_secret

**Module :** 3.1.4 ‚Äî Chiffrement Asym√©trique

**Concept :** b ‚Äî Protocoles d'√©change de cl√©s

**Difficult√© :** ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**Type :** complet

**Tiers :** 1 ‚Äî Concept isol√©

**Langage :** Rust Edition 2024

**Pr√©requis :** 3.1.2-a, 3.1.2-b, 3.1.4-a (arithm√©tique modulaire, nombres premiers, RSA)

**Domaines :** Crypto, MD

**Dur√©e estim√©e :** 120 min

**XP Base :** 275

**Complexit√© :** T4 O(k¬≥) √ó S2 O(k)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `echange_secret.rs`
**Autoris√© :** std, rand
**Interdit :** dh, elliptic-curve, p256, ring, openssl

### 1.2 Consigne

**üéÆ "Metal Gear Solid" ‚Äî Codec S√©curis√©**

*"Snake, tu dois √©tablir une communication s√©curis√©e avec Otacon. Mais Big Boss intercepte le r√©seau..."* ‚Äî Colonel Campbell

Tu es **Solid Snake**, en mission d'infiltration. **Otacon** t'attend de l'autre c√¥t√©, mais le r√©seau est surveill√© par **Big Boss** (MITM). Vous devez √©tablir un **canal s√©curis√©** sans jamais √©changer directement de cl√© secr√®te.

*"C'est l√† que Diffie-Hellman entre en jeu, Snake. Vous √©changez des valeurs publiques, mais le secret partag√© reste invisible √† l'ennemi... √† condition de valider les param√®tres."*

Mais Big Boss conna√Æt les faiblesses : **small subgroup attacks**, nonces r√©utilis√©s en DSA, mall√©abilit√© ElGamal.

**Ta mission :**

1. **Impl√©menter Diffie-Hellman** avec validation des param√®tres
2. **D√©tecter les attaques MITM** en comparant les secrets partag√©s
3. **Impl√©menter ElGamal** (chiffrement) et comprendre la mall√©abilit√©
4. **Impl√©menter DSA** avec attention critique aux nonces
5. **R√©cup√©rer une cl√© priv√©e** depuis deux signatures avec nonce r√©utilis√©

### 1.3 Prototype

```rust
pub fn echange_secret(input: &str) -> String

// Diffie-Hellman
struct DhParams { p: BigInt, g: BigInt }
struct DhKeyPair { private: BigInt, public: BigInt }
fn dh_generate_keypair(params: &DhParams) -> DhKeyPair
fn dh_compute_shared_secret(private: &BigInt, other_public: &BigInt, p: &BigInt) -> BigInt
fn dh_validate_public_key(public: &BigInt, params: &DhParams) -> bool

// ElGamal
struct ElGamalKeyPair { private: BigInt, public: BigInt, params: DhParams }
fn elgamal_encrypt(m: &BigInt, public_key: &BigInt, params: &DhParams) -> (BigInt, BigInt)
fn elgamal_decrypt(c1: &BigInt, c2: &BigInt, private_key: &BigInt, p: &BigInt) -> BigInt

// DSA
struct DsaParams { p: BigInt, q: BigInt, g: BigInt }
struct DsaKeyPair { x: BigInt, y: BigInt, params: DsaParams }
fn dsa_sign(message: &[u8], private_key: &BigInt, params: &DsaParams, k: &BigInt) -> (BigInt, BigInt)
fn dsa_verify(message: &[u8], signature: &(BigInt, BigInt), public_key: &BigInt, params: &DsaParams) -> bool
fn dsa_recover_private_key_from_nonce_reuse(msg1: &[u8], sig1: &(BigInt, BigInt), msg2: &[u8], sig2: &(BigInt, BigInt), params: &DsaParams) -> Option<BigInt>
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Le Hack de la PlayStation 3 (2010)

Sony utilisait DSA pour signer les jeux PS3. Mais ils ont commis l'erreur fatale : **utiliser le m√™me nonce k** pour toutes les signatures. Le groupe fail0verflow a r√©cup√©r√© la cl√© priv√©e en direct √† une conf√©rence, d√©verrouillant l'homebrew sur PS3.

### L'attaque Logjam (2015)

Des chercheurs ont d√©couvert que de nombreux serveurs utilisaient le m√™me groupe DH de 512 bits (export-grade). En pr√©calculant le logarithme discret pour ce groupe sp√©cifique, ils pouvaient d√©chiffrer les connexions en temps r√©el.

### 2.5 DANS LA VRAIE VIE

- **Security Engineer** : Audit des impl√©mentations DH/DSA
- **Cryptographer** : Conception de protocoles d'√©change s√©curis√©s
- **Pentester** : Exploitation des nonces faibles en DSA/ECDSA

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ cargo run --release
Diffie-Hellman key exchange: OK ‚úì
Shared secrets match: OK ‚úì
Small subgroup attack detected: REJECTED ‚úì
ElGamal encrypt/decrypt: OK ‚úì
DSA sign/verify: OK ‚úì
Nonce reuse attack - private key recovered: OK ‚úì
Tous les tests passent!
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence (extraits)

```rust
use std::collections::HashMap;

fn mod_pow(base: &BigInt, exp: &BigInt, modulus: &BigInt) -> BigInt {
    let mut result = BigInt::one();
    let mut base = base.clone() % modulus;
    let mut exp = exp.clone();
    while exp > BigInt::zero() {
        if &exp % 2u32 == BigInt::one() {
            result = (result * &base) % modulus;
        }
        exp >>= 1;
        base = (&base * &base) % modulus;
    }
    result
}

fn mod_inverse(a: &BigInt, m: &BigInt) -> Option<BigInt> {
    let (mut old_r, mut r) = (m.clone(), a.clone() % m);
    let (mut old_s, mut s) = (BigInt::zero(), BigInt::one());

    while r != BigInt::zero() {
        let quotient = &old_r / &r;
        let temp_r = r.clone();
        r = &old_r - &quotient * &r;
        old_r = temp_r;
        let temp_s = s.clone();
        s = &old_s - &quotient * &s;
        old_s = temp_s;
    }

    if old_r > BigInt::one() { return None; }
    if old_s < BigInt::zero() { old_s += m; }
    Some(old_s)
}

// Diffie-Hellman
fn dh_generate_keypair(params: &DhParams) -> DhKeyPair {
    let mut rng = rand::thread_rng();
    // Cl√© priv√©e: 2 <= x < p-2
    let private = rng.gen_bigint_range(&BigInt::from(2u32), &(&params.p - 2u32));
    // Cl√© publique: y = g^x mod p
    let public = mod_pow(&params.g, &private, &params.p);
    DhKeyPair { private, public }
}

fn dh_compute_shared_secret(private: &BigInt, other_public: &BigInt, p: &BigInt) -> BigInt {
    mod_pow(other_public, private, p)
}

fn dh_validate_public_key(public: &BigInt, params: &DhParams) -> bool {
    // V√©rifier 1 < public < p-1
    if public <= &BigInt::one() || public >= &(&params.p - 1u32) {
        return false;
    }
    // V√©rifier que public n'est pas dans un petit sous-groupe
    // public^q mod p doit √™tre 1 (o√π q est l'ordre du groupe)
    // Pour un groupe safe prime p = 2q + 1, v√©rifier public^2 != 1
    let test = mod_pow(public, &BigInt::from(2u32), &params.p);
    if test == BigInt::one() {
        return false; // Small subgroup attack!
    }
    true
}

// ElGamal Encryption
fn elgamal_encrypt(m: &BigInt, public_key: &BigInt, params: &DhParams) -> (BigInt, BigInt) {
    let mut rng = rand::thread_rng();
    let k = rng.gen_bigint_range(&BigInt::from(2u32), &(&params.p - 2u32));

    // c1 = g^k mod p
    let c1 = mod_pow(&params.g, &k, &params.p);
    // c2 = m * y^k mod p (o√π y est la cl√© publique)
    let s = mod_pow(public_key, &k, &params.p);
    let c2 = (m * &s) % &params.p;

    (c1, c2)
}

fn elgamal_decrypt(c1: &BigInt, c2: &BigInt, private_key: &BigInt, p: &BigInt) -> BigInt {
    // s = c1^x mod p
    let s = mod_pow(c1, private_key, p);
    // m = c2 * s^(-1) mod p
    let s_inv = mod_inverse(&s, p).unwrap();
    (c2 * &s_inv) % p
}

// DSA
fn sha256_to_bigint(message: &[u8]) -> BigInt {
    use sha2::{Sha256, Digest};
    let hash = Sha256::digest(message);
    BigInt::from_bytes_be(Sign::Plus, &hash)
}

fn dsa_sign(message: &[u8], x: &BigInt, params: &DsaParams, k: &BigInt) -> (BigInt, BigInt) {
    let h = sha256_to_bigint(message) % &params.q;

    // r = (g^k mod p) mod q
    let r = mod_pow(&params.g, k, &params.p) % &params.q;

    // s = k^(-1) * (h + x*r) mod q
    let k_inv = mod_inverse(k, &params.q).unwrap();
    let xr = (x * &r) % &params.q;
    let s = (&k_inv * (&h + &xr)) % &params.q;

    (r, s)
}

fn dsa_verify(message: &[u8], signature: &(BigInt, BigInt), y: &BigInt, params: &DsaParams) -> bool {
    let (r, s) = signature;

    // V√©rifier que 0 < r < q et 0 < s < q
    if r <= &BigInt::zero() || r >= &params.q { return false; }
    if s <= &BigInt::zero() || s >= &params.q { return false; }

    let h = sha256_to_bigint(message) % &params.q;

    // w = s^(-1) mod q
    let w = mod_inverse(s, &params.q).unwrap();

    // u1 = (h * w) mod q
    let u1 = (&h * &w) % &params.q;

    // u2 = (r * w) mod q
    let u2 = (r * &w) % &params.q;

    // v = ((g^u1 * y^u2) mod p) mod q
    let g_u1 = mod_pow(&params.g, &u1, &params.p);
    let y_u2 = mod_pow(y, &u2, &params.p);
    let v = ((&g_u1 * &y_u2) % &params.p) % &params.q;

    v == *r
}

// L'ATTAQUE CRITIQUE: R√©cup√©ration de cl√© priv√©e avec nonce r√©utilis√©
fn dsa_recover_private_key_from_nonce_reuse(
    msg1: &[u8], sig1: &(BigInt, BigInt),
    msg2: &[u8], sig2: &(BigInt, BigInt),
    params: &DsaParams
) -> Option<BigInt> {
    let (r1, s1) = sig1;
    let (r2, s2) = sig2;

    // Les deux signatures doivent avoir le m√™me r (m√™me k utilis√©)
    if r1 != r2 { return None; }

    let h1 = sha256_to_bigint(msg1) % &params.q;
    let h2 = sha256_to_bigint(msg2) % &params.q;

    // Avec le m√™me k:
    // s1 = k^(-1) * (h1 + x*r) mod q
    // s2 = k^(-1) * (h2 + x*r) mod q
    //
    // s1 - s2 = k^(-1) * (h1 - h2) mod q
    // k = (h1 - h2) * (s1 - s2)^(-1) mod q

    let h_diff = (&h1 - &h2 + &params.q) % &params.q;
    let s_diff = (s1 - s2 + &params.q) % &params.q;

    let s_diff_inv = mod_inverse(&s_diff, &params.q)?;
    let k = (&h_diff * &s_diff_inv) % &params.q;

    // Maintenant r√©cup√©rer x:
    // s1 * k = h1 + x*r mod q
    // x = (s1 * k - h1) * r^(-1) mod q
    let r_inv = mod_inverse(r1, &params.q)?;
    let sk = (s1 * &k) % &params.q;
    let x = ((&sk - &h1 + &params.q) * &r_inv) % &params.q;

    Some(x)
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A (Safety): Pas de validation du public key
fn dh_validate_public_key_mutant_a(public: &BigInt, params: &DhParams) -> bool {
    true  // ‚ùå Accepte tout! Vuln√©rable au small subgroup attack
}
// Pourquoi c'est faux: Sans validation, un attaquant peut envoyer g^0=1 ou p-1
// et le secret partag√© sera toujours 1, compromettant la s√©curit√©

// Mutant B (Logic): Mauvais calcul du secret partag√©
fn dh_compute_shared_secret_mutant_b(private: &BigInt, other_public: &BigInt, p: &BigInt) -> BigInt {
    mod_pow(other_public, other_public, p)  // ‚ùå Utilise other_public comme exposant!
}
// Pourquoi c'est faux: Le secret doit √™tre other_public^private mod p

// Mutant C (Resource): DSA avec nonce pr√©visible
fn dsa_sign_mutant_c(message: &[u8], x: &BigInt, params: &DsaParams) -> (BigInt, BigInt) {
    let k = BigInt::from(12345u32);  // ‚ùå Nonce fixe!
    // ... reste du calcul
    dsa_sign_internal(message, x, params, &k)
}
// Pourquoi c'est faux: Deux signatures avec m√™me k = fuite de la cl√© priv√©e

// Mutant D (Boundary): ElGamal avec k=1
fn elgamal_encrypt_mutant_d(m: &BigInt, public_key: &BigInt, params: &DhParams) -> (BigInt, BigInt) {
    let k = BigInt::one();  // ‚ùå k=1 trivial
    let c1 = params.g.clone();  // g^1 = g
    let c2 = (m * public_key) % &params.p;  // m * y^1
    (c1, c2)
}
// Pourquoi c'est faux: c1 = g r√©v√®le que k=1, permettant de calculer le secret

// Mutant E (Return): DSA verify ne v√©rifie pas les bornes
fn dsa_verify_mutant_e(message: &[u8], signature: &(BigInt, BigInt), y: &BigInt, params: &DsaParams) -> bool {
    let (r, s) = signature;
    // ‚ùå Pas de v√©rification 0 < r < q et 0 < s < q
    // ... calcul direct
    let h = sha256_to_bigint(message) % &params.q;
    let w = mod_inverse(s, &params.q).unwrap_or(BigInt::zero());
    // Si s = 0, w sera 0 et la v√©rification passera incorrectement
    true  // Simplifi√© pour l'exemple
}
// Pourquoi c'est faux: Signatures invalides (r=0, s=0) peuvent √™tre accept√©es
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

- **Diffie-Hellman** : √âchange de cl√©s sans canal s√©curis√© pr√©existant
- **Probl√®me du logarithme discret** : Fondement de la s√©curit√© DH/ElGamal/DSA
- **ElGamal** : Chiffrement asym√©trique bas√© sur DH
- **DSA** : Signatures num√©riques et criticit√© des nonces
- **Attaques** : MITM, small subgroup, nonce reuse

### 5.2 LDA ‚Äî Traduction litt√©rale

```
FONCTION dh_compute_shared_secret QUI RETOURNE UN GRAND ENTIER ET PREND EN PARAM√àTRES private QUI EST UN GRAND ENTIER ET other_public QUI EST UN GRAND ENTIER ET p QUI EST UN GRAND ENTIER
D√âBUT FONCTION
    RETOURNER other_public √âLEV√â √Ä LA PUISSANCE private MODULO p
FIN FONCTION

FONCTION dsa_recover_private_key_from_nonce_reuse QUI RETOURNE UN GRAND ENTIER OPTIONNEL ET PREND EN PARAM√àTRES msg1, sig1, msg2, sig2, params
D√âBUT FONCTION
    D√âCLARER h1 COMME LE HASH DE msg1 MODULO q
    D√âCLARER h2 COMME LE HASH DE msg2 MODULO q

    SI r1 EST DIFF√âRENT DE r2 ALORS
        RETOURNER AUCUN
    FIN SI

    D√âCLARER h_diff COMME h1 MOINS h2 MODULO q
    D√âCLARER s_diff COMME s1 MOINS s2 MODULO q

    D√âCLARER k COMME h_diff MULTIPLI√â PAR L'INVERSE DE s_diff MODULO q
    D√âCLARER x COMME s1 MULTIPLI√â PAR k MOINS h1 LE TOUT MULTIPLI√â PAR L'INVERSE DE r MODULO q

    RETOURNER x
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
DIFFIE-HELLMAN KEY EXCHANGE
===========================

    SNAKE                           OTACON
    (Alice)                         (Bob)
       ‚îÇ                               ‚îÇ
       ‚îÇ  Param√®tres publics: p, g     ‚îÇ
       ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
       ‚îÇ                               ‚îÇ
  a = random                     b = random
  A = g^a mod p                  B = g^b mod p
       ‚îÇ                               ‚îÇ
       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ A ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
       ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
       ‚îÇ                               ‚îÇ
  K = B^a mod p                  K = A^b mod p
       ‚îÇ                               ‚îÇ
       ‚ñº                               ‚ñº
  K = g^(ab) mod p    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê    K = g^(ab) mod p
       ‚îÇ                               ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ M√äME SECRET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

BIG BOSS (Eavesdropper) voit: p, g, A, B
Mais calculer K = g^(ab) depuis g^a et g^b est le probl√®me DLP!


ATTAQUE MITM (Man-In-The-Middle)
================================

SNAKE          BIG BOSS          OTACON
   ‚îÇ               ‚îÇ                 ‚îÇ
   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ A ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                 ‚îÇ
   ‚îÇ               ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
   ‚îÇ               ‚îÇ                 ‚îÇ
   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ M ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  (M = g^m)     ‚îÇ
   ‚îÇ               ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ N ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  (N = g^n)
   ‚îÇ               ‚îÇ                 ‚îÇ
   ‚ñº               ‚ñº                 ‚ñº
K1 = M^a        K1 = A^m         K2 = N^b
               K2 = B^n

Snake pense parler √† Otacon avec K1
Otacon pense parler √† Snake avec K2
Big Boss d√©chiffre/rechiffre au milieu!


DSA NONCE REUSE ATTACK (PS3 Hack)
=================================

    Signature 1:                    Signature 2:
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Message: "game1"‚îÇ            ‚îÇ Message: "game2"‚îÇ
    ‚îÇ k = SAME!       ‚îÇ            ‚îÇ k = SAME!       ‚îÇ
    ‚îÇ r = g^k mod p   ‚îÇ            ‚îÇ r = g^k mod p   ‚îÇ
    ‚îÇ s1 = k‚Åª¬π(H‚ÇÅ+xr) ‚îÇ            ‚îÇ s2 = k‚Åª¬π(H‚ÇÇ+xr) ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ                              ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ s1 - s2 =   ‚îÇ
                  ‚îÇ k‚Åª¬π(H‚ÇÅ-H‚ÇÇ)  ‚îÇ
                  ‚îÇ             ‚îÇ
                  ‚îÇ k = (H‚ÇÅ-H‚ÇÇ) ‚îÇ
                  ‚îÇ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ
                  ‚îÇ     s1 - s2 ‚îÇ
                  ‚îÇ             ‚îÇ
                  ‚îÇ x = (s‚ÇÅk-H‚ÇÅ)‚îÇ
                  ‚îÇ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
                  ‚îÇ        r    ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
              üîì PRIVATE KEY RECOVERED! üîì
```

### 5.4 Les pi√®ges en d√©tail

| Pi√®ge | Description | Impact |
|-------|-------------|--------|
| Small subgroup | Cl√© publique dans sous-groupe de petit ordre | Secret partag√© pr√©visible |
| Nonce r√©utilis√© | M√™me k pour deux signatures DSA | Fuite de la cl√© priv√©e |
| ElGamal mall√©able | c2' = c2 * m' ‚Üí d√©chiffre m * m' | Modification de message |
| Pas de validation | Accepter n'importe quelle cl√© publique | Attaques triviales |

### 5.5 Cours Complet

#### Le Probl√®me du Logarithme Discret (DLP)

Le DLP est : √©tant donn√© g, h, p, trouver x tel que g^x ‚â° h (mod p).

Pour des groupes bien choisis (safe primes), c'est calculatoirement infaisable pour des param√®tres de 2048+ bits.

#### Diffie-Hellman

1. Alice et Bob s'accordent sur p (premier) et g (g√©n√©rateur)
2. Alice choisit a al√©atoire, calcule A = g^a mod p
3. Bob choisit b al√©atoire, calcule B = g^b mod p
4. Ils √©changent A et B publiquement
5. Alice calcule K = B^a = g^(ba) mod p
6. Bob calcule K = A^b = g^(ab) mod p
7. K est leur secret partag√©

**S√©curit√©** : Un attaquant voit p, g, A, B mais doit r√©soudre le DLP pour trouver K.

#### ElGamal

Extension de DH pour le chiffrement :
- Cl√© priv√©e : x
- Cl√© publique : y = g^x mod p

Chiffrement de m :
- Choisir k al√©atoire
- c1 = g^k mod p
- c2 = m * y^k mod p

D√©chiffrement :
- s = c1^x mod p
- m = c2 * s^(-1) mod p

**Propri√©t√© de mall√©abilit√©** : Multiplier c2 par m' donne le chiffrement de m * m'.

#### DSA (Digital Signature Algorithm)

Param√®tres : p (3072 bits), q (256 bits, q divise p-1), g (ordre q)

Signature :
1. Choisir k al√©atoire, 0 < k < q
2. r = (g^k mod p) mod q
3. s = k^(-1) * (H(m) + x*r) mod q
4. Signature = (r, s)

V√©rification :
1. w = s^(-1) mod q
2. u1 = H(m) * w mod q
3. u2 = r * w mod q
4. v = (g^u1 * y^u2 mod p) mod q
5. Valide si v == r

### 5.7 Simulation avec trace d'ex√©cution

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape ‚îÇ Instruction                                  ‚îÇ R√©sultat                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ Alice g√©n√®re a = random()                   ‚îÇ a = 7 (simplifi√©)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2   ‚îÇ Alice calcule A = g^a mod p                 ‚îÇ A = 2^7 mod 23 = 13     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3   ‚îÇ Bob g√©n√®re b = random()                     ‚îÇ b = 11 (simplifi√©)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ Bob calcule B = g^b mod p                   ‚îÇ B = 2^11 mod 23 = 2     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ Alice calcule K = B^a mod p                 ‚îÇ K = 2^7 mod 23 = 13     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   6   ‚îÇ Bob calcule K = A^b mod p                   ‚îÇ K = 13^11 mod 23 = 13   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7   ‚îÇ Secret partag√© identique?                   ‚îÇ 13 == 13 ‚úì              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

**üéÆ MEME : "Snake, I'm already a demon" ‚Äî Nonce unique**

Comme Venom Snake dans MGSV qui dit "I'm already a demon", une fois que tu r√©utilises un nonce en DSA, tu es d√©j√† compromis. Il n'y a pas de retour. **Un nonce, une signature.**

```rust
fn dsa_sign_safe(msg: &[u8], private_key: &BigInt, params: &DsaParams) -> (BigInt, BigInt) {
    // üéÆ "I'm already a demon" si tu r√©utilises k!
    let k = generate_unique_nonce();  // JAMAIS r√©utiliser
    dsa_sign(msg, private_key, params, &k)
}
```

---

**üíÄ MEME : "A surveillance camera?!" ‚Äî Validation des param√®tres**

Dans MGS, Snake se fait rep√©rer s'il ne v√©rifie pas son environnement. En DH, si tu ne valides pas la cl√© publique re√ßue, tu te fais avoir par une attaque small subgroup.

```rust
if !dh_validate_public_key(&received_public, &params) {
    // "A surveillance camera?!" - Snake
    // D√âTECTION D'ATTAQUE
    return Err("Small subgroup attack detected!");
}
```

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | D√©tection | Correction |
|---|-------|-----------|------------|
| 1 | Small subgroup attack | public^2 == 1 | Rejeter cl√©s invalides |
| 2 | Nonce DSA r√©utilis√© | M√™me r dans signatures | Nonce al√©atoire unique |
| 3 | ElGamal mall√©abilit√© | c2 modifi√© | Ajouter authentification |
| 4 | MITM sans authentification | Secrets diff√©rents | PKI ou SAS |
| 5 | k pr√©visible | Attaque par √©num√©ration | CSPRNG pour k |

---

## üìù SECTION 7 : QCM

**Q1:** Dans DH, que voit un attaquant passif?
A) a, b, K  B) g, p, A, B ‚úì  C) a, B  D) K seulement

**Q2:** Pourquoi valider les cl√©s publiques DH?
A) Performance  B) Conformit√©  C) Small subgroup attack ‚úì  D) Esth√©tique

**Q3:** Que se passe-t-il si deux signatures DSA ont le m√™me r?
A) Rien  B) Cl√© publique compromise  C) Cl√© priv√©e r√©cup√©rable ‚úì  D) Signature invalide

**Q4:** ElGamal est mall√©able car:
A) c2' = c2 * m' d√©chiffre m * m' ‚úì  B) Trop lent  C) Cl√©s trop courtes  D) Hash faible

**Q5:** Comment Sony a perdu le contr√¥le de la PS3?
A) Mauvais RNG  B) Nonce DSA r√©utilis√© ‚úì  C) Cl√© trop courte  D) Buffer overflow

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.4-b : echange_secret |
| Concepts | DH, ElGamal, DSA, MITM, nonce reuse |
| Difficult√© | 9/10 |
| XP | 275 |

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
