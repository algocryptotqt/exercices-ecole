# Exercice 3.1.1-b : stratege_risque

**Module :**
3.1.1 ‚Äî Principes Fondamentaux de S√©curit√©

**Concept :**
i-o ‚Äî Threat Modeling, Risk Assessment, Security Controls, Policies, Frameworks, Compliance, Metrics

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
2 ‚Äî M√©lange (concepts i + j + k + l + m + n + o)

**Langage :**
Python 3.14

**Pr√©requis :**
- Exercice 3.1.1-a (auditeur_forteresse)
- Connaissance des principes CIA et AAA
- Manipulation avanc√©e de structures JSON

**Domaines :**
Crypto, MD, Probas

**Dur√©e estim√©e :**
120 min

**XP Base :**
200

**Complexit√© :**
T4 O(n¬≤) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`stratege_risque.py`

**Fonctions autoris√©es :**
- `json` (module standard Python)
- `typing` (annotations de type)
- `dataclasses` (optionnel)
- `math` (pour calculs de probabilit√©s)
- Toutes fonctions Python built-in

**Fonctions interdites :**
- Biblioth√®ques tierces (pandas, numpy, etc.)
- `eval()`, `exec()`
- Imports r√©seau ou syst√®me

### 1.2 Consigne

**üéÆ CONTEXTE FUN ‚Äî R√©f√©rence : "Death Note" √ó "Minority Report"**

*"Tu te souviens de Light Yagami qui planifiait chaque mouvement de L, anticipant ses r√©actions trois coups √† l'avance ? Ou de John Anderton dans Minority Report, utilisant les pr√©cogs pour pr√©dire les crimes avant qu'ils n'arrivent ? Aujourd'hui, c'est TOI le pr√©cog de la cybers√©curit√©."*

Tu viens d'√™tre nomm√© **Threat Intelligence Analyst** chez **VoteSecure Inc.**, une startup qui d√©veloppe un syst√®me de vote √©lectronique r√©volutionnaire pour les √©lections de 2026. Le gouvernement exige une analyse de menaces COMPL√àTE avant de certifier le syst√®me.

Le CTO t'envoie l'architecture du syst√®me "E-Vote 2024" avec tous ses composants, flux de donn√©es, fronti√®res de confiance et acteurs. Ta mission : produire une analyse STRIDE exhaustive, calculer les scores DREAD pour chaque menace, et v√©rifier la conformit√© GDPR + loi √©lectorale locale.

**Ta mission :**

√âcrire une fonction `analyze_threats` qui produit une mod√©lisation compl√®te des menaces d'un syst√®me.

**Entr√©e :**
- `system` : dictionnaire Python d√©crivant le syst√®me √† analyser
  - `name` : nom du syst√®me
  - `components` : liste des composants (serveurs, apps, bases de donn√©es)
  - `data_flows` : flux de donn√©es entre composants
  - `trust_boundaries` : fronti√®res de confiance du syst√®me
  - `actors` : acteurs (utilisateurs, admins, attaquants potentiels)
  - `regulations` : r√©glementations applicables (GDPR, loi √©lectorale, etc.)

**Sortie :**
- Dictionnaire contenant le mod√®le de menaces complet :
  - `stride_analysis` : analyse STRIDE par cat√©gorie
  - `dread_scores` : scores DREAD pour chaque menace identifi√©e
  - `attack_trees` : arbres d'attaque principaux
  - `controls` : contr√¥les recommand√©s (pr√©ventifs, d√©tectifs, correctifs)
  - `compliance_gaps` : √©carts de conformit√© identifi√©s
  - `metrics_baseline` : m√©triques de s√©curit√© (MTTD, MTTR cibles)

**Contraintes :**
- Les cat√©gories STRIDE sont : `spoofing`, `tampering`, `repudiation`, `information_disclosure`, `denial_of_service`, `elevation_of_privilege`
- Les scores DREAD vont de 0 √† 10 pour chaque dimension : Damage, Reproducibility, Exploitability, Affected Users, Discoverability
- La conformit√© doit v√©rifier : GDPR (data protection), loi √©lectorale (int√©grit√© du vote), et tout r√®glement fourni
- Les contr√¥les doivent √™tre cat√©goris√©s : preventive, detective, corrective
- Les m√©triques MTTD et MTTR doivent √™tre en heures

**Exemples :**

| Composant | Cat√©gorie STRIDE | Menace | Score DREAD |
|-----------|-----------------|--------|-------------|
| auth_server | Spoofing | Usurpation d'identit√© √©lecteur | D:8, R:7, E:6, A:10, D:5 = 7.2 |
| vote_storage | Tampering | Modification des votes | D:10, R:3, E:3, A:10, D:2 = 5.6 |
| audit_log | Repudiation | Effacement des traces | D:9, R:4, E:5, A:10, D:3 = 6.2 |

### 1.2.2 Consigne Acad√©mique

Impl√©menter un analyseur de menaces selon la m√©thodologie STRIDE/DREAD qui :
1. Identifie les menaces potentielles pour chaque composant du syst√®me
2. Calcule les scores DREAD pour prioriser les risques
3. G√©n√®re des arbres d'attaque pour les sc√©narios critiques
4. Propose des contr√¥les de s√©curit√© appropri√©s
5. V√©rifie la conformit√© r√©glementaire

L'algorithme doit analyser les flux de donn√©es, identifier les fronti√®res de confiance vuln√©rables, et produire une √©valuation des risques quantifi√©e.

### 1.3 Prototype

```python
def analyze_threats(system: dict) -> dict:
    """
    Analyse un syst√®me et produit un mod√®le de menaces STRIDE/DREAD complet.

    Args:
        system: Dictionnaire contenant name, components, data_flows,
                trust_boundaries, actors, regulations

    Returns:
        Dictionnaire avec stride_analysis, dread_scores, attack_trees,
        controls, compliance_gaps, metrics_baseline
    """
    pass
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'origine de STRIDE

**STRIDE** a √©t√© cr√©√© par **Loren Kohnfelder** et **Praerit Garg** chez Microsoft en 1999. Le nom est un acronyme des 6 cat√©gories de menaces :
- **S**poofing (usurpation d'identit√©)
- **T**ampering (falsification)
- **R**epudiation (r√©pudiation)
- **I**nformation Disclosure (divulgation)
- **D**enial of Service (d√©ni de service)
- **E**levation of Privilege (√©l√©vation de privil√®ges)

Fait amusant : Microsoft a d√©velopp√© STRIDE apr√®s avoir √©t√© victime de nombreuses failles dans Windows NT. C'est l'√©chec qui a men√© √† l'innovation !

### 2.2 DREAD : La formule magique

**DREAD** est un scoring system cr√©√© √©galement chez Microsoft :
- **D**amage potential (potentiel de d√©g√¢ts)
- **R**eproducibility (reproductibilit√©)
- **E**xploitability (facilit√© d'exploitation)
- **A**ffected users (utilisateurs affect√©s)
- **D**iscoverability (facilit√© de d√©couverte)

Le score final est la moyenne : `(D + R + E + A + D) / 5`

Note : Microsoft a abandonn√© DREAD en 2008 au profit de syst√®mes plus modernes comme CVSS, mais il reste enseign√© pour sa simplicit√© p√©dagogique.

### 2.3 Le vote √©lectronique : un d√©fi de confiance

Le vote √©lectronique est consid√©r√© comme l'un des d√©fis les plus difficiles en s√©curit√© informatique car il doit satisfaire des propri√©t√©s contradictoires :
- **Int√©grit√©** : chaque vote doit √™tre compt√© correctement
- **Confidentialit√©** : personne ne doit savoir qui a vot√© quoi
- **V√©rifiabilit√©** : l'√©lecteur doit pouvoir v√©rifier que son vote est bien compt√©
- **Non-coercibilit√©** : l'√©lecteur ne doit pas pouvoir prouver son vote √† un tiers

Ces propri√©t√©s sont si difficiles √† concilier que la plupart des experts recommandent encore le bulletin papier !

### 2.5 DANS LA VRAIE VIE

**Qui utilise la mod√©lisation des menaces ?**

| M√©tier | Utilisation |
|--------|-------------|
| **Threat Intelligence Analyst** | Analyse STRIDE/DREAD quotidienne sur nouvelles architectures |
| **Security Architect** | Int√®gre threat modeling dans le design des syst√®mes |
| **Risk Manager** | Utilise DREAD et FAIR pour quantifier les risques |
| **Compliance Officer** | V√©rifie l'alignement avec GDPR, PCI-DSS, etc. |
| **Red Team Lead** | Base les sc√©narios d'attaque sur les arbres d'attaque |
| **SOC Manager** | D√©finit les MTTD/MTTR cibles √† partir de l'analyse |

**Cas d'usage r√©el :**
Lors du d√©veloppement d'une application bancaire, l'√©quipe s√©curit√© effectue une analyse STRIDE sur chaque sprint. Par exemple, une nouvelle API de transfert d'argent g√©n√®re imm√©diatement 5-6 menaces STRIDE √† analyser et scorer avec DREAD.

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
stratege_risque.py  main.py  evote_system.json

$ python3 main.py

=== THREAT MODEL: E-Vote 2024 ===

STRIDE Analysis:
‚îú‚îÄ‚îÄ Spoofing: 4 threats identified
‚îÇ   ‚îú‚îÄ‚îÄ [CRITICAL] Voter identity spoofing (DREAD: 7.2)
‚îÇ   ‚îú‚îÄ‚îÄ [HIGH] Admin credential theft (DREAD: 6.8)
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Tampering: 3 threats identified
‚îÇ   ‚îú‚îÄ‚îÄ [CRITICAL] Vote modification in transit (DREAD: 8.1)
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Repudiation: 2 threats identified
‚îú‚îÄ‚îÄ Information Disclosure: 5 threats identified
‚îú‚îÄ‚îÄ Denial of Service: 3 threats identified
‚îî‚îÄ‚îÄ Elevation of Privilege: 2 threats identified

Top 5 Threats by DREAD Score:
1. Vote modification in transit (8.1) - Tampering
2. Mass voter identity spoofing (7.2) - Spoofing
3. Audit log tampering (6.9) - Repudiation
4. Voter choice disclosure (6.8) - Info Disclosure
5. Admin credential theft (6.8) - Spoofing

Compliance Gaps:
‚îú‚îÄ‚îÄ GDPR: 3 gaps identified
‚îÇ   ‚îú‚îÄ‚îÄ Data retention policy missing
‚îÇ   ‚îú‚îÄ‚îÄ Right to erasure not implemented
‚îÇ   ‚îî‚îÄ‚îÄ Data processing without consent log
‚îî‚îÄ‚îÄ Electoral Law: 2 gaps identified
    ‚îú‚îÄ‚îÄ No paper audit trail
    ‚îî‚îÄ‚îÄ Insufficient vote verification mechanism

Recommended Controls:
‚îú‚îÄ‚îÄ Preventive: 12 controls
‚îú‚îÄ‚îÄ Detective: 8 controls
‚îî‚îÄ‚îÄ Corrective: 5 controls

Security Metrics Baseline:
‚îú‚îÄ‚îÄ Target MTTD: 4 hours
‚îî‚îÄ‚îÄ Target MTTR: 24 hours

Threat model generated successfully.
```

### 3.1 üî• BONUS AVANC√â (OPTIONNEL)

**Difficult√© Bonus :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**R√©compense :**
XP √ó3

**Time Complexity attendue :**
O(n¬≤ log n) avec tri des menaces

**Space Complexity attendue :**
O(n¬≤) pour la matrice de risques crois√©s

**Domaines Bonus :**
`Struct, DP, Probas`

#### 3.1.1 Consigne Bonus

**üéÆ Extension : "Le Simulateur de Catastrophes"**

*Light Yagami ne se contentait pas de planifier un coup. Il simulait toutes les r√©ponses possibles de L, et les r√©ponses aux r√©ponses. C'est ton tour de penser comme Kira.*

En plus de l'analyse STRIDE/DREAD standard, impl√©menter un **simulateur de sc√©narios d'attaque** qui :
- Calcule la probabilit√© de succ√®s de cha√Ænes d'attaques
- Simule l'impact financier et r√©putationnel
- G√©n√®re des sc√©narios "What-If" avec variations

**Ta mission :**

√âtendre `analyze_threats` pour inclure des simulations Monte Carlo de sc√©narios d'attaque.

**Entr√©e :**
- M√™me syst√®me que l'exercice de base
- Param√®tre additionnel `simulation_runs` (nombre de simulations, d√©faut 1000)

**Sortie :**
- Rapport √©tendu avec un champ `simulations` contenant :
  - `scenarios` : liste des sc√©narios simul√©s
  - `expected_annual_loss` : perte annuelle attendue (ALE)
  - `var_95` : Value at Risk √† 95%
  - `worst_case` : pire sc√©nario simul√©
  - `mitigation_roi` : ROI de chaque contr√¥le propos√©

**Contraintes :**
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  simulation_runs ‚â• 100                  ‚îÇ
‚îÇ  ALE = SLE √ó ARO (Single Loss √ó Annual  ‚îÇ
‚îÇ         Rate of Occurrence)             ‚îÇ
‚îÇ  VaR_95 = 95th percentile des pertes    ‚îÇ
‚îÇ  Temps limite : O(n¬≤ √ó runs)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

**Exemples :**

| Sc√©nario | Probabilit√© | Impact | ALE |
|----------|-------------|--------|-----|
| Data breach via spoofing | 15%/an | ‚Ç¨500K | ‚Ç¨75K |
| Vote tampering | 5%/an | ‚Ç¨10M | ‚Ç¨500K |
| DDoS during election | 30%/an | ‚Ç¨200K | ‚Ç¨60K |

#### 3.1.2 Prototype Bonus

```python
def analyze_threats_extended(system: dict, simulation_runs: int = 1000) -> dict:
    """
    Analyse de menaces √©tendue avec simulation Monte Carlo.
    """
    pass
```

#### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Analyse | STRIDE/DREAD statique | + Simulations probabilistes |
| Output | scores, gaps, controls | + ALE, VaR, ROI |
| Complexit√© | O(n¬≤) | O(n¬≤ √ó simulation_runs) |
| Algorithme | Parcours et scoring | + Monte Carlo |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test ID | Input | Expected Output | Points |
|---------|-------|-----------------|--------|
| `test_null_input` | `None` | Dictionnaire vide structur√© | 5 |
| `test_empty_system` | `{}` | Dictionnaire avec listes vides | 5 |
| `test_single_component_stride` | 1 serveur auth | 6 cat√©gories STRIDE analys√©es | 10 |
| `test_dread_calculation` | Menace connue | Score DREAD correct (moyenne) | 10 |
| `test_trust_boundary_crossing` | Flux traversant boundary | Menaces identifi√©es sur le flux | 10 |
| `test_gdpr_compliance` | Syst√®me sans consentement | Gap GDPR d√©tect√© | 10 |
| `test_electoral_law` | Syst√®me sans audit trail | Gap loi √©lectorale d√©tect√© | 10 |
| `test_controls_categorization` | Menaces vari√©es | Contr√¥les preventive/detective/corrective | 10 |
| `test_attack_tree_generation` | Chemin d'attaque clair | Arbre d'attaque correct | 15 |
| `test_complete_evote_system` | Syst√®me E-Vote complet | Analyse compl√®te avec 19 menaces | 15 |

### 4.2 main.py de test

```python
#!/usr/bin/env python3
"""
Test runner pour stratege_risque.py
"""
import json
from stratege_risque import analyze_threats

def test_null_input():
    result = analyze_threats(None)
    assert "stride_analysis" in result
    assert "dread_scores" in result
    assert result["stride_analysis"]["spoofing"] == []
    print("Test NULL: OK")

def test_empty_system():
    result = analyze_threats({})
    assert result["stride_analysis"]["spoofing"] == []
    assert result["dread_scores"] == []
    assert result["compliance_gaps"] == []
    print("Test Empty: OK")

def test_single_component_stride():
    system = {
        "name": "Test System",
        "components": [
            {
                "id": "auth_server",
                "type": "authentication",
                "handles_pii": True,
                "exposed_to": "internet"
            }
        ],
        "data_flows": [],
        "trust_boundaries": [],
        "actors": [],
        "regulations": []
    }
    result = analyze_threats(system)

    # Doit avoir les 6 cat√©gories STRIDE
    stride = result["stride_analysis"]
    assert "spoofing" in stride
    assert "tampering" in stride
    assert "repudiation" in stride
    assert "information_disclosure" in stride
    assert "denial_of_service" in stride
    assert "elevation_of_privilege" in stride

    # Un serveur d'auth expos√© Internet doit avoir des menaces Spoofing
    assert len(stride["spoofing"]) >= 1
    print("Test Single Component STRIDE: OK")

def test_dread_calculation():
    system = {
        "name": "Test",
        "components": [
            {
                "id": "db",
                "type": "database",
                "contains": "votes",
                "exposed_to": "internal"
            }
        ],
        "data_flows": [],
        "trust_boundaries": [],
        "actors": [],
        "regulations": []
    }
    result = analyze_threats(system)

    # V√©rifier que les scores DREAD sont des moyennes valides (0-10)
    for score in result["dread_scores"]:
        assert 0 <= score["score"] <= 10
        assert all(0 <= score["breakdown"][k] <= 10
                   for k in ["damage", "reproducibility", "exploitability",
                             "affected_users", "discoverability"])
    print("Test DREAD Calculation: OK")

def test_trust_boundary_crossing():
    system = {
        "name": "Test",
        "components": [
            {"id": "web_app", "type": "application", "zone": "dmz"},
            {"id": "internal_db", "type": "database", "zone": "internal"}
        ],
        "data_flows": [
            {
                "source": "web_app",
                "destination": "internal_db",
                "data_type": "user_credentials",
                "crosses_boundary": True
            }
        ],
        "trust_boundaries": [
            {"name": "dmz_to_internal", "from_zone": "dmz", "to_zone": "internal"}
        ],
        "actors": [],
        "regulations": []
    }
    result = analyze_threats(system)

    # Les flux traversant des fronti√®res doivent g√©n√©rer plus de menaces
    total_threats = sum(len(v) for v in result["stride_analysis"].values())
    assert total_threats >= 3  # Au minimum Spoofing, Tampering, Info Disclosure
    print("Test Trust Boundary Crossing: OK")

def test_gdpr_compliance():
    system = {
        "name": "Test",
        "components": [
            {"id": "user_db", "type": "database", "contains": "personal_data"}
        ],
        "data_flows": [],
        "trust_boundaries": [],
        "actors": [],
        "regulations": ["GDPR"],
        "policies": {
            "consent_logging": False,
            "data_retention": None,
            "right_to_erasure": False
        }
    }
    result = analyze_threats(system)

    # Doit d√©tecter les gaps GDPR
    gdpr_gaps = [g for g in result["compliance_gaps"] if g["regulation"] == "GDPR"]
    assert len(gdpr_gaps) >= 2  # Au moins consent et retention
    print("Test GDPR Compliance: OK")

def test_electoral_law():
    system = {
        "name": "E-Vote",
        "components": [
            {"id": "vote_storage", "type": "database", "contains": "votes"}
        ],
        "data_flows": [],
        "trust_boundaries": [],
        "actors": [],
        "regulations": ["electoral_law"],
        "policies": {
            "paper_audit_trail": False,
            "vote_verification": False
        }
    }
    result = analyze_threats(system)

    # Doit d√©tecter les gaps loi √©lectorale
    electoral_gaps = [g for g in result["compliance_gaps"]
                      if g["regulation"] == "electoral_law"]
    assert len(electoral_gaps) >= 1
    print("Test Electoral Law: OK")

def test_controls_categorization():
    system = {
        "name": "Test",
        "components": [
            {"id": "api", "type": "api_gateway", "exposed_to": "internet"}
        ],
        "data_flows": [],
        "trust_boundaries": [],
        "actors": [],
        "regulations": []
    }
    result = analyze_threats(system)

    controls = result["controls"]
    assert "preventive" in controls
    assert "detective" in controls
    assert "corrective" in controls

    # Un API gateway expos√© doit avoir des contr√¥les pr√©ventifs
    assert len(controls["preventive"]) >= 1
    print("Test Controls Categorization: OK")

def test_metrics_baseline():
    system = {
        "name": "Critical System",
        "components": [
            {"id": "payment", "type": "payment", "criticality": "high"}
        ],
        "data_flows": [],
        "trust_boundaries": [],
        "actors": [],
        "regulations": []
    }
    result = analyze_threats(system)

    metrics = result["metrics_baseline"]
    assert "target_mttd_hours" in metrics
    assert "target_mttr_hours" in metrics
    assert metrics["target_mttd_hours"] > 0
    assert metrics["target_mttr_hours"] > 0
    print("Test Metrics Baseline: OK")

def test_complete_evote_system():
    with open("evote_system.json", "r") as f:
        system = json.load(f)
    result = analyze_threats(system)

    # V√©rifier la compl√©tude
    assert len(result["dread_scores"]) >= 15
    assert len(result["compliance_gaps"]) >= 3
    assert len(result["attack_trees"]) >= 2
    print("Test Complete E-Vote System: OK")

if __name__ == "__main__":
    test_null_input()
    test_empty_system()
    test_single_component_stride()
    test_dread_calculation()
    test_trust_boundary_crossing()
    test_gdpr_compliance()
    test_electoral_law()
    test_controls_categorization()
    test_metrics_baseline()
    print("\n=== Tous les tests passent! ===")
```

### 4.3 Solution de r√©f√©rence

```python
#!/usr/bin/env python3
"""
Solution de r√©f√©rence - stratege_risque.py
Mod√©lisation des menaces STRIDE/DREAD
"""
from typing import Optional, List, Dict, Any

STRIDE_CATEGORIES = [
    "spoofing", "tampering", "repudiation",
    "information_disclosure", "denial_of_service", "elevation_of_privilege"
]

COMPONENT_THREAT_MAPPING = {
    "authentication": {
        "spoofing": ["credential_theft", "session_hijacking", "identity_spoofing"],
        "repudiation": ["login_denial"],
        "elevation_of_privilege": ["privilege_escalation_via_auth_bypass"]
    },
    "database": {
        "tampering": ["data_modification", "sql_injection"],
        "information_disclosure": ["data_exfiltration", "unauthorized_access"],
        "denial_of_service": ["resource_exhaustion"]
    },
    "api_gateway": {
        "spoofing": ["api_key_theft"],
        "tampering": ["request_manipulation"],
        "denial_of_service": ["api_flooding", "rate_limit_bypass"],
        "information_disclosure": ["verbose_errors"]
    },
    "payment": {
        "tampering": ["transaction_modification"],
        "repudiation": ["payment_denial"],
        "information_disclosure": ["card_data_exposure"]
    },
    "application": {
        "spoofing": ["user_impersonation"],
        "tampering": ["input_manipulation"],
        "information_disclosure": ["session_disclosure"],
        "elevation_of_privilege": ["role_escalation"]
    }
}

def analyze_threats(system: Optional[dict]) -> dict:
    """
    Analyse un syst√®me et produit un mod√®le de menaces STRIDE/DREAD complet.
    """
    empty_result = {
        "stride_analysis": {cat: [] for cat in STRIDE_CATEGORIES},
        "dread_scores": [],
        "attack_trees": [],
        "controls": {"preventive": [], "detective": [], "corrective": []},
        "compliance_gaps": [],
        "metrics_baseline": {"target_mttd_hours": 24, "target_mttr_hours": 72}
    }

    if system is None or not system:
        return empty_result

    result = {
        "stride_analysis": {cat: [] for cat in STRIDE_CATEGORIES},
        "dread_scores": [],
        "attack_trees": [],
        "controls": {"preventive": [], "detective": [], "corrective": []},
        "compliance_gaps": [],
        "metrics_baseline": {}
    }

    # Analyse STRIDE des composants
    components = system.get("components", [])
    for component in components:
        threats = _analyze_component_stride(component)
        for category, threat_list in threats.items():
            result["stride_analysis"][category].extend(threat_list)

    # Analyse des flux de donn√©es
    data_flows = system.get("data_flows", [])
    trust_boundaries = system.get("trust_boundaries", [])
    flow_threats = _analyze_data_flows(data_flows, trust_boundaries)
    for category, threat_list in flow_threats.items():
        result["stride_analysis"][category].extend(threat_list)

    # Calcul des scores DREAD
    all_threats = []
    for category, threats in result["stride_analysis"].items():
        for threat in threats:
            threat["category"] = category
            all_threats.append(threat)

    result["dread_scores"] = [_calculate_dread(t) for t in all_threats]

    # G√©n√©ration des arbres d'attaque
    result["attack_trees"] = _generate_attack_trees(
        result["stride_analysis"],
        components,
        data_flows
    )

    # Analyse de conformit√©
    regulations = system.get("regulations", [])
    policies = system.get("policies", {})
    result["compliance_gaps"] = _check_compliance(regulations, policies, components)

    # G√©n√©ration des contr√¥les
    result["controls"] = _generate_controls(result["stride_analysis"], result["dread_scores"])

    # M√©triques de s√©curit√©
    result["metrics_baseline"] = _calculate_metrics_baseline(components, result["dread_scores"])

    return result

def _analyze_component_stride(component: dict) -> Dict[str, List[dict]]:
    """Analyse STRIDE d'un composant."""
    threats = {cat: [] for cat in STRIDE_CATEGORIES}

    comp_id = component.get("id", "unknown")
    comp_type = component.get("type", "generic")
    exposed_to = component.get("exposed_to", "internal")
    contains = component.get("contains", "")

    # Menaces bas√©es sur le type de composant
    type_threats = COMPONENT_THREAT_MAPPING.get(comp_type, {})
    for category, threat_names in type_threats.items():
        for threat_name in threat_names:
            severity = "high" if exposed_to == "internet" else "medium"
            threats[category].append({
                "id": f"{comp_id}_{threat_name}",
                "component": comp_id,
                "name": threat_name.replace("_", " ").title(),
                "description": f"Potential {threat_name} on {comp_type}",
                "severity": severity
            })

    # Menaces suppl√©mentaires si expos√© √† Internet
    if exposed_to == "internet":
        threats["denial_of_service"].append({
            "id": f"{comp_id}_ddos",
            "component": comp_id,
            "name": "DDoS Attack",
            "description": f"Internet-exposed {comp_type} vulnerable to DDoS",
            "severity": "high"
        })

    # Menaces si contient des donn√©es sensibles
    sensitive_data = ["votes", "personal_data", "credentials", "payment"]
    if any(s in str(contains).lower() for s in sensitive_data):
        threats["information_disclosure"].append({
            "id": f"{comp_id}_data_breach",
            "component": comp_id,
            "name": "Sensitive Data Exposure",
            "description": f"Component contains sensitive data: {contains}",
            "severity": "critical"
        })

    return threats

def _analyze_data_flows(data_flows: List[dict], trust_boundaries: List[dict]) -> Dict[str, List[dict]]:
    """Analyse STRIDE des flux de donn√©es."""
    threats = {cat: [] for cat in STRIDE_CATEGORIES}

    boundary_names = {b["name"] for b in trust_boundaries}

    for flow in data_flows:
        flow_id = f"{flow.get('source', 'src')}_{flow.get('destination', 'dst')}"
        crosses_boundary = flow.get("crosses_boundary", False)
        data_type = flow.get("data_type", "generic")

        # Les flux traversant des fronti√®res sont plus risqu√©s
        if crosses_boundary:
            threats["spoofing"].append({
                "id": f"{flow_id}_flow_spoofing",
                "flow": flow_id,
                "name": "Flow Source Spoofing",
                "description": f"Attacker could spoof source in cross-boundary flow",
                "severity": "high"
            })
            threats["tampering"].append({
                "id": f"{flow_id}_mitm",
                "flow": flow_id,
                "name": "Man-in-the-Middle",
                "description": f"Data could be tampered in transit across boundary",
                "severity": "high"
            })

        # Flux contenant des credentials
        if "credential" in data_type.lower():
            threats["information_disclosure"].append({
                "id": f"{flow_id}_cred_exposure",
                "flow": flow_id,
                "name": "Credential Exposure in Transit",
                "description": "Credentials transmitted could be intercepted",
                "severity": "critical"
            })

    return threats

def _calculate_dread(threat: dict) -> dict:
    """Calcule le score DREAD d'une menace."""
    severity = threat.get("severity", "medium")
    category = threat.get("category", "information_disclosure")

    # Base scores par s√©v√©rit√©
    severity_base = {"critical": 9, "high": 7, "medium": 5, "low": 3}
    base = severity_base.get(severity, 5)

    # Ajustements par cat√©gorie
    category_adjustments = {
        "spoofing": {"damage": 1, "exploitability": 1},
        "tampering": {"damage": 2, "reproducibility": -1},
        "repudiation": {"damage": -1, "discoverability": -2},
        "information_disclosure": {"affected_users": 2},
        "denial_of_service": {"affected_users": 2, "damage": -1},
        "elevation_of_privilege": {"damage": 2, "exploitability": -1}
    }

    adjustments = category_adjustments.get(category, {})

    breakdown = {
        "damage": min(10, max(0, base + adjustments.get("damage", 0))),
        "reproducibility": min(10, max(0, base + adjustments.get("reproducibility", 0))),
        "exploitability": min(10, max(0, base + adjustments.get("exploitability", 0))),
        "affected_users": min(10, max(0, base + adjustments.get("affected_users", 0))),
        "discoverability": min(10, max(0, base + adjustments.get("discoverability", 0)))
    }

    score = sum(breakdown.values()) / 5

    return {
        "threat_id": threat.get("id", "unknown"),
        "threat_name": threat.get("name", "Unknown Threat"),
        "category": category,
        "score": round(score, 1),
        "breakdown": breakdown
    }

def _generate_attack_trees(stride_analysis: dict, components: list, data_flows: list) -> list:
    """G√©n√®re des arbres d'attaque pour les sc√©narios critiques."""
    attack_trees = []

    # Arbre d'attaque: compromission du syst√®me de vote
    vote_components = [c for c in components if "vote" in c.get("contains", "").lower()
                       or c.get("type") == "database"]

    if vote_components:
        attack_trees.append({
            "id": "AT-001",
            "goal": "Compromise Vote Integrity",
            "root": {
                "name": "Modify Election Results",
                "type": "OR",
                "children": [
                    {
                        "name": "Direct Database Access",
                        "type": "AND",
                        "children": [
                            {"name": "Obtain DB Credentials", "type": "LEAF"},
                            {"name": "Bypass Network Controls", "type": "LEAF"}
                        ]
                    },
                    {
                        "name": "Application Layer Attack",
                        "type": "AND",
                        "children": [
                            {"name": "Find Injection Vulnerability", "type": "LEAF"},
                            {"name": "Escalate Privileges", "type": "LEAF"}
                        ]
                    }
                ]
            }
        })

    # Arbre d'attaque: vol d'identit√© √©lecteur
    auth_components = [c for c in components if c.get("type") == "authentication"]

    if auth_components:
        attack_trees.append({
            "id": "AT-002",
            "goal": "Voter Identity Theft",
            "root": {
                "name": "Vote As Another Person",
                "type": "OR",
                "children": [
                    {
                        "name": "Credential Theft",
                        "type": "OR",
                        "children": [
                            {"name": "Phishing Attack", "type": "LEAF"},
                            {"name": "Database Breach", "type": "LEAF"}
                        ]
                    },
                    {
                        "name": "Session Hijacking",
                        "type": "LEAF"
                    }
                ]
            }
        })

    return attack_trees

def _check_compliance(regulations: list, policies: dict, components: list) -> list:
    """V√©rifie la conformit√© r√©glementaire."""
    gaps = []

    if "GDPR" in regulations:
        # V√©rification GDPR
        if not policies.get("consent_logging", True):
            gaps.append({
                "regulation": "GDPR",
                "requirement": "Article 7 - Conditions for consent",
                "gap": "Consent logging not implemented",
                "severity": "high",
                "remediation": "Implement consent tracking and logging"
            })

        if policies.get("data_retention") is None:
            gaps.append({
                "regulation": "GDPR",
                "requirement": "Article 5(1)(e) - Storage limitation",
                "gap": "Data retention policy not defined",
                "severity": "high",
                "remediation": "Define and implement data retention policy"
            })

        if not policies.get("right_to_erasure", True):
            gaps.append({
                "regulation": "GDPR",
                "requirement": "Article 17 - Right to erasure",
                "gap": "Right to erasure not implemented",
                "severity": "medium",
                "remediation": "Implement data deletion mechanism"
            })

    if "electoral_law" in regulations:
        # V√©rification loi √©lectorale
        if not policies.get("paper_audit_trail", True):
            gaps.append({
                "regulation": "electoral_law",
                "requirement": "Audit trail requirement",
                "gap": "No paper audit trail for votes",
                "severity": "critical",
                "remediation": "Implement verifiable paper audit trail"
            })

        if not policies.get("vote_verification", True):
            gaps.append({
                "regulation": "electoral_law",
                "requirement": "Voter verification",
                "gap": "Voters cannot verify their vote was counted",
                "severity": "high",
                "remediation": "Implement end-to-end verifiable voting"
            })

    return gaps

def _generate_controls(stride_analysis: dict, dread_scores: list) -> dict:
    """G√©n√®re les contr√¥les de s√©curit√© recommand√©s."""
    controls = {
        "preventive": [],
        "detective": [],
        "corrective": []
    }

    # Contr√¥les bas√©s sur les cat√©gories STRIDE
    if stride_analysis["spoofing"]:
        controls["preventive"].extend([
            {"id": "CTRL-001", "name": "Multi-Factor Authentication",
             "description": "Implement MFA for all user accounts"},
            {"id": "CTRL-002", "name": "Strong Password Policy",
             "description": "Enforce complex passwords with rotation"}
        ])
        controls["detective"].append(
            {"id": "CTRL-003", "name": "Failed Login Monitoring",
             "description": "Alert on suspicious login patterns"}
        )

    if stride_analysis["tampering"]:
        controls["preventive"].extend([
            {"id": "CTRL-004", "name": "Input Validation",
             "description": "Validate and sanitize all inputs"},
            {"id": "CTRL-005", "name": "Integrity Checks",
             "description": "Implement checksums and digital signatures"}
        ])
        controls["detective"].append(
            {"id": "CTRL-006", "name": "Data Integrity Monitoring",
             "description": "Monitor for unauthorized data changes"}
        )

    if stride_analysis["denial_of_service"]:
        controls["preventive"].extend([
            {"id": "CTRL-007", "name": "Rate Limiting",
             "description": "Implement rate limiting on all endpoints"},
            {"id": "CTRL-008", "name": "DDoS Protection",
             "description": "Deploy WAF and DDoS mitigation"}
        ])
        controls["corrective"].append(
            {"id": "CTRL-009", "name": "Failover Mechanism",
             "description": "Automatic failover to backup systems"}
        )

    if stride_analysis["information_disclosure"]:
        controls["preventive"].extend([
            {"id": "CTRL-010", "name": "Encryption at Rest",
             "description": "Encrypt all sensitive data at rest"},
            {"id": "CTRL-011", "name": "Encryption in Transit",
             "description": "Use TLS for all communications"}
        ])

    # Contr√¥les g√©n√©raux
    controls["detective"].append(
        {"id": "CTRL-012", "name": "SIEM Integration",
         "description": "Centralized logging and monitoring"}
    )
    controls["corrective"].extend([
        {"id": "CTRL-013", "name": "Incident Response Plan",
         "description": "Documented IR procedures"},
        {"id": "CTRL-014", "name": "Backup and Recovery",
         "description": "Regular backups with tested recovery"}
    ])

    return controls

def _calculate_metrics_baseline(components: list, dread_scores: list) -> dict:
    """Calcule les m√©triques de s√©curit√© de base."""
    # MTTD et MTTR bas√©s sur la criticit√©
    critical_components = [c for c in components
                          if c.get("criticality") == "high"
                          or c.get("type") in ["payment", "authentication", "database"]]

    # Plus de composants critiques = objectifs plus stricts
    if len(critical_components) >= 3:
        target_mttd = 4  # heures
        target_mttr = 24
    elif len(critical_components) >= 1:
        target_mttd = 8
        target_mttr = 48
    else:
        target_mttd = 24
        target_mttr = 72

    # Ajuster selon les scores DREAD
    high_dread = [s for s in dread_scores if s["score"] >= 7]
    if len(high_dread) >= 5:
        target_mttd = max(1, target_mttd - 2)
        target_mttr = max(4, target_mttr - 12)

    return {
        "target_mttd_hours": target_mttd,
        "target_mttr_hours": target_mttr
    }
```

### 4.4 Solutions alternatives accept√©es

```python
# Alternative 1 : Approche avec classes et h√©ritage
class ThreatAnalyzer:
    def __init__(self, system):
        self.system = system or {}

    def analyze(self):
        stride = StrideAnalyzer(self.system).run()
        dread = DreadCalculator(stride).calculate_all()
        trees = AttackTreeGenerator(stride).generate()
        compliance = ComplianceChecker(self.system).check()
        controls = ControlGenerator(dread).generate()
        metrics = MetricsCalculator(self.system, dread).baseline()

        return {
            "stride_analysis": stride,
            "dread_scores": dread,
            "attack_trees": trees,
            "compliance_gaps": compliance,
            "controls": controls,
            "metrics_baseline": metrics
        }

def analyze_threats(system):
    return ThreatAnalyzer(system).analyze()
```

### 4.5 Solutions refus√©es (avec explications)

```python
# REFUS√â 1 : Ne calcule pas correctement le score DREAD
def _calculate_dread(threat):
    # Somme au lieu de moyenne
    return threat["severity_score"] * 5  # FAUX: DREAD = moyenne, pas somme
# Pourquoi refus√© : DREAD est une moyenne de 5 facteurs

# REFUS√â 2 : Ignore les trust boundaries
def analyze_threats(system):
    # Analyse seulement les composants, pas les flux
    for comp in system.get("components", []):
        # ...
    # Les data_flows et trust_boundaries sont ignor√©s
# Pourquoi refus√© : Les flux traversant des fronti√®res sont critiques

# REFUS√â 3 : Compliance hardcod√©e
def _check_compliance(regulations, policies, components):
    # Retourne toujours les m√™mes gaps sans v√©rifier les policies
    return [
        {"regulation": "GDPR", "gap": "Non-compliant"},
        {"regulation": "electoral_law", "gap": "Non-compliant"}
    ]
# Pourquoi refus√© : Pas de v√©rification r√©elle des politiques
```

### 4.6 Solution bonus de r√©f√©rence (COMPL√àTE)

```python
#!/usr/bin/env python3
"""
Solution bonus - Simulation Monte Carlo des menaces
"""
import random
from typing import Optional, List, Dict

def analyze_threats_extended(system: Optional[dict], simulation_runs: int = 1000) -> dict:
    """
    Analyse de menaces √©tendue avec simulation Monte Carlo.
    """
    # Analyse de base
    base_result = analyze_threats(system)

    if not system or simulation_runs < 100:
        base_result["simulations"] = {
            "scenarios": [],
            "expected_annual_loss": 0,
            "var_95": 0,
            "worst_case": None,
            "mitigation_roi": []
        }
        return base_result

    # D√©finir les sc√©narios bas√©s sur les menaces identifi√©es
    scenarios = _create_scenarios(base_result["dread_scores"])

    # Simulation Monte Carlo
    simulation_results = _run_monte_carlo(scenarios, simulation_runs)

    # Calcul des m√©triques financi√®res
    losses = [r["total_loss"] for r in simulation_results]
    losses.sort()

    expected_annual_loss = sum(losses) / len(losses)
    var_95_index = int(0.95 * len(losses))
    var_95 = losses[var_95_index] if var_95_index < len(losses) else losses[-1]
    worst_case = max(simulation_results, key=lambda r: r["total_loss"])

    # Calcul du ROI des contr√¥les
    mitigation_roi = _calculate_mitigation_roi(
        base_result["controls"],
        scenarios,
        expected_annual_loss
    )

    base_result["simulations"] = {
        "scenarios": scenarios,
        "expected_annual_loss": round(expected_annual_loss, 2),
        "var_95": round(var_95, 2),
        "worst_case": worst_case,
        "mitigation_roi": mitigation_roi
    }

    return base_result

def _create_scenarios(dread_scores: List[dict]) -> List[dict]:
    """Cr√©e des sc√©narios d'attaque bas√©s sur les scores DREAD."""
    scenarios = []

    # Impact financier estim√© par cat√©gorie
    category_impacts = {
        "spoofing": 200000,
        "tampering": 500000,
        "repudiation": 100000,
        "information_disclosure": 1000000,
        "denial_of_service": 150000,
        "elevation_of_privilege": 750000
    }

    for score in dread_scores:
        category = score["category"]
        dread = score["score"]

        # Probabilit√© annuelle bas√©e sur DREAD
        aro = (dread / 10) * 0.5  # Max 50% de chance par an

        # Impact bas√© sur la cat√©gorie et le score
        base_impact = category_impacts.get(category, 200000)
        sle = base_impact * (score["breakdown"]["damage"] / 10)

        scenarios.append({
            "threat_id": score["threat_id"],
            "threat_name": score["threat_name"],
            "category": category,
            "aro": aro,  # Annual Rate of Occurrence
            "sle": sle,  # Single Loss Expectancy
            "ale": aro * sle  # Annual Loss Expectancy
        })

    return scenarios

def _run_monte_carlo(scenarios: List[dict], runs: int) -> List[dict]:
    """Ex√©cute la simulation Monte Carlo."""
    results = []

    for run in range(runs):
        total_loss = 0
        triggered = []

        for scenario in scenarios:
            # Tirer au sort si l'√©v√©nement se produit
            if random.random() < scenario["aro"]:
                # Variation de l'impact (+/- 30%)
                variation = random.uniform(0.7, 1.3)
                loss = scenario["sle"] * variation
                total_loss += loss
                triggered.append({
                    "scenario": scenario["threat_id"],
                    "loss": loss
                })

        results.append({
            "run_id": run,
            "total_loss": total_loss,
            "events_triggered": triggered
        })

    return results

def _calculate_mitigation_roi(controls: dict, scenarios: List[dict], baseline_ale: float) -> List[dict]:
    """Calcule le ROI de chaque contr√¥le."""
    roi_list = []

    # Efficacit√© estim√©e par type de contr√¥le
    control_effectiveness = {
        "CTRL-001": {"categories": ["spoofing"], "reduction": 0.7},
        "CTRL-004": {"categories": ["tampering"], "reduction": 0.6},
        "CTRL-007": {"categories": ["denial_of_service"], "reduction": 0.8},
        "CTRL-010": {"categories": ["information_disclosure"], "reduction": 0.5},
        "CTRL-011": {"categories": ["information_disclosure", "tampering"], "reduction": 0.6}
    }

    # Co√ªt estim√© par contr√¥le
    control_costs = {
        "CTRL-001": 50000,
        "CTRL-004": 30000,
        "CTRL-007": 75000,
        "CTRL-010": 100000,
        "CTRL-011": 25000
    }

    for control_list in controls.values():
        for control in control_list:
            ctrl_id = control["id"]
            if ctrl_id in control_effectiveness:
                eff = control_effectiveness[ctrl_id]
                cost = control_costs.get(ctrl_id, 50000)

                # Calculer la r√©duction d'ALE
                affected_scenarios = [s for s in scenarios if s["category"] in eff["categories"]]
                ale_reduction = sum(s["ale"] * eff["reduction"] for s in affected_scenarios)

                roi = ((ale_reduction - cost) / cost) * 100 if cost > 0 else 0

                roi_list.append({
                    "control_id": ctrl_id,
                    "control_name": control["name"],
                    "implementation_cost": cost,
                    "annual_risk_reduction": round(ale_reduction, 2),
                    "roi_percent": round(roi, 1)
                })

    # Trier par ROI d√©croissant
    roi_list.sort(key=lambda x: x["roi_percent"], reverse=True)
    return roi_list
```

### 4.7-4.8 Solutions alternatives et refus√©es bonus

*(Similaire au pattern de l'exercice pr√©c√©dent)*

### 4.9 spec.json (ENGINE v22.1 ‚Äî FORMAT STRICT)

```json
{
  "name": "stratege_risque",
  "language": "python",
  "type": "code",
  "tier": 2,
  "tier_info": "M√©lange (concepts i-o)",
  "tags": ["threat-modeling", "stride", "dread", "risk", "compliance", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_threats",
    "prototype": "def analyze_threats(system: dict) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "system", "type": "dict"}
    ]
  },

  "driver": {
    "reference": "def ref_analyze_threats(system): return {'stride_analysis': {c: [] for c in ['spoofing','tampering','repudiation','information_disclosure','denial_of_service','elevation_of_privilege']}, 'dread_scores': [], 'attack_trees': [], 'controls': {'preventive': [], 'detective': [], 'corrective': []}, 'compliance_gaps': [], 'metrics_baseline': {'target_mttd_hours': 24, 'target_mttr_hours': 72}} if not system else _full_analysis(system)",

    "edge_cases": [
      {
        "name": "null_input",
        "args": [null],
        "expected_keys": ["stride_analysis", "dread_scores", "attack_trees", "controls", "compliance_gaps", "metrics_baseline"],
        "is_trap": true,
        "trap_explanation": "system est None, doit retourner structure vide"
      },
      {
        "name": "empty_system",
        "args": [{}],
        "expected_keys": ["stride_analysis"],
        "is_trap": true,
        "trap_explanation": "system vide, pas de menaces"
      },
      {
        "name": "auth_component",
        "args": [{"components": [{"id": "auth", "type": "authentication", "exposed_to": "internet"}]}],
        "expected_contains": {"category": "spoofing"},
        "is_trap": false
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 300,
      "generators": [
        {
          "type": "object",
          "param_index": 0,
          "params": {
            "schema": {
              "name": {"type": "string"},
              "components": {"type": "array"},
              "data_flows": {"type": "array"},
              "regulations": {"type": "array"}
            }
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["json.load", "json.loads", "math.sqrt", "math.log"],
    "forbidden_functions": ["eval", "exec", "os.system", "subprocess"],
    "check_security": true,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

```python
# Mutant A (Boundary) : Score DREAD > 10
def _calculate_dread(threat):
    # Pas de cap √† 10 sur les facteurs individuels
    breakdown = {
        "damage": base + 5,  # Peut d√©passer 10
        # ...
    }
    return sum(breakdown.values()) / 5  # Score potentiellement > 10
# Pourquoi c'est faux : DREAD doit √™tre entre 0 et 10

# Mutant B (Safety) : Division par z√©ro
def _calculate_dread(threat):
    factors = [d, r, e, a, d]
    return sum(factors) / len(factors)  # Si factors vide = ZeroDivisionError
# Pourquoi c'est faux : Pas de protection contre liste vide

# Mutant C (Logic) : STRIDE incomplet
STRIDE_CATEGORIES = ["spoofing", "tampering", "denial_of_service"]  # Manque 3
# Pourquoi c'est faux : STRIDE a 6 cat√©gories, pas 3

# Mutant D (Return) : Pas de compliance gaps
def _check_compliance(regulations, policies, components):
    return []  # Toujours vide
# Pourquoi c'est faux : Les gaps ne sont jamais d√©tect√©s

# Mutant E (Logic) : ARO invers√©
def _create_scenarios(dread_scores):
    for score in dread_scores:
        aro = (10 - score["score"]) / 10  # Plus le score est haut, moins c'est probable
# Pourquoi c'est faux : Un score DREAD √©lev√© = risque √©lev√©
```

---

## üß† SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

| Concept | Description | Application |
|---------|-------------|-------------|
| **STRIDE** | Framework de classification des menaces | Identifier syst√©matiquement toutes les menaces |
| **DREAD** | Scoring system pour prioriser les risques | Quantifier et comparer les menaces |
| **Attack Trees** | Mod√©lisation des chemins d'attaque | Visualiser les sc√©narios de compromission |
| **Security Controls** | Mesures pr√©ventives/d√©tectives/correctives | Proposer des rem√©diations appropri√©es |
| **Compliance** | Conformit√© r√©glementaire | V√©rifier GDPR, lois sectorielles |
| **Security Metrics** | MTTD, MTTR, KPIs | Mesurer l'efficacit√© de la s√©curit√© |
| **Risk Assessment** | √âvaluation quantitative des risques | Calculer ALE, VaR |

### 5.2 LDA ‚Äî Traduction litt√©rale en fran√ßais (MAJUSCULES)

```
FONCTION analyze_threats QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAM√àTRE system QUI EST UN DICTIONNAIRE
D√âBUT FONCTION
    SI system EST √âGAL √Ä NUL OU system EST VIDE ALORS
        RETOURNER UN DICTIONNAIRE VIDE STRUCTUR√â
    FIN SI

    INITIALISER stride_analysis AVEC 6 CAT√âGORIES VIDES
    INITIALISER dread_scores COMME LISTE VIDE

    POUR CHAQUE composant DANS system["components"] FAIRE
        IDENTIFIER LES MENACES STRIDE POUR CE composant
        AJOUTER LES MENACES √Ä stride_analysis
    FIN POUR

    POUR CHAQUE flux DANS system["data_flows"] FAIRE
        SI flux TRAVERSE UNE FRONTI√àRE DE CONFIANCE ALORS
            AJOUTER DES MENACES SUPPL√âMENTAIRES √Ä stride_analysis
        FIN SI
    FIN POUR

    POUR CHAQUE menace DANS stride_analysis FAIRE
        CALCULER LE SCORE DREAD
        AJOUTER √Ä dread_scores
    FIN POUR

    G√âN√âRER LES ARBRES D'ATTAQUE
    V√âRIFIER LA CONFORMIT√â R√âGLEMENTAIRE
    G√âN√âRER LES CONTR√îLES RECOMMAND√âS
    CALCULER LES M√âTRIQUES DE BASE

    RETOURNER LE MOD√àLE DE MENACES COMPLET
FIN FONCTION
```

### 5.3 Visualisation ASCII

**Le mod√®le STRIDE :**

```
                        MENACES STRIDE
                             ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ            ‚îÇ           ‚îÇ           ‚îÇ            ‚îÇ
    ‚ñº            ‚ñº           ‚ñº           ‚ñº            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇSpoofing‚îÇ ‚îÇTampering‚îÇ ‚îÇRepudia-  ‚îÇ ‚îÇInfo     ‚îÇ ‚îÇDenial of   ‚îÇ
‚îÇ        ‚îÇ ‚îÇ         ‚îÇ ‚îÇtion      ‚îÇ ‚îÇDisclos. ‚îÇ ‚îÇService     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ          ‚îÇ           ‚îÇ            ‚îÇ            ‚îÇ
     ‚îÇ          ‚îÇ           ‚îÇ            ‚îÇ            ‚îÇ
     ‚ñº          ‚ñº           ‚ñº            ‚ñº            ‚ñº
 Authen-    Int√©grit√©   Non-r√©pud.  Confident.   Disponib.
 tication                                        (CIA - A)
(AAA - Auth) (CIA - I)   (AAA - Acc) (CIA - C)

                             ‚îÇ
                             ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ Elevation of   ‚îÇ
                    ‚îÇ Privilege      ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
                    Authorization (AAA)
```

**Calcul du score DREAD :**

```
DREAD Score = (D + R + E + A + D) / 5

      Damage        Reproducibility   Exploitability
    Potential
         ‚îÇ                ‚îÇ                ‚îÇ
         ‚ñº                ‚ñº                ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  0-10  ‚îÇ       ‚îÇ  0-10  ‚îÇ       ‚îÇ  0-10  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                ‚îÇ                ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ         ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇAffected ‚îÇ  ‚îÇDiscover-  ‚îÇ
              ‚îÇ Users   ‚îÇ  ‚îÇability    ‚îÇ
              ‚îÇ  0-10   ‚îÇ  ‚îÇ   0-10    ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ            ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ DREAD SCORE ‚îÇ
                  ‚îÇ   0 - 10    ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Exemple:
Vote Tampering: D=10, R=3, E=3, A=10, D=2
Score = (10+3+3+10+2) / 5 = 5.6
```

**Arbre d'attaque :**

```
                    [GOAL: Modify Election Results]
                              ‚îÇ
                             OR
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ                   ‚îÇ
          [Direct DB Access]    [App Layer Attack]
                    ‚îÇ                   ‚îÇ
                   AND                 AND
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ             ‚îÇ      ‚îÇ           ‚îÇ
    [Get DB Creds]  [Bypass Net]  [Find Vuln] [Escalate]
            ‚îÇ             ‚îÇ           ‚îÇ           ‚îÇ
           OR            OR          LEAF        LEAF
       ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ       ‚îÇ     ‚îÇ       ‚îÇ
   [Phish] [Breach] [VPN] [Insider]
```

### 5.4 Les pi√®ges en d√©tail

#### Pi√®ge 1 : Oublier des cat√©gories STRIDE

```python
# FAUX : seulement 4 cat√©gories
STRIDE = ["spoofing", "tampering", "denial_of_service", "info_disclosure"]

# CORRECT : les 6 cat√©gories
STRIDE = ["spoofing", "tampering", "repudiation",
          "information_disclosure", "denial_of_service",
          "elevation_of_privilege"]
```

#### Pi√®ge 2 : Score DREAD hors limites

```python
# FAUX : pas de validation
def calculate_dread(threat):
    damage = base_score + 5  # Peut d√©passer 10 !
    return (damage + r + e + a + d) / 5

# CORRECT : cap √† 10
damage = min(10, max(0, base_score + adjustment))
```

#### Pi√®ge 3 : Ignorer les trust boundaries

```python
# FAUX : analyser uniquement les composants
for component in system["components"]:
    analyze(component)

# CORRECT : les flux traversant des fronti√®res sont critiques
for flow in system["data_flows"]:
    if flow["crosses_boundary"]:
        # Ces flux sont plus risqu√©s !
        threats.extend(analyze_boundary_crossing(flow))
```

### 5.5 Cours Complet

#### 5.5.1 STRIDE : Le Framework Microsoft

**STRIDE** est un framework de classification des menaces cr√©√© par Microsoft en 1999. Il permet d'identifier syst√©matiquement les menaces potentielles sur un syst√®me.

| Cat√©gorie | Description | Contre-mesure | Propri√©t√© viol√©e |
|-----------|-------------|---------------|------------------|
| **S**poofing | Usurpation d'identit√© | Authentication | Authenticit√© |
| **T**ampering | Modification non autoris√©e | Integrity checks | Int√©grit√© |
| **R**epudiation | Nier une action | Non-r√©pudiation | Tra√ßabilit√© |
| **I**nfo Disclosure | Fuite d'information | Encryption | Confidentialit√© |
| **D**enial of Service | Indisponibilit√© | Availability | Disponibilit√© |
| **E**levation of Privilege | Obtenir plus de droits | Authorization | Moindre privil√®ge |

**Comment appliquer STRIDE :**

1. **Dessiner le DFD** (Data Flow Diagram) du syst√®me
2. **Identifier les fronti√®res de confiance**
3. **Pour chaque √©l√©ment du DFD**, poser les 6 questions STRIDE :
   - Peut-on usurper l'identit√© de cet √©l√©ment ? (S)
   - Peut-on modifier les donn√©es ? (T)
   - Peut-on nier une action ? (R)
   - Peut-on acc√©der √† des donn√©es non autoris√©es ? (I)
   - Peut-on rendre le service indisponible ? (D)
   - Peut-on obtenir plus de privil√®ges ? (E)

#### 5.5.2 DREAD : Quantifier les Risques

**DREAD** permet de scorer les menaces identifi√©es pour les prioriser.

| Facteur | Question | Exemple (Vote Tampering) |
|---------|----------|--------------------------|
| **D**amage | Quel est l'impact si l'attaque r√©ussit ? | 10 (√©lection falsifi√©e) |
| **R**eproducibility | L'attaque est-elle facile √† reproduire ? | 3 (complexe) |
| **E**xploitability | L'attaque est-elle facile √† r√©aliser ? | 3 (n√©cessite expertise) |
| **A**ffected Users | Combien d'utilisateurs affect√©s ? | 10 (tous les √©lecteurs) |
| **D**iscoverability | L'attaque est-elle facile √† d√©couvrir ? | 2 (syst√®mes surveill√©s) |

**Score DREAD** = (10 + 3 + 3 + 10 + 2) / 5 = **5.6**

**Interpr√©tation :**
- 0-3 : Risque faible
- 4-6 : Risque moyen
- 7-8 : Risque √©lev√©
- 9-10 : Risque critique

#### 5.5.3 Attack Trees : Visualiser les Sc√©narios

Un **arbre d'attaque** repr√©sente les diff√©rentes fa√ßons d'atteindre un objectif malveillant.

**Structure :**
- **Racine** : Objectif de l'attaquant
- **N≈ìuds AND** : Toutes les sous-conditions doivent √™tre vraies
- **N≈ìuds OR** : Au moins une sous-condition doit √™tre vraie
- **Feuilles** : Actions atomiques

**Exemple : Compromission d'un syst√®me de vote**

```
Modifier les r√©sultats (GOAL)
‚îú‚îÄ‚îÄ OR ‚îÄ‚î¨‚îÄ Acc√®s direct √† la BDD
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ AND ‚îÄ‚î¨‚îÄ Obtenir les credentials
‚îÇ       ‚îÇ            ‚îî‚îÄ Contourner le r√©seau
‚îÇ       ‚îÇ
‚îÇ       ‚îî‚îÄ Attaque applicative
‚îÇ           ‚îî‚îÄ‚îÄ AND ‚îÄ‚î¨‚îÄ Trouver une vuln√©rabilit√©
‚îÇ                    ‚îî‚îÄ Escalader les privil√®ges
```

#### 5.5.4 Contr√¥les de S√©curit√©

Les contr√¥les se divisent en trois cat√©gories :

| Type | Objectif | Exemples |
|------|----------|----------|
| **Pr√©ventif** | Emp√™cher l'attaque | MFA, encryption, WAF |
| **D√©tectif** | D√©tecter l'attaque | SIEM, IDS, monitoring |
| **Correctif** | R√©cup√©rer apr√®s l'attaque | Backup, incident response |

**Principe de d√©fense en profondeur** : Combiner les trois types pour une protection compl√®te.

#### 5.5.5 Conformit√© R√©glementaire

**GDPR (R√®glement G√©n√©ral sur la Protection des Donn√©es) :**
- Article 7 : Consentement document√©
- Article 17 : Droit √† l'effacement
- Article 5(1)(e) : Limitation de conservation

**Lois √©lectorales :**
- Int√©grit√© du vote
- V√©rifiabilit√© end-to-end
- Audit trail papier (dans la plupart des juridictions)

#### 5.5.6 M√©triques de S√©curit√©

| M√©trique | D√©finition | Cible typique |
|----------|------------|---------------|
| **MTTD** | Mean Time To Detect | 4-24 heures |
| **MTTR** | Mean Time To Respond | 24-72 heures |
| **ALE** | Annual Loss Expectancy | Variable |
| **SLE** | Single Loss Expectancy | Variable |
| **ARO** | Annual Rate of Occurrence | 0-100% |

**Formule ALE** : ALE = SLE √ó ARO

### 5.8 Mn√©motechniques

#### üé≠ MEME : "Light vs L" ‚Äî STRIDE Complet

*"Light Yagami ne se contentait jamais d'un seul angle d'attaque. Il anticipait TOUT. STRIDE, c'est pareil : 6 angles, pas 4, pas 5, les 6."*

```
S - "Spoofing"      ‚Üí Light se fait passer pour Kira anonyme
T - "Tampering"     ‚Üí Light modifie les preuves
R - "Repudiation"   ‚Üí Light nie √™tre Kira
I - "Info Disc."    ‚Üí L d√©couvre l'identit√© de Light
D - "DoS"           ‚Üí Kira paralyse la police
E - "Elev. Priv."   ‚Üí Light obtient acc√®s √† l'enqu√™te via son p√®re
```

#### üìä MEME : "Les notes de L" ‚Äî DREAD Score

*"L note tout. DREAD, c'est les 5 dimensions de notation de L pour chaque suspect."*

```
D - Damage         ‚Üí "Si c'est Kira, quel d√©g√¢t ?"
R - Reproducible   ‚Üí "Peut-il tuer √† nouveau ?"
E - Exploitable    ‚Üí "Comment j'attrape ce suspect ?"
A - Affected       ‚Üí "Combien de victimes potentielles ?"
D - Discoverable   ‚Üí "Est-ce qu'on peut le prouver ?"
```

### 5.9 Applications pratiques

- **Pentest Scoping** : Utiliser STRIDE pour d√©finir le p√©rim√®tre des tests
- **Secure SDLC** : Int√©grer le threat modeling √† chaque sprint
- **Due Diligence** : √âvaluer les risques avant une acquisition
- **Certification** : Pr√©parer les audits SOC 2, ISO 27001

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | Solution |
|---|-------|----------|
| 1 | STRIDE incomplet | Toujours v√©rifier les 6 cat√©gories |
| 2 | DREAD > 10 | `min(10, max(0, score))` |
| 3 | Trust boundaries ignor√©es | Analyser sp√©cifiquement les flux cross-boundary |
| 4 | Compliance hardcod√©e | V√©rifier r√©ellement les policies |
| 5 | Pas de m√©triques | Toujours fournir MTTD/MTTR |

---

## üìù SECTION 7 : QCM

**Q1.** Que signifie le "E" dans STRIDE ?

- A) Encryption
- B) Enumeration
- C) Elevation of Privilege ‚úì
- D) Exploitation
- E) Error handling
- F) Exposure
- G) Exfiltration
- H) Evasion
- I) Entropy
- J) Enforcement

**Q2.** Comment calcule-t-on un score DREAD ?

- A) Somme des 5 facteurs
- B) Produit des 5 facteurs
- C) Moyenne des 5 facteurs ‚úì
- D) Maximum des 5 facteurs
- E) Minimum des 5 facteurs
- F) M√©diane des 5 facteurs
- G) Somme pond√©r√©e
- H) Racine carr√©e de la somme
- I) Logarithme de la somme
- J) Mode des 5 facteurs

**Q3.** Quel type de contr√¥le vise √† d√©tecter une attaque en cours ?

- A) Pr√©ventif
- B) Correctif
- C) D√©tectif ‚úì
- D) Compensatoire
- E) Dissuasif
- F) Physique
- G) Technique
- H) Administratif
- I) Logique
- J) R√©pressif

*(Questions 4-10 sur STRIDE, compliance, attack trees...)*

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| **Exercice ID** | 3.1.1-b |
| **Nom** | stratege_risque |
| **Difficult√©** | 8/10 |
| **Concepts** | 7 (STRIDE, DREAD, Controls, Compliance, Metrics, Attack Trees, Risk) |
| **XP Base** | 200 |
| **XP Bonus** | 600 (√ó3) |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.1.1-b-stratege-risque",
    "generated_at": "2026-01-11 15:00:00",

    "metadata": {
      "exercise_id": "3.1.1-b",
      "exercise_name": "stratege_risque",
      "module": "3.1.1",
      "phase": 3,
      "difficulty": 8,
      "xp_base": 200,
      "bonus_tier": "AVANC√â",
      "bonus_icon": "üî•"
    }
  }
}
```

---

*Document g√©n√©r√© selon HACKBRAIN v5.5.2*
*"L'excellence p√©dagogique ne se n√©gocie pas ‚Äî pas de raccourcis"*
