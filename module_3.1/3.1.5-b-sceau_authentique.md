# Exercice 3.1.5-b : sceau_authentique

**Module :** 3.1.5 â€” Fonctions de Hachage

**Concept :** b â€” HMAC et Hachage de Mots de Passe

**DifficultÃ© :** â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :** complet

**Tiers :** 1 â€” Concept isolÃ©

**Langage :** Python 3.14

**PrÃ©requis :** 3.1.5-a (fonctions de hachage)

**Domaines :** Crypto, Mem

**DurÃ©e estimÃ©e :** 100 min

**XP Base :** 250

**ComplexitÃ© :** T3 O(nÂ·iterations) Ã— S3 O(memory)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `sceau_authentique.py`
**AutorisÃ© :** hashlib, hmac, bcrypt, argon2-cffi, secrets
**Interdit :** ImplÃ©mentation maison des algorithmes de password hashing

### 1.2 Consigne

**ğŸ® "Mr. Robot" â€” fsociety Authentication System**

*"Control is an illusion. But the illusion of security isn't... if you hash correctly."* â€” Elliot Alderson

Tu es **Elliot Alderson**, et tu audites le systÃ¨me d'authentification de **E Corp**. Leur base de donnÃ©es a Ã©tÃ© leakÃ©e. Ta mission : Ã©valuer si les mots de passe sont sÃ©curisÃ©s, et si leurs API tokens utilisent HMAC correctement.

*"E Corp stocke les mots de passe en MD5 non salÃ©s. C'est comme laisser la porte ouverte avec un panneau 'Welcome Hackers'."*

**Ta mission :**

1. **ImplÃ©menter HMAC** pour l'authentification de messages
2. **Auditer les configurations** de hachage de mots de passe
3. **Comparer bcrypt, scrypt, Argon2** pour diffÃ©rents contextes
4. **Construire un arbre de Merkle** pour la vÃ©rification d'intÃ©gritÃ©
5. **Cracker des hashes faibles** pour dÃ©montrer les vulnÃ©rabilitÃ©s

### 1.3 Prototype

```python
def sceau_authentique(input_json: str) -> str:
    """Point d'entrÃ©e principal"""
    pass

# HMAC
def hmac_generate(key: bytes, message: bytes, algorithm: str = 'sha256') -> str:
    """GÃ©nÃ¨re un HMAC"""
    pass

def hmac_verify(key: bytes, message: bytes, mac: str, algorithm: str = 'sha256') -> bool:
    """VÃ©rifie un HMAC de faÃ§on constant-time"""
    pass

# Password Hashing
def password_hash_bcrypt(password: str, cost: int = 12) -> str:
    """Hash un mot de passe avec bcrypt"""
    pass

def password_hash_argon2(password: str, time_cost: int = 3,
                         memory_cost: int = 65536, parallelism: int = 4) -> str:
    """Hash un mot de passe avec Argon2id"""
    pass

def password_verify(password: str, hash: str) -> bool:
    """VÃ©rifie un mot de passe contre son hash"""
    pass

def audit_password_hash(hash: str) -> dict:
    """Analyse la sÃ©curitÃ© d'un hash de mot de passe"""
    pass

# Merkle Trees
def build_merkle_tree(leaves: list[bytes]) -> dict:
    """Construit un arbre de Merkle"""
    pass

def generate_merkle_proof(tree: dict, leaf_index: int) -> list:
    """GÃ©nÃ¨re une preuve d'inclusion"""
    pass

def verify_merkle_proof(root: bytes, leaf: bytes, proof: list, index: int) -> bool:
    """VÃ©rifie une preuve de Merkle"""
    pass

# Attack simulation
def crack_weak_hash(hash: str, algorithm: str, wordlist: list[str]) -> dict:
    """Tente de cracker un hash faible"""
    pass
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### LinkedIn Breach (2012, 2016)

6.5 millions de hash SHA-1 non salÃ©s leakÃ©s en 2012, puis 117 millions en 2016. 90% crackÃ©s en quelques jours car SHA-1 est trop rapide.

### bcrypt Origin Story

bcrypt a Ã©tÃ© crÃ©Ã© en 1999 par Niels Provos et David MaziÃ¨res pour OpenBSD. Le "cost factor" double le temps de calcul Ã  chaque incrÃ©ment â€” dÃ©fense contre la loi de Moore.

### Argon2 â€” Le Champion

Argon2 a gagnÃ© le Password Hashing Competition en 2015. C'est le seul algorithme conÃ§u pour rÃ©sister aux ASICs et GPUs via la memory-hardness.

### 2.5 DANS LA VRAIE VIE

- **Security Engineer** : Configuration sÃ©curisÃ©e des systÃ¨mes d'auth
- **Blockchain Developer** : Arbres de Merkle pour preuves d'inclusion
- **API Developer** : HMAC pour authentification de requÃªtes

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ python sceau_authentique.py
HMAC-SHA256 generated and verified: OK âœ“
bcrypt hash (cost=12): 284ms âœ“
Argon2id hash (64MB, 3 iterations): 156ms âœ“
Password audit - MD5 unsalted: CRITICAL âœ—
Merkle tree built with 4 leaves âœ“
Merkle proof verified: OK âœ“
Dictionary attack on MD5("password"): CRACKED in 0.001s âœ“
Tous les tests passent!
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```python
import hashlib
import hmac as hmac_lib
import secrets
import json
import time
from typing import Optional
import bcrypt
import argon2

# ==================== HMAC ====================

def hmac_generate(key: bytes, message: bytes, algorithm: str = 'sha256') -> str:
    """
    GÃ©nÃ¨re un HMAC pour authentifier un message.

    HMAC = Hash(key âŠ• opad || Hash(key âŠ• ipad || message))
    """
    return hmac_lib.new(key, message, algorithm).hexdigest()


def hmac_verify(key: bytes, message: bytes, mac: str, algorithm: str = 'sha256') -> bool:
    """
    VÃ©rifie un HMAC de faÃ§on CONSTANT-TIME.

    IMPORTANT: Utiliser secrets.compare_digest pour Ã©viter les timing attacks!
    """
    expected = hmac_lib.new(key, message, algorithm).hexdigest()
    return secrets.compare_digest(expected, mac)


# ==================== PASSWORD HASHING ====================

def password_hash_bcrypt(password: str, cost: int = 12) -> str:
    """
    Hash un mot de passe avec bcrypt.

    Le cost factor est exponentiel: cost=12 â†’ 2^12 = 4096 iterations.
    RecommandÃ©: cost >= 12 pour 2024.
    """
    if cost < 4:
        raise ValueError("Cost trop faible (minimum 4)")
    if cost < 10:
        print("Warning: cost < 10 non recommandÃ© pour la production")

    salt = bcrypt.gensalt(rounds=cost)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')


def password_hash_argon2(password: str, time_cost: int = 3,
                         memory_cost: int = 65536, parallelism: int = 4) -> str:
    """
    Hash un mot de passe avec Argon2id.

    ParamÃ¨tres recommandÃ©s (OWASP 2024):
    - memory_cost: 64 MB (65536 KB) minimum
    - time_cost: 3 iterations minimum
    - parallelism: selon les cores disponibles
    """
    if memory_cost < 8192:
        raise ValueError("memory_cost trop faible (minimum 8192 KB = 8 MB)")

    hasher = argon2.PasswordHasher(
        time_cost=time_cost,
        memory_cost=memory_cost,
        parallelism=parallelism,
        hash_len=32,
        type=argon2.Type.ID  # Argon2id recommandÃ©
    )
    return hasher.hash(password)


def password_hash_scrypt(password: str, n: int = 16384, r: int = 8, p: int = 1) -> str:
    """
    Hash un mot de passe avec scrypt.

    n: CPU/memory cost (doit Ãªtre puissance de 2)
    r: block size
    p: parallelism
    """
    salt = secrets.token_bytes(16)
    derived = hashlib.scrypt(
        password.encode('utf-8'),
        salt=salt,
        n=n, r=r, p=p,
        dklen=32
    )
    # Format: $scrypt$n$r$p$salt$hash
    import base64
    salt_b64 = base64.b64encode(salt).decode()
    hash_b64 = base64.b64encode(derived).decode()
    return f"$scrypt${n}${r}${p}${salt_b64}${hash_b64}"


def password_verify(password: str, hash_str: str) -> bool:
    """VÃ©rifie un mot de passe contre son hash (dÃ©tecte le format)."""
    try:
        if hash_str.startswith('$2'):  # bcrypt
            return bcrypt.checkpw(password.encode('utf-8'), hash_str.encode('utf-8'))
        elif hash_str.startswith('$argon2'):  # Argon2
            hasher = argon2.PasswordHasher()
            try:
                hasher.verify(hash_str, password)
                return True
            except argon2.exceptions.VerifyMismatchError:
                return False
        elif hash_str.startswith('$scrypt'):  # scrypt maison
            parts = hash_str.split('$')
            if len(parts) != 7:
                return False
            _, _, n, r, p, salt_b64, hash_b64 = parts
            import base64
            salt = base64.b64decode(salt_b64)
            expected = base64.b64decode(hash_b64)
            derived = hashlib.scrypt(
                password.encode('utf-8'),
                salt=salt,
                n=int(n), r=int(r), p=int(p),
                dklen=32
            )
            return secrets.compare_digest(derived, expected)
        else:
            return False
    except Exception:
        return False


def audit_password_hash(hash_str: str) -> dict:
    """Analyse la sÃ©curitÃ© d'un hash de mot de passe."""

    # DÃ©tection du type
    if hash_str.startswith('$2a$') or hash_str.startswith('$2b$'):
        # bcrypt: $2b$12$...
        parts = hash_str.split('$')
        cost = int(parts[2])

        security_rating = "WEAK" if cost < 10 else "MODERATE" if cost < 12 else "STRONG"
        time_estimate = {
            4: "< 1 minute",
            8: "~10 minutes",
            10: "~1 hour",
            12: "~4 hours",
            14: "~1 day"
        }.get(cost, "weeks+")

        return {
            'algorithm': 'bcrypt',
            'cost': cost,
            'security_rating': security_rating,
            'issues': ["cost trop bas"] if cost < 10 else [],
            'recommendation': f"Augmenter cost Ã  12+ (actuellement {cost})" if cost < 12 else "OK",
            'estimated_crack_time_per_hash': time_estimate
        }

    elif hash_str.startswith('$argon2'):
        # Argon2: $argon2id$v=19$m=65536,t=3,p=4$...
        import re
        match = re.search(r'm=(\d+),t=(\d+),p=(\d+)', hash_str)
        if match:
            memory_kb = int(match.group(1))
            time_cost = int(match.group(2))
            parallelism = int(match.group(3))

            issues = []
            if memory_kb < 65536:
                issues.append(f"memory trop bas ({memory_kb}KB < 64MB recommandÃ©)")
            if time_cost < 3:
                issues.append(f"iterations trop basses ({time_cost} < 3 recommandÃ©)")

            security_rating = "WEAK" if issues else "STRONG"

            return {
                'algorithm': 'argon2id',
                'memory_cost_kb': memory_kb,
                'time_cost': time_cost,
                'parallelism': parallelism,
                'security_rating': security_rating,
                'issues': issues,
                'recommendation': "Augmenter memory Ã  64MB+" if memory_kb < 65536 else "OK"
            }

    elif len(hash_str) == 32 and all(c in '0123456789abcdef' for c in hash_str.lower()):
        # MD5 (32 hex chars = 128 bits)
        return {
            'algorithm': 'md5',
            'security_rating': 'CRITICAL',
            'issues': [
                'MD5 cassÃ© cryptographiquement',
                'Pas de sel (rainbow tables applicables)',
                'Trop rapide (~milliards/sec sur GPU)'
            ],
            'recommendation': 'MIGRER IMMÃ‰DIATEMENT vers Argon2id ou bcrypt',
            'estimated_crack_time_per_hash': '< 1 second'
        }

    elif len(hash_str) == 40 and all(c in '0123456789abcdef' for c in hash_str.lower()):
        # SHA-1 (40 hex chars = 160 bits)
        return {
            'algorithm': 'sha1',
            'security_rating': 'CRITICAL',
            'issues': [
                'SHA-1 dÃ©prÃ©ciÃ©',
                'Probablement pas de sel',
                'Trop rapide pour passwords'
            ],
            'recommendation': 'MIGRER vers Argon2id',
            'estimated_crack_time_per_hash': '< 1 second'
        }

    return {'algorithm': 'unknown', 'security_rating': 'UNKNOWN'}


# ==================== MERKLE TREES ====================

def hash_leaf(data: bytes) -> bytes:
    """Hash une feuille avec prÃ©fixe 0x00 (domain separation)."""
    return hashlib.sha256(b'\x00' + data).digest()


def hash_node(left: bytes, right: bytes) -> bytes:
    """Hash un noeud interne avec prÃ©fixe 0x01."""
    return hashlib.sha256(b'\x01' + left + right).digest()


def build_merkle_tree(leaves: list[bytes]) -> dict:
    """
    Construit un arbre de Merkle.

    Retourne:
    {
        'root': bytes,
        'leaves': [bytes, ...],
        'tree': [[level0], [level1], ...],  # level0 = feuilles
    }
    """
    if not leaves:
        return {'root': b'\x00' * 32, 'leaves': [], 'tree': []}

    # Niveau 0: hash des feuilles
    current_level = [hash_leaf(leaf) for leaf in leaves]

    tree = [current_level[:]]

    # Construire les niveaux supÃ©rieurs
    while len(current_level) > 1:
        next_level = []
        for i in range(0, len(current_level), 2):
            left = current_level[i]
            # Si nombre impair, dupliquer le dernier
            right = current_level[i + 1] if i + 1 < len(current_level) else left
            next_level.append(hash_node(left, right))
        tree.append(next_level)
        current_level = next_level

    return {
        'root': current_level[0],
        'leaves': [hash_leaf(l) for l in leaves],
        'tree': tree
    }


def generate_merkle_proof(tree: dict, leaf_index: int) -> list:
    """
    GÃ©nÃ¨re une preuve d'inclusion pour une feuille.

    Retourne liste de (sibling_hash, direction) oÃ¹ direction = 'left' ou 'right'.
    """
    proof = []
    index = leaf_index
    levels = tree['tree']

    for level in levels[:-1]:  # Tous sauf la racine
        if index % 2 == 0:  # Noeud gauche
            sibling_index = index + 1 if index + 1 < len(level) else index
            direction = 'right'
        else:  # Noeud droit
            sibling_index = index - 1
            direction = 'left'

        proof.append({
            'sibling': level[sibling_index].hex(),
            'direction': direction
        })
        index //= 2

    return proof


def verify_merkle_proof(root: bytes, leaf: bytes, proof: list, leaf_index: int) -> bool:
    """VÃ©rifie une preuve de Merkle."""
    current = leaf

    for step in proof:
        sibling = bytes.fromhex(step['sibling'])
        if step['direction'] == 'right':
            current = hash_node(current, sibling)
        else:
            current = hash_node(sibling, current)

    return current == root


# ==================== ATTACK SIMULATION ====================

def crack_weak_hash(hash_str: str, algorithm: str, wordlist: list[str]) -> dict:
    """Tente de cracker un hash avec un dictionnaire."""
    hash_func = getattr(hashlib, algorithm)
    start_time = time.perf_counter()
    attempts = 0

    for word in wordlist:
        attempts += 1
        candidate = hash_func(word.encode()).hexdigest()
        if candidate == hash_str.lower():
            elapsed = time.perf_counter() - start_time
            return {
                'cracked': True,
                'password': word,
                'attempts': attempts,
                'time_seconds': round(elapsed, 6),
                'hash_rate': round(attempts / elapsed, 2) if elapsed > 0 else float('inf')
            }

    elapsed = time.perf_counter() - start_time
    return {
        'cracked': False,
        'attempts': attempts,
        'time_seconds': round(elapsed, 6)
    }


# ==================== MAIN ====================

def sceau_authentique(input_json: str) -> str:
    """Point d'entrÃ©e principal."""
    data = json.loads(input_json)
    results = {}

    # HMAC operations
    if 'hmac_operations' in data:
        results['hmac'] = []
        for op in data['hmac_operations']:
            key = op['key'].encode() if isinstance(op['key'], str) else bytes.fromhex(op['key'])
            msg = op['message'].encode() if isinstance(op['message'], str) else bytes.fromhex(op['message'])
            algo = op.get('algorithm', 'sha256')

            if op.get('verify'):
                result = hmac_verify(key, msg, op['verify'], algo)
                results['hmac'].append({'operation': 'verify', 'valid': result})
            else:
                mac = hmac_generate(key, msg, algo)
                results['hmac'].append({'operation': 'generate', 'mac': mac})

    # Password hashing
    if 'password_hashing' in data:
        results['password_hashing'] = []
        for op in data['password_hashing']:
            algo = op['algorithm']
            password = op['password']

            if algo == 'bcrypt':
                start = time.perf_counter()
                hash_result = password_hash_bcrypt(password, op.get('cost', 12))
                elapsed = (time.perf_counter() - start) * 1000
                results['password_hashing'].append({
                    'algorithm': 'bcrypt',
                    'hash': hash_result,
                    'time_ms': round(elapsed, 2)
                })

            elif algo == 'argon2id':
                start = time.perf_counter()
                hash_result = password_hash_argon2(
                    password,
                    op.get('time_cost', 3),
                    op.get('memory_cost', 65536),
                    op.get('parallelism', 4)
                )
                elapsed = (time.perf_counter() - start) * 1000
                results['password_hashing'].append({
                    'algorithm': 'argon2id',
                    'hash': hash_result,
                    'time_ms': round(elapsed, 2)
                })

    # Password audit
    if 'password_audit' in data:
        results['password_audit'] = []
        for item in data['password_audit']['hashes']:
            audit = audit_password_hash(item['hash'])
            audit['username'] = item.get('username', 'unknown')
            results['password_audit'].append(audit)

    # Attack simulation
    if 'attack_simulation' in data:
        atk = data['attack_simulation']
        wordlist = atk.get('wordlist', ['password', '123456', 'admin', 'letmein', 'welcome'])
        results['attack'] = crack_weak_hash(atk['hash'], atk['algorithm'], wordlist)

    # Merkle tree
    if 'merkle_tree' in data:
        leaves = [leaf.encode() for leaf in data['merkle_tree']['leaves']]
        tree = build_merkle_tree(leaves)

        results['merkle_tree'] = {
            'root': tree['root'].hex(),
            'leaf_count': len(leaves)
        }

        if 'proof_for_index' in data['merkle_tree']:
            idx = data['merkle_tree']['proof_for_index']
            proof = generate_merkle_proof(tree, idx)
            results['merkle_tree']['proof'] = proof
            results['merkle_tree']['proof_valid'] = verify_merkle_proof(
                tree['root'],
                tree['leaves'][idx],
                proof,
                idx
            )

    return json.dumps(results, indent=2)
```

### 4.10 Solutions Mutantes

```python
# Mutant A (Safety): VÃ©rification HMAC non constant-time
def hmac_verify_mutant_a(key: bytes, message: bytes, mac: str, algorithm: str = 'sha256') -> bool:
    expected = hmac_lib.new(key, message, algorithm).hexdigest()
    return expected == mac  # âŒ Comparaison non constant-time!
# Impact: Timing attack permet de deviner le MAC byte par byte

# Mutant B (Resource): bcrypt cost trop faible par dÃ©faut
def password_hash_bcrypt_mutant_b(password: str, cost: int = 4) -> str:  # âŒ cost=4!
    salt = bcrypt.gensalt(rounds=cost)
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')
# Impact: Hash crackable en millisecondes

# Mutant C (Logic): Argon2 avec mÃ©moire insuffisante
def password_hash_argon2_mutant_c(password: str) -> str:
    hasher = argon2.PasswordHasher(
        time_cost=1,
        memory_cost=1024,  # âŒ 1MB au lieu de 64MB!
        parallelism=1
    )
    return hasher.hash(password)
# Impact: GPU/ASIC attack viable

# Mutant D (Boundary): Merkle sans domain separation
def hash_leaf_mutant_d(data: bytes) -> bytes:
    return hashlib.sha256(data).digest()  # âŒ Pas de prÃ©fixe!
def hash_node_mutant_d(left: bytes, right: bytes) -> bytes:
    return hashlib.sha256(left + right).digest()  # âŒ Pas de prÃ©fixe!
# Impact: Second pre-image attack possible

# Mutant E (Return): Audit qui ne dÃ©tecte pas MD5
def audit_password_hash_mutant_e(hash_str: str) -> dict:
    if hash_str.startswith('$2'):
        return {'algorithm': 'bcrypt', 'security_rating': 'STRONG'}
    # âŒ Manque dÃ©tection MD5/SHA1!
    return {'algorithm': 'unknown', 'security_rating': 'UNKNOWN'}
# Impact: Faux nÃ©gatifs sur hashes critiquement faibles
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

- **HMAC** : Authentification de messages avec clÃ© secrÃ¨te
- **Password hashing** : bcrypt, scrypt, Argon2 et leurs paramÃ¨tres
- **Arbres de Merkle** : Preuves d'inclusion efficaces
- **Timing attacks** : Importance des comparaisons constant-time
- **Audit de sÃ©curitÃ©** : Ã‰valuer des configurations existantes

### 5.2 LDA â€” Traduction littÃ©rale

```
FONCTION hmac_verify QUI RETOURNE UN BOOLÃ‰EN ET PREND EN PARAMÃˆTRES key, message, mac, algorithm
DÃ‰BUT FONCTION
    DÃ‰CLARER expected COMME LE RÃ‰SULTAT DE hmac.new DE key, message, algorithm PUIS hexdigest
    RETOURNER LE RÃ‰SULTAT DE secrets.compare_digest DE expected ET mac
FIN FONCTION

FONCTION build_merkle_tree QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAMÃˆTRE leaves QUI EST UNE LISTE
DÃ‰BUT FONCTION
    DÃ‰CLARER current_level COMME UNE LISTE CONTENANT LE HASH DE CHAQUE FEUILLE
    DÃ‰CLARER tree COMME UNE LISTE CONTENANT current_level

    TANT QUE LA TAILLE DE current_level EST SUPÃ‰RIEURE Ã€ 1 FAIRE
        DÃ‰CLARER next_level COMME LISTE VIDE
        POUR CHAQUE PAIRE (left, right) DANS current_level FAIRE
            AJOUTER hash_node(left, right) Ã€ next_level
        FIN POUR
        AJOUTER next_level Ã€ tree
        AFFECTER next_level Ã€ current_level
    FIN TANT QUE

    RETOURNER UN DICTIONNAIRE AVEC root, leaves, tree
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
HMAC CONSTRUCTION
=================

HMAC(K, m) = H((K' âŠ• opad) || H((K' âŠ• ipad) || m))

oÃ¹ K' = K si |K| â‰¤ block_size, sinon H(K)
   ipad = 0x36 rÃ©pÃ©tÃ©
   opad = 0x5c rÃ©pÃ©tÃ©

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   Key (K)                                                       â”‚
â”‚     â”‚                                                           â”‚
â”‚     â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚   â”‚ Pad to block  â”‚                                            â”‚
â”‚   â”‚    size       â”‚                                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚           â”‚                                                     â”‚
â”‚           â–¼                                                     â”‚
â”‚    K' âŠ• ipad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚           â”‚                    â”‚                                â”‚
â”‚           â–¼                    â”‚                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚                                â”‚
â”‚   â”‚  || message   â”‚           â”‚                                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚                                â”‚
â”‚           â”‚                    â”‚                                â”‚
â”‚           â–¼                    â”‚                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚                                â”‚
â”‚   â”‚    Hash H     â”‚           â”‚                                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â–¼                                â”‚
â”‚           â”‚            K' âŠ• opad                               â”‚
â”‚           â”‚                   â”‚                                â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                   â”‚                                            â”‚
â”‚                   â–¼                                            â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚           â”‚      || H     â”‚                                    â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                   â”‚                                            â”‚
â”‚                   â–¼                                            â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚           â”‚    Hash H     â”‚                                    â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                   â”‚                                            â”‚
â”‚                   â–¼                                            â”‚
â”‚               HMAC(K,m)                                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


PASSWORD HASHING COMPARISON
===========================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Algorithm  â”‚ CPU Cost   â”‚ Memory     â”‚ GPU/ASIC Resistance        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MD5       â”‚ ğŸ’¨ Instant â”‚ O(1)       â”‚ âŒ 100B/s GPU             â”‚
â”‚ SHA-256   â”‚ ğŸ’¨ Fast    â”‚ O(1)       â”‚ âŒ 10B/s GPU              â”‚
â”‚ bcrypt    â”‚ ğŸ¢ Slow    â”‚ 4KB        â”‚ âš ï¸ Moderate (GPU ok)      â”‚
â”‚ scrypt    â”‚ ğŸ¢ Slow    â”‚ 1MB-1GB    â”‚ âœ“ Memory-hard             â”‚
â”‚ Argon2id  â”‚ ğŸ¢ Slow    â”‚ 64MB+      â”‚ âœ“âœ“ Memory+time-hard       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


MERKLE TREE
===========

Transactions: [T1, T2, T3, T4]

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      ROOT       â”‚
                      â”‚   H(H12||H34)   â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
        â”‚    H12    â”‚                    â”‚    H34    â”‚
        â”‚ H(H1||H2) â”‚                    â”‚ H(H3||H4) â”‚
        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
              â”‚                                 â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
       â”‚             â”‚                   â”‚             â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”     â”Œâ”€â”€â”€â”´â”€â”€â”€â”          â”Œâ”€â”€â”€â”´â”€â”€â”€â”     â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   â”‚  H1   â”‚     â”‚  H2   â”‚          â”‚  H3   â”‚     â”‚  H4   â”‚
   â”‚ H(T1) â”‚     â”‚ H(T2) â”‚          â”‚ H(T3) â”‚     â”‚ H(T4) â”‚
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜     â””â”€â”€â”€â”¬â”€â”€â”€â”˜          â””â”€â”€â”€â”¬â”€â”€â”€â”˜     â””â”€â”€â”€â”¬â”€â”€â”€â”˜
       â”‚             â”‚                   â”‚             â”‚
       T1            T2                  T3            T4


PROOF FOR T3:
â•â•â•â•â•â•â•â•â•â•â•â•â•
Pour prouver T3 âˆˆ arbre:

1. Start: H3 = H(T3)
2. Sibling: H4 â†’ H34 = H(H3||H4)
3. Sibling: H12 â†’ ROOT = H(H12||H34)

Proof = [H4, H12] avec directions [right, left]
Taille preuve: O(log n) vs O(n) pour liste complÃ¨te!
```

### 5.5 Cours Complet

#### HMAC â€” Pourquoi pas juste H(key || message)?

H(key || message) est vulnÃ©rable au length extension.
H(message || key) est vulnÃ©rable si H a des collisions.

HMAC rÃ©sout les deux problÃ¨mes avec sa construction double-hash.

#### Password Hashing â€” Les 3 critÃ¨res

1. **CPU-hard** : Lent Ã  calculer (bcrypt, Argon2)
2. **Memory-hard** : Requiert beaucoup de RAM (scrypt, Argon2)
3. **RÃ©sistant aux parallÃ©lisation** : Difficile Ã  accÃ©lÃ©rer sur GPU/ASIC

#### ParamÃ¨tres RecommandÃ©s 2024

| Algorithme | ParamÃ¨tres |
|------------|------------|
| bcrypt | cost â‰¥ 12 |
| scrypt | N=2^17, r=8, p=1, 128MB |
| Argon2id | t=3, m=64MB, p=4 |

### 5.8 MnÃ©motechniques

**ğŸ® MEME : "Mr. Robot - Timing Attack"**

Comme Elliot qui observe les micro-expressions de ses cibles, un attaquant peut observer les micro-secondes de ta comparaison de hash pour deviner le mot de passe byte par byte.

```python
# âŒ Elliot te regarde comparer
if user_mac == expected_mac:  # Timing leak!
    pass

# âœ… Constant-time: Elliot ne voit rien
if secrets.compare_digest(user_mac, expected_mac):
    pass
```

---

**ğŸ’» MEME : "E Corp Password Policy"**

E Corp stocke les mots de passe en MD5. C'est comme mettre ton argent dans un coffre en carton avec la combinaison Ã©crite dessus.

```python
# âŒ E Corp: "C'est sÃ©curisÃ© car c'est illisible!"
password_hash = hashlib.md5(password.encode()).hexdigest()

# âœ… fsociety approved:
password_hash = argon2.PasswordHasher().hash(password)
```

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | DÃ©tection | Correction |
|---|-------|-----------|------------|
| 1 | Comparaison non constant-time | Timing analysis | secrets.compare_digest |
| 2 | bcrypt cost < 10 | Audit config | Augmenter Ã  12+ |
| 3 | Argon2 memory < 64MB | Audit config | Augmenter mÃ©moire |
| 4 | H(secret\|\|msg) au lieu HMAC | Code review | Utiliser hmac module |
| 5 | Merkle sans domain separation | Analyse proto | PrÃ©fixes 0x00/0x01 |

---

## ğŸ“ SECTION 7 : QCM

**Q1:** Pourquoi HMAC plutÃ´t que H(key||message)?
A) Plus rapide  B) RÃ©siste au length extension âœ“  C) Plus court  D) Plus ancien

**Q2:** Quel est le cost minimum recommandÃ© pour bcrypt en 2024?
A) 4  B) 8  C) 12 âœ“  D) 16

**Q3:** Quelle propriÃ©tÃ© rend Argon2 rÃ©sistant aux GPUs?
A) Lenteur  B) Memory-hardness âœ“  C) ParallÃ©lisme  D) Taille de sortie

**Q4:** Pourquoi utiliser des prÃ©fixes dans les Merkle trees?
A) Performance  B) Ã‰viter les attaques second pre-image âœ“  C) Compression  D) CompatibilitÃ©

**Q5:** Quelle vulnÃ©rabilitÃ© exploite une timing attack sur HMAC verify?
A) Collisions  B) Comparaison byte-par-byte non constant-time âœ“  C) Weak key  D) Length extension

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| Exercice | 3.1.5-b : sceau_authentique |
| Concepts | HMAC, bcrypt, Argon2, Merkle trees |
| DifficultÃ© | 8/10 |
| XP | 250 |

---

*Exercice gÃ©nÃ©rÃ© par HACKBRAIN v5.5.2*
