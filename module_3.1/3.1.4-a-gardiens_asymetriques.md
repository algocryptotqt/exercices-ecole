# Exercice 3.1.4-a : gardiens_asymetriques

**Module :** 3.1.4 ‚Äî Chiffrement Asym√©trique
**Concept :** a ‚Äî RSA Complet
**Difficult√© :** ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)
**Type :** complet
**Tiers :** 1 ‚Äî Concept isol√©
**Langage :** Rust Edition 2024
**Pr√©requis :** 3.1.2-a, 3.1.2-b (arithm√©tique modulaire, primes)
**Domaines :** Crypto, MD
**Dur√©e estim√©e :** 120 min
**XP Base :** 275
**Complexit√© :** T4 O(k¬≥) √ó S2 O(k)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `gardiens_asymetriques.rs`
**Autoris√© :** std, rand
**Interdit :** rsa, ring, openssl

### 1.2 Consigne

**üéÆ "The Matrix" ‚Äî La Cl√© de la Matrice**

*"Il y a une diff√©rence entre conna√Ætre le chemin et arpenter le chemin."* ‚Äî Morpheus

Tu es **Neo**, nouvellement √©veill√© de la Matrice. **Morpheus** t'enseigne le secret des **Gardiens Asym√©triques** ‚Äî les sentinelles math√©matiques qui prot√®gent Zion.

*"Dans la Matrice, tout le monde peut chiffrer avec ta cl√© publique. Mais seul l'√âlu peut d√©chiffrer avec la cl√© priv√©e. C'est le pouvoir de RSA ‚Äî la trapdoor function."*

Mais **l'Agent Smith** conna√Æt les faiblesses : exposant trop petit, padding absent, modules mal g√©n√©r√©s. Ta mission : impl√©menter RSA correctement ET comprendre comment Smith attaquerait.

**Ta mission :**

1. **G√©n√©rer des cl√©s RSA** s√©curis√©es (p, q premiers, e=65537, d calcul√©)
2. **Chiffrer/D√©chiffrer** avec OAEP (pas textbook RSA!)
3. **Signer/V√©rifier** avec PSS
4. **Analyser les attaques** : low exponent, Wiener, Bleichenbacher

### 1.3 Prototype

```rust
pub fn gardiens_asymetriques(input: &str) -> String

struct RsaKeyPair { n: BigInt, e: BigInt, d: BigInt, p: BigInt, q: BigInt }

fn generate_rsa_keypair(bits: u32, e: u64) -> RsaKeyPair
fn rsa_encrypt_oaep(m: &[u8], public_key: &RsaPublic, label: &[u8]) -> Vec<u8>
fn rsa_decrypt_oaep(c: &[u8], private_key: &RsaPrivate, label: &[u8]) -> Result<Vec<u8>, &'static str>
fn rsa_sign_pss(msg: &[u8], private_key: &RsaPrivate) -> Vec<u8>
fn rsa_verify_pss(msg: &[u8], sig: &[u8], public_key: &RsaPublic) -> bool
fn wiener_attack(e: &BigInt, n: &BigInt) -> Option<BigInt>
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Debian OpenSSL Disaster (2008)

Un d√©veloppeur Debian a supprim√© une ligne "non-initialis√©e" pour faire taire Valgrind. R√©sultat : 2 ans de cl√©s RSA g√©n√©r√©es avec seulement 32,768 possibilit√©s au lieu de 2¬π‚Å∞¬≤‚Å¥. Toutes compromises.

### Bleichenbacher's Million Message Attack (1998)

Daniel Bleichenbacher a cass√© SSL en exploitant les messages d'erreur PKCS#1 v1.5. Les serveurs r√©v√©laient si le padding √©tait correct, permettant de d√©chiffrer en ~1 million de requ√™tes.

### 2.5 DANS LA VRAIE VIE

- **PKI Engineer** : G√©n√©rer certificats X.509 avec RSA
- **Security Researcher** : Auditer les impl√©mentations RSA
- **Pentest** : Tester Bleichenbacher sur TLS legacy

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ cargo run --release
RSA 2048-bit key generation: 1.2s ‚úì
OAEP encrypt/decrypt round-trip: OK ‚úì
PSS sign/verify: OK ‚úì
Wiener attack on weak d: recovered d ‚úì
Tous les tests passent!
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence (extraits)

```rust
fn mod_pow(base: &BigInt, exp: &BigInt, modulus: &BigInt) -> BigInt {
    // Square-and-multiply
    let mut result = BigInt::one();
    let mut base = base.clone() % modulus;
    let mut exp = exp.clone();
    while exp > BigInt::zero() {
        if &exp % 2u32 == BigInt::one() {
            result = (result * &base) % modulus;
        }
        exp >>= 1;
        base = (&base * &base) % modulus;
    }
    result
}

fn generate_rsa_keypair(bits: u32, e: u64) -> RsaKeyPair {
    let e = BigInt::from(e);
    loop {
        let p = generate_prime(bits / 2);
        let q = generate_prime(bits / 2);
        if &p == &q { continue; }

        let n = &p * &q;
        let phi = (&p - 1u32) * (&q - 1u32);

        if gcd(&e, &phi) != BigInt::one() { continue; }

        let d = mod_inverse(&e, &phi).unwrap();

        // V√©rifier que d n'est pas trop petit (Wiener)
        if d < n.sqrt() / 3u32 { continue; }

        return RsaKeyPair { n, e, d, p, q };
    }
}

fn rsa_encrypt_textbook(m: &BigInt, e: &BigInt, n: &BigInt) -> BigInt {
    mod_pow(m, e, n)
}

fn rsa_decrypt_textbook(c: &BigInt, d: &BigInt, n: &BigInt) -> BigInt {
    mod_pow(c, d, n)
}

// Wiener's attack: si d < n^(1/4) / 3, on peut retrouver d
fn wiener_attack(e: &BigInt, n: &BigInt) -> Option<BigInt> {
    // D√©veloppement en fraction continue de e/n
    let convergents = continued_fraction_convergents(e, n);

    for (k, d) in convergents {
        if k == BigInt::zero() { continue; }

        // œÜ(n) = (ed - 1) / k
        let ed_minus_1 = e * &d - 1u32;
        if &ed_minus_1 % &k != BigInt::zero() { continue; }

        let phi = &ed_minus_1 / &k;

        // n - œÜ(n) + 1 = p + q
        // V√©rifier si on peut factoriser n
        let sum_pq = n - &phi + 1u32;
        let discriminant = &sum_pq * &sum_pq - 4u32 * n;

        if discriminant >= BigInt::zero() {
            let sqrt_disc = discriminant.sqrt();
            if &sqrt_disc * &sqrt_disc == discriminant {
                // d trouv√©!
                return Some(d);
            }
        }
    }
    None
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A: p = q (n = p¬≤, trivial √† factoriser)
fn generate_keypair_mutant_a(bits: u32) -> RsaKeyPair {
    let p = generate_prime(bits / 2);
    let q = p.clone();  // ‚ùå n = p¬≤ ‚Üí factorisation triviale
    // ...
}

// Mutant B: Textbook RSA sans padding
fn encrypt_mutant_b(m: &BigInt, e: &BigInt, n: &BigInt) -> BigInt {
    mod_pow(m, e, n)  // ‚ùå Vuln√©rable: m√™me m ‚Üí m√™me c, attaques multiplicatives
}

// Mutant C: d trop petit (Wiener exploitable)
fn generate_keypair_mutant_c() -> RsaKeyPair {
    // Choisir d petit pour "acc√©l√©rer"
    // ‚ùå Wiener attack si d < n^0.25 / 3
}

// Mutant D: e = 3 sans padding (low exponent attack)
fn encrypt_mutant_d(m: &BigInt, n: &BigInt) -> BigInt {
    mod_pow(m, &BigInt::from(3), n)  // ‚ùå Si m¬≥ < n, c = m¬≥ ‚Üí m = ‚àõc
}
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 RSA en bref

```
G√©n√©ration:
1. p, q premiers al√©atoires
2. n = p √ó q
3. œÜ(n) = (p-1)(q-1)
4. e copremier avec œÜ(n) (souvent 65537)
5. d = e‚Åª¬π mod œÜ(n)

Public: (n, e)    Private: (n, d)

Chiffrement: c = m·µâ mod n
D√©chiffrement: m = c·µà mod n
```

### 5.3 Visualisation ASCII

```
          ALICE                              BOB
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Private: d  ‚îÇ                   ‚îÇ Public: e,n ‚îÇ
    ‚îÇ Public: e,n ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Bob veut envoyer "HELLO" √† Alice:
1. Bob: c = HELLO^e mod n
2. Bob ‚Üí Alice: c
3. Alice: m = c^d mod n = HELLO ‚úì
```

### 5.8 Mn√©motechniques

**üéÆ MEME : "The Matrix" ‚Äî Red pill or Blue pill**

```
Morpheus: "Textbook RSA ou OAEP?"

Neo: "Quelle est la diff√©rence?"

Morpheus: "Textbook = pilule bleue. Tu restes vuln√©rable.
           OAEP = pilule rouge. Tu vois les attaques."

Neo: *prend OAEP*
```

---

## üìù SECTION 7 : QCM

**Q1:** RSA repose sur la difficult√© de?
A) Log discret  B) Factorisation ‚úì  C) Hash  D) ECC

**Q2:** Pourquoi e=65537?
A) Premier, peu de 1 binaires (rapide) ‚úì  B) Al√©atoire  C) Standard impos√©  D) S√©curit√© maximale

**Q3:** Textbook RSA est vuln√©rable car?
A) Trop lent  B) D√©terministe, attaques multiplicatives ‚úì  C) Cl√© trop courte  D) Hash faible

**Q4:** Wiener attack fonctionne si?
A) e petit  B) d < n^0.25 / 3 ‚úì  C) p = q  D) n impair

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.4-a : gardiens_asymetriques |
| Concepts | RSA keygen, OAEP, PSS, Wiener |
| Difficult√© | 9/10 |
| XP | 275 |

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
