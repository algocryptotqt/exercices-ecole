# Exercice 3.1.3-b : coffre_fort_moderne

**Module :** 3.1.3 ‚Äî Chiffrement Sym√©trique
**Concept :** b ‚Äî Chiffrements par Blocs et Modes d'Op√©ration
**Difficult√© :** ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)
**Type :** complet
**Tiers :** 1 ‚Äî Concept isol√©
**Langage :** Rust Edition 2024
**Pr√©requis :** 3.1.3-a, bases XOR et manipulation binaire
**Domaines :** Crypto, Encodage
**Dur√©e estim√©e :** 100 min
**XP Base :** 225
**Complexit√© :** T2 O(n√ór) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `coffre_fort_moderne.rs`
**Autoris√© :** std Rust uniquement
**Interdit :** aes, ring, openssl, crypto

### 1.2 Consigne

**üéÆ "Mr. Robot" meets "Sneakers"**

*"Le chiffrement n'est pas une protection ‚Äî c'est une illusion de protection si tu ne comprends pas les modes."* ‚Äî Elliot Alderson (probablement)

Tu es **fsociety_crypt0**, membre de la division crypto de fsociety. Evil Corp utilise un syst√®me de chiffrement legacy avec plusieurs modes ‚Äî certains s√©curis√©s, d'autres catastrophiquement vuln√©rables.

Ton mentor, **Darlene**, t'a brief√© : *"ECB c'est pour les script kiddies ‚Äî les patterns sont visibles. CBC c'est mieux mais le bit-flipping peut tout casser. CTR c'est bien si tu ne r√©utilises jamais le nonce. Sinon, c'est game over."*

**Ta mission :**

1. **Impl√©menter un Feistel cipher** simplifi√© (comprendre la structure)
2. **Identifier les modes** (ECB, CBC, CTR) √† partir de ciphertexts
3. **Exploiter ECB** : d√©tecter les patterns de blocs identiques
4. **Attaque bit-flipping CBC** : modifier un byte sans conna√Ætre la cl√©
5. **Attaque CTR nonce-reuse** : r√©cup√©rer le keystream

**Entr√©e :** `input: &str` ‚Äî JSON avec t√¢ches
**Sortie :** `String` ‚Äî JSON avec r√©sultats

### 1.2.2 Consigne Acad√©mique

√âtudier et impl√©menter :
- **Structure de Feistel** : block = (L, R) ‚Üí (R, L ‚äï F(R, K))
- **Modes d'op√©ration** : ECB (dangereux), CBC (IV requis), CTR (nonce+counter)
- **Vuln√©rabilit√©s** : patterns ECB, bit-flipping CBC, nonce-reuse CTR

### 1.3 Prototype

```rust
pub fn coffre_fort_moderne(input: &str) -> String

// Feistel
fn feistel_round(l: u32, r: u32, key: u32) -> (u32, u32)
fn feistel_encrypt(block: u64, keys: &[u32], rounds: usize) -> u64
fn feistel_decrypt(block: u64, keys: &[u32], rounds: usize) -> u64

// Modes
fn ecb_encrypt(data: &[u8], cipher: impl Fn(&[u8]) -> Vec<u8>) -> Vec<u8>
fn cbc_encrypt(data: &[u8], iv: &[u8], cipher: impl Fn(&[u8]) -> Vec<u8>) -> Vec<u8>
fn ctr_encrypt(data: &[u8], nonce: &[u8], cipher: impl Fn(&[u8]) -> Vec<u8>) -> Vec<u8>

// Attaques
fn detect_ecb(ciphertext: &[u8], block_size: usize) -> bool
fn cbc_bitflip(ct: &mut [u8], iv: &mut [u8], byte_pos: usize, target: u8, known_pt: u8)
fn ctr_nonce_reuse_attack(c1: &[u8], c2: &[u8]) -> Vec<u8>
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Le Pingouin ECB

L'image la plus c√©l√®bre en crypto : le "ECB Penguin". Si tu chiffres une image BMP avec AES-ECB, les patterns de l'image originale restent visibles dans le ciphertext. Google "ECB penguin" ‚Äî c'est √©difiant.

### L'attaque Padding Oracle (POODLE)

En 2014, l'attaque **POODLE** a exploit√© CBC + padding pour d√©crypter HTTPS. Google l'a d√©couverte et SSL 3.0 a √©t√© enterr√©.

### PlayStation 3 Hack

En 2010, fail0verflow a cass√© la PS3 car Sony r√©utilisait le m√™me **nonce ECDSA** pour toutes les signatures. Un cas classique de CTR nonce-reuse appliqu√© aux signatures.

### 2.5 DANS LA VRAIE VIE

- **Pentest** : Identifier les modes utilis√©s pour planifier les attaques
- **DevSecOps** : Auditer le code pour les mauvais usages d'IV/nonce
- **Forensics** : Analyser les donn√©es chiffr√©es r√©cup√©r√©es
- **Reverse Engineer** : Identifier les algorithmes dans les binaires

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ cargo run --release
Feistel 4 rounds: encrypt/decrypt OK ‚úì
ECB pattern detection: blocs 2 et 5 identiques ‚úì
CBC bit-flip: byte 5 chang√© en 'X' sans conna√Ætre la cl√© ‚úì
CTR nonce-reuse: keystream r√©cup√©r√© ‚úì
Tous les tests passent!
```

---

## ‚ö° SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**Difficult√© :** üíÄ (11/10) | **XP :** √ó4

Impl√©menter :
- **AES complet** (SubBytes, ShiftRows, MixColumns, AddRoundKey)
- **Padding Oracle Attack** sur CBC (Vaudenay)
- **Lucky13** timing attack
- **GCM mode** avec authentification

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points | Trap |
|------|-------|----------|--------|------|
| feistel_encrypt | block, 4 rounds | Correct ciphertext | 15 | Non |
| feistel_decrypt | ciphertext | Original block | 10 | Non |
| ecb_pattern | Repeated plaintext blocks | Detected | 15 | Non |
| cbc_bitflip | Modify byte 5 ‚Üí 'X' | Success | 20 | Oui |
| ctr_nonce_reuse | c1, c2 same nonce | m1 ‚äï m2 | 20 | Oui |
| mode_identify | Multiple ciphertexts | Correct modes | 15 | Non |

### 4.2 main.rs de test

```rust
use coffre_fort_moderne::coffre_fort_moderne;
use serde_json::{json, Value};

fn main() {
    let mut passed = 0;

    // Test Feistel
    let input = json!({
        "implementations": [{
            "task": "feistel",
            "block_hex": "0123456789ABCDEF",
            "keys": [0x12345678u32, 0x9ABCDEF0u32, 0xFEDCBA98u32, 0x76543210u32],
            "rounds": 4
        }]
    }).to_string();
    let result: Value = serde_json::from_str(&coffre_fort_moderne(&input)).unwrap();
    if result["implementations"]["feistel"]["success"] == true {
        println!("Feistel: OK");
        passed += 1;
    }

    // Test ECB detection
    let input = json!({
        "mode_identification": [{
            "ciphertext_hex": "AABBCCDDAABBCCDDAABBCCDDAABBCCDD",  // Blocs identiques
            "block_size": 4
        }]
    }).to_string();
    let result: Value = serde_json::from_str(&coffre_fort_moderne(&input)).unwrap();
    if result["mode_identifications"][0]["mode"] == "ECB" {
        println!("ECB detection: OK");
        passed += 1;
    }

    // Test CBC bit-flip
    let input = json!({
        "attacks": [{
            "type": "cbc_bitflip",
            "ciphertext_hex": "...",
            "iv_hex": "...",
            "target_byte_position": 5,
            "current_plaintext_byte": 0x41,  // 'A'
            "target_plaintext_byte": 0x58   // 'X'
        }]
    }).to_string();
    let result: Value = serde_json::from_str(&coffre_fort_moderne(&input)).unwrap();
    if result["attack_results"][0]["success"] == true {
        println!("CBC bit-flip: OK");
        passed += 1;
    }

    println!("{}/3 tests pass√©s", passed);
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json;
use std::collections::HashMap;

// Simple round function for Feistel (demonstration)
fn feistel_f(r: u32, k: u32) -> u32 {
    // Rotation + XOR + substitution simple
    let rotated = r.rotate_left(5);
    let mixed = rotated ^ k;
    // S-box simplifi√©e (dans un vrai cipher, ce serait plus complexe)
    mixed.wrapping_mul(0x5bd1e995) ^ (mixed >> 15)
}

fn feistel_round(l: u32, r: u32, key: u32) -> (u32, u32) {
    (r, l ^ feistel_f(r, key))
}

fn feistel_encrypt(block: u64, keys: &[u32], rounds: usize) -> u64 {
    let mut l = (block >> 32) as u32;
    let mut r = block as u32;

    for i in 0..rounds {
        let (new_l, new_r) = feistel_round(l, r, keys[i % keys.len()]);
        l = new_l;
        r = new_r;
    }

    ((l as u64) << 32) | (r as u64)
}

fn feistel_decrypt(block: u64, keys: &[u32], rounds: usize) -> u64 {
    let mut l = (block >> 32) as u32;
    let mut r = block as u32;

    // Appliquer les rounds en ordre inverse
    for i in (0..rounds).rev() {
        let (new_r, new_l) = feistel_round(r, l, keys[i % keys.len()]);
        l = new_l;
        r = new_r;
    }

    ((l as u64) << 32) | (r as u64)
}

fn xor_blocks(a: &[u8], b: &[u8]) -> Vec<u8> {
    a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect()
}

fn detect_ecb(ciphertext: &[u8], block_size: usize) -> Option<Vec<(usize, usize)>> {
    let blocks: Vec<&[u8]> = ciphertext.chunks(block_size).collect();
    let mut duplicates = Vec::new();

    for i in 0..blocks.len() {
        for j in (i + 1)..blocks.len() {
            if blocks[i] == blocks[j] {
                duplicates.push((i, j));
            }
        }
    }

    if duplicates.is_empty() {
        None
    } else {
        Some(duplicates)
    }
}

fn cbc_bitflip(
    ciphertext: &mut [u8],
    iv: &mut [u8],
    block_size: usize,
    target_byte_pos: usize,
    known_plaintext_byte: u8,
    target_byte: u8,
) {
    // Position du bloc contenant le byte cible
    let target_block = target_byte_pos / block_size;
    let byte_in_block = target_byte_pos % block_size;

    // Modifier le bloc pr√©c√©dent (ou IV si target_block == 0)
    let flip_value = known_plaintext_byte ^ target_byte;

    if target_block == 0 {
        iv[byte_in_block] ^= flip_value;
    } else {
        let prev_block_start = (target_block - 1) * block_size;
        ciphertext[prev_block_start + byte_in_block] ^= flip_value;
    }
}

fn ctr_nonce_reuse_attack(c1: &[u8], c2: &[u8]) -> Vec<u8> {
    // Si c1 = m1 ‚äï keystream et c2 = m2 ‚äï keystream (m√™me nonce)
    // Alors c1 ‚äï c2 = m1 ‚äï m2
    xor_blocks(c1, c2)
}

fn identify_mode(ciphertext: &[u8], block_size: usize, has_iv: bool) -> &'static str {
    // ECB: blocs r√©p√©t√©s possibles
    if detect_ecb(ciphertext, block_size).is_some() {
        return "ECB";
    }

    // CBC: IV pr√©sent, pas de patterns (g√©n√©ralement)
    if has_iv {
        return "CBC";
    }

    // CTR: pas de patterns, peut avoir un nonce visible
    "CTR_or_CBC"
}

#[derive(Deserialize)]
struct Input {
    #[serde(default)]
    implementations: Vec<Implementation>,
    #[serde(default)]
    mode_identification: Vec<ModeIdTask>,
    #[serde(default)]
    attacks: Vec<Attack>,
}

#[derive(Deserialize)]
struct Implementation {
    task: String,
    #[serde(default)]
    block_hex: String,
    #[serde(default)]
    keys: Vec<u32>,
    #[serde(default)]
    rounds: usize,
}

#[derive(Deserialize)]
struct ModeIdTask {
    ciphertext_hex: String,
    #[serde(default)]
    block_size: usize,
    #[serde(default)]
    iv_hex: Option<String>,
}

#[derive(Deserialize)]
struct Attack {
    #[serde(rename = "type")]
    attack_type: String,
    #[serde(default)]
    ciphertext_hex: String,
    #[serde(default)]
    iv_hex: String,
    #[serde(default)]
    target_byte_position: usize,
    #[serde(default)]
    current_plaintext_byte: u8,
    #[serde(default)]
    target_plaintext_byte: u8,
    #[serde(default)]
    ciphertext2_hex: String,
}

pub fn coffre_fort_moderne(input: &str) -> String {
    let data: Input = match serde_json::from_str(input) {
        Ok(d) => d,
        Err(e) => return format!(r#"{{"error":"{}"}}"#, e),
    };

    let mut result = serde_json::Map::new();

    // Implementations
    if !data.implementations.is_empty() {
        let mut impl_results = serde_json::Map::new();
        for imp in &data.implementations {
            if imp.task == "feistel" {
                let block = u64::from_str_radix(&imp.block_hex, 16).unwrap_or(0);
                let encrypted = feistel_encrypt(block, &imp.keys, imp.rounds);
                let decrypted = feistel_decrypt(encrypted, &imp.keys, imp.rounds);
                impl_results.insert("feistel".to_string(), serde_json::json!({
                    "encrypted_hex": format!("{:016X}", encrypted),
                    "decrypted_hex": format!("{:016X}", decrypted),
                    "success": decrypted == block
                }));
            }
        }
        result.insert("implementations".to_string(), serde_json::Value::Object(impl_results));
    }

    // Mode identification
    if !data.mode_identification.is_empty() {
        let mut mode_results = Vec::new();
        for task in &data.mode_identification {
            let ct = hex::decode(&task.ciphertext_hex).unwrap_or_default();
            let block_size = if task.block_size > 0 { task.block_size } else { 16 };
            let has_iv = task.iv_hex.is_some();

            let mode = identify_mode(&ct, block_size, has_iv);
            let evidence = if mode == "ECB" {
                format!("duplicate_blocks: {:?}", detect_ecb(&ct, block_size))
            } else {
                "no_patterns_detected".to_string()
            };

            mode_results.push(serde_json::json!({
                "mode": mode,
                "evidence": evidence
            }));
        }
        result.insert("mode_identifications".to_string(), serde_json::Value::Array(mode_results));
    }

    // Attacks
    if !data.attacks.is_empty() {
        let mut attack_results = Vec::new();
        for attack in &data.attacks {
            match attack.attack_type.as_str() {
                "cbc_bitflip" => {
                    let mut ct = hex::decode(&attack.ciphertext_hex).unwrap_or_default();
                    let mut iv = hex::decode(&attack.iv_hex).unwrap_or_default();
                    cbc_bitflip(
                        &mut ct,
                        &mut iv,
                        16,
                        attack.target_byte_position,
                        attack.current_plaintext_byte,
                        attack.target_plaintext_byte,
                    );
                    attack_results.push(serde_json::json!({
                        "attack": "cbc_bitflip",
                        "modified_ciphertext_hex": hex::encode(&ct),
                        "modified_iv_hex": hex::encode(&iv),
                        "success": true
                    }));
                }
                "ctr_nonce_reuse" => {
                    let c1 = hex::decode(&attack.ciphertext_hex).unwrap_or_default();
                    let c2 = hex::decode(&attack.ciphertext2_hex).unwrap_or_default();
                    let xored = ctr_nonce_reuse_attack(&c1, &c2);
                    attack_results.push(serde_json::json!({
                        "attack": "ctr_nonce_reuse",
                        "m1_xor_m2_hex": hex::encode(&xored),
                        "success": true
                    }));
                }
                _ => {}
            }
        }
        result.insert("attack_results".to_string(), serde_json::Value::Array(attack_results));
    }

    serde_json::to_string(&serde_json::Value::Object(result)).unwrap()
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A: Feistel decrypt avec cl√©s dans le bon ordre
fn feistel_decrypt_mutant_a(block: u64, keys: &[u32], rounds: usize) -> u64 {
    let mut l = (block >> 32) as u32;
    let mut r = block as u32;
    for i in 0..rounds {  // ‚ùå Devrait √™tre (0..rounds).rev()
        let (new_r, new_l) = feistel_round(r, l, keys[i % keys.len()]);
        l = new_l;
        r = new_r;
    }
    ((l as u64) << 32) | (r as u64)
}

// Mutant B: ECB detection sans comparaison de blocs
fn detect_ecb_mutant_b(ct: &[u8], bs: usize) -> bool {
    ct.len() % bs == 0  // ‚ùå V√©rifie juste l'alignement, pas les duplicatas
}

// Mutant C: CBC bitflip au mauvais endroit
fn cbc_bitflip_mutant_c(ct: &mut [u8], pos: usize, flip: u8) {
    ct[pos] ^= flip;  // ‚ùå Modifie le bloc cible au lieu du pr√©c√©dent
    // Le d√©chiffrement donnera des r√©sultats inattendus
}

// Mutant D: CTR nonce-reuse sans XOR
fn ctr_nonce_reuse_mutant_d(c1: &[u8], c2: &[u8]) -> Vec<u8> {
    c1.to_vec()  // ‚ùå Retourne c1 au lieu de c1 ‚äï c2
}

// Mutant E: Feistel round sans XOR
fn feistel_round_mutant_e(l: u32, r: u32, k: u32) -> (u32, u32) {
    (r, feistel_f(r, k))  // ‚ùå MANQUE: l XOR ...
}
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Structure de Feistel** : inversion gratuite gr√¢ce √† la sym√©trie
2. **Mode ECB** : chaque bloc ind√©pendant ‚Üí patterns visibles
3. **Mode CBC** : cha√Ænage avec IV ‚Üí bit-flip possible
4. **Mode CTR** : stream cipher bas√© sur compteur ‚Üí nonce-reuse fatal

### 5.2 LDA

```
FONCTION feistel_encrypt(block, keys, rounds)
D√âBUT
    AFFECTER bits_hauts(block) √Ä L
    AFFECTER bits_bas(block) √Ä R

    POUR i ALLANT DE 0 √Ä rounds MOINS 1 FAIRE
        D√âCLARER temp COMME R
        AFFECTER L XOR F(R, keys[i]) √Ä R
        AFFECTER temp √Ä L
    FIN POUR

    RETOURNER (L << 32) OU R
FIN
```

### 5.3 Visualisation ASCII

**Structure de Feistel**

```
     L‚ÇÄ           R‚ÇÄ
      ‚îÇ            ‚îÇ
      ‚îÇ            ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ            ‚îÇ       ‚îÇ
      ‚îÇ            ‚ñº       ‚îÇ
      ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
      ‚îÇ         ‚îÇ  F  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚î§ K‚ÇÅ
      ‚îÇ         ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò    ‚îÇ
      ‚îÇ            ‚îÇ       ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫XOR‚óÑ‚îÄ‚îÄ‚îò       ‚îÇ
              ‚îÇ            ‚îÇ
              ‚ñº            ‚ñº
             R‚ÇÅ = L‚ÇÄ‚äïF(R‚ÇÄ,K‚ÇÅ)   L‚ÇÅ = R‚ÇÄ

     Apr√®s round: (L‚ÇÅ, R‚ÇÅ) = (R‚ÇÄ, L‚ÇÄ ‚äï F(R‚ÇÄ, K))
```

**ECB vs CBC**

```
ECB (Electronic Codebook):
P‚ÇÅ ‚îÄ‚îÄ‚ñ∫ [E] ‚îÄ‚îÄ‚ñ∫ C‚ÇÅ    M√™me P ‚Üí M√™me C!
P‚ÇÇ ‚îÄ‚îÄ‚ñ∫ [E] ‚îÄ‚îÄ‚ñ∫ C‚ÇÇ    Patterns visibles
P‚ÇÉ ‚îÄ‚îÄ‚ñ∫ [E] ‚îÄ‚îÄ‚ñ∫ C‚ÇÉ

CBC (Cipher Block Chaining):
IV ‚îÄ‚îÄ‚îê
     ‚ñº
P‚ÇÅ ‚îÄ‚ñ∫ XOR ‚îÄ‚ñ∫ [E] ‚îÄ‚îÄ‚ñ∫ C‚ÇÅ ‚îÄ‚îÄ‚îê
              ‚ñ≤           ‚îÇ
              ‚îÇ           ‚ñº
P‚ÇÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ XOR ‚îÄ‚ñ∫ [E] ‚îÄ‚îÄ‚ñ∫ C‚ÇÇ ‚îÄ‚îÄ‚îê
                             ‚îÇ
                             ‚ñº
P‚ÇÉ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ XOR ‚îÄ‚ñ∫ [E] ‚îÄ‚îÄ‚ñ∫ C‚ÇÉ
```

**CBC Bit-Flipping**

```
Pour modifier P‚ÇÇ[i], modifier C‚ÇÅ[i]:

C‚ÇÅ' = C‚ÇÅ ‚äï (P‚ÇÇ[i] ‚äï TARGET)
             ‚Üì
P‚ÇÇ'[i] = D(C‚ÇÇ) ‚äï C‚ÇÅ'[i]
       = P‚ÇÇ[i] ‚äï (P‚ÇÇ[i] ‚äï TARGET)
       = TARGET ‚úì
```

### 5.8 Mn√©motechniques

**üéÆ MEME : "ECB Penguin"**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Image originale    ‚Üí    Image chiffr√©e ECB    ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ      üêß                      üêß                 ‚îÇ
‚îÇ   (visible)              (STILL visible!)       ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  "ECB is so bad, even the penguin can see it"  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**üé¨ MEME : Mr. Robot ‚Äî "Same nonce, same problems"**

```
Elliot: "Ils utilisent CTR avec le m√™me nonce?"

Darlene: "Oui, deux messages."

Elliot: "C'est comme si Sony n'avait jamais hack√© la PS3.
         c1 ‚äï c2 = m1 ‚äï m2. Game over."
```

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| Pi√®ge | Pr√©vention |
|-------|------------|
| Feistel decrypt mauvais ordre | Inverser les cl√©s |
| ECB patterns | Utiliser CBC ou CTR |
| CBC bitflip | Utiliser AEAD (GCM) |
| CTR nonce reuse | Nonce unique par message |

---

## üìù SECTION 7 : QCM

**Q1:** Dans Feistel, pour d√©chiffrer on?
A) Inverse F  B) Applique les rounds en ordre inverse avec m√™mes F ‚úì  C) Change F  D) Utilise autre cl√©

**Q2:** Pourquoi ECB est dangereux?
A) Lent  B) Patterns de plaintext visibles dans ciphertext ‚úì  C) Pas assez de rounds  D) Cl√© trop courte

**Q3:** Dans CBC bitflip, on modifie?
A) Le bloc cible  B) Le bloc pr√©c√©dent ‚úì  C) L'IV seulement  D) La cl√©

**Q4:** CTR nonce-reuse donne acc√®s √†?
A) La cl√©  B) m1 ‚äï m2 ‚úì  C) Le nonce  D) Le plaintext complet

**Q5:** Mode recommand√© pour confidentialit√© + int√©grit√©?
A) ECB  B) CBC  C) CTR  D) GCM (AEAD) ‚úì

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.3-b : coffre_fort_moderne |
| Concepts | Feistel, ECB, CBC, CTR, Attaques |
| Difficult√© | 8/10 |
| XP | 225 / 900 (bonus) |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.1.3-b-coffre_fort_moderne",
    "metadata": {
      "exercise_id": "3.1.3-b",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 225,
      "bonus_tier": "EXPERT",
      "domains": ["Crypto", "Encodage"]
    }
  }
}
```

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
