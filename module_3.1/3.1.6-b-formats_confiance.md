# Exercice 3.1.6-b : formats_confiance

**Module :** 3.1.6 â€” Infrastructure Ã  ClÃ©s Publiques (PKI)

**Concept :** b â€” Formats de certificats et alternatives PKI

**DifficultÃ© :** â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :** complet

**Tiers :** 1 â€” Concept isolÃ©

**Langage :** Python 3.14

**PrÃ©requis :** 3.1.6-a (X.509, chaÃ®ne de confiance)

**Domaines :** Crypto, Encodage

**DurÃ©e estimÃ©e :** 90 min

**XP Base :** 200

**ComplexitÃ© :** T2 O(n) Ã— S2 O(cert_size)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `formats_confiance.py`
**AutorisÃ© :** cryptography, base64
**Interdit :** subprocess (pas d'appels openssl CLI)

### 1.2 Consigne

**ğŸ® "The Imitation Game" â€” DÃ©coder Enigma**

*"Parfois c'est les gens dont personne n'attend rien qui font les choses que personne n'attend."* â€” Alan Turing

Tu es **Alan Turing**, et tu dois dÃ©coder les formats de communication ennemis. Chaque format (PEM, DER, PKCS#12) est comme une variante d'Enigma â€” mÃªme contenu, encodage diffÃ©rent.

**Ta mission :**

1. **Convertir entre formats** : PEM â†” DER â†” PKCS#12
2. **Identifier les types de certificats** : DV, OV, EV
3. **MaÃ®triser les commandes OpenSSL** Ã©quivalentes
4. **Comprendre le Web of Trust** (PGP)
5. **Configurer le Certificate Pinning** (CAA, HPKP legacy)

### 1.3 Prototype

```python
def formats_confiance(input_json: str) -> str:
    """Point d'entrÃ©e principal"""
    pass

# Conversions de format
def pem_to_der(pem_data: str) -> bytes:
    """Convertit PEM en DER"""
    pass

def der_to_pem(der_data: bytes, object_type: str = 'CERTIFICATE') -> str:
    """Convertit DER en PEM"""
    pass

def create_pkcs12(cert_pem: str, key_pem: str, password: str, ca_chain: list = None) -> bytes:
    """CrÃ©e un bundle PKCS#12"""
    pass

def extract_pkcs12(p12_data: bytes, password: str) -> dict:
    """Extrait cert et clÃ© d'un PKCS#12"""
    pass

# Identification
def identify_certificate_type(cert_pem: str) -> dict:
    """Identifie DV, OV ou EV"""
    pass

# Web of Trust
def simulate_web_of_trust(keys: list, question: str) -> dict:
    """Simule la confiance PGP"""
    pass

# Pinning
def generate_pin_hash(cert_pem: str) -> str:
    """GÃ©nÃ¨re un hash pour certificate pinning"""
    pass

def generate_caa_record(domain: str, issuers: list) -> str:
    """GÃ©nÃ¨re un enregistrement DNS CAA"""
    pass
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### HPKP Disaster

HTTP Public Key Pinning (HPKP) a Ã©tÃ© dÃ©prÃ©ciÃ© en 2018. Mal configurÃ©, il pouvait rendre un site dÃ©finitivement inaccessible si les pins ne correspondaient plus. Plusieurs entreprises ont perdu l'accÃ¨s Ã  leurs propres sites.

### PGP Web of Trust

Phil Zimmermann a crÃ©Ã© PGP en 1991. Le modÃ¨le "Web of Trust" Ã©tait rÃ©volutionnaire : pas de CA central, mais une toile de signatures mutuelles. Toujours utilisÃ© pour signer les paquets Linux.

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.3 Solution de rÃ©fÃ©rence

```python
from cryptography import x509
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.backends import default_backend
from cryptography.x509.oid import ExtensionOID
import base64
import json
import hashlib

def pem_to_der(pem_data: str) -> bytes:
    """Convertit PEM en DER."""
    # PEM = Base64(DER) avec headers
    cert = x509.load_pem_x509_certificate(pem_data.encode())
    return cert.public_bytes(serialization.Encoding.DER)


def der_to_pem(der_data: bytes, object_type: str = 'CERTIFICATE') -> str:
    """Convertit DER en PEM."""
    cert = x509.load_der_x509_certificate(der_data)
    return cert.public_bytes(serialization.Encoding.PEM).decode()


def create_pkcs12(cert_pem: str, key_pem: str, password: str, ca_chain: list = None) -> bytes:
    """CrÃ©e un bundle PKCS#12."""
    from cryptography.hazmat.primitives.serialization import pkcs12

    cert = x509.load_pem_x509_certificate(cert_pem.encode())
    key = serialization.load_pem_private_key(key_pem.encode(), password=None)

    cas = None
    if ca_chain:
        cas = [x509.load_pem_x509_certificate(c.encode()) for c in ca_chain]

    return pkcs12.serialize_key_and_certificates(
        name=b"certificate",
        key=key,
        cert=cert,
        cas=cas,
        encryption_algorithm=serialization.BestAvailableEncryption(password.encode())
    )


def extract_pkcs12(p12_data: bytes, password: str) -> dict:
    """Extrait cert et clÃ© d'un PKCS#12."""
    from cryptography.hazmat.primitives.serialization import pkcs12

    key, cert, cas = pkcs12.load_key_and_certificates(p12_data, password.encode())

    result = {
        'certificate_pem': cert.public_bytes(serialization.Encoding.PEM).decode() if cert else None,
        'private_key_pem': key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        ).decode() if key else None,
        'ca_chain': [c.public_bytes(serialization.Encoding.PEM).decode() for c in cas] if cas else []
    }
    return result


def identify_certificate_type(cert_pem: str) -> dict:
    """
    Identifie si un certificat est DV, OV ou EV.

    DV (Domain Validation): Seulement le domaine vÃ©rifiÃ©
    OV (Organization Validation): Organisation vÃ©rifiÃ©e
    EV (Extended Validation): VÃ©rification approfondie, OID spÃ©cifique
    """
    cert = x509.load_pem_x509_certificate(cert_pem.encode())

    # VÃ©rifier la prÃ©sence de champs organisation
    from cryptography.x509.oid import NameOID
    org_attrs = cert.subject.get_attributes_for_oid(NameOID.ORGANIZATION_NAME)
    has_org = len(org_attrs) > 0 and org_attrs[0].value.strip() != ''

    # VÃ©rifier les OID de politique pour EV
    ev_oids = [
        "2.23.140.1.1",  # CA/Browser Forum EV Guidelines
        "2.16.840.1.114412.2.1",  # DigiCert EV
        "2.16.840.1.114028.10.1.2",  # Entrust EV
    ]

    is_ev = False
    try:
        policies = cert.extensions.get_extension_for_oid(ExtensionOID.CERTIFICATE_POLICIES)
        for policy in policies.value:
            if policy.policy_identifier.dotted_string in ev_oids:
                is_ev = True
                break
    except x509.ExtensionNotFound:
        pass

    if is_ev:
        cert_type = "EV"
        evidence = "EV OID found in certificate policies"
    elif has_org:
        cert_type = "OV"
        evidence = f"Organization field present: {org_attrs[0].value}"
    else:
        cert_type = "DV"
        evidence = "No organization field, domain-only validation"

    return {
        'type': cert_type,
        'evidence': evidence,
        'organization': org_attrs[0].value if has_org else None
    }


def simulate_web_of_trust(keys: list, question: str) -> dict:
    """
    Simule le modÃ¨le Web of Trust de PGP.

    Niveaux de confiance:
    - ultimate: Confiance absolue (gÃ©nÃ©ralement soi-mÃªme)
    - full: Confiance complÃ¨te (1 signature suffit)
    - marginal: Confiance partielle (3 signatures requises)
    - none: Pas de confiance
    """
    # Construire le graphe de confiance
    trust_graph = {}
    for key in keys:
        trust_graph[key['email']] = {
            'trust_level': key.get('trust_level', 'none'),
            'signed_by': key.get('signed_by', [])
        }

    # Parser la question (ex: "Can alice verify message from charlie?")
    parts = question.lower().split()
    if 'verify' in question and 'from' in question:
        verifier = parts[parts.index('can') + 1] if 'can' in parts else None
        target = parts[-1].rstrip('?')

        # Trouver le chemin de confiance
        path = find_trust_path(trust_graph, f"{verifier}@corp.com", f"{target}@corp.com")

        can_verify = path is not None
        explanation = f"Trust path: {' â†’ '.join(path)}" if path else "No valid trust path"

        return {
            'can_verify': can_verify,
            'trust_path': path,
            'explanation': explanation
        }

    return {'error': 'Could not parse question'}


def find_trust_path(graph, from_email, to_email, visited=None):
    """Trouve un chemin de confiance dans le Web of Trust."""
    if visited is None:
        visited = set()

    if from_email in visited:
        return None

    visited.add(from_email)

    if from_email not in graph:
        return None

    from_key = graph[from_email]

    # VÃ©rifier si from peut valider to
    if to_email in graph:
        to_key = graph[to_email]

        # Compter les signatures de confiance
        full_count = 0
        marginal_count = 0

        for signer in to_key.get('signed_by', []):
            signer_email = f"{signer}@corp.com"
            if signer_email in graph:
                signer_trust = graph[signer_email]['trust_level']
                if signer_trust in ['ultimate', 'full']:
                    full_count += 1
                elif signer_trust == 'marginal':
                    marginal_count += 1

        # RÃ¨gle PGP: 1 full OU 3 marginals
        if full_count >= 1 or marginal_count >= 3:
            return [from_email, to_email]

    # Chercher un chemin via d'autres clÃ©s
    for signer in graph.get(to_email, {}).get('signed_by', []):
        signer_email = f"{signer}@corp.com"
        if signer_email not in visited:
            path = find_trust_path(graph, from_email, signer_email, visited)
            if path:
                return path + [to_email]

    return None


def generate_pin_hash(cert_pem: str) -> str:
    """
    GÃ©nÃ¨re un hash SHA-256 de la clÃ© publique pour certificate pinning.

    Format: base64(sha256(SubjectPublicKeyInfo))
    """
    cert = x509.load_pem_x509_certificate(cert_pem.encode())
    spki = cert.public_key().public_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    pin_hash = hashlib.sha256(spki).digest()
    return base64.b64encode(pin_hash).decode()


def generate_caa_record(domain: str, issuers: list) -> str:
    """
    GÃ©nÃ¨re un enregistrement DNS CAA.

    CAA restreint quels CAs peuvent Ã©mettre des certificats pour le domaine.
    """
    records = []
    for issuer in issuers:
        records.append(f'{domain}. CAA 0 issue "{issuer}"')

    # Ajouter iodef pour les notifications
    records.append(f'{domain}. CAA 0 iodef "mailto:security@{domain}"')

    return '\n'.join(records)


def formats_confiance(input_json: str) -> str:
    """Point d'entrÃ©e principal."""
    data = json.loads(input_json)
    results = {}

    # Conversions de format
    if 'format_conversion' in data:
        results['conversions'] = []
        for conv in data['format_conversion']:
            try:
                if conv['input_format'] == 'pem' and conv['output_format'] == 'der':
                    der = pem_to_der(conv['input_data'])
                    results['conversions'].append({
                        'output_format': 'der',
                        'output_base64': base64.b64encode(der).decode()
                    })
                elif conv['input_format'] == 'der' and conv['output_format'] == 'pem':
                    der = base64.b64decode(conv['input_data'])
                    pem = der_to_pem(der)
                    results['conversions'].append({
                        'output_format': 'pem',
                        'output': pem
                    })
            except Exception as e:
                results['conversions'].append({'error': str(e)})

    # Identification de type
    if 'certificate_type_analysis' in data:
        results['certificate_types'] = []
        for item in data['certificate_type_analysis']:
            cert_type = identify_certificate_type(item['cert_pem'])
            results['certificate_types'].append(cert_type)

    # Web of Trust
    if 'pgp_web_of_trust' in data:
        wot = data['pgp_web_of_trust']
        results['web_of_trust'] = simulate_web_of_trust(wot['keys'], wot['question'])

    # Pinning
    if 'pinning_configuration' in data:
        pin_config = data['pinning_configuration']
        results['pinning'] = {
            'pin_hashes': [],
            'caa_record': generate_caa_record(pin_config['domain'], pin_config.get('issuers', []))
        }
        for cert in pin_config.get('certificates', []):
            pin_hash = generate_pin_hash(cert)
            results['pinning']['pin_hashes'].append({
                'type': 'sha256',
                'hash': pin_hash
            })

    return json.dumps(results, indent=2)
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
FORMATS DE CERTIFICATS
======================

PEM (Privacy Enhanced Mail)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-----BEGIN CERTIFICATE-----
MIIDdzCCAl+gAwIBAgIJAM...  â† Base64(DER)
...
-----END CERTIFICATE-----

DER (Distinguished Encoding Rules)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Binaire ASN.1 (non lisible)
30 82 03 77 30 82 02 5f...

PKCS#12 / PFX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Protected Container          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     Private Key (encrypted)   â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚       Certificate             â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚     CA Chain (optional)       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         ğŸ”’ Password protected       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


WEB OF TRUST (PGP)
==================

         Alice (Ultimate)
              â”‚
              â”‚ signs
              â–¼
         Bob (Full Trust)
        /           \
   signs             signs
      /                 \
     â–¼                   â–¼
  Charlie            Diana
  (Marginal)         (Marginal)
     â”‚                  â”‚
     â””â”€â”€â”€â”€â”€ both â”€â”€â”€â”€â”€â”€â”˜
            sign
              â”‚
              â–¼
           Eve
        (Untrusted)

RÃ¨gle: Eve est vÃ©rifiable si signÃ©e par:
- 1 clÃ© "Full" OU
- 3 clÃ©s "Marginal"

Eve a 2 signatures marginales â†’ âŒ Non vÃ©rifiable
```

---

## ğŸ“ SECTION 7 : QCM

**Q1:** Quelle est la diffÃ©rence entre PEM et DER?
A) Algorithme diffÃ©rent  B) PEM = Base64(DER) + headers âœ“  C) Taille  D) SÃ©curitÃ©

**Q2:** Que contient un fichier PKCS#12?
A) Seulement le certificat  B) Cert + clÃ© privÃ©e + chaÃ®ne CA âœ“  C) Seulement la clÃ©  D) Hash

**Q3:** Dans PGP Web of Trust, combien de signatures marginales valident une clÃ©?
A) 1  B) 2  C) 3 âœ“  D) 5

**Q4:** Ã€ quoi sert un enregistrement DNS CAA?
A) RÃ©solution IP  B) Restreindre les CAs autorisÃ©s âœ“  C) AccÃ©lÃ©rer TLS  D) Backup DNS

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| Exercice | 3.1.6-b : formats_confiance |
| Concepts | PEM, DER, PKCS#12, Web of Trust, CAA |
| DifficultÃ© | 7/10 |
| XP | 200 |

---

*Exercice gÃ©nÃ©rÃ© par HACKBRAIN v5.5.2*
