# Exercice 3.1.4-c : courbes_futur

**Module :** 3.1.4 ‚Äî Chiffrement Asym√©trique

**Concept :** c ‚Äî Cryptographie sur courbes elliptiques et post-quantique

**Difficult√© :** ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ (10/10)

**Type :** complet

**Tiers :** 1 ‚Äî Concept isol√©

**Langage :** Rust Edition 2024

**Pr√©requis :** 3.1.2-c, 3.1.4-a, 3.1.4-b (groupes alg√©briques, RSA, DH)

**Domaines :** Crypto, MD, AL

**Dur√©e estim√©e :** 150 min

**XP Base :** 350

**Complexit√© :** T4 O(k¬≥) √ó S2 O(k)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `courbes_futur.rs`
**Autoris√© :** std, rand, sha2
**Interdit :** p256, curve25519-dalek, ed25519-dalek, ring, pqcrypto

### 1.2 Consigne

**üéÆ "Ghost in the Shell" ‚Äî Projet 2501 vs Puppet Master Quantique**

*"Le r√©seau a √©volu√© au-del√† de nos pr√©dictions. Les Tachikomas utilisent maintenant des courbes elliptiques pour leurs communications..."* ‚Äî Major Kusanagi

Tu es **Major Motoko Kusanagi**, et le **Puppet Master quantique** menace toute la cryptographie actuelle. Les **Tachikomas** ont besoin d'une mise √† niveau de leurs protocoles de communication.

*"Les courbes elliptiques offrent la m√™me s√©curit√© que RSA avec des cl√©s 10x plus petites. Mais face √† un ordinateur quantique, m√™me les courbes tombent. Il est temps de penser post-quantique."*

**Ta mission :**

1. **Impl√©menter ECDH** sur P-256 (√©change de cl√©s sur courbes)
2. **Impl√©menter ECDSA** avec attention aux biais de nonce
3. **Comprendre Ed25519** (EdDSA, signatures d√©terministes)
4. **√âvaluer les menaces quantiques** (algorithme de Shor)
5. **Analyser les candidats post-quantiques** (Kyber, Dilithium)
6. **D√©tecter les vuln√©rabilit√©s side-channel** dans les impl√©mentations

### 1.3 Prototype

```rust
pub fn courbes_futur(input: &str) -> String

// Point sur courbe elliptique
#[derive(Clone, Debug, PartialEq)]
struct ECPoint {
    x: BigInt,
    y: BigInt,
    infinity: bool,
}

// Param√®tres de courbe (forme de Weierstrass courte: y¬≤ = x¬≥ + ax + b)
struct ECParams {
    p: BigInt,      // Module premier
    a: BigInt,      // Coefficient a
    b: BigInt,      // Coefficient b
    g: ECPoint,     // G√©n√©rateur
    n: BigInt,      // Ordre du groupe
    name: String,
}

// Op√©rations de base
fn ec_add(p1: &ECPoint, p2: &ECPoint, params: &ECParams) -> ECPoint
fn ec_double(p: &ECPoint, params: &ECParams) -> ECPoint
fn ec_scalar_mul(k: &BigInt, p: &ECPoint, params: &ECParams) -> ECPoint
fn ec_is_on_curve(p: &ECPoint, params: &ECParams) -> bool

// ECDH
fn ecdh_generate_keypair(params: &ECParams) -> (BigInt, ECPoint)
fn ecdh_compute_shared_secret(private: &BigInt, other_public: &ECPoint, params: &ECParams) -> ECPoint

// ECDSA
fn ecdsa_sign(message: &[u8], private_key: &BigInt, params: &ECParams, k: &BigInt) -> (BigInt, BigInt)
fn ecdsa_verify(message: &[u8], signature: &(BigInt, BigInt), public_key: &ECPoint, params: &ECParams) -> bool

// Validation et s√©curit√©
fn validate_ec_point(p: &ECPoint, params: &ECParams) -> Result<(), &'static str>
fn detect_timing_vulnerability(code: &str) -> Vec<String>

// √âvaluation post-quantique
fn evaluate_quantum_resistance(algorithm: &str) -> QuantumSecurityReport
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Invalid Curve Attack (2015)

Des chercheurs ont montr√© que si on n'invalide pas les points re√ßus, un attaquant peut envoyer des points sur une courbe diff√©rente (plus faible) et r√©cup√©rer la cl√© priv√©e morceau par morceau via CRT.

### Lattice Attacks sur ECDSA

En 2013, des chercheurs ont r√©cup√©r√© les cl√©s priv√©es de Bitcoin depuis des signatures avec des biais minuscules dans les nonces (quelques bits de biais suffisent avec ~100 signatures).

### 2.5 DANS LA VRAIE VIE

- **Blockchain Developer** : ECDSA (secp256k1) pour Bitcoin/Ethereum
- **Security Architect** : Transition vers post-quantique (NIST PQC)
- **Embedded Security** : Ed25519 pour IoT (rapide, petit)

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ cargo run --release
P-256 curve loaded ‚úì
ECDH key exchange: shared secrets match ‚úì
ECDSA sign/verify: OK ‚úì
Invalid curve attack detected and blocked ‚úì
Ed25519 deterministic signature: OK ‚úì
Quantum security evaluation complete ‚úì
Side-channel vulnerability detected in scalar_mul ‚úì
Tous les tests passent!
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence (extraits)

```rust
use num_bigint::BigInt;
use num_traits::{Zero, One};

// Param√®tres P-256 (NIST)
fn get_p256_params() -> ECParams {
    ECParams {
        p: BigInt::parse_bytes(
            b"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
            16
        ).unwrap(),
        a: BigInt::parse_bytes(
            b"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
            16
        ).unwrap(),
        b: BigInt::parse_bytes(
            b"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
            16
        ).unwrap(),
        g: ECPoint {
            x: BigInt::parse_bytes(
                b"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
                16
            ).unwrap(),
            y: BigInt::parse_bytes(
                b"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5",
                16
            ).unwrap(),
            infinity: false,
        },
        n: BigInt::parse_bytes(
            b"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
            16
        ).unwrap(),
        name: "P-256".to_string(),
    }
}

fn mod_positive(a: &BigInt, m: &BigInt) -> BigInt {
    let r = a % m;
    if r < BigInt::zero() { r + m } else { r }
}

fn mod_inverse(a: &BigInt, m: &BigInt) -> Option<BigInt> {
    let (mut old_r, mut r) = (m.clone(), mod_positive(a, m));
    let (mut old_s, mut s) = (BigInt::zero(), BigInt::one());

    while !r.is_zero() {
        let quotient = &old_r / &r;
        let temp = r.clone();
        r = &old_r - &quotient * &r;
        old_r = temp;
        let temp = s.clone();
        s = &old_s - &quotient * &s;
        old_s = temp;
    }

    if old_r > BigInt::one() { return None; }
    Some(mod_positive(&old_s, m))
}

// Addition de deux points sur la courbe
fn ec_add(p1: &ECPoint, p2: &ECPoint, params: &ECParams) -> ECPoint {
    // O + P = P
    if p1.infinity { return p2.clone(); }
    if p2.infinity { return p1.clone(); }

    // P + (-P) = O
    if p1.x == p2.x && (&p1.y + &p2.y) % &params.p == BigInt::zero() {
        return ECPoint { x: BigInt::zero(), y: BigInt::zero(), infinity: true };
    }

    // P + P = 2P (doubling)
    if p1 == p2 {
        return ec_double(p1, params);
    }

    // Calcul de la pente Œª = (y2 - y1) / (x2 - x1) mod p
    let dx = mod_positive(&(&p2.x - &p1.x), &params.p);
    let dy = mod_positive(&(&p2.y - &p1.y), &params.p);
    let lambda = (&dy * &mod_inverse(&dx, &params.p).unwrap()) % &params.p;

    // x3 = Œª¬≤ - x1 - x2 mod p
    let x3 = mod_positive(&(&lambda * &lambda - &p1.x - &p2.x), &params.p);

    // y3 = Œª(x1 - x3) - y1 mod p
    let y3 = mod_positive(&(&lambda * (&p1.x - &x3) - &p1.y), &params.p);

    ECPoint { x: x3, y: y3, infinity: false }
}

// Doublement d'un point
fn ec_double(p: &ECPoint, params: &ECParams) -> ECPoint {
    if p.infinity || p.y.is_zero() {
        return ECPoint { x: BigInt::zero(), y: BigInt::zero(), infinity: true };
    }

    // Œª = (3x¬≤ + a) / (2y) mod p
    let numerator = mod_positive(
        &(BigInt::from(3) * &p.x * &p.x + &params.a),
        &params.p
    );
    let denominator = mod_positive(&(BigInt::from(2) * &p.y), &params.p);
    let lambda = (&numerator * &mod_inverse(&denominator, &params.p).unwrap()) % &params.p;

    // x3 = Œª¬≤ - 2x mod p
    let x3 = mod_positive(&(&lambda * &lambda - BigInt::from(2) * &p.x), &params.p);

    // y3 = Œª(x - x3) - y mod p
    let y3 = mod_positive(&(&lambda * (&p.x - &x3) - &p.y), &params.p);

    ECPoint { x: x3, y: y3, infinity: false }
}

// Multiplication scalaire (double-and-add)
fn ec_scalar_mul(k: &BigInt, p: &ECPoint, params: &ECParams) -> ECPoint {
    if k.is_zero() || p.infinity {
        return ECPoint { x: BigInt::zero(), y: BigInt::zero(), infinity: true };
    }

    let mut result = ECPoint { x: BigInt::zero(), y: BigInt::zero(), infinity: true };
    let mut temp = p.clone();
    let mut k = k.clone();

    // Double-and-add
    while k > BigInt::zero() {
        if &k % 2 == BigInt::one() {
            result = ec_add(&result, &temp, params);
        }
        temp = ec_double(&temp, params);
        k >>= 1;
    }

    result
}

// V√©rifier qu'un point est sur la courbe
fn ec_is_on_curve(p: &ECPoint, params: &ECParams) -> bool {
    if p.infinity { return true; }

    // y¬≤ = x¬≥ + ax + b mod p
    let lhs = mod_positive(&(&p.y * &p.y), &params.p);
    let rhs = mod_positive(
        &(&p.x * &p.x * &p.x + &params.a * &p.x + &params.b),
        &params.p
    );
    lhs == rhs
}

// Validation compl√®te d'un point
fn validate_ec_point(p: &ECPoint, params: &ECParams) -> Result<(), &'static str> {
    // Point √† l'infini ok
    if p.infinity { return Ok(()); }

    // 1. Coordonn√©es dans le bon intervalle
    if p.x < BigInt::zero() || p.x >= params.p {
        return Err("x hors intervalle [0, p)");
    }
    if p.y < BigInt::zero() || p.y >= params.p {
        return Err("y hors intervalle [0, p)");
    }

    // 2. Point sur la courbe
    if !ec_is_on_curve(p, params) {
        return Err("Point non sur la courbe - Invalid Curve Attack!");
    }

    // 3. Point dans le bon sous-groupe (n*P = O)
    let check = ec_scalar_mul(&params.n, p, params);
    if !check.infinity {
        return Err("Point pas dans le sous-groupe d'ordre n");
    }

    Ok(())
}

// ECDH
fn ecdh_generate_keypair(params: &ECParams) -> (BigInt, ECPoint) {
    let mut rng = rand::thread_rng();
    let private = rng.gen_bigint_range(&BigInt::one(), &params.n);
    let public = ec_scalar_mul(&private, &params.g, params);
    (private, public)
}

fn ecdh_compute_shared_secret(private: &BigInt, other_public: &ECPoint, params: &ECParams) -> ECPoint {
    ec_scalar_mul(private, other_public, params)
}

// ECDSA
fn ecdsa_sign(message: &[u8], d: &BigInt, params: &ECParams, k: &BigInt) -> (BigInt, BigInt) {
    use sha2::{Sha256, Digest};
    let hash = Sha256::digest(message);
    let z = BigInt::from_bytes_be(num_bigint::Sign::Plus, &hash) % &params.n;

    // R = k*G
    let r_point = ec_scalar_mul(k, &params.g, params);
    let r = &r_point.x % &params.n;

    // s = k^(-1) * (z + r*d) mod n
    let k_inv = mod_inverse(k, &params.n).unwrap();
    let s = mod_positive(&(&k_inv * (&z + &r * d)), &params.n);

    (r, s)
}

fn ecdsa_verify(message: &[u8], sig: &(BigInt, BigInt), q: &ECPoint, params: &ECParams) -> bool {
    let (r, s) = sig;

    // V√©rifier 0 < r < n et 0 < s < n
    if r <= &BigInt::zero() || r >= &params.n { return false; }
    if s <= &BigInt::zero() || s >= &params.n { return false; }

    use sha2::{Sha256, Digest};
    let hash = Sha256::digest(message);
    let z = BigInt::from_bytes_be(num_bigint::Sign::Plus, &hash) % &params.n;

    let s_inv = mod_inverse(s, &params.n).unwrap();
    let u1 = mod_positive(&(&z * &s_inv), &params.n);
    let u2 = mod_positive(&(r * &s_inv), &params.n);

    // R' = u1*G + u2*Q
    let point1 = ec_scalar_mul(&u1, &params.g, params);
    let point2 = ec_scalar_mul(&u2, q, params);
    let r_prime = ec_add(&point1, &point2, params);

    if r_prime.infinity { return false; }

    // V√©rifier r' == r mod n
    &r_prime.x % &params.n == *r
}

// √âvaluation r√©sistance quantique
struct QuantumSecurityReport {
    algorithm: String,
    classical_security_bits: u32,
    quantum_security_bits: u32,
    vulnerable_to_shor: bool,
    recommendation: String,
}

fn evaluate_quantum_resistance(algorithm: &str) -> QuantumSecurityReport {
    match algorithm {
        "RSA-2048" => QuantumSecurityReport {
            algorithm: "RSA-2048".to_string(),
            classical_security_bits: 112,
            quantum_security_bits: 0,
            vulnerable_to_shor: true,
            recommendation: "Migrate to Kyber or hybrid".to_string(),
        },
        "ECDSA-P256" => QuantumSecurityReport {
            algorithm: "ECDSA-P256".to_string(),
            classical_security_bits: 128,
            quantum_security_bits: 0,
            vulnerable_to_shor: true,
            recommendation: "Migrate to Dilithium or hybrid Ed25519+Dilithium".to_string(),
        },
        "Kyber-768" => QuantumSecurityReport {
            algorithm: "Kyber-768".to_string(),
            classical_security_bits: 192,
            quantum_security_bits: 128,
            vulnerable_to_shor: false,
            recommendation: "Recommended for key encapsulation".to_string(),
        },
        "Dilithium-3" => QuantumSecurityReport {
            algorithm: "Dilithium-3".to_string(),
            classical_security_bits: 192,
            quantum_security_bits: 128,
            vulnerable_to_shor: false,
            recommendation: "Recommended for signatures".to_string(),
        },
        _ => QuantumSecurityReport {
            algorithm: algorithm.to_string(),
            classical_security_bits: 0,
            quantum_security_bits: 0,
            vulnerable_to_shor: true,
            recommendation: "Unknown algorithm".to_string(),
        },
    }
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A (Safety): Pas de validation du point re√ßu
fn ecdh_compute_shared_secret_mutant_a(private: &BigInt, other_public: &ECPoint, params: &ECParams) -> ECPoint {
    // ‚ùå Pas de validation! Vuln√©rable au Invalid Curve Attack
    ec_scalar_mul(private, other_public, params)
}
// Impact: Attaquant envoie point sur courbe faible ‚Üí r√©cup√®re cl√© priv√©e par CRT

// Mutant B (Boundary): Addition sans cas sp√©cial P + (-P)
fn ec_add_mutant_b(p1: &ECPoint, p2: &ECPoint, params: &ECParams) -> ECPoint {
    if p1.infinity { return p2.clone(); }
    if p2.infinity { return p1.clone(); }
    // ‚ùå Manque: if p1.x == p2.x && (p1.y + p2.y) % p == 0 ‚Üí return O
    let dx = mod_positive(&(&p2.x - &p1.x), &params.p);
    // Division par z√©ro si p1 == -p2!
    let lambda = ...;
    ...
}

// Mutant C (Logic): Scalar mul non constant-time
fn ec_scalar_mul_mutant_c(k: &BigInt, p: &ECPoint, params: &ECParams) -> ECPoint {
    let mut result = ECPoint::infinity();
    let mut temp = p.clone();
    let mut k = k.clone();

    while k > BigInt::zero() {
        if &k % 2 == BigInt::one() {
            result = ec_add(&result, &temp, params);  // ‚ùå Branch visible!
        }
        // Attaquant mesure le temps ‚Üí r√©cup√®re bits de k
        temp = ec_double(&temp, params);
        k >>= 1;
    }
    result
}

// Mutant D (Resource): ECDSA avec k biais√©
fn ecdsa_sign_mutant_d(msg: &[u8], d: &BigInt, params: &ECParams) -> (BigInt, BigInt) {
    let k = BigInt::from(std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos() as u64);
    // ‚ùå k d√©riv√© du temps! Lattice attack possible
    ecdsa_sign_internal(msg, d, params, &k)
}

// Mutant E (Return): V√©rification ECDSA sans bornes
fn ecdsa_verify_mutant_e(msg: &[u8], sig: &(BigInt, BigInt), q: &ECPoint, params: &ECParams) -> bool {
    let (r, s) = sig;
    // ‚ùå Pas de v√©rification 0 < r < n, 0 < s < n
    // r = 0 ou s = 0 pourrait passer incorrectement
    ...
}
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

- **Courbes elliptiques** : Structure de groupe sur une courbe
- **ECDH/ECDSA** : Analogues ECC de DH/DSA
- **Ed25519** : Signatures d√©terministes s√©curis√©es
- **Menace quantique** : Algorithme de Shor et migration PQC
- **Side-channels** : Timing attacks sur scalar multiplication

### 5.2 LDA ‚Äî Traduction litt√©rale

```
FONCTION ec_add QUI RETOURNE UN POINT ET PREND EN PARAM√àTRES p1 ET p2 QUI SONT DES POINTS ET params QUI EST UN ENSEMBLE DE PARAM√àTRES
D√âBUT FONCTION
    SI p1 EST LE POINT √Ä L'INFINI ALORS
        RETOURNER p2
    FIN SI
    SI p2 EST LE POINT √Ä L'INFINI ALORS
        RETOURNER p1
    FIN SI
    SI p1.x EST √âGAL √Ä p2.x ET p1.y PLUS p2.y MODULO p EST √âGAL √Ä 0 ALORS
        RETOURNER LE POINT √Ä L'INFINI
    FIN SI

    D√âCLARER lambda COMME (p2.y MOINS p1.y) DIVIS√â PAR (p2.x MOINS p1.x) MODULO p
    D√âCLARER x3 COMME lambda AU CARR√â MOINS p1.x MOINS p2.x MODULO p
    D√âCLARER y3 COMME lambda MULTIPLI√â PAR (p1.x MOINS x3) MOINS p1.y MODULO p

    RETOURNER LE POINT (x3, y3)
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
COURBE ELLIPTIQUE y¬≤ = x¬≥ + ax + b
======================================

           y ‚ñ≤
             ‚îÇ          .  .
             ‚îÇ       .        .
             ‚îÇ     .            .
             ‚îÇ    .              .
         ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚óèP‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ x
             ‚îÇ    ‚îÇ.            .‚îÇ
             ‚îÇ    ‚îÇ  .        .  ‚îÇ
             ‚îÇ    ‚îÇ    .  .      ‚îÇ
             ‚îÇ    ‚ñº              ‚îÇ
             ‚îÇ   -P              ‚îÇ
             ‚îÇ                   ‚îÇ


ADDITION DE POINTS P + Q = R
============================

           y ‚ñ≤
             ‚îÇ        P
             ‚îÇ       ‚óè
             ‚îÇ      /‚îÇ\.
             ‚îÇ     / ‚îÇ  \
             ‚îÇ    /  ‚îÇ   \ Q
             ‚îÇ   /   ‚îÇ    ‚óè
         ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ/‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ x
             ‚îÇ /     ‚îÇ      \
             ‚îÇ/      ‚îÇ       \
             ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè
            -R       ‚îÇ         R'
             ‚îÇ       ‚îÇ
             ‚ñº       ‚ñº

La ligne passant par P et Q intersecte
la courbe en R'. On r√©fl√©chit R' par
rapport √† l'axe x pour obtenir R = P + Q.


S√âCURIT√â CLASSIQUE vs QUANTIQUE
===============================

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ALGORITHME DE SHOR                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ   Probl√®mes "difficiles" classiques:                     ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ   ‚îÇ Factorisation    ‚îÇ  ‚îÇ Log Discret      ‚îÇ            ‚îÇ
‚îÇ   ‚îÇ n = p √ó q        ‚îÇ  ‚îÇ g^x = h mod p    ‚îÇ            ‚îÇ
‚îÇ   ‚îÇ ‚Üí RSA            ‚îÇ  ‚îÇ ‚Üí DH/DSA/ECDSA   ‚îÇ            ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ            ‚îÇ                     ‚îÇ                       ‚îÇ
‚îÇ            ‚ñº Shor               ‚ñº Shor                  ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ   ‚îÇ      R√âSOLU EN TEMPS POLYNOMIAL        ‚îÇ            ‚îÇ
‚îÇ   ‚îÇ      SUR ORDINATEUR QUANTIQUE          ‚îÇ            ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ   Post-Quantique (r√©sistant √† Shor):                    ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ   ‚îÇ   Lattices   ‚îÇ ‚îÇ  Hash-based  ‚îÇ ‚îÇ Code-based   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ  Kyber       ‚îÇ ‚îÇ  SPHINCS+    ‚îÇ ‚îÇ McEliece     ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ  Dilithium   ‚îÇ ‚îÇ              ‚îÇ ‚îÇ              ‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


TIMING ATTACK SUR SCALAR MULTIPLICATION
=======================================

    Bit de k:    1    0    1    1    0    1
                 ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ
                 ‚ñº    ‚ñº    ‚ñº    ‚ñº    ‚ñº    ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ADD:      ‚îÇ +P ‚îÇ    ‚îÇ    ‚îÇ ‚îÇ +P ‚îÇ    ‚îÇ +P ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    DOUBLE:   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ 2√ó ‚îÇ ‚îÇ 2√ó ‚îÇ ‚îÇ 2√ó ‚îÇ ‚îÇ 2√ó ‚îÇ ‚îÇ 2√ó ‚îÇ ‚îÇ 2√ó ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    Temps:    ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà
                ‚ñ≤
                ‚îÇ
    L'attaquant mesure: ADD prend plus de temps
    ‚Üí R√©v√®le quels bits de k sont 1!

    SOLUTION: Montgomery Ladder (constant-time)
```

### 5.5 Cours Complet

#### Courbes Elliptiques

Une courbe elliptique sur un corps fini Fp est l'ensemble des points (x, y) satisfaisant:

y¬≤ = x¬≥ + ax + b (mod p)

Plus le "point √† l'infini" O qui sert d'√©l√©ment neutre.

**Loi de groupe** : On peut "additionner" deux points g√©om√©triquement.

#### Avantages par rapport √† RSA/DH classique

| Algorithme | Taille cl√© pour 128 bits de s√©curit√© |
|------------|--------------------------------------|
| RSA | 3072 bits |
| DH | 3072 bits |
| ECDH/ECDSA | 256 bits |

10x plus petit = plus rapide, moins de bande passante.

#### Ed25519 vs ECDSA

| Aspect | ECDSA | Ed25519 |
|--------|-------|---------|
| Courbe | secp256k1, P-256 | Curve25519 |
| Nonce | Al√©atoire (dangereux) | D√©terministe (hash) |
| Mall√©abilit√© | Oui (s et -s valides) | Non |
| Performance | Moyen | Rapide |

Ed25519 d√©rive le nonce de fa√ßon d√©terministe: k = H(private || message), √©liminant le risque de r√©utilisation.

#### Menace Quantique

L'algorithme de Shor r√©sout la factorisation et le DLP en temps polynomial sur un ordinateur quantique suffisamment grand.

**Candidats post-quantiques NIST** :
- **Kyber** (lattices) : √âchange de cl√©s
- **Dilithium** (lattices) : Signatures
- **SPHINCS+** (hash) : Signatures (conservateur)

### 5.8 Mn√©motechniques

**üéÆ MEME : "Ghost in the Shell: Invalid Curve Attack"**

Comme le Puppet Master qui usurpe les identit√©s en envoyant de faux signaux neuraux, un attaquant envoie des points sur une courbe invalide pour usurper ta cl√© priv√©e.

```rust
fn receive_public_key(point: &ECPoint, params: &ECParams) -> Result<ECPoint, &'static str> {
    // "Your shell is mine!" - Puppet Master
    // Pas si on valide!
    validate_ec_point(point, params)?;
    Ok(point.clone())
}
```

---

**ü§ñ MEME : "Tachikoma - Constant Time"**

Les Tachikomas ont une IA qui apprend. Un attaquant qui observe leurs temps de r√©ponse pourrait deviner leurs secrets. Solution: tous les calculs prennent le m√™me temps.

```rust
// Tachikoma: "Nous avons tous le m√™me timing!"
fn ec_scalar_mul_constant_time(k: &BigInt, p: &ECPoint, params: &ECParams) -> ECPoint {
    let mut r0 = ECPoint::infinity();
    let mut r1 = p.clone();
    for bit in k.bits().rev() {
        if bit {
            r0 = ec_add(&r0, &r1, params);
            r1 = ec_double(&r1, params);
        } else {
            r1 = ec_add(&r0, &r1, params);
            r0 = ec_double(&r0, params);
        }
        // M√™me nombre d'op√©rations quel que soit le bit!
    }
    r0
}
```

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | D√©tection | Correction |
|---|-------|-----------|------------|
| 1 | Invalid curve attack | Point hors courbe | Validation compl√®te |
| 2 | Timing attack | Mesure de temps | Montgomery ladder |
| 3 | Nonce ECDSA biais√© | Signatures corr√©l√©es | RFC 6979 d√©terministe |
| 4 | Point non dans sous-groupe | n*P ‚â† O | V√©rification ordre |
| 5 | Shor (quantique) | Ordinateur quantique | Migrer vers PQC |

---

## üìù SECTION 7 : QCM

**Q1:** Pourquoi ECC est plus efficace que RSA?
A) Plus vieux  B) Probl√®me ECDLP plus dur par bit ‚úì  C) Plus simple  D) Standard gouvernemental

**Q2:** Comment Ed25519 √©vite le probl√®me du nonce r√©utilis√©?
A) Nonce al√©atoire plus grand  B) Nonce d√©terministe k = H(private||msg) ‚úì  C) Pas de nonce  D) Double signature

**Q3:** Qu'est-ce que l'Invalid Curve Attack?
A) Courbe mal dessin√©e  B) Point sur courbe diff√©rente ‚Üí fuite cl√© ‚úì  C) Courbe trop petite  D) Courbe non standard

**Q4:** Quel algorithme casse ECDSA sur ordinateur quantique?
A) Grover  B) Shor ‚úì  C) BKZ  D) Baby-step Giant-step

**Q5:** Kyber est un candidat post-quantique pour:
A) Signatures  B) Hachage  C) √âchange de cl√©s ‚úì  D) Chiffrement par blocs

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.4-c : courbes_futur |
| Concepts | ECDH, ECDSA, Ed25519, PQC, side-channels |
| Difficult√© | 10/10 |
| XP | 350 |

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
