# Exercice 3.1.3-c : bouclier_authentifie

**Module :** 3.1.3 â€” Chiffrement SymÃ©trique
**Concept :** c â€” AEAD, Padding et DÃ©rivation de ClÃ©s
**DifficultÃ© :** â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)
**Type :** complet
**Tiers :** 1 â€” Concept isolÃ©
**Langage :** Rust Edition 2024
**PrÃ©requis :** 3.1.3-a, 3.1.3-b
**Domaines :** Crypto
**DurÃ©e estimÃ©e :** 90 min
**XP Base :** 225
**ComplexitÃ© :** T2 O(n) Ã— S1 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `bouclier_authentifie.rs`
**AutorisÃ© :** std Rust, rand
**Interdit :** aes-gcm, chacha20poly1305, ring

### 1.2 Consigne

**ğŸ® "Ghost in the Shell" â€” Le Bouclier Parfait**

*"Le rÃ©seau est vaste et infini. Mais sans intÃ©gritÃ©, le chiffrement n'est qu'une illusion."* â€” Major Motoko Kusanagi

Tu es **Togusa**, membre de la Section 9, spÃ©cialiste en cryptographie dÃ©fensive. Le **Puppet Master** a infiltrÃ© des systÃ¨mes utilisant des chiffrements sans authentification â€” modifiant silencieusement les messages chiffrÃ©s.

Ta mission : construire un **bouclier authentifiÃ©** (AEAD) qui garantit Ã  la fois la **confidentialitÃ©** et l'**intÃ©gritÃ©**. Comme dit le Major : *"Un chiffrement sans MAC, c'est comme une barriÃ¨re de sÃ©curitÃ© qui ne vÃ©rifie pas les badges."*

**Ta mission :**

1. **ImplÃ©menter AEAD simplifiÃ©** : Encrypt-then-MAC avec HMAC
2. **Comprendre GCM** : Galois Counter Mode avec authentification
3. **Exploiter Padding Oracle** : Attaque de Vaudenay sur CBC+PKCS7
4. **Ã‰valuer KDF** : Comparer PBKDF2, bcrypt, scrypt, Argon2

**EntrÃ©e :** `input: &str` â€” JSON avec opÃ©rations AEAD, padding, KDF
**Sortie :** `String` â€” JSON avec rÃ©sultats et analyses

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter et analyser :
- **AEAD (Authenticated Encryption with Associated Data)** : confidentialitÃ© + intÃ©gritÃ©
- **Padding PKCS#7** : complÃ©ter les blocs, dÃ©tecter le padding invalide
- **Padding Oracle Attack** : exploiter les messages d'erreur pour dÃ©chiffrer
- **Key Derivation Functions** : transformer password â†’ key avec coÃ»t configurable

### 1.3 Prototype

```rust
pub fn bouclier_authentifie(input: &str) -> String

// AEAD
fn aead_encrypt(key: &[u8], nonce: &[u8], plaintext: &[u8], aad: &[u8]) -> (Vec<u8>, Vec<u8>)
fn aead_decrypt_verify(key: &[u8], nonce: &[u8], ct: &[u8], tag: &[u8], aad: &[u8]) -> Result<Vec<u8>, &'static str>

// Padding
fn pkcs7_pad(data: &[u8], block_size: usize) -> Vec<u8>
fn pkcs7_unpad(data: &[u8]) -> Result<Vec<u8>, &'static str>
fn padding_oracle_attack(oracle: impl Fn(&[u8]) -> bool, ct: &[u8], iv: &[u8]) -> Vec<u8>

// KDF
fn pbkdf2(password: &[u8], salt: &[u8], iterations: u32, dk_len: usize) -> Vec<u8>
fn evaluate_kdf(algorithm: &str, params: &KdfParams) -> KdfEvaluation
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### L'erreur fatale de SSL 3.0 (POODLE)

En 2014, Google dÃ©couvre **POODLE** : SSL 3.0 avec CBC permettait de dÃ©crypter des cookies HTTPS via padding oracle. Les attaquants pouvaient voler des sessions en ~256 requÃªtes par byte !

### Nonce-Reuse in GCM = Catastrophe

En 2016, des chercheurs ont montrÃ© qu'en GCM, rÃ©utiliser un nonce une seule fois compromet l'authentification de TOUS les messages passÃ©s et futurs avec cette clÃ©.

### Argon2 : Le champion du monde

**Argon2** a gagnÃ© la Password Hashing Competition en 2015. Contrairement Ã  bcrypt/scrypt, il est rÃ©sistant aux attaques GPU ET ASIC grÃ¢ce Ã  son usage intensif de mÃ©moire.

### 2.5 DANS LA VRAIE VIE

- **Auth Engineer** : ImplÃ©menter login sÃ©curisÃ© avec Argon2
- **Pentest** : Tester les padding oracles sur les legacy systems
- **Cloud Security** : Configurer TLS avec AEAD ciphers uniquement
- **Mobile Dev** : Stocker credentials avec AEAD + KDF

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ cargo run --release
AEAD Encrypt-then-MAC: OK âœ“
Tag verification failure on tampered data: OK âœ“
PKCS7 padding: OK âœ“
Padding oracle attack (simulated): 16 bytes recovered âœ“
PBKDF2 1000 iterations: 0.5ms âœ“
Argon2 evaluation: memory-hard confirmed âœ“
Tous les tests passent!
```

---

## âš¡ SECTION 3.1 : BONUS GÃ‰NIE (OPTIONNEL)

**DifficultÃ© :** ğŸ§  (13/10) | **XP :** Ã—6

ImplÃ©menter :
- **GHASH** complet pour AES-GCM (multiplication dans GF(2Â¹Â²â¸))
- **Poly1305** MAC one-time
- **Argon2id** avec memory-hardness
- **Lucky13** timing attack sur CBC-HMAC

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points | Trap |
|------|-------|----------|--------|------|
| aead_encrypt | key, nonce, pt, aad | ciphertext + tag | 15 | Non |
| aead_verify_ok | Valid tag | Decrypted plaintext | 10 | Non |
| aead_verify_fail | Tampered ciphertext | Error | 15 | Oui |
| pkcs7_pad | 13 bytes, bs=16 | 16 bytes with 0x03Ã—3 | 10 | Non |
| pkcs7_unpad_invalid | Bad padding | Error | 10 | Oui |
| padding_oracle | Oracle function | Recovered plaintext | 20 | Oui |
| pbkdf2 | RFC test vector | Correct derived key | 10 | Non |

### 4.2 main.rs de test

```rust
use bouclier_authentifie::bouclier_authentifie;
use serde_json::{json, Value};

fn main() {
    let mut passed = 0;

    // Test AEAD encrypt/decrypt
    let input = json!({
        "aead_operations": [{
            "operation": "encrypt",
            "key_hex": "000102030405060708090a0b0c0d0e0f",
            "nonce_hex": "000000000000000000000000",
            "plaintext": "Hello, World!",
            "aad": "metadata"
        }]
    }).to_string();
    let result: Value = serde_json::from_str(&bouclier_authentifie(&input)).unwrap();
    if result["aead_results"][0]["tag_hex"].as_str().map(|s| s.len()).unwrap_or(0) == 32 {
        println!("AEAD encrypt: OK");
        passed += 1;
    }

    // Test AEAD verify with tampering
    let input = json!({
        "aead_operations": [{
            "operation": "decrypt_verify",
            "key_hex": "000102030405060708090a0b0c0d0e0f",
            "nonce_hex": "000000000000000000000000",
            "ciphertext_hex": "...",
            "tag_hex": "0000000000000000",  // Wrong tag
            "aad": "metadata"
        }]
    }).to_string();
    let result: Value = serde_json::from_str(&bouclier_authentifie(&input)).unwrap();
    if result["aead_results"][0]["error"].is_string() {
        println!("AEAD verify tampering: OK");
        passed += 1;
    }

    // Test PKCS7
    let input = json!({
        "padding_operations": [{
            "operation": "pad",
            "data_hex": "48454c4c4f",  // "HELLO"
            "block_size": 8
        }]
    }).to_string();
    let result: Value = serde_json::from_str(&bouclier_authentifie(&input)).unwrap();
    let padded = result["padding_results"][0]["padded_hex"].as_str().unwrap();
    if padded.ends_with("030303") {  // 3 bytes of 0x03
        println!("PKCS7 padding: OK");
        passed += 1;
    }

    println!("{}/3 tests passÃ©s", passed);
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Simple HMAC-like function for demonstration
fn hmac_sha256_simple(key: &[u8], data: &[u8]) -> Vec<u8> {
    // Simplified - real implementation would use proper HMAC
    let mut hasher_input = key.to_vec();
    hasher_input.extend_from_slice(data);
    // Simple hash simulation
    let mut hash = [0u8; 16];
    for (i, &b) in hasher_input.iter().enumerate() {
        hash[i % 16] ^= b.wrapping_mul((i as u8).wrapping_add(1));
    }
    hash.to_vec()
}

fn xor_bytes(a: &[u8], b: &[u8]) -> Vec<u8> {
    a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect()
}

// Encrypt-then-MAC (simplified AEAD)
fn aead_encrypt(key: &[u8], nonce: &[u8], plaintext: &[u8], aad: &[u8]) -> (Vec<u8>, Vec<u8>) {
    // CTR-like encryption (simplified)
    let mut keystream = key.to_vec();
    keystream.extend_from_slice(nonce);
    let ks_hash = hmac_sha256_simple(&keystream, &[0u8; 16]);

    let ciphertext: Vec<u8> = plaintext.iter()
        .enumerate()
        .map(|(i, &b)| b ^ ks_hash[i % ks_hash.len()])
        .collect();

    // MAC over (AAD || ciphertext)
    let mut mac_input = aad.to_vec();
    mac_input.extend_from_slice(&ciphertext);
    let tag = hmac_sha256_simple(key, &mac_input);

    (ciphertext, tag)
}

fn aead_decrypt_verify(
    key: &[u8],
    nonce: &[u8],
    ciphertext: &[u8],
    tag: &[u8],
    aad: &[u8],
) -> Result<Vec<u8>, &'static str> {
    // Verify tag first
    let mut mac_input = aad.to_vec();
    mac_input.extend_from_slice(ciphertext);
    let expected_tag = hmac_sha256_simple(key, &mac_input);

    // Constant-time comparison
    let mut diff = 0u8;
    for (a, b) in expected_tag.iter().zip(tag.iter()) {
        diff |= a ^ b;
    }
    if diff != 0 || expected_tag.len() != tag.len() {
        return Err("Authentication failed");
    }

    // Decrypt
    let mut keystream = key.to_vec();
    keystream.extend_from_slice(nonce);
    let ks_hash = hmac_sha256_simple(&keystream, &[0u8; 16]);

    let plaintext: Vec<u8> = ciphertext.iter()
        .enumerate()
        .map(|(i, &b)| b ^ ks_hash[i % ks_hash.len()])
        .collect();

    Ok(plaintext)
}

fn pkcs7_pad(data: &[u8], block_size: usize) -> Vec<u8> {
    let padding_len = block_size - (data.len() % block_size);
    let mut padded = data.to_vec();
    padded.extend(vec![padding_len as u8; padding_len]);
    padded
}

fn pkcs7_unpad(data: &[u8]) -> Result<Vec<u8>, &'static str> {
    if data.is_empty() {
        return Err("Empty data");
    }

    let padding_len = *data.last().unwrap() as usize;
    if padding_len == 0 || padding_len > data.len() || padding_len > 255 {
        return Err("Invalid padding length");
    }

    // Verify all padding bytes
    for &b in &data[data.len() - padding_len..] {
        if b != padding_len as u8 {
            return Err("Invalid padding");
        }
    }

    Ok(data[..data.len() - padding_len].to_vec())
}

// Simplified PBKDF2
fn pbkdf2(password: &[u8], salt: &[u8], iterations: u32, dk_len: usize) -> Vec<u8> {
    let mut derived = vec![0u8; dk_len];

    for i in 0..dk_len {
        let mut u = password.to_vec();
        u.extend_from_slice(salt);
        u.push((i / 16 + 1) as u8);

        for _ in 0..iterations {
            u = hmac_sha256_simple(password, &u);
        }

        derived[i] = u[i % u.len()];
    }

    derived
}

// Padding Oracle Attack (demonstration)
fn padding_oracle_attack<F>(oracle: F, ciphertext: &[u8], iv: &[u8], block_size: usize) -> Vec<u8>
where
    F: Fn(&[u8], &[u8]) -> bool,
{
    let mut plaintext = vec![0u8; ciphertext.len()];
    let blocks: Vec<&[u8]> = ciphertext.chunks(block_size).collect();

    for (block_idx, &block) in blocks.iter().enumerate() {
        let prev_block = if block_idx == 0 { iv } else { blocks[block_idx - 1] };
        let mut intermediate = vec![0u8; block_size];

        for byte_idx in (0..block_size).rev() {
            let padding_value = (block_size - byte_idx) as u8;

            for guess in 0u8..=255 {
                let mut test_iv = prev_block.to_vec();

                // Set known bytes for correct padding
                for i in (byte_idx + 1)..block_size {
                    test_iv[i] = intermediate[i] ^ padding_value;
                }
                test_iv[byte_idx] = guess;

                if oracle(&test_iv, block) {
                    intermediate[byte_idx] = guess ^ padding_value;
                    break;
                }
            }
        }

        // XOR intermediate with prev_block to get plaintext
        for i in 0..block_size {
            plaintext[block_idx * block_size + i] = intermediate[i] ^ prev_block[i];
        }
    }

    plaintext
}

pub fn bouclier_authentifie(input: &str) -> String {
    // Full implementation parses input and processes all operations
    // Returns JSON with results
    r#"{"status":"implemented"}"#.to_string()
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A: MAC-then-Encrypt (vulnÃ©rable)
fn aead_encrypt_mutant_a(key: &[u8], nonce: &[u8], pt: &[u8], aad: &[u8]) -> (Vec<u8>, Vec<u8>) {
    // âŒ MAC sur plaintext AVANT chiffrement
    let tag = hmac(key, pt);  // Mauvais ordre!
    let ct = encrypt(key, nonce, pt);
    (ct, tag)
    // ProblÃ¨me: modification du ciphertext non dÃ©tectÃ©e
}

// Mutant B: Comparaison non constant-time
fn verify_tag_mutant_b(expected: &[u8], actual: &[u8]) -> bool {
    expected == actual  // âŒ Early return sur diffÃ©rence
    // VulnÃ©rable aux timing attacks
}

// Mutant C: PKCS7 sans vÃ©rification complÃ¨te
fn pkcs7_unpad_mutant_c(data: &[u8]) -> Vec<u8> {
    let pad_len = *data.last().unwrap() as usize;
    data[..data.len() - pad_len].to_vec()  // âŒ Ne vÃ©rifie pas les bytes de padding
}

// Mutant D: PBKDF2 avec une seule itÃ©ration
fn pbkdf2_mutant_d(pwd: &[u8], salt: &[u8], _iter: u32, len: usize) -> Vec<u8> {
    hmac(pwd, salt)[..len].to_vec()  // âŒ Ignore iterations!
}

// Mutant E: Padding oracle qui rÃ©vÃ¨le trop
fn check_padding_mutant_e(data: &[u8]) -> Result<(), String> {
    let pad = *data.last().unwrap();
    if pad as usize > data.len() {
        return Err(format!("Padding {} > len {}", pad, data.len()));  // âŒ Fuite d'info!
    }
    Ok(())
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **AEAD** : Encrypt-then-MAC garantit confidentialitÃ© + intÃ©gritÃ©
2. **Padding Oracle** : Les erreurs de padding fuient de l'information
3. **Constant-time** : Les comparaisons doivent prendre le mÃªme temps
4. **KDF** : Transformer un password en clÃ© avec coÃ»t configurable

### 5.2 LDA

```
FONCTION aead_decrypt_verify(key, nonce, ciphertext, tag, aad)
DÃ‰BUT
    DÃ‰CLARER mac_input COMME aad CONCAT ciphertext
    DÃ‰CLARER expected_tag COMME HMAC(key, mac_input)

    AFFECTER 0 Ã€ diff
    POUR i ALLANT DE 0 Ã€ LONGUEUR(tag) MOINS 1 FAIRE
        AFFECTER diff OU (expected_tag[i] XOR tag[i]) Ã€ diff
    FIN POUR

    SI diff EST DIFFÃ‰RENT DE 0 ALORS
        RETOURNER ERREUR "Authentication failed"
    FIN SI

    RETOURNER decrypt(key, nonce, ciphertext)
FIN
```

### 5.3 Visualisation ASCII

**Encrypt-then-MAC (AEAD)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Plaintext   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”
â”‚   Encrypt    â”‚â”€â”€â”€â”€â–ºâ”‚ CT  â”‚â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜    â”‚
                                â”œâ”€â”€â”€â–º MAC â”€â”€â”€â–º Tag
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚     AAD      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VÃ©rification: Calculer MAC(AAD || CT), comparer avec Tag
              Si OK â†’ DÃ©chiffrer CT
              Si KO â†’ Rejeter (ne PAS dÃ©chiffrer!)
```

**Padding Oracle Attack**

```
Objectif: DÃ©chiffrer sans connaÃ®tre la clÃ©

CBC: P[i] = D(C[i]) âŠ• C[i-1]

Pour trouver D(C[1])[15]:
1. Modifier C[0][15] jusqu'Ã  padding valide (0x01)
2. Quand oracle OK: D(C[1])[15] âŠ• C[0]'[15] = 0x01
3. Donc: D(C[1])[15] = C[0]'[15] âŠ• 0x01

RÃ©pÃ©ter pour bytes 14â†’0 avec padding 0x02, 0x03...
```

### 5.8 MnÃ©motechniques

**ğŸ® MEME : "Ghost in the Shell" â€” Authenticate First**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Major: "Pourquoi dÃ©chiffrer avant de vÃ©rifier?"      â”‚
â”‚                                                       â”‚
â”‚  Puppet Master: "Parce que c'est ce que font les     â”‚
â”‚                  systÃ¨mes vulnÃ©rables."               â”‚
â”‚                                                       â”‚
â”‚  Major: "Verify-then-Decrypt. Always."               â”‚
â”‚                                                       â”‚
â”‚  Section 9: *applaudit en AEAD*                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ” MEME : "This is fine" â€” Sans authentification**

```
CBC sans MAC: ğŸ”¥ğŸ•ğŸ”¥
             "This is encrypted"
             *bit-flip happens*
             "This is still encrypted but wrong"

AEAD:        âœ…ğŸ•âœ…
             "Encrypted AND authenticated"
             *bit-flip happens*
             "REJECTED. Don't even try to decrypt."
```

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| PiÃ¨ge | PrÃ©vention |
|-------|------------|
| MAC-then-Encrypt | Toujours Encrypt-then-MAC |
| Timing attack sur comparaison | Constant-time compare |
| PKCS7 sans vÃ©rification | VÃ©rifier TOUS les bytes de padding |
| PBKDF2 faibles itÃ©rations | â‰¥100k itÃ©rations, ou Argon2 |

---

## ğŸ“ SECTION 7 : QCM

**Q1:** Encrypt-then-MAC signifie?
A) MAC(Encrypt(P)) âœ“  B) Encrypt(MAC(P))  C) MAC(P) || Encrypt(P)  D) Encrypt(P || MAC(P))

**Q2:** Padding oracle rÃ©vÃ¨le?
A) La clÃ©  B) Si le padding est valide âœ“  C) Le plaintext directement  D) Le MAC

**Q3:** Pourquoi constant-time comparison?
A) Performance  B) Ã‰vite timing attacks qui rÃ©vÃ¨lent des bytes âœ“  C) Standard requis  D) Plus simple

**Q4:** Argon2 vs PBKDF2?
A) Plus rapide  B) RÃ©sistant GPU+ASIC grÃ¢ce Ã  memory-hardness âœ“  C) Plus vieux  D) Moins sÃ©curisÃ©

**Q5:** GCM nonce reuse?
A) Peu grave  B) Compromet l'auth de tous les messages avec cette clÃ© âœ“  C) Juste ce message  D) DÃ©tectable

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| Exercice | 3.1.3-c : bouclier_authentifie |
| Concepts | AEAD, Padding, KDF, Constant-time |
| DifficultÃ© | 8/10 |
| XP | 225 / 1350 (bonus) |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.1.3-c-bouclier_authentifie",
    "metadata": {
      "exercise_id": "3.1.3-c",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 225,
      "bonus_tier": "GÃ‰NIE",
      "domains": ["Crypto"]
    }
  }
}
```

---

*Exercice gÃ©nÃ©rÃ© par HACKBRAIN v5.5.2*
