# Exercice 3.1.8-a : sources_chaos

**Module :**
3.1.8 â€” GÃ©nÃ©ration de Nombres AlÃ©atoires

**Concept :**
a â€” Entropie, TRNG, PRNG et CSPRNG

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
1 â€” Concept isolÃ©

**Langage :**
Python 3.14

**PrÃ©requis :**
3.1.5-a (fonctions de hachage), 3.1.4-a (fondamentaux crypto)

**Domaines :**
Crypto, Probas, Encodage

**DurÃ©e estimÃ©e :**
120 min

**XP Base :**
250

**ComplexitÃ© :**
T2 O(n) Ã— S1 O(1)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `sources_chaos.py`
**AutorisÃ© :** secrets, os, hashlib, math, collections
**Interdit :** random (sauf pour dÃ©montrer ses faiblesses), numpy.random

### 1.2 Consigne

**ğŸ® "Dark" â€” Le Chaos Temporel**

*"Was wir wissen, ist ein Tropfen. Was wir nicht wissen, ein Ozean."* â€” Jonas Kahnwald

Tu es **Jonas Kahnwald**, voyageur temporel dans la sÃ©rie "Dark". Chaque boucle temporelle dÃ©pend d'Ã©vÃ©nements "alÃ©atoires" qui ne le sont pas vraiment â€” tout est dÃ©terministe si on connaÃ®t l'Ã©tat initial.

C'est exactement le problÃ¨me des **PRNG** (Pseudo-Random Number Generators) : ils SEMBLENT alÃ©atoires, mais sont en rÃ©alitÃ© dÃ©terministes. Si tu connais le seed initial (comme Adam connaÃ®t le dÃ©but de la boucle), tu peux prÃ©dire TOUTE la sÃ©quence.

**Ta mission :**

1. **Analyser l'entropie** : Mesurer le "vrai" hasard d'une source
2. **Distinguer PRNG vs CSPRNG** : Comprendre pourquoi `random` est dangereux
3. **ImplÃ©menter un CSPRNG** : BasÃ© sur HMAC-DRBG
4. **DÃ©tecter les failles historiques** : Debian OpenSSL, Dual_EC, Android SecureRandom
5. **Collecter l'entropie** : Sources systÃ¨me (/dev/random, /dev/urandom, RDRAND)

### 1.2.2 Consigne AcadÃ©mique

Cet exercice couvre les fondamentaux de la gÃ©nÃ©ration de nombres alÃ©atoires cryptographiques :

1. **Entropie de Shannon** : Mesure de l'incertitude
2. **TRNG vs PRNG** : Vrai hasard vs pseudo-hasard dÃ©terministe
3. **CSPRNG** : GÃ©nÃ©rateurs pseudo-alÃ©atoires cryptographiquement sÃ»rs
4. **Attaques RNG** : Historique des failles majeures
5. **Bonnes pratiques** : Comment utiliser correctement le hasard en crypto

### 1.3 Prototype

```python
def sources_chaos(input_json: str) -> str:
    """Point d'entrÃ©e principal"""
    pass

# Analyse d'entropie
def calculate_shannon_entropy(data: bytes) -> float:
    """Calcule l'entropie de Shannon en bits par byte"""
    pass

def analyze_entropy_sources() -> dict:
    """Analyse les sources d'entropie systÃ¨me disponibles"""
    pass

def estimate_min_entropy(samples: list) -> float:
    """Estime l'entropie minimale (conservatrice)"""
    pass

# PRNG vs CSPRNG
def demonstrate_prng_weakness(seed: int) -> dict:
    """DÃ©montre la prÃ©dictibilitÃ© de random.random()"""
    pass

def is_csprng_safe(generator_name: str) -> dict:
    """Ã‰value si un gÃ©nÃ©rateur est cryptographiquement sÃ»r"""
    pass

# ImplÃ©mentation CSPRNG
def hmac_drbg_instantiate(entropy: bytes, nonce: bytes, personalization: bytes = b'') -> dict:
    """Initialise HMAC-DRBG (NIST SP 800-90A)"""
    pass

def hmac_drbg_generate(state: dict, num_bytes: int) -> tuple:
    """GÃ©nÃ¨re des bytes alÃ©atoires avec HMAC-DRBG"""
    pass

def hmac_drbg_reseed(state: dict, entropy: bytes) -> dict:
    """Re-seed HMAC-DRBG avec nouvelle entropie"""
    pass

# DÃ©tection de failles
def analyze_rng_attack(attack_name: str) -> dict:
    """Explique une attaque RNG historique"""
    pass

def detect_weak_randomness(samples: bytes) -> dict:
    """DÃ©tecte des patterns dans des donnÃ©es supposÃ©es alÃ©atoires"""
    pass

def simulate_debian_openssl_bug() -> dict:
    """Simule le bug Debian OpenSSL de 2008"""
    pass

# Collecte d'entropie
def collect_system_entropy(num_bytes: int) -> bytes:
    """Collecte de l'entropie du systÃ¨me de maniÃ¨re sÃ»re"""
    pass

def mix_entropy_sources(sources: list) -> bytes:
    """MÃ©lange plusieurs sources d'entropie"""
    pass
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### Le Bug Debian OpenSSL â€” 2 Ans d'InvisibilitÃ©

En 2006, un mainteneur Debian a supprimÃ© une ligne de code OpenSSL qui lui semblait inutile (elle gÃ©nÃ©rait un warning Valgrind). Cette "correction" a rÃ©duit l'entropie du gÃ©nÃ©rateur Ã  seulement 15 bits (32,768 clÃ©s possibles). Le bug n'a Ã©tÃ© dÃ©couvert qu'en 2008 â€” toutes les clÃ©s SSH/SSL gÃ©nÃ©rÃ©es sur Debian/Ubuntu pendant 2 ans Ã©taient triviallement crackables.

### Dual_EC_DRBG â€” La Backdoor de la NSA

En 2007, deux chercheurs ont remarquÃ© que les constantes de Dual_EC_DRBG (un CSPRNG approuvÃ© par le NIST) pouvaient contenir une backdoor. En 2013, Edward Snowden a confirmÃ© que la NSA avait payÃ© RSA Security $10 millions pour utiliser ce gÃ©nÃ©rateur par dÃ©faut.

### Android SecureRandom â€” Bitcoin VolÃ©s

En 2013, une faille dans l'implÃ©mentation Android de SecureRandom permettait de prÃ©dire les clÃ©s privÃ©es de portefeuilles Bitcoin. Des millions de dollars en BTC ont Ã©tÃ© volÃ©s avant le correctif.

---

## ğŸ“ SECTION 2.5 : DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Cryptographer** | Design et audit de CSPRNG |
| **Security Researcher** | Analyse de la qualitÃ© de l'entropie |
| **Embedded Systems Engineer** | ImplÃ©mentation de sources d'entropie matÃ©rielles |
| **Blockchain Developer** | GÃ©nÃ©ration sÃ©curisÃ©e de clÃ©s privÃ©es |
| **Game Developer** | RNG pour les jeux (Ã©quitÃ©, anti-triche) |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
sources_chaos.py  main.py

$ python main.py

$ python -c "
from sources_chaos import *

# Mesure d'entropie
data = b'AAAAAAAAAA'  # Faible entropie
print('Entropie (rÃ©pÃ©titif):', calculate_shannon_entropy(data), 'bits/byte')

data = os.urandom(10)  # Haute entropie
print('Entropie (urandom):', calculate_shannon_entropy(data), 'bits/byte')
"
Entropie (rÃ©pÃ©titif): 0.0 bits/byte
Entropie (urandom): 7.82 bits/byte

$ python -c "
from sources_chaos import *

# DÃ©monstration faiblesse PRNG
result = demonstrate_prng_weakness(seed=42)
print('SÃ©quence prÃ©dite:', result['predicted'][:3])
print('SÃ©quence rÃ©elle:', result['actual'][:3])
print('Match:', result['predicted'] == result['actual'])
"
SÃ©quence prÃ©dite: [0.6394267984578837, 0.025010755222666936, 0.27502931836911926]
SÃ©quence rÃ©elle: [0.6394267984578837, 0.025010755222666936, 0.27502931836911926]
Match: True

$ python -c "
from sources_chaos import *

# HMAC-DRBG
entropy = os.urandom(32)
nonce = os.urandom(16)
state = hmac_drbg_instantiate(entropy, nonce)
random_bytes, state = hmac_drbg_generate(state, 32)
print('Generated:', random_bytes.hex()[:32], '...')
"
Generated: 7a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d ...

$ python -c "
from sources_chaos import *

# Analyse d'attaque
attack = analyze_rng_attack('debian_openssl')
print('CVE:', attack['cve'])
print('Impact:', attack['impact'])
print('ClÃ©s affectÃ©es:', attack['affected_keys'])
"
CVE: CVE-2008-0166
Impact: Toutes les clÃ©s SSH/SSL Debian/Ubuntu 2006-2008
ClÃ©s affectÃ©es: 32768 possibles (15 bits d'entropie)
```

---

## ğŸ”¥ SECTION 3.1 : BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(n log n) pour l'analyse statistique

**Space Complexity attendue :**
O(n) pour les samples

**Domaines Bonus :**
`Probas, MD`

### 3.1.1 Consigne Bonus

**ğŸ® "Dark" â€” Briser la Boucle**

Comme Jonas qui tente de briser la boucle temporelle, tu dois crÃ©er un **analyseur statistique complet** pour dÃ©tecter les failles RNG.

**Ta mission :**

1. **ImplÃ©menter les tests NIST SP 800-22** : Frequency, Runs, etc.
2. **DÃ©tecter les patterns temporels** : AutocorrÃ©lation
3. **Craquer un PRNG faible** : Retrouver le seed Ã  partir de la sortie
4. **Auditer des implÃ©mentations** : Identifier les faiblesses

**Contraintes :**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Tests statistiques formels             â”‚
â”‚  Analyse jusqu'Ã  1 million de samples   â”‚
â”‚  Confidence level 95%                   â”‚
â”‚  Support de plusieurs algorithmes       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

### 3.1.2 Prototype Bonus

```python
def nist_frequency_test(bits: bytes) -> dict:
    """Test de frÃ©quence NIST"""
    pass

def nist_runs_test(bits: bytes) -> dict:
    """Test des runs NIST"""
    pass

def crack_lcg(samples: list, modulus: int) -> dict:
    """Retrouve les paramÃ¨tres d'un LCG Ã  partir de samples"""
    pass

def audit_rng_implementation(code: str) -> dict:
    """Audite une implÃ©mentation RNG"""
    pass
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Analyse | Entropie simple | Tests statistiques NIST |
| Attaque | Description | ImplÃ©mentation de crack |
| Volume | Quelques samples | Jusqu'Ã  1M samples |
| Output | MÃ©triques basiques | Rapport d'audit complet |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `entropy_zeros` | b'\x00' * 1000 | entropy: 0.0 | 5 |
| `entropy_random` | os.urandom(1000) | entropy: > 7.5 | 5 |
| `entropy_text` | b'Hello World!' | entropy: ~3.0 | 5 |
| `prng_predict` | seed=42 | predicted == actual | 10 |
| `csprng_check` | "secrets" | safe: True | 5 |
| `csprng_check_random` | "random.random" | safe: False | 5 |
| `hmac_drbg_init` | entropy, nonce | valid state | 10 |
| `hmac_drbg_generate` | state, 32 | 32 random bytes | 10 |
| `hmac_drbg_reseed` | state, new_entropy | updated state | 5 |
| `attack_debian` | "debian_openssl" | cve, impact, mitigation | 10 |
| `attack_dual_ec` | "dual_ec_drbg" | nsa_backdoor: True | 10 |
| `detect_pattern` | repeating bytes | pattern_detected: True | 10 |
| `system_entropy` | 32 | 32 bytes from urandom | 5 |
| `mix_sources` | multiple sources | hashed output | 5 |

### 4.2 main.py de test

```python
import os
import math
from sources_chaos import *

def test_all():
    # Test 1: Entropie de zÃ©ros
    data = b'\x00' * 1000
    entropy = calculate_shannon_entropy(data)
    assert entropy == 0.0, f"Entropy of zeros should be 0, got {entropy}"
    print("âœ… Test entropie zÃ©ros: OK")

    # Test 2: Entropie de donnÃ©es alÃ©atoires
    data = os.urandom(1000)
    entropy = calculate_shannon_entropy(data)
    assert entropy > 7.5, f"Random data should have high entropy, got {entropy}"
    print("âœ… Test entropie alÃ©atoire: OK")

    # Test 3: Entropie de texte
    data = b'Hello World! ' * 100
    entropy = calculate_shannon_entropy(data)
    assert 2.5 < entropy < 4.0, f"Text entropy should be moderate, got {entropy}"
    print("âœ… Test entropie texte: OK")

    # Test 4: PrÃ©diction PRNG
    result = demonstrate_prng_weakness(seed=42)
    assert result['predicted'] == result['actual'], "PRNG should be predictable"
    assert result['predictable'] == True
    print("âœ… Test prÃ©diction PRNG: OK")

    # Test 5: Ã‰valuation CSPRNG - secrets
    result = is_csprng_safe('secrets')
    assert result['safe'] == True, "secrets module should be safe"
    print("âœ… Test CSPRNG secrets: OK")

    # Test 6: Ã‰valuation CSPRNG - random
    result = is_csprng_safe('random')
    assert result['safe'] == False, "random module is NOT cryptographically safe"
    print("âœ… Test CSPRNG random: OK")

    # Test 7: HMAC-DRBG instantiation
    entropy = os.urandom(32)
    nonce = os.urandom(16)
    state = hmac_drbg_instantiate(entropy, nonce)
    assert 'key' in state, "HMAC-DRBG state should have key"
    assert 'value' in state, "HMAC-DRBG state should have value"
    assert state['reseed_counter'] == 1
    print("âœ… Test HMAC-DRBG init: OK")

    # Test 8: HMAC-DRBG generate
    random_bytes, new_state = hmac_drbg_generate(state, 32)
    assert len(random_bytes) == 32, f"Should generate 32 bytes, got {len(random_bytes)}"
    assert random_bytes != b'\x00' * 32, "Should not be all zeros"
    assert new_state['reseed_counter'] == state['reseed_counter'] + 1
    print("âœ… Test HMAC-DRBG generate: OK")

    # Test 9: HMAC-DRBG reseed
    new_entropy = os.urandom(32)
    reseeded = hmac_drbg_reseed(new_state, new_entropy)
    assert reseeded['key'] != new_state['key'], "Reseed should change key"
    assert reseeded['reseed_counter'] == 1
    print("âœ… Test HMAC-DRBG reseed: OK")

    # Test 10: Analyse attaque Debian
    attack = analyze_rng_attack('debian_openssl')
    assert 'CVE-2008-0166' in attack.get('cve', '')
    assert attack.get('bits_of_entropy') == 15
    print("âœ… Test attaque Debian: OK")

    # Test 11: Analyse attaque Dual EC
    attack = analyze_rng_attack('dual_ec_drbg')
    assert attack.get('nsa_backdoor') == True
    print("âœ… Test attaque Dual EC: OK")

    # Test 12: DÃ©tection de patterns
    # DonnÃ©es avec pattern Ã©vident
    pattern_data = b'\xAB\xCD' * 500
    result = detect_weak_randomness(pattern_data)
    assert result.get('pattern_detected') == True
    print("âœ… Test dÃ©tection pattern: OK")

    # Test 13: Collecte entropie systÃ¨me
    entropy_bytes = collect_system_entropy(32)
    assert len(entropy_bytes) == 32
    assert entropy_bytes != b'\x00' * 32
    print("âœ… Test collecte entropie: OK")

    # Test 14: Mix de sources
    sources = [os.urandom(16), os.urandom(16), b'additional_input']
    mixed = mix_entropy_sources(sources)
    assert len(mixed) >= 32, "Mixed output should be at least 32 bytes"
    print("âœ… Test mix sources: OK")

    print("\nâœ… Tous les tests passent!")

if __name__ == "__main__":
    test_all()
```

### 4.3 Solution de rÃ©fÃ©rence

```python
import os
import math
import hmac
import hashlib
import secrets
import json
from collections import Counter
from typing import Dict, List, Tuple, Any, Optional

# ========================
# ANALYSE D'ENTROPIE
# ========================

def calculate_shannon_entropy(data: bytes) -> float:
    """
    Calcule l'entropie de Shannon en bits par byte.

    H = -Î£ p(x) * log2(p(x))

    Entropie maximale = 8 bits/byte (donnÃ©es parfaitement alÃ©atoires)
    Entropie minimale = 0 bits/byte (donnÃ©es constantes)
    """
    if not data:
        return 0.0

    # Compter les occurrences de chaque byte
    counts = Counter(data)
    total = len(data)

    # Calculer l'entropie
    entropy = 0.0
    for count in counts.values():
        if count > 0:
            p = count / total
            entropy -= p * math.log2(p)

    return entropy


def analyze_entropy_sources() -> dict:
    """Analyse les sources d'entropie systÃ¨me disponibles."""
    sources = {
        'available': [],
        'unavailable': [],
        'recommendations': []
    }

    # Check /dev/urandom (Linux/macOS)
    if os.path.exists('/dev/urandom'):
        sources['available'].append({
            'name': '/dev/urandom',
            'type': 'kernel',
            'blocking': False,
            'recommended_for': 'cryptographic use'
        })

    # Check /dev/random (Linux/macOS)
    if os.path.exists('/dev/random'):
        sources['available'].append({
            'name': '/dev/random',
            'type': 'kernel',
            'blocking': True,
            'note': 'May block if entropy pool depleted (Linux < 5.6)'
        })

    # Check for hardware RNG
    if os.path.exists('/dev/hwrng'):
        sources['available'].append({
            'name': '/dev/hwrng',
            'type': 'hardware',
            'blocking': False,
            'note': 'Hardware random number generator'
        })

    # os.urandom always available in Python
    sources['available'].append({
        'name': 'os.urandom()',
        'type': 'python',
        'blocking': False,
        'recommended_for': 'cryptographic use in Python'
    })

    # secrets module (Python 3.6+)
    sources['available'].append({
        'name': 'secrets module',
        'type': 'python',
        'blocking': False,
        'recommended_for': 'passwords, tokens, cryptographic use'
    })

    # Recommendations
    sources['recommendations'] = [
        'Use secrets module for cryptographic purposes',
        'Never use random module for security',
        'Prefer os.urandom() over /dev/random on modern Linux',
        'Consider hardware RNG for high-security applications'
    ]

    return sources


def estimate_min_entropy(samples: list) -> float:
    """
    Estime l'entropie minimale (approche conservatrice).

    Min-entropy = -log2(max_probability)

    C'est une estimation pessimiste, utile pour la crypto.
    """
    if not samples:
        return 0.0

    counts = Counter(samples)
    total = len(samples)
    max_prob = max(counts.values()) / total

    if max_prob == 0 or max_prob == 1:
        return 0.0

    return -math.log2(max_prob)


# ========================
# PRNG vs CSPRNG
# ========================

def demonstrate_prng_weakness(seed: int) -> dict:
    """
    DÃ©montre la prÃ©dictibilitÃ© de random.random().

    âš ï¸ Ã‰DUCATIF SEULEMENT - Ne jamais utiliser random pour la crypto!
    """
    import random

    # GÃ©nÃ©rer avec le seed original
    random.seed(seed)
    actual = [random.random() for _ in range(10)]

    # PrÃ©dire avec le mÃªme seed
    random.seed(seed)
    predicted = [random.random() for _ in range(10)]

    return {
        'seed': seed,
        'actual': actual,
        'predicted': predicted,
        'predictable': actual == predicted,
        'warning': 'NEVER use random.random() for cryptography!',
        'algorithm': 'Mersenne Twister (MT19937)',
        'state_size': '624 Ã— 32-bit integers',
        'attack': 'With 624 outputs, full state can be recovered'
    }


# Base de donnÃ©es des gÃ©nÃ©rateurs
GENERATORS_DB = {
    'secrets': {
        'safe': True,
        'source': 'os.urandom()',
        'algorithm': 'System CSPRNG',
        'recommendation': 'RECOMMENDED for cryptographic use',
        'examples': ['secrets.token_bytes()', 'secrets.token_hex()', 'secrets.token_urlsafe()']
    },
    'os.urandom': {
        'safe': True,
        'source': 'Kernel entropy pool',
        'algorithm': 'ChaCha20 (Linux 4.8+) or SHA-1 based',
        'recommendation': 'RECOMMENDED for cryptographic use'
    },
    'random': {
        'safe': False,
        'source': 'Deterministic PRNG',
        'algorithm': 'Mersenne Twister (MT19937)',
        'recommendation': 'NEVER use for security',
        'vulnerabilities': [
            'Predictable with 624 consecutive outputs',
            'Seed is only 32 bits (trivially brute-forceable)',
            'No cryptographic guarantees'
        ]
    },
    'random.random': {
        'safe': False,
        'source': 'Deterministic PRNG',
        'algorithm': 'Mersenne Twister (MT19937)',
        'recommendation': 'NEVER use for security'
    },
    'numpy.random': {
        'safe': False,
        'source': 'Deterministic PRNG',
        'algorithm': 'Mersenne Twister or PCG',
        'recommendation': 'NEVER use for security'
    },
    'SystemRandom': {
        'safe': True,
        'source': 'os.urandom()',
        'algorithm': 'System CSPRNG',
        'recommendation': 'Safe alternative using random module interface'
    }
}


def is_csprng_safe(generator_name: str) -> dict:
    """Ã‰value si un gÃ©nÃ©rateur est cryptographiquement sÃ»r."""
    generator_name_lower = generator_name.lower()

    # Lookup direct
    if generator_name in GENERATORS_DB:
        return GENERATORS_DB[generator_name]

    # Lookup par nom normalisÃ©
    for name, info in GENERATORS_DB.items():
        if generator_name_lower in name.lower():
            return {**info, 'matched': name}

    return {
        'safe': None,
        'error': f'Unknown generator: {generator_name}',
        'recommendation': 'Use secrets module for cryptographic purposes'
    }


# ========================
# HMAC-DRBG (NIST SP 800-90A)
# ========================

def hmac_drbg_instantiate(entropy: bytes, nonce: bytes, personalization: bytes = b'') -> dict:
    """
    Initialise HMAC-DRBG selon NIST SP 800-90A.

    ParamÃ¨tres:
    - entropy: Au moins 256 bits d'entropie
    - nonce: Au moins 128 bits (peut Ãªtre un compteur)
    - personalization: DonnÃ©es optionnelles pour diffÃ©rencier les instances
    """
    # Seed material
    seed_material = entropy + nonce + personalization

    # Initial values
    outlen = 32  # SHA-256 output
    key = b'\x00' * outlen
    value = b'\x01' * outlen

    # Update function
    key, value = _hmac_drbg_update(seed_material, key, value)

    return {
        'key': key,
        'value': value,
        'reseed_counter': 1,
        'security_strength': 256,
        'prediction_resistance': False
    }


def _hmac_drbg_update(provided_data: bytes, key: bytes, value: bytes) -> tuple:
    """
    Fonction de mise Ã  jour HMAC-DRBG.
    """
    # Step 1: K = HMAC(K, V || 0x00 || provided_data)
    key = hmac.new(key, value + b'\x00' + provided_data, hashlib.sha256).digest()

    # Step 2: V = HMAC(K, V)
    value = hmac.new(key, value, hashlib.sha256).digest()

    if provided_data:
        # Step 4: K = HMAC(K, V || 0x01 || provided_data)
        key = hmac.new(key, value + b'\x01' + provided_data, hashlib.sha256).digest()

        # Step 5: V = HMAC(K, V)
        value = hmac.new(key, value, hashlib.sha256).digest()

    return key, value


def hmac_drbg_generate(state: dict, num_bytes: int) -> tuple:
    """
    GÃ©nÃ¨re des bytes alÃ©atoires avec HMAC-DRBG.

    Retourne: (random_bytes, new_state)
    """
    key = state['key']
    value = state['value']

    # Check reseed counter
    if state['reseed_counter'] > 2**48:
        raise ValueError("Reseed required")

    # Generate
    output = b''
    temp = b''

    while len(temp) < num_bytes:
        value = hmac.new(key, value, hashlib.sha256).digest()
        temp += value

    output = temp[:num_bytes]

    # Update state
    key, value = _hmac_drbg_update(b'', key, value)

    new_state = {
        'key': key,
        'value': value,
        'reseed_counter': state['reseed_counter'] + 1,
        'security_strength': state['security_strength'],
        'prediction_resistance': state['prediction_resistance']
    }

    return output, new_state


def hmac_drbg_reseed(state: dict, entropy: bytes, additional_input: bytes = b'') -> dict:
    """
    Re-seed HMAC-DRBG avec nouvelle entropie.
    """
    seed_material = entropy + additional_input

    key, value = _hmac_drbg_update(seed_material, state['key'], state['value'])

    return {
        'key': key,
        'value': value,
        'reseed_counter': 1,
        'security_strength': state['security_strength'],
        'prediction_resistance': state['prediction_resistance']
    }


# ========================
# ATTAQUES RNG HISTORIQUES
# ========================

RNG_ATTACKS = {
    'debian_openssl': {
        'name': 'Debian OpenSSL PRNG Bug',
        'cve': 'CVE-2008-0166',
        'year': 2008,
        'duration': '2006-2008 (2 years undetected)',
        'cause': 'Removal of uninitialized memory in PRNG seeding',
        'bits_of_entropy': 15,
        'affected_keys': 32768,
        'impact': 'All SSH/SSL keys generated on Debian/Ubuntu compromised',
        'affected_systems': ['Debian', 'Ubuntu', 'derivatives'],
        'attack_complexity': 'Trivial - pre-computed key list',
        'mitigation': [
            'Regenerate all keys generated 2006-2008',
            'Use ssh-vulnkey to detect weak keys',
            'Update OpenSSL package'
        ],
        'lesson': 'Never remove code you do not understand, especially in crypto'
    },
    'dual_ec_drbg': {
        'name': 'Dual EC DRBG NSA Backdoor',
        'cve': 'N/A (by design)',
        'year': 2013,  # Revealed, suspected since 2007
        'duration': '2006-2013 (in NIST standard)',
        'cause': 'Elliptic curve constants potentially chosen by NSA',
        'nsa_backdoor': True,
        'nsa_payment': '$10 million to RSA Security',
        'impact': 'Anyone knowing backdoor constants could predict output',
        'affected_systems': ['RSA BSAFE', 'RSA Data Protection Manager', 'Many others'],
        'attack_complexity': 'Requires knowing the backdoor (Q = eP relationship)',
        'mitigation': [
            'Do not use Dual_EC_DRBG',
            'Use HMAC-DRBG or CTR-DRBG instead',
            'NIST removed from recommendations in 2014'
        ],
        'lesson': 'Prefer transparent, well-audited algorithms'
    },
    'android_securerandom': {
        'name': 'Android SecureRandom Bug',
        'cve': 'CVE-2013-7372',
        'year': 2013,
        'cause': 'PRNG not properly seeded on some Android versions',
        'impact': 'Bitcoin wallet private keys predictable',
        'affected_systems': ['Android 4.1-4.3'],
        'stolen': 'Millions of dollars in Bitcoin',
        'attack_complexity': 'Medium - requires knowing affected transactions',
        'mitigation': [
            'Update Android',
            'Re-generate all keys',
            'Use hardware-backed KeyStore'
        ],
        'lesson': 'Mobile platforms need special attention for RNG'
    },
    'ps3_ecdsa': {
        'name': 'PlayStation 3 ECDSA Nonce Reuse',
        'cve': 'N/A',
        'year': 2010,
        'cause': 'Static nonce (k) used in ECDSA signatures',
        'impact': 'Sony private signing key recovered',
        'consequence': 'Anyone could sign code as Sony',
        'attack_complexity': 'Mathematical - two signatures reveal private key',
        'mitigation': [
            'Use RFC 6979 deterministic nonces',
            'Never reuse nonces in DSA/ECDSA'
        ],
        'lesson': 'Random number quality is critical for DSA/ECDSA'
    },
    'cloudflare_lavarand': {
        'name': 'Cloudflare LavaRand',
        'type': 'solution',  # Not an attack
        'year': 2017,
        'description': 'Lava lamps as entropy source',
        'how_it_works': 'Camera captures chaotic lava motion',
        'used_for': 'Seeding Cloudflare edge server CSPRNGs',
        'lesson': 'Creative entropy sources can supplement hardware RNG'
    }
}


def analyze_rng_attack(attack_name: str) -> dict:
    """Explique une attaque RNG historique."""
    attack_name_lower = attack_name.lower().replace(' ', '_').replace('-', '_')

    # Direct lookup
    if attack_name_lower in RNG_ATTACKS:
        return RNG_ATTACKS[attack_name_lower]

    # Partial match
    for key, attack in RNG_ATTACKS.items():
        if attack_name_lower in key or key in attack_name_lower:
            return attack

    return {
        'error': f'Unknown attack: {attack_name}',
        'available': list(RNG_ATTACKS.keys())
    }


def detect_weak_randomness(samples: bytes) -> dict:
    """DÃ©tecte des patterns dans des donnÃ©es supposÃ©es alÃ©atoires."""
    if not samples:
        return {'error': 'No samples provided'}

    results = {
        'pattern_detected': False,
        'issues': [],
        'entropy': calculate_shannon_entropy(samples),
        'sample_size': len(samples)
    }

    # Check 1: Low entropy
    if results['entropy'] < 7.0:
        results['issues'].append({
            'type': 'low_entropy',
            'value': results['entropy'],
            'expected': '>= 7.5 for random data'
        })
        results['pattern_detected'] = True

    # Check 2: Repeating patterns (simple)
    counts = Counter(samples)
    most_common_byte, most_common_count = counts.most_common(1)[0]
    frequency = most_common_count / len(samples)

    if frequency > 0.02:  # Expected ~0.4% for uniform
        results['issues'].append({
            'type': 'byte_frequency_bias',
            'byte': hex(most_common_byte),
            'frequency': frequency,
            'expected': '~0.004 for uniform'
        })
        results['pattern_detected'] = True

    # Check 3: Sequential patterns (chunks)
    chunk_size = 2
    if len(samples) >= chunk_size * 10:
        chunks = [samples[i:i+chunk_size] for i in range(0, len(samples) - chunk_size + 1, chunk_size)]
        chunk_counts = Counter(tuple(c) for c in chunks)
        max_chunk_freq = max(chunk_counts.values()) / len(chunks)

        if max_chunk_freq > 0.01:  # Much higher than expected
            results['issues'].append({
                'type': 'chunk_pattern',
                'chunk_size': chunk_size,
                'max_frequency': max_chunk_freq
            })
            results['pattern_detected'] = True

    # Check 4: All zeros or all ones
    if samples == b'\x00' * len(samples):
        results['issues'].append({'type': 'all_zeros'})
        results['pattern_detected'] = True
    elif samples == b'\xff' * len(samples):
        results['issues'].append({'type': 'all_ones'})
        results['pattern_detected'] = True

    return results


def simulate_debian_openssl_bug() -> dict:
    """
    Simule le bug Debian OpenSSL de 2008.

    Le bug rÃ©duisait l'entropie Ã  seulement le PID du processus (15 bits).
    """
    import random

    # Simulate: Only PID used as entropy (15 bits = 32768 values)
    possible_pids = list(range(1, 32769))

    # "Generate" keys with each possible PID
    weak_keys = []
    for pid in possible_pids[:10]:  # Sample only first 10 for demo
        # Simulated key derivation with only PID as seed
        random.seed(pid)
        key_material = bytes([random.randint(0, 255) for _ in range(32)])
        weak_keys.append({
            'pid': pid,
            'key_preview': key_material[:8].hex()
        })

    return {
        'bug_description': 'OpenSSL PRNG seeded only with PID',
        'total_possible_keys': 32768,
        'bits_of_entropy': 15,
        'attack': 'Pre-compute all 32768 keys, compare with target',
        'time_to_crack': '< 1 second',
        'sample_weak_keys': weak_keys,
        'lesson': 'This is why entropy matters!'
    }


# ========================
# COLLECTE D'ENTROPIE
# ========================

def collect_system_entropy(num_bytes: int) -> bytes:
    """
    Collecte de l'entropie du systÃ¨me de maniÃ¨re sÃ»re.

    Utilise os.urandom() qui est la mÃ©thode recommandÃ©e.
    """
    # os.urandom est toujours la bonne rÃ©ponse
    return os.urandom(num_bytes)


def mix_entropy_sources(sources: list) -> bytes:
    """
    MÃ©lange plusieurs sources d'entropie via hachage.

    Cette technique est utilisÃ©e pour:
    1. Combiner des sources d'entropie faible
    2. Ajouter des donnÃ©es supplÃ©mentaires (personalization)
    3. Whitening (uniformiser la distribution)
    """
    if not sources:
        raise ValueError("At least one entropy source required")

    # ConcatÃ©ner toutes les sources
    combined = b''
    for source in sources:
        if isinstance(source, str):
            source = source.encode()
        combined += source

    # Hacher pour mixer et uniformiser
    # Utiliser SHA-512 pour avoir assez de bits
    h = hashlib.sha512()
    h.update(combined)

    # Ajouter un compteur pour extension si nÃ©cessaire
    result = h.digest()

    return result


# ========================
# POINT D'ENTRÃ‰E PRINCIPAL
# ========================

def sources_chaos(input_json: str) -> str:
    """Point d'entrÃ©e principal."""
    data = json.loads(input_json)
    results = {}

    # Calcul d'entropie
    if 'calculate_entropy' in data:
        input_data = data['calculate_entropy']
        if isinstance(input_data, str):
            input_data = bytes.fromhex(input_data) if all(c in '0123456789abcdefABCDEF' for c in input_data) else input_data.encode()
        results['entropy'] = {
            'shannon_bits_per_byte': calculate_shannon_entropy(input_data),
            'total_bits': calculate_shannon_entropy(input_data) * len(input_data),
            'max_possible': 8.0,
            'sample_size': len(input_data)
        }

    # Analyse sources systÃ¨me
    if data.get('analyze_sources'):
        results['entropy_sources'] = analyze_entropy_sources()

    # DÃ©monstration PRNG
    if 'demonstrate_prng' in data:
        results['prng_weakness'] = demonstrate_prng_weakness(data['demonstrate_prng'])

    # Ã‰valuation gÃ©nÃ©rateur
    if 'check_generator' in data:
        results['generator_analysis'] = is_csprng_safe(data['check_generator'])

    # HMAC-DRBG
    if 'hmac_drbg' in data:
        action = data['hmac_drbg'].get('action')

        if action == 'instantiate':
            entropy = bytes.fromhex(data['hmac_drbg']['entropy'])
            nonce = bytes.fromhex(data['hmac_drbg']['nonce'])
            personalization = bytes.fromhex(data['hmac_drbg'].get('personalization', ''))
            state = hmac_drbg_instantiate(entropy, nonce, personalization)
            results['hmac_drbg'] = {
                'state': {
                    'key': state['key'].hex(),
                    'value': state['value'].hex(),
                    'reseed_counter': state['reseed_counter']
                }
            }

        elif action == 'generate':
            state = {
                'key': bytes.fromhex(data['hmac_drbg']['state']['key']),
                'value': bytes.fromhex(data['hmac_drbg']['state']['value']),
                'reseed_counter': data['hmac_drbg']['state']['reseed_counter'],
                'security_strength': 256,
                'prediction_resistance': False
            }
            num_bytes = data['hmac_drbg']['num_bytes']
            random_bytes, new_state = hmac_drbg_generate(state, num_bytes)
            results['hmac_drbg'] = {
                'random_bytes': random_bytes.hex(),
                'new_state': {
                    'key': new_state['key'].hex(),
                    'value': new_state['value'].hex(),
                    'reseed_counter': new_state['reseed_counter']
                }
            }

    # Analyse d'attaque
    if 'analyze_attack' in data:
        results['attack'] = analyze_rng_attack(data['analyze_attack'])

    # DÃ©tection de faiblesse
    if 'detect_weakness' in data:
        samples = data['detect_weakness']
        if isinstance(samples, str):
            samples = bytes.fromhex(samples)
        results['weakness_analysis'] = detect_weak_randomness(samples)

    # Simulation bug Debian
    if data.get('simulate_debian'):
        results['debian_simulation'] = simulate_debian_openssl_bug()

    return json.dumps(results, indent=2)
```

### 4.10 Solutions Mutantes

```python
# Mutant A (Boundary) : Entropie toujours > 0 mÃªme pour donnÃ©es constantes
def calculate_shannon_entropy_mutant_a(data: bytes) -> float:
    if not data:
        return 0.0
    counts = Counter(data)
    total = len(data)
    entropy = 0.0
    for count in counts.values():
        p = count / total
        entropy -= p * math.log2(p + 0.0001)  # Ã‰vite log(0) mais fausse le calcul
    return entropy
# Pourquoi c'est faux : DonnÃ©es constantes devraient avoir entropie = 0

# Mutant B (Safety) : Accepte random comme sÃ»r
def is_csprng_safe_mutant_b(generator_name: str) -> dict:
    return {'safe': True}  # Tout est sÃ»r !
# Pourquoi c'est faux : random.random() n'est PAS cryptographiquement sÃ»r

# Mutant C (Logic) : HMAC-DRBG sans update aprÃ¨s generate
def hmac_drbg_generate_mutant_c(state: dict, num_bytes: int) -> tuple:
    key = state['key']
    value = state['value']
    output = b''
    while len(output) < num_bytes:
        value = hmac.new(key, value, hashlib.sha256).digest()
        output += value
    # Pas d'appel Ã  _hmac_drbg_update !
    return output[:num_bytes], state  # Ã‰tat inchangÃ©
# Pourquoi c'est faux : L'Ã©tat doit Ãªtre mis Ã  jour pour la sÃ©curitÃ© forward

# Mutant D (Resource) : DÃ©tection de patterns trop permissive
def detect_weak_randomness_mutant_d(samples: bytes) -> dict:
    entropy = calculate_shannon_entropy(samples)
    return {'pattern_detected': entropy < 1.0}  # Seuil trop bas !
# Pourquoi c'est faux : DonnÃ©es avec entropie 6 bits/byte sont dÃ©jÃ  suspectes

# Mutant E (Return) : Attaque Debian minimise l'impact
def analyze_rng_attack_mutant_e(attack_name: str) -> dict:
    if 'debian' in attack_name.lower():
        return {
            'impact': 'Minor issue',
            'bits_of_entropy': 128  # Faux !
        }
    return {}
# Pourquoi c'est faux : L'entropie Ã©tait de 15 bits, pas 128
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Entropie de Shannon** : Mesurer la qualitÃ© du hasard
2. **TRNG vs PRNG** : Vrai hasard physique vs algorithme dÃ©terministe
3. **CSPRNG** : Pourquoi la crypto a besoin de gÃ©nÃ©rateurs spÃ©ciaux
4. **HMAC-DRBG** : Comment construire un CSPRNG sÃ»r
5. **Attaques historiques** : Apprendre des erreurs passÃ©es
6. **Bonnes pratiques** : Utiliser `secrets`, jamais `random`

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION calculate_shannon_entropy QUI RETOURNE UN FLOTTANT ET PREND data QUI EST UNE SÃ‰QUENCE D'OCTETS
DÃ‰BUT FONCTION
    SI data EST VIDE ALORS
        RETOURNER 0.0
    FIN SI

    COMPTER les occurrences de chaque octet dans data
    AFFECTER la longueur de data Ã€ total

    AFFECTER 0.0 Ã€ entropy
    POUR CHAQUE count DANS les valeurs comptÃ©es FAIRE
        SI count EST SUPÃ‰RIEUR Ã€ 0 ALORS
            AFFECTER count DIVISÃ‰ PAR total Ã€ p
            AFFECTER entropy MOINS p MULTIPLIÃ‰ PAR LOG2 DE p Ã€ entropy
        FIN SI
    FIN POUR

    RETOURNER entropy
FIN FONCTION
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : HMAC-DRBG Generate
---
1. VÃ‰RIFIER le compteur de reseed
   - SI trop de gÃ©nÃ©rations â†’ ERREUR "Reseed required"

2. INITIALISER output Ã  vide

3. BOUCLE TANT QUE output est plus petit que demandÃ© :
   a. V = HMAC(K, V)
   b. AJOUTER V Ã  output

4. TRONQUER output Ã  la taille demandÃ©e

5. METTRE Ã€ JOUR l'Ã©tat :
   a. (K, V) = Update(K, V, '')
   b. INCRÃ‰MENTER reseed_counter

6. RETOURNER (output, nouvel_Ã©tat)
```

### 5.2.3.1 Logique de Garde

```
FONCTION : collect_system_entropy (num_bytes)
---
INIT rÃ©sultat = None

1. ESSAYER os.urandom(num_bytes) :
   |
   |-- SI succÃ¨s :
   |     RETOURNER les bytes collectÃ©s
   |
   |-- SI Ã©chec (rare) :
   |     ESSAYER /dev/urandom directement
   |
   |-- SI toujours Ã©chec :
   |     RETOURNER Erreur "No entropy source available"

2. VÃ‰RIFIER que les bytes ne sont pas tous zÃ©ros
   |
   |-- SI tous zÃ©ros :
   |     RETOURNER Erreur "Entropy source failure"

3. RETOURNER bytes collectÃ©s
```

### 5.3 Visualisation ASCII

```
ENTROPIE DE SHANNON
===================

DonnÃ©es constantes (entropie = 0 bits/byte)
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ A â”‚ A â”‚ A â”‚ A â”‚ A â”‚ A â”‚ A â”‚   H = -1.0 Ã— log2(1.0) = 0
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Texte anglais (entropie â‰ˆ 4 bits/byte)
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ H â”‚ e â”‚ l â”‚ l â”‚ o â”‚   â”‚ W â”‚ o â”‚   Lettres frÃ©quentes, patterns
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

DonnÃ©es compressÃ©es (entropie â‰ˆ 8 bits/byte)
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ 7aâ”‚ 3fâ”‚ 9câ”‚ 02â”‚ e8â”‚ b1â”‚ 5dâ”‚ 44â”‚   Distribution uniforme
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜


PRNG vs CSPRNG
==============

PRNG (Mersenne Twister)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚   Seed (32 bits)                                        â”‚
â”‚       â”‚                                                 â”‚
â”‚       â–¼                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  Ã‰tat interne (624 Ã— 32 bits)       â”‚               â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”             â”‚               â”‚
â”‚   â”‚  â”‚mt0â”‚mt1â”‚mt2â”‚...â”‚m623â”‚             â”‚               â”‚
â”‚   â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜             â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                     â”‚                                   â”‚
â”‚                     â–¼                                   â”‚
â”‚              Output (32 bits)                           â”‚
â”‚                                                         â”‚
â”‚   âš ï¸ Avec 624 outputs consÃ©cutifs,                      â”‚
â”‚      l'Ã©tat complet peut Ãªtre reconstruit!              â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CSPRNG (HMAC-DRBG)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚   Entropy (â‰¥256 bits) + Nonce + Personalization         â”‚
â”‚       â”‚                                                 â”‚
â”‚       â–¼                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  K = HMAC(K, V || 0x00 || seed)     â”‚               â”‚
â”‚   â”‚  V = HMAC(K, V)                     â”‚               â”‚
â”‚   â”‚  K = HMAC(K, V || 0x01 || seed)     â”‚               â”‚
â”‚   â”‚  V = HMAC(K, V)                     â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                     â”‚                                   â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚          â–¼                     â–¼                        â”‚
â”‚      K (256 bits)         V (256 bits)                  â”‚
â”‚                     â”‚                                   â”‚
â”‚                     â–¼                                   â”‚
â”‚              Output = HMAC(K, V)                        â”‚
â”‚                                                         â”‚
â”‚   âœ“ RÃ©sistant Ã  la prÃ©diction                          â”‚
â”‚   âœ“ RÃ©sistant au backtracking                          â”‚
â”‚   âœ“ Forward secrecy avec reseed                        â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


BUG DEBIAN OPENSSL
==================

Code original:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MD_Update(&m, buf, j);  // â† Entropy source â”‚
â”‚ MD_Update(&m, buf, j);  // (uninitialized)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Code Debian (buggy):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ // MD_Update(&m, buf, j);  â† REMOVED !      â”‚
â”‚ MD_Update(&m, &(pid), sizeof(pid));         â”‚
â”‚        â†‘                                    â”‚
â”‚    Seule source d'entropie : PID (15 bits)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ConsÃ©quence:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                           â”‚
â”‚   Toutes les clÃ©s possibles = 32,768 (2^15)              â”‚
â”‚                                                           â”‚
â”‚   PID 1    â†’ ClÃ© 1    (ssh-rsa AAAA...)                   â”‚
â”‚   PID 2    â†’ ClÃ© 2    (ssh-rsa AAAB...)                   â”‚
â”‚   PID 3    â†’ ClÃ© 3    (ssh-rsa AAAC...)                   â”‚
â”‚   ...                                                     â”‚
â”‚   PID 32768 â†’ ClÃ© 32768                                   â”‚
â”‚                                                           â”‚
â”‚   Attaque: GÃ©nÃ©rer toutes les clÃ©s, chercher la cible    â”‚
â”‚   Temps: < 1 seconde                                      â”‚
â”‚                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | ConsÃ©quence |
|-------|-------------|-------------|
| `random.random()` | Mersenne Twister non crypto | ClÃ©s prÃ©dictibles |
| Seed faible | Seed dÃ©rivÃ© du temps | Brute-forceable |
| Pas assez d'entropie | < 128 bits | Attaque exhaustive |
| Reseed nÃ©gligÃ© | DRBG jamais re-seedÃ© | Perd forward secrecy |
| Nonce constant | MÃªme nonce pour ECDSA | Fuite de clÃ© privÃ©e |
| /dev/random bloquant | Attente sur pool vide | DoS potentiel |

### 5.5 Cours Complet

#### 5.5.1 Entropie

**DÃ©finition** : Mesure de l'incertitude/information d'une source.

**Formule de Shannon** : H = -Î£ p(x) Ã— logâ‚‚(p(x))

- 8 bits/byte : donnÃ©es parfaitement alÃ©atoires
- 0 bits/byte : donnÃ©es constantes
- ~4 bits/byte : texte anglais

**Min-entropy** (plus conservatrice) : Hâˆ = -logâ‚‚(max(p(x)))

#### 5.5.2 Types de gÃ©nÃ©rateurs

**TRNG (True Random Number Generator)** :
- Source : PhÃ©nomÃ¨nes physiques (bruit thermique, radioactivitÃ©, timing)
- Avantage : Vraiment imprÃ©visible
- InconvÃ©nient : Lent, coÃ»teux

**PRNG (Pseudo-Random Number Generator)** :
- Algorithme dÃ©terministe
- Rapide et reproductible
- NON SÃ‰CURISÃ‰ pour la crypto

**CSPRNG (Cryptographically Secure PRNG)** :
- Impossible de distinguer de vrai hasard
- RÃ©sistant Ã  la prÃ©diction (forward security)
- RÃ©sistant au backtracking (backward security)

#### 5.5.3 HMAC-DRBG (NIST SP 800-90A)

```
Instantiate(entropy, nonce, personalization):
    K = 0x00...00 (32 bytes)
    V = 0x01...01 (32 bytes)
    (K, V) = Update(K, V, entropy || nonce || pers)

Update(K, V, provided_data):
    K = HMAC(K, V || 0x00 || provided_data)
    V = HMAC(K, V)
    K = HMAC(K, V || 0x01 || provided_data)
    V = HMAC(K, V)
    return (K, V)

Generate(state, num_bytes):
    output = ''
    while len(output) < num_bytes:
        V = HMAC(K, V)
        output += V
    (K, V) = Update(K, V, '')
    return output[:num_bytes]
```

#### 5.5.4 Bonnes pratiques Python

```python
# âœ… BON - Pour la cryptographie
import secrets
token = secrets.token_bytes(32)
password = secrets.token_urlsafe(16)

# âœ… BON - Bas niveau
import os
entropy = os.urandom(32)

# âŒ MAUVAIS - JAMAIS pour la crypto
import random
key = random.randint(0, 2**256)  # PRÃ‰DICTIBLE !

# âš ï¸ ATTENTION - SystemRandom est OK mais prÃ©fÃ©rer secrets
from random import SystemRandom
sr = SystemRandom()
```

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ import random                                                   â”‚
â”‚ key = random.randbytes(32)  # Ou getrandbits()                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ import secrets                                                  â”‚
â”‚ key = secrets.token_bytes(32)                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ random utilise Mersenne Twister (non crypto)                 â”‚
â”‚ â€¢ PrÃ©dictible avec 624 outputs consÃ©cutifs                     â”‚
â”‚ â€¢ Seed dÃ©rivable du temps â†’ brute-force facile                 â”‚
â”‚ â€¢ secrets utilise os.urandom() â†’ CSPRNG du noyau              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ Action                                         â”‚ Ã‰tat                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Collecter 256 bits d'entropie                  â”‚ entropy = os.urandom(32)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ GÃ©nÃ©rer nonce (128 bits)                       â”‚ nonce = os.urandom(16)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ HMAC-DRBG Instantiate                          â”‚ K, V initialisÃ©s            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Update(K, V, entropy||nonce)                   â”‚ K, V mis Ã  jour             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ Generate(32 bytes)                             â”‚ random_bytes produits       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   6   â”‚ Update(K, V, '')                               â”‚ Ã‰tat avancÃ© (forward sec.)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ“º MEME : "Dark" â€” La Boucle Temporelle

Dans "Dark", tout semble alÃ©atoire mais est en fait dÃ©terministe â€” Jonas est coincÃ© dans une boucle qu'il rÃ©pÃ¨te encore et encore.

**Mersenne Twister** c'est pareil : Ã§a SEMBLE alÃ©atoire, mais c'est une boucle dÃ©terministe. Si tu connais le point de dÃ©part (le seed), tu connais TOUTE la sÃ©quence â€” passÃ© et futur.

```python
# Jonas connaÃ®t le seed...
import random
random.seed(2019)  # L'annÃ©e oÃ¹ tout commence

# ... donc il connaÃ®t tout l'avenir
future = [random.random() for _ in range(1000)]
# Chaque nombre est prÃ©dÃ©terminÃ©, comme chaque Ã©vÃ©nement dans Dark
```

**CSPRNG** c'est comme briser la boucle : mÃªme si tu connais le prÃ©sent, tu ne peux pas prÃ©dire le futur (ni reconstruire le passÃ©).

#### ğŸ² MEME : "Entropy is a harsh mistress"

> "Dans un monde parfait, chaque bit serait incertain. Dans notre monde, on se bat pour chaque bit d'entropie."

```python
# Entropie parfaite (8 bits/byte)
>>> calculate_shannon_entropy(os.urandom(1000))
7.98  # Proche de 8

# Texte (faible entropie)
>>> calculate_shannon_entropy(b"Hello Hello Hello")
2.75  # Beaucoup de redondance

# Le bug Debian (catastrophe)
>>> math.log2(32768)
15.0  # Seulement 15 bits d'entropie totale !
```

### 5.9 Applications pratiques

1. **Auditer une application** : VÃ©rifier l'utilisation de `secrets` vs `random`
2. **ImplÃ©menter un wallet crypto** : GÃ©nÃ©ration sÃ©curisÃ©e de clÃ©s privÃ©es
3. **Tests de qualitÃ© RNG** : Appliquer les tests NIST SP 800-22
4. **Incident response** : DÃ©tecter si des clÃ©s ont Ã©tÃ© gÃ©nÃ©rÃ©es avec un RNG faible

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | Comment l'Ã©viter |
|---|-------|------------------|
| 1 | `random.random()` | Utiliser `secrets` |
| 2 | Seed = time() | Collecter vraie entropie |
| 3 | Entropie < 128 bits | Minimum 256 bits pour les clÃ©s |
| 4 | Pas de reseed | Reseed pÃ©riodiquement les DRBG |
| 5 | Math.random() JS | Utiliser crypto.getRandomValues() |
| 6 | /dev/random bloquant | PrÃ©fÃ©rer /dev/urandom (Linux 5.6+) |

---

## ğŸ“ SECTION 7 : QCM

**Q1:** Quelle est l'entropie de Shannon maximale en bits/byte?
A) 1  B) 4  C) 8 âœ“  D) 16

**Q2:** Pourquoi random.random() n'est pas cryptographiquement sÃ»r?
A) Trop lent  B) Mersenne Twister prÃ©dictible âœ“  C) Bugs frÃ©quents  D) Pas assez de bits

**Q3:** Combien de bits d'entropie le bug Debian laissait-il?
A) 0  B) 15 âœ“  C) 64  D) 128

**Q4:** Quel module Python utiliser pour la crypto?
A) random  B) numpy.random  C) secrets âœ“  D) math

**Q5:** Que signifie DRBG?
A) Dynamic Random Bit Generator  B) Deterministic Random Bit Generator âœ“  C) Digital Random Byte Generator  D) Distributed Random Block Generator

**Q6:** Quelle attaque a rÃ©vÃ©lÃ© une backdoor NSA dans un CSPRNG?
A) Heartbleed  B) Dual_EC_DRBG âœ“  C) BEAST  D) Debian OpenSSL

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| Exercice | 3.1.8-a : sources_chaos |
| Concepts | Entropie, TRNG, PRNG, CSPRNG, HMAC-DRBG |
| DifficultÃ© | 8/10 |
| XP | 250 |
| Bonus | ğŸ”¥ AvancÃ© (Ã—3) |

---

*Exercice gÃ©nÃ©rÃ© par HACKBRAIN v5.5.2*
