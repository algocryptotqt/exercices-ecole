# Exercice 3.1.7-b : gardiens_session

**Module :**
3.1.7 ‚Äî Protocoles Cryptographiques

**Concept :**
b ‚Äî Protocoles de session avanc√©s (Signal, Kerberos, mTLS, DNSSEC)

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Python 3.14

**Pr√©requis :**
3.1.4-c (ECC, ECDH), 3.1.5-b (HMAC), 3.1.7-a (TLS, SSH)

**Domaines :**
Crypto, Net, Struct

**Dur√©e estim√©e :**
150 min

**XP Base :**
300

**Complexit√© :**
T3 O(n √ó m) √ó S2 O(key_chain)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `gardiens_session.py`
**Autoris√© :** cryptography, hashlib, base64, secrets
**Interdit :** subprocess, pykerberos (impl√©menter la logique)

### 1.2 Consigne

**üéÆ "Severance" ‚Äî Innies vs Outies**

*"Please try to enjoy each moment as a gift."* ‚Äî Ms. Cobel

Tu es **Mark S.**, employ√© de Lumon Industries. Ta conscience est "sever√©e" ‚Äî l'Innie au travail ne sait rien de l'Outie √† l'ext√©rieur. Mais pour faire circuler des secrets entre les deux mondes, tu dois ma√Ætriser les protocoles de session les plus avanc√©s.

Le **Protocole Signal** c'est comme le Severed Floor : chaque message est isol√©, mais une cha√Æne cryptographique les relie secr√®tement.

**Kerberos** c'est comme les badges Lumon : un ticket central (le TGT) te donne acc√®s aux diff√©rents services.

**Ta mission :**

1. **Impl√©menter X3DH** (Extended Triple Diffie-Hellman) ‚Äî le handshake Signal
2. **Simuler Double Ratchet** ‚Äî le c≈ìur de Signal Protocol
3. **Mod√©liser Kerberos** ‚Äî TGT, TGS, Service Tickets
4. **Comprendre mTLS** ‚Äî mutual TLS pour les microservices
5. **Valider DNSSEC** ‚Äî cha√Æne de confiance DNS

### 1.2.2 Consigne Acad√©mique

Cet exercice couvre les protocoles de session avanc√©s utilis√©s dans les syst√®mes de communication s√©curis√©e modernes :

1. **Signal Protocol** : Protocole de messagerie avec forward secrecy et post-compromise security
2. **Kerberos** : Authentification centralis√©e par tickets
3. **mTLS** : Authentification mutuelle client-serveur
4. **DNSSEC** : Extension DNS pour l'int√©grit√© et l'authenticit√©

### 1.3 Prototype

```python
def gardiens_session(input_json: str) -> str:
    """Point d'entr√©e principal"""
    pass

# Signal Protocol - X3DH
def generate_x3dh_keys() -> dict:
    """G√©n√®re les cl√©s pour X3DH (IK, SPK, OPKs)"""
    pass

def x3dh_initiator(initiator_ik: bytes, responder_bundle: dict) -> dict:
    """Ex√©cute X3DH c√¥t√© initiateur (Alice)"""
    pass

def x3dh_responder(responder_keys: dict, initiator_message: dict) -> dict:
    """Ex√©cute X3DH c√¥t√© r√©pondeur (Bob)"""
    pass

# Signal Protocol - Double Ratchet
def initialize_double_ratchet(shared_secret: bytes, role: str) -> dict:
    """Initialise l'√©tat du Double Ratchet"""
    pass

def ratchet_encrypt(state: dict, plaintext: bytes) -> tuple:
    """Chiffre un message avec le Double Ratchet"""
    pass

def ratchet_decrypt(state: dict, header: dict, ciphertext: bytes) -> bytes:
    """D√©chiffre un message avec le Double Ratchet"""
    pass

# Kerberos
def kdc_authenticate(username: str, password: str) -> dict:
    """Simule l'authentification KDC (AS-REQ/AS-REP)"""
    pass

def request_service_ticket(tgt: dict, service: str) -> dict:
    """Demande un ticket de service (TGS-REQ/TGS-REP)"""
    pass

def validate_service_ticket(ticket: dict, service_key: bytes) -> dict:
    """Valide un ticket de service"""
    pass

def simulate_kerberoasting(ticket: dict) -> dict:
    """D√©montre l'attaque Kerberoasting"""
    pass

# mTLS
def generate_mtls_config(role: str, ca_cert: str) -> dict:
    """G√©n√®re une configuration mTLS"""
    pass

def validate_mtls_handshake(client_cert: str, server_cert: str, ca_chain: list) -> dict:
    """Valide un handshake mTLS"""
    pass

# DNSSEC
def validate_dnssec_chain(records: list, trust_anchor: str) -> dict:
    """Valide une cha√Æne DNSSEC"""
    pass

def explain_dnssec_record(record_type: str) -> dict:
    """Explique un type d'enregistrement DNSSEC"""
    pass
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Signal Protocol ‚Äî N√© de l'√âchec

Le Signal Protocol est n√© des cendres d'OTR (Off-the-Record). OTR avait un probl√®me : pas de messages offline. Moxie Marlinspike a invent√© le Double Ratchet pour r√©soudre √ßa. Aujourd'hui, WhatsApp, Facebook Messenger et Google Messages l'utilisent tous.

### Kerberos ‚Äî Le Chien √† Trois T√™tes

Kerberos tire son nom du chien √† trois t√™tes gardant les Enfers dans la mythologie grecque. Les trois "t√™tes" sont : le client, le serveur, et le KDC (Key Distribution Center).

### Kerberoasting ‚Äî L'Attaque de 2014

En 2014, Tim Medin a pr√©sent√© "Attacking Kerberos: Kicking the Guard Dog of Hades". Il a montr√© comment extraire des tickets de service et les cracker offline. Cette attaque est devenue un standard en pentest Active Directory.

---

## üìç SECTION 2.5 : DANS LA VRAIE VIE

| M√©tier | Utilisation |
|--------|-------------|
| **Security Architect** | Design de syst√®mes d'authentification (Kerberos, mTLS) |
| **Mobile Security Engineer** | Audit des impl√©mentations Signal Protocol |
| **Pentester/Red Team** | Exploitation Kerberoasting, Pass-the-Ticket |
| **DevOps/Platform Engineer** | Configuration mTLS pour microservices (Istio, Linkerd) |
| **DNS Administrator** | D√©ploiement et maintenance DNSSEC |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
gardiens_session.py  main.py

$ python main.py

$ python -c "
from gardiens_session import *
import json

# G√©n√©ration cl√©s X3DH (Bob)
bob_keys = generate_x3dh_keys()
print('Bob IK:', bob_keys['identity_key'][:32], '...')
print('Bob SPK:', bob_keys['signed_prekey'][:32], '...')
print('OPKs:', len(bob_keys['one_time_prekeys']))
"
Bob IK: b'\x04\x8a\x1b...' ...
Bob SPK: b'\x04\x7c\x2d...' ...
OPKs: 100

$ python -c "
from gardiens_session import *

# X3DH handshake complet
alice_ik = generate_x3dh_keys()
bob_bundle = generate_x3dh_keys()

# Alice initie
result = x3dh_initiator(alice_ik['identity_key_private'], {
    'identity_key': bob_bundle['identity_key'],
    'signed_prekey': bob_bundle['signed_prekey'],
    'one_time_prekey': bob_bundle['one_time_prekeys'][0]
})
print('Shared Secret (Alice):', result['shared_secret'][:16].hex(), '...')
"
Shared Secret (Alice): a3b7c9d2e5f8... ...

$ python -c "
from gardiens_session import *

# Simulation Kerberos
tgt = kdc_authenticate('mark.s', 'Lumon123!')
print('TGT valid:', tgt['valid'])
print('Realm:', tgt['realm'])

st = request_service_ticket(tgt, 'http/severed-floor.lumon.local')
print('Service Ticket:', st['service'])
"
TGT valid: True
Realm: LUMON.LOCAL
Service Ticket: http/severed-floor.lumon.local
```

---

## üíÄ SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**Difficult√© Bonus :**
üß† (11/10)

**R√©compense :**
XP √ó6

**Time Complexity attendue :**
O(n √ó log n) pour les op√©rations Kerberos sur n tickets

**Space Complexity attendue :**
O(ratchet_depth) pour le Double Ratchet

**Domaines Bonus :**
`Struct, Probas`

### 3.1.1 Consigne Bonus

**üéÆ "Severance" ‚Äî R√©veiller les Innies**

Les rebelles de Lumon ont trouv√© une faille. Tu dois impl√©menter un **analyseur de s√©curit√© complet** pour les protocoles de session.

**Ta mission :**

1. **D√©tecter les faiblesses Kerberos** : tickets avec encryption faible, SPN vuln√©rables
2. **Analyser les √©tats Double Ratchet** : d√©tecter les resets suspects
3. **Auditer DNSSEC** : d√©tecter les zones non sign√©es, algorithmes faibles
4. **Simuler des attaques** : Kerberoasting, Golden Ticket (d√©tection)

**Contraintes :**
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Analyse jusqu'√† 10,000 tickets         ‚îÇ
‚îÇ  D√©tection en O(n log n)                ‚îÇ
‚îÇ  Support de tous les etypes Kerberos    ‚îÇ
‚îÇ  G√©n√©ration de rapport d'audit          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

### 3.1.2 Prototype Bonus

```python
def analyze_kerberos_environment(tickets: list, config: dict) -> dict:
    """Analyse un environnement Kerberos complet"""
    pass

def detect_golden_ticket(ticket: dict, domain_config: dict) -> dict:
    """D√©tecte une tentative de Golden Ticket"""
    pass

def audit_double_ratchet_state(state: dict) -> dict:
    """Audite l'√©tat d'un Double Ratchet"""
    pass

def generate_security_report(analyses: dict) -> str:
    """G√©n√®re un rapport de s√©curit√© markdown"""
    pass
```

### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Kerberos | Simulation simple | Analyse d'environnement complet |
| Signal | Encryption/Decryption | Audit des √©tats |
| D√©tection | Vuln√©rabilit√©s connues | Patterns d'attaque avanc√©s |
| Output | Dict simple | Rapport de s√©curit√© |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `x3dh_keygen` | generate_x3dh_keys() | IK, SPK, 100 OPKs | 10 |
| `x3dh_handshake` | initiator + responder | Same shared secret | 15 |
| `double_ratchet_init` | shared_secret, "alice" | state with chains | 10 |
| `ratchet_encrypt_decrypt` | plaintext | Same plaintext after decrypt | 15 |
| `kdc_auth_valid` | valid creds | TGT with lifetime | 10 |
| `kdc_auth_invalid` | wrong password | error response | 5 |
| `service_ticket` | TGT, service | Valid ST | 10 |
| `kerberoasting_sim` | weak ticket | crackable: true | 10 |
| `mtls_validate` | valid certs + CA | handshake: success | 5 |
| `dnssec_valid_chain` | valid chain | valid: true | 5 |
| `dnssec_broken_chain` | missing RRSIG | valid: false, error: ... | 5 |

### 4.2 main.py de test

```python
import json
from gardiens_session import *

def test_all():
    # Test 1: X3DH key generation
    keys = generate_x3dh_keys()
    assert 'identity_key' in keys, "Missing identity key"
    assert 'identity_key_private' in keys, "Missing private IK"
    assert 'signed_prekey' in keys, "Missing SPK"
    assert 'signed_prekey_private' in keys, "Missing private SPK"
    assert len(keys.get('one_time_prekeys', [])) >= 10, "Need at least 10 OPKs"
    print("‚úÖ Test X3DH key generation: OK")

    # Test 2: X3DH handshake
    alice_keys = generate_x3dh_keys()
    bob_keys = generate_x3dh_keys()

    # Alice initiates with Bob's public bundle
    bob_bundle = {
        'identity_key': bob_keys['identity_key'],
        'signed_prekey': bob_keys['signed_prekey'],
        'signed_prekey_signature': bob_keys['signed_prekey_signature'],
        'one_time_prekey': bob_keys['one_time_prekeys'][0]
    }

    alice_result = x3dh_initiator(alice_keys, bob_bundle)
    assert 'shared_secret' in alice_result, "Missing shared secret (Alice)"
    assert 'ephemeral_key' in alice_result, "Missing ephemeral key"

    # Bob processes Alice's initial message
    alice_message = {
        'identity_key': alice_keys['identity_key'],
        'ephemeral_key': alice_result['ephemeral_key'],
        'one_time_prekey_used': bob_keys['one_time_prekeys'][0]
    }

    bob_result = x3dh_responder(bob_keys, alice_message)
    assert bob_result['shared_secret'] == alice_result['shared_secret'], "Shared secrets don't match!"
    print("‚úÖ Test X3DH handshake: OK")

    # Test 3: Double Ratchet initialization
    shared_secret = alice_result['shared_secret']
    alice_state = initialize_double_ratchet(shared_secret, 'initiator')
    bob_state = initialize_double_ratchet(shared_secret, 'responder')

    assert 'root_key' in alice_state, "Missing root key"
    assert 'sending_chain' in alice_state, "Missing sending chain"
    print("‚úÖ Test Double Ratchet init: OK")

    # Test 4: Double Ratchet encrypt/decrypt
    plaintext = b"Hello from the Severed Floor!"
    header, ciphertext = ratchet_encrypt(alice_state, plaintext)

    decrypted = ratchet_decrypt(bob_state, header, ciphertext)
    assert decrypted == plaintext, f"Decryption failed: {decrypted} != {plaintext}"
    print("‚úÖ Test Double Ratchet encrypt/decrypt: OK")

    # Test 5: Kerberos authentication
    tgt = kdc_authenticate('mark.s', 'Lumon123!')
    assert tgt.get('valid') == True, "Valid creds should return valid TGT"
    assert 'ticket' in tgt, "Missing ticket in response"
    assert 'realm' in tgt, "Missing realm"
    print("‚úÖ Test Kerberos auth valid: OK")

    # Test 6: Kerberos invalid auth
    result = kdc_authenticate('mark.s', 'wrongpassword')
    assert result.get('valid') == False, "Invalid creds should fail"
    print("‚úÖ Test Kerberos auth invalid: OK")

    # Test 7: Service ticket request
    st = request_service_ticket(tgt, 'http/severed-floor.lumon.local')
    assert st.get('valid') == True, "Service ticket should be valid"
    assert st.get('service') == 'http/severed-floor.lumon.local'
    print("‚úÖ Test Service ticket: OK")

    # Test 8: Kerberoasting simulation
    weak_ticket = {
        'encryption_type': 23,  # RC4-HMAC
        'service': 'http/legacy-app.lumon.local',
        'encrypted_part': b'\x00' * 100  # Simulated
    }
    result = simulate_kerberoasting(weak_ticket)
    assert result.get('vulnerable') == True, "RC4 ticket should be vulnerable"
    assert 'crack_time_estimate' in result
    print("‚úÖ Test Kerberoasting: OK")

    # Test 9: DNSSEC validation
    valid_chain = [
        {'type': 'DNSKEY', 'zone': '.', 'flags': 257, 'algorithm': 8},  # KSK
        {'type': 'DS', 'zone': 'com.', 'digest_type': 2},
        {'type': 'DNSKEY', 'zone': 'com.', 'flags': 256, 'algorithm': 8},  # ZSK
        {'type': 'RRSIG', 'zone': 'example.com.', 'signer': 'com.'}
    ]
    result = validate_dnssec_chain(valid_chain, '.')
    assert result.get('valid') == True
    print("‚úÖ Test DNSSEC valid chain: OK")

    # Test 10: DNSSEC broken chain
    broken_chain = [
        {'type': 'DNSKEY', 'zone': '.', 'flags': 257, 'algorithm': 8},
        {'type': 'DS', 'zone': 'com.', 'digest_type': 2},
        # Missing DNSKEY for com. and RRSIG
    ]
    result = validate_dnssec_chain(broken_chain, '.')
    assert result.get('valid') == False
    assert 'error' in result
    print("‚úÖ Test DNSSEC broken chain: OK")

    print("\n‚úÖ Tous les tests passent!")

if __name__ == "__main__":
    test_all()
```

### 4.3 Solution de r√©f√©rence

```python
import json
import hashlib
import secrets
import hmac
import struct
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass, field
from cryptography.hazmat.primitives.asymmetric import x25519, ed25519
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.backends import default_backend


# ========================
# SIGNAL PROTOCOL - X3DH
# ========================

def generate_x3dh_keys() -> dict:
    """G√©n√®re les cl√©s pour X3DH."""
    # Identity Key (long-term)
    ik_private = x25519.X25519PrivateKey.generate()
    ik_public = ik_private.public_key()

    # Signed PreKey (medium-term, signed by IK)
    spk_private = x25519.X25519PrivateKey.generate()
    spk_public = spk_private.public_key()

    # Sign SPK with Ed25519 (in practice, derived from IK)
    signing_key = ed25519.Ed25519PrivateKey.generate()
    spk_bytes = spk_public.public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw
    )
    spk_signature = signing_key.sign(spk_bytes)

    # One-Time PreKeys (ephemeral)
    one_time_prekeys = []
    one_time_prekeys_private = []
    for i in range(100):
        opk_private = x25519.X25519PrivateKey.generate()
        opk_public = opk_private.public_key()
        one_time_prekeys.append(opk_public.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        ))
        one_time_prekeys_private.append(opk_private)

    return {
        'identity_key': ik_public.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        ),
        'identity_key_private': ik_private,
        'signed_prekey': spk_bytes,
        'signed_prekey_private': spk_private,
        'signed_prekey_signature': spk_signature,
        'signing_key': signing_key,
        'one_time_prekeys': one_time_prekeys,
        'one_time_prekeys_private': one_time_prekeys_private
    }


def x3dh_initiator(initiator_keys: dict, responder_bundle: dict) -> dict:
    """Ex√©cute X3DH c√¥t√© initiateur (Alice)."""
    # Generate ephemeral key
    ek_private = x25519.X25519PrivateKey.generate()
    ek_public = ek_private.public_key()

    # Load responder's public keys
    ik_b = x25519.X25519PublicKey.from_public_bytes(responder_bundle['identity_key'])
    spk_b = x25519.X25519PublicKey.from_public_bytes(responder_bundle['signed_prekey'])

    # Get initiator's private identity key
    ik_a_private = initiator_keys['identity_key_private']

    # DH calculations:
    # DH1 = DH(IK_A, SPK_B)
    dh1 = ik_a_private.exchange(spk_b)

    # DH2 = DH(EK_A, IK_B)
    dh2 = ek_private.exchange(ik_b)

    # DH3 = DH(EK_A, SPK_B)
    dh3 = ek_private.exchange(spk_b)

    # DH4 = DH(EK_A, OPK_B) if OPK available
    dh4 = b''
    if 'one_time_prekey' in responder_bundle and responder_bundle['one_time_prekey']:
        opk_b = x25519.X25519PublicKey.from_public_bytes(responder_bundle['one_time_prekey'])
        dh4 = ek_private.exchange(opk_b)

    # Combine: SK = KDF(DH1 || DH2 || DH3 || DH4)
    dh_concat = dh1 + dh2 + dh3 + dh4

    shared_secret = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b'\x00' * 32,
        info=b'X3DH',
        backend=default_backend()
    ).derive(dh_concat)

    return {
        'shared_secret': shared_secret,
        'ephemeral_key': ek_public.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        ),
        'used_one_time_prekey': responder_bundle.get('one_time_prekey')
    }


def x3dh_responder(responder_keys: dict, initiator_message: dict) -> dict:
    """Ex√©cute X3DH c√¥t√© r√©pondeur (Bob)."""
    # Load initiator's public keys
    ik_a = x25519.X25519PublicKey.from_public_bytes(initiator_message['identity_key'])
    ek_a = x25519.X25519PublicKey.from_public_bytes(initiator_message['ephemeral_key'])

    # Get responder's private keys
    ik_b_private = responder_keys['identity_key_private']
    spk_b_private = responder_keys['signed_prekey_private']

    # DH calculations (mirrored):
    # DH1 = DH(SPK_B, IK_A)
    dh1 = spk_b_private.exchange(ik_a)

    # DH2 = DH(IK_B, EK_A)
    dh2 = ik_b_private.exchange(ek_a)

    # DH3 = DH(SPK_B, EK_A)
    dh3 = spk_b_private.exchange(ek_a)

    # DH4 if OPK was used
    dh4 = b''
    if initiator_message.get('one_time_prekey_used'):
        # Find the matching OPK private key
        opk_used = initiator_message['one_time_prekey_used']
        for i, opk_pub in enumerate(responder_keys['one_time_prekeys']):
            if opk_pub == opk_used:
                opk_private = responder_keys['one_time_prekeys_private'][i]
                dh4 = opk_private.exchange(ek_a)
                break

    # Combine
    dh_concat = dh1 + dh2 + dh3 + dh4

    shared_secret = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b'\x00' * 32,
        info=b'X3DH',
        backend=default_backend()
    ).derive(dh_concat)

    return {
        'shared_secret': shared_secret
    }


# ===========================
# SIGNAL PROTOCOL - DOUBLE RATCHET
# ===========================

def initialize_double_ratchet(shared_secret: bytes, role: str) -> dict:
    """Initialise l'√©tat du Double Ratchet."""
    # Derive initial keys from shared secret
    root_key = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b'\x00' * 32,
        info=b'DoubleRatchetRootKey',
        backend=default_backend()
    ).derive(shared_secret)

    # Generate initial DH ratchet key pair
    dh_private = x25519.X25519PrivateKey.generate()
    dh_public = dh_private.public_key()

    state = {
        'root_key': root_key,
        'dh_private': dh_private,
        'dh_public': dh_public.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        ),
        'dh_remote': None,
        'sending_chain': None,
        'receiving_chain': None,
        'sending_count': 0,
        'receiving_count': 0,
        'previous_sending_count': 0,
        'role': role,
        'skipped_keys': {}
    }

    if role == 'initiator':
        # Initiator starts with sending chain
        state['sending_chain'] = _kdf_chain_key(root_key, b'SendingChain')
    else:
        # Responder waits for first message
        state['receiving_chain'] = _kdf_chain_key(root_key, b'ReceivingChain')

    return state


def _kdf_chain_key(chain_key: bytes, info: bytes) -> bytes:
    """Derive next chain key."""
    return HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b'\x00' * 32,
        info=info,
        backend=default_backend()
    ).derive(chain_key)


def _kdf_message_key(chain_key: bytes) -> tuple:
    """Derive message key and next chain key."""
    derived = HKDF(
        algorithm=hashes.SHA256(),
        length=64,
        salt=b'\x00' * 32,
        info=b'MessageKey',
        backend=default_backend()
    ).derive(chain_key)

    return derived[:32], derived[32:]  # message_key, next_chain_key


def ratchet_encrypt(state: dict, plaintext: bytes) -> tuple:
    """Chiffre un message avec le Double Ratchet."""
    # Get message key from sending chain
    if state['sending_chain'] is None:
        # Need to perform DH ratchet step first
        _dh_ratchet_step(state)

    message_key, next_chain = _kdf_message_key(state['sending_chain'])
    state['sending_chain'] = next_chain
    state['sending_count'] += 1

    # Encrypt with AES-GCM
    aesgcm = AESGCM(message_key)
    nonce = secrets.token_bytes(12)
    ciphertext = aesgcm.encrypt(nonce, plaintext, None)

    # Header
    header = {
        'dh_public': state['dh_public'],
        'previous_count': state['previous_sending_count'],
        'message_number': state['sending_count'],
        'nonce': nonce
    }

    return header, ciphertext


def ratchet_decrypt(state: dict, header: dict, ciphertext: bytes) -> bytes:
    """D√©chiffre un message avec le Double Ratchet."""
    # Check if we need to do a DH ratchet step
    if header['dh_public'] != state.get('dh_remote'):
        # Perform DH ratchet
        state['dh_remote'] = header['dh_public']
        state['previous_sending_count'] = state['sending_count']
        state['sending_count'] = 0

        # Calculate new root key and receiving chain
        dh_remote = x25519.X25519PublicKey.from_public_bytes(header['dh_public'])
        dh_output = state['dh_private'].exchange(dh_remote)

        new_root = HKDF(
            algorithm=hashes.SHA256(),
            length=64,
            salt=b'\x00' * 32,
            info=b'RatchetStep',
            backend=default_backend()
        ).derive(state['root_key'] + dh_output)

        state['root_key'] = new_root[:32]
        state['receiving_chain'] = new_root[32:]

        # Generate new DH key pair for next send
        new_dh = x25519.X25519PrivateKey.generate()
        state['dh_private'] = new_dh
        state['dh_public'] = new_dh.public_key().public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        )

        # New sending chain
        dh_output2 = new_dh.exchange(dh_remote)
        send_root = HKDF(
            algorithm=hashes.SHA256(),
            length=64,
            salt=b'\x00' * 32,
            info=b'RatchetStep',
            backend=default_backend()
        ).derive(state['root_key'] + dh_output2)

        state['root_key'] = send_root[:32]
        state['sending_chain'] = send_root[32:]

    # Skip any missed messages
    while state['receiving_count'] < header['message_number'] - 1:
        message_key, state['receiving_chain'] = _kdf_message_key(state['receiving_chain'])
        state['skipped_keys'][(header['dh_public'], state['receiving_count'])] = message_key
        state['receiving_count'] += 1

    # Get message key
    message_key, state['receiving_chain'] = _kdf_message_key(state['receiving_chain'])
    state['receiving_count'] += 1

    # Decrypt
    aesgcm = AESGCM(message_key)
    plaintext = aesgcm.decrypt(header['nonce'], ciphertext, None)

    return plaintext


def _dh_ratchet_step(state: dict):
    """Perform a DH ratchet step for sending."""
    if state['dh_remote']:
        dh_remote = x25519.X25519PublicKey.from_public_bytes(state['dh_remote'])
        dh_output = state['dh_private'].exchange(dh_remote)

        derived = HKDF(
            algorithm=hashes.SHA256(),
            length=64,
            salt=b'\x00' * 32,
            info=b'RatchetStep',
            backend=default_backend()
        ).derive(state['root_key'] + dh_output)

        state['root_key'] = derived[:32]
        state['sending_chain'] = derived[32:]


# ========================
# KERBEROS
# ========================

# Encryption types
ETYPE_AES256_CTS_HMAC_SHA1 = 18
ETYPE_AES128_CTS_HMAC_SHA1 = 17
ETYPE_RC4_HMAC = 23  # Vulnerable to Kerberoasting

# Simulated KDC database
KDC_DB = {
    'mark.s': {
        'password_hash': hashlib.sha256(b'Lumon123!').digest(),
        'groups': ['severed-employees', 'mdg']
    },
    'helly.r': {
        'password_hash': hashlib.sha256(b'Eagan2024!').digest(),
        'groups': ['severed-employees']
    }
}

SERVICES_DB = {
    'http/severed-floor.lumon.local': {
        'key': secrets.token_bytes(32),
        'etype': ETYPE_AES256_CTS_HMAC_SHA1
    },
    'http/legacy-app.lumon.local': {
        'key': secrets.token_bytes(16),
        'etype': ETYPE_RC4_HMAC  # Weak!
    }
}


def kdc_authenticate(username: str, password: str) -> dict:
    """Simule l'authentification KDC (AS-REQ/AS-REP)."""
    # Check credentials
    user = KDC_DB.get(username)
    if not user:
        return {'valid': False, 'error': 'KDC_ERR_C_PRINCIPAL_UNKNOWN'}

    password_hash = hashlib.sha256(password.encode()).digest()
    if password_hash != user['password_hash']:
        return {'valid': False, 'error': 'KDC_ERR_PREAUTH_FAILED'}

    # Generate TGT
    import time
    now = int(time.time())

    tgt_data = {
        'cname': username,
        'crealm': 'LUMON.LOCAL',
        'authtime': now,
        'starttime': now,
        'endtime': now + 36000,  # 10 hours
        'renew_till': now + 604800,  # 7 days
        'flags': ['initial', 'pre-authent', 'renewable']
    }

    # Encrypt TGT with KRBTGT key (simulated)
    krbtgt_key = secrets.token_bytes(32)
    tgt_encrypted = _encrypt_kerberos(json.dumps(tgt_data).encode(), krbtgt_key)

    # Session key for client
    session_key = secrets.token_bytes(32)

    return {
        'valid': True,
        'ticket': {
            'tkt_vno': 5,
            'realm': 'LUMON.LOCAL',
            'sname': 'krbtgt/LUMON.LOCAL',
            'enc_part': tgt_encrypted,
            'etype': ETYPE_AES256_CTS_HMAC_SHA1
        },
        'session_key': session_key,
        'realm': 'LUMON.LOCAL',
        'cname': username,
        'authtime': now,
        'endtime': now + 36000
    }


def _encrypt_kerberos(data: bytes, key: bytes) -> bytes:
    """Simulated Kerberos encryption."""
    # In real Kerberos, this uses AES-CTS-HMAC-SHA1
    aesgcm = AESGCM(key[:32] if len(key) >= 32 else key.ljust(32, b'\x00'))
    nonce = secrets.token_bytes(12)
    return nonce + aesgcm.encrypt(nonce, data, None)


def _decrypt_kerberos(data: bytes, key: bytes) -> bytes:
    """Simulated Kerberos decryption."""
    aesgcm = AESGCM(key[:32] if len(key) >= 32 else key.ljust(32, b'\x00'))
    nonce = data[:12]
    return aesgcm.decrypt(nonce, data[12:], None)


def request_service_ticket(tgt: dict, service: str) -> dict:
    """Demande un ticket de service (TGS-REQ/TGS-REP)."""
    if not tgt.get('valid'):
        return {'valid': False, 'error': 'Invalid TGT'}

    service_info = SERVICES_DB.get(service)
    if not service_info:
        return {'valid': False, 'error': 'KDC_ERR_S_PRINCIPAL_UNKNOWN'}

    import time
    now = int(time.time())

    # Service ticket data
    st_data = {
        'cname': tgt.get('cname'),
        'crealm': tgt.get('realm'),
        'sname': service,
        'authtime': tgt.get('authtime'),
        'starttime': now,
        'endtime': min(tgt.get('endtime', now + 36000), now + 36000),
        'flags': ['forwardable', 'renewable']
    }

    # Encrypt with service key
    st_encrypted = _encrypt_kerberos(json.dumps(st_data).encode(), service_info['key'])

    # Session key for service
    service_session_key = secrets.token_bytes(32)

    return {
        'valid': True,
        'ticket': {
            'tkt_vno': 5,
            'realm': 'LUMON.LOCAL',
            'sname': service,
            'enc_part': st_encrypted,
            'etype': service_info['etype']
        },
        'service': service,
        'session_key': service_session_key,
        'endtime': st_data['endtime']
    }


def validate_service_ticket(ticket: dict, service_key: bytes) -> dict:
    """Valide un ticket de service."""
    try:
        decrypted = _decrypt_kerberos(ticket['enc_part'], service_key)
        data = json.loads(decrypted.decode())

        import time
        now = int(time.time())

        if data['endtime'] < now:
            return {'valid': False, 'error': 'Ticket expired'}

        return {
            'valid': True,
            'client': data['cname'],
            'realm': data['crealm'],
            'expires': data['endtime']
        }
    except Exception as e:
        return {'valid': False, 'error': str(e)}


def simulate_kerberoasting(ticket: dict) -> dict:
    """D√©montre l'attaque Kerberoasting."""
    etype = ticket.get('encryption_type', ticket.get('etype', 0))

    if etype == ETYPE_RC4_HMAC:
        # RC4 is vulnerable - can be cracked offline
        # Estimate crack time based on password complexity
        crack_estimates = {
            'weak_password': '< 1 hour',
            'medium_password': '1-24 hours',
            'strong_password': '1-7 days',
            'complex_password': '> 1 month'
        }

        return {
            'vulnerable': True,
            'encryption_type': 'RC4-HMAC (etype 23)',
            'attack': 'Kerberoasting',
            'method': 'Offline dictionary/brute-force attack on service ticket',
            'crack_time_estimate': crack_estimates,
            'mitigation': [
                'Use AES encryption (etype 17/18)',
                'Use long, complex service account passwords',
                'Use gMSA (Group Managed Service Accounts)',
                'Monitor for excessive TGS requests'
            ]
        }
    else:
        return {
            'vulnerable': False,
            'encryption_type': f'AES (etype {etype})',
            'note': 'AES-based tickets are significantly harder to crack'
        }


# ========================
# mTLS
# ========================

def generate_mtls_config(role: str, ca_cert: str) -> dict:
    """G√©n√®re une configuration mTLS."""
    if role == 'server':
        return {
            'ssl_certificate': '/etc/ssl/certs/server.crt',
            'ssl_certificate_key': '/etc/ssl/private/server.key',
            'ssl_client_certificate': ca_cert,
            'ssl_verify_client': 'on',
            'ssl_verify_depth': 2,
            'ssl_protocols': 'TLSv1.2 TLSv1.3',
            'ssl_ciphers': 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384',
            'ssl_prefer_server_ciphers': 'on'
        }
    elif role == 'client':
        return {
            'cert': '/etc/ssl/certs/client.crt',
            'key': '/etc/ssl/private/client.key',
            'ca_bundle': ca_cert,
            'verify': True,
            'verify_hostname': True
        }
    else:
        return {'error': 'Invalid role'}


def validate_mtls_handshake(client_cert: str, server_cert: str, ca_chain: list) -> dict:
    """Valide un handshake mTLS."""
    # Simplified validation logic
    issues = []

    # Check certificate chain
    if not ca_chain:
        issues.append('Empty CA chain')

    # Check client cert
    if not client_cert:
        issues.append('Missing client certificate')

    # Check server cert
    if not server_cert:
        issues.append('Missing server certificate')

    # In real implementation: verify signatures, expiry, revocation

    if issues:
        return {
            'handshake': 'failed',
            'issues': issues
        }

    return {
        'handshake': 'success',
        'mutual_auth': True,
        'client_authenticated': True,
        'server_authenticated': True,
        'forward_secrecy': True
    }


# ========================
# DNSSEC
# ========================

DNSSEC_ALGORITHMS = {
    5: {'name': 'RSASHA1', 'status': 'deprecated', 'secure': False},
    7: {'name': 'RSASHA1-NSEC3-SHA1', 'status': 'deprecated', 'secure': False},
    8: {'name': 'RSASHA256', 'status': 'recommended', 'secure': True},
    10: {'name': 'RSASHA512', 'status': 'acceptable', 'secure': True},
    13: {'name': 'ECDSAP256SHA256', 'status': 'recommended', 'secure': True},
    14: {'name': 'ECDSAP384SHA384', 'status': 'recommended', 'secure': True},
    15: {'name': 'ED25519', 'status': 'recommended', 'secure': True},
    16: {'name': 'ED448', 'status': 'acceptable', 'secure': True}
}


def validate_dnssec_chain(records: list, trust_anchor: str) -> dict:
    """Valide une cha√Æne DNSSEC."""
    if not records:
        return {'valid': False, 'error': 'Empty record chain'}

    # Need: DNSKEY for root, DS for each delegation, RRSIG for data
    has_root_key = False
    zones_covered = set()
    signatures_found = []
    issues = []

    for record in records:
        rtype = record.get('type')
        zone = record.get('zone', '')

        if rtype == 'DNSKEY':
            flags = record.get('flags', 0)
            algo = record.get('algorithm', 0)

            if zone == trust_anchor:
                if flags == 257:  # KSK
                    has_root_key = True
                zones_covered.add(zone)

            # Check algorithm security
            algo_info = DNSSEC_ALGORITHMS.get(algo, {})
            if algo_info and not algo_info.get('secure', True):
                issues.append(f'Weak algorithm {algo_info.get("name")} used for {zone}')

        elif rtype == 'DS':
            zones_covered.add(zone)
            digest_type = record.get('digest_type', 0)
            if digest_type == 1:  # SHA-1
                issues.append(f'SHA-1 digest for DS record in {zone} (should use SHA-256)')

        elif rtype == 'RRSIG':
            signer = record.get('signer', '')
            signatures_found.append({'zone': zone, 'signer': signer})

    # Validate chain completeness
    if not has_root_key:
        return {'valid': False, 'error': 'Missing root DNSKEY (KSK)'}

    if not signatures_found:
        return {'valid': False, 'error': 'No RRSIG records found'}

    # Check all signatures have valid signers
    for sig in signatures_found:
        if sig['signer'] not in zones_covered:
            return {'valid': False, 'error': f'RRSIG signer {sig["signer"]} not in chain'}

    return {
        'valid': True,
        'zones': list(zones_covered),
        'signatures': len(signatures_found),
        'issues': issues if issues else None
    }


def explain_dnssec_record(record_type: str) -> dict:
    """Explique un type d'enregistrement DNSSEC."""
    records = {
        'DNSKEY': {
            'description': 'Public key for zone signing',
            'flags': {
                256: 'ZSK (Zone Signing Key) - signs records',
                257: 'KSK (Key Signing Key) - signs DNSKEY RRset'
            },
            'format': 'flags protocol algorithm public_key'
        },
        'DS': {
            'description': 'Delegation Signer - hash of child DNSKEY',
            'purpose': 'Links parent zone to child zone DNSKEY',
            'format': 'key_tag algorithm digest_type digest',
            'digest_types': {
                1: 'SHA-1 (deprecated)',
                2: 'SHA-256 (recommended)',
                4: 'SHA-384'
            }
        },
        'RRSIG': {
            'description': 'Resource Record Signature',
            'purpose': 'Cryptographic signature over an RRset',
            'format': 'type_covered algorithm labels original_ttl expiration inception key_tag signer signature'
        },
        'NSEC': {
            'description': 'Next Secure record',
            'purpose': 'Proves non-existence of a name (linked list)',
            'issue': 'Allows zone enumeration (walking)'
        },
        'NSEC3': {
            'description': 'Next Secure v3',
            'purpose': 'Hashed proof of non-existence',
            'advantage': 'Prevents zone enumeration',
            'format': 'hash_algorithm flags iterations salt next_hashed_owner types'
        }
    }

    return records.get(record_type.upper(), {'error': f'Unknown record type: {record_type}'})


# ========================
# MAIN ENTRY POINT
# ========================

def gardiens_session(input_json: str) -> str:
    """Point d'entr√©e principal."""
    data = json.loads(input_json)
    results = {}

    # X3DH key generation
    if data.get('generate_x3dh'):
        keys = generate_x3dh_keys()
        results['x3dh_keys'] = {
            'identity_key': keys['identity_key'].hex(),
            'signed_prekey': keys['signed_prekey'].hex(),
            'one_time_prekeys_count': len(keys['one_time_prekeys'])
        }

    # Kerberos authentication
    if 'kerberos_auth' in data:
        auth = data['kerberos_auth']
        results['kerberos'] = kdc_authenticate(auth['username'], auth['password'])
        # Don't include actual keys in output
        if 'session_key' in results['kerberos']:
            results['kerberos']['session_key'] = '<redacted>'

    # Service ticket
    if 'request_service_ticket' in data:
        req = data['request_service_ticket']
        # Need a valid TGT first
        tgt = kdc_authenticate(req['username'], req['password'])
        if tgt['valid']:
            results['service_ticket'] = request_service_ticket(tgt, req['service'])
            if 'session_key' in results['service_ticket']:
                results['service_ticket']['session_key'] = '<redacted>'
        else:
            results['service_ticket'] = {'error': 'Invalid TGT'}

    # Kerberoasting simulation
    if 'simulate_kerberoast' in data:
        results['kerberoasting'] = simulate_kerberoasting(data['simulate_kerberoast'])

    # mTLS config
    if 'mtls_config' in data:
        cfg = data['mtls_config']
        results['mtls'] = generate_mtls_config(cfg['role'], cfg.get('ca_cert', ''))

    # DNSSEC validation
    if 'validate_dnssec' in data:
        results['dnssec'] = validate_dnssec_chain(
            data['validate_dnssec']['records'],
            data['validate_dnssec'].get('trust_anchor', '.')
        )

    # DNSSEC record explanation
    if 'explain_dnssec' in data:
        results['dnssec_explained'] = explain_dnssec_record(data['explain_dnssec'])

    return json.dumps(results, indent=2, default=str)
```

### 4.10 Solutions Mutantes

```python
# Mutant A (Boundary) : X3DH sans OPK dans le calcul
def x3dh_initiator_mutant_a(initiator_keys: dict, responder_bundle: dict) -> dict:
    # ... DH1, DH2, DH3 ...
    # Oublie DH4 avec OPK !
    dh_concat = dh1 + dh2 + dh3  # Pas de dh4
    # ...
# Pourquoi c'est faux : Le shared secret ne correspondra pas si Bob utilise l'OPK

# Mutant B (Safety) : Kerberos accepte n'importe quel mot de passe
def kdc_authenticate_mutant_b(username: str, password: str) -> dict:
    user = KDC_DB.get(username)
    if not user:
        return {'valid': False, 'error': 'User not found'}
    # Pas de v√©rification du mot de passe !
    return {'valid': True, 'ticket': {...}}
# Pourquoi c'est faux : N'importe qui peut obtenir un TGT pour n'importe quel user

# Mutant C (Logic) : Double Ratchet ne fait pas de ratchet DH
def ratchet_decrypt_mutant_c(state: dict, header: dict, ciphertext: bytes) -> bytes:
    # Ignore le changement de cl√© DH !
    # if header['dh_public'] != state.get('dh_remote'):
    #     ... DH ratchet step ...
    message_key, state['receiving_chain'] = _kdf_message_key(state['receiving_chain'])
    # ...
# Pourquoi c'est faux : Perd la forward secrecy et la post-compromise security

# Mutant D (Resource) : DNSSEC accepte SHA-1 DS sans warning
def validate_dnssec_chain_mutant_d(records: list, trust_anchor: str) -> dict:
    for record in records:
        if record.get('type') == 'DS':
            # Pas de v√©rification du digest_type !
            pass
    return {'valid': True}
# Pourquoi c'est faux : SHA-1 est vuln√©rable aux collisions

# Mutant E (Return) : Kerberoasting ne d√©tecte pas RC4
def simulate_kerberoasting_mutant_e(ticket: dict) -> dict:
    return {'vulnerable': False}  # Toujours "s√ªr"
# Pourquoi c'est faux : RC4 tickets sont triviallement crackables
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Signal Protocol** : Forward secrecy et post-compromise security
2. **X3DH** : Comment √©tablir une session sans rencontre synchrone
3. **Double Ratchet** : Renouvellement continu des cl√©s
4. **Kerberos** : Authentification centralis√©e par tickets
5. **mTLS** : Authentification mutuelle pour microservices
6. **DNSSEC** : Extension de s√©curit√© DNS

### 5.2 LDA ‚Äî Traduction Litt√©rale

```
FONCTION x3dh_initiator QUI RETOURNE UN DICTIONNAIRE ET PREND initiator_keys ET responder_bundle
D√âBUT FONCTION
    G√âN√âRER une cl√© √©ph√©m√®re EK

    CHARGER les cl√©s publiques de responder :
        - IK_B (Identity Key)
        - SPK_B (Signed PreKey)
        - OPK_B (One-Time PreKey, si disponible)

    CALCULER les quatre Diffie-Hellman :
        DH1 ‚Üê DH(IK_A_priv√©e, SPK_B)
        DH2 ‚Üê DH(EK_priv√©e, IK_B)
        DH3 ‚Üê DH(EK_priv√©e, SPK_B)
        DH4 ‚Üê DH(EK_priv√©e, OPK_B) SI OPK disponible

    CONCAT√âNER les r√©sultats DH
    D√âRIVER le secret partag√© avec HKDF

    RETOURNER {shared_secret, ephemeral_key}
FIN FONCTION
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Signal X3DH Handshake
---
1. Alice g√©n√®re ses cl√©s X3DH (IK_A, SPK_A, OPKs)
2. Bob g√©n√®re ses cl√©s X3DH (IK_B, SPK_B, OPKs)

3. Bob publie son "Prekey Bundle" sur le serveur :
   - Identity Key publique
   - Signed PreKey + signature
   - One-Time PreKeys

4. Alice t√©l√©charge le bundle de Bob

5. Alice calcule :
   DH1 = ECDH(IK_A, SPK_B)  ‚Üê Prouve identit√© Alice
   DH2 = ECDH(EK_A, IK_B)   ‚Üê Prouve identit√© Bob
   DH3 = ECDH(EK_A, SPK_B)  ‚Üê Forward secrecy
   DH4 = ECDH(EK_A, OPK_B)  ‚Üê One-time protection

6. SK = KDF(DH1 || DH2 || DH3 || DH4)

7. Alice envoie √† Bob :
   - Sa cl√© d'identit√© IK_A
   - Sa cl√© √©ph√©m√®re EK_A
   - Quel OPK elle a utilis√©
   - Premier message chiffr√© avec SK
```

### 5.3 Visualisation ASCII

```
SIGNAL PROTOCOL - X3DH
======================

Alice                        Server                         Bob
  ‚îÇ                            ‚îÇ                              ‚îÇ
  ‚îÇ     Publish Prekey Bundle  ‚îÇ                              ‚îÇ
  ‚îÇ                            ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ {IK_B, SPK_B, OPKs} ‚îÄ‚îÄ‚îÇ
  ‚îÇ                            ‚îÇ                              ‚îÇ
  ‚îÇ‚îÄ‚îÄ Request Bob's Bundle ‚îÄ‚îÄ‚îÄ>‚îÇ                              ‚îÇ
  ‚îÇ<‚îÄ‚îÄ {IK_B, SPK_B, OPK_0} ‚îÄ‚îÄ‚îÇ                              ‚îÇ
  ‚îÇ                            ‚îÇ                              ‚îÇ
  ‚îÇ Calculate:                 ‚îÇ                              ‚îÇ
  ‚îÇ DH1 = ECDH(IK_A, SPK_B)   ‚îÇ                              ‚îÇ
  ‚îÇ DH2 = ECDH(EK_A, IK_B)    ‚îÇ                              ‚îÇ
  ‚îÇ DH3 = ECDH(EK_A, SPK_B)   ‚îÇ                              ‚îÇ
  ‚îÇ DH4 = ECDH(EK_A, OPK_0)   ‚îÇ                              ‚îÇ
  ‚îÇ SK = KDF(DH1||DH2||DH3||DH4)                              ‚îÇ
  ‚îÇ                            ‚îÇ                              ‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Initial Message ‚îÄ‚îÄ‚îÄ>‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Forward to Bob ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ    {IK_A, EK_A, OPK_used,  ‚îÇ                              ‚îÇ
  ‚îÇ     Encrypt_SK(plaintext)} ‚îÇ                              ‚îÇ
  ‚îÇ                            ‚îÇ                              ‚îÇ
  ‚îÇ                            ‚îÇ         Bob calculates same  ‚îÇ
  ‚îÇ                            ‚îÇ         SK using his private ‚îÇ
  ‚îÇ                            ‚îÇ         keys: IK_B, SPK_B,   ‚îÇ
  ‚îÇ                            ‚îÇ         OPK_0                ‚îÇ


DOUBLE RATCHET
==============

      Alice                                          Bob
        ‚îÇ                                              ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇRoot Key ‚îÇ                                    ‚îÇRoot Key ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                                              ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê   DH Ratchet   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
   ‚îÇDH Key A1‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                 ‚îÇ     ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ   New Root Key   ‚îÇ     ‚îÇ
        ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇSending Chain‚îÇ                              ‚îÇReceiving    ‚îÇ
   ‚îÇ  Key        ‚îÇ                              ‚îÇChain Key    ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                                            ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇMsg Key 1‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Encrypted Message ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇMsg Key 1‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                                            ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇMsg Key 2‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Encrypted Message ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇMsg Key 2‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


KERBEROS FLOW
=============

  Client                    KDC                    Service
    ‚îÇ                        ‚îÇ                        ‚îÇ
    ‚îÇ‚îÄ‚îÄ AS-REQ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                        ‚îÇ
    ‚îÇ   (username, timestamp)‚îÇ                        ‚îÇ
    ‚îÇ                        ‚îÇ                        ‚îÇ
    ‚îÇ<‚îÄ‚îÄ AS-REP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                        ‚îÇ
    ‚îÇ   (TGT, session key)   ‚îÇ                        ‚îÇ
    ‚îÇ                        ‚îÇ                        ‚îÇ
    ‚îÇ‚îÄ‚îÄ TGS-REQ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                        ‚îÇ
    ‚îÇ   (TGT, service name)  ‚îÇ                        ‚îÇ
    ‚îÇ                        ‚îÇ                        ‚îÇ
    ‚îÇ<‚îÄ‚îÄ TGS-REP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                        ‚îÇ
    ‚îÇ   (Service Ticket)     ‚îÇ                        ‚îÇ
    ‚îÇ                        ‚îÇ                        ‚îÇ
    ‚îÇ‚îÄ‚îÄ AP-REQ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ   (Service Ticket)     ‚îÇ                        ‚îÇ
    ‚îÇ                        ‚îÇ                        ‚îÇ
    ‚îÇ<‚îÄ‚îÄ AP-REP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
    ‚îÇ   (authentication ok)  ‚îÇ                        ‚îÇ


DNSSEC CHAIN OF TRUST
=====================

                    Root (.)
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇ DNSKEY KSK ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ Trust Anchor
                 ‚îÇ DNSKEY ZSK ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ signs
                       ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ DS for .com    ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ points to
                       ‚ñº
                   com.
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ DNSKEY KSK ‚îÇ
              ‚îÇ DNSKEY ZSK ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ signs
                    ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ DS for example ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚ñº
              example.com.
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ DNSKEY KSK ‚îÇ
           ‚îÇ DNSKEY ZSK ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ signs
                 ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ A/AAAA/MX... ‚îÇ
          ‚îÇ + RRSIG      ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.4 Les pi√®ges en d√©tail

| Pi√®ge | Description | Cons√©quence |
|-------|-------------|-------------|
| OPK r√©utilis√© | Signal : r√©utiliser un One-Time PreKey | Perte de protection one-time |
| Pas de DH ratchet | Double Ratchet sans renouvellement DH | Perte forward secrecy |
| RC4 Kerberos | Tickets avec encryption type 23 | Kerberoasting trivial |
| TGT vol√© | Pas de protection du TGT | Pass-the-Ticket attack |
| DS SHA-1 | DNSSEC avec digest SHA-1 | Vuln√©rable aux collisions |
| mTLS sans CRL/OCSP | Pas de v√©rification r√©vocation | Certs r√©voqu√©s accept√©s |

### 5.5 Cours Complet

#### 5.5.1 Signal Protocol

**X3DH (Extended Triple Diffie-Hellman)** r√©sout le probl√®me du handshake asynchrone :
- Alice peut initier une session avec Bob m√™me si Bob est offline
- Bob publie des "prekeys" sur un serveur central
- Quatre DH garantissent : identit√© mutuelle + forward secrecy + one-time protection

**Double Ratchet** maintient la s√©curit√© dans le temps :
- **DH Ratchet** : Renouvelle les cl√©s racines via ECDH
- **Symmetric Ratchet** : D√©rive les cl√©s de messages via HKDF
- Chaque message a une cl√© unique ‚Üí compromission d'une cl√© ne compromet pas les autres

#### 5.5.2 Kerberos

**Composants :**
- **KDC** : Key Distribution Center (AS + TGS)
- **TGT** : Ticket Granting Ticket (passeport g√©n√©ral)
- **ST** : Service Ticket (acc√®s √† un service sp√©cifique)

**Vuln√©rabilit√©s :**
- **Kerberoasting** : Cracker offline les tickets RC4
- **Golden Ticket** : Forger des TGT si cl√© KRBTGT compromise
- **Pass-the-Ticket** : R√©utiliser des tickets vol√©s

#### 5.5.3 mTLS

Mutual TLS = client ET serveur pr√©sentent des certificats :
- Utilis√© dans les architectures microservices (Istio, Linkerd)
- Zero-trust networking : chaque service prouve son identit√©
- N√©cessite une PKI interne (souvent avec Vault, SPIFFE/SPIRE)

#### 5.5.4 DNSSEC

Ajoute l'authenticit√© au DNS :
- **DNSKEY** : Cl√©s publiques de zone (KSK + ZSK)
- **DS** : D√©l√©gation s√©curis√©e vers zone enfant
- **RRSIG** : Signature des enregistrements
- **NSEC/NSEC3** : Preuve de non-existence

### 5.6 Normes avec explications p√©dagogiques

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME                                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Kerberos avec etype 23 (RC4-HMAC)                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Kerberos avec etype 17/18 (AES-CTS-HMAC-SHA1)                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ RC4 biais√© : attaques statistiques possibles                 ‚îÇ
‚îÇ ‚Ä¢ Tickets RC4 : crackables offline en heures                   ‚îÇ
‚îÇ ‚Ä¢ AES requis depuis Windows Server 2008 R2                     ‚îÇ
‚îÇ ‚Ä¢ Conformit√© : PCI-DSS, HIPAA exigent encryption forte         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'ex√©cution

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape ‚îÇ Action                                     ‚îÇ √âtat                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ Alice g√©n√®re EK √©ph√©m√®re                   ‚îÇ EK_priv, EK_pub            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2   ‚îÇ DH1 = ECDH(IK_A, SPK_B)                    ‚îÇ 32 bytes secret             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3   ‚îÇ DH2 = ECDH(EK_A, IK_B)                     ‚îÇ 32 bytes secret             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ DH3 = ECDH(EK_A, SPK_B)                    ‚îÇ 32 bytes secret             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ DH4 = ECDH(EK_A, OPK_B)                    ‚îÇ 32 bytes secret             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   6   ‚îÇ SK = HKDF(DH1||DH2||DH3||DH4)              ‚îÇ Shared Secret 32 bytes      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7   ‚îÇ Initialize Double Ratchet with SK          ‚îÇ Root Key, Sending Chain     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üì∫ MEME : "Severance" ‚Äî Les Innies et les Outies

Dans Severance, Mark S. ne peut pas communiquer avec son "Outie" ‚Äî ils sont cryptographiquement s√©par√©s.

Le **Signal Protocol** c'est pareil : chaque message est comme un "Innie" diff√©rent. M√™me si on capture un message, on ne peut pas acc√©der aux autres (forward secrecy).

Le **Double Ratchet** c'est le "severed elevator" : √† chaque trajet, les cl√©s changent compl√®tement.

```python
# Chaque message a sa propre "conscience"
msg1_key = derive_key(chain, 1)  # Innie 1
msg2_key = derive_key(chain, 2)  # Innie 2
msg3_key = derive_key(chain, 3)  # Innie 3
# Capturer Innie 2 ne r√©v√®le pas Innie 1 ou 3
```

#### üêï MEME : "Cerberus" ‚Äî Le Chien √† Trois T√™tes

Kerberos a trois t√™tes :
1. **Client** : Toi, qui veux entrer
2. **KDC** : Le gardien qui v√©rifie ton identit√©
3. **Service** : La destination finale

Comme dans la mythologie, tu dois satisfaire les trois t√™tes pour passer.

### 5.9 Applications pratiques

1. **Impl√©menter un client Signal** : Comprendre le protocole end-to-end
2. **Auditer Active Directory** : D√©tecter les comptes Kerberoastables
3. **Configurer mTLS** : S√©curiser un cluster Kubernetes avec Istio
4. **D√©ployer DNSSEC** : Signer une zone DNS

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | Comment l'√©viter |
|---|-------|------------------|
| 1 | OPK r√©utilis√© | Supprimer OPK apr√®s usage |
| 2 | Pas de DH ratchet | Changer les cl√©s DH r√©guli√®rement |
| 3 | RC4 Kerberos | Forcer AES (etype 17/18) |
| 4 | mTLS sans r√©vocation | OCSP stapling ou CRL |
| 5 | DNSSEC SHA-1 | DS avec SHA-256 minimum |
| 6 | Service accounts faibles | Mots de passe longs, gMSA |

---

## üìù SECTION 7 : QCM

**Q1:** Combien de DH sont calcul√©s dans X3DH avec OPK?
A) 2  B) 3  C) 4 ‚úì  D) 5

**Q2:** Qu'est-ce que le "Double Ratchet" renouvelle?
A) Uniquement les cl√©s de message  B) Uniquement les cl√©s DH  C) Les deux ‚úì  D) Rien

**Q3:** Quel etype Kerberos est vuln√©rable au Kerberoasting?
A) 17 (AES-128)  B) 18 (AES-256)  C) 23 (RC4-HMAC) ‚úì  D) 24

**Q4:** Que signifie le "m" dans mTLS?
A) Managed  B) Mutual ‚úì  C) Monitored  D) Multi

**Q5:** Quel enregistrement DNSSEC prouve la non-existence?
A) DNSKEY  B) DS  C) RRSIG  D) NSEC/NSEC3 ‚úì

**Q6:** Dans Signal, pourquoi 4 DH au lieu de 1?
A) Performance  B) Propri√©t√©s de s√©curit√© diff√©rentes ‚úì  C) Compatibilit√©  D) Standard

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.7-b : gardiens_session |
| Concepts | X3DH, Double Ratchet, Kerberos, mTLS, DNSSEC |
| Difficult√© | 9/10 |
| XP | 300 |
| Bonus | üß† G√©nie (√ó6) |

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
