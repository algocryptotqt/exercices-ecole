# Exercice 3.1.2-b : theoreme_secret

**Module :**
3.1.2 ‚Äî Math√©matiques Cryptographiques

**Concept :**
b ‚Äî Th√©or√®me des Restes Chinois et Nombres Premiers

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- 3.1.2-a (Arithm√©tique modulaire de base)
- Compr√©hension des congruences
- Notion de nombres premiers

**Domaines :**
Crypto, MD

**Dur√©e estim√©e :**
90 min

**XP Base :**
200

**Complexit√© :**
T3 O(k log¬≥n) √ó S2 O(log n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :** `theoreme_secret.rs`

**Fonctions autoris√©es :**
- Biblioth√®que standard Rust uniquement
- `std::str::FromStr`
- `std::fmt::Display`
- `rand` (pour g√©n√©ration al√©atoire)

**Fonctions interdites :**
- Crates externes de grands entiers (`num-bigint`, `rug`, etc.)
- Crates cryptographiques (`ring`, `openssl`, etc.)

### 1.2 Consigne

**üéÆ CONTEXTE FUN ‚Äî "The Imitation Game" meets "Sneakers"**

*"Il n'existe que deux types de probl√®mes en cryptographie : ceux qu'on peut r√©soudre avec les math√©matiques chinoises, et ceux qu'on ne devrait pas essayer de r√©soudre."* ‚Äî Sun Tzu (probablement pas)

Tu es **Dr. Qian**, cryptanalyste au sein de l'agence secr√®te **ENIGMA-7**. Un ancien syst√®me de partage de secrets nucl√©aires bas√© sur le **Th√©or√®me des Restes Chinois** a √©t√© compromis. Les fragments de codes (les "shares") ont √©t√© dispers√©s dans diff√©rents serveurs √† travers le monde.

Ta mission : reconstruire les codes secrets originaux √† partir des fragments, **ET** g√©n√©rer de nouveaux nombres premiers ultra-s√©curis√©s pour le nouveau syst√®me ‚Äî des **safe primes** qui r√©sisteront m√™me aux ordinateurs quantiques de demain.

Le G√©n√©ral t'a pr√©venu : *"Ces nombres de Carmichael sont fourbes ‚Äî ils se font passer pour des premiers alors qu'ils ne le sont pas. Fermat s'est fait avoir. Pas toi."*

**Ta mission :**

√âcrire un module Rust `theoreme_secret` qui :

1. **R√©sout des syst√®mes de congruences** via le Th√©or√®me des Restes Chinois
2. **Teste la primalit√©** avec l'algorithme de Miller-Rabin (robuste contre Carmichael)
3. **G√©n√®re des nombres premiers s√ªrs** (safe primes) de taille arbitraire

**Entr√©e :**
- `input: &str` : JSON contenant les probl√®mes CRT, tests de primalit√©, et demandes de g√©n√©ration

**Sortie :**
- `String` : JSON avec les solutions CRT, r√©sultats de primalit√©, et nombres premiers g√©n√©r√©s

**Contraintes :**
- Grands entiers repr√©sent√©s comme `String` (d√©cimal)
- CRT doit d√©tecter les modules non-coprimes et retourner une erreur
- Miller-Rabin avec nombre de rounds configurable
- Safe prime : p est safe si (p-1)/2 est aussi premier

**Exemples :**

| Entr√©e | Sortie | Explication |
|--------|--------|-------------|
| `{"crt_problems":[{"congruences":[{"r":2,"m":3},{"r":3,"m":5},{"r":2,"m":7}]}]}` | `{"crt_solutions":[{"x":"23","modulus":"105"}]}` | x ‚â° 2 (mod 3), x ‚â° 3 (mod 5), x ‚â° 2 (mod 7) ‚Üí x = 23 |
| `{"primality_tests":[{"number":"561","rounds":20}]}` | `{"primality_results":[{"number":"561","is_prime":false}]}` | 561 est un nombre de Carmichael (3√ó11√ó17) |
| `{"prime_generation":[{"bits":32,"safe_prime":true}]}` | `{"generated_primes":[{"prime":"...","sophie_germain":"..."}]}` | G√©n√®re p tel que (p-1)/2 soit aussi premier |

### 1.2.2 Consigne Acad√©mique

Impl√©menter un module de th√©orie des nombres comprenant :

1. **Algorithme CRT (Th√©or√®me des Restes Chinois)** : √âtant donn√© un syst√®me de congruences `x ‚â° r·µ¢ (mod m·µ¢)` o√π les `m·µ¢` sont deux √† deux premiers entre eux, trouver l'unique solution `x` modulo `M = ‚àèm·µ¢`.

2. **Test de primalit√© Miller-Rabin** : Algorithme probabiliste permettant de d√©terminer si un nombre est compos√© (certain) ou probablement premier avec une confiance de `1 - 4^(-k)` apr√®s `k` rounds.

3. **G√©n√©ration de Safe Primes** : Un nombre premier `p` est dit "safe" si `q = (p-1)/2` est √©galement premier. `q` est alors appel√© "premier de Sophie Germain".

### 1.3 Prototype

```rust
pub fn theoreme_secret(input: &str) -> String

// Structures internes recommand√©es
pub struct CrtProblem {
    congruences: Vec<Congruence>,
}

pub struct Congruence {
    remainder: String,  // r
    modulus: String,    // m
}

pub struct PrimalityTest {
    number: String,
    rounds: u32,
}

pub struct PrimeGeneration {
    bits: u32,
    safe_prime: bool,
}

// Fonctions helpers
fn solve_crt(problem: &CrtProblem) -> Result<(String, String), &'static str>
fn miller_rabin(n: &str, rounds: u32) -> (bool, f64)
fn generate_prime(bits: u32, safe: bool) -> (String, Option<String>)
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Histoire du CRT

Le Th√©or√®me des Restes Chinois remonte au **IIIe si√®cle** ! Le math√©maticien chinois **Sun Zi** (Sunzi Suanjing) l'a formul√© pour r√©soudre ce probl√®me :

> *"Il y a des objets dont on ignore le nombre. Si on les compte par 3, il en reste 2. Par 5, il en reste 3. Par 7, il en reste 2. Combien y a-t-il d'objets ?"*

La r√©ponse est **23** ‚Äî exactement notre premier exemple !

### 2.2 Les Nombres de Carmichael ‚Äî Les "Faux Premiers"

En 1910, **Robert Carmichael** d√©couvre des nombres compos√©s qui passent le test de Fermat pour TOUTES les bases. Le plus petit est **561 = 3 √ó 11 √ó 17**.

Ces nombres sont rares mais dangereux : si vous utilisez uniquement le test de Fermat, vous pourriez accepter un nombre compos√© comme premier, compromettant toute votre cryptographie !

**Miller-Rabin** r√©sout ce probl√®me en exploitant une propri√©t√© plus fine des nombres premiers.

### 2.3 Sophie Germain ‚Äî La Math√©maticienne Clandestine

**Sophie Germain** (1776-1831) √©tait une math√©maticienne fran√ßaise qui, interdite d'universit√© car femme, correspondait avec Gauss sous le pseudonyme masculin "Monsieur LeBlanc".

Les **premiers de Sophie Germain** (p tel que 2p+1 soit aussi premier) portent son nom. Les **safe primes** (2q+1 o√π q est un premier de Sophie Germain) sont essentiels en cryptographie moderne pour √©viter certaines attaques sur Diffie-Hellman.

---

## üè¢ SECTION 2.5 : DANS LA VRAIE VIE

### Cryptographe / Security Engineer

**Cas d'usage CRT :** Acc√©l√©ration RSA (RSA-CRT). Au lieu de calculer `m = c^d mod n`, on calcule s√©par√©ment modulo p et modulo q, puis on recombine avec CRT. **Gain : 4x plus rapide !**

### Blockchain Developer

**Cas d'usage Safe Primes :** Les protocoles de signature (DSA, Schnorr) et d'√©change de cl√©s (DH) utilisent des groupes dont l'ordre est un safe prime pour √©viter les attaques par sous-groupes.

### Hardware Security Engineer

**Cas d'usage Miller-Rabin :** Les HSM (Hardware Security Modules) utilisent Miller-Rabin pour g√©n√©rer des cl√©s RSA. Le nombre de rounds d√©termine le niveau de confiance ‚Äî 64 rounds pour des cl√©s critiques.

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
theoreme_secret.rs  main.rs  Cargo.toml

$ cargo build --release

$ cargo run --release
Test CRT basique: OK (x=23, M=105)
Test Carmichael 561: OK (d√©tect√© comme compos√©)
Test premier 104729: OK (confirm√© premier)
Test safe prime 32-bit: OK (g√©n√©r√© en 0.3s)
Tous les tests passent!
```

---

## ‚ö° SECTION 3.1 : BONUS AVANC√â (OPTIONNEL)

**Difficult√© Bonus :**
üß† (12/10)

**R√©compense :**
XP √ó6

**Time Complexity attendue :**
O(k log¬≤n) avec FFT

**Space Complexity attendue :**
O(log n)

**Domaines Bonus :**
`Crypto, MD, Algo`

### 3.1.1 Consigne Bonus

**üéÆ "Op√©ration Garner" ‚Äî L'Optimisation Ultime**

Le G√©n√©ral est impressionn√©, mais l'ennemi a intercept√© vos calculs. Ils ont mesur√© le temps d'ex√©cution et peuvent d√©duire la taille des nombres ! Vous devez impl√©menter des versions **constant-time** et **optimis√©es**.

**Ta mission √©tendue :**

1. **CRT avec l'algorithme de Garner** (plus efficace que la m√©thode directe)
2. **Miller-Rabin constant-time** (r√©sistant aux timing attacks)
3. **G√©n√©ration de Strong Primes** (p-1 et p+1 ont tous deux de grands facteurs premiers)

**Contraintes Bonus :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Safe prime : (p-1)/2 premier           ‚îÇ
‚îÇ  Strong prime : p-1 a un grand facteur  ‚îÇ
‚îÇ                 p+1 a un grand facteur  ‚îÇ
‚îÇ  Gordon's algorithm pour strong primes  ‚îÇ
‚îÇ  Temps constant pour Miller-Rabin       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 3.1.2 Prototype Bonus

```rust
fn solve_crt_garner(problem: &CrtProblem) -> Result<(String, String), &'static str>
fn miller_rabin_constant_time(n: &str, rounds: u32) -> (bool, f64)
fn generate_strong_prime(bits: u32) -> StrongPrimeResult
```

### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Algorithme CRT | Direct (‚àèM·µ¢y·µ¢r·µ¢) | Garner (it√©ratif) |
| Miller-Rabin | Variable-time | Constant-time |
| Type de premier | Safe prime | Strong prime |
| Complexit√© | O(k log¬≥n) | O(k log¬≤n) avec Karatsuba |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points | Trap |
|------|-------|----------|--------|------|
| crt_basic | `{"crt_problems":[{"congruences":[{"r":2,"m":3},{"r":3,"m":5},{"r":2,"m":7}]}]}` | x=23, M=105 | 10 | Non |
| crt_two_mods | `{"crt_problems":[{"congruences":[{"r":1,"m":4},{"r":2,"m":5}]}]}` | x=17, M=20 | 5 | Non |
| crt_not_coprime | `{"crt_problems":[{"congruences":[{"r":1,"m":4},{"r":2,"m":6}]}]}` | ERROR | 10 | Oui |
| crt_large | Modules 997, 991, 983 | Valide | 10 | Non |
| miller_small_prime | 17, 20 rounds | true | 5 | Non |
| miller_carmichael_561 | 561, 20 rounds | false | 15 | Oui |
| miller_carmichael_1105 | 1105, 20 rounds | false | 10 | Oui |
| miller_large_prime | 104729, 40 rounds | true | 10 | Non |
| miller_mersenne | 2^31-1 | true | 5 | Non |
| gen_prime_32 | 32 bits, not safe | valid prime | 10 | Non |
| gen_safe_prime_32 | 32 bits, safe | valid safe prime | 10 | Non |

### 4.2 main.rs de test

```rust
use std::collections::HashMap;
use serde_json::{json, Value};

mod theoreme_secret;
use theoreme_secret::theoreme_secret;

fn main() {
    let mut passed = 0;
    let mut total = 0;

    // Test 1: CRT basique
    total += 1;
    let input = r#"{"crt_problems":[{"congruences":[{"r":"2","m":"3"},{"r":"3","m":"5"},{"r":"2","m":"7"}]}]}"#;
    let result: Value = serde_json::from_str(&theoreme_secret(input)).unwrap();
    if result["crt_solutions"][0]["x"] == "23" && result["crt_solutions"][0]["modulus"] == "105" {
        println!("Test CRT basique: OK");
        passed += 1;
    } else {
        println!("Test CRT basique: FAIL - got {:?}", result);
    }

    // Test 2: CRT modules non coprimes
    total += 1;
    let input = r#"{"crt_problems":[{"congruences":[{"r":"1","m":"4"},{"r":"2","m":"6"}]}]}"#;
    let result: Value = serde_json::from_str(&theoreme_secret(input)).unwrap();
    if result["crt_solutions"][0]["error"].is_string() {
        println!("Test CRT non-coprime: OK");
        passed += 1;
    } else {
        println!("Test CRT non-coprime: FAIL - should return error");
    }

    // Test 3: Miller-Rabin sur nombre de Carmichael
    total += 1;
    let input = r#"{"primality_tests":[{"number":"561","rounds":20}]}"#;
    let result: Value = serde_json::from_str(&theoreme_secret(input)).unwrap();
    if result["primality_results"][0]["is_prime"] == false {
        println!("Test Carmichael 561: OK");
        passed += 1;
    } else {
        println!("Test Carmichael 561: FAIL - 561=3*11*17 should be composite");
    }

    // Test 4: Miller-Rabin sur vrai premier
    total += 1;
    let input = r#"{"primality_tests":[{"number":"104729","rounds":20}]}"#;
    let result: Value = serde_json::from_str(&theoreme_secret(input)).unwrap();
    if result["primality_results"][0]["is_prime"] == true {
        println!("Test premier 104729: OK");
        passed += 1;
    } else {
        println!("Test premier 104729: FAIL - 104729 is prime");
    }

    // Test 5: G√©n√©ration safe prime
    total += 1;
    let input = r#"{"prime_generation":[{"bits":32,"safe_prime":true}]}"#;
    let result: Value = serde_json::from_str(&theoreme_secret(input)).unwrap();
    let prime_str = result["generated_primes"][0]["prime"].as_str().unwrap();
    let sophie = result["generated_primes"][0]["sophie_germain"].as_str().unwrap();
    // V√©rifier que prime = 2*sophie + 1
    let p: u128 = prime_str.parse().unwrap();
    let q: u128 = sophie.parse().unwrap();
    if p == 2 * q + 1 {
        println!("Test safe prime: OK (p={}, q={})", p, q);
        passed += 1;
    } else {
        println!("Test safe prime: FAIL - p != 2q+1");
    }

    println!("\n{}/{} tests pass√©s", passed, total);
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json;
use rand::Rng;

#[derive(Deserialize)]
struct Input {
    #[serde(default)]
    crt_problems: Vec<CrtProblem>,
    #[serde(default)]
    primality_tests: Vec<PrimalityTest>,
    #[serde(default)]
    prime_generation: Vec<PrimeGeneration>,
}

#[derive(Deserialize)]
struct CrtProblem {
    congruences: Vec<Congruence>,
}

#[derive(Deserialize)]
struct Congruence {
    r: String,
    m: String,
}

#[derive(Deserialize)]
struct PrimalityTest {
    number: String,
    rounds: u32,
}

#[derive(Deserialize)]
struct PrimeGeneration {
    bits: u32,
    safe_prime: bool,
}

#[derive(Serialize)]
struct Output {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    crt_solutions: Vec<CrtSolution>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    primality_results: Vec<PrimalityResult>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    generated_primes: Vec<GeneratedPrime>,
}

#[derive(Serialize)]
struct CrtSolution {
    #[serde(skip_serializing_if = "Option::is_none")]
    x: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    modulus: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
}

#[derive(Serialize)]
struct PrimalityResult {
    number: String,
    is_prime: bool,
    confidence: f64,
}

#[derive(Serialize)]
struct GeneratedPrime {
    prime: String,
    bits: u32,
    is_safe: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    sophie_germain: Option<String>,
}

// BigInt operations using u128 for simplicity (production would use arbitrary precision)
fn parse_num(s: &str) -> u128 {
    s.parse().unwrap_or(0)
}

fn gcd(a: u128, b: u128) -> u128 {
    if b == 0 { a } else { gcd(b, a % b) }
}

fn extended_gcd(a: i128, b: i128) -> (i128, i128, i128) {
    if b == 0 {
        (a, 1, 0)
    } else {
        let (g, x, y) = extended_gcd(b, a % b);
        (g, y, x - (a / b) * y)
    }
}

fn mod_inverse(a: u128, m: u128) -> Option<u128> {
    let (g, x, _) = extended_gcd(a as i128, m as i128);
    if g != 1 {
        None
    } else {
        Some(((x % m as i128 + m as i128) % m as i128) as u128)
    }
}

fn mod_mul(a: u128, b: u128, m: u128) -> u128 {
    ((a as u128 % m) * (b as u128 % m)) % m
}

fn mod_pow(mut base: u128, mut exp: u128, m: u128) -> u128 {
    if m == 1 { return 0; }
    let mut result: u128 = 1;
    base %= m;
    while exp > 0 {
        if exp & 1 == 1 {
            result = mod_mul(result, base, m);
        }
        exp >>= 1;
        base = mod_mul(base, base, m);
    }
    result
}

fn solve_crt(problem: &CrtProblem) -> Result<(u128, u128), &'static str> {
    if problem.congruences.is_empty() {
        return Err("No congruences provided");
    }

    // V√©rifier que tous les modules sont coprimes deux √† deux
    let mods: Vec<u128> = problem.congruences.iter()
        .map(|c| parse_num(&c.m))
        .collect();

    for i in 0..mods.len() {
        for j in (i+1)..mods.len() {
            if gcd(mods[i], mods[j]) != 1 {
                return Err("Modules are not pairwise coprime");
            }
        }
    }

    // Calculer M = produit de tous les modules
    let big_m: u128 = mods.iter().product();

    // Appliquer CRT: x = Œ£(r·µ¢ √ó M·µ¢ √ó y·µ¢) mod M
    // o√π M·µ¢ = M/m·µ¢ et y·µ¢ = inverse de M·µ¢ modulo m·µ¢
    let mut x: u128 = 0;

    for cong in &problem.congruences {
        let r = parse_num(&cong.r);
        let m = parse_num(&cong.m);
        let big_mi = big_m / m;
        let yi = mod_inverse(big_mi % m, m).ok_or("No inverse exists")?;
        x = (x + mod_mul(mod_mul(r, big_mi, big_m), yi, big_m)) % big_m;
    }

    Ok((x, big_m))
}

fn miller_rabin(n: u128, rounds: u32) -> (bool, f64) {
    // Cas triviaux
    if n < 2 { return (false, 1.0); }
    if n == 2 || n == 3 { return (true, 1.0); }
    if n % 2 == 0 { return (false, 1.0); }

    // √âcrire n-1 = 2^s √ó d avec d impair
    let mut d = n - 1;
    let mut s = 0u32;
    while d % 2 == 0 {
        d /= 2;
        s += 1;
    }

    let mut rng = rand::thread_rng();

    for _ in 0..rounds {
        // Choisir a al√©atoire dans [2, n-2]
        let a = rng.gen_range(2..n-1);

        // Calculer x = a^d mod n
        let mut x = mod_pow(a, d, n);

        if x == 1 || x == n - 1 {
            continue;
        }

        let mut is_composite = true;
        for _ in 0..(s - 1) {
            x = mod_mul(x, x, n);
            if x == n - 1 {
                is_composite = false;
                break;
            }
        }

        if is_composite {
            return (false, 1.0);
        }
    }

    // Probablement premier avec confiance 1 - 4^(-rounds)
    let confidence = 1.0 - (0.25_f64).powi(rounds as i32);
    (true, confidence)
}

fn generate_prime(bits: u32, safe: bool) -> GeneratedPrime {
    let mut rng = rand::thread_rng();

    loop {
        // G√©n√©rer un nombre al√©atoire de `bits` bits
        let mut n: u128 = rng.gen_range(1u128 << (bits - 1)..1u128 << bits);
        n |= 1; // S'assurer qu'il est impair

        if safe {
            // Pour un safe prime p, on v√©rifie que q = (p-1)/2 est aussi premier
            // Plus efficace: g√©n√©rer q puis tester p = 2q+1
            let q = n;
            let p = 2 * q + 1;

            if p < (1u128 << bits) || p >= (1u128 << (bits + 1)) {
                continue;
            }

            let (q_prime, _) = miller_rabin(q, 40);
            if !q_prime { continue; }

            let (p_prime, _) = miller_rabin(p, 40);
            if p_prime {
                return GeneratedPrime {
                    prime: p.to_string(),
                    bits,
                    is_safe: true,
                    sophie_germain: Some(q.to_string()),
                };
            }
        } else {
            let (is_prime, _) = miller_rabin(n, 40);
            if is_prime {
                return GeneratedPrime {
                    prime: n.to_string(),
                    bits,
                    is_safe: false,
                    sophie_germain: None,
                };
            }
        }
    }
}

pub fn theoreme_secret(input: &str) -> String {
    let parsed: Input = match serde_json::from_str(input) {
        Ok(v) => v,
        Err(e) => return format!(r#"{{"error":"Parse error: {}"}}"#, e),
    };

    let mut output = Output {
        crt_solutions: Vec::new(),
        primality_results: Vec::new(),
        generated_primes: Vec::new(),
    };

    // R√©soudre les probl√®mes CRT
    for problem in &parsed.crt_problems {
        match solve_crt(problem) {
            Ok((x, m)) => {
                output.crt_solutions.push(CrtSolution {
                    x: Some(x.to_string()),
                    modulus: Some(m.to_string()),
                    error: None,
                });
            }
            Err(e) => {
                output.crt_solutions.push(CrtSolution {
                    x: None,
                    modulus: None,
                    error: Some(e.to_string()),
                });
            }
        }
    }

    // Tests de primalit√©
    for test in &parsed.primality_tests {
        let n = parse_num(&test.number);
        let (is_prime, confidence) = miller_rabin(n, test.rounds);
        output.primality_results.push(PrimalityResult {
            number: test.number.clone(),
            is_prime,
            confidence,
        });
    }

    // G√©n√©ration de nombres premiers
    for gen in &parsed.prime_generation {
        output.generated_primes.push(generate_prime(gen.bits, gen.safe_prime));
    }

    serde_json::to_string(&output).unwrap_or_else(|_| r#"{"error":"Serialization failed"}"#.to_string())
}
```

### 4.4 Solutions alternatives accept√©es

```rust
// Alternative 1: CRT avec algorithme de Garner (plus efficace)
fn solve_crt_garner(problem: &CrtProblem) -> Result<(u128, u128), &'static str> {
    let n = problem.congruences.len();
    if n == 0 { return Err("Empty"); }

    let rs: Vec<u128> = problem.congruences.iter().map(|c| parse_num(&c.r)).collect();
    let ms: Vec<u128> = problem.congruences.iter().map(|c| parse_num(&c.m)).collect();

    // V√©rifier coprimalit√©
    for i in 0..n {
        for j in (i+1)..n {
            if gcd(ms[i], ms[j]) != 1 { return Err("Not coprime"); }
        }
    }

    // Algorithme de Garner
    let mut x = rs[0] % ms[0];
    let mut m_prod = ms[0];

    for i in 1..n {
        let c_i = mod_inverse(m_prod % ms[i], ms[i]).ok_or("No inverse")?;
        let diff = if rs[i] >= x % ms[i] { rs[i] - x % ms[i] } else { ms[i] + rs[i] - x % ms[i] };
        let u = mod_mul(diff, c_i, ms[i]);
        x = x + u * m_prod;
        m_prod *= ms[i];
    }

    Ok((x % m_prod, m_prod))
}
```

### 4.5 Solutions refus√©es

```rust
// REFUS√âE: Test de Fermat simple (vuln√©rable aux Carmichael)
fn fermat_test(n: u128, rounds: u32) -> bool {
    // ‚ùå Carmichael numbers like 561 pass this test!
    for _ in 0..rounds {
        let a = rand::thread_rng().gen_range(2..n-1);
        if mod_pow(a, n - 1, n) != 1 {
            return false;
        }
    }
    true  // FAUX pour 561, 1105, 1729...
}
// Pourquoi refus√©: Les nombres de Carmichael passent ce test pour TOUTE base a coprime avec n

// REFUS√âE: CRT sans v√©rification de coprimalit√©
fn solve_crt_unsafe(problem: &CrtProblem) -> (u128, u128) {
    // ‚ùå Pas de v√©rification que les modules sont coprimes!
    let big_m: u128 = problem.congruences.iter()
        .map(|c| parse_num(&c.m))
        .product();
    // ... calcul direct
    // Probl√®me: si gcd(m1, m2) > 1, le r√©sultat est faux ou inexistant
}

// REFUS√âE: G√©n√©ration na√Øve de safe primes
fn generate_safe_naive(bits: u32) -> u128 {
    // ‚ùå Teste p d'abord puis v√©rifie q = (p-1)/2
    // Beaucoup moins efficace que g√©n√©rer q puis p = 2q+1
    loop {
        let p = random_odd(bits);
        if is_prime(p) && is_prime((p-1)/2) {
            return p;
        }
    }
}
```

### 4.6 Solution bonus de r√©f√©rence

```rust
// Algorithme de Garner avec temps constant pour certaines op√©rations
fn solve_crt_garner_optimized(problem: &CrtProblem) -> Result<(u128, u128), &'static str> {
    // Pr√©calculer les inverses et utiliser Montgomery multiplication
    // pour r√©duire le co√ªt des multiplications modulaires

    let n = problem.congruences.len();
    let ms: Vec<u128> = problem.congruences.iter().map(|c| parse_num(&c.m)).collect();
    let rs: Vec<u128> = problem.congruences.iter().map(|c| parse_num(&c.r)).collect();

    // Pr√©calculer la table des inverses c[i][j] = m[0]*...*m[i-1] mod m[i]
    let mut c: Vec<Vec<u128>> = vec![vec![0; n]; n];
    for i in 1..n {
        let mut prod = ms[0];
        c[0][i] = mod_inverse(prod % ms[i], ms[i]).ok_or("No inverse")?;
        for j in 1..i {
            prod = mod_mul(prod, ms[j], ms[i]);
            c[j][i] = mod_inverse(prod % ms[i], ms[i]).ok_or("No inverse")?;
        }
    }

    // Garner avec table pr√©calcul√©e
    let mut x = rs[0];
    let mut m_prod = ms[0];

    for i in 1..n {
        let u = mod_mul(
            if rs[i] >= x % ms[i] { rs[i] - x % ms[i] } else { ms[i] + rs[i] - x % ms[i] },
            c[i-1][i],
            ms[i]
        );
        x = x + u * m_prod;
        m_prod *= ms[i];
    }

    Ok((x, m_prod))
}

// Miller-Rabin avec bases d√©terministes pour n < 3,317,044,064,679,887,385,961,981
fn miller_rabin_deterministic(n: u128) -> bool {
    if n < 2 { return false; }
    if n == 2 { return true; }
    if n % 2 == 0 { return false; }

    // Bases qui garantissent un r√©sultat correct pour n < 3.3√ó10^24
    let witnesses: [u128; 12] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];

    let mut d = n - 1;
    let mut r = 0u32;
    while d % 2 == 0 {
        d /= 2;
        r += 1;
    }

    'witness: for &a in &witnesses {
        if a >= n { continue; }

        let mut x = mod_pow(a, d, n);
        if x == 1 || x == n - 1 { continue; }

        for _ in 0..r-1 {
            x = mod_mul(x, x, n);
            if x == n - 1 { continue 'witness; }
        }
        return false;
    }
    true
}

// G√©n√©ration de strong primes (Gordon's algorithm)
fn generate_strong_prime(bits: u32) -> StrongPrimeResult {
    loop {
        // 1. G√©n√©rer deux grands premiers s et t
        let s = generate_prime(bits / 2 - 2, false).prime.parse::<u128>().unwrap();
        let t = generate_prime(bits / 2 - 2, false).prime.parse::<u128>().unwrap();

        // 2. Trouver r tel que r ‚â° 1 (mod 2t)
        // r doit √™tre premier et ‚âà bits/2 bits
        let two_t = 2 * t;
        let mut r = two_t + 1;
        while !miller_rabin_deterministic(r) {
            r += two_t;
            if r.ilog2() > bits / 2 { break; }
        }
        if !miller_rabin_deterministic(r) { continue; }

        // 3. Calculer p‚ÇÄ = 2(s^(r-2) mod r)s - 1
        let exp = r - 2;
        let s_pow = mod_pow(s, exp, r);
        let p0 = 2 * s_pow * s - 1;

        // 4. Trouver p = p‚ÇÄ + 2krs qui est premier
        let two_rs = 2 * r * s;
        let mut p = p0;
        for _ in 0..1000 {
            if p.ilog2() >= bits - 1 && p.ilog2() < bits && miller_rabin_deterministic(p) {
                return StrongPrimeResult {
                    prime: p.to_string(),
                    large_factor_p_minus_1: r.to_string(),
                    large_factor_p_plus_1: s.to_string(),
                };
            }
            p += two_rs;
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A (Boundary): Off-by-one dans la boucle Miller-Rabin
fn miller_rabin_mutant_a(n: u128, rounds: u32) -> (bool, f64) {
    // ... setup identique ...
    for _ in 0..=s {  // ‚ùå <= au lieu de < (s-1)
        x = mod_mul(x, x, n);
        if x == n - 1 { is_composite = false; break; }
    }
    // Fait une it√©ration de trop, peut accepter des compos√©s
}
// Pourquoi faux: La boucle interne doit faire exactement s-1 it√©rations
// Ce mutant peut accepter certains compos√©s comme premiers

// Mutant B (Safety): Pas de v√©rification des modules coprimes
fn solve_crt_mutant_b(problem: &CrtProblem) -> Result<(u128, u128), &'static str> {
    // ‚ùå MANQUE: v√©rification que gcd(mi, mj) = 1 pour tout i ‚â† j
    let big_m: u128 = problem.congruences.iter()
        .map(|c| parse_num(&c.m))
        .product();
    // Calcul direct sans v√©rification
}
// Pourquoi faux: Si les modules ne sont pas coprimes, le CRT ne s'applique pas
// et le r√©sultat est soit faux soit inexistant

// Mutant C (Logic): Mauvais calcul de l'exposant s dans Miller-Rabin
fn miller_rabin_mutant_c(n: u128, rounds: u32) -> (bool, f64) {
    let mut d = n - 1;
    let mut s = 0u32;
    while d % 2 == 0 {
        d /= 2;
        // ‚ùå MANQUE: s += 1
    }
    // s reste √† 0, la boucle interne ne s'ex√©cute jamais
    // √âquivalent au test de Fermat ‚Üí vuln√©rable aux Carmichael
}
// Pourquoi faux: Sans incr√©menter s, on perd la puissance du test Miller-Rabin
// 561 (Carmichael) passerait ce test

// Mutant D (Return): Inversion du r√©sultat de primalit√©
fn miller_rabin_mutant_d(n: u128, rounds: u32) -> (bool, f64) {
    // ... tout le code correct ...
    if is_composite {
        return (true, 1.0);  // ‚ùå Retourne premier au lieu de compos√©!
    }
    (false, confidence)  // ‚ùå Retourne compos√© au lieu de premier!
}
// Pourquoi faux: Inversion totale de la logique

// Mutant E (Resource): Safe prime mal v√©rifi√©
fn generate_prime_mutant_e(bits: u32, safe: bool) -> GeneratedPrime {
    if safe {
        let q = random_prime(bits - 1);
        let p = 2 * q + 1;
        // ‚ùå Ne v√©rifie PAS que p est aussi premier!
        return GeneratedPrime {
            prime: p.to_string(),
            is_safe: true,
            sophie_germain: Some(q.to_string()),
        };
    }
}
// Pourquoi faux: p = 2q + 1 n'est pas forc√©ment premier m√™me si q l'est
// Ex: q=23 (premier), p=47 (premier) ‚úì
// Ex: q=29 (premier), p=59 (premier) ‚úì
// Ex: q=37 (premier), p=75 = 3√ó25 ‚úó
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Th√©or√®me des Restes Chinois (CRT)** : R√©soudre des syst√®mes de congruences simultan√©es
2. **Test de primalit√© Miller-Rabin** : Distinguer premiers et compos√©s de fa√ßon probabiliste
3. **Nombres de Carmichael** : Comprendre pourquoi Fermat seul ne suffit pas
4. **Safe Primes** : G√©n√©rer des premiers robustes pour la cryptographie

### 5.2 LDA ‚Äî Traduction litt√©rale en fran√ßais (MAJUSCULES)

```
FONCTION solve_crt QUI RETOURNE UN R√âSULTAT (x, M) OU UNE ERREUR
D√âBUT FONCTION
    SI problem.congruences EST VIDE ALORS
        RETOURNER ERREUR "Pas de congruences"
    FIN SI

    POUR i ALLANT DE 0 √Ä LONGUEUR(mods) MOINS 1 FAIRE
        POUR j ALLANT DE i PLUS 1 √Ä LONGUEUR(mods) MOINS 1 FAIRE
            SI PGCD(mods[i], mods[j]) EST DIFF√âRENT DE 1 ALORS
                RETOURNER ERREUR "Modules non coprimes"
            FIN SI
        FIN POUR
    FIN POUR

    AFFECTER PRODUIT DE TOUS LES mods √Ä big_m
    AFFECTER 0 √Ä x

    POUR CHAQUE congruence DANS problem FAIRE
        D√âCLARER Mi COMME big_m DIVIS√â PAR m
        D√âCLARER yi COMME INVERSE MODULAIRE DE Mi MODULO m
        AFFECTER x PLUS (r MULTIPLI√â PAR Mi MULTIPLI√â PAR yi) MODULO big_m √Ä x
    FIN POUR

    RETOURNER (x, big_m)
FIN FONCTION
```

### 5.3 Visualisation ASCII

**Le Th√©or√®me des Restes Chinois**

```
Probl√®me : x ‚â° 2 (mod 3), x ‚â° 3 (mod 5), x ‚â° 2 (mod 7)

mod 3:  0  1 [2] 0  1 [2] 0  1 [2] 0  1 [2] 0  1 [2] 0  1 [2] 0  1 [2] 0 [2]...
mod 5:  0  1  2 [3] 4  0  1  2 [3] 4  0  1  2 [3] 4  0  1  2 [3] 4  0  1  2 [3]...
mod 7:  0  1 [2] 3  4  5  6  0  1 [2] 3  4  5  6  0  1 [2] 3  4  5  6  0  1 [2]...
        ‚Üë                                                               ‚Üë
       x=0                                                            x=23 ‚úì

Unique solution x dans [0, 3√ó5√ó7) = [0, 105) ‚Üí x = 23
```

**Miller-Rabin sur 561 (Carmichael)**

```
561 = 3 √ó 11 √ó 17, n-1 = 560 = 2‚Å¥ √ó 35

Test avec a = 2:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape  ‚îÇ Calcul           ‚îÇ R√©sultat ‚îÇ Analyse     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ x‚ÇÄ     ‚îÇ 2¬≥‚Åµ mod 561      ‚îÇ 263      ‚îÇ ‚â† 1, ‚â† 560  ‚îÇ
‚îÇ x‚ÇÅ     ‚îÇ 263¬≤ mod 561     ‚îÇ 166      ‚îÇ ‚â† 560       ‚îÇ
‚îÇ x‚ÇÇ     ‚îÇ 166¬≤ mod 561     ‚îÇ 67       ‚îÇ ‚â† 560       ‚îÇ
‚îÇ x‚ÇÉ     ‚îÇ 67¬≤ mod 561      ‚îÇ 1        ‚îÇ ALERTE!     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
67 est racine non-triviale de 1 ‚Üí 561 COMPOS√â ‚úì
```

### 5.4 Les pi√®ges en d√©tail

| Pi√®ge | Description | Solution |
|-------|-------------|----------|
| Modules non coprimes | CRT invalide si gcd(m‚ÇÅ,m‚ÇÇ)>1 | Toujours v√©rifier |
| Carmichael | Passe Fermat, √©choue MR | Utiliser Miller-Rabin |
| Safe prime mal v√©rifi√© | p=2q+1 peut √™tre compos√© | Tester p ET q |
| Overflow | a√ób peut d√©border avant mod | Utiliser mod_mul |

### 5.5 Cours Complet

**Th√©or√®me des Restes Chinois :** Si m‚ÇÅ,...,m‚Çñ sont coprimes deux √† deux, alors le syst√®me x‚â°r·µ¢ (mod m·µ¢) a une unique solution modulo M=‚àèm·µ¢.

**Miller-Rabin :** Si p premier et p-1=2À¢d, alors pour tout a: soit a^d‚â°1, soit a^(2 ≥d)‚â°-1 pour un r<s. Violation ‚Üí compos√©. Confiance: 1-4^(-k) apr√®s k rounds.

**Safe Primes :** p=2q+1 avec q premier. Utilis√©s en DH/DSA car (‚Ñ§/p‚Ñ§)* n'a pas de petits sous-groupes exploitables.

### 5.8 Mn√©motechniques

**üéÆ MEME : Among Us ‚Äî Carmichael Imposter**

```
561 was The Imposter. ‡∂û

Fermat: "561 is safe, I saw him in electrical"
Miller-Rabin: "561 is sus, j'ai trouv√© un t√©moin"
```

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| Pi√®ge | Impact | Pr√©vention |
|-------|--------|------------|
| Modules non coprimes | Solution invalide | V√©rifier gcd pairwise |
| Nombres de Carmichael | Faux positif Fermat | Utiliser Miller-Rabin |
| Safe prime mal g√©n√©r√© | Vuln√©rable | Tester (p-1)/2 aussi |

---

## üìù SECTION 7 : QCM

**Q1:** Solution de x‚â°1(mod 3), x‚â°2(mod 5)?
A) 7 ‚úì  B) 12  C) 17  D) 2

**Q2:** Pourquoi 561 √©chappe √† Fermat mais pas Miller-Rabin?
C) Racines non-triviales de 1 ‚úì

**Q3:** Si gcd(m‚ÇÅ,m‚ÇÇ)>1?
C) Syst√®me peut √™tre inconsistant ‚úì

**Q4:** Safe prime?
B) p tel que (p-1)/2 premier ‚úì

**Q5:** Confiance apr√®s 20 rounds MR?
D) 1-4‚Åª¬≤‚Å∞ ‚âà 99.9999999999% ‚úì

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.2-b : theoreme_secret |
| Concepts | CRT, Miller-Rabin, Safe Primes |
| Langage | Rust Edition 2024 |
| Difficult√© | 8/10 |
| XP | 200 (base) / 1200 (bonus) |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.1.2-b-theoreme_secret",
    "metadata": {
      "exercise_id": "3.1.2-b",
      "exercise_name": "theoreme_secret",
      "module": "3.1.2",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 200,
      "bonus_tier": "G√âNIE",
      "bonus_icon": "üß†"
    }
  }
}
```

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
