# Exercice 3.1.2-a : cles_royaume

**Module :**
3.1.2 â€” MathÃ©matiques Cryptographiques

**Concept :**
a-f â€” ArithmÃ©tique modulaire, PGCD, Inverse modulaire, ThÃ©orÃ¨me de Fermat, ThÃ©orÃ¨me d'Euler, Exponentiation modulaire

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
2 â€” MÃ©lange (concepts a + b + c + d + e + f)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- AlgÃ¨bre de base (modulo, division euclidienne)
- Notions de complexitÃ© algorithmique
- Syntaxe Rust de base (structs, impl, Result)

**Domaines :**
MD, Crypto, Encodage

**DurÃ©e estimÃ©e :**
120 min

**XP Base :**
250

**ComplexitÃ© :**
T3 O(log n) Ã— S1 O(1)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :**
`cles_royaume.rs`

**Fonctions autorisÃ©es :**
- BibliothÃ¨que standard Rust uniquement
- `std::str::FromStr` pour parsing
- `std::fmt` pour affichage

**Fonctions interdites :**
- Crates externes (num-bigint, rug, etc.)
- `unsafe` blocks
- Macro `panic!` dans le code de production

### 1.2 Consigne

**ğŸ® CONTEXTE FUN â€” RÃ©fÃ©rence : "The Imitation Game" Ã— "Cryptonomicon"**

*"Tu te souviens d'Alan Turing Ã  Bletchley Park, dÃ©chiffrant Enigma avec des mathÃ©matiques pures ? Ou de Randy Waterhouse dans Cryptonomicon, implÃ©mentant des algorithmes cryptographiques from scratch dans un bunker ? Aujourd'hui, tu es ce cryptographe solitaire."*

Tu viens d'Ãªtre recrutÃ© par **Aegis Embedded Systems**, une startup qui dÃ©veloppe des HSM (Hardware Security Modules) pour satellites. Le problÃ¨me : les librairies crypto classiques (OpenSSL, libsodium) sont trop lourdes pour leur microcontrÃ´leur ARM Cortex-M0 avec seulement 32KB de RAM.

Le CTO te demande d'implÃ©menter une **bibliothÃ¨que cryptographique lÃ©gÃ¨re from scratch**, en commenÃ§ant par les primitives mathÃ©matiques fondamentales. Sans ces briques de base, pas de RSA, pas de Diffie-Hellman, pas de signatures.

**Ta mission :**

ImplÃ©menter un module `crypto_math` avec les opÃ©rations arithmÃ©tiques modulaires fondamentales.

**EntrÃ©e :**
- `operations` : vecteur de structures `Operation` dÃ©crivant les calculs Ã  effectuer
  - `mod_add` : addition modulaire
  - `mod_mul` : multiplication modulaire
  - `gcd_extended` : PGCD et coefficients de BÃ©zout
  - `mod_inverse` : inverse modulaire via Euclide Ã©tendu
  - `mod_exp` : exponentiation modulaire (square-and-multiply)
  - `euler_phi` : fonction indicatrice d'Euler Ï†(n)

**Sortie :**
- Vecteur de `OperationResult` avec le rÃ©sultat et la mÃ©thode utilisÃ©e

**Contraintes :**
- Tous les calculs doivent utiliser des `String` pour reprÃ©senter les grands entiers (pas de u128 limitÃ©)
- L'exponentiation doit Ãªtre en O(log n) via square-and-multiply
- L'inverse modulaire doit utiliser l'algorithme d'Euclide Ã©tendu
- Gestion propre des cas oÃ¹ l'inverse n'existe pas (pgcd â‰  1)
- Pas de conversion vers types entiers natifs pour les calculs

**Exemples :**

| OpÃ©ration | EntrÃ©e | Sortie | MÃ©thode |
|-----------|--------|--------|---------|
| mod_add | a=123456789, b=987654321, n=1000000007 | 111111103 | standard |
| gcd_extended | a=35, b=15 | gcd=5, x=-1, y=3 | extended_euclid |
| mod_inverse | a=7, n=11 | 8 | extended_euclid |
| mod_exp | base=3, exp=7, mod=11 | 9 | square_and_multiply |
| euler_phi | n=12 | 4 | factorization |

### 1.2.2 Consigne AcadÃ©mique

ImplÃ©menter les primitives arithmÃ©tiques modulaires suivantes :

1. **Addition modulaire** : (a + b) mod n, avec gestion de l'overflow
2. **Multiplication modulaire** : (a Ã— b) mod n, avec technique de rÃ©duction
3. **PGCD Ã©tendu** : Algorithme d'Euclide Ã©tendu retournant gcd et coefficients de BÃ©zout
4. **Inverse modulaire** : aâ»Â¹ mod n tel que a Ã— aâ»Â¹ â‰¡ 1 (mod n)
5. **Exponentiation modulaire** : a^e mod n en O(log e) via square-and-multiply
6. **Fonction Ï† d'Euler** : Nombre d'entiers premiers avec n

Ces primitives sont les fondations de RSA, Diffie-Hellman, et la plupart des systÃ¨mes cryptographiques modernes.

### 1.3 Prototype

```rust
/// ReprÃ©sentation d'un grand entier comme String (base 10)
pub type BigInt = String;

/// Types d'opÃ©rations supportÃ©es
#[derive(Debug, Clone)]
pub enum OperationType {
    ModAdd { a: BigInt, b: BigInt, n: BigInt },
    ModMul { a: BigInt, b: BigInt, n: BigInt },
    GcdExtended { a: BigInt, b: BigInt },
    ModInverse { a: BigInt, n: BigInt },
    ModExp { base: BigInt, exp: BigInt, modulo: BigInt },
    EulerPhi { n: BigInt },
}

/// RÃ©sultat d'une opÃ©ration
#[derive(Debug, Clone)]
pub struct OperationResult {
    pub operation_index: usize,
    pub result: Result<BigInt, String>,
    pub method: String,
    pub extended_result: Option<ExtendedGcdResult>,
}

/// RÃ©sultat Ã©tendu pour GCD
#[derive(Debug, Clone)]
pub struct ExtendedGcdResult {
    pub gcd: BigInt,
    pub x: BigInt,  // Peut Ãªtre nÃ©gatif (prÃ©fixÃ© par '-')
    pub y: BigInt,
}

/// Point d'entrÃ©e principal
pub fn process_operations(operations: Vec<OperationType>) -> Vec<OperationResult> {
    todo!()
}

// Fonctions internes Ã  implÃ©menter
fn bigint_add(a: &str, b: &str) -> BigInt { todo!() }
fn bigint_sub(a: &str, b: &str) -> BigInt { todo!() }
fn bigint_mul(a: &str, b: &str) -> BigInt { todo!() }
fn bigint_div(a: &str, b: &str) -> (BigInt, BigInt) { todo!() } // (quotient, remainder)
fn bigint_mod(a: &str, n: &str) -> BigInt { todo!() }
fn bigint_cmp(a: &str, b: &str) -> std::cmp::Ordering { todo!() }

fn mod_add(a: &str, b: &str, n: &str) -> BigInt { todo!() }
fn mod_mul(a: &str, b: &str, n: &str) -> BigInt { todo!() }
fn gcd_extended(a: &str, b: &str) -> ExtendedGcdResult { todo!() }
fn mod_inverse(a: &str, n: &str) -> Result<BigInt, String> { todo!() }
fn mod_exp(base: &str, exp: &str, modulo: &str) -> BigInt { todo!() }
fn euler_phi(n: &str) -> BigInt { todo!() }
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'algorithme d'Euclide : 2300 ans et toujours lÃ 

L'algorithme d'Euclide pour calculer le PGCD est l'un des plus anciens algorithmes encore utilisÃ©s aujourd'hui. DÃ©crit dans les *Ã‰lÃ©ments* d'Euclide vers 300 av. J.-C., il est Ã  la base de la cryptographie RSA moderne.

Fait amusant : Le thÃ©orÃ¨me de LamÃ© (1844) prouve que le pire cas pour Euclide est atteint avec les nombres de Fibonacci consÃ©cutifs. C'est pourquoi la complexitÃ© est O(log(min(a,b))).

### 2.2 Square-and-Multiply : Le secret de RSA

L'exponentiation naÃ¯ve a^e nÃ©cessite e multiplications. Pour RSA-2048 avec e = 65537, c'est 65537 multiplications.

Avec square-and-multiply, on utilise la dÃ©composition binaire de l'exposant : seulement ~17 multiplications pour le mÃªme calcul ! C'est ce qui rend RSA praticable.

### 2.3 Pourquoi Rust pour la crypto ?

Rust est devenu le langage de choix pour les implÃ©mentations cryptographiques grÃ¢ce Ã  :
- **Memory safety** sans garbage collector
- **Pas de null pointers** (Option<T> Ã  la place)
- **Ownership system** qui prÃ©vient les use-after-free
- **Compilation vers bare metal** pour l'embarquÃ©

Les projets comme `ring` (utilisÃ© par Cloudflare) et `rustls` prouvent la viabilitÃ© de Rust pour la crypto production.

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Utilisation |
|--------|-------------|
| **Cryptographer** | ImplÃ©mente ces primitives dans les bibliothÃ¨ques crypto |
| **Security Engineer** | Audite les implÃ©mentations pour timing attacks |
| **Embedded Developer** | Porte les algorithmes sur microcontrÃ´leurs |
| **Blockchain Developer** | Utilise ces opÃ©rations pour les signatures |
| **PKI Engineer** | GÃ©nÃ¨re les clÃ©s RSA avec ces primitives |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
cles_royaume.rs  main.rs  Cargo.toml

$ cargo build --release
   Compiling cles_royaume v0.1.0
    Finished release [optimized] target(s) in 2.34s

$ cargo run --release
=== CRYPTO MATH LIBRARY TEST ===

Test 1: mod_add(123456789, 987654321, 1000000007)
Result: 111111103
Method: standard
Status: OK

Test 2: gcd_extended(35, 15)
Result: gcd=5, x=-1, y=3
Verification: 35*(-1) + 15*3 = -35 + 45 = 10 âœ—
Status: FAIL (should be 5)

Test 3: mod_inverse(7, 11)
Result: 8
Verification: 7 * 8 mod 11 = 56 mod 11 = 1 âœ“
Status: OK

Test 4: mod_exp(3, 7, 11)
Result: 9
Method: square_and_multiply (4 multiplications)
Verification: 3^7 = 2187, 2187 mod 11 = 9 âœ“
Status: OK

Test 5: euler_phi(12)
Result: 4
Explanation: {1, 5, 7, 11} sont premiers avec 12
Status: OK

Test 6: mod_inverse(6, 9)
Result: Error("No inverse exists: gcd(6, 9) = 3 â‰  1")
Status: OK (correct error handling)

=== 5/6 tests passed ===
```

### 3.1 ğŸ”¥ BONUS AVANCÃ‰ (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**RÃ©compense :**
XP Ã—3

**Time Complexity attendue :**
O(logÂ² n) pour primality test

**Space Complexity attendue :**
O(1) auxiliaire

**Domaines Bonus :**
`Probas, Crypto`

#### 3.1.1 Consigne Bonus

**ğŸ® Extension : "Le GÃ©nÃ©rateur de Secrets"**

*"Turing ne se contentait pas de dÃ©chiffrer. Il gÃ©nÃ©rait aussi des clÃ©s. Pour RSA, il faut des nombres premiers Ã‰NORMES. Comment les trouver ?"*

En plus des opÃ©rations de base, implÃ©menter :
- **Test de primalitÃ© Miller-Rabin** probabiliste
- **GÃ©nÃ©ration de nombres premiers** de n bits
- **GÃ©nÃ©ration de clÃ©s RSA** (p, q, n, e, d)

**Contraintes :**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Miller-Rabin avec k = 20 itÃ©rations    â”‚
â”‚  ProbabilitÃ© d'erreur < 4^(-20)         â”‚
â”‚  GÃ©nÃ©ration de premiers jusqu'Ã  512 bitsâ”‚
â”‚  RSA key generation fonctionnelle       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

#### 3.1.2 Prototype Bonus

```rust
/// Test de primalitÃ© Miller-Rabin
pub fn miller_rabin(n: &str, rounds: u32) -> bool { todo!() }

/// GÃ©nÃ¨re un nombre premier de `bits` bits
pub fn generate_prime(bits: u32, rng: &mut impl Rng) -> BigInt { todo!() }

/// GÃ©nÃ¨re une paire de clÃ©s RSA
pub fn generate_rsa_keypair(bits: u32) -> RsaKeyPair { todo!() }

pub struct RsaKeyPair {
    pub n: BigInt,      // Modulus
    pub e: BigInt,      // Public exponent
    pub d: BigInt,      // Private exponent
    pub p: BigInt,      // First prime
    pub q: BigInt,      // Second prime
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test ID | Input | Expected Output | Points |
|---------|-------|-----------------|--------|
| `test_mod_add_simple` | 5 + 7 mod 10 | 2 | 5 |
| `test_mod_add_large` | 123456789 + 987654321 mod 1000000007 | 111111103 | 5 |
| `test_mod_mul_simple` | 7 Ã— 8 mod 11 | 1 | 5 |
| `test_mod_mul_large` | Grands nombres | Correct | 10 |
| `test_gcd_simple` | gcd(35, 15) | 5, x=-1, y=3 | 10 |
| `test_gcd_coprime` | gcd(17, 23) | 1 | 5 |
| `test_inverse_exists` | 7â»Â¹ mod 11 | 8 | 10 |
| `test_inverse_not_exists` | 6â»Â¹ mod 9 | Error | 10 |
| `test_mod_exp_simple` | 3^7 mod 11 | 9 | 10 |
| `test_mod_exp_large` | Grands exposants | Correct | 10 |
| `test_euler_phi_prime` | Ï†(7) | 6 | 5 |
| `test_euler_phi_composite` | Ï†(12) | 4 | 5 |
| `test_euler_phi_prime_power` | Ï†(8) | 4 | 5 |
| `test_complete_workflow` | Workflow RSA-like | Correct | 5 |

### 4.2 main.rs de test

```rust
//! Test runner pour cles_royaume.rs

mod cles_royaume;
use cles_royaume::*;

fn main() {
    let mut passed = 0;
    let mut failed = 0;

    // Test 1: mod_add simple
    let ops = vec![OperationType::ModAdd {
        a: "5".to_string(),
        b: "7".to_string(),
        n: "10".to_string(),
    }];
    let results = process_operations(ops);
    if results[0].result == Ok("2".to_string()) {
        println!("Test mod_add simple: OK");
        passed += 1;
    } else {
        println!("Test mod_add simple: FAIL (got {:?})", results[0].result);
        failed += 1;
    }

    // Test 2: mod_add large
    let ops = vec![OperationType::ModAdd {
        a: "123456789".to_string(),
        b: "987654321".to_string(),
        n: "1000000007".to_string(),
    }];
    let results = process_operations(ops);
    if results[0].result == Ok("111111103".to_string()) {
        println!("Test mod_add large: OK");
        passed += 1;
    } else {
        println!("Test mod_add large: FAIL");
        failed += 1;
    }

    // Test 3: gcd_extended
    let ops = vec![OperationType::GcdExtended {
        a: "35".to_string(),
        b: "15".to_string(),
    }];
    let results = process_operations(ops);
    if let Some(ref ext) = results[0].extended_result {
        if ext.gcd == "5" {
            // Verify: a*x + b*y = gcd
            println!("Test gcd_extended: OK (gcd=5, x={}, y={})", ext.x, ext.y);
            passed += 1;
        } else {
            println!("Test gcd_extended: FAIL (gcd={})", ext.gcd);
            failed += 1;
        }
    } else {
        println!("Test gcd_extended: FAIL (no extended result)");
        failed += 1;
    }

    // Test 4: mod_inverse exists
    let ops = vec![OperationType::ModInverse {
        a: "7".to_string(),
        n: "11".to_string(),
    }];
    let results = process_operations(ops);
    if results[0].result == Ok("8".to_string()) {
        // Verify: 7 * 8 mod 11 = 56 mod 11 = 1
        println!("Test mod_inverse (exists): OK");
        passed += 1;
    } else {
        println!("Test mod_inverse (exists): FAIL");
        failed += 1;
    }

    // Test 5: mod_inverse doesn't exist
    let ops = vec![OperationType::ModInverse {
        a: "6".to_string(),
        n: "9".to_string(),
    }];
    let results = process_operations(ops);
    if results[0].result.is_err() {
        println!("Test mod_inverse (no inverse): OK");
        passed += 1;
    } else {
        println!("Test mod_inverse (no inverse): FAIL (should be error)");
        failed += 1;
    }

    // Test 6: mod_exp
    let ops = vec![OperationType::ModExp {
        base: "3".to_string(),
        exp: "7".to_string(),
        modulo: "11".to_string(),
    }];
    let results = process_operations(ops);
    // 3^7 = 2187, 2187 mod 11 = 9
    if results[0].result == Ok("9".to_string()) {
        println!("Test mod_exp: OK");
        passed += 1;
    } else {
        println!("Test mod_exp: FAIL (got {:?})", results[0].result);
        failed += 1;
    }

    // Test 7: euler_phi
    let ops = vec![OperationType::EulerPhi {
        n: "12".to_string(),
    }];
    let results = process_operations(ops);
    // Ï†(12) = 12 Ã— (1 - 1/2) Ã— (1 - 1/3) = 12 Ã— 1/2 Ã— 2/3 = 4
    if results[0].result == Ok("4".to_string()) {
        println!("Test euler_phi: OK");
        passed += 1;
    } else {
        println!("Test euler_phi: FAIL");
        failed += 1;
    }

    // Test 8: mod_exp with large exponent
    let ops = vec![OperationType::ModExp {
        base: "2".to_string(),
        exp: "100".to_string(),
        modulo: "1000000007".to_string(),
    }];
    let results = process_operations(ops);
    // 2^100 mod 1000000007 = 976371285
    if results[0].result == Ok("976371285".to_string()) {
        println!("Test mod_exp large: OK");
        passed += 1;
    } else {
        println!("Test mod_exp large: FAIL (got {:?})", results[0].result);
        failed += 1;
    }

    println!("\n=== {}/{} tests passed ===", passed, passed + failed);
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
//! Solution de rÃ©fÃ©rence - cles_royaume.rs
//! ImplÃ©mentation from-scratch de l'arithmÃ©tique modulaire pour crypto

use std::cmp::Ordering;

pub type BigInt = String;

#[derive(Debug, Clone)]
pub enum OperationType {
    ModAdd { a: BigInt, b: BigInt, n: BigInt },
    ModMul { a: BigInt, b: BigInt, n: BigInt },
    GcdExtended { a: BigInt, b: BigInt },
    ModInverse { a: BigInt, n: BigInt },
    ModExp { base: BigInt, exp: BigInt, modulo: BigInt },
    EulerPhi { n: BigInt },
}

#[derive(Debug, Clone)]
pub struct OperationResult {
    pub operation_index: usize,
    pub result: Result<BigInt, String>,
    pub method: String,
    pub extended_result: Option<ExtendedGcdResult>,
}

#[derive(Debug, Clone)]
pub struct ExtendedGcdResult {
    pub gcd: BigInt,
    pub x: BigInt,
    pub y: BigInt,
}

pub fn process_operations(operations: Vec<OperationType>) -> Vec<OperationResult> {
    operations
        .into_iter()
        .enumerate()
        .map(|(i, op)| match op {
            OperationType::ModAdd { a, b, n } => OperationResult {
                operation_index: i,
                result: Ok(mod_add(&a, &b, &n)),
                method: "standard".to_string(),
                extended_result: None,
            },
            OperationType::ModMul { a, b, n } => OperationResult {
                operation_index: i,
                result: Ok(mod_mul(&a, &b, &n)),
                method: "standard".to_string(),
                extended_result: None,
            },
            OperationType::GcdExtended { a, b } => {
                let ext = gcd_extended(&a, &b);
                OperationResult {
                    operation_index: i,
                    result: Ok(ext.gcd.clone()),
                    method: "extended_euclid".to_string(),
                    extended_result: Some(ext),
                }
            }
            OperationType::ModInverse { a, n } => {
                let res = mod_inverse(&a, &n);
                OperationResult {
                    operation_index: i,
                    result: res,
                    method: "extended_euclid".to_string(),
                    extended_result: None,
                }
            }
            OperationType::ModExp { base, exp, modulo } => OperationResult {
                operation_index: i,
                result: Ok(mod_exp(&base, &exp, &modulo)),
                method: "square_and_multiply".to_string(),
                extended_result: None,
            },
            OperationType::EulerPhi { n } => OperationResult {
                operation_index: i,
                result: Ok(euler_phi(&n)),
                method: "factorization".to_string(),
                extended_result: None,
            },
        })
        .collect()
}

// ============= BIGINT OPERATIONS =============

fn parse_digits(s: &str) -> Vec<u8> {
    s.chars()
        .filter(|c| c.is_ascii_digit())
        .map(|c| c.to_digit(10).unwrap() as u8)
        .collect()
}

fn digits_to_string(digits: &[u8]) -> String {
    if digits.is_empty() {
        return "0".to_string();
    }
    // Remove leading zeros
    let start = digits.iter().position(|&d| d != 0).unwrap_or(digits.len() - 1);
    digits[start..].iter().map(|d| (b'0' + d) as char).collect()
}

fn bigint_cmp(a: &str, b: &str) -> Ordering {
    let a_neg = a.starts_with('-');
    let b_neg = b.starts_with('-');

    if a_neg && !b_neg {
        return Ordering::Less;
    }
    if !a_neg && b_neg {
        return Ordering::Greater;
    }

    let a_clean: String = a.chars().filter(|c| c.is_ascii_digit()).collect();
    let b_clean: String = b.chars().filter(|c| c.is_ascii_digit()).collect();

    let cmp = match a_clean.len().cmp(&b_clean.len()) {
        Ordering::Equal => a_clean.cmp(&b_clean),
        other => other,
    };

    if a_neg && b_neg {
        cmp.reverse()
    } else {
        cmp
    }
}

fn bigint_add(a: &str, b: &str) -> BigInt {
    let a_digits: Vec<u8> = parse_digits(a);
    let b_digits: Vec<u8> = parse_digits(b);

    let max_len = a_digits.len().max(b_digits.len());
    let mut result = vec![0u8; max_len + 1];
    let mut carry = 0u8;

    for i in 0..max_len {
        let a_val = if i < a_digits.len() {
            a_digits[a_digits.len() - 1 - i]
        } else {
            0
        };
        let b_val = if i < b_digits.len() {
            b_digits[b_digits.len() - 1 - i]
        } else {
            0
        };

        let sum = a_val + b_val + carry;
        result[max_len - i] = sum % 10;
        carry = sum / 10;
    }
    result[0] = carry;

    digits_to_string(&result)
}

fn bigint_sub(a: &str, b: &str) -> BigInt {
    // Assumes a >= b for simplicity
    if bigint_cmp(a, b) == Ordering::Less {
        let result = bigint_sub(b, a);
        return format!("-{}", result);
    }

    let a_digits: Vec<u8> = parse_digits(a);
    let b_digits: Vec<u8> = parse_digits(b);

    let mut result = vec![0u8; a_digits.len()];
    let mut borrow = 0i8;

    for i in 0..a_digits.len() {
        let a_val = a_digits[a_digits.len() - 1 - i] as i8;
        let b_val = if i < b_digits.len() {
            b_digits[b_digits.len() - 1 - i] as i8
        } else {
            0
        };

        let mut diff = a_val - b_val - borrow;
        if diff < 0 {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        result[a_digits.len() - 1 - i] = diff as u8;
    }

    digits_to_string(&result)
}

fn bigint_mul(a: &str, b: &str) -> BigInt {
    let a_digits: Vec<u8> = parse_digits(a);
    let b_digits: Vec<u8> = parse_digits(b);

    let mut result = vec![0u16; a_digits.len() + b_digits.len()];

    for (i, &a_val) in a_digits.iter().rev().enumerate() {
        for (j, &b_val) in b_digits.iter().rev().enumerate() {
            let pos = result.len() - 1 - i - j;
            result[pos] += (a_val as u16) * (b_val as u16);
        }
    }

    // Normalize
    for i in (1..result.len()).rev() {
        result[i - 1] += result[i] / 10;
        result[i] %= 10;
    }

    let result_u8: Vec<u8> = result.iter().map(|&x| x as u8).collect();
    digits_to_string(&result_u8)
}

fn bigint_div(a: &str, b: &str) -> (BigInt, BigInt) {
    if b == "0" {
        panic!("Division by zero");
    }

    if bigint_cmp(a, b) == Ordering::Less {
        return ("0".to_string(), a.to_string());
    }

    let a_digits: Vec<u8> = parse_digits(a);
    let mut quotient = String::new();
    let mut current = String::new();

    for &digit in &a_digits {
        current.push((b'0' + digit) as char);
        // Remove leading zeros
        current = current.trim_start_matches('0').to_string();
        if current.is_empty() {
            current = "0".to_string();
        }

        let mut count = 0u8;
        while bigint_cmp(&current, b) != Ordering::Less {
            current = bigint_sub(&current, b);
            count += 1;
        }
        quotient.push((b'0' + count) as char);
    }

    let quotient = quotient.trim_start_matches('0').to_string();
    let quotient = if quotient.is_empty() {
        "0".to_string()
    } else {
        quotient
    };

    (quotient, current)
}

fn bigint_mod(a: &str, n: &str) -> BigInt {
    let (_, remainder) = bigint_div(a, n);
    remainder
}

// ============= MODULAR OPERATIONS =============

fn mod_add(a: &str, b: &str, n: &str) -> BigInt {
    let sum = bigint_add(a, b);
    bigint_mod(&sum, n)
}

fn mod_mul(a: &str, b: &str, n: &str) -> BigInt {
    let a_mod = bigint_mod(a, n);
    let b_mod = bigint_mod(b, n);
    let product = bigint_mul(&a_mod, &b_mod);
    bigint_mod(&product, n)
}

fn gcd_extended(a: &str, b: &str) -> ExtendedGcdResult {
    if b == "0" {
        return ExtendedGcdResult {
            gcd: a.to_string(),
            x: "1".to_string(),
            y: "0".to_string(),
        };
    }

    let (q, r) = bigint_div(a, b);
    let ext = gcd_extended(b, &r);

    // x = y_prev
    // y = x_prev - q * y_prev
    let new_x = ext.y.clone();
    let qy = bigint_mul(&q, &ext.y);

    let new_y = if ext.x.starts_with('-') {
        let x_abs = ext.x.trim_start_matches('-');
        format!("-{}", bigint_add(x_abs, &qy))
    } else if bigint_cmp(&ext.x, &qy) == Ordering::Less {
        format!("-{}", bigint_sub(&qy, &ext.x))
    } else {
        bigint_sub(&ext.x, &qy)
    };

    ExtendedGcdResult {
        gcd: ext.gcd,
        x: new_x,
        y: new_y,
    }
}

fn mod_inverse(a: &str, n: &str) -> Result<BigInt, String> {
    let ext = gcd_extended(a, n);

    if ext.gcd != "1" {
        return Err(format!(
            "No inverse exists: gcd({}, {}) = {} â‰  1",
            a, n, ext.gcd
        ));
    }

    // x might be negative, need to make it positive mod n
    if ext.x.starts_with('-') {
        let x_abs = ext.x.trim_start_matches('-');
        Ok(bigint_sub(n, x_abs))
    } else {
        Ok(bigint_mod(&ext.x, n))
    }
}

fn mod_exp(base: &str, exp: &str, modulo: &str) -> BigInt {
    if exp == "0" {
        return "1".to_string();
    }
    if modulo == "1" {
        return "0".to_string();
    }

    let mut result = "1".to_string();
    let mut base_mod = bigint_mod(base, modulo);
    let mut exp_remaining = exp.to_string();

    // Square-and-multiply
    while exp_remaining != "0" {
        // Check if exp is odd
        let last_digit = exp_remaining.chars().last().unwrap().to_digit(10).unwrap();
        if last_digit % 2 == 1 {
            result = mod_mul(&result, &base_mod, modulo);
        }

        // exp = exp / 2
        let (q, _) = bigint_div(&exp_remaining, "2");
        exp_remaining = q;

        // base = base^2 mod modulo
        base_mod = mod_mul(&base_mod, &base_mod, modulo);
    }

    result
}

fn euler_phi(n: &str) -> BigInt {
    if n == "1" {
        return "1".to_string();
    }

    let mut result = n.to_string();
    let mut temp_n = n.to_string();
    let mut p = "2".to_string();

    // Find prime factors and apply Ï†(n) = n Ã— âˆ(1 - 1/p)
    while bigint_cmp(&bigint_mul(&p, &p), &temp_n) != Ordering::Greater {
        if bigint_mod(&temp_n, &p) == "0" {
            // p is a factor
            // result = result - result/p
            let (div_result, _) = bigint_div(&result, &p);
            result = bigint_sub(&result, &div_result);

            // Remove all factors of p
            while bigint_mod(&temp_n, &p) == "0" {
                let (q, _) = bigint_div(&temp_n, &p);
                temp_n = q;
            }
        }
        p = bigint_add(&p, "1");
    }

    // If temp_n > 1, then it's a prime factor
    if bigint_cmp(&temp_n, "1") == Ordering::Greater {
        let (div_result, _) = bigint_div(&result, &temp_n);
        result = bigint_sub(&result, &div_result);
    }

    result
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1 : Utilisation de u128 pour petits nombres puis fallback
fn mod_exp_hybrid(base: &str, exp: &str, modulo: &str) -> BigInt {
    // Try u128 first for performance
    if let (Ok(b), Ok(e), Ok(m)) = (
        base.parse::<u128>(),
        exp.parse::<u128>(),
        modulo.parse::<u128>()
    ) {
        if m > 0 && m < (1u128 << 64) {
            return fast_mod_exp_u128(b, e, m).to_string();
        }
    }
    // Fallback to BigInt
    mod_exp_bigint(base, exp, modulo)
}
```

### 4.5 Solutions refusÃ©es (avec explications)

```rust
// REFUSÃ‰ 1 : Exponentiation naÃ¯ve O(n)
fn mod_exp_naive(base: &str, exp: &str, modulo: &str) -> BigInt {
    let mut result = "1".to_string();
    let mut i = "0".to_string();
    while bigint_cmp(&i, exp) == Ordering::Less {
        result = mod_mul(&result, base, modulo);
        i = bigint_add(&i, "1");
    }
    result
}
// Pourquoi refusÃ© : O(n) au lieu de O(log n), inutilisable pour RSA

// REFUSÃ‰ 2 : Division par zÃ©ro non gÃ©rÃ©e
fn bigint_div(a: &str, b: &str) -> (BigInt, BigInt) {
    // Pas de vÃ©rification si b == "0"
    // ...
}
// Pourquoi refusÃ© : Crash ou comportement indÃ©fini

// REFUSÃ‰ 3 : Inverse sans vÃ©rification du GCD
fn mod_inverse(a: &str, n: &str) -> BigInt {
    let ext = gcd_extended(a, n);
    ext.x // Retourne mÃªme si gcd != 1
}
// Pourquoi refusÃ© : L'inverse n'existe pas si gcd(a,n) != 1
```

### 4.9 spec.json

```json
{
  "name": "cles_royaume",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "MÃ©lange (concepts a-f)",
  "tags": ["crypto", "math", "modular-arithmetic", "rsa", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "process_operations",
    "prototype": "pub fn process_operations(operations: Vec<OperationType>) -> Vec<OperationResult>",
    "return_type": "Vec<OperationResult>",
    "parameters": [
      {"name": "operations", "type": "Vec<OperationType>"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "mod_add_simple",
        "args": [{"ModAdd": {"a": "5", "b": "7", "n": "10"}}],
        "expected": "2"
      },
      {
        "name": "mod_inverse_exists",
        "args": [{"ModInverse": {"a": "7", "n": "11"}}],
        "expected": "8"
      },
      {
        "name": "mod_inverse_not_exists",
        "args": [{"ModInverse": {"a": "6", "n": "9"}}],
        "expected_error": true,
        "is_trap": true,
        "trap_explanation": "gcd(6,9) = 3 â‰  1, pas d'inverse"
      },
      {
        "name": "mod_exp_zero",
        "args": [{"ModExp": {"base": "5", "exp": "0", "modulo": "7"}}],
        "expected": "1",
        "is_trap": true,
        "trap_explanation": "Tout nombre^0 = 1"
      }
    ]
  },

  "norm": {
    "allowed_functions": ["std::*"],
    "forbidden_functions": ["unsafe"],
    "forbidden_crates": ["num-bigint", "rug", "gmp"],
    "check_security": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
// Mutant A (Boundary) : Off-by-one dans square-and-multiply
fn mod_exp(base: &str, exp: &str, modulo: &str) -> BigInt {
    // BUG: Condition de boucle incorrecte
    while exp_remaining != "1" {  // Devrait Ãªtre "0"
        // ...
    }
}
// Pourquoi c'est faux : Ne traite pas le dernier bit

// Mutant B (Safety) : Division par zÃ©ro
fn bigint_mod(a: &str, n: &str) -> BigInt {
    // BUG: Pas de vÃ©rification n == "0"
    let (_, r) = bigint_div(a, n);
    r
}

// Mutant C (Logic) : GCD Ã©tendu avec mauvais signe
fn gcd_extended(a: &str, b: &str) -> ExtendedGcdResult {
    // BUG: new_y = x_prev + q * y_prev (+ au lieu de -)
    let new_y = bigint_add(&ext.x, &qy);
}

// Mutant D (Return) : Inverse toujours positif
fn mod_inverse(a: &str, n: &str) -> Result<BigInt, String> {
    let ext = gcd_extended(a, n);
    // BUG: Ne normalise pas le rÃ©sultat nÃ©gatif
    Ok(ext.x)  // Peut retourner un nombre nÃ©gatif
}

// Mutant E (Logic) : Euler phi incomplet
fn euler_phi(n: &str) -> BigInt {
    // BUG: Ne gÃ¨re pas le dernier facteur premier
    // Si temp_n > 1 aprÃ¨s la boucle, c'est un facteur premier qu'on ignore
}
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

| Concept | Formule | Application |
|---------|---------|-------------|
| **ArithmÃ©tique modulaire** | a mod n | Base de toute crypto |
| **PGCD** | gcd(a,b) via Euclide | VÃ©rifier coprimaritÃ© |
| **BÃ©zout** | ax + by = gcd(a,b) | Trouver l'inverse |
| **Inverse modulaire** | aâ»Â¹ tel que aaâ»Â¹ â‰¡ 1 | DÃ©chiffrement RSA |
| **Petit thÃ©orÃ¨me de Fermat** | a^(p-1) â‰¡ 1 (mod p) | Optimisation |
| **Fonction Ï† d'Euler** | Ï†(n) = nombres premiers avec n | Exposant RSA |
| **Square-and-multiply** | a^e en O(log e) | Exponentiation rapide |

### 5.2 LDA

```
FONCTION mod_exp QUI RETOURNE UN BIGINT ET PREND base, exp, modulo COMME BIGINT
DÃ‰BUT FONCTION
    SI exp EST Ã‰GAL Ã€ "0" ALORS
        RETOURNER "1"
    FIN SI
    SI modulo EST Ã‰GAL Ã€ "1" ALORS
        RETOURNER "0"
    FIN SI

    DÃ‰CLARER result COMME "1"
    DÃ‰CLARER base_mod COMME base MODULO modulo

    TANT QUE exp EST DIFFÃ‰RENT DE "0" FAIRE
        SI exp EST IMPAIR ALORS
            result â† (result Ã— base_mod) MODULO modulo
        FIN SI
        exp â† exp DIVISÃ‰ PAR 2
        base_mod â† (base_mod Ã— base_mod) MODULO modulo
    FIN TANT QUE

    RETOURNER result
FIN FONCTION
```

### 5.3 Visualisation ASCII

**Square-and-Multiply pour 3^7 mod 11 :**

```
Exposant 7 en binaire : 111

Ã‰tape   | exp (bin) | result | base_mod | Action
--------|-----------|--------|----------|--------
Init    | 111       | 1      | 3        |
Iter 1  | 111       | 1Ã—3=3  | 3        | exp impair â†’ mult
        | 011       | 3      | 9        | baseÂ² mod 11
Iter 2  | 011       | 3Ã—9=27â†’5| 9       | exp impair â†’ mult
        | 001       | 5      | 81â†’4    | baseÂ² mod 11
Iter 3  | 001       | 5Ã—4=20â†’9| 4       | exp impair â†’ mult
        | 000       | 9      | â€”        | STOP

RÃ©sultat : 3^7 mod 11 = 9 âœ“
```

**Algorithme d'Euclide Ã©tendu pour gcd(35, 15) :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ gcd(35, 15)                                              â”‚
â”‚   35 = 2Ã—15 + 5                                          â”‚
â”‚   â†’ gcd(15, 5)                                           â”‚
â”‚       15 = 3Ã—5 + 0                                       â”‚
â”‚       â†’ gcd(5, 0) = 5                                    â”‚
â”‚                                                          â”‚
â”‚ RemontÃ©e des coefficients :                              â”‚
â”‚   gcd(5, 0)  : x=1, y=0   â†’ 5 = 5Ã—1 + 0Ã—0               â”‚
â”‚   gcd(15, 5) : x=0, y=1   â†’ 5 = 15Ã—0 + 5Ã—1              â”‚
â”‚   gcd(35, 15): x=1, y=-2  â†’ 5 = 35Ã—1 + 15Ã—(-2)          â”‚
â”‚                          = 35 - 30 = 5 âœ“                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "The Imitation Game" â€” Euclide Ã©tendu

*"Comme Turing cassant Enigma en utilisant les faiblesses mathÃ©matiques, tu utilises Euclide Ã©tendu pour trouver l'inverse modulaire."*

```rust
// Turing cherchait des patterns. Euclide aussi.
// ax + by = gcd(a,b)
// Si gcd = 1, alors x est l'inverse de a mod b !
```

#### ğŸ”¢ MEME : "It's over 9000!" â€” Overflow

*"Vegeta n'a jamais gÃ©rÃ© l'overflow de son scouter. Toi, tu dois gÃ©rer l'overflow de tes multiplications."*

```rust
// DANGER: u64 * u64 peut overflow !
// Solution: rÃ©duire modulo AVANT de multiplier
let a_mod = bigint_mod(a, n);  // RÃ©duire d'abord
let b_mod = bigint_mod(b, n);
let product = bigint_mul(&a_mod, &b_mod);  // Puis multiplier
```

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Exercice ID** | 3.1.2-a |
| **Nom** | cles_royaume |
| **DifficultÃ©** | 8/10 |
| **Langage** | Rust Edition 2024 |
| **XP Base** | 250 |
| **XP Bonus** | 750 (Ã—3) |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.1.2-a-cles-royaume",
    "generated_at": "2026-01-11 16:00:00",

    "metadata": {
      "exercise_id": "3.1.2-a",
      "exercise_name": "cles_royaume",
      "module": "3.1.2",
      "phase": 3,
      "difficulty": 8,
      "language": "rust",
      "xp_base": 250,
      "bonus_tier": "AVANCÃ‰",
      "bonus_icon": "ğŸ”¥"
    }
  }
}
```

---

*Document gÃ©nÃ©rÃ© selon HACKBRAIN v5.5.2*
*"L'excellence pÃ©dagogique ne se nÃ©gocie pas â€” pas de raccourcis"*
