# Exercice 3.1.7-a : protocoles_blindes

**Module :**
3.1.7 ‚Äî Protocoles Cryptographiques

**Concept :**
a ‚Äî TLS, SSH et tunnels s√©curis√©s

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Python 3.14

**Pr√©requis :**
3.1.4-c (cryptographie asym√©trique), 3.1.5-a (fonctions de hachage), 3.1.6-a (PKI)

**Domaines :**
Crypto, Net, Encodage

**Dur√©e estim√©e :**
120 min

**XP Base :**
250

**Complexit√© :**
T2 O(n) √ó S2 O(handshake_size)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `protocoles_blindes.py`
**Autoris√© :** cryptography, ssl, socket, paramiko (pour SSH), hashlib
**Interdit :** subprocess (pas d'appels openssl CLI directs), requests (trop haut niveau)

### 1.2 Consigne

**üéÆ "Person of Interest" ‚Äî La Machine qui Surveille Tout**

*"You are being watched. The government has a secret system, a machine that spies on you every hour of every day."* ‚Äî Harold Finch

Tu es **Harold Finch**, le g√©nie qui a cr√©√© La Machine. Pour prot√©ger les communications de ton √©quipe contre Samaritan (l'IA rivale), tu dois ma√Ætriser les protocoles de communication s√©curis√©e.

Chaque canal (TLS, SSH, VPN) est comme un tunnel blind√© entre toi et tes "num√©ros pertinents". Si Samaritan intercepte la communication, il peut pr√©dire tes mouvements. Tu dois t'assurer que chaque tunnel est **imp√©n√©trable**.

**Ta mission :**

1. **Auditer les configurations TLS** : Analyser les cipher suites, d√©tecter les vuln√©rabilit√©s
2. **Identifier les attaques historiques** : BEAST, POODLE, Heartbleed, CRIME, DROWN
3. **Comparer TLS 1.2 vs 1.3** : Comprendre les am√©liorations
4. **Analyser SSH** : Hardening, key exchange, host key verification
5. **Comparer VPN protocols** : IPsec vs WireGuard vs OpenVPN

### 1.2.2 Consigne Acad√©mique

Cet exercice couvre l'analyse et l'audit des protocoles de s√©curit√© r√©seau. Les objectifs sont :

1. Comprendre le handshake TLS et ses √©volutions (1.2 ‚Üí 1.3)
2. Identifier les vuln√©rabilit√©s historiques des protocoles
3. Auditer des configurations de s√©curit√©
4. Comparer les diff√©rentes solutions de tunneling (SSH, VPN)
5. Recommander des configurations s√©curis√©es selon le contexte

### 1.3 Prototype

```python
def protocoles_blindes(input_json: str) -> str:
    """Point d'entr√©e principal"""
    pass

# Analyse TLS
def parse_tls_config(config: dict) -> dict:
    """Parse une configuration TLS et extrait les param√®tres"""
    pass

def audit_cipher_suite(suite: str) -> dict:
    """Analyse une cipher suite (ex: TLS_AES_256_GCM_SHA384)"""
    pass

def detect_tls_vulnerabilities(config: dict) -> list:
    """D√©tecte les vuln√©rabilit√©s connues dans une config TLS"""
    pass

def compare_tls_versions(v1: str, v2: str) -> dict:
    """Compare deux versions TLS (fonctionnalit√©s, s√©curit√©)"""
    pass

def simulate_tls_handshake(version: str, cipher: str) -> dict:
    """Simule un handshake TLS et retourne les √©tapes"""
    pass

# Analyse d'attaques
def identify_attack(symptoms: dict) -> dict:
    """Identifie une attaque √† partir de ses sympt√¥mes"""
    pass

def explain_attack(attack_name: str) -> dict:
    """Explique une attaque (BEAST, POODLE, etc.)"""
    pass

# SSH
def parse_ssh_config(config: str) -> dict:
    """Parse un fichier sshd_config"""
    pass

def audit_ssh_config(config: dict) -> dict:
    """Audite une configuration SSH"""
    pass

def recommend_ssh_hardening(current_config: dict) -> list:
    """Recommande des am√©liorations SSH"""
    pass

# VPN
def compare_vpn_protocols(protocols: list) -> dict:
    """Compare des protocoles VPN (IPsec, WireGuard, OpenVPN)"""
    pass

def analyze_wireguard_config(config: str) -> dict:
    """Analyse une configuration WireGuard"""
    pass
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### Heartbleed ‚Äî Le Bug √† $500M

En avril 2014, Heartbleed (CVE-2014-0160) a expos√© les cl√©s priv√©es de 17% des serveurs HTTPS du monde. Un simple bug de bounds checking dans OpenSSL permettait de lire 64KB de m√©moire serveur. Le correctif a co√ªt√© estimativement $500 millions √† l'industrie.

### Le Handshake TLS 1.3 ‚Äî 1-RTT Revolution

TLS 1.3 a r√©duit le handshake de 2-RTT √† 1-RTT (voire 0-RTT avec resumption). Google a mesur√© une am√©lioration de 100ms sur les connexions mobiles ‚Äî ce qui repr√©sente des milliards de dollars en commerce √©lectronique.

### WireGuard ‚Äî 4000 lignes vs 400,000

WireGuard fait ~4000 lignes de code. OpenVPN en fait ~100,000, IPsec ~400,000. Moins de code = moins de surface d'attaque = plus facile √† auditer.

---

## üìç SECTION 2.5 : DANS LA VRAIE VIE

| M√©tier | Utilisation |
|--------|-------------|
| **Security Engineer** | Audit des configurations TLS/SSH, d√©ploiement de politiques de s√©curit√© |
| **DevOps/SRE** | Configuration des reverse proxies (nginx, HAProxy), hardening SSH |
| **Pentester** | Test des cipher suites faibles, exploitation des vuln√©rabilit√©s TLS |
| **Cloud Architect** | Choix et configuration des VPN inter-datacenter (WireGuard vs IPsec) |
| **Compliance Officer** | V√©rification conformit√© PCI-DSS, HIPAA (exigences TLS 1.2+) |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
protocoles_blindes.py  main.py

$ python main.py

$ python -c "
from protocoles_blindes import *
import json

# Audit d'une cipher suite
result = audit_cipher_suite('TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384')
print(json.dumps(result, indent=2))
"
{
  "cipher_suite": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
  "key_exchange": "ECDHE",
  "authentication": "RSA",
  "encryption": "AES_256_GCM",
  "mac": "SHA384",
  "forward_secrecy": true,
  "aead": true,
  "security_rating": "A",
  "recommendations": []
}

$ python -c "
from protocoles_blindes import *

# D√©tection d'attaque
attack = identify_attack({
    'protocol': 'TLS 1.0',
    'cipher_mode': 'CBC',
    'symptom': 'padding_oracle'
})
print(attack['name'], '-', attack['cve'])
"
POODLE - CVE-2014-3566

$ python -c "
from protocoles_blindes import *

# Comparaison TLS versions
diff = compare_tls_versions('TLS 1.2', 'TLS 1.3')
print('Round trips:', diff['tls_1.2']['round_trips'], '‚Üí', diff['tls_1.3']['round_trips'])
print('Cipher suites removed:', len(diff['removed_ciphers']))
"
Round trips: 2 ‚Üí 1
Cipher suites removed: 37
```

---

## üî• SECTION 3.1 : BONUS AVANC√â (OPTIONNEL)

**Difficult√© Bonus :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (9/10)

**R√©compense :**
XP √ó3

**Time Complexity attendue :**
O(n √ó m) o√π n = nombre de connexions, m = taille des logs

**Space Complexity attendue :**
O(log_size)

**Domaines Bonus :**
`Net, Struct`

### 3.1.1 Consigne Bonus

**üéÆ "Person of Interest" ‚Äî Traquer Samaritan**

Samaritan lance des attaques contre tes tunnels. Tu dois impl√©menter un **syst√®me de d√©tection d'intrusion (IDS)** pour les protocoles cryptographiques.

**Ta mission :**

1. **Analyser des logs TLS** pour d√©tecter des patterns d'attaque
2. **Impl√©menter la d√©tection de downgrade attacks**
3. **Cr√©er un score de risque** bas√© sur les configurations observ√©es
4. **G√©n√©rer des alertes** pour les comportements suspects

**Contraintes :**
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  D√©tection en temps r√©el simul√©         ‚îÇ
‚îÇ  False positive rate < 1%               ‚îÇ
‚îÇ  Support TLS 1.0, 1.1, 1.2, 1.3         ‚îÇ
‚îÇ  Logs jusqu'√† 100,000 entr√©es           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

### 3.1.2 Prototype Bonus

```python
def analyze_tls_logs(logs: list) -> dict:
    """Analyse des logs TLS pour d√©tecter des attaques"""
    pass

def detect_downgrade_attack(handshakes: list) -> list:
    """D√©tecte les tentatives de downgrade"""
    pass

def calculate_risk_score(config: dict, history: list) -> float:
    """Calcule un score de risque 0-100"""
    pass

def generate_security_report(analysis: dict) -> str:
    """G√©n√®re un rapport de s√©curit√© markdown"""
    pass
```

### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Analyse | Config statique | Logs dynamiques |
| D√©tection | Vuln√©rabilit√©s connues | Patterns d'attaque en temps r√©el |
| Output | Dict simple | Rapport + score + alertes |
| Volume | Config unique | Jusqu'√† 100k logs |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Input | Expected | Points |
|------|-------|----------|--------|
| `cipher_suite_modern` | `TLS_AES_256_GCM_SHA384` | rating: "A+" | 5 |
| `cipher_suite_weak` | `TLS_RSA_WITH_RC4_128_SHA` | rating: "F", warnings: [...] | 5 |
| `cipher_suite_null` | `TLS_NULL_WITH_NULL_NULL` | rating: "F", critical: true | 5 |
| `detect_beast` | symptoms: {TLS1.0, CBC, chosen_plaintext} | attack: "BEAST" | 10 |
| `detect_poodle` | symptoms: {TLS1.0, CBC, padding_oracle} | attack: "POODLE" | 10 |
| `detect_heartbleed` | symptoms: {memory_leak, heartbeat} | attack: "Heartbleed" | 10 |
| `tls_compare` | "TLS 1.2", "TLS 1.3" | round_trips: 2‚Üí1, removed_ciphers: 37 | 10 |
| `ssh_weak_config` | PermitRootLogin=yes, Password=yes | findings: 2+ critical | 10 |
| `ssh_hardened` | Modern config | findings: 0 critical | 10 |
| `vpn_compare` | [IPsec, WireGuard] | latency, complexity, security | 10 |
| `handshake_tls13` | version=1.3, cipher=AES_256_GCM | steps: 3 (vs 7 for 1.2) | 10 |
| `wireguard_parse` | Valid config | endpoints, peers, keys | 5 |

### 4.2 main.py de test

```python
import json
from protocoles_blindes import *

def test_all():
    # Test 1: Cipher suite moderne
    result = audit_cipher_suite("TLS_AES_256_GCM_SHA384")
    assert result['security_rating'] in ['A', 'A+'], f"Modern cipher should be A/A+, got {result['security_rating']}"
    assert result['aead'] == True
    print("‚úÖ Test cipher suite moderne: OK")

    # Test 2: Cipher suite faible
    result = audit_cipher_suite("TLS_RSA_WITH_RC4_128_SHA")
    assert result['security_rating'] == 'F', "RC4 should be F"
    assert 'RC4' in str(result.get('warnings', []))
    print("‚úÖ Test cipher suite faible: OK")

    # Test 3: D√©tection BEAST
    attack = identify_attack({
        'protocol': 'TLS 1.0',
        'cipher_mode': 'CBC',
        'symptom': 'chosen_plaintext'
    })
    assert attack['name'] == 'BEAST', f"Should detect BEAST, got {attack['name']}"
    assert 'CVE-2011-3389' in attack.get('cve', '')
    print("‚úÖ Test d√©tection BEAST: OK")

    # Test 4: D√©tection POODLE
    attack = identify_attack({
        'protocol': 'SSL 3.0',
        'cipher_mode': 'CBC',
        'symptom': 'padding_oracle'
    })
    assert attack['name'] == 'POODLE'
    print("‚úÖ Test d√©tection POODLE: OK")

    # Test 5: D√©tection Heartbleed
    attack = identify_attack({
        'extension': 'heartbeat',
        'symptom': 'memory_disclosure',
        'bytes_leaked': 64000
    })
    assert attack['name'] == 'Heartbleed'
    print("‚úÖ Test d√©tection Heartbleed: OK")

    # Test 6: Comparaison TLS versions
    diff = compare_tls_versions('TLS 1.2', 'TLS 1.3')
    assert diff['tls_1.2']['round_trips'] == 2
    assert diff['tls_1.3']['round_trips'] == 1
    assert len(diff.get('removed_ciphers', [])) >= 30
    print("‚úÖ Test comparaison TLS: OK")

    # Test 7: Audit SSH config faible
    weak_config = {
        'PermitRootLogin': 'yes',
        'PasswordAuthentication': 'yes',
        'Protocol': '1,2',
        'Ciphers': 'aes128-cbc,3des-cbc',
        'PermitEmptyPasswords': 'yes'
    }
    result = audit_ssh_config(weak_config)
    critical = [f for f in result.get('findings', []) if f.get('severity') == 'critical']
    assert len(critical) >= 2, f"Should have 2+ critical findings, got {len(critical)}"
    print("‚úÖ Test SSH config faible: OK")

    # Test 8: Audit SSH config durcie
    hardened_config = {
        'PermitRootLogin': 'no',
        'PasswordAuthentication': 'no',
        'PubkeyAuthentication': 'yes',
        'Protocol': '2',
        'Ciphers': 'chacha20-poly1305@openssh.com,aes256-gcm@openssh.com',
        'KexAlgorithms': 'curve25519-sha256@libssh.org',
        'MACs': 'hmac-sha2-512-etm@openssh.com'
    }
    result = audit_ssh_config(hardened_config)
    critical = [f for f in result.get('findings', []) if f.get('severity') == 'critical']
    assert len(critical) == 0, "Hardened config should have no critical findings"
    print("‚úÖ Test SSH config durcie: OK")

    # Test 9: Comparaison VPN
    result = compare_vpn_protocols(['IPsec', 'WireGuard', 'OpenVPN'])
    assert 'WireGuard' in result
    assert result['WireGuard']['code_lines'] < result['OpenVPN']['code_lines']
    print("‚úÖ Test comparaison VPN: OK")

    # Test 10: Handshake TLS 1.3
    handshake = simulate_tls_handshake('1.3', 'TLS_AES_256_GCM_SHA384')
    assert len(handshake.get('steps', [])) <= 4  # 1-RTT
    print("‚úÖ Test handshake TLS 1.3: OK")

    print("\n‚úÖ Tous les tests passent!")

if __name__ == "__main__":
    test_all()
```

### 4.3 Solution de r√©f√©rence

```python
import json
import re
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum

class SecurityRating(Enum):
    A_PLUS = "A+"
    A = "A"
    B = "B"
    C = "C"
    D = "D"
    F = "F"

# Base de donn√©es des cipher suites
CIPHER_SUITES_DB = {
    # TLS 1.3 (tous bons)
    'TLS_AES_256_GCM_SHA384': {
        'kex': 'ECDHE', 'auth': 'any', 'enc': 'AES-256-GCM', 'mac': 'AEAD',
        'pfs': True, 'aead': True, 'rating': 'A+'
    },
    'TLS_AES_128_GCM_SHA256': {
        'kex': 'ECDHE', 'auth': 'any', 'enc': 'AES-128-GCM', 'mac': 'AEAD',
        'pfs': True, 'aead': True, 'rating': 'A'
    },
    'TLS_CHACHA20_POLY1305_SHA256': {
        'kex': 'ECDHE', 'auth': 'any', 'enc': 'ChaCha20-Poly1305', 'mac': 'AEAD',
        'pfs': True, 'aead': True, 'rating': 'A+'
    },
    # TLS 1.2 bons
    'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384': {
        'kex': 'ECDHE', 'auth': 'RSA', 'enc': 'AES-256-GCM', 'mac': 'SHA384',
        'pfs': True, 'aead': True, 'rating': 'A'
    },
    'TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384': {
        'kex': 'ECDHE', 'auth': 'ECDSA', 'enc': 'AES-256-GCM', 'mac': 'SHA384',
        'pfs': True, 'aead': True, 'rating': 'A+'
    },
    # TLS 1.2 moyens
    'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256': {
        'kex': 'ECDHE', 'auth': 'RSA', 'enc': 'AES-128-CBC', 'mac': 'SHA256',
        'pfs': True, 'aead': False, 'rating': 'B'
    },
    # TLS 1.2 faibles
    'TLS_RSA_WITH_AES_256_CBC_SHA': {
        'kex': 'RSA', 'auth': 'RSA', 'enc': 'AES-256-CBC', 'mac': 'SHA1',
        'pfs': False, 'aead': False, 'rating': 'C'
    },
    'TLS_RSA_WITH_3DES_EDE_CBC_SHA': {
        'kex': 'RSA', 'auth': 'RSA', 'enc': '3DES', 'mac': 'SHA1',
        'pfs': False, 'aead': False, 'rating': 'D'
    },
    # Dangereux
    'TLS_RSA_WITH_RC4_128_SHA': {
        'kex': 'RSA', 'auth': 'RSA', 'enc': 'RC4', 'mac': 'SHA1',
        'pfs': False, 'aead': False, 'rating': 'F'
    },
    'TLS_RSA_WITH_RC4_128_MD5': {
        'kex': 'RSA', 'auth': 'RSA', 'enc': 'RC4', 'mac': 'MD5',
        'pfs': False, 'aead': False, 'rating': 'F'
    },
    'TLS_NULL_WITH_NULL_NULL': {
        'kex': 'NULL', 'auth': 'NULL', 'enc': 'NULL', 'mac': 'NULL',
        'pfs': False, 'aead': False, 'rating': 'F'
    },
    # Export (interdits)
    'TLS_RSA_EXPORT_WITH_RC4_40_MD5': {
        'kex': 'RSA', 'auth': 'RSA', 'enc': 'RC4-40', 'mac': 'MD5',
        'pfs': False, 'aead': False, 'rating': 'F'
    },
}

# Attaques connues
KNOWN_ATTACKS = {
    'BEAST': {
        'cve': 'CVE-2011-3389',
        'protocols': ['TLS 1.0', 'SSL 3.0'],
        'cipher_mode': 'CBC',
        'symptom': 'chosen_plaintext',
        'mitigation': 'Upgrade to TLS 1.1+ or use RC4 (deprecated)',
        'description': 'Browser Exploit Against SSL/TLS - exploits CBC IV predictability'
    },
    'POODLE': {
        'cve': 'CVE-2014-3566',
        'protocols': ['SSL 3.0', 'TLS 1.0'],
        'cipher_mode': 'CBC',
        'symptom': 'padding_oracle',
        'mitigation': 'Disable SSL 3.0, use TLS 1.2+',
        'description': 'Padding Oracle On Downgraded Legacy Encryption'
    },
    'Heartbleed': {
        'cve': 'CVE-2014-0160',
        'protocols': ['TLS 1.0', 'TLS 1.1', 'TLS 1.2'],
        'extension': 'heartbeat',
        'symptom': 'memory_disclosure',
        'mitigation': 'Update OpenSSL to 1.0.1g+',
        'description': 'Buffer over-read in OpenSSL heartbeat extension'
    },
    'CRIME': {
        'cve': 'CVE-2012-4929',
        'protocols': ['TLS 1.0', 'TLS 1.1', 'TLS 1.2'],
        'feature': 'compression',
        'symptom': 'compression_oracle',
        'mitigation': 'Disable TLS compression',
        'description': 'Compression Ratio Info-leak Made Easy'
    },
    'BREACH': {
        'cve': 'CVE-2013-3587',
        'protocols': ['HTTP'],
        'feature': 'http_compression',
        'symptom': 'compression_oracle',
        'mitigation': 'Disable HTTP compression for sensitive data',
        'description': 'Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext'
    },
    'DROWN': {
        'cve': 'CVE-2016-0800',
        'protocols': ['SSL 2.0'],
        'symptom': 'cross_protocol',
        'mitigation': 'Disable SSL 2.0 on all servers sharing keys',
        'description': 'Decrypting RSA with Obsolete and Weakened eNcryption'
    },
    'FREAK': {
        'cve': 'CVE-2015-0204',
        'protocols': ['TLS'],
        'cipher_type': 'export',
        'symptom': 'downgrade_export',
        'mitigation': 'Disable export cipher suites',
        'description': 'Factoring RSA Export Keys'
    },
    'Logjam': {
        'cve': 'CVE-2015-4000',
        'protocols': ['TLS'],
        'cipher_type': 'DHE_EXPORT',
        'symptom': 'downgrade_dh',
        'mitigation': 'Use 2048-bit DH parameters, disable export',
        'description': 'DH key exchange downgrade to 512-bit'
    },
    'ROBOT': {
        'cve': 'CVE-2017-13099',
        'protocols': ['TLS'],
        'key_exchange': 'RSA',
        'symptom': 'bleichenbacher',
        'mitigation': 'Disable RSA key exchange, use ECDHE',
        'description': 'Return Of Bleichenbacher Oracle Threat'
    }
}

# SSH settings dangereux
SSH_DANGEROUS = {
    'PermitRootLogin': {'dangerous': ['yes', 'without-password'], 'safe': 'no', 'severity': 'critical'},
    'PasswordAuthentication': {'dangerous': ['yes'], 'safe': 'no', 'severity': 'high'},
    'PermitEmptyPasswords': {'dangerous': ['yes'], 'safe': 'no', 'severity': 'critical'},
    'Protocol': {'dangerous': ['1', '1,2'], 'safe': '2', 'severity': 'critical'},
    'X11Forwarding': {'dangerous': ['yes'], 'safe': 'no', 'severity': 'medium'},
    'UsePAM': {'dangerous': ['no'], 'safe': 'yes', 'severity': 'low'},
    'MaxAuthTries': {'max_safe': 3, 'severity': 'medium'},
    'LoginGraceTime': {'max_safe': 60, 'severity': 'low'},
}

SSH_WEAK_CIPHERS = ['3des-cbc', 'aes128-cbc', 'aes192-cbc', 'aes256-cbc', 'blowfish-cbc', 'cast128-cbc']
SSH_WEAK_MACS = ['hmac-md5', 'hmac-sha1', 'umac-64@openssh.com']
SSH_WEAK_KEX = ['diffie-hellman-group1-sha1', 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1']


def audit_cipher_suite(suite: str) -> dict:
    """Analyse une cipher suite."""
    # Lookup direct
    if suite in CIPHER_SUITES_DB:
        info = CIPHER_SUITES_DB[suite]
        return {
            'cipher_suite': suite,
            'key_exchange': info['kex'],
            'authentication': info['auth'],
            'encryption': info['enc'],
            'mac': info['mac'],
            'forward_secrecy': info['pfs'],
            'aead': info['aead'],
            'security_rating': info['rating'],
            'warnings': _get_cipher_warnings(info),
            'recommendations': _get_cipher_recommendations(info)
        }

    # Parse dynamique
    return _parse_cipher_suite_dynamic(suite)


def _get_cipher_warnings(info: dict) -> list:
    """G√©n√®re les warnings pour une cipher suite."""
    warnings = []

    if info['enc'] == 'RC4':
        warnings.append('RC4 is broken - biased keystream allows plaintext recovery')
    if info['enc'] == '3DES':
        warnings.append('3DES has 64-bit block size - vulnerable to Sweet32 attack')
    if info['enc'] == 'NULL':
        warnings.append('NULL encryption provides no confidentiality')
    if 'CBC' in info['enc']:
        warnings.append('CBC mode vulnerable to padding oracle attacks (POODLE, Lucky13)')
    if info['mac'] == 'MD5':
        warnings.append('MD5 is cryptographically broken')
    if info['mac'] == 'SHA1':
        warnings.append('SHA1 is deprecated for cryptographic use')
    if not info['pfs']:
        warnings.append('No forward secrecy - compromised key decrypts past traffic')
    if info['kex'] == 'RSA':
        warnings.append('Static RSA key exchange - no forward secrecy')
    if 'EXPORT' in str(info.get('enc', '')):
        warnings.append('Export cipher - intentionally weakened (40-56 bit)')

    return warnings


def _get_cipher_recommendations(info: dict) -> list:
    """G√©n√®re des recommandations."""
    recs = []

    if not info['pfs']:
        recs.append('Use ECDHE or DHE for forward secrecy')
    if not info['aead']:
        recs.append('Use AEAD ciphers (GCM, ChaCha20-Poly1305) for authenticated encryption')
    if info['rating'] in ['D', 'F']:
        recs.append('Disable this cipher suite immediately')

    return recs


def _parse_cipher_suite_dynamic(suite: str) -> dict:
    """Parse dynamiquement une cipher suite inconnue."""
    result = {
        'cipher_suite': suite,
        'key_exchange': 'unknown',
        'authentication': 'unknown',
        'encryption': 'unknown',
        'mac': 'unknown',
        'forward_secrecy': False,
        'aead': False,
        'security_rating': 'C',
        'warnings': [],
        'recommendations': []
    }

    suite_upper = suite.upper()

    # Key exchange
    if 'ECDHE' in suite_upper:
        result['key_exchange'] = 'ECDHE'
        result['forward_secrecy'] = True
    elif 'DHE' in suite_upper:
        result['key_exchange'] = 'DHE'
        result['forward_secrecy'] = True
    elif 'RSA' in suite_upper:
        result['key_exchange'] = 'RSA'

    # Auth
    if 'ECDSA' in suite_upper:
        result['authentication'] = 'ECDSA'
    elif 'RSA' in suite_upper:
        result['authentication'] = 'RSA'

    # Encryption
    if 'CHACHA20' in suite_upper:
        result['encryption'] = 'ChaCha20-Poly1305'
        result['aead'] = True
    elif 'GCM' in suite_upper:
        result['aead'] = True
        if 'AES_256' in suite_upper or 'AES256' in suite_upper:
            result['encryption'] = 'AES-256-GCM'
        else:
            result['encryption'] = 'AES-128-GCM'
    elif 'CBC' in suite_upper:
        if 'AES_256' in suite_upper:
            result['encryption'] = 'AES-256-CBC'
        elif 'AES_128' in suite_upper:
            result['encryption'] = 'AES-128-CBC'
        elif '3DES' in suite_upper:
            result['encryption'] = '3DES-CBC'
    elif 'RC4' in suite_upper:
        result['encryption'] = 'RC4'
        result['security_rating'] = 'F'

    # MAC
    if 'SHA384' in suite_upper:
        result['mac'] = 'SHA384'
    elif 'SHA256' in suite_upper:
        result['mac'] = 'SHA256'
    elif 'SHA' in suite_upper:
        result['mac'] = 'SHA1'
    elif 'MD5' in suite_upper:
        result['mac'] = 'MD5'

    # Rating
    if result['aead'] and result['forward_secrecy']:
        result['security_rating'] = 'A'
    elif result['forward_secrecy']:
        result['security_rating'] = 'B'
    elif 'CBC' in result['encryption']:
        result['security_rating'] = 'C'

    return result


def identify_attack(symptoms: dict) -> dict:
    """Identifie une attaque √† partir de ses sympt√¥mes."""

    protocol = symptoms.get('protocol', '').upper()
    cipher_mode = symptoms.get('cipher_mode', '')
    symptom = symptoms.get('symptom', '')
    extension = symptoms.get('extension', '')
    feature = symptoms.get('feature', '')

    # BEAST
    if 'TLS 1.0' in protocol or 'SSL' in protocol:
        if cipher_mode == 'CBC' and symptom == 'chosen_plaintext':
            return {'name': 'BEAST', **KNOWN_ATTACKS['BEAST']}

    # POODLE
    if 'SSL 3.0' in protocol or 'TLS 1.0' in protocol:
        if cipher_mode == 'CBC' and symptom == 'padding_oracle':
            return {'name': 'POODLE', **KNOWN_ATTACKS['POODLE']}

    # Heartbleed
    if extension == 'heartbeat' or symptom == 'memory_disclosure':
        if symptoms.get('bytes_leaked', 0) > 0:
            return {'name': 'Heartbleed', **KNOWN_ATTACKS['Heartbleed']}

    # CRIME
    if feature == 'compression' or symptom == 'compression_oracle':
        if 'http' not in feature.lower():
            return {'name': 'CRIME', **KNOWN_ATTACKS['CRIME']}

    # BREACH
    if feature == 'http_compression':
        return {'name': 'BREACH', **KNOWN_ATTACKS['BREACH']}

    # DROWN
    if 'SSL 2.0' in protocol or symptom == 'cross_protocol':
        return {'name': 'DROWN', **KNOWN_ATTACKS['DROWN']}

    # FREAK
    if symptoms.get('cipher_type') == 'export' or symptom == 'downgrade_export':
        return {'name': 'FREAK', **KNOWN_ATTACKS['FREAK']}

    # Logjam
    if symptoms.get('cipher_type') == 'DHE_EXPORT' or symptom == 'downgrade_dh':
        return {'name': 'Logjam', **KNOWN_ATTACKS['Logjam']}

    # ROBOT
    if symptoms.get('key_exchange') == 'RSA' and symptom == 'bleichenbacher':
        return {'name': 'ROBOT', **KNOWN_ATTACKS['ROBOT']}

    return {'name': 'Unknown', 'description': 'Attack not recognized from symptoms'}


def explain_attack(attack_name: str) -> dict:
    """Explique une attaque en d√©tail."""
    if attack_name in KNOWN_ATTACKS:
        return {
            'name': attack_name,
            **KNOWN_ATTACKS[attack_name]
        }
    return {'name': attack_name, 'error': 'Attack not found in database'}


def compare_tls_versions(v1: str, v2: str) -> dict:
    """Compare deux versions TLS."""
    versions_info = {
        'SSL 2.0': {
            'year': 1995,
            'round_trips': 3,
            'deprecated': True,
            'pfs_support': False,
            'aead_support': False,
            'vulnerabilities': ['DROWN', 'many others'],
            'status': 'PROHIBITED'
        },
        'SSL 3.0': {
            'year': 1996,
            'round_trips': 2,
            'deprecated': True,
            'pfs_support': True,
            'aead_support': False,
            'vulnerabilities': ['POODLE'],
            'status': 'PROHIBITED'
        },
        'TLS 1.0': {
            'year': 1999,
            'round_trips': 2,
            'deprecated': True,
            'pfs_support': True,
            'aead_support': False,
            'vulnerabilities': ['BEAST', 'POODLE'],
            'status': 'DEPRECATED'
        },
        'TLS 1.1': {
            'year': 2006,
            'round_trips': 2,
            'deprecated': True,
            'pfs_support': True,
            'aead_support': False,
            'vulnerabilities': [],
            'status': 'DEPRECATED'
        },
        'TLS 1.2': {
            'year': 2008,
            'round_trips': 2,
            'deprecated': False,
            'pfs_support': True,
            'aead_support': True,
            'vulnerabilities': [],
            'cipher_suites_count': 319,
            'status': 'CURRENT'
        },
        'TLS 1.3': {
            'year': 2018,
            'round_trips': 1,
            'zero_rtt': True,
            'deprecated': False,
            'pfs_support': True,  # Mandatory
            'aead_support': True,  # Mandatory
            'vulnerabilities': [],
            'cipher_suites_count': 5,
            'status': 'RECOMMENDED'
        }
    }

    v1_norm = v1.upper().replace('TLSV', 'TLS ').replace('SSLV', 'SSL ')
    v2_norm = v2.upper().replace('TLSV', 'TLS ').replace('SSLV', 'SSL ')

    # Normalize version strings
    for key in versions_info:
        if v1_norm.replace(' ', '') == key.replace(' ', ''):
            v1_norm = key
        if v2_norm.replace(' ', '') == key.replace(' ', ''):
            v2_norm = key

    info1 = versions_info.get(v1_norm, {})
    info2 = versions_info.get(v2_norm, {})

    # Removed ciphers from TLS 1.2 to 1.3
    removed_ciphers = [
        'TLS_RSA_WITH_AES_256_CBC_SHA256',
        'TLS_RSA_WITH_AES_128_CBC_SHA256',
        'TLS_RSA_WITH_AES_256_CBC_SHA',
        'TLS_RSA_WITH_AES_128_CBC_SHA',
        'TLS_RSA_WITH_3DES_EDE_CBC_SHA',
        'TLS_DHE_RSA_WITH_AES_256_CBC_SHA256',
        'TLS_DHE_RSA_WITH_AES_128_CBC_SHA256',
        'TLS_DHE_RSA_WITH_AES_256_CBC_SHA',
        'TLS_DHE_RSA_WITH_AES_128_CBC_SHA',
        'TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA',
        'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384',
        'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256',
        'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA',
        'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA',
        'TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA',
        'TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384',
        'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256',
        'TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA',
        'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA',
        'TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA',
        'TLS_RSA_WITH_RC4_128_SHA',
        'TLS_RSA_WITH_RC4_128_MD5',
        'TLS_DHE_DSS_WITH_AES_256_CBC_SHA256',
        'TLS_DHE_DSS_WITH_AES_128_CBC_SHA256',
        'TLS_DHE_DSS_WITH_AES_256_CBC_SHA',
        'TLS_DHE_DSS_WITH_AES_128_CBC_SHA',
        'TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA',
        'TLS_RSA_WITH_CAMELLIA_256_CBC_SHA',
        'TLS_RSA_WITH_CAMELLIA_128_CBC_SHA',
        'TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA',
        'TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA',
        'TLS_DH_anon_WITH_AES_256_CBC_SHA256',
        'TLS_DH_anon_WITH_AES_128_CBC_SHA256',
        'TLS_DH_anon_WITH_AES_256_CBC_SHA',
        'TLS_DH_anon_WITH_AES_128_CBC_SHA',
        'TLS_DH_anon_WITH_3DES_EDE_CBC_SHA',
        'TLS_DH_anon_WITH_RC4_128_MD5',
        'TLS_RSA_WITH_NULL_SHA256',
    ]

    return {
        v1_norm.lower().replace(' ', '_'): info1,
        v2_norm.lower().replace(' ', '_'): info2,
        'removed_ciphers': removed_ciphers if 'TLS 1.2' in [v1_norm, v2_norm] and 'TLS 1.3' in [v1_norm, v2_norm] else [],
        'improvements': _get_tls_improvements(v1_norm, v2_norm)
    }


def _get_tls_improvements(v1: str, v2: str) -> list:
    """Liste les am√©liorations entre versions."""
    improvements = []

    if v1 == 'TLS 1.2' and v2 == 'TLS 1.3':
        improvements = [
            '1-RTT handshake (vs 2-RTT)',
            '0-RTT resumption available',
            'Forward secrecy mandatory (ECDHE only)',
            'AEAD mandatory (GCM, ChaCha20-Poly1305)',
            'CBC mode removed',
            'RSA key exchange removed',
            'Static DH removed',
            'Compression removed',
            'Renegotiation removed',
            'Simplified cipher suite naming',
            'Encrypted SNI (ESNI) support',
            'Only 5 cipher suites (vs 319)',
        ]

    return improvements


def simulate_tls_handshake(version: str, cipher: str) -> dict:
    """Simule un handshake TLS."""

    if '1.3' in version:
        steps = [
            {'step': 1, 'direction': 'C‚ÜíS', 'message': 'ClientHello',
             'content': ['supported_versions', 'key_share (ECDHE)', 'signature_algorithms']},
            {'step': 2, 'direction': 'S‚ÜíC', 'message': 'ServerHello + EncryptedExtensions + Certificate + CertificateVerify + Finished',
             'content': ['selected_version', 'key_share', 'certificate_chain', 'handshake_signature']},
            {'step': 3, 'direction': 'C‚ÜíS', 'message': 'Finished',
             'content': ['handshake_verify_data']},
        ]
        rtt = 1
    else:
        steps = [
            {'step': 1, 'direction': 'C‚ÜíS', 'message': 'ClientHello',
             'content': ['version', 'random', 'cipher_suites', 'extensions']},
            {'step': 2, 'direction': 'S‚ÜíC', 'message': 'ServerHello',
             'content': ['version', 'random', 'cipher_suite', 'extensions']},
            {'step': 3, 'direction': 'S‚ÜíC', 'message': 'Certificate',
             'content': ['certificate_chain']},
            {'step': 4, 'direction': 'S‚ÜíC', 'message': 'ServerKeyExchange',
             'content': ['ECDHE_params', 'signature']},
            {'step': 5, 'direction': 'S‚ÜíC', 'message': 'ServerHelloDone',
             'content': []},
            {'step': 6, 'direction': 'C‚ÜíS', 'message': 'ClientKeyExchange',
             'content': ['ECDHE_public_key']},
            {'step': 7, 'direction': 'C‚ÜíS', 'message': 'ChangeCipherSpec + Finished',
             'content': ['verify_data']},
            {'step': 8, 'direction': 'S‚ÜíC', 'message': 'ChangeCipherSpec + Finished',
             'content': ['verify_data']},
        ]
        rtt = 2

    return {
        'version': version,
        'cipher_suite': cipher,
        'round_trips': rtt,
        'steps': steps,
        'key_derivation': 'HKDF' if '1.3' in version else 'PRF',
        'forward_secrecy': True
    }


def parse_ssh_config(config: str) -> dict:
    """Parse un fichier sshd_config."""
    parsed = {}

    for line in config.strip().split('\n'):
        line = line.strip()
        if not line or line.startswith('#'):
            continue

        parts = line.split(None, 1)
        if len(parts) >= 2:
            key, value = parts[0], parts[1]
            parsed[key] = value
        elif len(parts) == 1:
            parsed[parts[0]] = ''

    return parsed


def audit_ssh_config(config: dict) -> dict:
    """Audite une configuration SSH."""
    findings = []

    for setting, rules in SSH_DANGEROUS.items():
        value = config.get(setting, '')

        if 'dangerous' in rules:
            if value.lower() in [v.lower() for v in rules['dangerous']]:
                findings.append({
                    'setting': setting,
                    'current_value': value,
                    'recommended': rules['safe'],
                    'severity': rules['severity'],
                    'reason': f"{setting}={value} is insecure"
                })

        if 'max_safe' in rules:
            try:
                if int(value) > rules['max_safe']:
                    findings.append({
                        'setting': setting,
                        'current_value': value,
                        'recommended': str(rules['max_safe']),
                        'severity': rules['severity'],
                        'reason': f"{setting} too high (max recommended: {rules['max_safe']})"
                    })
            except (ValueError, TypeError):
                pass

    # Check ciphers
    ciphers = config.get('Ciphers', '').split(',')
    weak_found = [c.strip() for c in ciphers if c.strip() in SSH_WEAK_CIPHERS]
    if weak_found:
        findings.append({
            'setting': 'Ciphers',
            'current_value': ','.join(weak_found),
            'recommended': 'chacha20-poly1305@openssh.com,aes256-gcm@openssh.com',
            'severity': 'high',
            'reason': 'Weak ciphers enabled (CBC mode vulnerable)'
        })

    # Check MACs
    macs = config.get('MACs', '').split(',')
    weak_macs = [m.strip() for m in macs if m.strip() in SSH_WEAK_MACS]
    if weak_macs:
        findings.append({
            'setting': 'MACs',
            'current_value': ','.join(weak_macs),
            'recommended': 'hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com',
            'severity': 'medium',
            'reason': 'Weak MACs enabled'
        })

    # Check KEX
    kex = config.get('KexAlgorithms', '').split(',')
    weak_kex = [k.strip() for k in kex if k.strip() in SSH_WEAK_KEX]
    if weak_kex:
        findings.append({
            'setting': 'KexAlgorithms',
            'current_value': ','.join(weak_kex),
            'recommended': 'curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256',
            'severity': 'high',
            'reason': 'Weak key exchange algorithms'
        })

    return {
        'findings': findings,
        'critical_count': len([f for f in findings if f['severity'] == 'critical']),
        'high_count': len([f for f in findings if f['severity'] == 'high']),
        'overall_rating': _calculate_ssh_rating(findings)
    }


def _calculate_ssh_rating(findings: list) -> str:
    """Calcule un rating global pour SSH."""
    critical = len([f for f in findings if f['severity'] == 'critical'])
    high = len([f for f in findings if f['severity'] == 'high'])

    if critical > 0:
        return 'F'
    if high > 2:
        return 'D'
    if high > 0:
        return 'C'
    if len(findings) > 2:
        return 'B'
    if len(findings) > 0:
        return 'A'
    return 'A+'


def recommend_ssh_hardening(current_config: dict) -> list:
    """Recommande des am√©liorations SSH."""
    recommendations = []

    if current_config.get('PermitRootLogin', 'yes').lower() != 'no':
        recommendations.append({
            'priority': 1,
            'setting': 'PermitRootLogin no',
            'reason': 'Prevent direct root access'
        })

    if current_config.get('PasswordAuthentication', 'yes').lower() != 'no':
        recommendations.append({
            'priority': 1,
            'setting': 'PasswordAuthentication no',
            'reason': 'Force key-based authentication'
        })

    if current_config.get('PubkeyAuthentication', 'yes').lower() != 'yes':
        recommendations.append({
            'priority': 1,
            'setting': 'PubkeyAuthentication yes',
            'reason': 'Enable key-based authentication'
        })

    if 'Ciphers' not in current_config:
        recommendations.append({
            'priority': 2,
            'setting': 'Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com',
            'reason': 'Restrict to modern ciphers only'
        })

    if 'KexAlgorithms' not in current_config:
        recommendations.append({
            'priority': 2,
            'setting': 'KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256',
            'reason': 'Use secure key exchange only'
        })

    if 'MACs' not in current_config:
        recommendations.append({
            'priority': 2,
            'setting': 'MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com',
            'reason': 'Use Encrypt-then-MAC'
        })

    recommendations.append({
        'priority': 3,
        'setting': 'AllowUsers <specific_users>',
        'reason': 'Whitelist allowed users'
    })

    recommendations.append({
        'priority': 3,
        'setting': 'Port <non-standard>',
        'reason': 'Reduce automated scanning (security through obscurity, low value)'
    })

    return sorted(recommendations, key=lambda x: x['priority'])


def compare_vpn_protocols(protocols: list) -> dict:
    """Compare des protocoles VPN."""
    vpn_info = {
        'IPsec': {
            'code_lines': 400000,
            'year': 1995,
            'encryption': ['AES-GCM', 'ChaCha20'],
            'key_exchange': ['IKEv2'],
            'authentication': ['RSA', 'ECDSA', 'PSK'],
            'latency': 'medium',
            'complexity': 'very high',
            'audit_difficulty': 'very hard',
            'mobile_support': 'native (IKEv2)',
            'nat_traversal': 'NAT-T extension required',
            'ports': ['UDP 500', 'UDP 4500'],
            'pros': ['Industry standard', 'Hardware acceleration', 'Mature'],
            'cons': ['Complex configuration', 'Large attack surface', 'Hard to audit']
        },
        'WireGuard': {
            'code_lines': 4000,
            'year': 2016,
            'encryption': ['ChaCha20-Poly1305'],
            'key_exchange': ['Curve25519'],
            'authentication': ['Ed25519'],
            'latency': 'low',
            'complexity': 'low',
            'audit_difficulty': 'easy',
            'mobile_support': 'excellent',
            'nat_traversal': 'built-in',
            'ports': ['UDP 51820 (configurable)'],
            'pros': ['Simple', 'Fast', 'Modern crypto', 'Easy to audit'],
            'cons': ['No TCP fallback', 'Fixed crypto (no agility)', 'Newer']
        },
        'OpenVPN': {
            'code_lines': 100000,
            'year': 2001,
            'encryption': ['AES-GCM', 'ChaCha20'],
            'key_exchange': ['TLS'],
            'authentication': ['RSA', 'ECDSA', 'Certificates'],
            'latency': 'medium',
            'complexity': 'medium',
            'audit_difficulty': 'hard',
            'mobile_support': 'good (third-party apps)',
            'nat_traversal': 'TCP fallback',
            'ports': ['UDP 1194', 'TCP 443'],
            'pros': ['Flexible', 'TCP fallback', 'Wide support'],
            'cons': ['User-space (slower)', 'Complex configuration', 'Large codebase']
        }
    }

    result = {}
    for protocol in protocols:
        if protocol in vpn_info:
            result[protocol] = vpn_info[protocol]

    return result


def analyze_wireguard_config(config: str) -> dict:
    """Analyse une configuration WireGuard."""
    result = {
        'interface': {},
        'peers': [],
        'issues': [],
        'recommendations': []
    }

    current_section = None
    current_peer = {}

    for line in config.strip().split('\n'):
        line = line.strip()
        if not line or line.startswith('#'):
            continue

        if line == '[Interface]':
            current_section = 'interface'
            continue
        elif line == '[Peer]':
            if current_peer:
                result['peers'].append(current_peer)
            current_peer = {}
            current_section = 'peer'
            continue

        if '=' in line:
            key, value = line.split('=', 1)
            key = key.strip()
            value = value.strip()

            if current_section == 'interface':
                result['interface'][key] = value
            elif current_section == 'peer':
                current_peer[key] = value

    if current_peer:
        result['peers'].append(current_peer)

    # Validate
    if 'PrivateKey' not in result['interface']:
        result['issues'].append('Missing PrivateKey in [Interface]')

    if 'Address' not in result['interface']:
        result['issues'].append('Missing Address in [Interface]')

    for i, peer in enumerate(result['peers']):
        if 'PublicKey' not in peer:
            result['issues'].append(f'Peer {i+1}: Missing PublicKey')
        if 'AllowedIPs' not in peer:
            result['issues'].append(f'Peer {i+1}: Missing AllowedIPs')
        if peer.get('AllowedIPs') == '0.0.0.0/0':
            result['recommendations'].append(f'Peer {i+1}: AllowedIPs=0.0.0.0/0 routes all traffic (full tunnel)')

    return result


def detect_tls_vulnerabilities(config: dict) -> list:
    """D√©tecte les vuln√©rabilit√©s dans une config TLS."""
    vulns = []

    protocols = config.get('protocols', [])
    ciphers = config.get('cipher_suites', [])

    # Protocol issues
    if 'SSL 2.0' in protocols:
        vulns.append({'name': 'DROWN', 'severity': 'critical', 'fix': 'Disable SSL 2.0'})
    if 'SSL 3.0' in protocols:
        vulns.append({'name': 'POODLE', 'severity': 'critical', 'fix': 'Disable SSL 3.0'})
    if 'TLS 1.0' in protocols:
        vulns.append({'name': 'BEAST/POODLE', 'severity': 'high', 'fix': 'Disable TLS 1.0'})
    if 'TLS 1.1' in protocols:
        vulns.append({'name': 'Deprecated', 'severity': 'medium', 'fix': 'Disable TLS 1.1'})

    # Cipher issues
    for cipher in ciphers:
        if 'RC4' in cipher:
            vulns.append({'name': 'RC4 bias', 'severity': 'critical', 'cipher': cipher})
        if 'EXPORT' in cipher:
            vulns.append({'name': 'FREAK/Logjam', 'severity': 'critical', 'cipher': cipher})
        if 'NULL' in cipher:
            vulns.append({'name': 'No encryption', 'severity': 'critical', 'cipher': cipher})
        if '3DES' in cipher:
            vulns.append({'name': 'Sweet32', 'severity': 'high', 'cipher': cipher})
        if 'CBC' in cipher and 'TLS 1.0' in protocols:
            vulns.append({'name': 'Lucky13', 'severity': 'medium', 'cipher': cipher})

    # Feature issues
    if config.get('compression', False):
        vulns.append({'name': 'CRIME', 'severity': 'high', 'fix': 'Disable TLS compression'})

    if not config.get('ocsp_stapling', False):
        vulns.append({'name': 'No OCSP stapling', 'severity': 'low', 'fix': 'Enable OCSP stapling'})

    return vulns


def protocoles_blindes(input_json: str) -> str:
    """Point d'entr√©e principal."""
    data = json.loads(input_json)
    results = {}

    # Audit cipher suites
    if 'audit_ciphers' in data:
        results['cipher_audits'] = []
        for suite in data['audit_ciphers']:
            results['cipher_audits'].append(audit_cipher_suite(suite))

    # Identify attacks
    if 'identify_attack' in data:
        results['attack'] = identify_attack(data['identify_attack'])

    # Explain attack
    if 'explain_attack' in data:
        results['explanation'] = explain_attack(data['explain_attack'])

    # Compare TLS versions
    if 'compare_tls' in data:
        v1, v2 = data['compare_tls']
        results['tls_comparison'] = compare_tls_versions(v1, v2)

    # Simulate handshake
    if 'handshake' in data:
        hs = data['handshake']
        results['handshake'] = simulate_tls_handshake(hs['version'], hs['cipher'])

    # Audit SSH
    if 'ssh_config' in data:
        if isinstance(data['ssh_config'], str):
            config = parse_ssh_config(data['ssh_config'])
        else:
            config = data['ssh_config']
        results['ssh_audit'] = audit_ssh_config(config)
        results['ssh_recommendations'] = recommend_ssh_hardening(config)

    # Compare VPN
    if 'compare_vpn' in data:
        results['vpn_comparison'] = compare_vpn_protocols(data['compare_vpn'])

    # Analyze WireGuard
    if 'wireguard_config' in data:
        results['wireguard'] = analyze_wireguard_config(data['wireguard_config'])

    # Detect TLS vulnerabilities
    if 'tls_config' in data:
        results['vulnerabilities'] = detect_tls_vulnerabilities(data['tls_config'])

    return json.dumps(results, indent=2)
```

### 4.10 Solutions Mutantes

```python
# Mutant A (Boundary) : Ne d√©tecte pas SSL 3.0 comme vuln√©rable √† POODLE
def identify_attack_mutant_a(symptoms: dict) -> dict:
    protocol = symptoms.get('protocol', '').upper()
    if 'TLS 1.0' in protocol:  # Oublie SSL 3.0 !
        if symptoms.get('cipher_mode') == 'CBC' and symptoms.get('symptom') == 'padding_oracle':
            return {'name': 'POODLE', 'cve': 'CVE-2014-3566'}
    return {'name': 'Unknown'}
# Pourquoi c'est faux : POODLE affecte AUSSI SSL 3.0 (c'est m√™me le protocole principal)

# Mutant B (Safety) : Rating trop permissif pour CBC
def audit_cipher_suite_mutant_b(suite: str) -> dict:
    result = _parse_cipher_suite_dynamic(suite)
    if result['forward_secrecy']:
        result['security_rating'] = 'A'  # CBC + PFS = A ? Non !
    return result
# Pourquoi c'est faux : CBC mode reste vuln√©rable m√™me avec PFS (Lucky13)

# Mutant C (Logic) : Inverse PFS dans comparaison TLS
def compare_tls_versions_mutant_c(v1: str, v2: str) -> dict:
    info = {
        'TLS 1.2': {'pfs_support': False},  # Faux !
        'TLS 1.3': {'pfs_support': True}
    }
    return {v1: info.get(v1, {}), v2: info.get(v2, {})}
# Pourquoi c'est faux : TLS 1.2 supporte PFS (optionnel), c'est TLS 1.3 qui le rend obligatoire

# Mutant D (Resource) : N'inclut pas les weak ciphers dans l'audit SSH
def audit_ssh_config_mutant_d(config: dict) -> dict:
    findings = []
    for setting, rules in SSH_DANGEROUS.items():
        value = config.get(setting, '')
        if value in rules.get('dangerous', []):
            findings.append({'setting': setting, 'severity': rules['severity']})
    # Oublie de v√©rifier Ciphers, MACs, KexAlgorithms !
    return {'findings': findings}
# Pourquoi c'est faux : Les algorithmes crypto faibles sont aussi critiques

# Mutant E (Return) : Retourne toujours rating 'A' pour SSH
def _calculate_ssh_rating_mutant_e(findings: list) -> str:
    return 'A'  # Ignore les findings !
# Pourquoi c'est faux : Un rating doit refl√©ter les vuln√©rabilit√©s trouv√©es
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Architecture des protocoles s√©curis√©s** : Comprendre le handshake TLS, les couches de s√©curit√©
2. **√âvolution de la s√©curit√©** : Pourquoi TLS 1.3 est meilleur que 1.2
3. **Vuln√©rabilit√©s historiques** : Apprendre des erreurs du pass√© (Heartbleed, POODLE, BEAST)
4. **Audit de configuration** : √âvaluer la s√©curit√© d'un serveur
5. **Hardening** : Appliquer les bonnes pratiques de durcissement
6. **Choix technologiques** : Comparer VPN pour diff√©rents contextes

### 5.2 LDA ‚Äî Traduction Litt√©rale

```
FONCTION audit_cipher_suite QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAM√àTRE suite QUI EST UNE CHA√éNE
D√âBUT FONCTION
    SI suite EST DANS LA BASE DE DONN√âES DES CIPHER SUITES ALORS
        AFFECTER LES INFORMATIONS DE LA BASE √Ä info
        CONSTRUIRE ET RETOURNER UN DICTIONNAIRE AVEC :
            - cl√©_√©change √âGAL √Ä info.kex
            - authentification √âGAL √Ä info.auth
            - chiffrement √âGAL √Ä info.enc
            - forward_secrecy √âGAL √Ä info.pfs
            - rating √âGAL √Ä info.rating
            - warnings √âGAL √Ä APPELER _get_cipher_warnings AVEC info
    SINON
        RETOURNER APPELER _parse_cipher_suite_dynamic AVEC suite
    FIN SI
FIN FONCTION
```

### 5.2.2.1 Logic Flow

```
ALGORITHME : Audit Configuration TLS
---
1. POUR CHAQUE cipher_suite dans la configuration :
   a. RECHERCHER la suite dans la base de donn√©es
   b. SI trouv√©e :
      - EXTRAIRE les propri√©t√©s (kex, auth, enc, mac)
      - √âVALUER le rating bas√© sur les crit√®res
      - G√âN√âRER les warnings appropri√©s
   c. SINON :
      - PARSER dynamiquement le nom de la suite
      - D√âDUIRE les propri√©t√©s du parsing

2. POUR CHAQUE protocole activ√© :
   a. V√âRIFIER s'il est dans la liste des protocoles vuln√©rables
   b. SI vuln√©rable :
      - AJOUTER l'alerte correspondante (DROWN, POODLE, etc.)

3. AGR√âGER les r√©sultats et RETOURNER le rapport d'audit
```

### 5.3 Visualisation ASCII

```
TLS 1.2 HANDSHAKE (2-RTT)
=========================

Client                                              Server
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ClientHello (ciphers, random) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ServerHello (cipher, random) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Certificate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ServerKeyExchange (ECDHE params) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ServerHelloDone ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ClientKeyExchange ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ChangeCipherSpec ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Finished (encrypted) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ChangeCipherSpec ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Finished (encrypted) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îú‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê APPLICATION DATA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚î§


TLS 1.3 HANDSHAKE (1-RTT)
=========================

Client                                              Server
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚îÄ‚îÄ ClientHello + key_share ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ<‚îÄ‚îÄ ServerHello + key_share ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ {EncryptedExtensions} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ {Certificate} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ {CertificateVerify} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ<‚îÄ‚îÄ {Finished} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚îÄ‚îÄ {Finished} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îú‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê APPLICATION DATA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚î§
       {} = encrypted with handshake keys


ATTAQUES TLS HISTORIQUES
========================

HEARTBLEED (CVE-2014-0160)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Client Request:                                     ‚îÇ
‚îÇ "Echo back 'hello' (payload_length: 65535)"         ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ Server Response:                                    ‚îÇ
‚îÇ "hello" + 65530 bytes of memory (keys, passwords)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

POODLE (CVE-2014-3566)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SSL 3.0 CBC Padding:                                ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ D   ‚îÇ A   ‚îÇ T   ‚îÇ A   ‚îÇ PAD ‚îÇ PAD ‚îÇ PAD ‚îÇ 0x03‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                        ‚Üë            ‚îÇ
‚îÇ Attacker manipulates to learn plaintext byte-by-byte‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


CIPHER SUITE ANATOMY
====================

TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
  ‚îÇ    ‚îÇ    ‚îÇ         ‚îÇ    ‚îÇ     ‚îÇ
  ‚îÇ    ‚îÇ    ‚îÇ         ‚îÇ    ‚îÇ     ‚îî‚îÄ‚îÄ PRF hash (TLS 1.2)
  ‚îÇ    ‚îÇ    ‚îÇ         ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Mode (AEAD = authenticated)
  ‚îÇ    ‚îÇ    ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Cipher & key size
  ‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Authentication
  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Key Exchange
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Protocol


VPN PROTOCOLS COMPARISON
========================

                IPsec          OpenVPN        WireGuard
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Lines of Code ‚îÇ 400,000 ‚îÇ    ‚îÇ 100,000 ‚îÇ    ‚îÇ  4,000  ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ              ‚îÇ              ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Audit         ‚îÇ  HARD   ‚îÇ    ‚îÇ MEDIUM  ‚îÇ    ‚îÇ  EASY   ‚îÇ
Difficulty    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Latency       ‚îÇ MEDIUM  ‚îÇ    ‚îÇ MEDIUM  ‚îÇ    ‚îÇ   LOW   ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Crypto        ‚îÇFlexible ‚îÇ    ‚îÇFlexible ‚îÇ    ‚îÇ  Fixed  ‚îÇ
Agility       ‚îÇ(good/bad)‚îÇ    ‚îÇ(good/bad)‚îÇ    ‚îÇ(good!)  ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.4 Les pi√®ges en d√©tail

| Pi√®ge | Description | Cons√©quence |
|-------|-------------|-------------|
| SSL 3.0 encore actif | "On le garde pour la compatibilit√©" | POODLE exploit |
| TLS 1.0 avec CBC | "C'est encore support√©" | BEAST, Lucky13 |
| RC4 "pour √©viter CBC" | Rem√®de pire que le mal | Bias attacks |
| RSA key exchange | Pas de forward secrecy | Decrypt pass√© |
| Compression TLS | Performance over security | CRIME attack |
| SSH root login | "C'est plus pratique" | Compromission totale |
| Passwords SSH | "Les cl√©s c'est compliqu√©" | Brute force |

### 5.5 Cours Complet

#### 5.5.1 TLS : Transport Layer Security

**Objectif :** Confidentialit√©, int√©grit√© et authentification au niveau transport.

**Handshake TLS 1.2 :**
1. ClientHello : Propose versions et cipher suites
2. ServerHello : Choisit version et cipher
3. Certificate : Serveur prouve son identit√©
4. ServerKeyExchange : Param√®tres ECDHE (si PFS)
5. ClientKeyExchange : Cl√© publique client
6. ChangeCipherSpec : Bascule vers chiffrement
7. Finished : V√©rifie l'int√©grit√© du handshake

**Am√©liorations TLS 1.3 :**
- 1-RTT au lieu de 2-RTT
- Forward secrecy obligatoire
- AEAD obligatoire (plus de CBC)
- Handshake chiffr√© apr√®s ServerHello
- 0-RTT pour reconnexion rapide

#### 5.5.2 SSH : Secure Shell

**Objectif :** Terminal distant s√©curis√©, tunneling, transfert de fichiers.

**Hardening essentiel :**
```
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com
KexAlgorithms curve25519-sha256@libssh.org
MACs hmac-sha2-512-etm@openssh.com
```

#### 5.5.3 VPN : Virtual Private Networks

**IPsec :** Standard industriel, complexe, bien support√©.
**OpenVPN :** Flexible, user-space, TCP fallback.
**WireGuard :** Moderne, simple, performant, kernel-space.

### 5.6 Normes avec explications p√©dagogiques

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME                                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ssl_protocols TLSv1.2 TLSv1.3;                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ SSLv3 : POODLE attack, pas de rem√©diation possible           ‚îÇ
‚îÇ ‚Ä¢ TLSv1.0 : BEAST attack, deprecated depuis 2020               ‚îÇ
‚îÇ ‚Ä¢ TLSv1.1 : Pas de vuln√©rabilit√© connue mais deprecated        ‚îÇ
‚îÇ ‚Ä¢ Seuls TLSv1.2 et 1.3 sont consid√©r√©s s√ªrs                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'ex√©cution

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape ‚îÇ Action                                    ‚îÇ R√©sultat                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ audit_cipher_suite("TLS_RSA_WITH_RC4...") ‚îÇ Lookup dans DB               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2   ‚îÇ Extraction info: kex=RSA, enc=RC4        ‚îÇ PFS=False, AEAD=False        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3   ‚îÇ _get_cipher_warnings()                    ‚îÇ ["RC4 broken", "No PFS"]     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ Calcul rating                             ‚îÇ rating = "F"                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ Retour dict complet                       ‚îÇ {rating: F, warnings: [...]} ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üé¨ MEME : "Person of Interest" ‚Äî La Machine vs Samaritan

Harold Finch a cr√©√© La Machine pour prot√©ger. Samaritan a √©t√© cr√©√© pour contr√¥ler.

TLS 1.3 c'est La Machine : minimaliste, efficace, fait ce qu'il faut.
TLS 1.0 c'est Samaritan : beaucoup de fonctionnalit√©s, mais trop de surface d'attaque.

```python
# La Machine (TLS 1.3) : Simple et s√ªr
cipher_suites = [
    "TLS_AES_256_GCM_SHA384",
    "TLS_CHACHA20_POLY1305_SHA256"
]

# Samaritan (TLS 1.0) : Compliqu√© et vuln√©rable
cipher_suites = [
    "TLS_RSA_WITH_RC4_128_SHA",  # Broken
    "TLS_RSA_WITH_3DES_EDE_CBC_SHA",  # Sweet32
    # ... 300+ autres suites probl√©matiques
]
```

#### üíÄ MEME : "Heartbleed" ‚Äî Le bug qui a bris√© Internet

```
Client: "Hello, I have a secret of length 65535"
Server: "Here's your secret: hello‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        [64KB of private keys, passwords, secrets]"
```

Comme un barman qui remplit ton verre jusqu'√† ce qu'il d√©borde... sur tes papiers d'identit√©.

### 5.9 Applications pratiques

1. **Configurer nginx/Apache** avec TLS 1.3 only
2. **Auditer la configuration SSH** d'un serveur de production
3. **Choisir un VPN** pour un environnement corporate vs personnel
4. **D√©tecter des attaques** via analyse de logs TLS

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | Comment l'√©viter |
|---|-------|------------------|
| 1 | SSL 2.0/3.0 encore actif | D√©sactiver imp√©rativement |
| 2 | TLS 1.0 avec CBC | Migrer vers TLS 1.2+ |
| 3 | RC4 "car CBC est vuln√©rable" | Utiliser AEAD (GCM, ChaCha20) |
| 4 | RSA key exchange | Utiliser ECDHE |
| 5 | Compression TLS | D√©sactiver |
| 6 | SSH PasswordAuthentication | Key-based only |
| 7 | SSH PermitRootLogin yes | Jamais de root direct |
| 8 | VPN "c'est compliqu√©" | WireGuard simplifie tout |

---

## üìù SECTION 7 : QCM

**Q1:** Quelle attaque exploite le CBC padding dans SSL 3.0?
A) BEAST  B) Heartbleed  C) POODLE ‚úì  D) CRIME

**Q2:** TLS 1.3 r√©duit le handshake √† combien de round-trips?
A) 0  B) 1 ‚úì  C) 2  D) 3

**Q3:** Quel param√®tre SSH est critique pour la s√©curit√©?
A) Port  B) Banner  C) PermitRootLogin ‚úì  D) ClientAliveInterval

**Q4:** WireGuard utilise quel algorithme pour le key exchange?
A) RSA  B) DH  C) ECDH  D) Curve25519 ‚úì

**Q5:** Pourquoi RC4 est-il interdit?
A) Lent  B) Biais dans le keystream ‚úì  C) Cl√© trop courte  D) Pas de MAC

**Q6:** Qu'est-ce que le "forward secrecy"?
A) Chiffrement plus rapide  B) Cl√©s pass√©es prot√©g√©es m√™me si cl√© serveur compromise ‚úì  C) V√©rification du futur  D) Backup des cl√©s

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.7-a : protocoles_blindes |
| Concepts | TLS, SSH, VPN, attaques historiques, hardening |
| Difficult√© | 8/10 |
| XP | 250 |
| Bonus | üî• Avanc√© (√ó3) |

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
