# Exercice 3.1.5-a : empreinte_numerique

**Module :** 3.1.5 ‚Äî Fonctions de Hachage

**Concept :** a ‚Äî Propri√©t√©s et constructions des fonctions de hachage

**Difficult√© :** ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :** complet

**Tiers :** 1 ‚Äî Concept isol√©

**Langage :** Python 3.14

**Pr√©requis :** 3.1.1-a (concepts de s√©curit√© de base)

**Domaines :** Crypto, Encodage

**Dur√©e estim√©e :** 90 min

**XP Base :** 225

**Complexit√© :** T2 O(n) √ó S1 O(1)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `empreinte_numerique.py`
**Autoris√© :** hashlib, struct
**Interdit :** Biblioth√®ques crypto tierces (cryptography, pycryptodome)

### 1.2 Consigne

**üéÆ "Death Note" ‚Äî Le Registre de la Mort Num√©rique**

*"Le nom √©crit dans ce cahier mourra... mais peut-on prouver que c'√©tait bien le nom original?"* ‚Äî Ryuk

Tu es **L Lawliet**, et tu enqu√™tes sur **Kira**. Pour prouver l'int√©grit√© des preuves num√©riques, tu dois comprendre les **empreintes digitales** ‚Äî les fonctions de hachage.

*"Un hash est comme une empreinte parfaite. M√™me modification infime dans le fichier, et l'empreinte change compl√®tement. C'est l'effet avalanche."*

Mais Light Yagami conna√Æt les failles : **collisions MD5**, **length extension**, **SHAttered**. Ta mission est d'analyser chaque algorithme et de recommander le plus s√ªr.

**Ta mission :**

1. **Impl√©menter et comparer** MD5, SHA-1, SHA-256, SHA-3, BLAKE3
2. **D√©montrer l'effet avalanche** (un bit change ‚Üí 50% des bits du hash changent)
3. **Exploiter la length extension** sur Merkle-Damg√•rd
4. **Analyser les collisions** MD5/SHA-1
5. **Recommander** l'algorithme appropri√© selon le contexte

### 1.3 Prototype

```python
def empreinte_numerique(input_json: str) -> str:
    """Point d'entr√©e principal"""
    pass

def hash_with_algorithm(data: bytes, algorithm: str) -> str:
    """Hash data avec l'algorithme sp√©cifi√©"""
    pass

def avalanche_test(data1: bytes, data2: bytes, algorithm: str) -> dict:
    """Teste l'effet avalanche entre deux inputs"""
    pass

def length_extension_attack(known_hash: str, known_length: int,
                           append_data: bytes, algorithm: str) -> dict:
    """D√©montre l'attaque length extension"""
    pass

def compare_algorithms(data: bytes) -> dict:
    """Compare tous les algorithmes de hachage"""
    pass

def collision_analysis(algorithm: str) -> dict:
    """Analyse les vuln√©rabilit√©s de collision"""
    pass

def recommend_algorithm(use_case: str, performance: str) -> dict:
    """Recommande un algorithme selon le contexte"""
    pass
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### SHAttered Attack (2017)

Google et CWI Amsterdam ont produit les deux premiers PDF diff√©rents avec le m√™me hash SHA-1. Co√ªt : ~110,000 GPU-ann√©es de calcul, environ $110,000 en cloud computing. GitHub a d√ª migrer vers SHA-256.

### Length Extension ‚Äî La Faille Oubli√©e

En 2009, Flickr a √©t√© compromis par une length extension attack. Leur API signait les requ√™tes avec MD5(secret || data). Un attaquant pouvait √©tendre data sans conna√Ætre le secret.

### MD5 Collisions en Temps R√©el

Depuis 2012, on peut g√©n√©rer des collisions MD5 en moins d'une seconde sur un laptop. Des certificats SSL frauduleux ont √©t√© cr√©√©s avec cette technique.

### 2.5 DANS LA VRAIE VIE

- **Security Auditor** : V√©rifier que les syst√®mes n'utilisent pas MD5/SHA-1
- **DevOps** : Configurer l'int√©grit√© des artefacts (BLAKE3 pour la vitesse)
- **Forensics** : Prouver l'int√©grit√© des preuves num√©riques

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

```bash
$ python empreinte_numerique.py
MD5 hash: d41d8cd98f00b204e9800998ecf8427e
SHA-256 hash: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
Avalanche test (1 bit flip): 127/256 bits changed (49.6%) ‚úì
Length extension on SHA-256: vulnerable ‚úì
Length extension on SHA-3: not vulnerable ‚úì
Algorithm recommendation for integrity: BLAKE3 ‚úì
Tous les tests passent!
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.3 Solution de r√©f√©rence

```python
import hashlib
import struct
import json
from typing import Optional

def hash_with_algorithm(data: bytes, algorithm: str) -> str:
    """Hash data avec l'algorithme sp√©cifi√©."""
    algo_map = {
        'md5': hashlib.md5,
        'sha1': hashlib.sha1,
        'sha256': hashlib.sha256,
        'sha384': hashlib.sha384,
        'sha512': hashlib.sha512,
        'sha3_256': hashlib.sha3_256,
        'sha3_512': hashlib.sha3_512,
        'blake2b': hashlib.blake2b,
        'blake2s': hashlib.blake2s,
    }

    if algorithm not in algo_map:
        raise ValueError(f"Algorithme inconnu: {algorithm}")

    return algo_map[algorithm](data).hexdigest()


def bytes_to_bits(data: bytes) -> list:
    """Convertit bytes en liste de bits."""
    bits = []
    for byte in data:
        for i in range(7, -1, -1):
            bits.append((byte >> i) & 1)
    return bits


def hamming_distance(hash1: str, hash2: str) -> int:
    """Calcule la distance de Hamming entre deux hash hex."""
    b1 = bytes.fromhex(hash1)
    b2 = bytes.fromhex(hash2)
    bits1 = bytes_to_bits(b1)
    bits2 = bytes_to_bits(b2)

    return sum(a != b for a, b in zip(bits1, bits2))


def avalanche_test(data1: bytes, data2: bytes, algorithm: str) -> dict:
    """
    Teste l'effet avalanche entre deux inputs.

    Un bon hash doit avoir ~50% des bits qui changent
    quand un seul bit de l'input change.
    """
    hash1 = hash_with_algorithm(data1, algorithm)
    hash2 = hash_with_algorithm(data2, algorithm)

    total_bits = len(hash1) * 4  # 4 bits par caract√®re hex
    distance = hamming_distance(hash1, hash2)
    percentage = (distance / total_bits) * 100

    # Un bon hash a ~50% de bits qui changent
    satisfies_avalanche = 45 <= percentage <= 55

    return {
        'hash1': hash1,
        'hash2': hash2,
        'hamming_distance': distance,
        'total_bits': total_bits,
        'percentage_changed': round(percentage, 2),
        'satisfies_avalanche': satisfies_avalanche
    }


def length_extension_demo(algorithm: str) -> dict:
    """
    D√©montre la vuln√©rabilit√© length extension.

    Merkle-Damg√•rd (MD5, SHA-1, SHA-256) est vuln√©rable car:
    - L'√©tat interne final = le hash
    - On peut "continuer" le hash sans conna√Ætre le message original
    """
    vulnerable_algorithms = ['md5', 'sha1', 'sha256', 'sha384', 'sha512']
    safe_algorithms = ['sha3_256', 'sha3_512', 'blake2b', 'blake2s']

    if algorithm in vulnerable_algorithms:
        return {
            'algorithm': algorithm,
            'construction': 'Merkle-Damg√•rd',
            'vulnerable': True,
            'explanation': (
                "L'√©tat interne apr√®s le hash = le hash lui-m√™me. "
                "Un attaquant connaissant H(secret||msg) et len(secret||msg) "
                "peut calculer H(secret||msg||padding||extension) sans conna√Ætre secret."
            ),
            'mitigation': "Utiliser HMAC ou passer √† SHA-3/BLAKE"
        }
    elif algorithm in safe_algorithms:
        return {
            'algorithm': algorithm,
            'construction': 'Sponge' if 'sha3' in algorithm else 'HAIFA/Davies-Meyer',
            'vulnerable': False,
            'explanation': (
                "SHA-3 utilise une construction sponge qui ne r√©v√®le pas "
                "l'√©tat interne complet. BLAKE2 utilise HAIFA qui inclut "
                "la longueur dans chaque bloc."
            )
        }
    else:
        return {'error': f"Algorithme inconnu: {algorithm}"}


def collision_analysis(algorithm: str) -> dict:
    """Analyse les vuln√©rabilit√©s de collision connues."""
    analyses = {
        'md5': {
            'status': 'BROKEN',
            'year_broken': 2004,
            'collision_time': '< 1 second on modern CPU',
            'chosen_prefix_collision': True,
            'practical_attack': 'Flame malware (2012), rogue CA certificates',
            'recommendation': 'NEVER use for security, OK for checksums only',
            'birthday_attack_complexity': '2^64 (but practical attacks exist)'
        },
        'sha1': {
            'status': 'BROKEN',
            'year_broken': 2017,
            'collision_time': '~110,000 GPU-years (or ~$110k cloud)',
            'chosen_prefix_collision': True,
            'practical_attack': 'SHAttered (two different PDFs with same hash)',
            'recommendation': 'Deprecated, migrate to SHA-256 or SHA-3',
            'birthday_attack_complexity': '2^80 (theoretical), ~2^63 (practical)'
        },
        'sha256': {
            'status': 'SECURE',
            'year_broken': None,
            'collision_time': 'Not known',
            'chosen_prefix_collision': False,
            'practical_attack': None,
            'recommendation': 'Safe for current use',
            'birthday_attack_complexity': '2^128',
            'note': 'Vulnerable to length extension, use HMAC or SHA-3'
        },
        'sha3_256': {
            'status': 'SECURE',
            'year_broken': None,
            'collision_time': 'Not known',
            'chosen_prefix_collision': False,
            'practical_attack': None,
            'recommendation': 'Recommended for new systems',
            'birthday_attack_complexity': '2^128',
            'note': 'Not vulnerable to length extension'
        },
        'blake2b': {
            'status': 'SECURE',
            'year_broken': None,
            'collision_time': 'Not known',
            'chosen_prefix_collision': False,
            'practical_attack': None,
            'recommendation': 'Excellent for performance-critical applications',
            'birthday_attack_complexity': '2^256',
            'note': 'Faster than MD5 while being secure'
        }
    }

    if algorithm in analyses:
        return analyses[algorithm]
    return {'error': f"Analyse non disponible pour: {algorithm}"}


def compare_algorithms(data: bytes) -> dict:
    """Compare tous les algorithmes disponibles."""
    import time

    algorithms = ['md5', 'sha1', 'sha256', 'sha3_256', 'blake2b']
    results = {}

    for algo in algorithms:
        # Hash
        hash_result = hash_with_algorithm(data, algo)

        # Performance (moyenne sur 1000 it√©rations)
        iterations = 1000
        start = time.perf_counter()
        for _ in range(iterations):
            hash_with_algorithm(data, algo)
        elapsed = time.perf_counter() - start
        throughput_mb_s = (len(data) * iterations / elapsed) / (1024 * 1024)

        # S√©curit√©
        security = collision_analysis(algo)

        results[algo] = {
            'hash': hash_result,
            'hash_length_bits': len(hash_result) * 4,
            'performance_mb_s': round(throughput_mb_s, 2),
            'security_status': security.get('status', 'UNKNOWN'),
            'length_extension_vulnerable': algo in ['md5', 'sha1', 'sha256']
        }

    return results


def recommend_algorithm(use_case: str, performance: str = 'moderate') -> dict:
    """
    Recommande un algorithme selon le contexte.

    use_case: 'integrity', 'password', 'signature', 'checksum', 'blockchain'
    performance: 'critical', 'high', 'moderate', 'low'
    """
    recommendations = {
        'integrity': {
            'critical': {
                'primary': 'BLAKE3',
                'alternative': 'SHA-256',
                'reasoning': 'BLAKE3 is fastest and secure. SHA-256 if compliance required.'
            },
            'moderate': {
                'primary': 'SHA-256',
                'alternative': 'SHA3-256',
                'reasoning': 'SHA-256 is well-established. SHA3-256 for length extension resistance.'
            }
        },
        'password': {
            'primary': 'NOT A HASH FUNCTION',
            'use_instead': ['Argon2id', 'bcrypt', 'scrypt'],
            'reasoning': 'Password hashing requires slow, memory-hard functions.'
        },
        'signature': {
            'primary': 'SHA-256',
            'alternative': 'SHA3-256',
            'reasoning': 'Standard for digital signatures. SHA3 for future-proofing.'
        },
        'checksum': {
            'critical': {
                'primary': 'BLAKE3',
                'reasoning': 'Fastest modern hash, parallelizable, no length extension.'
            },
            'moderate': {
                'primary': 'SHA-256',
                'alternative': 'BLAKE2b',
                'reasoning': 'Standard choice with good performance.'
            }
        },
        'blockchain': {
            'primary': 'SHA-256 (double)',
            'alternative': 'Keccak-256',
            'reasoning': 'Bitcoin uses SHA-256d, Ethereum uses Keccak-256.'
        },
        'git': {
            'primary': 'SHA-256',
            'legacy': 'SHA-1 (deprecated)',
            'reasoning': 'Git migrating from SHA-1 due to SHAttered attack.'
        }
    }

    if use_case not in recommendations:
        return {'error': f"Use case inconnu: {use_case}"}

    result = recommendations[use_case]
    if isinstance(result, dict) and performance in result:
        return result[performance]
    return result


def empreinte_numerique(input_json: str) -> str:
    """Point d'entr√©e principal."""
    data = json.loads(input_json)
    results = {}

    # Hash operations
    if 'hash_operations' in data:
        results['hashes'] = []
        for op in data['hash_operations']:
            algo = op['algorithm']
            input_data = op['input'].encode() if isinstance(op['input'], str) else bytes.fromhex(op['input'])
            hash_result = hash_with_algorithm(input_data, algo)
            results['hashes'].append({
                'algorithm': algo,
                'input': op['input'],
                'hash': hash_result
            })

    # Avalanche test
    if 'avalanche_test' in data:
        test = data['avalanche_test']
        input1 = test['input1'].encode()
        input2 = test['input2'].encode()
        results['avalanche'] = avalanche_test(input1, input2, test['algorithm'])

    # Length extension analysis
    if 'length_extension' in data:
        results['length_extension'] = {}
        for algo in data['length_extension']['algorithms']:
            results['length_extension'][algo] = length_extension_demo(algo)

    # Collision analysis
    if 'collision_analysis' in data:
        results['collision_analysis'] = {}
        for algo in data['collision_analysis']['algorithms']:
            results['collision_analysis'][algo] = collision_analysis(algo)

    # Comparison
    if 'compare' in data:
        test_data = data['compare'].get('data', 'test').encode()
        results['comparison'] = compare_algorithms(test_data)

    # Recommendation
    if 'recommend' in data:
        rec = data['recommend']
        results['recommendation'] = recommend_algorithm(
            rec['use_case'],
            rec.get('performance', 'moderate')
        )

    return json.dumps(results, indent=2)
```

### 4.10 Solutions Mutantes

```python
# Mutant A (Logic): Calcul Hamming incorrect
def hamming_distance_mutant_a(hash1: str, hash2: str) -> int:
    # ‚ùå Compare les caract√®res hex, pas les bits!
    return sum(a != b for a, b in zip(hash1, hash2))
# Impact: Sous-estime la distance (4x moins que r√©el)

# Mutant B (Safety): Pas de validation d'algorithme
def hash_with_algorithm_mutant_b(data: bytes, algorithm: str) -> str:
    # ‚ùå Utilise getattr sans validation
    return getattr(hashlib, algorithm)(data).hexdigest()
# Impact: Permet des algorithmes dangereux ou crash

# Mutant C (Resource): Compare mauvais algorithmes
def recommend_algorithm_mutant_c(use_case: str) -> dict:
    # ‚ùå Recommande MD5 pour tout!
    return {'primary': 'md5', 'reasoning': 'Fast and widely supported'}
# Impact: Recommande un algorithme cass√©

# Mutant D (Boundary): Avalanche avec seuil incorrect
def avalanche_test_mutant_d(data1: bytes, data2: bytes, algorithm: str) -> dict:
    hash1 = hash_with_algorithm(data1, algorithm)
    hash2 = hash_with_algorithm(data2, algorithm)
    distance = hamming_distance(hash1, hash2)
    total_bits = len(hash1) * 4
    percentage = (distance / total_bits) * 100
    # ‚ùå Seuil trop large (20-80% au lieu de 45-55%)
    satisfies_avalanche = 20 <= percentage <= 80
    return {..., 'satisfies_avalanche': satisfies_avalanche}
# Impact: Valide des hash non-cryptographiques

# Mutant E (Return): Length extension mal classifi√©
def length_extension_demo_mutant_e(algorithm: str) -> dict:
    # ‚ùå Classe SHA3 comme vuln√©rable!
    vulnerable_algorithms = ['md5', 'sha1', 'sha256', 'sha3_256']  # ERREUR
    ...
# Impact: Fausse information de s√©curit√©
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

- **Propri√©t√©s des hash** : Pre-image, second pre-image, collision
- **Effet avalanche** : Un bit change ‚Üí 50% du hash change
- **Constructions** : Merkle-Damg√•rd vs Sponge
- **Length extension** : Vuln√©rabilit√© de MD5/SHA-1/SHA-2
- **√âtat de l'art** : SHA-3, BLAKE2, BLAKE3

### 5.2 LDA ‚Äî Traduction litt√©rale

```
FONCTION avalanche_test QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAM√àTRES data1, data2 QUI SONT DES BYTES ET algorithm QUI EST UNE CHA√éNE
D√âBUT FONCTION
    D√âCLARER hash1 COMME LE R√âSULTAT DE hash_with_algorithm DE data1 AVEC algorithm
    D√âCLARER hash2 COMME LE R√âSULTAT DE hash_with_algorithm DE data2 AVEC algorithm

    D√âCLARER total_bits COMME LA LONGUEUR DE hash1 MULTIPLI√â PAR 4
    D√âCLARER distance COMME LA DISTANCE DE HAMMING ENTRE hash1 ET hash2
    D√âCLARER percentage COMME distance DIVIS√â PAR total_bits MULTIPLI√â PAR 100

    D√âCLARER satisfies_avalanche COMME VRAI SI percentage EST ENTRE 45 ET 55

    RETOURNER UN DICTIONNAIRE AVEC distance, percentage, satisfies_avalanche
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
EFFET AVALANCHE
===============

Input 1: "test"
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      SHA-256                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
Hash 1: 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08

Input 2: "Test" (un seul bit diff√©rent: 't' ‚Üí 'T')
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      SHA-256                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
Hash 2: 532eaabd9574880dbf76b9b8cc00832c20a6ec113d682299550d7a6e0f345e25
        ‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤
                    ~50% des bits ont chang√©!


LENGTH EXTENSION ATTACK
=======================

VICTIME (serveur)                     ATTAQUANT
       ‚îÇ                                  ‚îÇ
       ‚îÇ  secret = "secretkey"           ‚îÇ
       ‚îÇ  data = "amount=100"            ‚îÇ
       ‚îÇ  sig = MD5(secret || data)      ‚îÇ
       ‚îÇ                                  ‚îÇ
       ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Voit: data, sig ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
       ‚îÇ         (pas secret!)           ‚îÇ
       ‚îÇ                                  ‚îÇ
       ‚îÇ                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                           ‚îÇ Calcule:  ‚îÇ
       ‚îÇ                           ‚îÇ extension ‚îÇ
       ‚îÇ                           ‚îÇ= "&admin  ‚îÇ
       ‚îÇ                           ‚îÇ   =true"  ‚îÇ
       ‚îÇ                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                  ‚îÇ
       ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ   ‚îÇ Sans conna√Ætre 'secret',      ‚îÇ
       ‚îÇ   ‚îÇ calcule:                      ‚îÇ
       ‚îÇ   ‚îÇ MD5(secret||data||pad||ext)   ‚îÇ
       ‚îÇ   ‚îÇ √† partir de MD5(secret||data) ‚îÇ
       ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                  ‚îÇ
       ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Envoie: data||pad||ext, ‚îÄ‚îÄ‚îÇ
       ‚îÇ              sig_forg√©           ‚îÇ
       ‚îÇ                                  ‚îÇ
       ‚ñº                                  ‚îÇ
Serveur v√©rifie:                         ‚îÇ
MD5(secret||data||pad||ext) == sig_forg√© ‚îÇ
         ‚úì VALIDE!                       ‚îÇ
                                         ‚îÇ
L'attaquant a ajout√© "&admin=true"      ‚îÇ
sans conna√Ætre le secret!               ‚îÇ


CONSTRUCTIONS DE HASH
=====================

MERKLE-DAMG√ÖRD (MD5, SHA-1, SHA-256)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Message: [bloc1][bloc2][bloc3][padding]
             ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ
             ‚ñº      ‚ñº      ‚ñº      ‚ñº
     IV ‚îÄ‚îÄ‚ñ∫[f]‚îÄ‚îÄ‚ñ∫[f]‚îÄ‚îÄ‚ñ∫[f]‚îÄ‚îÄ‚ñ∫[f]‚îÄ‚îÄ‚ñ∫ HASH
             ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 √âtat interne

‚ö†Ô∏è L'√©tat final = le hash = point de d√©part pour extension!


SPONGE (SHA-3/Keccak)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ        √âtat Interne            ‚îÇ
     ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     ‚îÇ  ‚îÇ   Rate (r)  ‚îÇ Capacity(c) ‚îÇ ‚îÇ
     ‚îÇ  ‚îÇ   visible   ‚îÇ   cach√©     ‚îÇ ‚îÇ
     ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Phase ABSORB:          Phase SQUEEZE:

[M1]‚îÄ‚îê                      ‚îå‚îÄ[H1]
     ‚ñº                      ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ ‚äï ‚îÇ‚îÄ‚îÄ‚îÄpermute‚îÄ‚îÄ‚îÄ‚ñ∫   ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫output
   ‚îî‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îò
     ‚ñ≤                      ‚îÇ
[M2]‚îÄ‚îò                      ‚îî‚îÄ[H2]...

‚úì Seul 'rate' est XOR√©/extrait
‚úì 'capacity' reste secret ‚Üí pas de length extension!
```

### 5.5 Cours Complet

#### Propri√©t√©s Fondamentales

| Propri√©t√© | Description | Violation = |
|-----------|-------------|-------------|
| Pre-image | √âtant donn√© h, trouver m tel que H(m)=h | Forge de fichiers |
| 2nd pre-image | √âtant donn√© m1, trouver m2‚â†m1 avec H(m1)=H(m2) | Substitution |
| Collision | Trouver m1‚â†m2 avec H(m1)=H(m2) | Forge de certificats |

#### Complexit√© des Attaques

| Attaque | Complexit√© | Hash 256 bits |
|---------|------------|---------------|
| Pre-image | O(2^n) | 2^256 |
| 2nd pre-image | O(2^n) | 2^256 |
| Collision (birthday) | O(2^(n/2)) | 2^128 |

#### √âtat de l'Art 2024

| Algorithme | Statut | Usage Recommand√© |
|------------|--------|------------------|
| MD5 | üíÄ CASS√â | Checksums non-crypto uniquement |
| SHA-1 | ‚ö†Ô∏è D√âPR√âCI√â | Migration urgente |
| SHA-256 | ‚úÖ S√õR | Standard actuel |
| SHA-3 | ‚úÖ S√õR | Nouveau standard, pas de length ext. |
| BLAKE3 | ‚úÖ S√õR | Performance + s√©curit√© |

### 5.8 Mn√©motechniques

**üéÆ MEME : "Death Note - L'√©criture ne ment pas"**

Comme dans Death Note o√π chaque nom √©crit scelle un destin, chaque fichier hach√© a une empreinte unique. Modifier un seul caract√®re change compl√®tement le hash ‚Äî comme si le fichier √©tait quelqu'un d'autre.

```python
def verify_evidence(file_path: str, expected_hash: str) -> bool:
    """L v√©rifies les preuves contre Kira."""
    # "Si le hash ne correspond pas, c'est que Kira a touch√© au fichier."
    actual_hash = hash_file(file_path, 'sha256')
    if actual_hash != expected_hash:
        print("Le fichier a √©t√© modifi√©. Kira √©tait l√†.")
        return False
    return True
```

---

**üìì MEME : "Ryuk - Length Extension"**

Ryuk peut ajouter des pages au Death Note sans que L le sache. C'est exactement ce que fait l'attaque length extension : ajouter des donn√©es sign√©es sans conna√Ætre le secret.

```python
# ‚ùå Vuln√©rable (comme un Death Note extensible)
signature = md5(secret + data)

# ‚úÖ S√ªr (HMAC emp√™che l'extension)
signature = hmac_sha256(secret, data)
```

---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

| # | Pi√®ge | D√©tection | Correction |
|---|-------|-----------|------------|
| 1 | MD5 pour s√©curit√© | Audit de code | Migrer vers SHA-256+ |
| 2 | SHA-1 pour signatures | D√©pendances | Migrer vers SHA-256+ |
| 3 | H(secret\|\|data) | Analyse protocole | Utiliser HMAC |
| 4 | Hash pour mots de passe | Audit | Argon2id/bcrypt |
| 5 | Comparaison non constant-time | Timing attack | secrets.compare_digest |

---

## üìù SECTION 7 : QCM

**Q1:** Quelle est la complexit√© d'une attaque collision (birthday)?
A) O(2^n)  B) O(2^(n/2)) ‚úì  C) O(n)  D) O(n^2)

**Q2:** Pourquoi SHA-3 n'est pas vuln√©rable au length extension?
A) Plus long  B) Construction sponge avec capacit√© cach√©e ‚úì  C) Plus r√©cent  D) Plus lent

**Q3:** MD5 est cass√© depuis quelle ann√©e?
A) 1996  B) 2004 ‚úì  C) 2010  D) 2017

**Q4:** Que signifie l'effet avalanche?
A) Hash rapide  B) 1 bit change ‚Üí ~50% du hash change ‚úì  C) Collisions fr√©quentes  D) Compression forte

**Q5:** Pour hacher des mots de passe, on utilise:
A) SHA-256  B) MD5  C) Argon2id ‚úì  D) BLAKE3

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| Exercice | 3.1.5-a : empreinte_numerique |
| Concepts | MD5, SHA, length extension, avalanche |
| Difficult√© | 8/10 |
| XP | 225 |

---

*Exercice g√©n√©r√© par HACKBRAIN v5.5.2*
