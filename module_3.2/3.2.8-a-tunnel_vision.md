# Exercice 3.2.14 : tunnel_vision

**Module :**
3.2.8 â€” VPN & Tunneling

**Concept :**
a â€” VPN & Tunneling Analyzer (Detection, Classification)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
2 â€” Melange (concepts a + b + c + d + e + f + g + h)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.3 (Traffic Analysis)
- 3.2.7 (Wireless Security)
- Understanding of encryption protocols

**Domaines :**
Net, Crypto, Algo

**Duree estimee :**
6-8 heures

**XP Base :**
400

**Complexite :**
T3 O(n log n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :** `tunnel_vision.rs`

**Fonctions autorisees :**
- `std::collections::*`
- `serde::*`
- `chrono::*`
- Fonctions mathematiques standard

**Fonctions interdites :**
- Bibliotheques VPN reelles
- `std::process::Command`
- Acces reseau reel

---

### 1.2 Consigne

**ğŸ® CONTEXTE : "TRON: Legacy" - The Grid Pathways**

*"Sur la Grille, les programmes se deplacent via des tunnels de lumiere. Ces tunnels sont les arteres du systeme, certains legitimes, d'autres crees par des 'ISOs' rebelles pour contourner les controles de CLU.*

*Tu es un Security Program, charge de surveiller le flux des donnees. Les VPNs legitimes sont comme les Light Cycles officiels - rapides, directs, autorises. Mais certains tunnels sont des passages secrets : DNS tunneling qui cache des donnees dans les requetes, ICMP tunneling via des pings, HTTP tunneling deguise en trafic web normal.*

*'The Grid. A digital frontier. I tried to picture clusters of information as they moved through the computer...' - Et maintenant, tu dois voir a travers ces tunnels."*

---

### 1.2.1 Contexte Academique

Le tunneling reseau permet d'encapsuler un protocole dans un autre :

1. **VPN classiques** : OpenVPN, WireGuard, IPsec - Legitimes mais surveillables
2. **SSH Tunneling** : Port forwarding, SOCKS proxy - Souvent autorise, parfois abuse
3. **DNS Tunneling** : Donnees cachees dans les requetes DNS - Exfiltration
4. **ICMP Tunneling** : Donnees dans les pings - Contourne les firewalls
5. **HTTP Tunneling** : WebSockets, Chisel - Se fond dans le trafic web

---

**Ta mission :**

Implementer `tunnel_vision` qui:

1. **Detecte les VPNs** (patterns OpenVPN, WireGuard, IPsec)
2. **Identifie le SSH tunneling** (port forwarding patterns)
3. **Detecte le DNS tunneling** (entropie, frequence, taille)
4. **Identifie le HTTP tunneling** (long-polling, WebSocket abuse)
5. **Classifie** chaque tunnel (legitime vs suspect)
6. **Calcule des metriques** de suspicion

---

**Entree :**

```json
{
  "analysis_window": {
    "start": "2026-01-10T00:00:00Z",
    "end": "2026-01-10T23:59:59Z"
  },
  "network_flows": [
    {
      "flow_id": "F001",
      "timestamp": "2026-01-10T10:00:00.000Z",
      "src_ip": "192.168.1.100",
      "dst_ip": "198.51.100.10",
      "src_port": 45678,
      "dst_port": 1194,
      "protocol": "UDP",
      "bytes_sent": 1500000,
      "bytes_received": 2500000,
      "packets": 5000,
      "duration_seconds": 3600,
      "tls_info": null
    },
    {
      "flow_id": "F002",
      "timestamp": "2026-01-10T10:30:00.000Z",
      "src_ip": "192.168.1.100",
      "dst_ip": "203.0.113.50",
      "src_port": 12345,
      "dst_port": 22,
      "protocol": "TCP",
      "bytes_sent": 50000000,
      "bytes_received": 100000,
      "duration_seconds": 7200,
      "tls_info": null
    }
  ],
  "dns_queries": [
    {
      "timestamp": "2026-01-10T11:00:00.000Z",
      "client": "192.168.1.200",
      "query": "aGVsbG8gd29ybGQK.tunnel.evil.com",
      "query_type": "TXT",
      "response_size": 500,
      "response_data": "d29ybGQgaGVsbG8K..."
    }
  ],
  "http_sessions": [
    {
      "session_id": "H001",
      "timestamp": "2026-01-10T12:00:00.000Z",
      "client": "192.168.1.150",
      "server": "198.51.100.80",
      "method": "POST",
      "uri": "/api/stream",
      "content_type": "application/octet-stream",
      "request_size": 1024,
      "response_size": 2048,
      "connection": "keep-alive",
      "duration_ms": 30000,
      "websocket_upgrade": true
    }
  ],
  "icmp_packets": [
    {
      "timestamp": "2026-01-10T13:00:00.000Z",
      "src_ip": "192.168.1.100",
      "dst_ip": "10.0.0.1",
      "type": 8,
      "code": 0,
      "payload_size": 1400
    }
  ],
  "whitelist": {
    "vpn_endpoints": ["198.51.100.10"],
    "ssh_servers": ["203.0.113.50"],
    "allowed_tunnels": ["corporate-vpn"]
  }
}
```

---

**Sortie :**

```json
{
  "tunnels_detected": [
    {
      "tunnel_id": "TUN-001",
      "tunnel_type": "openvpn",
      "classification": "legitimate",
      "confidence": 0.95,
      "evidence": {
        "dst_port": 1194,
        "protocol": "UDP",
        "packet_pattern": "openvpn_handshake",
        "endpoint": "198.51.100.10",
        "whitelisted": true
      },
      "traffic_volume": {
        "bytes_total": 4000000,
        "duration_seconds": 3600,
        "avg_bandwidth_kbps": 8.88
      }
    },
    {
      "tunnel_id": "TUN-002",
      "tunnel_type": "ssh_tunnel",
      "classification": "suspicious",
      "confidence": 0.85,
      "evidence": {
        "asymmetric_ratio": 500.0,
        "high_data_transfer": true,
        "long_duration": true,
        "potential_use": "data_exfiltration"
      },
      "alerts": [
        "Unusual data ratio (500:1 outbound)",
        "Long-lived connection (2 hours)",
        "50MB transferred out via SSH"
      ]
    },
    {
      "tunnel_id": "TUN-003",
      "tunnel_type": "dns_tunnel",
      "classification": "malicious",
      "confidence": 0.92,
      "evidence": {
        "domain": "tunnel.evil.com",
        "query_entropy": 4.8,
        "query_frequency": 120,
        "avg_response_size": 500,
        "encoding_detected": "base64",
        "data_volume_estimated_kb": 150
      },
      "alerts": [
        "High entropy subdomain queries",
        "TXT record abuse detected",
        "Base64 encoding in DNS",
        "Known tunneling domain pattern"
      ]
    },
    {
      "tunnel_id": "TUN-004",
      "tunnel_type": "http_tunnel",
      "classification": "suspicious",
      "confidence": 0.78,
      "evidence": {
        "websocket_upgrade": true,
        "binary_content": true,
        "long_polling": true,
        "potential_tools": ["chisel", "reGeorg"]
      }
    },
    {
      "tunnel_id": "TUN-005",
      "tunnel_type": "icmp_tunnel",
      "classification": "malicious",
      "confidence": 0.88,
      "evidence": {
        "large_payload": true,
        "avg_payload_size": 1400,
        "frequency": 60,
        "normal_ping_size": 64
      }
    }
  ],
  "vpn_analysis": {
    "detected_vpns": [
      {
        "type": "OpenVPN",
        "endpoint": "198.51.100.10:1194",
        "status": "whitelisted",
        "protocol": "UDP"
      }
    ],
    "potential_vpns": [
      {
        "type": "WireGuard",
        "endpoint": "51820",
        "indicators": ["udp_51820", "small_packets", "constant_rate"]
      }
    ]
  },
  "exfiltration_risk": {
    "high_risk_tunnels": ["TUN-002", "TUN-003"],
    "estimated_data_exfil_mb": 50.15,
    "channels": ["SSH", "DNS"]
  },
  "recommendations": [
    {
      "priority": "critical",
      "action": "Block DNS queries to tunnel.evil.com",
      "reason": "Active DNS tunneling detected"
    },
    {
      "priority": "high",
      "action": "Investigate SSH session from 192.168.1.100",
      "reason": "Unusual data transfer pattern"
    },
    {
      "priority": "medium",
      "action": "Monitor WebSocket connections to /api/stream",
      "reason": "Potential HTTP tunneling"
    }
  ]
}
```

---

### 1.3 Prototype

```rust
/// Point d'entree principal
pub fn analyze_tunnels(input: &TunnelInput) -> TunnelAnalysis;

/// Detecte les VPNs dans les flows
pub fn detect_vpns(flows: &[NetworkFlow]) -> Vec<VpnDetection>;

/// Detecte le SSH tunneling
pub fn detect_ssh_tunneling(
    flows: &[NetworkFlow],
    threshold_ratio: f64
) -> Vec<SshTunnel>;

/// Detecte le DNS tunneling
pub fn detect_dns_tunneling(
    queries: &[DnsQuery],
    entropy_threshold: f64
) -> Vec<DnsTunnel>;

/// Detecte le HTTP tunneling
pub fn detect_http_tunneling(
    sessions: &[HttpSession]
) -> Vec<HttpTunnel>;

/// Detecte le ICMP tunneling
pub fn detect_icmp_tunneling(
    packets: &[IcmpPacket],
    size_threshold: usize
) -> Vec<IcmpTunnel>;

/// Classifie un tunnel
pub fn classify_tunnel(
    tunnel: &Tunnel,
    whitelist: &Whitelist
) -> Classification;

/// Calcule l'entropie d'une chaine
pub fn calculate_entropy(data: &str) -> f64;

/// Detecte l'encodage base64
pub fn detect_base64_encoding(data: &str) -> bool;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Iodine : DNS sur UDP 53

Iodine est l'un des outils de DNS tunneling les plus connus. Il peut atteindre jusqu'a 680 kbit/s en utilisant les requetes NULL et fonctionne meme quand seul le port 53 est autorise.

### 2.2 WireGuard : Le VPN moderne

WireGuard utilise seulement ~4000 lignes de code (vs ~100,000 pour OpenVPN), utilise Curve25519, ChaCha20, Poly1305, et est integre au kernel Linux depuis la version 5.6.

### 2.3 Domain Fronting

Technique utilisee pour cacher la destination reelle du trafic HTTPS en utilisant un CDN. La requete TLS va vers cloudfront.com mais le header Host indique evil.com.

---

### 2.5 DANS LA VRAIE VIE

| Metier | Utilisation |
|--------|-------------|
| **SOC Analyst** | Detecte les exfiltrations via tunnels |
| **Network Security** | Configure les regles de detection |
| **Penetration Tester** | Utilise le tunneling pour maintenir l'acces |
| **Threat Hunter** | Recherche les C2 caches |
| **DLP Analyst** | Previent les fuites de donnees |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
tunnel_vision.rs  main.rs  captures/

$ cargo build --release

$ ./target/release/tunnel_vision captures/network_dump.json
Tunnel Vision Analysis Complete!

VPNs Detected:
- OpenVPN (198.51.100.10:1194) - WHITELISTED
- WireGuard? (51820) - UNKNOWN

Suspicious Tunnels:
[CRITICAL] DNS Tunnel to tunnel.evil.com
           - Entropy: 4.8 (high)
           - Est. data: 150 KB

[HIGH] SSH Exfiltration from 192.168.1.100
       - 50 MB transferred (500:1 ratio)

[MEDIUM] HTTP Tunnel via WebSocket
         - Binary data detected

Exfiltration Risk: HIGH (50.15 MB estimated)
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Detect OpenVPN by port | 10 |
| `T02` | Detect WireGuard pattern | 10 |
| `T03` | Detect SSH tunneling (ratio) | 15 |
| `T04` | Detect DNS tunneling (entropy) | 15 |
| `T05` | Detect base64 in DNS | 10 |
| `T06` | Detect HTTP tunneling | 10 |
| `T07` | Detect ICMP tunneling | 10 |
| `T08` | Classify legitimate vs malicious | 10 |
| `T09` | Handle whitelist correctly | 10 |

**Total : 100 points**

---

### 4.3 Solution de reference (extraits)

```rust
pub fn detect_vpns(flows: &[NetworkFlow]) -> Vec<VpnDetection> {
    let mut vpns = Vec::new();

    for flow in flows {
        let vpn_type = identify_vpn_type(flow);

        if let Some(vtype) = vpn_type {
            vpns.push(VpnDetection {
                tunnel_id: format!("VPN-{}", vpns.len() + 1),
                vpn_type: vtype,
                endpoint: format!("{}:{}", flow.dst_ip, flow.dst_port),
                protocol: flow.protocol.clone(),
                confidence: calculate_vpn_confidence(flow, &vtype),
            });
        }
    }

    vpns
}

fn identify_vpn_type(flow: &NetworkFlow) -> Option<VpnType> {
    // OpenVPN: UDP/TCP 1194, or TCP 443 with specific patterns
    if flow.dst_port == 1194 {
        return Some(VpnType::OpenVPN);
    }

    // WireGuard: UDP 51820
    if flow.dst_port == 51820 && flow.protocol == "UDP" {
        return Some(VpnType::WireGuard);
    }

    // IPsec: UDP 500 (IKE) or UDP 4500 (NAT-T)
    if (flow.dst_port == 500 || flow.dst_port == 4500) && flow.protocol == "UDP" {
        return Some(VpnType::IPsec);
    }

    // SSTP: TCP 443 with specific TLS patterns
    if flow.dst_port == 443 {
        if let Some(ref tls) = flow.tls_info {
            if tls.server_name.contains("sstp") {
                return Some(VpnType::SSTP);
            }
        }
    }

    None
}

pub fn detect_ssh_tunneling(
    flows: &[NetworkFlow],
    threshold_ratio: f64
) -> Vec<SshTunnel> {
    let mut tunnels = Vec::new();

    let ssh_flows: Vec<_> = flows.iter()
        .filter(|f| f.dst_port == 22 || f.src_port == 22)
        .collect();

    for flow in ssh_flows {
        // Calculate data transfer ratio
        let ratio = if flow.bytes_received > 0 {
            flow.bytes_sent as f64 / flow.bytes_received as f64
        } else {
            flow.bytes_sent as f64
        };

        // Suspicious indicators
        let mut alerts = Vec::new();

        // High asymmetric ratio (likely exfiltration)
        if ratio > threshold_ratio {
            alerts.push(format!(
                "Unusual data ratio ({:.1}:1 outbound)",
                ratio
            ));
        }

        // Large data transfer
        if flow.bytes_sent > 10_000_000 { // 10MB
            alerts.push(format!(
                "{}MB transferred out via SSH",
                flow.bytes_sent / 1_000_000
            ));
        }

        // Long duration
        if flow.duration_seconds > 3600 { // 1 hour
            alerts.push(format!(
                "Long-lived connection ({} hours)",
                flow.duration_seconds / 3600
            ));
        }

        if !alerts.is_empty() {
            tunnels.push(SshTunnel {
                tunnel_id: format!("SSH-{}", tunnels.len() + 1),
                flow_id: flow.flow_id.clone(),
                src_ip: flow.src_ip.clone(),
                dst_ip: flow.dst_ip.clone(),
                bytes_sent: flow.bytes_sent,
                bytes_received: flow.bytes_received,
                ratio,
                duration: flow.duration_seconds,
                alerts,
                classification: if ratio > 100.0 {
                    Classification::Suspicious
                } else {
                    Classification::Normal
                },
            });
        }
    }

    tunnels
}

pub fn detect_dns_tunneling(
    queries: &[DnsQuery],
    entropy_threshold: f64
) -> Vec<DnsTunnel> {
    let mut tunnels = Vec::new();
    let mut domain_stats: HashMap<String, DomainAnalysis> = HashMap::new();

    for query in queries {
        let base_domain = extract_base_domain(&query.query);
        let subdomain = extract_subdomain(&query.query);

        let stats = domain_stats.entry(base_domain.clone()).or_default();
        stats.query_count += 1;
        stats.total_response_size += query.response_size;

        if let Some(ref sub) = subdomain {
            let entropy = calculate_entropy(sub);
            stats.entropies.push(entropy);
            stats.subdomains.push(sub.clone());

            // Check for base64 encoding
            if detect_base64_encoding(sub) {
                stats.base64_detected = true;
            }
        }

        // Track query types (TXT often used for tunneling)
        stats.query_types.push(query.query_type.clone());
    }

    for (domain, stats) in domain_stats {
        if stats.entropies.is_empty() {
            continue;
        }

        let avg_entropy = stats.entropies.iter().sum::<f64>()
            / stats.entropies.len() as f64;

        let txt_ratio = stats.query_types.iter()
            .filter(|t| *t == "TXT")
            .count() as f64 / stats.query_types.len() as f64;

        let mut alerts = Vec::new();

        // High entropy subdomains
        if avg_entropy > entropy_threshold {
            alerts.push("High entropy subdomain queries".to_string());
        }

        // TXT record abuse
        if txt_ratio > 0.5 {
            alerts.push("TXT record abuse detected".to_string());
        }

        // Base64 encoding
        if stats.base64_detected {
            alerts.push("Base64 encoding in DNS".to_string());
        }

        // High query frequency
        if stats.query_count > 100 {
            alerts.push("High query frequency".to_string());
        }

        // Large responses
        if stats.total_response_size > 10000 {
            alerts.push("Large DNS responses".to_string());
        }

        if alerts.len() >= 2 {
            let confidence = calculate_dns_tunnel_confidence(
                avg_entropy,
                txt_ratio,
                stats.base64_detected,
                stats.query_count,
            );

            tunnels.push(DnsTunnel {
                tunnel_id: format!("DNS-{}", tunnels.len() + 1),
                domain,
                avg_entropy,
                query_count: stats.query_count,
                total_response_size: stats.total_response_size,
                base64_detected: stats.base64_detected,
                txt_ratio,
                alerts,
                confidence,
                classification: Classification::Malicious,
            });
        }
    }

    tunnels
}

pub fn calculate_entropy(data: &str) -> f64 {
    if data.is_empty() {
        return 0.0;
    }

    let mut freq: HashMap<char, usize> = HashMap::new();
    for c in data.chars() {
        *freq.entry(c).or_insert(0) += 1;
    }

    let len = data.len() as f64;
    freq.values()
        .map(|&count| {
            let p = count as f64 / len;
            if p > 0.0 {
                -p * p.log2()
            } else {
                0.0
            }
        })
        .sum()
}

pub fn detect_base64_encoding(data: &str) -> bool {
    // Base64 characteristics:
    // - Only [A-Za-z0-9+/=]
    // - Length multiple of 4 (with padding)
    // - Entropy around 4.0-4.5

    if data.len() < 4 {
        return false;
    }

    let valid_chars = data.chars().all(|c|
        c.is_ascii_alphanumeric() || c == '+' || c == '/' || c == '='
    );

    if !valid_chars {
        return false;
    }

    let entropy = calculate_entropy(data);

    // Base64 typically has entropy around 4.0-4.5
    entropy > 3.5 && entropy < 5.0
}

pub fn detect_icmp_tunneling(
    packets: &[IcmpPacket],
    size_threshold: usize
) -> Vec<IcmpTunnel> {
    let mut tunnels = Vec::new();
    let mut src_stats: HashMap<String, IcmpStats> = HashMap::new();

    // Normal ping payload is typically 32-64 bytes
    let normal_size = 64;

    for packet in packets {
        // Only interested in echo request (8) and reply (0)
        if packet.icmp_type != 8 && packet.icmp_type != 0 {
            continue;
        }

        let stats = src_stats.entry(packet.src_ip.clone()).or_default();
        stats.count += 1;
        stats.total_payload += packet.payload_size;
        stats.payload_sizes.push(packet.payload_size);
    }

    for (src_ip, stats) in src_stats {
        let avg_payload = stats.total_payload / stats.count.max(1);

        if avg_payload > size_threshold {
            let large_ratio = stats.payload_sizes.iter()
                .filter(|&&s| s > size_threshold)
                .count() as f64 / stats.count as f64;

            if large_ratio > 0.5 {
                tunnels.push(IcmpTunnel {
                    tunnel_id: format!("ICMP-{}", tunnels.len() + 1),
                    src_ip,
                    packet_count: stats.count,
                    avg_payload_size: avg_payload,
                    max_payload_size: *stats.payload_sizes.iter().max().unwrap_or(&0),
                    alerts: vec![
                        "Large ICMP payloads".to_string(),
                        format!("Avg size: {} (normal: {})", avg_payload, normal_size),
                    ],
                    confidence: large_ratio.min(0.95),
                    classification: Classification::Malicious,
                });
            }
        }
    }

    tunnels
}

pub fn classify_tunnel(
    tunnel: &Tunnel,
    whitelist: &Whitelist
) -> Classification {
    // Check whitelist first
    if let Some(ref endpoint) = tunnel.endpoint {
        if whitelist.vpn_endpoints.contains(endpoint) {
            return Classification::Legitimate;
        }
        if whitelist.ssh_servers.contains(endpoint) {
            return Classification::Legitimate;
        }
    }

    // Classification based on tunnel type and indicators
    match tunnel.tunnel_type {
        TunnelType::OpenVPN | TunnelType::WireGuard | TunnelType::IPsec => {
            // VPNs to unknown endpoints are suspicious
            Classification::Suspicious
        },
        TunnelType::DnsTunnel | TunnelType::IcmpTunnel => {
            // Almost always malicious
            Classification::Malicious
        },
        TunnelType::SshTunnel => {
            // Depends on data patterns
            if tunnel.ratio.unwrap_or(0.0) > 100.0 {
                Classification::Suspicious
            } else {
                Classification::Normal
            }
        },
        TunnelType::HttpTunnel => {
            // Depends on content
            if tunnel.binary_content.unwrap_or(false) {
                Classification::Suspicious
            } else {
                Classification::Normal
            }
        },
    }
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A : Entropie mal calculee

```rust
pub fn calculate_entropy(data: &str) -> f64 {
    // BUG: Divise par le mauvais denominateur
    let len = data.len() as f64;
    freq.values()
        .map(|&count| {
            let p = count as f64 / 256.0;  // BUG: devrait etre len
            -p * p.log2()
        })
        .sum()
}
// Pourquoi c'est faux : L'entropie est sous-estimee
```

#### Mutant B : SSH ratio inverse

```rust
let ratio = if flow.bytes_sent > 0 {
    flow.bytes_received as f64 / flow.bytes_sent as f64  // BUG: inverse
} else {
    0.0
};
// Pourquoi c'est faux : Detection exfiltration inversee
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.3 Visualisation ASCII

```
TUNNEL TYPES OVERVIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LEGITIMATE VPN TUNNEL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client   â”‚â”€â”€â”€â”€â–ºâ”‚  VPN Server  â”‚â”€â”€â”€â”€â–ºâ”‚  Internet  â”‚
â”‚192.168.1.1 â”‚     â”‚198.51.100.10 â”‚     â”‚            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚
       â”‚   UDP 1194       â”‚
       â”‚  (OpenVPN)       â”‚
       â”‚   Encrypted      â”‚
       â”‚   âœ“ Legitimate   â”‚


DNS TUNNELING (Malicious)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Infected  â”‚â”€â”€â”€â”€â–ºâ”‚  DNS Server â”‚â”€â”€â”€â”€â–ºâ”‚   Attacker  â”‚
â”‚    Host    â”‚     â”‚(Recursive)  â”‚     â”‚   C2 Server â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚                   â”‚
       â”‚   Query:         â”‚    Query:         â”‚
       â”‚   aGVsbG8.evil.com  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
       â”‚                  â”‚                   â”‚
       â”‚   Response:      â”‚    Response:      â”‚
       â”‚   TXT "d29ybGQ=" â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
       â”‚                  â”‚                   â”‚
       â”‚   Data hidden in DNS!               â”‚


ICMP TUNNELING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Normal Ping:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ICMP Echo Request                                    â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ IP Headerâ”‚ICMP Headerâ”‚ Payload (32-64 bytes)   â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ICMP Tunnel:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ICMP Echo Request                                    â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ IP Headerâ”‚ICMP Headerâ”‚ DATA DATA DATA (1400B)  â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                        â†‘                             â”‚
â”‚           SUSPICIOUS! Normal ping is ~64 bytes       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


SSH TUNNEL DATA EXFILTRATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Normal SSH Session:
Bytes Out â”â”â”â”â” (commands: small)
Bytes In  â”â”â”â”â”â”â”â”â”â”â”â”â” (output: larger)
Ratio: 1:3 - 1:10 (normal)

Exfiltration via SSH:
Bytes Out â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” (DATA!)
Bytes In  â” (acknowledgments only)
Ratio: 500:1 - SUSPICIOUS!


ENTROPY ANALYSIS FOR DNS TUNNELING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Normal subdomain:     "www", "mail", "api"
Entropy: ~2.0-2.5     Low (predictable patterns)

Tunneling subdomain:  "aGVsbG8gd29ybGQK"
Entropy: ~4.5-5.0     High (base64 = random-like)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Entropy Scale                                       â”‚
â”‚                                                     â”‚
â”‚ 0.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2.5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 5.0+  â”‚
â”‚ â”‚             â”‚               â”‚               â”‚     â”‚
â”‚ Predictable  Normal          Base64         Random â”‚
â”‚ (aaaa)       (www.google)    Encoded         Data  â”‚
â”‚                              â†‘                      â”‚
â”‚                    TUNNEL INDICATOR                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 Mnemotechniques

#### ğŸ¬ MEME : "TRON: Legacy" - The Grid

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  "The Grid. A digital frontier."                                â”‚
â”‚                                                                 â”‚
â”‚  ğŸï¸ VPN = Light Cycle Lanes                                    â”‚
â”‚     â†’ Tunnels officiels, rapides, autorises                     â”‚
â”‚     â†’ OpenVPN/WireGuard = Highway legitime                      â”‚
â”‚                                                                 â”‚
â”‚  ğŸŒŠ DNS TUNNEL = Underground Program                            â”‚
â”‚     â†’ Se cache dans les requetes DNS                            â”‚
â”‚     â†’ Comme les ISOs se cachant dans la Grille                  â”‚
â”‚     â†’ Detection: Entropie elevee = "Ce n'est pas un programme   â”‚
â”‚       normal!"                                                  â”‚
â”‚                                                                 â”‚
â”‚  ğŸ“¡ ICMP TUNNEL = Light Trail Abuse                             â”‚
â”‚     â†’ Les pings sont comme les traces des Light Cycles          â”‚
â”‚     â†’ Normalement courts, si longs = contrebande                â”‚
â”‚                                                                 â”‚
â”‚  ğŸŒ HTTP TUNNEL = Sea of Simulation                             â”‚
â”‚     â†’ Se fond dans le trafic web normal                         â”‚
â”‚     â†’ WebSocket = Connection directe au serveur CLU             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ SECTION 7 : QCM (extraits)

### Q1. Quel port est typiquement utilise par OpenVPN ?

- A) 22
- B) 443
- C) 1194
- D) 51820

**Reponse : C**

### Q2. Comment detecter le DNS tunneling ?

- A) Port non standard
- B) Entropie elevee des sous-domaines + requetes TXT
- C) Taille des paquets
- D) Adresse IP source

**Reponse : B**

### Q3. Quel ratio de donnees SSH indique une potentielle exfiltration ?

- A) 1:1
- B) 1:10
- C) 100:1 (sortant)
- D) 1:100

**Reponse : C**

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.2.8-a-tunnel-vision",
    "metadata": {
      "exercise_id": "3.2.14",
      "exercise_name": "tunnel_vision",
      "module": "3.2.8",
      "module_name": "VPN & Tunneling",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 400,
      "tags": ["vpn", "tunneling", "dns-tunnel", "ssh", "exfiltration", "detection"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Tunnel Vision*
*"The Grid. A digital frontier."*
