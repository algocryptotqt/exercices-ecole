# Exercice 3.2.10 : protocol_chaos

**Module :**
3.2.5 â€” Protocol Attacks

**Concept :**
a â€” TCP/IP Attack Lab (Hijacking, RST, SYN Flood, Amplification, Fragmentation)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
2 â€” Melange (concepts a + b + c + d + e + f + g + h)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.3 (Traffic Analysis)
- 3.2.4 (Network Attacks)
- TCP/IP fundamentals
- Understanding of sequence numbers

**Domaines :**
Net, Algo, Crypto

**Duree estimee :**
6-8 heures

**XP Base :**
400

**Complexite :**
T3 O(n log n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :** `protocol_chaos.rs`

**Fonctions autorisees :**
- `std::collections::*` (HashMap, HashSet, BTreeMap)
- `std::net::*` (IpAddr, Ipv4Addr, Ipv6Addr)
- `serde::*` (Serialize, Deserialize)
- `chrono::*` (DateTime, Duration)
- Fonctions mathematiques standard

**Fonctions interdites :**
- `std::net::TcpStream` (pas de connexions reelles)
- `std::process::Command` (pas d'execution systeme)
- Toute bibliotheque reseau active
- Bibliotheques externes non listees

---

### 1.2 Consigne

**ğŸ® CONTEXTE : "The Matrix" - Protocol Manipulation Division**

*"Tu vois, Neo, la matrice n'est qu'un flux de donnees. Des paquets TCP/IP qui forment la realite numerique. Les agents utilisent des attaques protocolaires pour corrompre ce flux - SYN floods pour submerger, RST injections pour interrompre, fragmentation pour traverser les defenses.*

*Morpheus t'a confie la mission d'analyser ces corruptions dans le flux. Tu dois voir au-dela des octets, comprendre les sequences, detecter les amplifications. Car celui qui maitrise les protocoles maitrise la Matrice elle-meme."*

---

### 1.2.1 Contexte Academique

Les attaques au niveau TCP/IP exploitent les faiblesses fondamentales des protocoles reseau :

1. **TCP Hijacking** : Prediction des numeros de sequence pour injecter des paquets
2. **TCP Reset** : Injection de paquets RST pour interrompre les connexions
3. **SYN Flood** : Saturation de la file d'attente SYN du serveur
4. **Amplification DDoS** : Utilisation de DNS/NTP comme amplificateurs
5. **Fragmentation** : Exploitation du reassemblage IP pour contourner les filtres

---

**Ta mission :**

Implementer `protocol_chaos` qui:

1. **Analyse les paquets TCP** pour detecter les hijacking attempts (sequence analysis)
2. **Detecte les SYN floods** (ratio SYN/SYN-ACK, half-open connections)
3. **Identifie les attaques d'amplification** (DNS/NTP avec facteur de calcul)
4. **Detecte les RST injections** (RST hors sequence, timing suspect)
5. **Analyse les fragments IP** (overlapping, teardrop patterns)
6. **Propose des regles de filtrage** en reponse aux attaques detectees

---

**Entree :**

```json
{
  "analysis_config": {
    "syn_flood_threshold": 100,
    "amplification_factor_threshold": 10,
    "sequence_window": 65535
  },
  "packets": [
    {
      "timestamp": "2026-01-10T10:00:00.000Z",
      "src_ip": "192.168.1.100",
      "dst_ip": "10.0.0.1",
      "src_port": 45678,
      "dst_port": 80,
      "protocol": "TCP",
      "tcp_flags": {
        "syn": true,
        "ack": false,
        "rst": false,
        "fin": false,
        "psh": false
      },
      "seq_number": 1000000,
      "ack_number": 0,
      "window_size": 65535,
      "payload_size": 0,
      "ttl": 64
    }
  ],
  "udp_packets": [
    {
      "timestamp": "2026-01-10T10:00:01.000Z",
      "src_ip": "10.0.0.50",
      "dst_ip": "8.8.8.8",
      "src_port": 12345,
      "dst_port": 53,
      "protocol": "UDP",
      "payload_size": 40,
      "dns_query": "example.com",
      "dns_type": "ANY"
    }
  ],
  "ip_fragments": [
    {
      "timestamp": "2026-01-10T10:00:02.000Z",
      "src_ip": "192.168.1.200",
      "dst_ip": "10.0.0.1",
      "identification": 12345,
      "fragment_offset": 0,
      "more_fragments": true,
      "payload_size": 1480,
      "ttl": 128
    }
  ]
}
```

---

**Sortie :**

```json
{
  "attacks_detected": [
    {
      "attack_id": "ATK-001",
      "attack_type": "syn_flood",
      "severity": "critical",
      "confidence": 0.95,
      "description": "SYN flood detected from multiple sources",
      "evidence": {
        "syn_count": 15000,
        "synack_count": 150,
        "ratio": 100.0,
        "unique_sources": 1500,
        "target": "10.0.0.1:80",
        "duration_seconds": 60
      },
      "affected_hosts": ["10.0.0.1"],
      "mitre_technique": "T1498.001"
    },
    {
      "attack_id": "ATK-002",
      "attack_type": "dns_amplification",
      "severity": "high",
      "confidence": 0.88,
      "evidence": {
        "query_size_avg": 40,
        "response_size_avg": 3000,
        "amplification_factor": 75.0,
        "spoofed_source": "10.0.0.1",
        "dns_servers_used": 50
      }
    },
    {
      "attack_id": "ATK-003",
      "attack_type": "tcp_hijack_attempt",
      "severity": "critical",
      "evidence": {
        "connection": "192.168.1.100:45678 -> 10.0.0.1:80",
        "injected_seq": 1000500,
        "expected_window": [1000000, 1065535],
        "in_window": true,
        "suspicious_reason": "RST with valid sequence from non-original source"
      }
    },
    {
      "attack_id": "ATK-004",
      "attack_type": "fragment_attack",
      "severity": "high",
      "evidence": {
        "attack_subtype": "overlapping_fragments",
        "identification": 12345,
        "fragments_received": 3,
        "overlap_detected": true,
        "overlap_offset": 1400,
        "potential_impact": "IDS evasion / Host crash"
      }
    }
  ],
  "connection_states": {
    "half_open_connections": 14500,
    "established_connections": 200,
    "suspicious_resets": 45
  },
  "amplification_analysis": {
    "dns_amplification_detected": true,
    "ntp_amplification_detected": false,
    "total_amplification_traffic_mb": 450.5,
    "reflectors_identified": ["8.8.8.8", "8.8.4.4"]
  },
  "fragment_analysis": {
    "total_fragments": 156,
    "reassembly_issues": 12,
    "overlapping_fragments": 8,
    "tiny_fragments": 4
  },
  "proposed_filter_rules": [
    {
      "rule_id": "RULE-001",
      "rule_type": "rate_limit",
      "action": "limit",
      "target": "syn_packets",
      "parameters": {
        "rate": "100/second",
        "burst": 200
      },
      "justification": "Mitigate SYN flood attack"
    },
    {
      "rule_id": "RULE-002",
      "rule_type": "block",
      "action": "drop",
      "source": "0.0.0.0/0",
      "destination_port": 53,
      "protocol": "UDP",
      "direction": "inbound",
      "justification": "Block external DNS ANY queries"
    },
    {
      "rule_id": "RULE-003",
      "rule_type": "fragment_policy",
      "action": "drop",
      "parameters": {
        "min_fragment_size": 400,
        "max_fragments_per_packet": 10
      },
      "justification": "Prevent fragment-based attacks"
    }
  ],
  "statistics": {
    "total_packets_analyzed": 25000,
    "attack_packets": 18500,
    "legitimate_packets": 6500,
    "analysis_duration_ms": 450
  }
}
```

---

### 1.3 Prototype

```rust
/// Point d'entree principal
pub fn analyze_protocol_attacks(input: &ProtocolInput) -> ProtocolAnalysis;

/// Detecte les SYN floods
pub fn detect_syn_flood(
    packets: &[TcpPacket],
    threshold: u32
) -> Option<SynFloodAttack>;

/// Detecte les tentatives de hijacking TCP
pub fn detect_tcp_hijacking(
    connections: &HashMap<ConnectionKey, ConnectionState>,
    packets: &[TcpPacket]
) -> Vec<HijackAttempt>;

/// Detecte les RST injections
pub fn detect_rst_injection(
    connections: &HashMap<ConnectionKey, ConnectionState>,
    rst_packets: &[TcpPacket]
) -> Vec<RstInjection>;

/// Analyse les attaques d'amplification
pub fn analyze_amplification(
    udp_packets: &[UdpPacket],
    factor_threshold: f64
) -> AmplificationAnalysis;

/// Analyse les fragments IP
pub fn analyze_fragments(
    fragments: &[IpFragment]
) -> FragmentAnalysis;

/// Genere des regles de filtrage
pub fn generate_filter_rules(
    attacks: &[Attack]
) -> Vec<FilterRule>;

/// Calcule le facteur d'amplification
pub fn calculate_amplification_factor(
    request_size: usize,
    response_size: usize
) -> f64;

/// Verifie si un numero de sequence est dans la fenetre
pub fn is_in_sequence_window(
    seq: u32,
    expected_seq: u32,
    window_size: u32
) -> bool;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'histoire du SYN Flood

En 1996, le premier SYN flood majeur a frappe Panix, un des premiers ISP de New York. L'attaque etait si efficace qu'elle a inspire la creation des **SYN cookies** - une defense ingenieuse qui encode les informations de connexion dans le numero de sequence initial, evitant ainsi de stocker des etats pour les connexions non completees.

### 2.2 Le theoreme de Kaminsky

En 2008, Dan Kaminsky a decouvert que le DNS cache poisoning etait beaucoup plus facile qu'on ne le pensait. Son attaque permettait d'empoisonner un cache DNS en ~10 secondes au lieu des ~10 ans theoriques. Cela a conduit a l'adoption massive de DNSSEC et a la randomisation des ports source.

### 2.3 L'amplification record

L'attaque d'amplification la plus massive connue utilisait **memcached** avec un facteur d'amplification de **51,000x**. Une requete de 15 bytes pouvait generer une reponse de 750KB. GitHub a subi une attaque de 1.35 Tbps en 2018 utilisant cette technique.

---

### 2.5 DANS LA VRAIE VIE

| Metier | Utilisation |
|--------|-------------|
| **SOC Analyst** | Detecte les attaques DDoS en temps reel, analyse les patterns de trafic |
| **Incident Responder** | Analyse les captures lors d'incidents, identifie les vecteurs d'attaque |
| **Penetration Tester** | Teste la resilience des infrastructures aux attaques protocolaires |
| **Network Engineer** | Configure les protections (SYN cookies, rate limiting, BCP38) |
| **DDoS Mitigation Specialist** | Concoit les strategies de defense contre les attaques volumetriques |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
protocol_chaos.rs  main.rs  test_data/

$ cargo build --release

$ ./target/release/protocol_chaos test_data/capture.json
Analysis Complete!
Attacks Detected: 4
- SYN Flood: Critical (15000 SYN, 150 SYN-ACK)
- DNS Amplification: High (factor: 75x)
- TCP Hijack Attempt: Critical (1 connection)
- Fragment Attack: High (overlapping)

Filter Rules Generated: 3
Total Packets: 25000
Attack Packets: 18500 (74%)
```

---

## ğŸ’€ SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
ğŸ§  (12/10)

**Recompense :**
XP Ã—6

**Time Complexity attendue :**
O(n log n)

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Probas, Crypto`

### 3.1.1 Consigne Bonus

**ğŸ® "The Architect's View" - Predictive Attack Analysis**

*"Neo, l'Architecte voit tous les chemins possibles. Tu dois faire de meme : predire les attaques avant qu'elles ne se materialisent, detecter les patterns d'emergence, identifier les botnets par leur signature comportementale."*

**Ta mission :**

Implementer `predict_attacks` qui:

1. **Analyse comportementale** : Detecte les patterns de botnet (timing correlation)
2. **Prediction de sequence TCP** : Estime la vulnerabilite a la prediction
3. **Detection de covert channels** : Identifie les communications cachees dans les flags/timing
4. **Machine Learning lite** : Clustering des sources d'attaque par comportement
5. **Forensic timeline** : Reconstruction de l'attaque avec phases identifiees

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  packets.len() â‰¤ 10^6                   â”‚
â”‚  Temps limite : O(n log n)              â”‚
â”‚  Memoire limite : O(n)                  â”‚
â”‚  Faux positifs < 1%                     â”‚
â”‚  Detection : > 99% des attaques         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```rust
/// Analyse predictive des attaques
pub fn predict_attacks(
    packets: &[Packet],
    historical_data: Option<&HistoricalData>
) -> PredictiveAnalysis;

/// Detecte les covert channels
pub fn detect_covert_channels(
    packets: &[TcpPacket]
) -> Vec<CovertChannel>;

/// Clustering des sources d'attaque
pub fn cluster_attack_sources(
    attacks: &[Attack]
) -> Vec<AttackCluster>;

/// Reconstruction forensique
pub fn build_attack_timeline(
    packets: &[Packet],
    attacks: &[Attack]
) -> AttackTimeline;
```

### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Detection | Reactive | Predictive |
| Botnet | Non detecte | Clustering comportemental |
| Covert channels | Non | Detection timing/flags |
| Output | Attaques detectees | Timeline forensique complete |
| Precision | ~90% | >99% avec <1% faux positifs |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Detect SYN flood (basic) | 10 |
| `T02` | Detect SYN flood (distributed) | 10 |
| `T03` | Calculate half-open connections | 5 |
| `T04` | Detect TCP hijacking attempt | 15 |
| `T05` | Detect RST injection | 10 |
| `T06` | Calculate amplification factor | 10 |
| `T07` | Detect DNS amplification | 10 |
| `T08` | Detect NTP amplification | 5 |
| `T09` | Detect overlapping fragments | 10 |
| `T10` | Detect tiny fragments | 5 |
| `T11` | Generate appropriate filter rules | 10 |

**Total : 100 points**

---

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use chrono::{DateTime, Utc, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone)]
pub struct TcpPacket {
    pub timestamp: DateTime<Utc>,
    pub src_ip: String,
    pub dst_ip: String,
    pub src_port: u16,
    pub dst_port: u16,
    pub tcp_flags: TcpFlags,
    pub seq_number: u32,
    pub ack_number: u32,
    pub window_size: u32,
    pub payload_size: usize,
    pub ttl: u8,
}

#[derive(Debug, Clone)]
pub struct TcpFlags {
    pub syn: bool,
    pub ack: bool,
    pub rst: bool,
    pub fin: bool,
    pub psh: bool,
}

#[derive(Debug, Clone)]
pub struct ConnectionState {
    pub client_seq: u32,
    pub server_seq: u32,
    pub state: TcpState,
    pub last_activity: DateTime<Utc>,
    pub client_ip: String,
    pub server_ip: String,
}

#[derive(Debug, Clone, PartialEq)]
pub enum TcpState {
    SynSent,
    SynReceived,
    Established,
    FinWait,
    Closed,
}

pub fn detect_syn_flood(
    packets: &[TcpPacket],
    threshold: u32
) -> Option<SynFloodAttack> {
    let mut syn_count: HashMap<String, u32> = HashMap::new();
    let mut synack_count: HashMap<String, u32> = HashMap::new();
    let mut sources: HashMap<String, HashSet<String>> = HashMap::new();

    for packet in packets {
        let target = format!("{}:{}", packet.dst_ip, packet.dst_port);

        if packet.tcp_flags.syn && !packet.tcp_flags.ack {
            *syn_count.entry(target.clone()).or_insert(0) += 1;
            sources.entry(target.clone())
                .or_insert_with(HashSet::new)
                .insert(packet.src_ip.clone());
        } else if packet.tcp_flags.syn && packet.tcp_flags.ack {
            *synack_count.entry(target.clone()).or_insert(0) += 1;
        }
    }

    for (target, syn_total) in &syn_count {
        let synack_total = synack_count.get(target).unwrap_or(&0);

        if *syn_total > threshold && *synack_total > 0 {
            let ratio = *syn_total as f64 / *synack_total as f64;

            if ratio > 10.0 {
                let unique_sources = sources.get(target)
                    .map(|s| s.len())
                    .unwrap_or(0);

                return Some(SynFloodAttack {
                    target: target.clone(),
                    syn_count: *syn_total,
                    synack_count: *synack_total,
                    ratio,
                    unique_sources,
                    severity: if ratio > 50.0 { Severity::Critical } else { Severity::High },
                    confidence: calculate_syn_flood_confidence(ratio, unique_sources),
                });
            }
        }
    }

    None
}

pub fn detect_tcp_hijacking(
    connections: &HashMap<ConnectionKey, ConnectionState>,
    packets: &[TcpPacket]
) -> Vec<HijackAttempt> {
    let mut attempts = Vec::new();

    for packet in packets {
        let key = ConnectionKey {
            src_ip: packet.src_ip.clone(),
            dst_ip: packet.dst_ip.clone(),
            src_port: packet.src_port,
            dst_port: packet.dst_port,
        };

        // Check reverse connection too
        let reverse_key = ConnectionKey {
            src_ip: packet.dst_ip.clone(),
            dst_ip: packet.src_ip.clone(),
            src_port: packet.dst_port,
            dst_port: packet.src_port,
        };

        // Look for packets with valid sequence but from different source
        if let Some(conn) = connections.get(&reverse_key) {
            if conn.state == TcpState::Established {
                // Check if this packet's source doesn't match the connection
                if packet.src_ip != conn.client_ip && packet.src_ip != conn.server_ip {
                    let in_window = is_in_sequence_window(
                        packet.seq_number,
                        conn.server_seq,
                        conn.window_size,
                    );

                    if in_window {
                        attempts.push(HijackAttempt {
                            connection: format!("{}:{} -> {}:{}",
                                conn.client_ip, key.src_port,
                                conn.server_ip, key.dst_port),
                            injected_seq: packet.seq_number,
                            expected_window: (conn.server_seq, conn.server_seq.wrapping_add(conn.window_size)),
                            in_window,
                            suspicious_ip: packet.src_ip.clone(),
                            has_rst: packet.tcp_flags.rst,
                            has_data: packet.payload_size > 0,
                        });
                    }
                }
            }
        }
    }

    attempts
}

pub fn detect_rst_injection(
    connections: &HashMap<ConnectionKey, ConnectionState>,
    packets: &[TcpPacket]
) -> Vec<RstInjection> {
    let mut injections = Vec::new();

    let rst_packets: Vec<_> = packets.iter()
        .filter(|p| p.tcp_flags.rst)
        .collect();

    for rst in rst_packets {
        let key = ConnectionKey {
            src_ip: rst.src_ip.clone(),
            dst_ip: rst.dst_ip.clone(),
            src_port: rst.src_port,
            dst_port: rst.dst_port,
        };

        if let Some(conn) = connections.get(&key) {
            // RST should have valid sequence number
            let valid_seq = is_in_sequence_window(
                rst.seq_number,
                conn.client_seq,
                65535,
            );

            // Check for suspicious patterns
            let suspicious = is_rst_suspicious(rst, conn);

            if suspicious {
                injections.push(RstInjection {
                    connection: format!("{}:{} -> {}:{}",
                        rst.src_ip, rst.src_port,
                        rst.dst_ip, rst.dst_port),
                    rst_seq: rst.seq_number,
                    expected_seq: conn.client_seq,
                    valid_sequence: valid_seq,
                    ttl_mismatch: rst.ttl != conn.expected_ttl,
                    timing_suspicious: true,
                });
            }
        }
    }

    injections
}

fn is_rst_suspicious(rst: &TcpPacket, conn: &ConnectionState) -> bool {
    // Multiple RSTs in short time
    // TTL significantly different from established connection
    // RST immediately after SYN-ACK (connection teardown attack)

    rst.ttl.abs_diff(conn.expected_ttl) > 10
}

pub fn analyze_amplification(
    udp_packets: &[UdpPacket],
    factor_threshold: f64
) -> AmplificationAnalysis {
    let mut dns_queries: HashMap<String, (usize, usize)> = HashMap::new();
    let mut ntp_queries: HashMap<String, (usize, usize)> = HashMap::new();
    let mut reflectors: HashSet<String> = HashSet::new();

    for packet in udp_packets {
        match packet.dst_port {
            53 => {
                // DNS
                let key = packet.src_ip.clone();
                let entry = dns_queries.entry(key).or_insert((0, 0));

                if packet.is_query {
                    entry.0 += packet.payload_size;

                    // Check for amplification-prone queries
                    if packet.dns_type == Some("ANY".to_string()) ||
                       packet.dns_type == Some("TXT".to_string()) {
                        reflectors.insert(packet.dst_ip.clone());
                    }
                } else {
                    entry.1 += packet.payload_size;
                }
            },
            123 => {
                // NTP
                let key = packet.src_ip.clone();
                let entry = ntp_queries.entry(key).or_insert((0, 0));

                if packet.payload_size < 100 {
                    entry.0 += packet.payload_size;

                    // monlist command
                    if packet.ntp_mode == Some(7) {
                        reflectors.insert(packet.dst_ip.clone());
                    }
                } else {
                    entry.1 += packet.payload_size;
                }
            },
            _ => {}
        }
    }

    // Calculate amplification factors
    let mut dns_detected = false;
    let mut ntp_detected = false;
    let mut total_amplified_bytes = 0usize;
    let mut max_dns_factor = 0.0f64;
    let mut max_ntp_factor = 0.0f64;

    for (_, (query_bytes, response_bytes)) in &dns_queries {
        if *query_bytes > 0 {
            let factor = *response_bytes as f64 / *query_bytes as f64;
            if factor > factor_threshold {
                dns_detected = true;
                max_dns_factor = max_dns_factor.max(factor);
                total_amplified_bytes += response_bytes;
            }
        }
    }

    for (_, (query_bytes, response_bytes)) in &ntp_queries {
        if *query_bytes > 0 {
            let factor = *response_bytes as f64 / *query_bytes as f64;
            if factor > factor_threshold {
                ntp_detected = true;
                max_ntp_factor = max_ntp_factor.max(factor);
                total_amplified_bytes += response_bytes;
            }
        }
    }

    AmplificationAnalysis {
        dns_amplification_detected: dns_detected,
        ntp_amplification_detected: ntp_detected,
        max_dns_factor,
        max_ntp_factor,
        total_amplification_traffic_mb: total_amplified_bytes as f64 / 1_000_000.0,
        reflectors_identified: reflectors.into_iter().collect(),
    }
}

pub fn analyze_fragments(
    fragments: &[IpFragment]
) -> FragmentAnalysis {
    let mut fragment_groups: HashMap<(String, String, u16), Vec<&IpFragment>> = HashMap::new();

    // Group fragments by identification
    for frag in fragments {
        let key = (frag.src_ip.clone(), frag.dst_ip.clone(), frag.identification);
        fragment_groups.entry(key).or_default().push(frag);
    }

    let mut overlapping_count = 0;
    let mut tiny_count = 0;
    let mut reassembly_issues = 0;
    let mut attacks = Vec::new();

    for (key, frags) in &fragment_groups {
        let mut sorted_frags: Vec<_> = frags.iter().collect();
        sorted_frags.sort_by_key(|f| f.fragment_offset);

        // Check for overlapping fragments
        for i in 1..sorted_frags.len() {
            let prev = sorted_frags[i - 1];
            let curr = sorted_frags[i];

            let prev_end = prev.fragment_offset + prev.payload_size as u16;

            if curr.fragment_offset < prev_end {
                overlapping_count += 1;
                attacks.push(FragmentAttack {
                    attack_subtype: "overlapping_fragments".to_string(),
                    identification: key.2,
                    overlap_offset: curr.fragment_offset,
                    potential_impact: "IDS evasion / Host crash".to_string(),
                });
            }
        }

        // Check for tiny fragments (evasion technique)
        for frag in &sorted_frags {
            if frag.payload_size < 8 && frag.more_fragments {
                tiny_count += 1;
            }
        }

        // Check for reassembly completeness
        let has_first = sorted_frags.iter().any(|f| f.fragment_offset == 0);
        let has_last = sorted_frags.iter().any(|f| !f.more_fragments);

        if !has_first || !has_last {
            reassembly_issues += 1;
        }
    }

    FragmentAnalysis {
        total_fragments: fragments.len(),
        reassembly_issues,
        overlapping_fragments: overlapping_count,
        tiny_fragments: tiny_count,
        attacks,
    }
}

pub fn generate_filter_rules(attacks: &[Attack]) -> Vec<FilterRule> {
    let mut rules = Vec::new();

    for attack in attacks {
        match &attack.attack_type {
            AttackType::SynFlood { target, .. } => {
                rules.push(FilterRule {
                    rule_id: format!("RULE-{}", rules.len() + 1),
                    rule_type: "rate_limit".to_string(),
                    action: "limit".to_string(),
                    target: Some(target.clone()),
                    parameters: Some(RuleParameters {
                        rate: "100/second".to_string(),
                        burst: Some(200),
                    }),
                    justification: "Mitigate SYN flood attack".to_string(),
                });

                // Also add SYN cookies recommendation
                rules.push(FilterRule {
                    rule_id: format!("RULE-{}", rules.len() + 1),
                    rule_type: "sysctl".to_string(),
                    action: "enable".to_string(),
                    target: Some("net.ipv4.tcp_syncookies".to_string()),
                    parameters: None,
                    justification: "Enable SYN cookies for connection flood protection".to_string(),
                });
            },

            AttackType::DnsAmplification { reflectors, .. } => {
                rules.push(FilterRule {
                    rule_id: format!("RULE-{}", rules.len() + 1),
                    rule_type: "block".to_string(),
                    action: "drop".to_string(),
                    target: Some("udp/53".to_string()),
                    parameters: Some(RuleParameters {
                        rate: String::new(),
                        burst: None,
                    }),
                    justification: "Block external DNS ANY queries to prevent amplification".to_string(),
                });

                // BCP38 recommendation
                rules.push(FilterRule {
                    rule_id: format!("RULE-{}", rules.len() + 1),
                    rule_type: "bcp38".to_string(),
                    action: "implement".to_string(),
                    target: Some("egress".to_string()),
                    parameters: None,
                    justification: "Implement BCP38 to prevent IP spoofing".to_string(),
                });
            },

            AttackType::FragmentAttack { .. } => {
                rules.push(FilterRule {
                    rule_id: format!("RULE-{}", rules.len() + 1),
                    rule_type: "fragment_policy".to_string(),
                    action: "drop".to_string(),
                    target: Some("ip fragments".to_string()),
                    parameters: Some(RuleParameters {
                        rate: "min_size:400".to_string(),
                        burst: Some(10),
                    }),
                    justification: "Prevent fragment-based attacks".to_string(),
                });
            },

            AttackType::TcpHijacking { .. } | AttackType::RstInjection { .. } => {
                rules.push(FilterRule {
                    rule_id: format!("RULE-{}", rules.len() + 1),
                    rule_type: "tcp_security".to_string(),
                    action: "enable".to_string(),
                    target: Some("tcp_timestamps".to_string()),
                    parameters: None,
                    justification: "Enable TCP timestamps to prevent injection attacks".to_string(),
                });
            },

            _ => {}
        }
    }

    rules
}

pub fn is_in_sequence_window(seq: u32, expected_seq: u32, window_size: u32) -> bool {
    // Handle wraparound
    let diff = seq.wrapping_sub(expected_seq);
    diff <= window_size
}

pub fn calculate_amplification_factor(request_size: usize, response_size: usize) -> f64 {
    if request_size == 0 {
        return 0.0;
    }
    response_size as f64 / request_size as f64
}

fn calculate_syn_flood_confidence(ratio: f64, unique_sources: usize) -> f64 {
    // Higher confidence with higher ratio and more sources
    let ratio_score = (ratio / 100.0).min(1.0);
    let source_score = (unique_sources as f64 / 1000.0).min(1.0);

    (ratio_score * 0.6 + source_score * 0.4).min(0.99)
}
```

---

### 4.10 Solutions Mutantes (minimum 5)

#### Mutant A (Boundary) : Off-by-one dans la fenetre de sequence

```rust
pub fn is_in_sequence_window(seq: u32, expected_seq: u32, window_size: u32) -> bool {
    let diff = seq.wrapping_sub(expected_seq);
    diff < window_size  // BUG: < au lieu de <=
}
// Pourquoi c'est faux : La sequence exacte expected_seq + window_size est valide
// Ce qui etait pense : La fenetre est exclusive
```

#### Mutant B (Safety) : Pas de gestion du wraparound

```rust
pub fn is_in_sequence_window(seq: u32, expected_seq: u32, window_size: u32) -> bool {
    seq >= expected_seq && seq <= expected_seq + window_size  // BUG: pas de wrapping
}
// Pourquoi c'est faux : Les numeros de sequence TCP wraparound a 2^32
// Ce qui etait pense : Les sequences sont toujours croissantes
```

#### Mutant C (Logic) : Mauvais calcul du ratio SYN/SYN-ACK

```rust
pub fn detect_syn_flood(...) -> Option<SynFloodAttack> {
    // ...
    let ratio = *synack_total as f64 / *syn_total as f64;  // BUG: inverse
    // ...
}
// Pourquoi c'est faux : Le ratio doit etre SYN/SYN-ACK, pas l'inverse
// Ce qui etait pense : Plus de SYN-ACK = attaque
```

#### Mutant D (Resource) : Detection amplification sans seuil

```rust
pub fn analyze_amplification(...) -> AmplificationAnalysis {
    for (_, (query_bytes, response_bytes)) in &dns_queries {
        let factor = *response_bytes as f64 / *query_bytes as f64;
        // BUG: pas de comparaison avec factor_threshold
        dns_detected = true;  // Toujours detecte
        // ...
    }
}
// Pourquoi c'est faux : Tout trafic DNS est detecte comme amplification
// Ce qui etait pense : Toute reponse > requete est une attaque
```

#### Mutant E (Return) : Retourne None meme quand attaque detectee

```rust
pub fn detect_syn_flood(...) -> Option<SynFloodAttack> {
    // ... detection logic ...
    if ratio > 10.0 {
        // BUG: return None au lieu de Some(attack)
        return None;
    }
    None
}
// Pourquoi c'est faux : L'attaque detectee n'est pas retournee
// Ce qui etait pense : Le code continue apres la detection
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **TCP State Machine** : Comprendre les etats de connexion TCP
2. **Sequence Numbers** : Role critique dans la securite TCP
3. **Amplification Attacks** : Comment de petites requetes generent d'enormes reponses
4. **IP Fragmentation** : Vulnerabilites du reassemblage
5. **Defense in Depth** : Strategies de mitigation multi-couches

### 5.2 LDA â€” Traduction litterale

```
FONCTION detect_syn_flood QUI RETOURNE UNE OPTION D'ATTAQUE ET PREND EN PARAMÃˆTRES packets QUI EST UN TABLEAU DE PAQUETS TCP ET threshold QUI EST UN ENTIER
DÃ‰BUT FONCTION
    DÃ‰CLARER syn_count COMME TABLEAU ASSOCIATIF CLÃ‰ STRING VALEUR ENTIER
    DÃ‰CLARER synack_count COMME TABLEAU ASSOCIATIF CLÃ‰ STRING VALEUR ENTIER

    POUR CHAQUE packet DANS packets FAIRE
        DÃ‰CLARER target COMME CHAÃNE FORMAT "{}:{}" AVEC dst_ip ET dst_port

        SI packet A FLAG SYN ET N'A PAS FLAG ACK ALORS
            INCRÃ‰MENTER syn_count[target] DE 1
        SINON SI packet A FLAG SYN ET A FLAG ACK ALORS
            INCRÃ‰MENTER synack_count[target] DE 1
        FIN SI
    FIN POUR

    POUR CHAQUE (target, syn_total) DANS syn_count FAIRE
        DÃ‰CLARER synack_total COMME synack_count[target] OU 0

        SI syn_total EST SUPÃ‰RIEUR Ã€ threshold ET synack_total EST SUPÃ‰RIEUR Ã€ 0 ALORS
            DÃ‰CLARER ratio COMME syn_total DIVISÃ‰ PAR synack_total

            SI ratio EST SUPÃ‰RIEUR Ã€ 10 ALORS
                RETOURNER QUELQUE CHOSE AVEC L'ATTAQUE DÃ‰TECTÃ‰E
            FIN SI
        FIN SI
    FIN POUR

    RETOURNER RIEN
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
TCP THREE-WAY HANDSHAKE (Normal)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Client                                Server
  â”‚                                      â”‚
  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€[SYN seq=100]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
  â”‚                                      â”‚
  â”‚â†â”€â”€â”€â”€[SYN-ACK seq=300, ack=101]â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                      â”‚
  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€[ACK ack=301]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
  â”‚                                      â”‚
  â”‚          ESTABLISHED                 â”‚
  â”‚                                      â”‚


SYN FLOOD ATTACK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Attacker (spoofed IPs)              Server
  â”‚                                    â”‚
  â”‚â”€â”€â”€â”€â”€[SYN seq=xxx, src=1.1.1.1]â”€â”€â”€â”€â†’â”‚ â”
  â”‚â”€â”€â”€â”€â”€[SYN seq=xxx, src=2.2.2.2]â”€â”€â”€â”€â†’â”‚ â”‚ SYN Queue
  â”‚â”€â”€â”€â”€â”€[SYN seq=xxx, src=3.3.3.3]â”€â”€â”€â”€â†’â”‚ â”‚ Fills Up!
  â”‚â”€â”€â”€â”€â”€[SYN seq=xxx, src=4.4.4.4]â”€â”€â”€â”€â†’â”‚ â”‚
  â”‚        ... thousands more ...       â”‚ â”˜
  â”‚                                    â”‚
  â”‚â†â”€â”€[SYN-ACK to 1.1.1.1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ (No response)
  â”‚â†â”€â”€[SYN-ACK to 2.2.2.2]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ (No response)
  â”‚                                    â”‚
  â”‚      LEGITIMATE CLIENT             â”‚
  â”‚                                    â”‚
  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€[SYN seq=100]â”€â”€â”€â”€â”€â”€â”€â”€â”€Xâ”€â”€â”€â”€â”‚ DROPPED!
  â”‚                                    â”‚

Result: Half-open connections exhaust server resources


TCP SEQUENCE NUMBER HIJACKING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Client (IP: 192.168.1.100)      Server (IP: 10.0.0.1)
seq=1000, ack=5000              seq=5000, ack=1000
  â”‚                                    â”‚
  â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”€[Data]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                    â”‚
      Attacker observes traffic
      Predicts next sequence: ~1000-1500
  â”‚                                    â”‚
  â”‚   Attacker (spoofed 192.168.1.100) â”‚
  â”‚â”€â”€â”€â”€â”€[RST seq=1200]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                    â”‚
  â”‚      CONNECTION TERMINATED!        â”‚


AMPLIFICATION ATTACK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚  Attacker                DNS Server           Victim       â”‚
â”‚     â”‚                        â”‚                   â”‚         â”‚
â”‚     â”‚ Spoofed src=Victim     â”‚                   â”‚         â”‚
â”‚     â”‚â”€â”€â”€[Query ANY? 40B]â”€â”€â”€â”€â†’â”‚                   â”‚         â”‚
â”‚     â”‚                        â”‚                   â”‚         â”‚
â”‚     â”‚                        â”‚â”€â”€â”€[Response      â”‚         â”‚
â”‚     â”‚                        â”‚    3000B]â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚         â”‚
â”‚     â”‚                        â”‚                   â”‚         â”‚
â”‚                                                            â”‚
â”‚  Amplification Factor = 3000 / 40 = 75x                    â”‚
â”‚                                                            â”‚
â”‚  With 1000 reflectors:                                     â”‚
â”‚  1 Mbps attack â†’ 75 Gbps at victim                         â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


FRAGMENT OVERLAP ATTACK (Teardrop)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Normal Reassembly:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frag 0  â”‚â”‚ Frag 1  â”‚â”‚ Frag 2  â”‚
â”‚ 0-1479  â”‚â”‚1480-2959â”‚â”‚2960-end â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Overlapping Fragments:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Fragment 0 â”‚ offset=0, len=1480
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Fragment 1 â”‚ offset=1400, len=1480  â† OVERLAP!
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Fragment 2 â”‚ offset=1300, len=1000  â† MORE OVERLAP!
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

What data goes at offset 1400?
â†’ Undefined behavior â†’ Crash / IDS evasion
```

### 5.4 Les pieges en detail

#### Piege 1 : Faux positifs sur gros sites

```rust
// MAUVAIS : Detecte Google comme attaque
if syn_count > 1000 {
    return Attack::SynFlood;
}

// BON : Utilise le ratio
if syn_count > threshold && (syn_count / synack_count) > 10.0 {
    // Legitime si beaucoup de SYN-ACK aussi
}
```

#### Piege 2 : Sequence number wraparound

```rust
// MAUVAIS : Ne gere pas le wraparound
if new_seq > expected_seq && new_seq < expected_seq + window {
    // BUG quand expected_seq proche de u32::MAX
}

// BON : Utilise wrapping_sub
let diff = new_seq.wrapping_sub(expected_seq);
if diff <= window {
    // Correct meme avec wraparound
}
```

#### Piege 3 : Fragmentation legitime vs attaque

```rust
// MAUVAIS : Bloque toute fragmentation
if packet.is_fragment {
    return Attack;
}

// BON : Detecte patterns specifiques
if has_overlap || has_tiny_first_fragment || has_impossible_offset {
    return Attack;
}
```

### 5.5 Cours Complet

#### 5.5.1 TCP State Machine et Securite

TCP utilise des **numeros de sequence** de 32 bits pour ordonner les segments et assurer la fiabilite. Ces numeros etaient autrefois previsibles (incrementes lineairement), permettant des attaques de hijacking.

**ISN (Initial Sequence Number) Security:**
```
Ancien (vulnerable): ISN = ISN_precedent + 128000
Moderne (securise):  ISN = hash(src_ip, src_port, dst_ip, dst_port, secret)
```

#### 5.5.2 SYN Cookies

Defense contre le SYN flood qui evite de stocker l'etat:

```
SYN Cookie = MSS_encoded | Timestamp | Hash(src, dst, ports, timestamp, secret)
```

Le serveur encode l'information dans le numero de sequence de la reponse SYN-ACK. Si le client repond avec ACK, le serveur peut reconstruire l'etat.

#### 5.5.3 Amplification DNS

Certaines requetes DNS produisent des reponses tres volumineuses:

| Type Query | Request | Response | Factor |
|------------|---------|----------|--------|
| ANY | ~40B | ~3000B | 75x |
| TXT | ~40B | ~4000B | 100x |
| DNSSEC | ~50B | ~4000B | 80x |

**Mitigations:**
- Response Rate Limiting (RRL)
- Desactiver ANY pour les requetes externes
- BCP38 (filtrage source)

#### 5.5.4 IP Fragmentation Attacks

**Teardrop:** Fragments qui se chevauchent avec des donnees differentes
**Ping of Death:** Fragment final cree un paquet > 65535 bytes
**Tiny Fragment:** Premier fragment si petit que les headers TCP sont splits

### 5.6 Normes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais interdit)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if seq > expected && seq < expected + window { ... }            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let diff = seq.wrapping_sub(expected);                          â”‚
â”‚ if diff <= window { ... }                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Les sequence numbers TCP wraparound a 2^32                    â”‚
â”‚ â€¢ Sans wrapping_sub, on rate des paquets valides                â”‚
â”‚ â€¢ Faille de securite potentielle (faux negatifs)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'execution

**Scenario:** Detection SYN Flood

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Paquet                       â”‚ SYN cnt â”‚ ACK cnt  â”‚ Action             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ SYN from 1.1.1.1:12345       â”‚    1    â”‚    0     â”‚ Compte SYN         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ SYN from 2.2.2.2:23456       â”‚    2    â”‚    0     â”‚ Compte SYN         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ SYN-ACK to 1.1.1.1           â”‚    2    â”‚    1     â”‚ Compte SYN-ACK     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ...  â”‚ ... 14997 more SYNs ...      â”‚ 15000   â”‚    1     â”‚ Ratio = 15000      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 15001 â”‚ Final: ratio > threshold     â”‚ 15000   â”‚   150    â”‚ ATTACK DETECTED!   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 Mnemotechniques

#### ğŸ”´ğŸ’Š MEME : "The Matrix" - Red Pill / Blue Pill

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  ğŸ”´ RED PILL : Tu vois la realite des paquets                   â”‚
â”‚                                                                 â”‚
â”‚     "Free your mind" â†’ Free your sequence numbers               â”‚
â”‚     Les agents (attaquants) manipulent la Matrice (reseau)      â”‚
â”‚     Tu dois voir au-dela des octets                             â”‚
â”‚                                                                 â”‚
â”‚  SYN FLOOD = "Sentinel Swarm"                                   â”‚
â”‚     â†’ Des milliers d'entites qui submergent Zion                â”‚
â”‚     â†’ Chaque SYN est un Sentinel                                â”‚
â”‚     â†’ SYN Cookies = EMP (neutralise sans stocker)               â”‚
â”‚                                                                 â”‚
â”‚  TCP HIJACKING = "Agent Smith takes over"                       â”‚
â”‚     â†’ L'agent prend le controle d'un corps (connexion)          â”‚
â”‚     â†’ Meme apparence, meme sequence numbers                     â”‚
â”‚     â†’ Detecte par le "code" different (TTL, timing)             â”‚
â”‚                                                                 â”‚
â”‚  AMPLIFICATION = "Bullet Time"                                  â”‚
â”‚     â†’ Un petit geste (requete) declenche une pluie de balles    â”‚
â”‚     â†’ Factor 75x = 75 balles pour un mouvement                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.9 Applications pratiques

1. **DDoS Mitigation Service** : Scrubbing centers analysent ces patterns
2. **ISP Network Security** : Detection d'attaques sortantes (BCP38)
3. **CDN Edge Security** : Protection des origines contre amplification
4. **Enterprise SOC** : Correlation d'evenements reseau

---

## âš ï¸ SECTION 6 : PIEGES â€” RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Ignorer le wraparound TCP | Faux negatifs sur hijacking | `wrapping_sub()` |
| 2 | Seuil SYN fixe | Faux positifs sur gros sites | Ratio SYN/SYN-ACK |
| 3 | Bloquer toute fragmentation | Casse le trafic legitime | Detecter patterns specifiques |
| 4 | Ignorer TTL dans injection | Rate les RST injectes | Comparer TTL au baseline |
| 5 | Division par zero amplification | Crash sur zero queries | Verifier query_bytes > 0 |

---

## ğŸ“ SECTION 7 : QCM

### Q1. Qu'est-ce qui caracterise un SYN flood ?

- A) Beaucoup de connexions etablies
- B) Ratio SYN/SYN-ACK tres eleve
- C) Beaucoup de paquets RST
- D) Trafic UDP uniquement

**Reponse : B**

### Q2. Comment les SYN cookies fonctionnent-ils ?

- A) Ils bloquent tous les SYN
- B) Ils stockent l'etat dans le sequence number de la reponse
- C) Ils accelerent le three-way handshake
- D) Ils chiffrent les paquets SYN

**Reponse : B**

### Q3. Quel est le facteur d'amplification typique du DNS ANY ?

- A) 2x
- B) 10x
- C) 50-100x
- D) 1000x

**Reponse : C**

### Q4. Pourquoi le wraparound TCP est-il important pour la detection ?

- A) Il accelere l'analyse
- B) Les sequence numbers font 32 bits et reviennent a zero
- C) Il reduit la memoire utilisee
- D) Il n'est pas important

**Reponse : B**

### Q5. Qu'est-ce qu'une attaque Teardrop ?

- A) Flood de paquets SYN
- B) Fragments IP qui se chevauchent
- C) Injection de paquets RST
- D) Amplification NTP

**Reponse : B**

### Q6. Comment BCP38 aide contre les attaques d'amplification ?

- A) Il bloque le DNS
- B) Il filtre les paquets avec IP source spoofee
- C) Il limite le debit
- D) Il chiffre le trafic

**Reponse : B**

### Q7. Qu'est-ce qui rend une injection RST detectable ?

- A) Le port de destination
- B) Le TTL different et timing suspect
- C) La taille du paquet
- D) Le protocole utilise

**Reponse : B**

### Q8. Quelle commande NTP est exploitee pour l'amplification ?

- A) time
- B) sync
- C) monlist
- D) version

**Reponse : C**

### Q9. Pourquoi les tiny fragments sont-ils suspects ?

- A) Ils sont trop rapides
- B) Ils peuvent splitter les headers TCP pour evader les filtres
- C) Ils utilisent trop de bande passante
- D) Ils ne sont jamais legitimes

**Reponse : B**

### Q10. Comment detecter un TCP hijacking ?

- A) Compter les paquets
- B) Analyser si des paquets avec sequence valide viennent d'IP differentes
- C) Mesurer la latence
- D) Verifier les checksums

**Reponse : B**

---

## ğŸ“Š SECTION 8 : RECAPITULATIF

| Concept | Implementation | Points Cles |
|---------|----------------|-------------|
| SYN Flood | Ratio SYN/SYN-ACK | Seuil dynamique, multi-source |
| TCP Hijacking | Sequence analysis | Window check, source verification |
| RST Injection | TTL/timing analysis | Baseline comparison |
| Amplification | Factor calculation | DNS ANY, NTP monlist |
| Fragmentation | Overlap detection | Teardrop, tiny fragments |
| Filter Rules | Contextual generation | Rate limit, BCP38, cookies |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.2.5-a-protocol-chaos",
    "metadata": {
      "exercise_id": "3.2.10",
      "exercise_name": "protocol_chaos",
      "module": "3.2.5",
      "module_name": "Protocol Attacks",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 400,
      "tags": ["tcp", "syn-flood", "amplification", "hijacking", "fragmentation", "ddos"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Protocol Chaos*
*"Voir au-dela des octets, maitriser la Matrice"*
