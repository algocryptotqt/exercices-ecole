# Exercice 3.2.1-b : digital_periscope

**Module :**
3.2.1 â€” Reconnaissance & OSINT

**Concept :**
b â€” Search Engine Intelligence (Shodan, Censys, Infrastructure Mapping)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
2 â€” MÃ©lange (concepts d + e + i + j)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
3.2.1-a (OSINT basics), JSON parsing, Structures de donnÃ©es

**Domaines :**
Net, Struct, Crypto

**DurÃ©e estimÃ©e :**
240-300 min (4-5 heures)

**XP Base :**
450

**ComplexitÃ© :**
T3 O(nÂ·m) Ã— S3 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier :** `digital_periscope.rs`
**AutorisÃ© :** serde, serde_json, chrono, regex, ipnetwork
**Interdit :** reqwest, hyper, tokio (pas de vraies requÃªtes rÃ©seau)

### 1.2 Consigne

**ğŸ® "Metal Gear Solid" â€” The Patriots' Network**

*"Information is power. But like all power, there are those who want to keep it for themselves."* â€” Solid Snake

Tu es **Solid Snake**, infiltrÃ© dans le rÃ©seau des Patriots. Leur infrastructure mondiale est exposÃ©e Ã  travers des moteurs de recherche spÃ©cialisÃ©s comme **Shodan** et **Censys**. Ces outils indexent chaque serveur, chaque service, chaque certificat SSL du monde.

Ton codec t'a transmis des donnÃ©es brutes. Ã€ toi de les analyser pour mapper l'infrastructure ennemie.

**Contexte RÃ©el :**

Shodan et Censys sont des "moteurs de recherche pour l'Internet des objets". Contrairement Ã  Google qui indexe le contenu web, ils scannent et indexent :
- **Shodan** : BanniÃ¨res de services, ports ouverts, versions logicielles
- **Censys** : Certificats SSL, configurations TLS, services HTTPS

Les professionnels utilisent ces outils pour :
- **Asset Discovery** : Trouver tous les assets exposÃ©s d'une organisation
- **Vulnerability Assessment** : Identifier les versions vulnÃ©rables
- **Attack Surface Mapping** : Comprendre l'exposition globale
- **Threat Intelligence** : Tracker les infrastructures malveillantes

**Ta mission :**

ImplÃ©menter un analyseur de rÃ©sultats Shodan/Censys qui :

1. **Parse les rÃ©sultats de scan** : Format JSON simulant l'API Shodan
2. **Extrait les services exposÃ©s** : Ports, banniÃ¨res, versions
3. **Identifie les vulnÃ©rabilitÃ©s** : Versions obsolÃ¨tes, configurations dangereuses
4. **Construit la carte d'infrastructure** : ASN, netblocks, sous-domaines
5. **Calcule un score de risque** : BasÃ© sur l'exposition et les vulnÃ©rabilitÃ©s
6. **GÃ©nÃ¨re des recommandations** : Actions de remÃ©diation prioritaires

**EntrÃ©e :**
- `input_json` : String JSON contenant :
  - `shodan_results` : RÃ©sultats de recherche Shodan (hosts, services, banniÃ¨res)
  - `censys_results` : Certificats SSL et configurations
  - `target_organization` : Nom de l'organisation cible
  - `known_assets` : Assets dÃ©jÃ  connus (pour comparaison)

**Sortie :**
- JSON structurÃ© avec :
  - `infrastructure_map` : Carte complÃ¨te (IPs, ASNs, sous-domaines)
  - `exposed_services` : Services dÃ©tectÃ©s avec mÃ©tadonnÃ©es
  - `vulnerabilities` : VulnÃ©rabilitÃ©s identifiÃ©es avec sÃ©vÃ©ritÃ©
  - `risk_score` : Score de risque global (0-100)
  - `attack_surface` : Analyse de la surface d'attaque
  - `recommendations` : Actions de remÃ©diation ordonnÃ©es

**Contraintes :**
- Les versions connues vulnÃ©rables doivent Ãªtre dÃ©tectÃ©es (ex: OpenSSL < 1.1.1)
- Les ASN doivent Ãªtre correctement groupÃ©s
- Les sous-domaines extraits des certificats doivent Ãªtre dÃ©dupliquÃ©s
- Le score de risque doit reflÃ©ter la rÃ©alitÃ© de l'exposition

**Exemples :**

| Cas | Description | Comportement Attendu |
|-----|-------------|---------------------|
| SSH vieux | OpenSSH 5.x | VulnÃ©rabilitÃ© HIGH |
| Telnet exposÃ© | Port 23 ouvert | Critique, recommandation fermer |
| Cert wildcard | *.example.com | Extraction tous sous-domaines |
| Same ASN | 5 IPs dans AS12345 | Groupement correct |
| Version rÃ©cente | nginx 1.24 | Pas de vulnÃ©rabilitÃ© |

### 1.2.2 Consigne AcadÃ©mique

Cet exercice implÃ©mente un systÃ¨me d'analyse de rÃ©sultats de scans Internet (Shodan/Censys). L'objectif est de construire une vue complÃ¨te de l'infrastructure d'une cible Ã  partir de donnÃ©es de scan, identifier les faiblesses, et proposer des actions correctives.

Le systÃ¨me doit :
1. Parser les formats de rÃ©ponse Shodan/Censys simulÃ©s
2. Extraire et normaliser les informations de service
3. DÃ©tecter les versions vulnÃ©rables via une base de connaissances
4. Construire une carte d'infrastructure (ASN â†’ Netblock â†’ IP â†’ Service)
5. Calculer des scores de risque multicritÃ¨res
6. GÃ©nÃ©rer des recommandations priorisÃ©es

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::net::IpAddr;

/// Point d'entrÃ©e principal
pub fn digital_periscope(input_json: &str) -> String {
    todo!()
}

// ============ STRUCTURES D'ENTRÃ‰E ============

#[derive(Debug, Deserialize)]
pub struct PeriscopeInput {
    pub shodan_results: Option<Vec<ShodanHost>>,
    pub censys_results: Option<Vec<CensysCertificate>>,
    pub target_organization: String,
    pub known_assets: Option<Vec<KnownAsset>>,
}

#[derive(Debug, Deserialize)]
pub struct ShodanHost {
    pub ip: String,
    pub port: u16,
    pub transport: String, // "tcp" or "udp"
    pub banner: Option<String>,
    pub product: Option<String>,
    pub version: Option<String>,
    pub cpe: Option<Vec<String>>, // Common Platform Enumeration
    pub hostnames: Option<Vec<String>>,
    pub domains: Option<Vec<String>>,
    pub org: Option<String>,
    pub asn: Option<String>,
    pub isp: Option<String>,
    pub os: Option<String>,
    pub timestamp: String,
    pub location: Option<GeoLocation>,
    pub vulns: Option<Vec<String>>, // CVE IDs if available
    pub tags: Option<Vec<String>>,
    pub ssl: Option<SslInfo>,
    pub http: Option<HttpInfo>,
}

#[derive(Debug, Deserialize)]
pub struct GeoLocation {
    pub country_code: String,
    pub country_name: String,
    pub city: Option<String>,
    pub latitude: f64,
    pub longitude: f64,
}

#[derive(Debug, Deserialize)]
pub struct SslInfo {
    pub cert: CertificateInfo,
    pub cipher: CipherInfo,
    pub chain: Option<Vec<CertificateInfo>>,
    pub versions: Vec<String>, // ["TLSv1.2", "TLSv1.3"]
}

#[derive(Debug, Deserialize)]
pub struct CertificateInfo {
    pub subject: SubjectInfo,
    pub issuer: IssuerInfo,
    pub serial: String,
    pub fingerprint: FingerprintInfo,
    pub validity: ValidityInfo,
    pub extensions: Option<CertExtensions>,
}

#[derive(Debug, Deserialize)]
pub struct SubjectInfo {
    pub cn: Option<String>, // Common Name
    pub o: Option<String>,  // Organization
    pub ou: Option<String>, // Organizational Unit
    pub c: Option<String>,  // Country
}

#[derive(Debug, Deserialize)]
pub struct IssuerInfo {
    pub cn: Option<String>,
    pub o: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct FingerprintInfo {
    pub sha256: String,
    pub sha1: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct ValidityInfo {
    pub not_before: String,
    pub not_after: String,
}

#[derive(Debug, Deserialize)]
pub struct CertExtensions {
    pub subject_alt_names: Option<Vec<String>>, // SANs - includes subdomains!
    pub key_usage: Option<Vec<String>>,
    pub extended_key_usage: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
pub struct CipherInfo {
    pub name: String,
    pub bits: u32,
    pub version: String,
}

#[derive(Debug, Deserialize)]
pub struct HttpInfo {
    pub status: u16,
    pub title: Option<String>,
    pub server: Option<String>,
    pub headers: Option<HashMap<String, String>>,
    pub robots_hash: Option<String>,
    pub favicon_hash: Option<i64>,
}

#[derive(Debug, Deserialize)]
pub struct CensysCertificate {
    pub fingerprint_sha256: String,
    pub parsed: ParsedCertificate,
    pub hosts: Vec<String>, // IPs where this cert is seen
}

#[derive(Debug, Deserialize)]
pub struct ParsedCertificate {
    pub subject_dn: String,
    pub issuer_dn: String,
    pub validity_start: String,
    pub validity_end: String,
    pub names: Vec<String>, // All names including SANs
    pub subject_key_info: SubjectKeyInfo,
    pub signature_algorithm: String,
}

#[derive(Debug, Deserialize)]
pub struct SubjectKeyInfo {
    pub key_algorithm: String,
    pub key_size: u32,
}

#[derive(Debug, Deserialize)]
pub struct KnownAsset {
    pub asset_type: String, // "ip", "domain", "netblock"
    pub value: String,
    pub owner: String,
}

// ============ STRUCTURES DE SORTIE ============

#[derive(Debug, Serialize)]
pub struct PeriscopeOutput {
    pub infrastructure_map: InfrastructureMap,
    pub exposed_services: Vec<ExposedService>,
    pub vulnerabilities: Vec<Vulnerability>,
    pub risk_score: RiskScore,
    pub attack_surface: AttackSurface,
    pub recommendations: Vec<Recommendation>,
    pub subdomains_discovered: Vec<String>,
    pub shadow_it: Vec<ShadowAsset>,
}

#[derive(Debug, Serialize)]
pub struct InfrastructureMap {
    pub asns: Vec<AsnInfo>,
    pub netblocks: Vec<NetblockInfo>,
    pub hosts: Vec<HostInfo>,
    pub total_ips: u32,
    pub total_services: u32,
    pub geo_distribution: HashMap<String, u32>, // country -> count
}

#[derive(Debug, Serialize)]
pub struct AsnInfo {
    pub asn: String,
    pub name: Option<String>,
    pub ip_count: u32,
    pub netblocks: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct NetblockInfo {
    pub cidr: String,
    pub asn: String,
    pub ip_count: u32,
}

#[derive(Debug, Serialize)]
pub struct HostInfo {
    pub ip: String,
    pub hostnames: Vec<String>,
    pub asn: Option<String>,
    pub org: Option<String>,
    pub services: Vec<ServiceSummary>,
    pub geo: Option<GeoSummary>,
}

#[derive(Debug, Serialize)]
pub struct ServiceSummary {
    pub port: u16,
    pub transport: String,
    pub product: Option<String>,
    pub version: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct GeoSummary {
    pub country: String,
    pub city: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ExposedService {
    pub ip: String,
    pub port: u16,
    pub transport: String,
    pub service_name: String,
    pub product: Option<String>,
    pub version: Option<String>,
    pub banner_snippet: Option<String>,
    pub exposure_level: String, // "critical", "high", "medium", "low"
    pub ssl_enabled: bool,
    pub last_seen: String,
}

#[derive(Debug, Serialize)]
pub struct Vulnerability {
    pub vuln_type: String,
    pub severity: String, // "critical", "high", "medium", "low", "info"
    pub cvss_score: Option<f32>,
    pub cve_ids: Vec<String>,
    pub affected_hosts: Vec<String>,
    pub affected_service: String,
    pub description: String,
    pub remediation: String,
}

#[derive(Debug, Serialize)]
pub struct RiskScore {
    pub overall: u32, // 0-100
    pub exposure_score: u32,
    pub vulnerability_score: u32,
    pub configuration_score: u32,
    pub category: String, // "critical", "high", "medium", "low"
    pub breakdown: RiskBreakdown,
}

#[derive(Debug, Serialize)]
pub struct RiskBreakdown {
    pub critical_vulns: u32,
    pub high_vulns: u32,
    pub exposed_admin_interfaces: u32,
    pub deprecated_protocols: u32,
    pub weak_encryption: u32,
}

#[derive(Debug, Serialize)]
pub struct AttackSurface {
    pub total_ports: u32,
    pub unique_services: u32,
    pub admin_interfaces: Vec<AdminInterface>,
    pub database_ports: Vec<DatabaseExposure>,
    pub deprecated_services: Vec<DeprecatedService>,
    pub entry_points: Vec<EntryPoint>,
}

#[derive(Debug, Serialize)]
pub struct AdminInterface {
    pub ip: String,
    pub port: u16,
    pub interface_type: String, // "ssh", "rdp", "vnc", "web_admin"
    pub risk: String,
}

#[derive(Debug, Serialize)]
pub struct DatabaseExposure {
    pub ip: String,
    pub port: u16,
    pub db_type: String, // "mysql", "postgres", "mongodb", "redis"
    pub authenticated: Option<bool>,
}

#[derive(Debug, Serialize)]
pub struct DeprecatedService {
    pub ip: String,
    pub port: u16,
    pub service: String,
    pub reason: String,
}

#[derive(Debug, Serialize)]
pub struct EntryPoint {
    pub ip: String,
    pub port: u16,
    pub service: String,
    pub attack_vectors: Vec<String>,
    pub priority: u32, // 1 = highest priority
}

#[derive(Debug, Serialize)]
pub struct Recommendation {
    pub priority: u32, // 1 = highest
    pub category: String,
    pub title: String,
    pub description: String,
    pub affected_assets: Vec<String>,
    pub effort: String, // "low", "medium", "high"
    pub impact: String, // "low", "medium", "high"
}

#[derive(Debug, Serialize)]
pub struct ShadowAsset {
    pub ip: String,
    pub hostnames: Vec<String>,
    pub reason: String, // Why it's considered shadow IT
    pub confidence: f64,
}

// ============ FONCTIONS AUXILIAIRES ============

/// Parse les rÃ©sultats Shodan
pub fn parse_shodan_results(hosts: &[ShodanHost]) -> Vec<ExposedService> {
    todo!()
}

/// Extrait les sous-domaines des certificats
pub fn extract_subdomains_from_certs(
    shodan: &[ShodanHost],
    censys: &[CensysCertificate],
    target_domain: &str,
) -> Vec<String> {
    todo!()
}

/// Construit la carte d'infrastructure par ASN
pub fn build_infrastructure_map(hosts: &[ShodanHost]) -> InfrastructureMap {
    todo!()
}

/// DÃ©tecte les vulnÃ©rabilitÃ©s basÃ©es sur les versions
pub fn detect_vulnerabilities(services: &[ExposedService]) -> Vec<Vulnerability> {
    todo!()
}

/// Identifie les services critiques exposÃ©s
pub fn identify_critical_exposures(services: &[ExposedService]) -> AttackSurface {
    todo!()
}

/// Calcule le score de risque global
pub fn calculate_risk_score(
    vulns: &[Vulnerability],
    surface: &AttackSurface],
    services: &[ExposedService],
) -> RiskScore {
    todo!()
}

/// GÃ©nÃ¨re les recommandations priorisÃ©es
pub fn generate_recommendations(
    vulns: &[Vulnerability],
    surface: &AttackSurface],
) -> Vec<Recommendation> {
    todo!()
}

/// DÃ©tecte le Shadow IT (assets non dÃ©clarÃ©s)
pub fn detect_shadow_it(
    discovered: &[HostInfo],
    known: &[KnownAsset],
) -> Vec<ShadowAsset> {
    todo!()
}

/// Base de donnÃ©es des versions vulnÃ©rables
pub fn get_vulnerable_versions() -> HashMap<String, Vec<VulnerableVersion>> {
    todo!()
}

#[derive(Debug, Clone)]
pub struct VulnerableVersion {
    pub product: String,
    pub version_regex: String,
    pub severity: String,
    pub cve: Option<String>,
    pub description: String,
}

/// DÃ©termine si un port correspond Ã  un service d'administration
pub fn is_admin_port(port: u16, service: &str) -> bool {
    todo!()
}

/// DÃ©termine si un port correspond Ã  une base de donnÃ©es
pub fn is_database_port(port: u16) -> Option<String> {
    todo!()
}
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### Shodan : Le Google des Hackers

John Matherly a crÃ©Ã© Shodan en 2009. Le nom vient de System Shock (SHODAN = Sentient Hyper-Optimized Data Access Network). Aujourd'hui, Shodan indexe des millions d'appareils : webcams, routeurs, serveurs SCADA, systÃ¨mes industriels...

### La DÃ©couverte d'Heartbleed

En 2014, les chercheurs ont utilisÃ© Shodan pour identifier en quelques heures que 17% de tous les serveurs HTTPS (600,000+) Ã©taient vulnÃ©rables Ã  Heartbleed. Cette capacitÃ© de scanning Ã  l'Ã©chelle d'Internet a rÃ©volutionnÃ© la rÃ©ponse aux vulnÃ©rabilitÃ©s.

### Les Certificats SSL Comme Source OSINT

Un seul certificat SSL peut rÃ©vÃ©ler :
- Tous les sous-domaines (Subject Alternative Names)
- L'organisation propriÃ©taire
- L'infrastructure interne (noms internes dans les SANs)
- La stack technologique (autoritÃ© de certification utilisÃ©e)

---

## ğŸ“ SECTION 2.5 : DANS LA VRAIE VIE

### MÃ©tiers Utilisant Shodan/Censys

| MÃ©tier | Usage | Exemple Concret |
|--------|-------|-----------------|
| **Pentester** | Asset discovery | Trouver tous les services exposÃ©s avant un test |
| **Bug Bounty Hunter** | Surface d'attaque | DÃ©couvrir les sous-domaines cachÃ©s |
| **SOC Analyst** | Threat Intel | VÃ©rifier si une IP malveillante a d'autres services |
| **IT Security** | Shadow IT | DÃ©tecter les assets non dÃ©clarÃ©s |
| **Risk Analyst** | Exposure scoring | Ã‰valuer la posture de sÃ©curitÃ© |
| **CISO** | Reporting | Dashboard d'exposition mensuel |

### Outils ComplÃ©mentaires

- **Shodan CLI** : `shodan search "org:\"Example Corp\""`
- **Censys CLI** : `censys search "parsed.subject.organization:Example"`
- **Amass** : Ã‰numÃ©ration de sous-domaines passive
- **Subfinder** : DÃ©couverte via certificats et APIs

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
digital_periscope.rs  main.rs  Cargo.toml  shodan_results.json

$ cargo build --release

$ cargo run --release -- shodan_results.json
{
  "infrastructure_map": {
    "asns": [
      {
        "asn": "AS12345",
        "name": "Example ISP",
        "ip_count": 12,
        "netblocks": ["203.0.113.0/24"]
      }
    ],
    "total_ips": 15,
    "total_services": 42,
    ...
  },
  "exposed_services": [...],
  "vulnerabilities": [
    {
      "vuln_type": "outdated_software",
      "severity": "high",
      "cve_ids": ["CVE-2021-44228"],
      "affected_hosts": ["203.0.113.10"],
      "affected_service": "Apache Log4j 2.14.0",
      "description": "Log4Shell RCE vulnerability",
      "remediation": "Upgrade to Log4j 2.17.0+"
    }
  ],
  "risk_score": {
    "overall": 72,
    "category": "high",
    ...
  },
  "recommendations": [...]
}

$ echo "Analysis complete"
```

---

## âš¡ SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**DifficultÃ© Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**RÃ©compense :**
XP Ã—2

**Time Complexity attendue :**
O(nÂ·m) avec n hosts et m services

**Space Complexity attendue :**
O(n) pour les maps

**Domaines Bonus :**
`Net, Struct, MD (Graphes)`

### 3.1.1 Consigne Bonus

**ğŸ® "Metal Gear Solid 2" â€” GW Arsenal Analysis**

*"The digital age is the age where information itself is the weapon."* â€” The Patriots

Arsenal Gear utilise GW pour analyser les patterns globaux. Tu dois maintenant faire de mÃªme : analyser les tendances Ã  travers toute l'infrastructure.

**Ta mission Ã©tendue :**

1. **Trend Analysis** : Identifier les patterns rÃ©currents (mÃªme banner, mÃªme config)
2. **Honeypot Detection** : DÃ©tecter les honeypots (banniÃ¨res incohÃ©rentes, ports trap)
3. **Infrastructure Correlation** : Lier les assets par infrastructure partagÃ©e
4. **Historical Diff** : Si donnÃ©es historiques prÃ©sentes, montrer les changements
5. **Export Formats** : GÃ©nÃ©rer CSV, GraphML pour visualisation externe

**Contraintes Bonus :**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hosts : 1 â‰¤ n â‰¤ 10â´                    â”‚
â”‚  Services : 1 â‰¤ m â‰¤ 10âµ                 â”‚
â”‚  DÃ©tection honeypots : prÃ©cision > 80%  â”‚
â”‚  Export GraphML syntaxiquement valide   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Serialize)]
pub struct EnhancedOutput {
    pub base_output: PeriscopeOutput,
    pub trend_analysis: TrendAnalysis,
    pub honeypot_candidates: Vec<HoneypotCandidate>,
    pub infrastructure_correlation: InfraCorrelation,
    pub historical_diff: Option<HistoricalDiff>,
    pub exports: ExportFormats,
}

#[derive(Debug, Serialize)]
pub struct TrendAnalysis {
    pub common_products: Vec<(String, u32)>, // (product, count)
    pub common_versions: Vec<(String, u32)>,
    pub common_ports: Vec<(u16, u32)>,
    pub banner_clusters: Vec<BannerCluster>,
}

#[derive(Debug, Serialize)]
pub struct BannerCluster {
    pub pattern: String,
    pub hosts: Vec<String>,
    pub anomaly_score: f64,
}

#[derive(Debug, Serialize)]
pub struct HoneypotCandidate {
    pub ip: String,
    pub confidence: f64,
    pub indicators: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct InfraCorrelation {
    pub shared_ssl_certs: Vec<SharedCert>,
    pub shared_favicon: Vec<SharedFavicon>,
    pub same_server_header: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct SharedCert {
    pub fingerprint: String,
    pub hosts: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct SharedFavicon {
    pub hash: i64,
    pub hosts: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct HistoricalDiff {
    pub new_hosts: Vec<String>,
    pub removed_hosts: Vec<String>,
    pub changed_services: Vec<ServiceChange>,
}

#[derive(Debug, Serialize)]
pub struct ServiceChange {
    pub ip: String,
    pub port: u16,
    pub old_version: Option<String>,
    pub new_version: Option<String>,
    pub change_type: String,
}

#[derive(Debug, Serialize)]
pub struct ExportFormats {
    pub csv: String,
    pub graphml: String,
}

/// DÃ©tection de honeypots
pub fn detect_honeypots(hosts: &[ShodanHost]) -> Vec<HoneypotCandidate> {
    todo!()
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette (tableau des tests)

| # | Test | Input | Expected | Points |
|---|------|-------|----------|--------|
| 1 | Shodan parsing | 1 host simple | ExposedService crÃ©Ã© | 5 |
| 2 | Multi-ports | 1 host, 5 ports | 5 services | 5 |
| 3 | ASN grouping | 3 hosts mÃªme ASN | 1 ASN avec count=3 | 10 |
| 4 | Subdomain from SAN | Cert avec SANs | Subdomains extraits | 10 |
| 5 | Vuln detection SSH | OpenSSH 5.3 | HIGH vulnerability | 10 |
| 6 | Vuln detection SSL | TLSv1.0 | MEDIUM vulnerability | 5 |
| 7 | Admin interface | Port 22 SSH | AdminInterface crÃ©Ã© | 5 |
| 8 | Database exposure | Port 3306 MySQL | DatabaseExposure crÃ©Ã© | 5 |
| 9 | Risk score calc | Mix vulns | Score cohÃ©rent | 10 |
| 10 | Recommendations | Critical vuln | Priority 1 recommendation | 10 |
| 11 | Geo distribution | 3 countries | HashMap correct | 5 |
| 12 | Shadow IT | Unknown IP | ShadowAsset flagged | 10 |
| 13 | Empty input | {} | Empty but valid output | 5 |
| 14 | Telnet exposure | Port 23 | Critical exposure | 5 |
| **Total** | | | | **100** |

### 4.2 main.rs de test

```rust
use digital_periscope::*;
use serde_json::Value;

fn main() {
    let tests = vec![
        // Test 1: Shodan parsing simple
        (
            r#"{
                "shodan_results": [{
                    "ip": "1.2.3.4",
                    "port": 80,
                    "transport": "tcp",
                    "product": "nginx",
                    "version": "1.18.0",
                    "timestamp": "2026-01-10T12:00:00Z"
                }],
                "target_organization": "Test Corp"
            }"#,
            |output: &Value| {
                output["exposed_services"].as_array().map_or(false, |s| s.len() == 1)
            },
            "Shodan parsing simple"
        ),
        // Test 5: VulnÃ©rabilitÃ© SSH
        (
            r#"{
                "shodan_results": [{
                    "ip": "1.2.3.4",
                    "port": 22,
                    "transport": "tcp",
                    "product": "OpenSSH",
                    "version": "5.3",
                    "timestamp": "2026-01-10T12:00:00Z"
                }],
                "target_organization": "Test Corp"
            }"#,
            |output: &Value| {
                let vulns = output["vulnerabilities"].as_array().unwrap();
                vulns.iter().any(|v| v["severity"] == "high")
            },
            "DÃ©tection vulnÃ©rabilitÃ© SSH ancien"
        ),
        // Test 8: Database exposure
        (
            r#"{
                "shodan_results": [{
                    "ip": "10.0.0.1",
                    "port": 3306,
                    "transport": "tcp",
                    "product": "MySQL",
                    "version": "5.7.32",
                    "timestamp": "2026-01-10T12:00:00Z"
                }],
                "target_organization": "Test Corp"
            }"#,
            |output: &Value| {
                let surface = &output["attack_surface"];
                let db_ports = surface["database_ports"].as_array().unwrap();
                db_ports.iter().any(|d| d["db_type"] == "mysql")
            },
            "DÃ©tection base de donnÃ©es exposÃ©e"
        ),
        // Test 12: Shadow IT detection
        (
            r#"{
                "shodan_results": [{
                    "ip": "192.168.1.100",
                    "port": 443,
                    "transport": "tcp",
                    "product": "Apache",
                    "org": "Unknown Hosting",
                    "timestamp": "2026-01-10T12:00:00Z"
                }],
                "target_organization": "Test Corp",
                "known_assets": [
                    {"asset_type": "ip", "value": "10.0.0.0/8", "owner": "Test Corp"}
                ]
            }"#,
            |output: &Value| {
                let shadow = output["shadow_it"].as_array().unwrap();
                shadow.len() > 0
            },
            "DÃ©tection Shadow IT"
        ),
    ];

    let mut passed = 0;
    for (input, check, name) in &tests {
        let output_str = digital_periscope(input);
        match serde_json::from_str::<Value>(&output_str) {
            Ok(output) => {
                if check(&output) {
                    println!("âœ… {}", name);
                    passed += 1;
                } else {
                    println!("âŒ {} - Check failed", name);
                }
            }
            Err(e) => println!("âŒ {} - Parse error: {}", name, e),
        }
    }
    println!("\n{}/{} tests passed", passed, tests.len());
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use serde_json;
use std::collections::{HashMap, HashSet};
use regex::Regex;

pub fn digital_periscope(input_json: &str) -> String {
    let input: PeriscopeInput = match serde_json::from_str(input_json) {
        Ok(i) => i,
        Err(_) => return serde_json::to_string(&create_empty_output()).unwrap(),
    };

    // Parse Shodan results
    let shodan_hosts = input.shodan_results.unwrap_or_default();
    let censys_certs = input.censys_results.unwrap_or_default();
    let known_assets = input.known_assets.unwrap_or_default();

    // Extract exposed services
    let exposed_services = parse_shodan_results(&shodan_hosts);

    // Build infrastructure map
    let infrastructure_map = build_infrastructure_map(&shodan_hosts);

    // Extract subdomains from certificates
    let target_domain = extract_domain_from_org(&input.target_organization);
    let subdomains = extract_subdomains_from_certs(&shodan_hosts, &censys_certs, &target_domain);

    // Detect vulnerabilities
    let vulnerabilities = detect_vulnerabilities(&exposed_services);

    // Identify attack surface
    let attack_surface = identify_critical_exposures(&exposed_services);

    // Calculate risk score
    let risk_score = calculate_risk_score(&vulnerabilities, &attack_surface, &exposed_services);

    // Generate recommendations
    let recommendations = generate_recommendations(&vulnerabilities, &attack_surface);

    // Detect shadow IT
    let hosts: Vec<HostInfo> = shodan_hosts.iter().map(|h| {
        HostInfo {
            ip: h.ip.clone(),
            hostnames: h.hostnames.clone().unwrap_or_default(),
            asn: h.asn.clone(),
            org: h.org.clone(),
            services: vec![],
            geo: h.location.as_ref().map(|l| GeoSummary {
                country: l.country_code.clone(),
                city: l.city.clone(),
            }),
        }
    }).collect();
    let shadow_it = detect_shadow_it(&hosts, &known_assets);

    let output = PeriscopeOutput {
        infrastructure_map,
        exposed_services,
        vulnerabilities,
        risk_score,
        attack_surface,
        recommendations,
        subdomains_discovered: subdomains,
        shadow_it,
    };

    serde_json::to_string_pretty(&output).unwrap_or_else(|_| "{}".to_string())
}

fn parse_shodan_results(hosts: &[ShodanHost]) -> Vec<ExposedService> {
    hosts.iter().map(|h| {
        let exposure_level = determine_exposure_level(h.port, h.product.as_deref());
        let ssl_enabled = h.ssl.is_some();

        ExposedService {
            ip: h.ip.clone(),
            port: h.port,
            transport: h.transport.clone(),
            service_name: infer_service_name(h.port, h.product.as_deref()),
            product: h.product.clone(),
            version: h.version.clone(),
            banner_snippet: h.banner.as_ref().map(|b| truncate_banner(b, 100)),
            exposure_level,
            ssl_enabled,
            last_seen: h.timestamp.clone(),
        }
    }).collect()
}

fn determine_exposure_level(port: u16, product: Option<&str>) -> String {
    // Critical: Telnet, unauth databases, admin without SSL
    if port == 23 { return "critical".to_string(); }
    if matches!(port, 27017 | 6379 | 9200) { return "critical".to_string(); } // MongoDB, Redis, Elastic

    // High: SSH, RDP, databases
    if matches!(port, 22 | 3389 | 3306 | 5432) { return "high".to_string(); }

    // Medium: Web admin, FTP
    if matches!(port, 21 | 8080 | 8443 | 9090) { return "medium".to_string(); }

    // Low: Standard web
    "low".to_string()
}

fn infer_service_name(port: u16, product: Option<&str>) -> String {
    if let Some(p) = product {
        return p.to_string();
    }
    match port {
        21 => "FTP",
        22 => "SSH",
        23 => "Telnet",
        25 => "SMTP",
        53 => "DNS",
        80 => "HTTP",
        110 => "POP3",
        143 => "IMAP",
        443 => "HTTPS",
        3306 => "MySQL",
        3389 => "RDP",
        5432 => "PostgreSQL",
        6379 => "Redis",
        27017 => "MongoDB",
        _ => "Unknown",
    }.to_string()
}

fn truncate_banner(banner: &str, max_len: usize) -> String {
    if banner.len() <= max_len {
        banner.to_string()
    } else {
        format!("{}...", &banner[..max_len])
    }
}

fn build_infrastructure_map(hosts: &[ShodanHost]) -> InfrastructureMap {
    let mut asn_map: HashMap<String, (Option<String>, HashSet<String>)> = HashMap::new();
    let mut geo_dist: HashMap<String, u32> = HashMap::new();

    for host in hosts {
        if let Some(asn) = &host.asn {
            let entry = asn_map.entry(asn.clone()).or_insert((host.isp.clone(), HashSet::new()));
            entry.1.insert(host.ip.clone());
        }

        if let Some(loc) = &host.location {
            *geo_dist.entry(loc.country_code.clone()).or_insert(0) += 1;
        }
    }

    let asns: Vec<AsnInfo> = asn_map.into_iter().map(|(asn, (name, ips))| {
        AsnInfo {
            asn,
            name,
            ip_count: ips.len() as u32,
            netblocks: vec![], // Simplified
        }
    }).collect();

    let unique_ips: HashSet<_> = hosts.iter().map(|h| &h.ip).collect();

    InfrastructureMap {
        asns,
        netblocks: vec![],
        hosts: vec![],
        total_ips: unique_ips.len() as u32,
        total_services: hosts.len() as u32,
        geo_distribution: geo_dist,
    }
}

fn extract_subdomains_from_certs(
    shodan: &[ShodanHost],
    censys: &[CensysCertificate],
    target_domain: &str,
) -> Vec<String> {
    let mut subdomains: HashSet<String> = HashSet::new();

    // From Shodan SSL certs
    for host in shodan {
        if let Some(ssl) = &host.ssl {
            if let Some(exts) = &ssl.cert.extensions {
                if let Some(sans) = &exts.subject_alt_names {
                    for san in sans {
                        if san.ends_with(target_domain) || san == target_domain {
                            subdomains.insert(san.clone());
                        }
                    }
                }
            }
            // Also check CN
            if let Some(cn) = &ssl.cert.subject.cn {
                if cn.ends_with(target_domain) || cn == target_domain {
                    subdomains.insert(cn.clone());
                }
            }
        }
    }

    // From Censys certificates
    for cert in censys {
        for name in &cert.parsed.names {
            if name.ends_with(target_domain) || name == target_domain {
                subdomains.insert(name.clone());
            }
        }
    }

    let mut result: Vec<_> = subdomains.into_iter().collect();
    result.sort();
    result
}

fn detect_vulnerabilities(services: &[ExposedService]) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();
    let vuln_db = get_vulnerable_versions();

    for service in services {
        // Check version-based vulnerabilities
        if let (Some(product), Some(version)) = (&service.product, &service.version) {
            let product_lower = product.to_lowercase();

            // OpenSSH vulnerabilities
            if product_lower.contains("openssh") {
                if let Some(major) = extract_major_version(version) {
                    if major < 7 {
                        vulns.push(Vulnerability {
                            vuln_type: "outdated_software".to_string(),
                            severity: "high".to_string(),
                            cvss_score: Some(7.5),
                            cve_ids: vec!["CVE-2016-10012".to_string()],
                            affected_hosts: vec![service.ip.clone()],
                            affected_service: format!("{} {}", product, version),
                            description: "OpenSSH version vulnerable to multiple CVEs".to_string(),
                            remediation: "Upgrade to OpenSSH 8.x or later".to_string(),
                        });
                    }
                }
            }

            // Apache vulnerabilities
            if product_lower.contains("apache") && version.starts_with("2.2") {
                vulns.push(Vulnerability {
                    vuln_type: "outdated_software".to_string(),
                    severity: "medium".to_string(),
                    cvss_score: Some(5.0),
                    cve_ids: vec![],
                    affected_hosts: vec![service.ip.clone()],
                    affected_service: format!("{} {}", product, version),
                    description: "Apache 2.2.x is end-of-life".to_string(),
                    remediation: "Upgrade to Apache 2.4.x".to_string(),
                });
            }
        }

        // Protocol-based vulnerabilities
        if service.port == 23 {
            vulns.push(Vulnerability {
                vuln_type: "insecure_protocol".to_string(),
                severity: "critical".to_string(),
                cvss_score: Some(9.0),
                cve_ids: vec![],
                affected_hosts: vec![service.ip.clone()],
                affected_service: "Telnet".to_string(),
                description: "Telnet transmits credentials in cleartext".to_string(),
                remediation: "Disable Telnet, use SSH instead".to_string(),
            });
        }

        // Exposed databases without auth
        if matches!(service.port, 27017 | 6379 | 9200) {
            vulns.push(Vulnerability {
                vuln_type: "exposed_database".to_string(),
                severity: "critical".to_string(),
                cvss_score: Some(9.8),
                cve_ids: vec![],
                affected_hosts: vec![service.ip.clone()],
                affected_service: service.service_name.clone(),
                description: format!("{} exposed to internet without authentication", service.service_name),
                remediation: "Block external access, enable authentication".to_string(),
            });
        }
    }

    vulns
}

fn extract_major_version(version: &str) -> Option<u32> {
    version.split('.').next()?.parse().ok()
}

fn identify_critical_exposures(services: &[ExposedService]) -> AttackSurface {
    let mut admin_interfaces = Vec::new();
    let mut database_ports = Vec::new();
    let mut deprecated_services = Vec::new();
    let mut entry_points = Vec::new();

    let unique_services: HashSet<_> = services.iter().map(|s| &s.service_name).collect();

    for service in services {
        // Admin interfaces
        if is_admin_port(service.port, &service.service_name) {
            admin_interfaces.push(AdminInterface {
                ip: service.ip.clone(),
                port: service.port,
                interface_type: match service.port {
                    22 => "ssh",
                    3389 => "rdp",
                    5900..=5999 => "vnc",
                    _ => "web_admin",
                }.to_string(),
                risk: service.exposure_level.clone(),
            });
        }

        // Database exposures
        if let Some(db_type) = is_database_port(service.port) {
            database_ports.push(DatabaseExposure {
                ip: service.ip.clone(),
                port: service.port,
                db_type,
                authenticated: None,
            });
        }

        // Deprecated services
        if service.port == 23 {
            deprecated_services.push(DeprecatedService {
                ip: service.ip.clone(),
                port: service.port,
                service: "Telnet".to_string(),
                reason: "Cleartext protocol, replaced by SSH".to_string(),
            });
        }

        if service.port == 21 {
            deprecated_services.push(DeprecatedService {
                ip: service.ip.clone(),
                port: service.port,
                service: "FTP".to_string(),
                reason: "Cleartext protocol, use SFTP instead".to_string(),
            });
        }

        // Entry points for attacks
        let attack_vectors = match service.port {
            22 => vec!["Brute force", "Key-based auth bypass"],
            80 | 443 => vec!["Web vulnerabilities", "Path traversal"],
            3306 | 5432 => vec!["SQL injection", "Credential stuffing"],
            _ => vec![],
        };

        if !attack_vectors.is_empty() {
            entry_points.push(EntryPoint {
                ip: service.ip.clone(),
                port: service.port,
                service: service.service_name.clone(),
                attack_vectors: attack_vectors.into_iter().map(String::from).collect(),
                priority: match service.exposure_level.as_str() {
                    "critical" => 1,
                    "high" => 2,
                    "medium" => 3,
                    _ => 4,
                },
            });
        }
    }

    AttackSurface {
        total_ports: services.len() as u32,
        unique_services: unique_services.len() as u32,
        admin_interfaces,
        database_ports,
        deprecated_services,
        entry_points,
    }
}

fn calculate_risk_score(
    vulns: &[Vulnerability],
    surface: &AttackSurface,
    services: &[ExposedService],
) -> RiskScore {
    let critical_vulns = vulns.iter().filter(|v| v.severity == "critical").count() as u32;
    let high_vulns = vulns.iter().filter(|v| v.severity == "high").count() as u32;

    // Vulnerability score (0-40)
    let vuln_score = (critical_vulns * 15 + high_vulns * 8).min(40);

    // Exposure score (0-30)
    let exposure_score = (surface.admin_interfaces.len() * 5 +
                         surface.database_ports.len() * 8 +
                         surface.deprecated_services.len() * 10).min(30) as u32;

    // Configuration score (0-30)
    let weak_encryption = services.iter().filter(|s| !s.ssl_enabled && s.port == 443).count();
    let config_score = (weak_encryption * 10).min(30) as u32;

    let overall = vuln_score + exposure_score + config_score;

    let category = match overall {
        0..=25 => "low",
        26..=50 => "medium",
        51..=75 => "high",
        _ => "critical",
    }.to_string();

    RiskScore {
        overall,
        exposure_score,
        vulnerability_score: vuln_score,
        configuration_score: config_score,
        category,
        breakdown: RiskBreakdown {
            critical_vulns,
            high_vulns,
            exposed_admin_interfaces: surface.admin_interfaces.len() as u32,
            deprecated_protocols: surface.deprecated_services.len() as u32,
            weak_encryption: weak_encryption as u32,
        },
    }
}

fn generate_recommendations(vulns: &[Vulnerability], surface: &AttackSurface) -> Vec<Recommendation> {
    let mut recommendations = Vec::new();
    let mut priority = 1;

    // Critical vulnerabilities first
    for vuln in vulns.iter().filter(|v| v.severity == "critical") {
        recommendations.push(Recommendation {
            priority,
            category: "vulnerability".to_string(),
            title: format!("Fix critical vulnerability: {}", vuln.vuln_type),
            description: vuln.description.clone(),
            affected_assets: vuln.affected_hosts.clone(),
            effort: "high".to_string(),
            impact: "high".to_string(),
        });
        priority += 1;
    }

    // Deprecated services
    for deprecated in &surface.deprecated_services {
        recommendations.push(Recommendation {
            priority,
            category: "deprecated_protocol".to_string(),
            title: format!("Disable deprecated service: {}", deprecated.service),
            description: deprecated.reason.clone(),
            affected_assets: vec![deprecated.ip.clone()],
            effort: "low".to_string(),
            impact: "high".to_string(),
        });
        priority += 1;
    }

    // Exposed databases
    for db in &surface.database_ports {
        recommendations.push(Recommendation {
            priority,
            category: "exposure".to_string(),
            title: format!("Restrict {} database access", db.db_type),
            description: "Database should not be directly accessible from internet".to_string(),
            affected_assets: vec![db.ip.clone()],
            effort: "medium".to_string(),
            impact: "high".to_string(),
        });
        priority += 1;
    }

    recommendations
}

fn detect_shadow_it(discovered: &[HostInfo], known: &[KnownAsset]) -> Vec<ShadowAsset> {
    let mut shadow = Vec::new();

    let known_ips: HashSet<_> = known.iter()
        .filter(|a| a.asset_type == "ip")
        .map(|a| &a.value)
        .collect();

    for host in discovered {
        let ip_known = known_ips.contains(&host.ip);
        let org_matches = known.iter().any(|a| {
            host.org.as_ref().map_or(false, |o| o.contains(&a.owner))
        });

        if !ip_known && !org_matches {
            shadow.push(ShadowAsset {
                ip: host.ip.clone(),
                hostnames: host.hostnames.clone(),
                reason: "IP not in known assets, organization mismatch".to_string(),
                confidence: 0.7,
            });
        }
    }

    shadow
}

fn is_admin_port(port: u16, service: &str) -> bool {
    matches!(port, 22 | 23 | 3389 | 5900..=5999 | 8080 | 8443 | 9090 | 10000)
}

fn is_database_port(port: u16) -> Option<String> {
    match port {
        3306 => Some("mysql".to_string()),
        5432 => Some("postgresql".to_string()),
        27017 => Some("mongodb".to_string()),
        6379 => Some("redis".to_string()),
        9200 => Some("elasticsearch".to_string()),
        1433 => Some("mssql".to_string()),
        1521 => Some("oracle".to_string()),
        _ => None,
    }
}

fn extract_domain_from_org(org: &str) -> String {
    org.to_lowercase()
        .replace(" corp", ".com")
        .replace(" inc", ".com")
        .replace(" ", "")
}

fn create_empty_output() -> PeriscopeOutput {
    PeriscopeOutput {
        infrastructure_map: InfrastructureMap {
            asns: vec![],
            netblocks: vec![],
            hosts: vec![],
            total_ips: 0,
            total_services: 0,
            geo_distribution: HashMap::new(),
        },
        exposed_services: vec![],
        vulnerabilities: vec![],
        risk_score: RiskScore {
            overall: 0,
            exposure_score: 0,
            vulnerability_score: 0,
            configuration_score: 0,
            category: "low".to_string(),
            breakdown: RiskBreakdown {
                critical_vulns: 0,
                high_vulns: 0,
                exposed_admin_interfaces: 0,
                deprecated_protocols: 0,
                weak_encryption: 0,
            },
        },
        attack_surface: AttackSurface {
            total_ports: 0,
            unique_services: 0,
            admin_interfaces: vec![],
            database_ports: vec![],
            deprecated_services: vec![],
            entry_points: vec![],
        },
        recommendations: vec![],
        subdomains_discovered: vec![],
        shadow_it: vec![],
    }
}

fn get_vulnerable_versions() -> HashMap<String, Vec<VulnerableVersion>> {
    let mut db = HashMap::new();

    db.insert("openssh".to_string(), vec![
        VulnerableVersion {
            product: "OpenSSH".to_string(),
            version_regex: r"^[1-6]\.".to_string(),
            severity: "high".to_string(),
            cve: Some("CVE-2016-10012".to_string()),
            description: "OpenSSH < 7.0 multiple vulnerabilities".to_string(),
        },
    ]);

    db.insert("apache".to_string(), vec![
        VulnerableVersion {
            product: "Apache".to_string(),
            version_regex: r"^2\.2\.".to_string(),
            severity: "medium".to_string(),
            cve: None,
            description: "Apache 2.2.x end-of-life".to_string(),
        },
    ]);

    db
}
```

### 4.10 Solutions Mutantes (minimum 5)

```rust
/* Mutant A (Boundary) : Port database mal dÃ©tectÃ© */
fn is_database_port_mutant_a(port: u16) -> Option<String> {
    match port {
        3306 => Some("mysql".to_string()),
        // Bug: Manque PostgreSQL 5432
        27017 => Some("mongodb".to_string()),
        _ => None,
    }
}
// Pourquoi c'est faux : PostgreSQL (5432) non dÃ©tectÃ©
// Ce qui Ã©tait pensÃ© : "Les ports communs suffisent"

/* Mutant B (Safety) : Version parsing crash */
fn extract_major_version_mutant_b(version: &str) -> Option<u32> {
    version.split('.').next().unwrap().parse().ok() // PANIC sur empty string!
}
// Pourquoi c'est faux : unwrap() sur Option peut panic
// Ce qui Ã©tait pensÃ© : "Il y aura toujours au moins un Ã©lÃ©ment"

/* Mutant C (Logic) : Risk score inversÃ© */
fn calculate_risk_score_mutant_c(...) -> RiskScore {
    // Bug: Plus de vulns = score plus bas (inversÃ©)
    let overall = 100 - (vuln_score + exposure_score);
    // ...
}
// Pourquoi c'est faux : Haut risque â†’ bas score (illogique)
// Ce qui Ã©tait pensÃ© : Erreur de signe

/* Mutant D (Return) : Toujours "low" exposure */
fn determine_exposure_level_mutant_d(port: u16, _product: Option<&str>) -> String {
    "low".to_string() // Bug: Ignore le port
}
// Pourquoi c'est faux : Telnet port 23 marquÃ© "low"
// Ce qui Ã©tait pensÃ© : Simplification

/* Mutant E (Resource) : Pas de dÃ©duplication subdomains */
fn extract_subdomains_from_certs_mutant_e(...) -> Vec<String> {
    let mut subdomains = Vec::new(); // Bug: Vec au lieu de HashSet
    // Duplicates possibles
    subdomains
}
// Pourquoi c'est faux : Subdomains dupliquÃ©s dans la sortie
// Ce qui Ã©tait pensÃ© : "Vec est plus simple"

/* Mutant F (Correlation) : Shadow IT jamais dÃ©tectÃ© */
fn detect_shadow_it_mutant_f(discovered: &[HostInfo], _known: &[KnownAsset]) -> Vec<ShadowAsset> {
    vec![] // Bug: Retourne toujours vide
}
// Pourquoi c'est faux : Ne dÃ©tecte jamais le shadow IT
// Ce qui Ã©tait pensÃ© : "ImplÃ©mentation plus tard"
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Shodan/Censys API** : Structure des donnÃ©es de scan Internet
2. **Service Fingerprinting** : Identification des services par port/banniÃ¨re
3. **Version Vulnerability Mapping** : CorrÃ©lation versions â†” CVEs
4. **ASN/Netblock Analysis** : Groupement d'infrastructure
5. **Certificate Analysis** : Extraction d'informations depuis les certificats SSL
6. **Risk Scoring** : Calcul de score de risque multicritÃ¨res
7. **Shadow IT Detection** : Identification d'assets non dÃ©clarÃ©s

### 5.2 LDA â€” Traduction littÃ©rale en franÃ§ais (MAJUSCULES)

```
FONCTION digital_periscope QUI RETOURNE UNE CHAÃNE ET PREND EN PARAMÃˆTRE input_json
DÃ‰BUT FONCTION
    DÃ‰CLARER input COMME RÃ‰SULTAT DU PARSING JSON
    SI LE PARSING Ã‰CHOUE ALORS
        RETOURNER UN OUTPUT VIDE
    FIN SI

    DÃ‰CLARER shodan_hosts COMME LA LISTE DES RÃ‰SULTATS SHODAN
    DÃ‰CLARER censys_certs COMME LA LISTE DES CERTIFICATS CENSYS

    POUR CHAQUE host DANS shodan_hosts FAIRE
        CRÃ‰ER un ExposedService avec port, produit, version
        DÃ‰TERMINER le niveau d'exposition selon le port
        AJOUTER Ã  la liste des services exposÃ©s
    FIN POUR

    CONSTRUIRE la carte d'infrastructure par ASN
    EXTRAIRE les sous-domaines des certificats SSL
    DÃ‰TECTER les vulnÃ©rabilitÃ©s selon les versions
    IDENTIFIER la surface d'attaque
    CALCULER le score de risque global
    GÃ‰NÃ‰RER les recommandations priorisÃ©es
    DÃ‰TECTER le Shadow IT

    RETOURNER L'OUTPUT JSON STRUCTURÃ‰
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
SHODAN/CENSYS DATA FLOW
=======================

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  SHODAN SCAN    â”‚       â”‚  CENSYS SCAN    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚ IP:Port   â”‚  â”‚       â”‚  â”‚ SSL Cert  â”‚  â”‚
    â”‚  â”‚ Banner    â”‚  â”‚       â”‚  â”‚ SANs      â”‚  â”‚
    â”‚  â”‚ Version   â”‚  â”‚       â”‚  â”‚ Issuer    â”‚  â”‚
    â”‚  â”‚ ASN/Org   â”‚  â”‚       â”‚  â”‚ Validity  â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                          â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           DIGITAL PERISCOPE ENGINE          â”‚
    â”‚                                             â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
    â”‚  â”‚   Parser    â”‚â”€â”€â”€â–¶â”‚ Normalizer  â”‚        â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
    â”‚                            â”‚               â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  â”‚                         â–¼               â”‚
    â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚  â”‚        ANALYSIS MODULES          â”‚   â”‚
    â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
    â”‚  â”‚  â”‚  Vuln    â”‚ Infra    â”‚  Surface   â”‚   â”‚
    â”‚  â”‚  â”‚ Detector â”‚ Mapper   â”‚  Analyzer  â”‚   â”‚
    â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚  â”‚                                          â”‚
    â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚  â”‚        CORRELATION ENGINE         â”‚   â”‚
    â”‚  â”‚  â”‚  ASN â†’ Netblock â†’ IP â†’ Service   â”‚   â”‚
    â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              OUTPUT GENERATOR               â”‚
    â”‚                                             â”‚
    â”‚  â€¢ Infrastructure Map                       â”‚
    â”‚  â€¢ Vulnerabilities (CVEs)                   â”‚
    â”‚  â€¢ Risk Score (0-100)                       â”‚
    â”‚  â€¢ Recommendations                          â”‚
    â”‚  â€¢ Shadow IT Alerts                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


INFRASTRUCTURE HIERARCHY
========================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ASN                                 â”‚
â”‚                      AS12345                                â”‚
â”‚            "Example Internet Provider"                      â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    Netblock 1      â”‚    â”‚    Netblock 2      â”‚          â”‚
â”‚  â”‚  203.0.113.0/24    â”‚    â”‚  198.51.100.0/24   â”‚          â”‚
â”‚  â”‚                    â”‚    â”‚                    â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”    â”‚    â”‚  â”Œâ”€â”€â”€â”€â”            â”‚          â”‚
â”‚  â”‚  â”‚.10 â”‚ â”‚.20 â”‚    â”‚    â”‚  â”‚.50 â”‚            â”‚          â”‚
â”‚  â”‚  â””â”€â”¬â”€â”€â”˜ â””â”€â”¬â”€â”€â”˜    â”‚    â”‚  â””â”€â”¬â”€â”€â”˜            â”‚          â”‚
â”‚  â”‚    â”‚      â”‚       â”‚    â”‚    â”‚               â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚       â”‚      â”‚                  â”‚                          â”‚
â”‚       â–¼      â–¼                  â–¼                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    SERVICES                         â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  .10:22 SSH      .20:443 HTTPS    .50:3306 MySQL   â”‚   â”‚
â”‚  â”‚  .10:80 HTTP     .20:22  SSH                        â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


RISK SCORE CALCULATION
======================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RISK SCORE: 72/100                      â”‚
â”‚                    Category: HIGH                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  Vulnerability Score (40 max):                             â”‚
â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  28/40            â”‚
â”‚  â€¢ 2 Critical vulnerabilities (2Ã—15 = 30, capped)          â”‚
â”‚  â€¢ 1 High vulnerability (1Ã—8 = 8)                          â”‚
â”‚                                                            â”‚
â”‚  Exposure Score (30 max):                                  â”‚
â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  22/30            â”‚
â”‚  â€¢ 3 Admin interfaces (3Ã—5 = 15)                           â”‚
â”‚  â€¢ 1 Exposed database (1Ã—8 = 8, capped)                    â”‚
â”‚                                                            â”‚
â”‚  Configuration Score (30 max):                             â”‚
â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘  22/30            â”‚
â”‚  â€¢ 2 Services without TLS (2Ã—10 = 20)                      â”‚
â”‚  â€¢ 1 Deprecated protocol (1Ã—10 = 10, capped)               â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **Version parsing** | "1.2.3-beta" crash le parser | Regex robuste, gestion erreurs |
| **ASN sans nom** | ASN existe mais pas de nom | Option<String> pour name |
| **Port non-standard** | MySQL sur 3307 | Combiner port + banner |
| **Cert wildcard** | *.example.com â†’ infini | Ne pas expand, garder wildcard |
| **MÃªme IP multi-ASN** | Rare mais possible | HashSet<ASN> par IP |
| **Shadow IT false positive** | Cloud provider diffÃ©rent | VÃ©rifier org match |

### 5.5 Cours Complet

#### 5.5.1 Introduction Ã  Shodan

Shodan scanne Internet en continu et indexe les banniÃ¨res de services. Une banniÃ¨re est la rÃ©ponse initiale d'un service (ex: "SSH-2.0-OpenSSH_8.2").

**DonnÃ©es Shodan par host :**
- IP, port, protocole
- BanniÃ¨re complÃ¨te
- Produit et version (si dÃ©tectable)
- Organisation et ASN
- GÃ©olocalisation
- Certificats SSL
- VulnÃ©rabilitÃ©s connues (tags)

**Queries Shodan courantes :**
```
org:"Example Corp"           # Par organisation
port:22 product:OpenSSH      # SSH servers
ssl.cert.subject.cn:*.example.com  # Wildcard certs
vuln:CVE-2021-44228          # Log4Shell
```

#### 5.5.2 Censys et les Certificats

Censys se concentre sur les certificats SSL et la configuration TLS. Les certificats rÃ©vÃ¨lent :

**Subject Alternative Names (SANs)** : Liste TOUS les domaines couverts
```
DNS:www.example.com
DNS:api.example.com
DNS:admin.internal.example.com  â† Information interne !
```

**Informations Organisation** :
- O (Organization)
- OU (Organizational Unit)
- L (Locality), ST (State), C (Country)

#### 5.5.3 ASN et Infrastructure

Un **ASN** (Autonomous System Number) identifie un rÃ©seau sur Internet. Exemples :
- AS15169 : Google
- AS13335 : Cloudflare
- AS16509 : Amazon

**Netblock** : Plage d'IPs appartenant Ã  un ASN
```
AS12345 possÃ¨de :
  203.0.113.0/24 (256 IPs)
  198.51.100.0/25 (128 IPs)
```

#### 5.5.4 DÃ©tection de VulnÃ©rabilitÃ©s

La dÃ©tection se fait par :
1. **Version matching** : OpenSSH 5.x â†’ CVE-XXXX
2. **Banner analysis** : Patterns connus de services vulnÃ©rables
3. **Configuration** : TLS 1.0 â†’ Deprecated
4. **Exposure** : Telnet ouvert â†’ Critique

**Base de versions vulnÃ©rables :**
```
Product     | Vulnerable  | Severity | CVE
------------|-------------|----------|-------------
OpenSSH     | < 7.0       | HIGH     | CVE-2016-10012
Apache      | 2.2.x       | MEDIUM   | EOL
Log4j       | 2.0-2.14.1  | CRITICAL | CVE-2021-44228
```

### 5.6 Normes avec explications pÃ©dagogiques

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if port == 22 || port == 3389 || port == 5900 { ... }          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if matches!(port, 22 | 3389 | 5900..=5999) { ... }             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ matches! est plus lisible pour les patterns multiples         â”‚
â”‚ â€¢ Supporte les ranges (5900..=5999) nativement                 â”‚
â”‚ â€¢ Idiomatique Rust                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**Input :**
```json
{
  "shodan_results": [
    {"ip": "1.2.3.4", "port": 22, "product": "OpenSSH", "version": "5.3", "asn": "AS12345"},
    {"ip": "1.2.3.4", "port": 80, "product": "nginx", "version": "1.18.0", "asn": "AS12345"},
    {"ip": "5.6.7.8", "port": 3306, "product": "MySQL", "version": "5.7", "asn": "AS12345"}
  ],
  "target_organization": "Test Corp"
}
```

**Trace :**

| Ã‰tape | Action | RÃ©sultat |
|-------|--------|----------|
| 1 | Parse JSON | 3 hosts extraits |
| 2 | Parse host 1 (SSH) | ExposedService: HIGH exposure |
| 3 | Parse host 2 (HTTP) | ExposedService: LOW exposure |
| 4 | Parse host 3 (MySQL) | ExposedService: CRITICAL exposure |
| 5 | Build infra map | 1 ASN (AS12345), 2 unique IPs |
| 6 | Detect vulns SSH 5.3 | Vulnerability HIGH crÃ©Ã©e |
| 7 | Detect vulns MySQL exposed | Vulnerability CRITICAL crÃ©Ã©e |
| 8 | Identify attack surface | 1 admin (SSH), 1 database |
| 9 | Calculate risk | 72/100 (HIGH) |
| 10 | Generate recommendations | 3 recommendations |

### 5.8 MnÃ©motechniques (MEME obligatoire)

#### ğŸ® MEME : "Metal Gear Solid â€” Tactical Espionage"

Dans MGS, Snake utilise le **Soliton Radar** pour voir les ennemis. Shodan est ton radar pour voir tous les serveurs exposÃ©s sur Internet.

```rust
// Comme le Soliton Radar de Snake
let exposure = match service.port {
    22 => "ğŸŸ¡ SSH dÃ©tectÃ© - Garde en vue",
    23 => "ğŸ”´ TELNET - ALERTE ROUGE!",
    443 => "ğŸŸ¢ HTTPS - Zone sÃ©curisÃ©e",
    3306 => "ğŸ”´ MySQL exposÃ© - DANGER!",
    _ => "âšª Signal inconnu",
};
```

#### ğŸ•µï¸ MEME : "The Matrix â€” Seeing the Code"

*"I don't even see the code anymore. I just see blonde, brunette, redhead..."*

AprÃ¨s suffisamment de practice, tu ne verras plus les banniÃ¨res brutes :
```
SSH-2.0-OpenSSH_5.3 â†’ "VulnÃ©rable, ancien, Ã  patcher"
220 ProFTPD 1.3.3c â†’ "FTP ? En 2026 ? Shadow IT probable"
```

### 5.9 Applications pratiques

1. **Asset Discovery** : Trouver tous les assets exposÃ©s d'une organisation
2. **Vulnerability Assessment** : Identifier les versions vulnÃ©rables avant un pentest
3. **Compliance Check** : VÃ©rifier que les politiques de sÃ©curitÃ© sont respectÃ©es
4. **Incident Response** : Identifier l'Ã©tendue d'une compromission
5. **M&A Due Diligence** : Ã‰valuer la posture de sÃ©curitÃ© d'une acquisition
6. **Bug Bounty** : DÃ©couvrir la surface d'attaque d'une cible

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | Impact | DÃ©tection |
|---|-------|--------|-----------|
| 1 | Version parsing empty | Panic | Check empty string |
| 2 | Port non-standard DB | Miss detection | Combine port + banner |
| 3 | Wildcard cert expand | Infinite loop | Keep as-is |
| 4 | ASN null | Crash | Option<String> |
| 5 | Duplicate subdomains | Wrong count | HashSet dedup |
| 6 | Shadow IT false positive | Wrong alerts | Check org match |

---

## ğŸ“ SECTION 7 : QCM

**Q1:** Quel service Shodan identifie principalement ?
A) Contenu web  B) BanniÃ¨res de services âœ“  C) Emails  D) DNS records

**Q2:** OÃ¹ trouve-t-on les sous-domaines dans un certificat SSL ?
A) Subject CN seulement  B) Issuer  C) Subject Alternative Names (SANs) âœ“  D) Serial number

**Q3:** Quel port indique gÃ©nÃ©ralement une base de donnÃ©es MongoDB ?
A) 3306  B) 5432  C) 27017 âœ“  D) 6379

**Q4:** Qu'est-ce qu'un ASN ?
A) Type de certificat  B) NumÃ©ro identifiant un rÃ©seau autonome âœ“  C) Port de scan  D) Version TLS

**Q5:** Pourquoi Telnet (port 23) est-il considÃ©rÃ© critique ?
A) Trop lent  B) Transmet en clair âœ“  C) Port rÃ©servÃ©  D) VulnÃ©rable par dÃ©faut

**Q6:** Comment dÃ©tecter du Shadow IT ?
A) Scanner tous les ports  B) Comparer discovered vs known assets âœ“  C) Analyser les banniÃ¨res  D) VÃ©rifier les certificats

**Q7:** Quel score de risque correspond Ã  "critical" ?
A) 0-25  B) 26-50  C) 51-75  D) 76-100 âœ“

**Q8:** Qu'est-ce que le favicon hash dans Shodan ?
A) Hash du certificat  B) Hash de l'icÃ´ne du site âœ“  C) Hash de la banniÃ¨re  D) Hash de l'IP

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| Exercice | 3.2.1-b : digital_periscope |
| Module | 3.2.1 â€” Reconnaissance & OSINT |
| Concepts | Shodan, Censys, ASN, Subdomain enum, Infrastructure mapping |
| DifficultÃ© | 7/10 |
| Langage | Rust Edition 2024 |
| XP Base | 450 |
| XP Bonus | Ã—2 (900 XP) |
| DurÃ©e | 4-5 heures |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.2.1-b-digital_periscope",
    "generated_at": "2026-01-11 00:00:00",

    "metadata": {
      "exercise_id": "3.2.1-b",
      "exercise_name": "digital_periscope",
      "module": "3.2.1",
      "module_name": "Reconnaissance & OSINT",
      "concept": "b",
      "concept_name": "Search Engine Intelligence",
      "type": "complet",
      "tier": 2,
      "tier_info": "MÃ©lange (concepts d + e + i + j)",
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜†",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 270,
      "xp_base": 450,
      "xp_bonus_multiplier": 2,
      "bonus_tier": "STANDARD",
      "bonus_icon": "âš¡",
      "complexity_time": "T3 O(nÂ·m)",
      "complexity_space": "S3 O(n)",
      "prerequisites": ["3.2.1-a"],
      "domains": ["Net", "Struct", "Crypto"],
      "tags": ["shodan", "censys", "infrastructure", "vulnerability"],
      "meme_reference": "Metal Gear Solid Soliton Radar"
    }
  }
}
```

---

*Exercice gÃ©nÃ©rÃ© par HACKBRAIN v5.5.2*
*Module 3.2.1 â€” Reconnaissance & OSINT*
*"Information is power. But like all power, there are those who want to keep it for themselves."*
