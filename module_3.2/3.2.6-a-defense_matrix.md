# Exercice 3.2.11 : defense_matrix

**Module :**
3.2.6 â€” Firewalls & IDS

**Concept :**
a â€” Firewall & IDS Analyzer (Rules, Evasion, WAF)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
2 â€” Melange (concepts a + b + c + d + e + f + g + h)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.5 (Protocol Attacks)
- Understanding of network security concepts
- Regular expression basics

**Domaines :**
Net, Algo, Crypto

**Duree estimee :**
7-9 heures

**XP Base :**
425

**Complexite :**
T3 O(n Ã— m) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :** `defense_matrix.rs`

**Fonctions autorisees :**
- `std::collections::*`
- `regex::*`
- `serde::*`
- `chrono::*`
- Fonctions mathematiques standard

**Fonctions interdites :**
- `std::net::TcpStream`
- `std::process::Command`
- Toute execution reseau reelle

---

### 1.2 Consigne

**ğŸ® CONTEXTE : "Minority Report" - PreCrime Network Division**

*"Dans le futur de 2054, le systeme PreCrime ne se limite plus aux meurtres. La division reseau utilise des 'precogs numeriques' - des IDS et firewalls capables de voir les attaques avant qu'elles ne se produisent.*

*John Anderton, tu es le nouveau technicien affecte a l'analyse des matrices de defense. Ton role : evaluer l'efficacite des regles, detecter les failles dans les configurations, et predire les techniques d'evasion que les criminels pourraient utiliser.*

*Chaque regle mal configuree est une future breche. Chaque faux positif est un innocent accuse. La precision est tout."*

---

### 1.2.1 Contexte Academique

Les systemes de defense reseau reposent sur :

1. **Firewalls** : Filtrage base sur IP, ports, protocoles, etats
2. **IDS/IPS** : Detection par signature et anomalie
3. **WAF** : Protection specifique aux applications web
4. **Evasion** : Techniques pour contourner ces defenses

L'efficacite depend de la configuration, de l'ordre des regles, et de la comprehension des techniques d'evasion.

---

**Ta mission :**

Implementer `defense_matrix` qui:

1. **Parse des regles firewall** (format simplifie iptables/nftables)
2. **Parse des regles IDS** (format simplifie Snort)
3. **Simule le passage de paquets** a travers ces regles
4. **Identifie les failles** dans les rulesets (regles shadowed, trop permissives)
5. **Genere des payloads d'evasion** potentiels
6. **Evalue la posture de securite** et propose des ameliorations

---

**Entree :**

```json
{
  "firewall_rules": [
    {
      "rule_id": "FW-001",
      "chain": "INPUT",
      "action": "ACCEPT",
      "protocol": "tcp",
      "source": "192.168.1.0/24",
      "destination": "any",
      "dst_port": 22,
      "state": "NEW,ESTABLISHED"
    },
    {
      "rule_id": "FW-002",
      "chain": "INPUT",
      "action": "DROP",
      "protocol": "tcp",
      "source": "any",
      "destination": "any",
      "dst_port": 22
    }
  ],
  "ids_rules": [
    {
      "rule_id": "IDS-001",
      "action": "alert",
      "protocol": "tcp",
      "source": "any",
      "destination": "any",
      "dst_port": 80,
      "content": "/etc/passwd",
      "options": {
        "nocase": true,
        "msg": "Potential LFI attempt"
      }
    },
    {
      "rule_id": "IDS-002",
      "action": "alert",
      "protocol": "tcp",
      "source": "any",
      "destination": "any",
      "dst_port": 80,
      "pcre": "/union.*select/i",
      "options": {
        "msg": "SQL Injection attempt"
      }
    }
  ],
  "waf_rules": [
    {
      "rule_id": "WAF-001",
      "type": "blacklist",
      "target": "request_uri",
      "pattern": "(\\.\\./|\\.\\.\\\\)",
      "action": "block",
      "severity": "critical"
    }
  ],
  "test_packets": [
    {
      "packet_id": "PKT-001",
      "src_ip": "192.168.1.50",
      "dst_ip": "10.0.0.1",
      "protocol": "tcp",
      "src_port": 45678,
      "dst_port": 22,
      "flags": ["SYN"],
      "payload": null
    },
    {
      "packet_id": "PKT-002",
      "src_ip": "10.0.0.100",
      "dst_ip": "10.0.0.1",
      "protocol": "tcp",
      "src_port": 12345,
      "dst_port": 80,
      "flags": ["PSH", "ACK"],
      "payload": "GET /page?file=../../../etc/passwd HTTP/1.1"
    }
  ]
}
```

---

**Sortie :**

```json
{
  "simulation_results": [
    {
      "packet_id": "PKT-001",
      "firewall_result": {
        "action": "ACCEPT",
        "matched_rule": "FW-001",
        "chain_path": ["INPUT"]
      },
      "ids_alerts": [],
      "waf_alerts": [],
      "final_status": "allowed"
    },
    {
      "packet_id": "PKT-002",
      "firewall_result": {
        "action": "ACCEPT",
        "matched_rule": "default_accept",
        "chain_path": ["INPUT"]
      },
      "ids_alerts": [
        {
          "rule_id": "IDS-001",
          "msg": "Potential LFI attempt",
          "matched_content": "/etc/passwd"
        }
      ],
      "waf_alerts": [
        {
          "rule_id": "WAF-001",
          "action": "block",
          "matched_pattern": "../../../"
        }
      ],
      "final_status": "blocked_by_waf"
    }
  ],
  "ruleset_analysis": {
    "firewall_issues": [
      {
        "issue_type": "shadowed_rule",
        "affected_rule": "FW-002",
        "shadowed_by": "FW-001",
        "explanation": "FW-002 never matches because FW-001 accepts all 192.168.1.0/24 traffic to port 22 first",
        "severity": "medium"
      }
    ],
    "ids_issues": [
      {
        "issue_type": "evasion_possible",
        "affected_rule": "IDS-001",
        "evasion_technique": "URL encoding",
        "example": "/etc%2Fpasswd",
        "severity": "high"
      }
    ],
    "waf_issues": []
  },
  "evasion_techniques": [
    {
      "technique_id": "EVA-001",
      "name": "URL Encoding",
      "bypasses_rules": ["IDS-001"],
      "example_payload": "GET /page?file=%2e%2e%2f%2e%2e%2fetc%2fpasswd HTTP/1.1",
      "success_probability": 0.9
    },
    {
      "technique_id": "EVA-002",
      "name": "Case Manipulation",
      "bypasses_rules": ["IDS-002"],
      "example_payload": "GET /page?id=1 UnIoN SeLeCt * FROM users HTTP/1.1",
      "success_probability": 0.3
    },
    {
      "technique_id": "EVA-003",
      "name": "IP Fragmentation",
      "bypasses_rules": ["IDS-001", "IDS-002"],
      "example": "Fragment payload across multiple IP packets",
      "success_probability": 0.7
    }
  ],
  "security_posture": {
    "overall_score": 68,
    "firewall_score": 75,
    "ids_score": 60,
    "waf_score": 70,
    "recommendations": [
      {
        "priority": "high",
        "category": "IDS",
        "recommendation": "Add URL-decoded content inspection",
        "affected_rules": ["IDS-001"]
      },
      {
        "priority": "medium",
        "category": "Firewall",
        "recommendation": "Review rule order - shadowed rule detected",
        "affected_rules": ["FW-002"]
      }
    ]
  }
}
```

---

### 1.3 Prototype

```rust
/// Point d'entree principal
pub fn analyze_defense_matrix(input: &DefenseInput) -> DefenseAnalysis;

/// Parse et valide les regles firewall
pub fn parse_firewall_rules(rules: &[FirewallRule]) -> ParsedRuleset;

/// Parse les regles IDS (Snort-like)
pub fn parse_ids_rules(rules: &[IdsRule]) -> ParsedIdsRuleset;

/// Simule le passage d'un paquet
pub fn simulate_packet(
    packet: &TestPacket,
    fw_rules: &ParsedRuleset,
    ids_rules: &ParsedIdsRuleset,
    waf_rules: &[WafRule]
) -> PacketSimulation;

/// Detecte les regles shadowed
pub fn detect_shadowed_rules(rules: &ParsedRuleset) -> Vec<ShadowedRule>;

/// Genere des techniques d'evasion
pub fn generate_evasion_techniques(
    ids_rules: &ParsedIdsRuleset,
    waf_rules: &[WafRule]
) -> Vec<EvasionTechnique>;

/// Calcule le score de securite
pub fn calculate_security_score(
    fw_issues: &[FirewallIssue],
    ids_issues: &[IdsIssue],
    waf_issues: &[WafIssue]
) -> SecurityPosture;

/// Verifie si un paquet matche une regle firewall
pub fn matches_firewall_rule(
    packet: &TestPacket,
    rule: &FirewallRule
) -> bool;

/// Verifie si un payload matche une regle IDS
pub fn matches_ids_rule(
    payload: &str,
    rule: &IdsRule
) -> Option<IdsMatch>;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'ordre des regles iptables

Dans iptables, la premiere regle qui matche determine l'action. Une regle "ACCEPT" en position 1 peut rendre inutile une regle "DROP" en position 2 si elles ont le meme scope. C'est le probleme des **regles shadowed**.

### 2.2 Snort vs Suricata

Snort utilise un modele single-threaded, tandis que Suricata est multi-threaded. Pour le meme hardware, Suricata peut inspecter 3-5x plus de trafic. Cependant, les regles Snort sont plus largement partagees (Emerging Threats, etc.).

### 2.3 WAF Bypass Hall of Fame

En 2019, un chercheur a contourne Cloudflare WAF avec la payload: `<img src=x onerror="&#x61;lert(1)">`. L'encodage HTML des caracteres a trompe le parser.

---

### 2.5 DANS LA VRAIE VIE

| Metier | Utilisation |
|--------|-------------|
| **Security Engineer** | Configure et optimise les firewalls d'entreprise |
| **SOC Analyst** | Analyse les alertes IDS, distingue vrais/faux positifs |
| **Penetration Tester** | Teste les techniques d'evasion contre les defenses |
| **DevSecOps** | Integre WAF dans les pipelines CI/CD |
| **Compliance Officer** | Verifie que les regles respectent les politiques |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
defense_matrix.rs  main.rs  rules/

$ cargo build --release

$ ./target/release/defense_matrix rules/corporate.json
Defense Matrix Analysis Complete!

Simulation Results:
- Packets tested: 100
- Allowed: 45
- Blocked by FW: 30
- Blocked by IDS: 15
- Blocked by WAF: 10

Issues Found:
- Shadowed rules: 3
- Evasion possible: 5

Security Score: 68/100
Recommendations: 4 high, 2 medium
```

---

## ğŸ”¥ SECTION 3.1 : BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
ğŸ§  (11/10)

**Recompense :**
XP Ã—6

**Time Complexity attendue :**
O(n Ã— m Ã— log k)

**Space Complexity attendue :**
O(n + m)

**Domaines Bonus :**
`ML, Probas`

### 3.1.1 Consigne Bonus

**ğŸ® "PreCogs Avances" - Predictive Defense**

*"Les precogs de niveau 2 ne voient pas juste les attaques - ils voient les patterns d'evolution des menaces. Tu dois implementer un systeme qui apprend des attaques passees pour predire les futures techniques d'evasion."*

**Ta mission :**

Implementer `predictive_defense` qui:

1. **Analyse historique** : Apprend des attaques passees et leurs evasions
2. **Correlation de regles** : Identifie les combinaisons de regles faibles
3. **Generation automatique** : Cree des regles IDS pour bloquer les evasions predites
4. **Scoring ML-lite** : Utilise des heuristiques pour predire la probabilite d'evasion
5. **Optimisation** : Propose un ordre optimal des regles

**Contraintes :**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  rules.len() â‰¤ 10^4                     â”‚
â”‚  Temps limite : O(n Ã— m Ã— log k)        â”‚
â”‚  Faux positifs < 0.1%                   â”‚
â”‚  Coverage evasions > 95%                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.2 Prototype Bonus

```rust
/// Defense predictive
pub fn predictive_defense(
    current_rules: &DefenseInput,
    attack_history: &[AttackEvent]
) -> PredictiveAnalysis;

/// Genere des regles anti-evasion
pub fn generate_anti_evasion_rules(
    vulnerable_rules: &[IdsRule],
    known_evasions: &[EvasionTechnique]
) -> Vec<IdsRule>;

/// Optimise l'ordre des regles
pub fn optimize_rule_order(
    rules: &[FirewallRule]
) -> Vec<FirewallRule>;
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Parse iptables-like rules | 10 |
| `T02` | Parse Snort-like rules | 10 |
| `T03` | Simulate packet through FW | 10 |
| `T04` | Simulate packet through IDS | 10 |
| `T05` | Detect shadowed rules | 15 |
| `T06` | Detect rule order issues | 10 |
| `T07` | Generate URL encoding evasion | 10 |
| `T08` | Generate fragmentation evasion | 10 |
| `T09` | Calculate security score | 10 |
| `T10` | Generate recommendations | 5 |

**Total : 100 points**

---

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use regex::Regex;
use serde::{Serialize, Deserialize};
use std::net::Ipv4Addr;

#[derive(Debug, Clone)]
pub struct FirewallRule {
    pub rule_id: String,
    pub chain: String,
    pub action: Action,
    pub protocol: Option<String>,
    pub source: IpSpec,
    pub destination: IpSpec,
    pub src_port: Option<PortSpec>,
    pub dst_port: Option<PortSpec>,
    pub state: Option<Vec<String>>,
}

#[derive(Debug, Clone)]
pub enum Action {
    Accept,
    Drop,
    Reject,
    Log,
}

#[derive(Debug, Clone)]
pub enum IpSpec {
    Any,
    Single(Ipv4Addr),
    Cidr(Ipv4Addr, u8),
}

#[derive(Debug, Clone)]
pub enum PortSpec {
    Single(u16),
    Range(u16, u16),
    List(Vec<u16>),
}

#[derive(Debug, Clone)]
pub struct IdsRule {
    pub rule_id: String,
    pub action: String,
    pub protocol: String,
    pub source: IpSpec,
    pub destination: IpSpec,
    pub dst_port: Option<PortSpec>,
    pub content: Option<String>,
    pub pcre: Option<String>,
    pub options: IdsOptions,
}

#[derive(Debug, Clone, Default)]
pub struct IdsOptions {
    pub nocase: bool,
    pub msg: String,
    pub offset: Option<usize>,
    pub depth: Option<usize>,
}

pub fn simulate_packet(
    packet: &TestPacket,
    fw_rules: &[FirewallRule],
    ids_rules: &[IdsRule],
    waf_rules: &[WafRule]
) -> PacketSimulation {
    // First, check firewall rules (first match wins)
    let fw_result = evaluate_firewall(packet, fw_rules);

    // If firewall blocks, stop here
    if fw_result.action == Action::Drop || fw_result.action == Action::Reject {
        return PacketSimulation {
            packet_id: packet.packet_id.clone(),
            firewall_result: fw_result,
            ids_alerts: vec![],
            waf_alerts: vec![],
            final_status: FinalStatus::BlockedByFirewall,
        };
    }

    // Check IDS rules (all rules checked, alerts generated)
    let ids_alerts = evaluate_ids(packet, ids_rules);

    // Check WAF rules (if HTTP traffic)
    let waf_alerts = if packet.dst_port == Some(80) || packet.dst_port == Some(443) {
        evaluate_waf(packet, waf_rules)
    } else {
        vec![]
    };

    // Determine final status
    let final_status = if waf_alerts.iter().any(|a| a.action == "block") {
        FinalStatus::BlockedByWaf
    } else if !ids_alerts.is_empty() {
        // IDS is typically passive (alerts only, doesn't block)
        FinalStatus::AllowedWithAlerts
    } else {
        FinalStatus::Allowed
    };

    PacketSimulation {
        packet_id: packet.packet_id.clone(),
        firewall_result: fw_result,
        ids_alerts,
        waf_alerts,
        final_status,
    }
}

fn evaluate_firewall(packet: &TestPacket, rules: &[FirewallRule]) -> FirewallResult {
    for rule in rules {
        if matches_firewall_rule(packet, rule) {
            return FirewallResult {
                action: rule.action.clone(),
                matched_rule: rule.rule_id.clone(),
                chain_path: vec![rule.chain.clone()],
            };
        }
    }

    // Default policy (typically DROP for INPUT, ACCEPT for OUTPUT)
    FirewallResult {
        action: Action::Accept,
        matched_rule: "default_policy".to_string(),
        chain_path: vec!["INPUT".to_string()],
    }
}

pub fn matches_firewall_rule(packet: &TestPacket, rule: &FirewallRule) -> bool {
    // Check protocol
    if let Some(ref proto) = rule.protocol {
        if proto != &packet.protocol {
            return false;
        }
    }

    // Check source IP
    if !ip_matches(&packet.src_ip, &rule.source) {
        return false;
    }

    // Check destination IP
    if !ip_matches(&packet.dst_ip, &rule.destination) {
        return false;
    }

    // Check destination port
    if let Some(ref port_spec) = rule.dst_port {
        if let Some(pkt_port) = packet.dst_port {
            if !port_matches(pkt_port, port_spec) {
                return false;
            }
        } else {
            return false;
        }
    }

    true
}

fn ip_matches(ip: &str, spec: &IpSpec) -> bool {
    match spec {
        IpSpec::Any => true,
        IpSpec::Single(target) => {
            ip.parse::<Ipv4Addr>().ok() == Some(*target)
        },
        IpSpec::Cidr(network, prefix) => {
            if let Ok(addr) = ip.parse::<Ipv4Addr>() {
                let mask = u32::MAX << (32 - prefix);
                let addr_u32 = u32::from(addr);
                let net_u32 = u32::from(*network);
                (addr_u32 & mask) == (net_u32 & mask)
            } else {
                false
            }
        }
    }
}

fn port_matches(port: u16, spec: &PortSpec) -> bool {
    match spec {
        PortSpec::Single(p) => port == *p,
        PortSpec::Range(start, end) => port >= *start && port <= *end,
        PortSpec::List(ports) => ports.contains(&port),
    }
}

fn evaluate_ids(packet: &TestPacket, rules: &[IdsRule]) -> Vec<IdsAlert> {
    let mut alerts = Vec::new();

    let payload = packet.payload.as_ref().map(|s| s.as_str()).unwrap_or("");

    for rule in rules {
        if let Some(ids_match) = matches_ids_rule(payload, rule) {
            alerts.push(IdsAlert {
                rule_id: rule.rule_id.clone(),
                msg: rule.options.msg.clone(),
                matched_content: ids_match.matched_text,
            });
        }
    }

    alerts
}

pub fn matches_ids_rule(payload: &str, rule: &IdsRule) -> Option<IdsMatch> {
    // Check content match
    if let Some(ref content) = rule.content {
        let search_payload = if rule.options.nocase {
            payload.to_lowercase()
        } else {
            payload.to_string()
        };

        let search_content = if rule.options.nocase {
            content.to_lowercase()
        } else {
            content.clone()
        };

        if search_payload.contains(&search_content) {
            return Some(IdsMatch {
                matched_text: content.clone(),
                match_type: MatchType::Content,
            });
        }
    }

    // Check PCRE match
    if let Some(ref pcre) = rule.pcre {
        // Parse Snort PCRE format: /pattern/flags
        let (pattern, flags) = parse_pcre(pcre);

        let regex_pattern = if flags.contains('i') {
            format!("(?i){}", pattern)
        } else {
            pattern.to_string()
        };

        if let Ok(re) = Regex::new(&regex_pattern) {
            if let Some(m) = re.find(payload) {
                return Some(IdsMatch {
                    matched_text: m.as_str().to_string(),
                    match_type: MatchType::Pcre,
                });
            }
        }
    }

    None
}

fn parse_pcre(pcre: &str) -> (&str, &str) {
    // Format: /pattern/flags
    let trimmed = pcre.trim_start_matches('/');
    if let Some(pos) = trimmed.rfind('/') {
        (&trimmed[..pos], &trimmed[pos+1..])
    } else {
        (trimmed, "")
    }
}

pub fn detect_shadowed_rules(rules: &[FirewallRule]) -> Vec<ShadowedRule> {
    let mut shadowed = Vec::new();

    for i in 0..rules.len() {
        for j in (i + 1)..rules.len() {
            if is_shadowed(&rules[j], &rules[i]) {
                shadowed.push(ShadowedRule {
                    affected_rule: rules[j].rule_id.clone(),
                    shadowed_by: rules[i].rule_id.clone(),
                    explanation: format!(
                        "{} never matches because {} matches all its traffic first",
                        rules[j].rule_id, rules[i].rule_id
                    ),
                });
            }
        }
    }

    shadowed
}

fn is_shadowed(rule: &FirewallRule, by: &FirewallRule) -> bool {
    // Rule A shadows Rule B if:
    // - A comes before B
    // - A's conditions are a superset of B's
    // - A has an action that terminates (ACCEPT, DROP, REJECT)

    // Same chain
    if rule.chain != by.chain {
        return false;
    }

    // Both must have terminating actions
    match by.action {
        Action::Accept | Action::Drop | Action::Reject => {},
        _ => return false,
    }

    // Check if 'by' is more general than 'rule'
    is_more_general(&by.source, &rule.source) &&
    is_more_general(&by.destination, &rule.destination) &&
    port_more_general(&by.dst_port, &rule.dst_port) &&
    protocol_more_general(&by.protocol, &rule.protocol)
}

fn is_more_general(general: &IpSpec, specific: &IpSpec) -> bool {
    match (general, specific) {
        (IpSpec::Any, _) => true,
        (IpSpec::Cidr(g_net, g_prefix), IpSpec::Cidr(s_net, s_prefix)) => {
            // General has smaller or equal prefix (larger network)
            if g_prefix > s_prefix {
                return false;
            }
            // Specific network is within general network
            let g_mask = u32::MAX << (32 - g_prefix);
            let g_u32 = u32::from(*g_net);
            let s_u32 = u32::from(*s_net);
            (g_u32 & g_mask) == (s_u32 & g_mask)
        },
        (IpSpec::Cidr(g_net, g_prefix), IpSpec::Single(s_addr)) => {
            let g_mask = u32::MAX << (32 - g_prefix);
            let g_u32 = u32::from(*g_net);
            let s_u32 = u32::from(*s_addr);
            (g_u32 & g_mask) == (s_u32 & g_mask)
        },
        (IpSpec::Single(a), IpSpec::Single(b)) => a == b,
        _ => false,
    }
}

fn port_more_general(general: &Option<PortSpec>, specific: &Option<PortSpec>) -> bool {
    match (general, specific) {
        (None, _) => true, // No port spec = any port
        (Some(g), Some(s)) => {
            match (g, s) {
                (PortSpec::Range(g_start, g_end), PortSpec::Single(p)) => {
                    *p >= *g_start && *p <= *g_end
                },
                (PortSpec::Single(g), PortSpec::Single(s)) => g == s,
                _ => false,
            }
        },
        (Some(_), None) => false,
    }
}

fn protocol_more_general(general: &Option<String>, specific: &Option<String>) -> bool {
    match (general, specific) {
        (None, _) => true,
        (Some(g), Some(s)) => g == s,
        (Some(_), None) => false,
    }
}

pub fn generate_evasion_techniques(
    ids_rules: &[IdsRule],
    waf_rules: &[WafRule]
) -> Vec<EvasionTechnique> {
    let mut techniques = Vec::new();

    for rule in ids_rules {
        // URL Encoding evasion
        if rule.content.is_some() && !has_url_decode_option(rule) {
            let encoded = url_encode_payload(rule.content.as_ref().unwrap());
            techniques.push(EvasionTechnique {
                technique_id: format!("EVA-{}", techniques.len() + 1),
                name: "URL Encoding".to_string(),
                bypasses_rules: vec![rule.rule_id.clone()],
                example_payload: encoded,
                success_probability: 0.9,
            });
        }

        // Case manipulation (if nocase not set)
        if rule.content.is_some() && !rule.options.nocase {
            let mixed = mix_case(rule.content.as_ref().unwrap());
            techniques.push(EvasionTechnique {
                technique_id: format!("EVA-{}", techniques.len() + 1),
                name: "Case Manipulation".to_string(),
                bypasses_rules: vec![rule.rule_id.clone()],
                example_payload: mixed,
                success_probability: 0.95,
            });
        }

        // Null byte injection
        if rule.content.is_some() {
            techniques.push(EvasionTechnique {
                technique_id: format!("EVA-{}", techniques.len() + 1),
                name: "Null Byte Injection".to_string(),
                bypasses_rules: vec![rule.rule_id.clone()],
                example_payload: format!("{}%00{}",
                    &rule.content.as_ref().unwrap()[..3],
                    &rule.content.as_ref().unwrap()[3..]),
                success_probability: 0.6,
            });
        }
    }

    // IP Fragmentation (bypasses most content inspection)
    techniques.push(EvasionTechnique {
        technique_id: format!("EVA-{}", techniques.len() + 1),
        name: "IP Fragmentation".to_string(),
        bypasses_rules: ids_rules.iter().map(|r| r.rule_id.clone()).collect(),
        example_payload: "Fragment payload across multiple IP packets".to_string(),
        success_probability: 0.7,
    });

    techniques
}

fn has_url_decode_option(rule: &IdsRule) -> bool {
    // In real Snort, this would be http_uri with normalization
    false // Simplified - assume no URL decoding
}

fn url_encode_payload(payload: &str) -> String {
    payload.chars()
        .map(|c| format!("%{:02X}", c as u8))
        .collect()
}

fn mix_case(s: &str) -> String {
    s.chars()
        .enumerate()
        .map(|(i, c)| {
            if i % 2 == 0 {
                c.to_uppercase().to_string()
            } else {
                c.to_lowercase().to_string()
            }
        })
        .collect()
}

pub fn calculate_security_score(
    fw_issues: &[ShadowedRule],
    ids_issues: &[IdsIssue],
    evasions: &[EvasionTechnique]
) -> SecurityPosture {
    let base_score = 100;

    // Deductions
    let fw_deduction = fw_issues.len() as i32 * 5;
    let ids_deduction = ids_issues.len() as i32 * 8;
    let evasion_deduction = evasions.len() as i32 * 4;

    let overall = (base_score - fw_deduction - ids_deduction - evasion_deduction).max(0);
    let fw_score = (100 - fw_issues.len() as i32 * 10).max(0);
    let ids_score = (100 - ids_issues.len() as i32 * 15 - evasions.len() as i32 * 5).max(0);

    SecurityPosture {
        overall_score: overall as u32,
        firewall_score: fw_score as u32,
        ids_score: ids_score as u32,
        waf_score: 70, // Simplified
        recommendations: generate_recommendations(fw_issues, ids_issues, evasions),
    }
}

fn generate_recommendations(
    fw_issues: &[ShadowedRule],
    _ids_issues: &[IdsIssue],
    evasions: &[EvasionTechnique]
) -> Vec<Recommendation> {
    let mut recs = Vec::new();

    if !fw_issues.is_empty() {
        recs.push(Recommendation {
            priority: Priority::Medium,
            category: "Firewall".to_string(),
            recommendation: "Review rule order - shadowed rules detected".to_string(),
            affected_rules: fw_issues.iter().map(|i| i.affected_rule.clone()).collect(),
        });
    }

    for evasion in evasions {
        if evasion.name == "URL Encoding" {
            recs.push(Recommendation {
                priority: Priority::High,
                category: "IDS".to_string(),
                recommendation: "Add URL-decoded content inspection".to_string(),
                affected_rules: evasion.bypasses_rules.clone(),
            });
        }
    }

    recs
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A (Boundary) : Mauvais calcul CIDR

```rust
fn ip_matches(ip: &str, spec: &IpSpec) -> bool {
    match spec {
        IpSpec::Cidr(network, prefix) => {
            let mask = u32::MAX >> (32 - prefix);  // BUG: >> au lieu de <<
            // ...
        }
    }
}
// Pourquoi c'est faux : Le masque est inverse, accepte les mauvaises IPs
```

#### Mutant B (Logic) : First match ignore

```rust
fn evaluate_firewall(packet: &TestPacket, rules: &[FirewallRule]) -> FirewallResult {
    let mut result = None;
    for rule in rules {
        if matches_firewall_rule(packet, rule) {
            result = Some(rule);  // BUG: continue au lieu de return
        }
    }
    // Prend la derniere au lieu de la premiere
}
// Pourquoi c'est faux : iptables est first-match, pas last-match
```

#### Mutant C (Safety) : Regex panic sur input malveillant

```rust
fn matches_ids_rule(payload: &str, rule: &IdsRule) -> Option<IdsMatch> {
    if let Some(ref pcre) = rule.pcre {
        let re = Regex::new(pcre).unwrap();  // BUG: panic sur regex invalide
        // ...
    }
}
// Pourquoi c'est faux : Un attaquant peut crafted une regle qui fait panic
```

#### Mutant D (Resource) : Detection shadowing incomplete

```rust
fn is_shadowed(rule: &FirewallRule, by: &FirewallRule) -> bool {
    // BUG: Ne verifie pas les ports
    is_more_general(&by.source, &rule.source) &&
    is_more_general(&by.destination, &rule.destination)
}
// Pourquoi c'est faux : Ignore la condition de port dans le shadowing
```

#### Mutant E (Return) : Evasion avec mauvaise probabilite

```rust
techniques.push(EvasionTechnique {
    success_probability: 1.0,  // BUG: toujours 100%
    // ...
});
// Pourquoi c'est faux : Les evasions ne marchent pas toujours
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Firewall Rule Logic** : Ordre des regles, first-match, shadowing
2. **IDS Signatures** : Content matching, PCRE, options
3. **Evasion Techniques** : Comment les attaquants contournent les defenses
4. **Defense in Depth** : Combiner FW + IDS + WAF

### 5.2 LDA â€” Traduction litterale

```
FONCTION simulate_packet QUI RETOURNE UNE SIMULATION ET PREND EN PARAMÃˆTRES packet, fw_rules, ids_rules, waf_rules
DÃ‰BUT FONCTION
    DÃ‰CLARER fw_result COMME RÃ‰SULTAT DE evaluate_firewall(packet, fw_rules)

    SI fw_result.action EST DROP OU REJECT ALORS
        RETOURNER SIMULATION AVEC status BLOQUÃ‰ PAR FIREWALL
    FIN SI

    DÃ‰CLARER ids_alerts COMME RÃ‰SULTAT DE evaluate_ids(packet, ids_rules)
    DÃ‰CLARER waf_alerts COMME RÃ‰SULTAT DE evaluate_waf(packet, waf_rules)

    SI waf_alerts CONTIENT ACTION BLOCK ALORS
        RETOURNER SIMULATION AVEC status BLOQUÃ‰ PAR WAF
    FIN SI

    RETOURNER SIMULATION AVEC status AUTORISÃ‰
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
PACKET FLOW THROUGH DEFENSE MATRIX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  INCOMING PKT   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FIREWALL                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Rule 1: ACCEPT 192.168.1.0/24 â†’ :22          â”‚â”€â”€â”¼â”€â”€â†’ ACCEPT
â”‚  â”‚ Rule 2: DROP any â†’ :22                        â”‚  â”‚
â”‚  â”‚ Rule 3: ACCEPT any â†’ :80,443                  â”‚  â”‚
â”‚  â”‚ Rule 4: DROP any                              â”‚â”€â”€â”¼â”€â”€â†’ DROP
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                    â”‚
â”‚  First Match Wins!                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼ (if ACCEPT)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      IDS                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Alert on "/etc/passwd" (content match)        â”‚  â”‚
â”‚  â”‚ Alert on "union select" (PCRE match)          â”‚  â”‚
â”‚  â”‚ Alert on Port Scan pattern                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                    â”‚
â”‚  All Rules Checked â†’ Generate Alerts              â”‚
â”‚  (Typically doesn't block, just alerts)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      WAF                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Block on path traversal: ../ or ..\\          â”‚  â”‚
â”‚  â”‚ Block on XSS: <script>                        â”‚  â”‚
â”‚  â”‚ Block on SQLi: ' OR '1'='1                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                    â”‚
â”‚  BLOCK action = Request terminated               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   APPLICATION   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


SHADOWED RULE PROBLEM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Rule Order:
1. ACCEPT 192.168.0.0/16 â†’ :22    â† Matches ALL 192.168.x.x
2. DROP 192.168.1.100 â†’ :22        â† NEVER REACHED (Shadowed!)

Why? Because 192.168.1.100 is within 192.168.0.0/16
Rule 1 always matches first â†’ Rule 2 is dead code


EVASION TECHNIQUES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Original Attack:        GET /page?file=../etc/passwd
                                        â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                   â”‚                   â”‚
                    â–¼                   â–¼                   â–¼
           URL Encoding          Case Mixing          Fragmentation
        %2e%2e%2fetc%2f         ../EtC/pAsSwD         Fragment 1: "GET /p"
           passwd                                     Fragment 2: "age?fi"
                                                      Fragment 3: "le=../"
                                                      Fragment 4: "etc/pa"
                                                      Fragment 5: "sswd"

IDS may not detect because:
- No URL decoding
- Case-sensitive matching
- No reassembly before inspection
```

### 5.4 Les pieges en detail

#### Piege 1 : Rule Order

```rust
// MAUVAIS : Assume last-match
let mut matched_rule = None;
for rule in rules {
    if matches(packet, rule) {
        matched_rule = Some(rule);  // Continue checking
    }
}

// BON : First-match (iptables behavior)
for rule in rules {
    if matches(packet, rule) {
        return Some(rule);  // Stop immediately
    }
}
```

#### Piege 2 : CIDR Calculation

```rust
// MAUVAIS : Wrong bit shift direction
let mask = u32::MAX >> (32 - prefix);

// BON : Correct shift for network mask
let mask = u32::MAX << (32 - prefix);
```

### 5.5 Cours Complet

#### 5.5.1 Firewall Stateless vs Stateful

**Stateless:** Chaque paquet evalue independamment
**Stateful:** Suit les connexions (SYNâ†’SYN-ACKâ†’ACK), permet "ESTABLISHED"

```
Stateful Rule: -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
â†’ Permet les reponses aux connexions initiees depuis l'interieur
```

#### 5.5.2 IDS Signature Anatomy

```
alert tcp $EXTERNAL_NET any -> $HOME_NET 80 (
    msg:"SQL Injection attempt";
    content:"union"; nocase;
    content:"select"; nocase; distance:0; within:20;
    pcre:"/union\s+(all\s+)?select/i";
    sid:1000001; rev:1;
)
```

- `content`: String match
- `nocase`: Case insensitive
- `distance/within`: Position relative
- `pcre`: Regular expression

#### 5.5.3 WAF ModSecurity Rules

```
SecRule REQUEST_URI "@rx \.\./" "id:1001,phase:1,deny,status:403,msg:'Path Traversal'"
```

### 5.6 Normes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME (compile, mais interdit)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let re = Regex::new(pattern).unwrap();                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let re = match Regex::new(pattern) {                            â”‚
â”‚     Ok(r) => r,                                                  â”‚
â”‚     Err(_) => return None,                                       â”‚
â”‚ };                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Les patterns PCRE peuvent etre malformes                      â”‚
â”‚ â€¢ Un attaquant pourrait exploiter un panic                      â”‚
â”‚ â€¢ Les regles IDS viennent de sources externes                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'execution

**Scenario:** Paquet SSH depuis 192.168.1.50 vers 10.0.0.1:22

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Etape â”‚ Regle evaluee                â”‚ Match?     â”‚ Action             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ FW-001: 192.168.1.0/24 â†’ :22 â”‚ OUI        â”‚ ACCEPT â†’ TERMINE   â”‚
â”‚   -   â”‚ FW-002: any â†’ :22 DROP       â”‚ (skip)     â”‚ (jamais evalue)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Resultat: ACCEPT par FW-001, FW-002 est shadowed
```

### 5.8 Mnemotechniques

#### ğŸ¬ MEME : "Minority Report" - PreCrime

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  "The Precogs see the crime before it happens"                  â”‚
â”‚                                                                 â”‚
â”‚  ğŸ”® FIREWALL = The Containment Field                           â”‚
â”‚     â†’ Bloque physiquement l'acces                               â”‚
â”‚     â†’ First-match = first precog vision wins                    â”‚
â”‚                                                                 â”‚
â”‚  ğŸ‘ï¸ IDS = The Precogs                                          â”‚
â”‚     â†’ Voient les patterns d'attaque                             â”‚
â”‚     â†’ Alertent mais ne bloquent pas (passive)                   â”‚
â”‚     â†’ "Red Ball!" = Alerte critique                             â”‚
â”‚                                                                 â”‚
â”‚  ğŸ›¡ï¸ WAF = PreCrime Officers                                    â”‚
â”‚     â†’ Action directe sur l'application                          â”‚
â”‚     â†’ Bloquent les crimes web (SQLi, XSS)                       â”‚
â”‚                                                                 â”‚
â”‚  ğŸ­ EVASION = John Anderton's escape                            â”‚
â”‚     â†’ Change d'apparence (encoding)                             â”‚
â”‚     â†’ Multiple identites (fragmentation)                        â”‚
â”‚     â†’ "Everybody runs" - adaptabilite                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.9 Applications pratiques

1. **Security Audit** : Analyse des rulesets existants
2. **Penetration Testing** : Generation automatique d'evasions
3. **SOC Operations** : Validation des alertes
4. **Compliance** : Verification des politiques de securite

---

## âš ï¸ SECTION 6 : PIEGES â€” RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Last-match au lieu de first-match | Mauvaise simulation FW | Return immediatement |
| 2 | CIDR mal calcule | Mauvais filtrage IP | Bit shift correct |
| 3 | Regex non valide â†’ panic | DoS possible | Handle Result |
| 4 | Shadowing partiel | Detection incomplete | Verifier tous les criteres |
| 5 | Evasion toujours 100% | Fausse confiance | Probabilites realistes |

---

## ğŸ“ SECTION 7 : QCM

### Q1. Comment iptables evalue-t-il les regles ?

- A) Toutes les regles sont evaluees
- B) La derniere regle qui matche gagne
- C) La premiere regle qui matche gagne
- D) Les regles sont evaluees aleatoirement

**Reponse : C**

### Q2. Qu'est-ce qu'une regle "shadowed" ?

- A) Une regle cachee
- B) Une regle qui ne sera jamais evaluee car une regle precedente matche toujours
- C) Une regle de logging
- D) Une regle desactivee

**Reponse : B**

### Q3. Quelle technique d'evasion contourne le content matching sans URL decode ?

- A) IP fragmentation
- B) URL encoding
- C) Port scanning
- D) SYN flood

**Reponse : B**

### Q4. Quelle est la difference entre IDS et IPS ?

- A) IDS bloque, IPS alerte
- B) IDS alerte, IPS bloque
- C) Aucune difference
- D) IPS est plus ancien

**Reponse : B**

### Q5. Dans Snort, que signifie l'option "nocase" ?

- A) Ignore les cas NULL
- B) Recherche insensible a la casse
- C) Ne genere pas d'alerte
- D) Match uniquement en minuscules

**Reponse : B**

---

## ğŸ“Š SECTION 8 : RECAPITULATIF

| Concept | Implementation | Points Cles |
|---------|----------------|-------------|
| Firewall Rules | First-match evaluation | Ordre critique |
| IDS Signatures | Content + PCRE matching | Options importantes |
| WAF | Web-specific patterns | Path traversal, SQLi, XSS |
| Evasion | Encoding, fragmentation | Multiple techniques |
| Security Score | Weighted issues | Recommendations |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.2.6-a-defense-matrix",
    "metadata": {
      "exercise_id": "3.2.11",
      "exercise_name": "defense_matrix",
      "module": "3.2.6",
      "module_name": "Firewalls & IDS",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 425,
      "tags": ["firewall", "ids", "snort", "waf", "evasion", "iptables"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Defense Matrix*
*"Voir le crime avant qu'il ne se produise"*
