# Exercice 3.2.08 : layer2_havoc

**Module :**
3.2.4 â€” Network Attacks

**Concept :**
a â€” Layer 2 Attack Detector (ARP Spoofing, MITM, DNS Spoofing, DHCP, VLAN, STP, LLMNR)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Type :**
complet

**Tiers :**
2 â€” Melange (concepts a + b + c + d + e + f + g + h)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.06-07 (Traffic Analysis)
- Protocoles L2 (ARP, DHCP, STP)
- Ethernet frames basics

**Domaines :**
Net, Struct, Algo

**Duree estimee :**
7-9 heures

**XP Base :**
400

**Complexite :**
T3 O(n log n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
layer2_havoc/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ detectors/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ arp_detector.rs
â”‚   â”‚   â”œâ”€â”€ dhcp_detector.rs
â”‚   â”‚   â”œâ”€â”€ dns_detector.rs
â”‚   â”‚   â”œâ”€â”€ vlan_detector.rs
â”‚   â”‚   â”œâ”€â”€ stp_detector.rs
â”‚   â”‚   â””â”€â”€ llmnr_detector.rs
â”‚   â”œâ”€â”€ correlator/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ attack_chain.rs
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ mod.rs
```

**Fonctions autorisees :**
- `serde`, `serde_json`
- `chrono` pour timestamps
- Crates standard Rust 2024

**Fonctions interdites :**
- Acces reseau reel
- Raw sockets

---

### 1.2 Consigne

**ğŸ® CONTEXTE : "Watch Dogs" - Network Intrusion Detection**

*"Dans l'univers de Watch Dogs, Aiden Pearce utilise son telephone pour hacker les reseaux de la ville. Tu travailles pour Blume Corporation et tu dois developper un systeme de detection capable d'identifier les attaques Layer 2.*

*Les logs reseau arrivent sous forme de timeline d'evenements. Tu dois detecter les attaques ARP spoofing, DHCP starvation, VLAN hopping, et autres menaces L2 avant qu'Aiden ne prenne le controle de ctOS."*

---

**Ta mission :**

Implementer `layer2_havoc` qui:

1. **Analyse les logs reseau** (ARP tables, DHCP leases, STP topology)
2. **Detecte les anomalies** indicatives d'attaques L2
3. **Correle les evenements** pour identifier des attaques coordonnees
4. **Propose des reponses/mitigations** automatiques
5. **Calcule un score de compromission** reseau

---

**Entree :**

```json
{
  "network_state": {
    "timestamp": "2026-01-10T14:00:00Z",
    "network_id": "corp_lan_01"
  },
  "arp_events": [
    {
      "timestamp": "2026-01-10T14:00:05Z",
      "event_type": "arp_reply",
      "source_mac": "AA:BB:CC:DD:EE:01",
      "source_ip": "192.168.1.1",
      "interface": "eth0"
    },
    {
      "timestamp": "2026-01-10T14:00:10Z",
      "event_type": "arp_reply",
      "source_mac": "AA:BB:CC:DD:EE:99",
      "source_ip": "192.168.1.1",
      "interface": "eth0"
    }
  ],
  "dhcp_events": [
    {
      "timestamp": "2026-01-10T14:01:00Z",
      "event_type": "dhcp_discover",
      "client_mac": "11:22:33:44:55:01",
      "requested_ip": null
    },
    {
      "timestamp": "2026-01-10T14:01:01Z",
      "event_type": "dhcp_discover",
      "client_mac": "11:22:33:44:55:02",
      "requested_ip": null
    }
  ],
  "stp_events": [
    {
      "timestamp": "2026-01-10T14:02:00Z",
      "event_type": "bpdu_received",
      "bridge_id": "8000.AABBCCDDEEFF",
      "root_id": "8000.AABBCCDDEEFF",
      "port_id": 1,
      "message_age": 0
    }
  ],
  "dns_events": [
    {
      "timestamp": "2026-01-10T14:03:00Z",
      "event_type": "dns_response",
      "query": "internal.corp.local",
      "response_ip": "192.168.1.100",
      "source": "192.168.1.53"
    }
  ],
  "llmnr_events": [
    {
      "timestamp": "2026-01-10T14:04:00Z",
      "event_type": "llmnr_response",
      "query_name": "fileserver",
      "responder_ip": "192.168.1.200",
      "responder_mac": "AA:BB:CC:DD:EE:99"
    }
  ],
  "baseline": {
    "known_gateways": [
      {"ip": "192.168.1.1", "mac": "AA:BB:CC:DD:EE:01"}
    ],
    "known_dhcp_servers": ["192.168.1.2"],
    "known_dns_servers": ["192.168.1.53"],
    "stp_root_bridge": "8000.AABBCCDDEEFF"
  }
}
```

---

**Sortie :**

```json
{
  "analysis_metadata": {
    "analyzer": "layer2_havoc",
    "events_analyzed": 156,
    "analysis_duration_ms": 234
  },
  "attacks_detected": [
    {
      "attack_id": "ATK-001",
      "attack_type": "arp_spoofing",
      "severity": "critical",
      "confidence": 0.95,
      "description": "Gateway IP 192.168.1.1 claimed by unknown MAC AA:BB:CC:DD:EE:99",
      "evidence": {
        "original_mac": "AA:BB:CC:DD:EE:01",
        "spoofed_mac": "AA:BB:CC:DD:EE:99",
        "target_ip": "192.168.1.1",
        "first_seen": "2026-01-10T14:00:10Z"
      },
      "affected_assets": ["192.168.1.1", "all_hosts_on_segment"],
      "mitigation": {
        "immediate": "Block MAC AA:BB:CC:DD:EE:99 at switch level",
        "long_term": "Enable Dynamic ARP Inspection (DAI)"
      }
    },
    {
      "attack_id": "ATK-002",
      "attack_type": "llmnr_poisoning",
      "severity": "high",
      "confidence": 0.85,
      "description": "LLMNR response from non-authorized source for 'fileserver'",
      "evidence": {
        "query_name": "fileserver",
        "malicious_responder": "192.168.1.200"
      },
      "mitigation": {
        "immediate": "Investigate host 192.168.1.200",
        "long_term": "Disable LLMNR via GPO"
      }
    }
  ],
  "correlation_graph": {
    "attack_chains": [
      {
        "chain_id": "CHAIN-001",
        "attacks": ["ATK-001", "ATK-002"],
        "hypothesis": "MITM attack in progress - ARP spoofing + LLMNR poisoning from same source",
        "threat_actor_indicators": {
          "likely_source": "192.168.1.200",
          "likely_mac": "AA:BB:CC:DD:EE:99",
          "tools_suspected": ["Responder", "Bettercap"]
        }
      }
    ]
  },
  "network_compromise_score": {
    "score": 75,
    "rating": "critical",
    "breakdown": {
      "arp_integrity": 20,
      "dhcp_integrity": 100,
      "dns_integrity": 100,
      "stp_integrity": 100,
      "llmnr_nbns_exposure": 50
    }
  },
  "mitigation_plan": {
    "priority_1": [
      "Isolate MAC AA:BB:CC:DD:EE:99 immediately",
      "Enable DAI on affected VLANs"
    ],
    "priority_2": [
      "Disable LLMNR/NBT-NS network-wide",
      "Review DHCP snooping configuration"
    ],
    "priority_3": [
      "Implement 802.1X for network access control",
      "Deploy network monitoring solution"
    ]
  }
}
```

---

**Contraintes :**

- Detecter les 8 types d'attaques L2 (ARP, MITM, DNS, DHCP, VLAN, STP, LLMNR)
- Correler les attaques pour identifier les chains
- Distinguer les changements legitimes des attaques
- Proposer des mitigations specifiques par type d'attaque
- Score de compromission 0-100

---

### 1.3 Prototype

```rust
/// Point d'entree principal
pub fn analyze_network_events(input: &NetworkInput) -> AnalysisResult;

/// Detecte les attaques ARP spoofing
pub fn detect_arp_spoofing(
    events: &[ArpEvent],
    baseline: &Baseline
) -> Vec<Attack>;

/// Detecte les attaques DHCP
pub fn detect_dhcp_attacks(
    events: &[DhcpEvent],
    baseline: &Baseline
) -> Vec<Attack>;

/// Detecte les attaques DNS spoofing
pub fn detect_dns_spoofing(
    events: &[DnsEvent],
    baseline: &Baseline
) -> Vec<Attack>;

/// Detecte le VLAN hopping
pub fn detect_vlan_hopping(events: &[VlanEvent]) -> Vec<Attack>;

/// Detecte les attaques STP
pub fn detect_stp_attacks(
    events: &[StpEvent],
    baseline: &Baseline
) -> Vec<Attack>;

/// Detecte le LLMNR/NBT-NS poisoning
pub fn detect_llmnr_poisoning(events: &[LlmnrEvent]) -> Vec<Attack>;

/// Correle les attaques en chains
pub fn correlate_attacks(attacks: &[Attack]) -> Vec<AttackChain>;

/// Calcule le score de compromission
pub fn calculate_compromise_score(attacks: &[Attack]) -> CompromiseScore;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 ARP - Le protocole sans memoire

**ARP** (Address Resolution Protocol) n'a pas de mecanisme d'authentification. N'importe qui peut envoyer des reponses ARP non sollicitees (gratuitous ARP), ce qui permet l'ARP spoofing.

### 2.2 La Kaminsky Attack (DNS)

En 2008, Dan Kaminsky a decouvert une faille majeure dans DNS permettant le cache poisoning en masse. Cette decouverte a mene a un patch coordonne de tous les serveurs DNS mondiaux.

### 2.3 LLMNR/NBT-NS - Les protocoles oublies

**LLMNR** (Link-Local Multicast Name Resolution) et **NBT-NS** (NetBIOS Name Service) sont actifs par defaut sur Windows. L'outil **Responder** les exploite pour capturer des hashes NTLMv2.

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

### Network Security Engineer
- Configure DAI, DHCP Snooping, Port Security
- Implemente 802.1X pour le controle d'acces
- Segmente le reseau en VLANs

### Penetration Tester
- Utilise Responder, Bettercap, arpspoof
- Exploite les faiblesses L2 pour le mouvement lateral
- Teste les defenses de segmentation

### SOC Analyst
- Detecte les anomalies ARP/DHCP dans les logs
- Correle les alertes L2 avec les IOCs
- Investigate les incidents de MITM

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo build --release

$ ./target/release/layer2_havoc --input network_events.json
{
  "attacks_detected": [
    {"attack_type": "arp_spoofing", "severity": "critical"},
    {"attack_type": "llmnr_poisoning", "severity": "high"}
  ],
  "correlation_graph": {
    "attack_chains": [
      {"hypothesis": "MITM attack in progress"}
    ]
  },
  "network_compromise_score": {"score": 75, "rating": "critical"}
}

$ cargo test
running 42 tests
...
test result: ok. 42 passed; 0 failed
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Detect ARP spoofing basic | 10 |
| `T02` | Detect ARP flux | 5 |
| `T03` | Detect DHCP starvation | 10 |
| `T04` | Detect rogue DHCP | 10 |
| `T05` | Detect DNS spoofing | 10 |
| `T06` | Detect VLAN hopping | 10 |
| `T07` | Detect STP root takeover | 10 |
| `T08` | Detect LLMNR poisoning | 10 |
| `T09` | Correlate attack chain | 10 |
| `T10` | Distinguish legitimate change | 10 |
| `T11` | Compromise score calculation | 5 |

**Total : 100 points**

---

### 4.3 Solution de reference (extraits)

```rust
pub fn detect_arp_spoofing(
    events: &[ArpEvent],
    baseline: &Baseline
) -> Vec<Attack> {
    let mut attacks = Vec::new();
    let mut ip_to_mac: HashMap<String, HashSet<String>> = HashMap::new();

    // Build IP-to-MAC mapping
    for event in events {
        if event.event_type == "arp_reply" {
            ip_to_mac
                .entry(event.source_ip.clone())
                .or_default()
                .insert(event.source_mac.clone());
        }
    }

    // Check for IP address claimed by multiple MACs
    for (ip, macs) in &ip_to_mac {
        if macs.len() > 1 {
            // Check if this IP is a known gateway
            let known_mac = baseline.known_gateways
                .iter()
                .find(|g| &g.ip == ip)
                .map(|g| &g.mac);

            if let Some(legitimate_mac) = known_mac {
                let spoofed_macs: Vec<_> = macs.iter()
                    .filter(|m| m != &legitimate_mac)
                    .collect();

                for spoofed_mac in spoofed_macs {
                    attacks.push(Attack {
                        attack_id: generate_attack_id(),
                        attack_type: AttackType::ArpSpoofing,
                        severity: Severity::Critical,
                        confidence: 0.95,
                        description: format!(
                            "Gateway IP {} claimed by unknown MAC {}",
                            ip, spoofed_mac
                        ),
                        evidence: AttackEvidence::ArpSpoof {
                            original_mac: legitimate_mac.clone(),
                            spoofed_mac: spoofed_mac.clone(),
                            target_ip: ip.clone(),
                        },
                        mitigation: Mitigation {
                            immediate: format!("Block MAC {} at switch level", spoofed_mac),
                            long_term: "Enable Dynamic ARP Inspection (DAI)".to_string(),
                        },
                    });
                }
            }
        }
    }

    // Check for ARP flux (rapid MAC changes)
    let arp_flux_threshold = 5; // MAC changes in short period
    // ... flux detection logic

    attacks
}

pub fn detect_llmnr_poisoning(events: &[LlmnrEvent]) -> Vec<Attack> {
    let mut attacks = Vec::new();
    let mut responders: HashMap<String, HashSet<String>> = HashMap::new();

    for event in events {
        if event.event_type == "llmnr_response" {
            responders
                .entry(event.query_name.clone())
                .or_default()
                .insert(event.responder_ip.clone());
        }
    }

    // Any LLMNR response could be malicious if we're in a secure environment
    for (query, ips) in responders {
        for ip in ips {
            attacks.push(Attack {
                attack_id: generate_attack_id(),
                attack_type: AttackType::LlmnrPoisoning,
                severity: Severity::High,
                confidence: 0.85,
                description: format!(
                    "LLMNR response from {} for query '{}'",
                    ip, query
                ),
                evidence: AttackEvidence::LlmnrPoison {
                    query_name: query.clone(),
                    malicious_responder: ip.clone(),
                },
                mitigation: Mitigation {
                    immediate: format!("Investigate host {}", ip),
                    long_term: "Disable LLMNR via GPO".to_string(),
                },
            });
        }
    }

    attacks
}

pub fn correlate_attacks(attacks: &[Attack]) -> Vec<AttackChain> {
    let mut chains = Vec::new();

    // Group attacks by source
    let mut by_source: HashMap<String, Vec<&Attack>> = HashMap::new();
    for attack in attacks {
        if let Some(source) = attack.get_source_indicator() {
            by_source.entry(source).or_default().push(attack);
        }
    }

    // Look for MITM patterns
    for (source, source_attacks) in by_source {
        let has_arp = source_attacks.iter().any(|a| a.attack_type == AttackType::ArpSpoofing);
        let has_llmnr = source_attacks.iter().any(|a| a.attack_type == AttackType::LlmnrPoisoning);
        let has_dns = source_attacks.iter().any(|a| a.attack_type == AttackType::DnsSpoofing);

        if has_arp && (has_llmnr || has_dns) {
            chains.push(AttackChain {
                chain_id: generate_chain_id(),
                attacks: source_attacks.iter().map(|a| a.attack_id.clone()).collect(),
                hypothesis: "MITM attack in progress - ARP spoofing combined with name resolution poisoning".to_string(),
                threat_actor_indicators: ThreatActorIndicators {
                    likely_source: source.clone(),
                    tools_suspected: vec!["Responder".to_string(), "Bettercap".to_string()],
                },
            });
        }
    }

    chains
}
```

---

### 4.10 Solutions Mutantes

**Mutant A (Logic) : Ignore les gratuitous ARP**
```rust
// BUG: Ne detecte pas les gratuitous ARP (les plus dangereux)
if event.event_type == "arp_request" { // Devrait inclure arp_reply
```

**Mutant B (Safety) : Pas de baseline check**
```rust
// BUG: Flag tout changement MAC comme attaque
if macs.len() > 1 {
    attacks.push(...); // Manque la verification du baseline
}
```

**Mutant C (Return) : Correlation incomplete**
```rust
// BUG: Ne correle que les attaques du meme type
fn correlate_attacks(attacks: &[Attack]) -> Vec<AttackChain> {
    // Manque la correlation cross-type (ARP + LLMNR)
}
```

**Mutant D (Boundary) : Seuil DHCP trop bas**
```rust
// BUG: Detecte le DHCP legitime comme starvation
let starvation_threshold = 3; // Devrait etre ~50
```

**Mutant E (Logic) : Score inversÃ©**
```rust
// BUG: Plus d'attaques = meilleur score
score: 100 - attacks.len() * 10, // Devrait etre: attacks.len() * 10
```

---

## ğŸ§  SECTION 5 : COMPRENDRE (extraits)

### 5.3 Visualisation ASCII

```
ARP SPOOFING ATTACK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Normal state:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Victim    â”‚â—„â”€â”€â”€â”€â”€â”€ARPâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   Gateway   â”‚
â”‚ 192.168.1.10â”‚  MAC: AA:BB:..01   â”‚ 192.168.1.1 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After ARP spoofing:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Victim    â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚   Attacker  â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚   Gateway   â”‚
â”‚ 192.168.1.10â”‚        â”‚ 192.168.1.50â”‚        â”‚ 192.168.1.1 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ MAC: ..99   â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚  MITM!      â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Victim thinks:  Gateway = AA:BB:CC:DD:EE:99 (WRONG!)
Gateway thinks: Victim = AA:BB:CC:DD:EE:99  (WRONG!)


LLMNR/NBT-NS POISONING (Responder)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Victim broadcasts: "Who has 'fileserver'?"
                â”‚
                â–¼
2. Responder answers: "I do! (malicious IP)"
                â”‚
                â–¼
3. Victim connects to Responder
                â”‚
                â–¼
4. Responder captures NTLM hash
```

---

### 5.8 Mnemotechniques

#### ğŸ® MEME : "Watch Dogs - Everything is hackable"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  ğŸ® ctOS SECURITY CHECKLIST                                    â”‚
â”‚                                                                 â”‚
â”‚  ARP Spoofing = "Hijacking the streets"                        â”‚
â”‚  â†’ Tout le trafic passe par l'attaquant                        â”‚
â”‚                                                                 â”‚
â”‚  DHCP Starvation = "Stealing all the parking spots"            â”‚
â”‚  â†’ Plus personne ne peut se connecter                          â”‚
â”‚                                                                 â”‚
â”‚  LLMNR Poisoning = "Fake street signs"                         â”‚
â”‚  â†’ Les victimes vont au mauvais endroit                        â”‚
â”‚                                                                 â”‚
â”‚  STP Attack = "Taking control of traffic lights"               â”‚
â”‚  â†’ L'attaquant devient le point central                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.2.4-a-layer2-havoc",
    "metadata": {
      "exercise_id": "3.2.08",
      "exercise_name": "layer2_havoc",
      "module": "3.2.4",
      "module_name": "Network Attacks",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 400,
      "tags": ["arp", "dhcp", "llmnr", "mitm", "layer2", "detection"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Layer 2 Havoc*
*"Detecter le chaos avant qu'il ne se propage"*