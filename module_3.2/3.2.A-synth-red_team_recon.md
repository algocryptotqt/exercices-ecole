# Projet 3.2.A : red_team_recon

**Module :**
3.2 ‚Äî Network Security (SYNTH√àSE)

**Concept :**
synth ‚Äî Reconnaissance Pipeline Complet (24 concepts int√©gr√©s)

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ (10/10)

**Type :**
complet

**Tiers :**
3 ‚Äî Synth√®se (tous concepts 3.2.1 + 3.2.2)

**Langage :**
Rust Edition 2024

**Pr√©requis :**
- Tous les exercices 3.2.01 √† 3.2.05
- 3.2.1.a-k (OSINT, 11 concepts)
- 3.2.2.a-m (Scanning, 13 concepts)
- Structures de donn√©es avanc√©es

**Domaines :**
Net, Struct, MD, Probas

**Dur√©e estim√©e :**
900-1200 min (15-20 heures)

**XP Base :**
1000

**Complexit√© :**
T9 O(n √ó m √ó log n) √ó S8 O(n √ó m)
*o√π n = sources, m = entit√©s d√©couvertes*

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers √† rendre :**
- `red_team_recon.rs` (module principal)
- `osint_engine.rs` (moteur OSINT)
- `scan_engine.rs` (moteur scanning)
- `correlator.rs` (corr√©lation)
- `reporter.rs` (g√©n√©ration rapport)

**Fonctions autoris√©es :**
- `std::collections::{HashMap, HashSet, BTreeMap, BinaryHeap}`
- `std::io::{Read, Write}`
- `serde_json`, `serde`
- `regex` pour parsing
- Algorithmes personnalis√©s

**Fonctions interdites :**
- Biblioth√®ques r√©seau r√©elles
- DNS/HTTP clients
- Toute connexion externe

### 1.2 Consigne

#### üé¨ Version Culture : "GHOST IN THE SHELL ‚Äî Section 9 Recon Unit"

**"The net is vast and infinite."** ‚Äî Major Motoko Kusanagi

Dans l'univers de *Ghost in the Shell*, la Section 9 est une unit√© d'√©lite de cyber-op√©rations qui excelle dans la collecte de renseignements. Avant chaque mission, ils construisent une image compl√®te de leur cible en fusionnant des sources multiples : donn√©es publiques, interceptions r√©seau, reconnaissance active.

Tu es le nouveau **Tachikoma** (robot de support) de la Section 9. Ta mission : construire un **pipeline de reconnaissance automatis√©** capable de :

1. **"Diving"** (Plong√©e) ‚Äî Collecter des donn√©es OSINT
   - Comme quand Motoko "plonge" dans le net, tu dois ing√©rer des donn√©es multi-sources
   - DNS records, WHOIS, Shodan, m√©tadonn√©es, r√©seaux sociaux

2. **"Ghost Hacking"** (Analyse) ‚Äî Corr√©ler et d√©dupliquer
   - Les Tachikomas partagent leur m√©moire : tu dois fusionner les infos
   - Identifier les entit√©s uniques malgr√© les variations

3. **"Stand Alone Complex"** ‚Äî Mod√©liser l'infrastructure
   - Construire un graphe de l'infrastructure cible
   - Relations entre domaines, IPs, services, personnes

4. **"Laughing Man Protocol"** ‚Äî Identifier les vecteurs d'attaque
   - Prioriser les vuln√©rabilit√©s
   - Calculer un score de risque

5. **"Puppet Master Report"** ‚Äî G√©n√©rer le rapport
   - Executive summary pour le chef Aramaki
   - D√©tails techniques pour Batou et l'√©quipe

**La citation cl√© :**
> *"If a technological feat is possible, man will do it. Almost as if it's wired into the core of our being."*

C'est exactement ce que fait un bon reconnaissance : d√©couvrir TOUT ce qui est techniquement d√©couvrable.

#### 1.2.2 Version Acad√©mique

**Contexte technique :**

La **reconnaissance** est la premi√®re phase de tout test d'intrusion. Elle consiste √† collecter un maximum d'informations sur une cible avant toute action offensive. Un pipeline de reconnaissance professionnel doit :

1. **Ing√©rer des donn√©es multi-sources** :
   - OSINT passif (DNS, WHOIS, archives web)
   - Scanning actif (ports, services, versions)
   - √ânum√©ration (subdomains, directories)

2. **Corr√©ler et d√©dupliquer** :
   - Fusionner les donn√©es de sources diff√©rentes
   - Identifier les entit√©s uniques
   - R√©soudre les conflits d'information

3. **Mod√©liser l'infrastructure** :
   - Graphe de relations entre entit√©s
   - Topologie r√©seau inf√©r√©e
   - Cartographie des actifs

4. **Prioriser les vecteurs d'attaque** :
   - Scoring de vuln√©rabilit√©
   - Classification par criticit√©
   - Recommandations d'exploitation

5. **G√©n√©rer un rapport professionnel** :
   - Executive summary
   - Findings d√©taill√©s
   - Plan d'action recommand√©

**Entr√©e :**
```json
{
  "target": {
    "primary_domain": "example.com",
    "scope": ["*.example.com", "192.168.1.0/24"]
  },
  "data_sources": {
    "dns_records": [
      {"domain": "example.com", "type": "A", "value": "192.168.1.10"},
      {"domain": "mail.example.com", "type": "MX", "value": "10 smtp.example.com"},
      {"domain": "www.example.com", "type": "CNAME", "value": "example.com"}
    ],
    "whois_data": {
      "domain": "example.com",
      "registrant": "ACME Corp",
      "registrant_email": "admin@example.com",
      "creation_date": "2010-01-15",
      "name_servers": ["ns1.example.com", "ns2.example.com"]
    },
    "shodan_results": [
      {
        "ip": "192.168.1.10",
        "ports": [22, 80, 443],
        "services": [
          {"port": 22, "service": "SSH", "version": "OpenSSH 7.9", "banner": "SSH-2.0-OpenSSH_7.9"},
          {"port": 80, "service": "HTTP", "version": "nginx/1.18.0"},
          {"port": 443, "service": "HTTPS", "version": "nginx/1.18.0"}
        ],
        "vulns": ["CVE-2021-44228"]
      }
    ],
    "subdomain_enum": [
      {"subdomain": "www.example.com", "ip": "192.168.1.10"},
      {"subdomain": "mail.example.com", "ip": "192.168.1.11"},
      {"subdomain": "dev.example.com", "ip": "192.168.1.20"},
      {"subdomain": "staging.example.com", "ip": "192.168.1.21"}
    ],
    "port_scans": [
      {
        "ip": "192.168.1.10",
        "ports": [
          {"port": 22, "state": "open", "service": "ssh", "version": "OpenSSH 7.9"},
          {"port": 80, "state": "open", "service": "http", "version": "nginx 1.18.0"},
          {"port": 443, "state": "open", "service": "https", "version": "nginx 1.18.0"}
        ]
      },
      {
        "ip": "192.168.1.11",
        "ports": [
          {"port": 25, "state": "open", "service": "smtp", "version": "Postfix"},
          {"port": 143, "state": "open", "service": "imap", "version": "Dovecot"}
        ]
      }
    ],
    "social_osint": [
      {"platform": "linkedin", "name": "John Admin", "title": "IT Administrator", "company": "ACME Corp"},
      {"platform": "github", "username": "acme-dev", "repos": ["internal-tools", "config-backups"]}
    ],
    "metadata_extracted": [
      {"file": "report.pdf", "author": "jadmin", "software": "Microsoft Word 2019", "created": "2023-05-10"},
      {"file": "diagram.png", "gps": null, "camera": null, "software": "draw.io"}
    ]
  }
}
```

**Sortie :**
```json
{
  "infrastructure_model": {
    "entities": [
      {
        "id": "host-001",
        "type": "server",
        "hostnames": ["example.com", "www.example.com"],
        "ip": "192.168.1.10",
        "services": [
          {"port": 22, "service": "SSH", "version": "OpenSSH 7.9"},
          {"port": 80, "service": "HTTP", "version": "nginx 1.18.0"},
          {"port": 443, "service": "HTTPS", "version": "nginx 1.18.0"}
        ],
        "vulns": ["CVE-2021-44228"],
        "criticality": "high"
      }
    ],
    "relationships": [
      {"from": "host-001", "to": "host-002", "type": "same_network"},
      {"from": "domain-001", "to": "host-001", "type": "resolves_to"}
    ],
    "network_topology": {
      "segments": [
        {"cidr": "192.168.1.0/24", "hosts": ["host-001", "host-002", "host-003", "host-004"]}
      ]
    }
  },
  "attack_vectors": [
    {
      "id": "AV-001",
      "name": "Log4Shell RCE",
      "target": "host-001",
      "cve": "CVE-2021-44228",
      "cvss": 10.0,
      "priority": 1,
      "exploitation_path": "HTTP request with malicious JNDI lookup",
      "prerequisites": ["Network access to port 443"]
    },
    {
      "id": "AV-002",
      "name": "SSH Bruteforce",
      "target": "host-001",
      "cvss": 5.0,
      "priority": 3,
      "prerequisites": ["Valid username", "Weak password"]
    }
  ],
  "intelligence_summary": {
    "organization": "ACME Corp",
    "key_personnel": [
      {"name": "John Admin", "role": "IT Administrator", "email_pattern": "jadmin@example.com"}
    ],
    "technology_stack": ["nginx", "OpenSSH", "Postfix", "Dovecot", "Microsoft Office"],
    "exposed_assets": 4,
    "critical_vulns": 1,
    "high_vulns": 0,
    "medium_vulns": 2
  },
  "report": {
    "executive_summary": "The reconnaissance of example.com revealed 4 internet-facing assets with 1 critical vulnerability (CVE-2021-44228). Immediate remediation is recommended.",
    "risk_score": 8.5,
    "recommendations": [
      {
        "priority": 1,
        "action": "Patch Log4j vulnerability on 192.168.1.10",
        "impact": "Prevents remote code execution"
      },
      {
        "priority": 2,
        "action": "Implement SSH key-based authentication",
        "impact": "Reduces bruteforce risk"
      }
    ],
    "attack_plan": [
      "Phase 1: Exploit CVE-2021-44228 on www.example.com",
      "Phase 2: Establish persistence on web server",
      "Phase 3: Pivot to internal network via 192.168.1.0/24",
      "Phase 4: Enumerate mail server (192.168.1.11)"
    ]
  }
}
```

**Contraintes :**
- ‚â§ 1000 entit√©s (hosts, domains, IPs)
- ‚â§ 10000 relationships
- ‚â§ 100 sources de donn√©es
- G√©n√©ration de rapport < 5 secondes

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, BTreeMap};

// ============ STRUCTURES D'ENTR√âE ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReconInput {
    pub target: TargetScope,
    pub data_sources: DataSources,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetScope {
    pub primary_domain: String,
    pub scope: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataSources {
    pub dns_records: Vec<DnsRecord>,
    pub whois_data: Option<WhoisData>,
    pub shodan_results: Vec<ShodanResult>,
    pub subdomain_enum: Vec<SubdomainResult>,
    pub port_scans: Vec<PortScanResult>,
    pub social_osint: Vec<SocialOsint>,
    pub metadata_extracted: Vec<MetadataResult>,
}

// ... autres structures d'entr√©e ...

// ============ STRUCTURES DE SORTIE ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReconOutput {
    pub infrastructure_model: InfrastructureModel,
    pub attack_vectors: Vec<AttackVector>,
    pub intelligence_summary: IntelligenceSummary,
    pub report: Report,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InfrastructureModel {
    pub entities: Vec<Entity>,
    pub relationships: Vec<Relationship>,
    pub network_topology: NetworkTopology,
}

// ============ FONCTIONS PRINCIPALES ============

/// Point d'entr√©e principal du pipeline
pub fn run_recon_pipeline(input: &ReconInput) -> ReconOutput;

// Module OSINT
pub mod osint_engine {
    pub fn process_dns_records(records: &[DnsRecord]) -> Vec<DnsIntel>;
    pub fn process_whois(whois: &WhoisData) -> OrgIntel;
    pub fn process_shodan(results: &[ShodanResult]) -> Vec<HostIntel>;
    pub fn process_social_osint(social: &[SocialOsint]) -> Vec<PersonIntel>;
    pub fn extract_metadata_intel(metadata: &[MetadataResult]) -> Vec<MetaIntel>;
}

// Module Scanning
pub mod scan_engine {
    pub fn process_port_scans(scans: &[PortScanResult]) -> Vec<ServiceIntel>;
    pub fn process_subdomain_enum(subs: &[SubdomainResult]) -> Vec<SubdomainIntel>;
    pub fn detect_service_versions(services: &[ServiceIntel]) -> Vec<VersionIntel>;
    pub fn identify_vulnerabilities(versions: &[VersionIntel]) -> Vec<VulnIntel>;
}

// Module Corr√©lation
pub mod correlator {
    pub fn merge_intel_sources(sources: Vec<Box<dyn Intel>>) -> Vec<Entity>;
    pub fn deduplicate_entities(entities: &mut Vec<Entity>);
    pub fn build_relationships(entities: &[Entity]) -> Vec<Relationship>;
    pub fn infer_network_topology(entities: &[Entity]) -> NetworkTopology;
}

// Module Rapport
pub mod reporter {
    pub fn calculate_risk_score(model: &InfrastructureModel) -> f64;
    pub fn prioritize_attack_vectors(vectors: &mut Vec<AttackVector>);
    pub fn generate_executive_summary(model: &InfrastructureModel, vectors: &[AttackVector]) -> String;
    pub fn generate_recommendations(vectors: &[AttackVector]) -> Vec<Recommendation>;
    pub fn generate_attack_plan(vectors: &[AttackVector], model: &InfrastructureModel) -> Vec<String>;
}
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Le Cycle du Renseignement

La reconnaissance en cybers√©curit√© suit le m√™me cycle que le renseignement militaire :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    INTELLIGENCE CYCLE                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                             ‚îÇ
‚îÇ                    ‚îÇ   PLANNING   ‚îÇ                             ‚îÇ
‚îÇ                    ‚îÇ  (Targeting) ‚îÇ                             ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                             ‚îÇ
‚îÇ                           ‚îÇ                                     ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ    ‚îÇ                      ‚ñº                      ‚îÇ              ‚îÇ
‚îÇ    ‚îÇ               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ              ‚îÇ
‚îÇ    ‚îÇ               ‚îÇ  COLLECTION  ‚îÇ              ‚îÇ              ‚îÇ
‚îÇ    ‚îÇ               ‚îÇ   (OSINT,    ‚îÇ              ‚îÇ              ‚îÇ
‚îÇ    ‚îÇ               ‚îÇ   Scanning)  ‚îÇ              ‚îÇ              ‚îÇ
‚îÇ    ‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ              ‚îÇ
‚îÇ    ‚îÇ                      ‚îÇ                      ‚îÇ              ‚îÇ
‚îÇ    ‚ñº                      ‚ñº                      ‚ñº              ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ ‚îÇDISSEM-   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  ANALYSIS    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇPRODUCTION‚îÇ         ‚îÇ
‚îÇ ‚îÇINATION   ‚îÇ       ‚îÇ(Correlation) ‚îÇ       ‚îÇ (Report) ‚îÇ         ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Sources OSINT Professionnelles

| Source | Type | Informations |
|--------|------|--------------|
| **DNS** | Passif | Subdomains, mail servers, TXT records |
| **WHOIS** | Passif | Registrant, dates, nameservers |
| **Shodan/Censys** | Passif | Ports, services, vuln√©rabilit√©s |
| **Wayback Machine** | Passif | Historique, anciennes pages |
| **LinkedIn** | Passif | Personnel, technologies utilis√©es |
| **GitHub** | Passif | Code source, secrets expos√©s |
| **Nmap** | Actif | Ports, versions exactes, OS |
| **Directory brute** | Actif | Chemins cach√©s, admin panels |

### 2.3 Corr√©lation d'Entit√©s

Le d√©fi majeur est de **fusionner** des informations de sources diff√©rentes qui d√©crivent la m√™me entit√© :

```
Source DNS:     www.example.com ‚Üí 192.168.1.10
Source Shodan:  192.168.1.10 ‚Üí nginx/1.18.0
Source Scan:    192.168.1.10:80 ‚Üí HTTP (nginx)

                         ‚Üì CORR√âLATION

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ENTIT√â UNIFI√âE: host-001                                       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Hostnames: [www.example.com, example.com]                  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ IP: 192.168.1.10                                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Services:                                                  ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ Port 80: HTTP (nginx 1.18.0)                           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Source confidence: HIGH (3 sources concordantes)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.4 DANS LA VRAIE VIE

| M√©tier | Application |
|--------|-------------|
| **Pentester** | Construit ce pipeline avant chaque engagement |
| **Red Teamer** | √âtend avec des sources non-techniques (HUMINT) |
| **Bug Bounty Hunter** | Automatise pour couvrir large scope rapidement |
| **Threat Intelligence** | Adapte pour surveiller les acteurs malveillants |
| **SOC Analyst** | Utilise pour enrichir les IOCs avec contexte |

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
red_team_recon.rs  osint_engine.rs  scan_engine.rs  correlator.rs  reporter.rs  main.rs  Cargo.toml

$ cargo build --release

$ cat input.json | ./target/release/red_team_recon
{
  "infrastructure_model": {
    "entities": [
      {
        "id": "host-001",
        "type": "server",
        "hostnames": ["example.com", "www.example.com"],
        "ip": "192.168.1.10",
        "services": [...],
        "vulns": ["CVE-2021-44228"],
        "criticality": "high"
      },
      ...
    ],
    "relationships": [...],
    "network_topology": {...}
  },
  "attack_vectors": [
    {
      "id": "AV-001",
      "name": "Log4Shell RCE",
      "cvss": 10.0,
      "priority": 1
    },
    ...
  ],
  "intelligence_summary": {
    "organization": "ACME Corp",
    "exposed_assets": 4,
    "critical_vulns": 1
  },
  "report": {
    "executive_summary": "...",
    "risk_score": 8.5,
    "recommendations": [...],
    "attack_plan": [...]
  }
}
```

---

## ‚ö° SECTION 3.1 : BONUS WIZARD (OPTIONNEL)

**Difficult√© Bonus :**
üîÆ (35/10)

**R√©compense :**
XP √ó20

**Domaines Bonus :**
`ML, Probas, Graphes`

### 3.1.1 Consigne Bonus

**üé¨ "Le Puppet Master ‚Äî Intelligence Artificielle"**

Dans Ghost in the Shell, le Puppet Master est une IA qui a √©volu√© au-del√† de sa programmation initiale. Pour ce bonus, ton pipeline doit inclure des capacit√©s d'analyse avanc√©e :

1. **Graph Analysis** :
   - Calcul de centralit√© (PageRank) pour identifier les assets critiques
   - D√©tection de communaut√©s (Louvain) pour segmenter le r√©seau
   - Shortest path entre attaquant et cibles prioritaires

2. **Probabilistic Scoring** :
   - Mod√®le bay√©sien pour la confiance des donn√©es
   - Fusion de sources avec pond√©ration dynamique
   - Incertitude quantifi√©e dans le rapport

3. **Attack Path Optimization** :
   - Algorithme g√©n√©tique pour trouver le meilleur chemin d'attaque
   - Multi-objectif : minimiser d√©tection, maximiser impact
   - Simulation Monte Carlo pour robustesse

4. **Natural Language Generation** :
   - G√©n√©ration automatique de l'executive summary
   - Adaptation du ton selon l'audience (technique/ex√©cutif)
   - Templates contextuels

### 3.1.2 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Scoring | CVSS simple | Bayesian + Monte Carlo |
| Graphe | Relations simples | PageRank + Louvain |
| Attack path | Liste s√©quentielle | Genetic algorithm |
| Rapport | Template fixe | NLG adaptatif |
| Complexit√© | O(n √ó m) | O(n¬≤ √ó iterations) |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | Entr√©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_dns_parsing` | 5 DNS records | 5 DnsIntel objects | 5 |
| `test_whois_extraction` | WHOIS data | OrgIntel with all fields | 5 |
| `test_entity_dedup` | Duplicate hostnames/IPs | Single entity | 10 |
| `test_relationship_build` | 10 entities | Correct relationships | 10 |
| `test_vuln_identification` | OpenSSH 7.9 | Known CVEs listed | 10 |
| `test_cvss_priority` | Multiple vulns | Sorted by CVSS | 10 |
| `test_network_topology` | IPs in same /24 | Grouped correctly | 10 |
| `test_risk_score` | 1 critical vuln | Score > 8.0 | 10 |
| `test_executive_summary` | Full input | Non-empty summary | 10 |
| `test_attack_plan` | Vulns + topology | Logical attack sequence | 10 |
| `test_full_pipeline` | Complete dataset | Valid ReconOutput | 10 |

### 4.2 main.rs de test

```rust
use red_team_recon::*;
use serde_json;

fn main() {
    // Test 1: Basic DNS parsing
    let dns_records = vec![
        DnsRecord { domain: "example.com".to_string(), record_type: "A".to_string(), value: "192.168.1.10".to_string() },
        DnsRecord { domain: "www.example.com".to_string(), record_type: "CNAME".to_string(), value: "example.com".to_string() },
    ];

    let dns_intel = osint_engine::process_dns_records(&dns_records);
    assert_eq!(dns_intel.len(), 2);
    println!("Test 1 (DNS parsing): OK");

    // Test 2: Entity deduplication
    let mut entities = vec![
        Entity { id: "1".to_string(), hostnames: vec!["example.com".to_string()], ip: Some("192.168.1.10".to_string()), ..Default::default() },
        Entity { id: "2".to_string(), hostnames: vec!["www.example.com".to_string()], ip: Some("192.168.1.10".to_string()), ..Default::default() },
    ];

    correlator::deduplicate_entities(&mut entities);
    assert_eq!(entities.len(), 1);
    assert!(entities[0].hostnames.contains(&"example.com".to_string()));
    assert!(entities[0].hostnames.contains(&"www.example.com".to_string()));
    println!("Test 2 (Entity deduplication): OK");

    // Test 3: Vulnerability identification
    let versions = vec![
        VersionIntel { service: "OpenSSH".to_string(), version: "7.9".to_string(), port: 22 },
    ];

    let vulns = scan_engine::identify_vulnerabilities(&versions);
    assert!(!vulns.is_empty());
    println!("Test 3 (Vulnerability identification): OK");

    // Test 4: Full pipeline
    let input_json = r#"{
        "target": {
            "primary_domain": "example.com",
            "scope": ["*.example.com"]
        },
        "data_sources": {
            "dns_records": [
                {"domain": "example.com", "type": "A", "value": "192.168.1.10"}
            ],
            "whois_data": {
                "domain": "example.com",
                "registrant": "ACME Corp",
                "registrant_email": "admin@example.com",
                "creation_date": "2010-01-15",
                "name_servers": ["ns1.example.com"]
            },
            "shodan_results": [],
            "subdomain_enum": [],
            "port_scans": [
                {
                    "ip": "192.168.1.10",
                    "ports": [
                        {"port": 80, "state": "open", "service": "http", "version": "nginx 1.18.0"}
                    ]
                }
            ],
            "social_osint": [],
            "metadata_extracted": []
        }
    }"#;

    let input: ReconInput = serde_json::from_str(input_json).unwrap();
    let output = run_recon_pipeline(&input);

    assert!(!output.infrastructure_model.entities.is_empty());
    assert!(!output.report.executive_summary.is_empty());
    println!("Test 4 (Full pipeline): OK");

    println!("\nAll tests passed!");
}
```

### 4.3 Solution de r√©f√©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, BTreeMap};

// ============ STRUCTURES D'ENTR√âE ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReconInput {
    pub target: TargetScope,
    pub data_sources: DataSources,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetScope {
    pub primary_domain: String,
    pub scope: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataSources {
    pub dns_records: Vec<DnsRecord>,
    pub whois_data: Option<WhoisData>,
    pub shodan_results: Vec<ShodanResult>,
    pub subdomain_enum: Vec<SubdomainResult>,
    pub port_scans: Vec<PortScanResult>,
    pub social_osint: Vec<SocialOsint>,
    pub metadata_extracted: Vec<MetadataResult>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DnsRecord {
    pub domain: String,
    #[serde(rename = "type")]
    pub record_type: String,
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WhoisData {
    pub domain: String,
    pub registrant: String,
    pub registrant_email: String,
    pub creation_date: String,
    pub name_servers: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShodanResult {
    pub ip: String,
    pub ports: Vec<u16>,
    pub services: Vec<ShodanService>,
    pub vulns: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShodanService {
    pub port: u16,
    pub service: String,
    pub version: String,
    pub banner: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubdomainResult {
    pub subdomain: String,
    pub ip: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortScanResult {
    pub ip: String,
    pub ports: Vec<PortInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortInfo {
    pub port: u16,
    pub state: String,
    pub service: String,
    pub version: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SocialOsint {
    pub platform: String,
    pub name: Option<String>,
    pub username: Option<String>,
    pub title: Option<String>,
    pub company: Option<String>,
    pub repos: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetadataResult {
    pub file: String,
    pub author: Option<String>,
    pub software: Option<String>,
    pub created: Option<String>,
    pub gps: Option<String>,
    pub camera: Option<String>,
}

// ============ STRUCTURES DE SORTIE ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReconOutput {
    pub infrastructure_model: InfrastructureModel,
    pub attack_vectors: Vec<AttackVector>,
    pub intelligence_summary: IntelligenceSummary,
    pub report: Report,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Entity {
    pub id: String,
    pub entity_type: String,
    pub hostnames: Vec<String>,
    pub ip: Option<String>,
    pub services: Vec<ServiceInfo>,
    pub vulns: Vec<String>,
    pub criticality: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub port: u16,
    pub service: String,
    pub version: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InfrastructureModel {
    pub entities: Vec<Entity>,
    pub relationships: Vec<Relationship>,
    pub network_topology: NetworkTopology,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Relationship {
    pub from: String,
    pub to: String,
    pub relationship_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTopology {
    pub segments: Vec<NetworkSegment>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkSegment {
    pub cidr: String,
    pub hosts: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttackVector {
    pub id: String,
    pub name: String,
    pub target: String,
    pub cve: Option<String>,
    pub cvss: f64,
    pub priority: u8,
    pub exploitation_path: String,
    pub prerequisites: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IntelligenceSummary {
    pub organization: String,
    pub key_personnel: Vec<Personnel>,
    pub technology_stack: Vec<String>,
    pub exposed_assets: usize,
    pub critical_vulns: usize,
    pub high_vulns: usize,
    pub medium_vulns: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Personnel {
    pub name: String,
    pub role: String,
    pub email_pattern: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Report {
    pub executive_summary: String,
    pub risk_score: f64,
    pub recommendations: Vec<Recommendation>,
    pub attack_plan: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Recommendation {
    pub priority: u8,
    pub action: String,
    pub impact: String,
}

// ============ MODULE OSINT ============

pub mod osint_engine {
    use super::*;

    pub fn process_dns_records(records: &[DnsRecord]) -> HashMap<String, Vec<String>> {
        let mut domain_to_ips: HashMap<String, Vec<String>> = HashMap::new();

        for record in records {
            match record.record_type.as_str() {
                "A" | "AAAA" => {
                    domain_to_ips.entry(record.domain.clone())
                        .or_insert_with(Vec::new)
                        .push(record.value.clone());
                }
                "CNAME" => {
                    // Resolve CNAME by finding the A record of the target
                    if let Some(ips) = domain_to_ips.get(&record.value) {
                        domain_to_ips.entry(record.domain.clone())
                            .or_insert_with(Vec::new)
                            .extend(ips.clone());
                    }
                }
                _ => {}
            }
        }

        domain_to_ips
    }

    pub fn process_whois(whois: &WhoisData) -> (String, String) {
        (whois.registrant.clone(), whois.registrant_email.clone())
    }

    pub fn process_shodan(results: &[ShodanResult]) -> HashMap<String, (Vec<ServiceInfo>, Vec<String>)> {
        let mut ip_intel: HashMap<String, (Vec<ServiceInfo>, Vec<String>)> = HashMap::new();

        for result in results {
            let services: Vec<ServiceInfo> = result.services.iter()
                .map(|s| ServiceInfo {
                    port: s.port,
                    service: s.service.clone(),
                    version: s.version.clone(),
                })
                .collect();

            ip_intel.insert(result.ip.clone(), (services, result.vulns.clone()));
        }

        ip_intel
    }

    pub fn process_social_osint(social: &[SocialOsint]) -> Vec<Personnel> {
        social.iter()
            .filter_map(|s| {
                s.name.as_ref().map(|name| Personnel {
                    name: name.clone(),
                    role: s.title.clone().unwrap_or_else(|| "Unknown".to_string()),
                    email_pattern: None,
                })
            })
            .collect()
    }

    pub fn extract_technology_stack(
        metadata: &[MetadataResult],
        services: &[ServiceInfo]
    ) -> Vec<String> {
        let mut stack: HashSet<String> = HashSet::new();

        for meta in metadata {
            if let Some(ref sw) = meta.software {
                stack.insert(sw.clone());
            }
        }

        for service in services {
            stack.insert(format!("{}", service.service));
        }

        stack.into_iter().collect()
    }
}

// ============ MODULE SCAN ============

pub mod scan_engine {
    use super::*;

    pub fn process_port_scans(scans: &[PortScanResult]) -> HashMap<String, Vec<ServiceInfo>> {
        let mut ip_services: HashMap<String, Vec<ServiceInfo>> = HashMap::new();

        for scan in scans {
            let services: Vec<ServiceInfo> = scan.ports.iter()
                .filter(|p| p.state == "open")
                .map(|p| ServiceInfo {
                    port: p.port,
                    service: p.service.clone(),
                    version: p.version.clone(),
                })
                .collect();

            ip_services.insert(scan.ip.clone(), services);
        }

        ip_services
    }

    pub fn process_subdomain_enum(subs: &[SubdomainResult]) -> HashMap<String, String> {
        subs.iter()
            .map(|s| (s.subdomain.clone(), s.ip.clone()))
            .collect()
    }

    pub fn identify_vulnerabilities(version: &str, service: &str) -> Vec<String> {
        let mut vulns = Vec::new();

        // Simulated vulnerability database
        if service.to_lowercase().contains("openssh") {
            if version.contains("7.") || version.contains("6.") {
                vulns.push("CVE-2020-15778".to_string());
            }
        }

        if service.to_lowercase().contains("nginx") {
            if version.contains("1.18") || version.contains("1.17") {
                vulns.push("CVE-2021-23017".to_string());
            }
        }

        if service.to_lowercase().contains("apache") {
            vulns.push("CVE-2021-41773".to_string());
        }

        vulns
    }

    pub fn get_cvss_score(cve: &str) -> f64 {
        // Simulated CVSS database
        match cve {
            "CVE-2021-44228" => 10.0,
            "CVE-2021-41773" => 7.5,
            "CVE-2021-23017" => 5.3,
            "CVE-2020-15778" => 6.8,
            _ => 5.0,
        }
    }
}

// ============ MODULE CORRELATOR ============

pub mod correlator {
    use super::*;

    pub fn build_entities(
        dns_intel: &HashMap<String, Vec<String>>,
        shodan_intel: &HashMap<String, (Vec<ServiceInfo>, Vec<String>)>,
        port_scans: &HashMap<String, Vec<ServiceInfo>>,
        subdomain_intel: &HashMap<String, String>,
    ) -> Vec<Entity> {
        let mut entities: Vec<Entity> = Vec::new();
        let mut ip_to_entity: HashMap<String, usize> = HashMap::new();
        let mut entity_id = 0;

        // First pass: create entities from port scans and shodan
        let mut all_ips: HashSet<String> = HashSet::new();
        all_ips.extend(port_scans.keys().cloned());
        all_ips.extend(shodan_intel.keys().cloned());
        all_ips.extend(subdomain_intel.values().cloned());

        for ip in all_ips {
            entity_id += 1;
            let id = format!("host-{:03}", entity_id);

            // Gather hostnames for this IP
            let mut hostnames: Vec<String> = Vec::new();
            for (domain, ips) in dns_intel {
                if ips.contains(&ip) {
                    hostnames.push(domain.clone());
                }
            }
            for (subdomain, sub_ip) in subdomain_intel {
                if sub_ip == &ip && !hostnames.contains(subdomain) {
                    hostnames.push(subdomain.clone());
                }
            }

            // Gather services
            let mut services: Vec<ServiceInfo> = Vec::new();
            if let Some(scan_services) = port_scans.get(&ip) {
                services.extend(scan_services.clone());
            }
            if let Some((shodan_services, _)) = shodan_intel.get(&ip) {
                for ss in shodan_services {
                    if !services.iter().any(|s| s.port == ss.port) {
                        services.push(ss.clone());
                    }
                }
            }

            // Gather vulns
            let mut vulns: Vec<String> = Vec::new();
            if let Some((_, shodan_vulns)) = shodan_intel.get(&ip) {
                vulns.extend(shodan_vulns.clone());
            }

            // Determine criticality
            let criticality = if vulns.iter().any(|v| scan_engine::get_cvss_score(v) >= 9.0) {
                "critical"
            } else if vulns.iter().any(|v| scan_engine::get_cvss_score(v) >= 7.0) {
                "high"
            } else if !vulns.is_empty() {
                "medium"
            } else {
                "low"
            };

            entities.push(Entity {
                id: id.clone(),
                entity_type: "server".to_string(),
                hostnames,
                ip: Some(ip.clone()),
                services,
                vulns,
                criticality: criticality.to_string(),
            });

            ip_to_entity.insert(ip, entities.len() - 1);
        }

        entities
    }

    pub fn deduplicate_entities(entities: &mut Vec<Entity>) {
        // Group by IP
        let mut ip_groups: HashMap<String, Vec<usize>> = HashMap::new();

        for (idx, entity) in entities.iter().enumerate() {
            if let Some(ref ip) = entity.ip {
                ip_groups.entry(ip.clone()).or_insert_with(Vec::new).push(idx);
            }
        }

        // Merge entities with same IP
        let mut to_remove: Vec<usize> = Vec::new();

        for (_, indices) in ip_groups {
            if indices.len() > 1 {
                let first = indices[0];

                for &other in &indices[1..] {
                    // Merge hostnames
                    let other_hostnames = entities[other].hostnames.clone();
                    for hostname in other_hostnames {
                        if !entities[first].hostnames.contains(&hostname) {
                            entities[first].hostnames.push(hostname);
                        }
                    }

                    // Merge services
                    let other_services = entities[other].services.clone();
                    for service in other_services {
                        if !entities[first].services.iter().any(|s| s.port == service.port) {
                            entities[first].services.push(service);
                        }
                    }

                    // Merge vulns
                    let other_vulns = entities[other].vulns.clone();
                    for vuln in other_vulns {
                        if !entities[first].vulns.contains(&vuln) {
                            entities[first].vulns.push(vuln);
                        }
                    }

                    to_remove.push(other);
                }
            }
        }

        // Remove duplicates (reverse order to preserve indices)
        to_remove.sort();
        to_remove.reverse();
        for idx in to_remove {
            entities.remove(idx);
        }
    }

    pub fn build_relationships(entities: &[Entity]) -> Vec<Relationship> {
        let mut relationships: Vec<Relationship> = Vec::new();

        // Same network relationships
        for i in 0..entities.len() {
            for j in (i + 1)..entities.len() {
                if let (Some(ip1), Some(ip2)) = (&entities[i].ip, &entities[j].ip) {
                    if same_network(ip1, ip2, 24) {
                        relationships.push(Relationship {
                            from: entities[i].id.clone(),
                            to: entities[j].id.clone(),
                            relationship_type: "same_network".to_string(),
                        });
                    }
                }
            }
        }

        relationships
    }

    fn same_network(ip1: &str, ip2: &str, prefix: u8) -> bool {
        let parse_ip = |ip: &str| -> Option<u32> {
            let parts: Vec<u8> = ip.split('.').filter_map(|s| s.parse().ok()).collect();
            if parts.len() == 4 {
                Some(((parts[0] as u32) << 24) | ((parts[1] as u32) << 16) |
                     ((parts[2] as u32) << 8) | (parts[3] as u32))
            } else {
                None
            }
        };

        if let (Some(n1), Some(n2)) = (parse_ip(ip1), parse_ip(ip2)) {
            let mask = !((1u32 << (32 - prefix)) - 1);
            (n1 & mask) == (n2 & mask)
        } else {
            false
        }
    }

    pub fn infer_network_topology(entities: &[Entity]) -> NetworkTopology {
        let mut segments: HashMap<String, Vec<String>> = HashMap::new();

        for entity in entities {
            if let Some(ref ip) = entity.ip {
                // Extract /24 network
                let parts: Vec<&str> = ip.split('.').collect();
                if parts.len() == 4 {
                    let network = format!("{}.{}.{}.0/24", parts[0], parts[1], parts[2]);
                    segments.entry(network)
                        .or_insert_with(Vec::new)
                        .push(entity.id.clone());
                }
            }
        }

        NetworkTopology {
            segments: segments.into_iter()
                .map(|(cidr, hosts)| NetworkSegment { cidr, hosts })
                .collect()
        }
    }
}

// ============ MODULE REPORTER ============

pub mod reporter {
    use super::*;

    pub fn build_attack_vectors(entities: &[Entity]) -> Vec<AttackVector> {
        let mut vectors: Vec<AttackVector> = Vec::new();
        let mut av_id = 0;

        for entity in entities {
            for vuln in &entity.vulns {
                av_id += 1;
                let cvss = scan_engine::get_cvss_score(vuln);

                vectors.push(AttackVector {
                    id: format!("AV-{:03}", av_id),
                    name: get_vuln_name(vuln),
                    target: entity.id.clone(),
                    cve: Some(vuln.clone()),
                    cvss,
                    priority: 0, // Will be set later
                    exploitation_path: get_exploitation_path(vuln),
                    prerequisites: get_prerequisites(vuln, entity),
                });
            }

            // Add generic vectors based on services
            for service in &entity.services {
                if service.service.to_lowercase().contains("ssh") {
                    av_id += 1;
                    vectors.push(AttackVector {
                        id: format!("AV-{:03}", av_id),
                        name: "SSH Bruteforce".to_string(),
                        target: entity.id.clone(),
                        cve: None,
                        cvss: 5.0,
                        priority: 0,
                        exploitation_path: "Password guessing or credential stuffing".to_string(),
                        prerequisites: vec!["Valid username".to_string(), "Weak password policy".to_string()],
                    });
                }
            }
        }

        // Sort and assign priorities
        vectors.sort_by(|a, b| b.cvss.partial_cmp(&a.cvss).unwrap_or(std::cmp::Ordering::Equal));
        for (i, vector) in vectors.iter_mut().enumerate() {
            vector.priority = (i + 1) as u8;
        }

        vectors
    }

    fn get_vuln_name(cve: &str) -> String {
        match cve {
            "CVE-2021-44228" => "Log4Shell RCE".to_string(),
            "CVE-2021-41773" => "Apache Path Traversal".to_string(),
            "CVE-2021-23017" => "nginx DNS Resolver Heap Overflow".to_string(),
            _ => format!("{} Vulnerability", cve),
        }
    }

    fn get_exploitation_path(cve: &str) -> String {
        match cve {
            "CVE-2021-44228" => "Send malicious JNDI lookup in HTTP header".to_string(),
            "CVE-2021-41773" => "Send path traversal in URL".to_string(),
            _ => "Refer to CVE details for exploitation".to_string(),
        }
    }

    fn get_prerequisites(cve: &str, entity: &Entity) -> Vec<String> {
        let mut prereqs = vec![format!("Network access to {}", entity.ip.as_deref().unwrap_or("target"))];

        match cve {
            "CVE-2021-44228" => {
                prereqs.push("Log4j in classpath".to_string());
                prereqs.push("Outbound LDAP/RMI allowed".to_string());
            }
            _ => {}
        }

        prereqs
    }

    pub fn calculate_risk_score(model: &InfrastructureModel, vectors: &[AttackVector]) -> f64 {
        if vectors.is_empty() {
            return 0.0;
        }

        // Weight by CVSS and exposure
        let max_cvss = vectors.iter().map(|v| v.cvss).fold(0.0, f64::max);
        let avg_cvss: f64 = vectors.iter().map(|v| v.cvss).sum::<f64>() / vectors.len() as f64;
        let exposure_factor = (model.entities.len() as f64).ln().max(1.0);

        ((max_cvss * 0.6) + (avg_cvss * 0.3) + exposure_factor).min(10.0)
    }

    pub fn generate_executive_summary(
        org: &str,
        model: &InfrastructureModel,
        vectors: &[AttackVector]
    ) -> String {
        let critical = vectors.iter().filter(|v| v.cvss >= 9.0).count();
        let high = vectors.iter().filter(|v| v.cvss >= 7.0 && v.cvss < 9.0).count();

        format!(
            "The reconnaissance of {} revealed {} internet-facing assets. \
             {} critical and {} high severity vulnerabilities were identified. \
             Immediate remediation is recommended for the {} highest priority issues.",
            org,
            model.entities.len(),
            critical,
            high,
            critical.min(3)
        )
    }

    pub fn generate_recommendations(vectors: &[AttackVector]) -> Vec<Recommendation> {
        vectors.iter()
            .take(5)
            .enumerate()
            .map(|(i, v)| Recommendation {
                priority: (i + 1) as u8,
                action: format!("Remediate {} on {}", v.name, v.target),
                impact: if v.cvss >= 9.0 {
                    "Prevents critical remote code execution".to_string()
                } else if v.cvss >= 7.0 {
                    "Reduces high-severity attack surface".to_string()
                } else {
                    "Improves security posture".to_string()
                },
            })
            .collect()
    }

    pub fn generate_attack_plan(
        vectors: &[AttackVector],
        model: &InfrastructureModel
    ) -> Vec<String> {
        let mut plan = Vec::new();

        if let Some(first) = vectors.first() {
            plan.push(format!("Phase 1: Exploit {} on {}", first.name, first.target));
            plan.push("Phase 2: Establish persistence on initial foothold".to_string());

            if model.network_topology.segments.len() > 1 {
                plan.push("Phase 3: Pivot to internal network segments".to_string());
            }

            if vectors.len() > 1 {
                plan.push("Phase 4: Exploit additional vulnerabilities for lateral movement".to_string());
            }

            plan.push("Phase 5: Exfiltrate data and demonstrate impact".to_string());
        }

        plan
    }
}

// ============ FONCTION PRINCIPALE ============

pub fn run_recon_pipeline(input: &ReconInput) -> ReconOutput {
    // 1. Process OSINT sources
    let dns_intel = osint_engine::process_dns_records(&input.data_sources.dns_records);

    let (org_name, org_email) = input.data_sources.whois_data.as_ref()
        .map(|w| osint_engine::process_whois(w))
        .unwrap_or_else(|| ("Unknown".to_string(), "".to_string()));

    let shodan_intel = osint_engine::process_shodan(&input.data_sources.shodan_results);
    let personnel = osint_engine::process_social_osint(&input.data_sources.social_osint);

    // 2. Process scan data
    let port_scan_intel = scan_engine::process_port_scans(&input.data_sources.port_scans);
    let subdomain_intel = scan_engine::process_subdomain_enum(&input.data_sources.subdomain_enum);

    // 3. Correlate and build entities
    let mut entities = correlator::build_entities(
        &dns_intel,
        &shodan_intel,
        &port_scan_intel,
        &subdomain_intel,
    );

    correlator::deduplicate_entities(&mut entities);

    // Add vulnerabilities from version analysis
    for entity in &mut entities {
        for service in &entity.services {
            let vulns = scan_engine::identify_vulnerabilities(&service.version, &service.service);
            for vuln in vulns {
                if !entity.vulns.contains(&vuln) {
                    entity.vulns.push(vuln);
                }
            }
        }

        // Recalculate criticality
        entity.criticality = if entity.vulns.iter().any(|v| scan_engine::get_cvss_score(v) >= 9.0) {
            "critical".to_string()
        } else if entity.vulns.iter().any(|v| scan_engine::get_cvss_score(v) >= 7.0) {
            "high".to_string()
        } else if !entity.vulns.is_empty() {
            "medium".to_string()
        } else {
            "low".to_string()
        };
    }

    // 4. Build relationships and topology
    let relationships = correlator::build_relationships(&entities);
    let network_topology = correlator::infer_network_topology(&entities);

    let infrastructure_model = InfrastructureModel {
        entities: entities.clone(),
        relationships,
        network_topology,
    };

    // 5. Build attack vectors
    let attack_vectors = reporter::build_attack_vectors(&entities);

    // 6. Build intelligence summary
    let all_services: Vec<ServiceInfo> = entities.iter()
        .flat_map(|e| e.services.clone())
        .collect();

    let technology_stack = osint_engine::extract_technology_stack(
        &input.data_sources.metadata_extracted,
        &all_services,
    );

    let critical_vulns = attack_vectors.iter().filter(|v| v.cvss >= 9.0).count();
    let high_vulns = attack_vectors.iter().filter(|v| v.cvss >= 7.0 && v.cvss < 9.0).count();
    let medium_vulns = attack_vectors.iter().filter(|v| v.cvss >= 4.0 && v.cvss < 7.0).count();

    let intelligence_summary = IntelligenceSummary {
        organization: org_name.clone(),
        key_personnel: personnel,
        technology_stack,
        exposed_assets: entities.len(),
        critical_vulns,
        high_vulns,
        medium_vulns,
    };

    // 7. Generate report
    let risk_score = reporter::calculate_risk_score(&infrastructure_model, &attack_vectors);
    let executive_summary = reporter::generate_executive_summary(&org_name, &infrastructure_model, &attack_vectors);
    let recommendations = reporter::generate_recommendations(&attack_vectors);
    let attack_plan = reporter::generate_attack_plan(&attack_vectors, &infrastructure_model);

    let report = Report {
        executive_summary,
        risk_score,
        recommendations,
        attack_plan,
    };

    ReconOutput {
        infrastructure_model,
        attack_vectors,
        intelligence_summary,
        report,
    }
}

fn main() {
    let input: ReconInput = serde_json::from_reader(std::io::stdin())
        .expect("Failed to parse input JSON");

    let output = run_recon_pipeline(&input);

    println!("{}", serde_json::to_string_pretty(&output).unwrap());
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Off-by-one dans le calcul de r√©seau */
fn same_network_mutant(ip1: &str, ip2: &str, prefix: u8) -> bool {
    // ERREUR: Mauvais calcul du masque
    let mask = (1u32 << prefix) - 1;  // ‚Üê Devrait √™tre !((1 << (32-prefix)) - 1)
    // ...
}
// Pourquoi c'est faux: Le masque est invers√©, deux IPs dans le m√™me /24
// seront consid√©r√©es comme dans des r√©seaux diff√©rents

/* Mutant B (Safety) : Ne v√©rifie pas les duplicates avant merge */
pub fn deduplicate_entities_mutant(entities: &mut Vec<Entity>) {
    let mut ip_groups: HashMap<String, Vec<usize>> = HashMap::new();

    for (idx, entity) in entities.iter().enumerate() {
        if let Some(ref ip) = entity.ip {
            ip_groups.entry(ip.clone()).or_insert_with(Vec::new).push(idx);
        }
    }

    for (_, indices) in ip_groups {
        if indices.len() > 1 {
            let first = indices[0];
            for &other in &indices[1..] {
                // ERREUR: Ajoute les hostnames sans v√©rifier les duplicates
                let other_hostnames = entities[other].hostnames.clone();
                entities[first].hostnames.extend(other_hostnames);
                // ‚Üê Peut cr√©er ["example.com", "example.com"]
            }
        }
    }
    // ...
}
// Pourquoi c'est faux: Les hostnames dupliqu√©s polluent les donn√©es

/* Mutant C (Resource) : Fuite m√©moire via clones inutiles */
pub fn build_entities_mutant(/* ... */) -> Vec<Entity> {
    let mut all_data = Vec::new();

    for ip in all_ips {
        // ERREUR: Clone tout le dataset pour chaque IP
        let full_dns = dns_intel.clone();  // ‚Üê O(n) pour chaque IP = O(n¬≤)
        let full_shodan = shodan_intel.clone();
        // ...
    }
    // ...
}
// Pourquoi c'est faux: Complexit√© m√©moire explose avec le nombre d'IPs

/* Mutant D (Logic) : CVSS invers√© pour la priorit√© */
pub fn build_attack_vectors_mutant(entities: &[Entity]) -> Vec<AttackVector> {
    // ...
    vectors.sort_by(|a, b| a.cvss.partial_cmp(&b.cvss).unwrap());  // ‚Üê ASC au lieu de DESC
    // ...
}
// Pourquoi c'est faux: Les vulns les moins critiques sont prioritaires

/* Mutant E (Return) : Score de risque toujours maximum */
pub fn calculate_risk_score_mutant(_: &InfrastructureModel, _: &[AttackVector]) -> f64 {
    10.0  // ‚Üê Toujours 10
}
// Pourquoi c'est faux: Perd toute la granularit√© du scoring
```

---

## üß† SECTION 5 : COMPRENDRE

### 5.1 Ce que ce projet enseigne

1. **Architecture pipeline** : Conception de syst√®mes modulaires
2. **Corr√©lation de donn√©es** : Fusion de sources h√©t√©rog√®nes
3. **Mod√©lisation de graphe** : Repr√©sentation d'infrastructures
4. **Scoring de risque** : Quantification des vuln√©rabilit√©s
5. **G√©n√©ration de rapports** : Communication technique et ex√©cutive

### 5.2 LDA ‚Äî Traduction Litt√©rale

```
FONCTION run_recon_pipeline QUI RETOURNE UNE STRUCTURE ReconOutput
D√âBUT FONCTION
    // 1. TRAITEMENT OSINT
    AFFECTER TRAITER_DNS(input.dns_records) √Ä dns_intel
    AFFECTER TRAITER_WHOIS(input.whois_data) √Ä (org_name, org_email)
    AFFECTER TRAITER_SHODAN(input.shodan_results) √Ä shodan_intel
    AFFECTER TRAITER_SOCIAL(input.social_osint) √Ä personnel

    // 2. TRAITEMENT SCANS
    AFFECTER TRAITER_PORT_SCANS(input.port_scans) √Ä port_scan_intel
    AFFECTER TRAITER_SUBDOMAINS(input.subdomain_enum) √Ä subdomain_intel

    // 3. CORR√âLATION
    AFFECTER CONSTRUIRE_ENTIT√âS(dns_intel, shodan_intel, port_scan_intel, subdomain_intel) √Ä entities
    APPELER D√âDUPLIQUER_ENTIT√âS(entities)

    // 4. RELATIONS ET TOPOLOGIE
    AFFECTER CONSTRUIRE_RELATIONS(entities) √Ä relationships
    AFFECTER INF√âRER_TOPOLOGIE(entities) √Ä network_topology

    // 5. VECTEURS D'ATTAQUE
    AFFECTER CONSTRUIRE_VECTEURS(entities) √Ä attack_vectors

    // 6. INTELLIGENCE SUMMARY
    AFFECTER CONSTRUIRE_SUMMARY(org_name, personnel, entities) √Ä intelligence_summary

    // 7. RAPPORT
    AFFECTER G√âN√âRER_RAPPORT(infrastructure_model, attack_vectors) √Ä report

    RETOURNER NOUVELLE STRUCTURE ReconOutput
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                         RECONNAISSANCE PIPELINE
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                        DATA SOURCES                                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ DNS ‚îÇ ‚îÇWHOIS‚îÇ ‚îÇShodan‚îÇ ‚îÇSubs ‚îÇ ‚îÇPorts‚îÇ ‚îÇSocial‚îÇ ‚îÇMeta ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò           ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ        ‚îÇ      ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ                    ‚îÇ
‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                              ‚îÇ                                             ‚îÇ
‚îÇ                              ‚ñº                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                      CORRELATION ENGINE                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    ‚îÇ   Merge    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Dedup     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   Enrich   ‚îÇ               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                    ‚îÇ                                       ‚îÇ
‚îÇ                                    ‚ñº                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    INFRASTRUCTURE MODEL                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Entities ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Relationships ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Topology           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                    ‚îÇ                                       ‚îÇ
‚îÇ                                    ‚ñº                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                      ANALYSIS ENGINE                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  Vulns   ‚îÇ  ‚îÇ  Scoring ‚îÇ  ‚îÇ  Vectors ‚îÇ  ‚îÇ   Plan   ‚îÇ            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ          ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ                       ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ
‚îÇ                                    ‚îÇ                                       ‚îÇ
‚îÇ                                    ‚ñº                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                          REPORT                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Executive Summary  ‚Ä¢ Recommendations  ‚Ä¢ Attack Plan              ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.8 Mn√©motechniques

#### üé¨ MEME : "Ghost in the Shell ‚Äî Section 9"

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                   ‚îÇ
‚îÇ   "The net is vast and infinite"                                  ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ   OSINT = Diving into the net (Motoko)                           ‚îÇ
‚îÇ   Scanning = Ghost Hacking (penetrating systems)                  ‚îÇ
‚îÇ   Correlation = Tachikoma memory sharing                          ‚îÇ
‚îÇ   Report = Briefing for Chief Aramaki                            ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ   "If you want to know someone, you need to know their ghost"    ‚îÇ
‚îÇ   ‚Üí Reconnaissance reveals the "ghost" of an organization        ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìä SECTION 8 : R√âCAPITULATIF

| √âl√©ment | Valeur |
|---------|--------|
| **Type** | Projet Int√©gratif (Synth√®se) |
| **Concepts int√©gr√©s** | 24 (3.2.1 + 3.2.2) |
| **Difficult√©** | 10/10 |
| **Modules** | OSINT, Scanning, Correlation, Reporting |
| **Complexit√© temps** | O(n √ó m √ó log n) |
| **Architecture** | Pipeline modulaire |
| **Output principal** | Infrastructure model + Attack plan |
| **MEME** | Ghost in the Shell (Section 9) |

---

## üì¶ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.2.A-synth-red_team_recon",
    "generated_at": "2026-01-11T00:00:00Z",

    "metadata": {
      "exercise_id": "3.2.A",
      "exercise_name": "red_team_recon",
      "module": "3.2",
      "module_name": "Network Security",
      "concept": "synth",
      "concept_name": "Full Reconnaissance Pipeline",
      "type": "projet",
      "tier": 3,
      "tier_info": "Synth√®se (24 concepts)",
      "phase": 3,
      "difficulty": 10,
      "difficulty_stars": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ",
      "language": "rust",
      "duration_minutes": 1080,
      "xp_base": 1000,
      "xp_bonus_multiplier": 20,
      "bonus_tier": "WIZARD",
      "bonus_icon": "üîÆ",
      "concepts_integrated": 24,
      "meme_reference": "Ghost in the Shell"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 ‚Äî L'excellence p√©dagogique ne se n√©gocie pas*
*"The net is vast and infinite." ‚Äî Major Motoko Kusanagi*
