# Projet 3.2.B : blue_team_watch

**Module :**
3.2 â€” Network Security (SYNTHÃˆSE)

**Concept :**
synth â€” Network Defense Platform (41 concepts intÃ©grÃ©s)

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… (10/10)

**Type :**
complet

**Tiers :**
3 â€” SynthÃ¨se (concepts 3.2.3 + 3.2.4 + 3.2.5 + 3.2.6)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- Tous les exercices 3.2.06 Ã  3.2.11
- Traffic Analysis (3.2.3, 10 concepts)
- Attack Detection (3.2.4, 15 concepts)
- Protocol Attacks (3.2.5, 8 concepts)
- Defense Systems (3.2.6, 8 concepts)

**Domaines :**
Net, Struct, Probas, Process

**DurÃ©e estimÃ©e :**
1200-1500 min (20-25 heures)

**XP Base :**
1200

**ComplexitÃ© :**
T10 O(n Ã— m Ã— log n) Ã— S9 O(n Ã— m)
*oÃ¹ n = events, m = rules*

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers Ã  rendre :**
- `blue_team_watch.rs` (module principal)
- `log_ingester.rs` (ingestion multi-sources)
- `detection_engine.rs` (moteur de dÃ©tection)
- `correlation_engine.rs` (corrÃ©lation d'Ã©vÃ©nements)
- `alert_manager.rs` (gestion des alertes)
- `metrics_engine.rs` (mÃ©triques SOC)

**Fonctions autorisÃ©es :**
- `std::collections::{HashMap, HashSet, BTreeMap, VecDeque}`
- `std::time::{Duration, Instant}` (simulation)
- `serde_json`, `serde`
- `regex` pour parsing
- Algorithmes personnalisÃ©s

**Fonctions interdites :**
- BibliothÃ¨ques rÃ©seau rÃ©elles
- Multithreading rÃ©el (`std::thread`)
- Tout I/O rÃ©seau

### 1.2 Consigne

#### ğŸ¬ Version Culture : "PERSON OF INTEREST â€” The Machine Never Sleeps"

**"You are being watched."** â€” Opening narration

Dans la sÃ©rie *Person of Interest* (2011-2016), Harold Finch a crÃ©Ã© **The Machine**, une intelligence artificielle de surveillance de masse capable de dÃ©tecter les menaces avant qu'elles ne se produisent. The Machine analyse des millions de donnÃ©es en temps rÃ©el : camÃ©ras, emails, appels tÃ©lÃ©phoniques, transactions financiÃ¨res.

Tu vas construire ta propre **Machine** pour la cybersÃ©curitÃ© :

1. **"The Numbers"** â€” Ingestion multi-sources
   - Comme The Machine qui reÃ§oit des flux de donnÃ©es constants
   - Logs firewall, IDS alerts, NetFlow, HTTP logs, DNS queries

2. **"Relevant vs Irrelevant"** â€” DÃ©tection en temps rÃ©el
   - The Machine classifie les menaces en "relevant" (terrorisme) et "irrelevant" (crimes ordinaires)
   - Ton systÃ¨me classe en Critical, High, Medium, Low

3. **"Pattern Recognition"** â€” CorrÃ©lation d'Ã©vÃ©nements
   - The Machine connecte des Ã©vÃ©nements apparemment non liÃ©s
   - Tu dois identifier les campagnes d'attaque multi-Ã©tapes

4. **"Asset Protection"** â€” Alertes contextuelles
   - The Machine assigne des "assets" (Reese, Shaw) aux menaces
   - Tu assignes des analystes SOC avec le contexte nÃ©cessaire

5. **"Samaritan Detection"** â€” MÃ©triques de performance
   - The Machine doit rester efficace contre Samaritan (IA rivale)
   - Tu mesures MTTD (Mean Time To Detect) et MTTR (Mean Time To Respond)

**La citation clÃ© :**
> *"Everyone has a number. And when your number comes up, we'll find you."*

C'est exactement ce que fait un bon SIEM : chaque attaque a une signature, et quand elle apparaÃ®t, on la trouve.

#### 1.2.2 Version AcadÃ©mique

**Contexte technique :**

Une **plateforme de dÃ©fense rÃ©seau** (SIEM - Security Information and Event Management) est le cÅ“ur d'un SOC (Security Operations Center). Elle doit :

1. **IngÃ©rer des logs multi-sources** :
   - Firewall logs (iptables, pf)
   - IDS/IPS alerts (Snort, Suricata)
   - Network flows (NetFlow, sFlow)
   - Application logs (HTTP, DNS, SMTP)
   - Endpoint logs (syslog)

2. **DÃ©tecter les attaques en temps simulÃ©** :
   - Pattern matching (signatures)
   - Anomaly detection (baselines)
   - Heuristics (comportementale)
   - Threat intelligence correlation

3. **CorrÃ©ler les Ã©vÃ©nements** :
   - Identifier les kill chains
   - Grouper les Ã©vÃ©nements par campagne
   - DÃ©tecter les mouvements latÃ©raux
   - Timeline reconstruction

4. **GÃ©nÃ©rer des alertes enrichies** :
   - Contexte IOC (Indicators of Compromise)
   - MITRE ATT&CK mapping
   - Asset criticality
   - Historical patterns

5. **Proposer des remÃ©diations** :
   - Playbooks automatiques
   - Firewall rule suggestions
   - Quarantine recommendations
   - Forensic collection triggers

6. **Produire des mÃ©triques SOC** :
   - MTTD (Mean Time To Detect)
   - MTTR (Mean Time To Respond)
   - False positive rate
   - Alert fatigue metrics

**EntrÃ©e :**
```json
{
  "configuration": {
    "detection_rules": [
      {
        "id": "R001",
        "name": "SQL Injection Attempt",
        "type": "signature",
        "pattern": "(?i)(union\\s+select|or\\s+1=1|drop\\s+table)",
        "log_source": "http",
        "severity": "high",
        "mitre_technique": "T1190"
      },
      {
        "id": "R002",
        "name": "Brute Force SSH",
        "type": "threshold",
        "condition": "count(ssh_failed) > 10 in 60s per source_ip",
        "log_source": "auth",
        "severity": "medium",
        "mitre_technique": "T1110"
      }
    ],
    "correlation_rules": [
      {
        "id": "C001",
        "name": "Lateral Movement Chain",
        "sequence": ["R002", "internal_scan", "credential_dump"],
        "time_window_seconds": 3600,
        "severity_escalation": "critical"
      }
    ],
    "asset_inventory": [
      {"ip": "192.168.1.10", "name": "web-prod-01", "criticality": "high", "owner": "web-team"},
      {"ip": "192.168.1.20", "name": "db-prod-01", "criticality": "critical", "owner": "dba-team"}
    ],
    "threat_intel": [
      {"ioc_type": "ip", "value": "45.33.32.156", "threat_actor": "APT28", "confidence": 0.9},
      {"ioc_type": "domain", "value": "evil.com", "threat_actor": "FIN7", "confidence": 0.85}
    ]
  },
  "log_streams": {
    "firewall_logs": [
      {"timestamp": "2024-01-15T10:00:00Z", "src_ip": "45.33.32.156", "dst_ip": "192.168.1.10", "dst_port": 443, "action": "allow"},
      {"timestamp": "2024-01-15T10:00:01Z", "src_ip": "45.33.32.156", "dst_ip": "192.168.1.10", "dst_port": 22, "action": "deny"}
    ],
    "http_logs": [
      {"timestamp": "2024-01-15T10:00:00Z", "client_ip": "45.33.32.156", "method": "POST", "uri": "/login", "payload": "user=admin' OR 1=1--", "status": 200}
    ],
    "auth_logs": [
      {"timestamp": "2024-01-15T10:01:00Z", "event": "ssh_failed", "source_ip": "10.0.0.50", "target_ip": "192.168.1.20", "username": "root"},
      {"timestamp": "2024-01-15T10:01:05Z", "event": "ssh_failed", "source_ip": "10.0.0.50", "target_ip": "192.168.1.20", "username": "admin"}
    ],
    "ids_alerts": [
      {"timestamp": "2024-01-15T10:00:00Z", "signature_id": 1000001, "signature": "ET SQL Injection", "src_ip": "45.33.32.156", "dst_ip": "192.168.1.10", "priority": 1}
    ]
  },
  "simulation_time_range": {
    "start": "2024-01-15T10:00:00Z",
    "end": "2024-01-15T12:00:00Z"
  }
}
```

**Sortie :**
```json
{
  "alerts": [
    {
      "alert_id": "ALT-001",
      "timestamp": "2024-01-15T10:00:00Z",
      "rule_id": "R001",
      "rule_name": "SQL Injection Attempt",
      "severity": "high",
      "source_ip": "45.33.32.156",
      "destination_ip": "192.168.1.10",
      "destination_asset": "web-prod-01",
      "asset_criticality": "high",
      "mitre_technique": "T1190",
      "threat_intel_match": {
        "ioc": "45.33.32.156",
        "threat_actor": "APT28",
        "confidence": 0.9
      },
      "context": {
        "related_events": 3,
        "first_seen": "2024-01-15T10:00:00Z",
        "last_seen": "2024-01-15T10:00:01Z"
      },
      "recommended_actions": [
        "Block IP 45.33.32.156 at perimeter firewall",
        "Initiate incident response for web-prod-01",
        "Preserve HTTP logs for forensic analysis"
      ]
    }
  ],
  "correlated_incidents": [
    {
      "incident_id": "INC-001",
      "name": "APT28 Initial Access Attempt",
      "severity": "critical",
      "alerts": ["ALT-001", "ALT-002"],
      "kill_chain_phase": "initial_access",
      "mitre_tactics": ["TA0001", "TA0006"],
      "timeline": [
        {"time": "10:00:00", "event": "SQL Injection from APT28 IP"},
        {"time": "10:00:01", "event": "SSH probe blocked"}
      ],
      "threat_actor": "APT28",
      "confidence": 0.85
    }
  ],
  "metrics": {
    "total_events_processed": 1250,
    "alerts_generated": 15,
    "incidents_created": 3,
    "mttd_seconds": 0.5,
    "mttr_seconds": 120,
    "false_positive_rate": 0.12,
    "coverage": {
      "mitre_techniques_detected": 8,
      "mitre_techniques_total": 15
    }
  },
  "remediation_playbook": {
    "incident_id": "INC-001",
    "steps": [
      {"step": 1, "action": "isolate", "target": "192.168.1.10", "automated": true},
      {"step": 2, "action": "block_ip", "target": "45.33.32.156", "automated": true},
      {"step": 3, "action": "forensic_capture", "target": "web-prod-01", "automated": false},
      {"step": 4, "action": "notify", "target": "web-team", "automated": true}
    ]
  }
}
```

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque, BTreeMap};

// ============ STRUCTURES D'ENTRÃ‰E ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlueTeamInput {
    pub configuration: Configuration,
    pub log_streams: LogStreams,
    pub simulation_time_range: TimeRange,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Configuration {
    pub detection_rules: Vec<DetectionRule>,
    pub correlation_rules: Vec<CorrelationRule>,
    pub asset_inventory: Vec<Asset>,
    pub threat_intel: Vec<ThreatIntel>,
}

// ... autres structures ...

// ============ STRUCTURES DE SORTIE ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlueTeamOutput {
    pub alerts: Vec<Alert>,
    pub correlated_incidents: Vec<Incident>,
    pub metrics: Metrics,
    pub remediation_playbook: Option<Playbook>,
}

// ============ MODULES ============

pub mod log_ingester {
    pub fn ingest_firewall_logs(logs: &[FirewallLog]) -> Vec<NormalizedEvent>;
    pub fn ingest_http_logs(logs: &[HttpLog]) -> Vec<NormalizedEvent>;
    pub fn ingest_auth_logs(logs: &[AuthLog]) -> Vec<NormalizedEvent>;
    pub fn ingest_ids_alerts(alerts: &[IdsAlert]) -> Vec<NormalizedEvent>;
    pub fn normalize_timestamp(ts: &str) -> u64;
}

pub mod detection_engine {
    pub fn apply_signature_rules(events: &[NormalizedEvent], rules: &[DetectionRule]) -> Vec<RuleMatch>;
    pub fn apply_threshold_rules(events: &[NormalizedEvent], rules: &[DetectionRule]) -> Vec<RuleMatch>;
    pub fn apply_anomaly_detection(events: &[NormalizedEvent], baselines: &Baselines) -> Vec<RuleMatch>;
    pub fn enrich_with_threat_intel(matches: &mut [RuleMatch], intel: &[ThreatIntel]);
    pub fn enrich_with_asset_context(matches: &mut [RuleMatch], assets: &[Asset]);
}

pub mod correlation_engine {
    pub fn build_event_timeline(matches: &[RuleMatch]) -> BTreeMap<u64, Vec<&RuleMatch>>;
    pub fn detect_kill_chains(timeline: &BTreeMap<u64, Vec<&RuleMatch>>, rules: &[CorrelationRule]) -> Vec<CorrelatedChain>;
    pub fn group_by_source(matches: &[RuleMatch]) -> HashMap<String, Vec<&RuleMatch>>;
    pub fn identify_campaigns(chains: &[CorrelatedChain]) -> Vec<Campaign>;
}

pub mod alert_manager {
    pub fn create_alerts(matches: &[RuleMatch], context: &AlertContext) -> Vec<Alert>;
    pub fn deduplicate_alerts(alerts: &mut Vec<Alert>);
    pub fn prioritize_alerts(alerts: &mut Vec<Alert>);
    pub fn generate_recommendations(alert: &Alert) -> Vec<String>;
}

pub mod metrics_engine {
    pub fn calculate_mttd(events: &[NormalizedEvent], alerts: &[Alert]) -> f64;
    pub fn calculate_mttr(alerts: &[Alert], remediations: &[Remediation]) -> f64;
    pub fn calculate_false_positive_rate(alerts: &[Alert], confirmed: &[String]) -> f64;
    pub fn calculate_coverage(alerts: &[Alert], mitre_matrix: &MitreMatrix) -> Coverage;
}

/// Point d'entrÃ©e principal
pub fn run_blue_team_platform(input: &BlueTeamInput) -> BlueTeamOutput;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Architecture SIEM Moderne

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SIEM ARCHITECTURE                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  DATA SOURCES          COLLECTION          PROCESSING          OUTPUT      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Firewall â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚          â”‚        â”‚          â”‚       â”‚          â”‚ â”‚
â”‚  â”‚ IDS/IPS  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Log     â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Detectionâ”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚  Alerts  â”‚ â”‚
â”‚  â”‚ NetFlow  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Collectorâ”‚        â”‚ Engine   â”‚       â”‚          â”‚ â”‚
â”‚  â”‚ Endpointsâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚          â”‚        â”‚          â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”‚ Apps     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚          â”‚        â”‚          â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜       â”‚Dashboard â”‚ â”‚
â”‚                            â”‚                   â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                            â–¼                   â–¼              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ Metrics  â”‚ â”‚
â”‚                       â”‚Normalizerâ”‚       â”‚Correlatorâ”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚          â”‚ â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â”‚                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚                       â”‚         THREAT INTEL               â”‚               â”‚
â”‚                       â”‚  IOCs, TTPs, Threat Actors         â”‚               â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Kill Chain et MITRE ATT&CK

La **Cyber Kill Chain** de Lockheed Martin et le framework **MITRE ATT&CK** permettent de catÃ©goriser les phases d'une attaque :

```
KILL CHAIN                        MITRE ATT&CK TACTICS
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Reconnaissance   â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ TA0043: Reconnaissance â”‚
â”‚ 2. Weaponization    â”‚          â”‚                        â”‚
â”‚ 3. Delivery         â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ TA0001: Initial Access â”‚
â”‚ 4. Exploitation     â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ TA0002: Execution      â”‚
â”‚ 5. Installation     â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ TA0003: Persistence    â”‚
â”‚ 6. Command & Ctrl   â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ TA0011: C2             â”‚
â”‚ 7. Actions on Obj   â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ TA0010: Exfiltration   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 MÃ©triques SOC Critiques

| MÃ©trique | Formule | Objectif |
|----------|---------|----------|
| **MTTD** | (Î£ detection_time - event_time) / n | < 5 minutes |
| **MTTR** | (Î£ response_time - alert_time) / n | < 30 minutes |
| **FPR** | false_positives / total_alerts | < 20% |
| **Coverage** | detected_techniques / total_techniques | > 80% |

### 2.4 DANS LA VRAIE VIE

| MÃ©tier | Application |
|--------|-------------|
| **SOC Analyst L1** | Triage des alertes, premier niveau |
| **SOC Analyst L2** | Investigation et corrÃ©lation |
| **Incident Responder** | Utilise le contexte pour containment |
| **Threat Hunter** | Analyse proactive avec les donnÃ©es |
| **Security Engineer** | AmÃ©liore les rÃ¨gles de dÃ©tection |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
blue_team_watch.rs  log_ingester.rs  detection_engine.rs  correlation_engine.rs  alert_manager.rs  metrics_engine.rs  main.rs

$ cargo build --release

$ cat scenario.json | ./target/release/blue_team_watch
{
  "alerts": [
    {
      "alert_id": "ALT-001",
      "rule_name": "SQL Injection Attempt",
      "severity": "high",
      "source_ip": "45.33.32.156",
      "threat_intel_match": {
        "threat_actor": "APT28",
        "confidence": 0.9
      },
      "recommended_actions": [
        "Block IP at perimeter",
        "Initiate incident response"
      ]
    }
  ],
  "correlated_incidents": [
    {
      "incident_id": "INC-001",
      "name": "APT28 Initial Access Attempt",
      "severity": "critical",
      "kill_chain_phase": "initial_access"
    }
  ],
  "metrics": {
    "mttd_seconds": 0.5,
    "mttr_seconds": 120,
    "false_positive_rate": 0.12
  }
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_log_normalization` | Mixed log formats | Unified NormalizedEvent | 5 |
| `test_signature_detection` | HTTP with SQLi | Alert triggered | 10 |
| `test_threshold_detection` | 15 SSH failures in 60s | Brute force alert | 10 |
| `test_threat_intel_enrichment` | Known bad IP | Threat actor attached | 10 |
| `test_asset_enrichment` | Target IP in inventory | Asset context added | 10 |
| `test_kill_chain_correlation` | Multi-stage attack | Chain detected | 15 |
| `test_alert_deduplication` | Duplicate events | Single alert | 10 |
| `test_mttd_calculation` | Events with timestamps | Correct MTTD | 10 |
| `test_remediation_playbook` | Critical incident | Playbook generated | 10 |
| `test_full_pipeline` | Complete scenario | Valid output | 10 |

### 4.3 Solution de rÃ©fÃ©rence (extraits clÃ©s)

```rust
// ============ MODULE DETECTION ============

pub mod detection_engine {
    use super::*;
    use regex::Regex;

    pub fn apply_signature_rules(
        events: &[NormalizedEvent],
        rules: &[DetectionRule]
    ) -> Vec<RuleMatch> {
        let mut matches = Vec::new();

        for rule in rules {
            if rule.rule_type != "signature" {
                continue;
            }

            let pattern = match Regex::new(&rule.pattern) {
                Ok(p) => p,
                Err(_) => continue,
            };

            for event in events {
                if event.log_source != rule.log_source {
                    continue;
                }

                // Check all string fields
                let searchable = format!(
                    "{} {} {} {}",
                    event.raw_log,
                    event.payload.as_deref().unwrap_or(""),
                    event.uri.as_deref().unwrap_or(""),
                    event.user_agent.as_deref().unwrap_or("")
                );

                if pattern.is_match(&searchable) {
                    matches.push(RuleMatch {
                        rule_id: rule.id.clone(),
                        rule_name: rule.name.clone(),
                        event_timestamp: event.timestamp,
                        source_ip: event.source_ip.clone(),
                        destination_ip: event.destination_ip.clone(),
                        severity: rule.severity.clone(),
                        mitre_technique: rule.mitre_technique.clone(),
                        matched_content: searchable.clone(),
                        threat_intel: None,
                        asset: None,
                    });
                }
            }
        }

        matches
    }

    pub fn apply_threshold_rules(
        events: &[NormalizedEvent],
        rules: &[DetectionRule]
    ) -> Vec<RuleMatch> {
        let mut matches = Vec::new();

        for rule in rules {
            if rule.rule_type != "threshold" {
                continue;
            }

            // Parse condition: "count(event_type) > N in Xs per field"
            let parsed = parse_threshold_condition(&rule.condition);
            if parsed.is_none() {
                continue;
            }
            let (event_type, threshold, window_secs, group_field) = parsed.unwrap();

            // Group events by the grouping field
            let mut groups: HashMap<String, Vec<&NormalizedEvent>> = HashMap::new();

            for event in events {
                if event.event_type.as_deref() != Some(event_type.as_str()) {
                    continue;
                }

                let key = match group_field.as_str() {
                    "source_ip" => event.source_ip.clone(),
                    "destination_ip" => event.destination_ip.clone(),
                    _ => "all".to_string(),
                };

                groups.entry(key).or_insert_with(Vec::new).push(event);
            }

            // Check threshold for each group
            for (group_key, group_events) in groups {
                // Sort by timestamp
                let mut sorted = group_events.clone();
                sorted.sort_by_key(|e| e.timestamp);

                // Sliding window check
                for i in 0..sorted.len() {
                    let window_start = sorted[i].timestamp;
                    let window_end = window_start + window_secs;

                    let count = sorted[i..].iter()
                        .take_while(|e| e.timestamp <= window_end)
                        .count();

                    if count > threshold {
                        matches.push(RuleMatch {
                            rule_id: rule.id.clone(),
                            rule_name: rule.name.clone(),
                            event_timestamp: sorted[i].timestamp,
                            source_ip: group_key.clone(),
                            destination_ip: sorted[i].destination_ip.clone(),
                            severity: rule.severity.clone(),
                            mitre_technique: rule.mitre_technique.clone(),
                            matched_content: format!("{} events in {}s", count, window_secs),
                            threat_intel: None,
                            asset: None,
                        });
                        break; // One alert per group
                    }
                }
            }
        }

        matches
    }

    fn parse_threshold_condition(condition: &str) -> Option<(String, usize, u64, String)> {
        // Parse: "count(event_type) > N in Xs per field"
        let re = Regex::new(r"count\((\w+)\)\s*>\s*(\d+)\s+in\s+(\d+)s\s+per\s+(\w+)").ok()?;
        let caps = re.captures(condition)?;

        Some((
            caps[1].to_string(),
            caps[2].parse().ok()?,
            caps[3].parse().ok()?,
            caps[4].to_string(),
        ))
    }

    pub fn enrich_with_threat_intel(
        matches: &mut [RuleMatch],
        intel: &[ThreatIntel]
    ) {
        let intel_map: HashMap<&str, &ThreatIntel> = intel.iter()
            .map(|i| (i.value.as_str(), i))
            .collect();

        for m in matches {
            // Check source IP
            if let Some(intel) = intel_map.get(m.source_ip.as_str()) {
                m.threat_intel = Some(ThreatIntelMatch {
                    ioc: intel.value.clone(),
                    threat_actor: intel.threat_actor.clone(),
                    confidence: intel.confidence,
                });
            }
        }
    }
}

// ============ MODULE CORRELATION ============

pub mod correlation_engine {
    use super::*;

    pub fn detect_kill_chains(
        matches: &[RuleMatch],
        rules: &[CorrelationRule]
    ) -> Vec<CorrelatedChain> {
        let mut chains = Vec::new();

        for rule in rules {
            // Group matches by source IP
            let mut by_source: HashMap<&str, Vec<&RuleMatch>> = HashMap::new();
            for m in matches {
                by_source.entry(&m.source_ip)
                    .or_insert_with(Vec::new)
                    .push(m);
            }

            for (source_ip, source_matches) in by_source {
                // Check if all sequence elements are present within time window
                let mut sequence_matches: Vec<Option<&RuleMatch>> = vec![None; rule.sequence.len()];

                for m in &source_matches {
                    if let Some(pos) = rule.sequence.iter().position(|s| s == &m.rule_id) {
                        if sequence_matches[pos].is_none() ||
                           m.event_timestamp < sequence_matches[pos].unwrap().event_timestamp {
                            sequence_matches[pos] = Some(m);
                        }
                    }
                }

                // Check if all steps found and in order within time window
                if sequence_matches.iter().all(|m| m.is_some()) {
                    let times: Vec<u64> = sequence_matches.iter()
                        .filter_map(|m| m.map(|x| x.event_timestamp))
                        .collect();

                    let first = *times.iter().min().unwrap();
                    let last = *times.iter().max().unwrap();

                    if last - first <= rule.time_window_seconds {
                        // Check order
                        let mut in_order = true;
                        for i in 1..times.len() {
                            if times[i] < times[i-1] {
                                in_order = false;
                                break;
                            }
                        }

                        if in_order {
                            chains.push(CorrelatedChain {
                                correlation_rule_id: rule.id.clone(),
                                correlation_rule_name: rule.name.clone(),
                                source_ip: source_ip.to_string(),
                                matched_rules: sequence_matches.iter()
                                    .filter_map(|m| m.map(|x| x.rule_id.clone()))
                                    .collect(),
                                first_event: first,
                                last_event: last,
                                severity: rule.severity_escalation.clone(),
                            });
                        }
                    }
                }
            }
        }

        chains
    }
}

// ============ MODULE METRICS ============

pub mod metrics_engine {
    use super::*;

    pub fn calculate_mttd(
        events: &[NormalizedEvent],
        alerts: &[Alert]
    ) -> f64 {
        if alerts.is_empty() {
            return 0.0;
        }

        let mut total_detection_time = 0u64;
        let mut count = 0;

        for alert in alerts {
            // Find the earliest related event
            let earliest_event = events.iter()
                .filter(|e| {
                    e.source_ip == alert.source_ip &&
                    e.destination_ip == alert.destination_ip
                })
                .min_by_key(|e| e.timestamp);

            if let Some(event) = earliest_event {
                let detection_time = alert.timestamp.saturating_sub(event.timestamp);
                total_detection_time += detection_time;
                count += 1;
            }
        }

        if count == 0 {
            0.0
        } else {
            total_detection_time as f64 / count as f64
        }
    }

    pub fn calculate_coverage(
        alerts: &[Alert],
        all_techniques: &[String]
    ) -> Coverage {
        let detected: HashSet<_> = alerts.iter()
            .filter_map(|a| a.mitre_technique.clone())
            .collect();

        Coverage {
            mitre_techniques_detected: detected.len(),
            mitre_techniques_total: all_techniques.len(),
            percentage: (detected.len() as f64 / all_techniques.len() as f64) * 100.0,
        }
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Off-by-one dans la fenÃªtre temporelle */
pub fn apply_threshold_rules_mutant(events: &[NormalizedEvent], rules: &[DetectionRule]) -> Vec<RuleMatch> {
    // ...
    let count = sorted[i..].iter()
        .take_while(|e| e.timestamp < window_end)  // â† ERREUR: < au lieu de <=
        .count();
    // ...
}
// Pourquoi c'est faux: Manque les Ã©vÃ©nements Ã  la limite exacte

/* Mutant B (Safety) : Regex non Ã©chappÃ©e */
pub fn apply_signature_rules_mutant(events: &[NormalizedEvent], rules: &[DetectionRule]) -> Vec<RuleMatch> {
    // ...
    let pattern = Regex::new(&rule.pattern).unwrap();  // â† ERREUR: panic si regex invalide
    // ...
}
// Pourquoi c'est faux: Une rÃ¨gle malformÃ©e crash tout le systÃ¨me

/* Mutant C (Logic) : SÃ©quence vÃ©rifiÃ©e sans ordre */
pub fn detect_kill_chains_mutant(matches: &[RuleMatch], rules: &[CorrelationRule]) -> Vec<CorrelatedChain> {
    // ...
    // ERREUR: Ne vÃ©rifie pas l'ordre chronologique de la sÃ©quence
    if sequence_matches.iter().all(|m| m.is_some()) {
        // ConsidÃ¨re valide mÃªme si step 3 arrive avant step 1
        chains.push(...);
    }
    // ...
}
// Pourquoi c'est faux: Une kill chain doit Ãªtre ordonnÃ©e temporellement

/* Mutant D (Return) : MTTD toujours zÃ©ro */
pub fn calculate_mttd_mutant(_: &[NormalizedEvent], _: &[Alert]) -> f64 {
    0.0  // â† Retourne toujours 0
}
// Pourquoi c'est faux: MÃ©trique inutile, pas de visibilitÃ© sur la performance

/* Mutant E (Resource) : Pas de dÃ©duplication */
pub fn create_alerts_mutant(matches: &[RuleMatch], ctx: &AlertContext) -> Vec<Alert> {
    // ERREUR: CrÃ©e une alerte pour chaque match, mÃªme duplicates
    matches.iter().map(|m| Alert::from_match(m, ctx)).collect()
}
// Pourquoi c'est faux: Alert fatigue - 1000 Ã©vÃ©nements = 1000 alertes
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que ce projet enseigne

1. **Architecture SIEM** : Pipeline de traitement de logs
2. **DÃ©tection multi-mÃ©thode** : Signatures + Seuils + Anomalies
3. **CorrÃ©lation temporelle** : DÃ©tection de chaÃ®nes d'attaque
4. **Enrichissement contextuel** : Threat Intel + Assets
5. **MÃ©triques SOC** : MTTD, MTTR, couverture

### 5.3 Visualisation ASCII

```
                          DETECTION ENGINE FLOW
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   RAW LOGS                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚   â”‚  FW  â”‚ â”‚ HTTP â”‚ â”‚ AUTH â”‚ â”‚  IDS â”‚                                      â”‚
â”‚   â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜                                      â”‚
â”‚      â”‚        â”‚        â”‚        â”‚                                          â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                    â”‚                                                        â”‚
â”‚                    â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    NORMALIZER                                      â”‚   â”‚
â”‚   â”‚    [timestamp, src_ip, dst_ip, log_source, payload, ...]          â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                       â”‚
â”‚                                    â–¼                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    DETECTION RULES                                 â”‚   â”‚
â”‚   â”‚                                                                    â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚   â”‚  â”‚  SIGNATURE   â”‚  â”‚  THRESHOLD   â”‚  â”‚   ANOMALY    â”‚            â”‚   â”‚
â”‚   â”‚  â”‚  Regex match â”‚  â”‚  Count > N   â”‚  â”‚  Deviation   â”‚            â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚   â”‚         â”‚                 â”‚                 â”‚                     â”‚   â”‚
â”‚   â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚   â”‚
â”‚   â”‚                           â”‚                                       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                               â–¼                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    ENRICHMENT                                      â”‚   â”‚
â”‚   â”‚                                                                    â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚
â”‚   â”‚  â”‚ THREAT INTEL  â”‚              â”‚    ASSETS     â”‚                 â”‚   â”‚
â”‚   â”‚  â”‚ IOC â†’ Actor   â”‚              â”‚ IP â†’ Context  â”‚                 â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
â”‚   â”‚                                                                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                       â”‚
â”‚                                    â–¼                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    CORRELATION ENGINE                              â”‚   â”‚
â”‚   â”‚                                                                    â”‚   â”‚
â”‚   â”‚    Event A â”€â”€â”€â”€â–º Event B â”€â”€â”€â”€â–º Event C  =  KILL CHAIN             â”‚   â”‚
â”‚   â”‚    (10:00)       (10:05)       (10:10)                            â”‚   â”‚
â”‚   â”‚                                                                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                       â”‚
â”‚                                    â–¼                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                      ALERTS + INCIDENTS                            â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Person of Interest â€” The Machine"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚   "You are being watched. The government has a secret system..."  â”‚
â”‚                                                                   â”‚
â”‚   THE MACHINE = SIEM                                              â”‚
â”‚   â”œâ”€â”€ Cameras = Log Sources                                       â”‚
â”‚   â”œâ”€â”€ Pattern Recognition = Detection Rules                       â”‚
â”‚   â”œâ”€â”€ Relevant Numbers = Critical Alerts                          â”‚
â”‚   â”œâ”€â”€ Irrelevant Numbers = Low-priority Alerts                    â”‚
â”‚   â””â”€â”€ Assets (Reese, Shaw) = SOC Analysts                        â”‚
â”‚                                                                   â”‚
â”‚   "The Machine sees everything, but it shows us only what we     â”‚
â”‚    need to know." â†’ Alert filtering and prioritization            â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Type** | Projet IntÃ©gratif (SynthÃ¨se) |
| **Concepts intÃ©grÃ©s** | 41 (3.2.3 + 3.2.4 + 3.2.5 + 3.2.6) |
| **DifficultÃ©** | 10/10 |
| **Modules** | Ingestion, Detection, Correlation, Alerting, Metrics |
| **ComplexitÃ© temps** | O(n Ã— m Ã— log n) |
| **Architecture** | Stream processing pipeline |
| **Output principal** | Alerts + Incidents + Metrics |
| **MEME** | Person of Interest (The Machine) |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.2.B-synth-blue_team_watch",
    "generated_at": "2026-01-11T00:00:00Z",

    "metadata": {
      "exercise_id": "3.2.B",
      "exercise_name": "blue_team_watch",
      "module": "3.2",
      "module_name": "Network Security",
      "concept": "synth",
      "concept_name": "Network Defense Platform",
      "type": "projet",
      "tier": 3,
      "tier_info": "SynthÃ¨se (41 concepts)",
      "phase": 3,
      "difficulty": 10,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…",
      "language": "rust",
      "duration_minutes": 1350,
      "xp_base": 1200,
      "xp_bonus_multiplier": 20,
      "bonus_tier": "WIZARD",
      "bonus_icon": "ğŸ”®",
      "concepts_integrated": 41,
      "meme_reference": "Person of Interest"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” L'excellence pÃ©dagogique ne se nÃ©gocie pas*
*"You are being watched." â€” The Machine*
