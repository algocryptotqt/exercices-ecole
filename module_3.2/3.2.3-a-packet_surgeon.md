# Exercice 3.2.06 : packet_surgeon

**Module :**
3.2.3 â€” Traffic Analysis

**Concept :**
a â€” Traffic Analysis Engine (Wireshark, tcpdump, TCP streams, HTTP extraction)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
2 â€” Melange (concepts a + b + c + d + g + h)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.04-05 (Scanning & Enumeration)
- Protocole TCP/IP (flags, sequence numbers)
- HTTP request/response format

**Domaines :**
Net, Struct, Algo

**Duree estimee :**
6-8 heures

**XP Base :**
350

**Complexite :**
T3 O(n log n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
packet_surgeon/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ packet.rs
â”‚   â”‚   â””â”€â”€ tcp_stream.rs
â”‚   â”œâ”€â”€ analyzer/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ http_extractor.rs
â”‚   â”‚   â”œâ”€â”€ anomaly_detector.rs
â”‚   â”‚   â””â”€â”€ statistics.rs
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ mod.rs
```

**Fonctions autorisees :**
- `serde`, `serde_json`
- `chrono` pour timestamps
- Crates standard Rust 2024

**Fonctions interdites :**
- Capture de paquets reelle (`pcap`, `libpnet`)
- Sockets reseau

---

### 1.2 Consigne

**ğŸ® CONTEXTE : "The Wire" - Network Surveillance Unit**

*"Dans l'univers de The Wire, l'unite de surveillance de Baltimore intercepte les communications des organisations criminelles. Tu es l'analyste technique qui doit extraire l'intelligence des captures reseau.*

*Les ecoutes arrivent sous forme de fichiers JSON (simules depuis Wireshark). Tu dois reconstruire les conversations TCP, extraire le contenu HTTP, et identifier les patterns suspects qui pourraient indiquer des activites de type C2 (Command & Control)."*

---

**Ta mission :**

Implementer `packet_surgeon` qui:

1. **Parse des paquets reseau** au format JSON (simule depuis pcap/Wireshark)
2. **Reconstruit les streams TCP** (sequence numbers, ACKs, retransmissions)
3. **Extrait les requetes/reponses HTTP** completes
4. **Detecte les anomalies** (retransmissions excessives, RST suspects, beaconing)
5. **Genere des statistiques** (top talkers, protocols, ports)

---

**Entree :**

```json
{
  "capture_metadata": {
    "capture_file": "evidence_001.pcap",
    "capture_start": "2026-01-10T10:00:00Z",
    "capture_end": "2026-01-10T10:30:00Z",
    "interface": "eth0",
    "snaplen": 65535
  },
  "packets": [
    {
      "frame_number": 1,
      "timestamp": "2026-01-10T10:00:00.123456Z",
      "src_ip": "192.168.1.100",
      "dst_ip": "93.184.216.34",
      "src_port": 54321,
      "dst_port": 80,
      "protocol": "TCP",
      "tcp_flags": {
        "syn": true,
        "ack": false,
        "fin": false,
        "rst": false,
        "psh": false
      },
      "seq_number": 1000,
      "ack_number": 0,
      "window_size": 65535,
      "payload_length": 0,
      "payload_hex": ""
    },
    {
      "frame_number": 2,
      "timestamp": "2026-01-10T10:00:00.145678Z",
      "src_ip": "93.184.216.34",
      "dst_ip": "192.168.1.100",
      "src_port": 80,
      "dst_port": 54321,
      "protocol": "TCP",
      "tcp_flags": {
        "syn": true,
        "ack": true
      },
      "seq_number": 2000,
      "ack_number": 1001,
      "window_size": 65535,
      "payload_length": 0
    },
    {
      "frame_number": 5,
      "timestamp": "2026-01-10T10:00:00.200000Z",
      "src_ip": "192.168.1.100",
      "dst_ip": "93.184.216.34",
      "src_port": 54321,
      "dst_port": 80,
      "protocol": "TCP",
      "tcp_flags": {
        "psh": true,
        "ack": true
      },
      "seq_number": 1001,
      "ack_number": 2001,
      "payload_length": 128,
      "payload_hex": "474554202f20485454502f312e310d0a486f73743a206578616d706c652e636f6d0d0a557365722d4167656e743a204d6f7a696c6c612f352e300d0a0d0a"
    }
  ]
}
```

---

**Sortie :**

```json
{
  "analysis_metadata": {
    "analyzer": "packet_surgeon",
    "version": "1.0.0",
    "packets_analyzed": 1523,
    "duration_seconds": 1800
  },
  "tcp_streams": [
    {
      "stream_id": 0,
      "src": "192.168.1.100:54321",
      "dst": "93.184.216.34:80",
      "state": "established",
      "packets_count": 45,
      "bytes_transferred": 15234,
      "duration_ms": 523,
      "retransmissions": 2,
      "out_of_order": 0
    }
  ],
  "http_objects": [
    {
      "stream_id": 0,
      "request": {
        "method": "GET",
        "uri": "/",
        "version": "HTTP/1.1",
        "headers": {
          "Host": "example.com",
          "User-Agent": "Mozilla/5.0"
        },
        "body": null
      },
      "response": {
        "status_code": 200,
        "status_text": "OK",
        "version": "HTTP/1.1",
        "headers": {
          "Content-Type": "text/html",
          "Content-Length": "1256"
        },
        "body_size": 1256,
        "body_preview": "<!DOCTYPE html>..."
      },
      "timing": {
        "request_time": "2026-01-10T10:00:00.200Z",
        "response_time": "2026-01-10T10:00:00.350Z",
        "latency_ms": 150
      }
    }
  ],
  "anomalies": [
    {
      "type": "excessive_retransmissions",
      "stream_id": 3,
      "description": "Stream has 15% retransmission rate (threshold: 5%)",
      "severity": "medium",
      "possible_causes": ["network congestion", "packet loss", "firewall interference"]
    },
    {
      "type": "beaconing_pattern",
      "hosts": ["192.168.1.100", "198.51.100.50"],
      "interval_seconds": 60,
      "jitter_percent": 5,
      "description": "Regular communication pattern detected - possible C2",
      "severity": "high"
    }
  ],
  "statistics": {
    "top_talkers": [
      {"ip": "192.168.1.100", "bytes_sent": 52340, "bytes_received": 128450}
    ],
    "protocol_distribution": {
      "TCP": 1450,
      "UDP": 73,
      "ICMP": 0
    },
    "port_distribution": {
      "80": 450,
      "443": 980,
      "53": 73
    },
    "timeline": {
      "packets_per_minute": [45, 52, 38, 67, 55]
    }
  }
}
```

---

**Contraintes :**

- Reconstruire correctement les streams TCP (gestion des sequence numbers)
- Decoder le payload HTTP (hex -> ASCII)
- Detecter au moins 5 types d'anomalies
- Calculer des statistiques coherentes
- Gerer les paquets hors ordre

---

### 1.3 Prototype

```rust
/// Point d'entree principal
pub fn analyze_capture(input: &CaptureInput) -> AnalysisResult;

/// Reconstruit les streams TCP
pub fn reconstruct_tcp_streams(packets: &[Packet]) -> Vec<TcpStream>;

/// Extrait les objets HTTP d'un stream
pub fn extract_http_objects(stream: &TcpStream) -> Vec<HttpObject>;

/// Decode un payload hex en ASCII
pub fn decode_payload(hex: &str) -> Result<String, DecodeError>;

/// Detecte les anomalies dans la capture
pub fn detect_anomalies(
    streams: &[TcpStream],
    packets: &[Packet]
) -> Vec<Anomaly>;

/// Detecte les patterns de beaconing
pub fn detect_beaconing(packets: &[Packet]) -> Vec<BeaconingPattern>;

/// Genere les statistiques
pub fn compute_statistics(packets: &[Packet]) -> Statistics;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 TCP Sequence Numbers

Les **sequence numbers** TCP commencent a une valeur aleatoire (ISN - Initial Sequence Number) pour prevenir les attaques de prediction. Chaque byte de donnees incremente le sequence number de 1.

### 2.2 Beaconing - Le signal du C2

Le **beaconing** est le pattern ou un malware contacte son serveur C2 a intervalles reguliers. Les analystes cherchent des communications a intervalles fixes (60s, 300s) avec un faible jitter.

### 2.3 Wireshark coloring rules

Wireshark utilise des couleurs pour identifier rapidement les problemes:
- **Noir** : Erreurs TCP (RST, problemes checksum)
- **Rouge fonce** : Retransmissions
- **Bleu clair** : TCP, vert : HTTP

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

### Threat Hunter
- Analyse le trafic pour identifier les IOCs
- Detecte les communications C2 via beaconing analysis
- Correle le trafic avec les IOCs connus

### Incident Responder
- Reconstruit la timeline d'une attaque
- Extrait les artefacts (fichiers telecharges, credentials)
- Identifie le patient zero

### Network Security Engineer
- Baseline le trafic normal du reseau
- Identifie les anomalies de performance
- Troubleshoot les problemes de connectivite

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/  tests/  captures/

$ cargo build --release

$ ./target/release/packet_surgeon --input captures/suspicious.json
{
  "analysis_metadata": {
    "analyzer": "packet_surgeon",
    "packets_analyzed": 1523
  },
  "tcp_streams": [...],
  "http_objects": [...],
  "anomalies": [
    {"type": "beaconing_pattern", "severity": "high"}
  ],
  "statistics": {...}
}

$ cargo test
running 38 tests
test parser::tcp_stream::test_reconstruct ... ok
test analyzer::http_extractor::test_get_request ... ok
test analyzer::anomaly_detector::test_beaconing ... ok
...
test result: ok. 38 passed; 0 failed
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points |
|---------|-------------|--------|
| `T01` | Parse packet JSON | 5 |
| `T02` | TCP stream reconstruction | 10 |
| `T03` | Handle retransmissions | 10 |
| `T04` | HTTP GET extraction | 10 |
| `T05` | HTTP POST with body | 10 |
| `T06` | Hex payload decode | 5 |
| `T07` | Detect excessive retrans | 10 |
| `T08` | Detect beaconing | 15 |
| `T09` | Statistics top talkers | 10 |
| `T10` | Statistics protocols | 5 |
| `T11` | Handle out-of-order | 10 |

**Total : 100 points**

---

### 4.3 Solution de reference (extraits)

```rust
pub fn reconstruct_tcp_streams(packets: &[Packet]) -> Vec<TcpStream> {
    let mut streams: HashMap<StreamKey, TcpStreamBuilder> = HashMap::new();

    for packet in packets {
        if packet.protocol != Protocol::Tcp {
            continue;
        }

        // Create bidirectional stream key
        let key = StreamKey::new(
            &packet.src_ip, packet.src_port,
            &packet.dst_ip, packet.dst_port
        );

        let stream = streams.entry(key).or_insert_with(|| {
            TcpStreamBuilder::new(packet)
        });

        stream.add_packet(packet);
    }

    streams.into_values()
        .map(|builder| builder.build())
        .collect()
}

pub fn detect_beaconing(packets: &[Packet]) -> Vec<BeaconingPattern> {
    let mut patterns = Vec::new();

    // Group packets by src/dst pair
    let mut connections: HashMap<(String, String), Vec<&Packet>> = HashMap::new();
    for packet in packets {
        let key = (packet.src_ip.clone(), packet.dst_ip.clone());
        connections.entry(key).or_default().push(packet);
    }

    for ((src, dst), pkts) in connections {
        if pkts.len() < 5 {
            continue; // Need enough samples
        }

        // Calculate intervals between packets
        let mut intervals = Vec::new();
        for i in 1..pkts.len() {
            let delta = pkts[i].timestamp - pkts[i-1].timestamp;
            intervals.push(delta.num_milliseconds() as f64);
        }

        // Calculate mean and standard deviation
        let mean = intervals.iter().sum::<f64>() / intervals.len() as f64;
        let variance = intervals.iter()
            .map(|x| (x - mean).powi(2))
            .sum::<f64>() / intervals.len() as f64;
        let std_dev = variance.sqrt();

        // Low std_dev relative to mean = potential beaconing
        let jitter_percent = (std_dev / mean * 100.0) as u32;

        if jitter_percent < 20 && mean > 10000.0 { // > 10 sec intervals, < 20% jitter
            patterns.push(BeaconingPattern {
                src,
                dst,
                interval_ms: mean as u64,
                jitter_percent,
                sample_count: pkts.len(),
            });
        }
    }

    patterns
}

pub fn decode_payload(hex: &str) -> Result<String, DecodeError> {
    if hex.is_empty() {
        return Ok(String::new());
    }

    let bytes: Result<Vec<u8>, _> = (0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i+2], 16))
        .collect();

    match bytes {
        Ok(b) => String::from_utf8(b).map_err(|_| DecodeError::InvalidUtf8),
        Err(_) => Err(DecodeError::InvalidHex),
    }
}
```

---

### 4.10 Solutions Mutantes

**Mutant A (Boundary) : Off-by-one dans les sequence numbers**
```rust
// BUG: Ne compte pas le SYN qui consomme 1 seq
let expected_ack = prev_seq + payload_len; // Manque: + 1 si SYN
```

**Mutant B (Logic) : Beaconing detection trop stricte**
```rust
// BUG: Jitter trop strict, rate tous les vrais C2
if jitter_percent < 1 { ... } // Devrait etre < 20
```

**Mutant C (Safety) : Pas de validation hex**
```rust
// BUG: Panic sur hex invalide
let bytes: Vec<u8> = (0..hex.len())
    .step_by(2)
    .map(|i| u8::from_str_radix(&hex[i..i+2], 16).unwrap()) // CRASH
    .collect();
```

**Mutant D (Return) : Stats incorrectes**
```rust
// BUG: Compte les bytes au lieu des paquets pour protocol_distribution
protocol_distribution.insert(proto, pkt.payload_length); // Devrait etre += 1
```

**Mutant E (Resource) : Memory leak sur gros fichiers**
```rust
// BUG: Clone tous les payloads en memoire
let all_payloads: Vec<String> = packets.iter()
    .map(|p| decode_payload(&p.payload_hex).unwrap_or_default())
    .collect();
// Devrait traiter en streaming
```

---

## ğŸ§  SECTION 5 : COMPRENDRE (extraits)

### 5.3 Visualisation ASCII

```
TCP 3-WAY HANDSHAKE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Client                                  Server
   â”‚                                       â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€SYN (seq=1000)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                       â”‚
   â”‚<â”€â”€â”€â”€â”€SYN-ACK (seq=2000, ack=1001)â”€â”€â”€â”€â”€â”‚
   â”‚                                       â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ACK (seq=1001, ack=2001)â”€â”€â”€â”€>â”‚
   â”‚                                       â”‚
   â”‚â•â•â•â•â•â•â• CONNECTION ESTABLISHED â•â•â•â•â•â•â•â•â”‚
   â”‚                                       â”‚
   â”‚â”€â”€PSH-ACK (seq=1001, 128 bytes data)â”€â”€>â”‚
   â”‚                                       â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€ACK (ack=1129)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚                                       â”‚


BEACONING DETECTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Time (minutes)
0        1        2        3        4        5
â”‚        â”‚        â”‚        â”‚        â”‚        â”‚
â–¼        â–¼        â–¼        â–¼        â–¼        â–¼
â—â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â—
   60s      60s      60s      60s      60s

Mean interval: 60s
Standard deviation: 2s
Jitter: 3.3%  â† LOW = POTENTIAL BEACONING

Normal traffic:
â—â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â—â—â”€â”€â”€â”€â”€â”€â—
   Random intervals = HIGH JITTER = Likely legitimate
```

---

### 5.8 Mnemotechniques

#### ğŸ¬ MEME : "The Wire - All in the Game"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  Omar: "You come at the king, you best not miss"               â”‚
â”‚                                                                 â”‚
â”‚  ğŸ” PACKET ANALYSIS RULES:                                     â”‚
â”‚                                                                 â”‚
â”‚  Rule 1: "Follow the sequence numbers"                         â”‚
â”‚          â†’ Comme suivre l'argent dans The Wire                 â”‚
â”‚                                                                 â”‚
â”‚  Rule 2: "Retransmissions tell a story"                        â”‚
â”‚          â†’ Quelque chose bloque la communication               â”‚
â”‚                                                                 â”‚
â”‚  Rule 3: "Regular intervals = wire tap detected"               â”‚
â”‚          â†’ Beaconing = malware calling home                    â”‚
â”‚                                                                 â”‚
â”‚  Rule 4: "RST out of nowhere = someone got caught"             â”‚
â”‚          â†’ Connection killed = possible IDS/firewall           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "3.2.3-a-packet-surgeon",
    "metadata": {
      "exercise_id": "3.2.06",
      "exercise_name": "packet_surgeon",
      "module": "3.2.3",
      "module_name": "Traffic Analysis",
      "difficulty": 7,
      "language": "rust",
      "xp_base": 350,
      "tags": ["wireshark", "tcp", "http", "beaconing", "forensics"]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Packet Surgeon*
*"Dissequer le trafic, reveler la verite"*