# Exercice 3.2.05 : service_revealer

**Module :**
3.2.2 â€” Scanning & Enumeration

**Concept :**
e â€” Enumeration Protocol Analyzer (NSE, Evasion, Banner Grabbing, SNMP/SMB/LDAP)

**Difficulte :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜†â˜† (7/10)

**Type :**
complet

**Tiers :**
2 â€” Melange (concepts f + g + i + j + k + l + m)

**Langage :**
Rust Edition 2024

**Prerequis :**
- 3.2.04 (Network Cartographer)
- Protocoles reseau (SNMP, SMB, LDAP)
- Parsing multi-format

**Domaines :**
Net, Struct, Crypto

**Duree estimee :**
5-7 heures

**XP Base :**
300

**Complexite :**
T2 O(n) Ã— S2 O(n)

---

## ğŸ“ SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
```
service_revealer/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ protocols/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ snmp.rs
â”‚   â”‚   â”œâ”€â”€ smb.rs
â”‚   â”‚   â”œâ”€â”€ ldap.rs
â”‚   â”‚   â”œâ”€â”€ banner.rs
â”‚   â”‚   â””â”€â”€ dns.rs
â”‚   â”œâ”€â”€ analyzer/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ info_extractor.rs
â”‚   â”‚   â”œâ”€â”€ vuln_detector.rs
â”‚   â”‚   â””â”€â”€ honeypot_detector.rs
â”‚   â””â”€â”€ models/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ enumeration.rs
```

**Fonctions autorisees :**
- `serde`, `serde_json` pour parsing
- `regex` pour extraction patterns
- `base64` pour decodage
- Crates Rust standard 2024

**Fonctions interdites :**
- Connexions reseau reelles
- Execution de commandes externes

---

### 1.2 Consigne

**ğŸ® CONTEXTE : "Mr. Robot" - fsociety Enumeration Suite**

*"Dans l'univers de Mr. Robot, fsociety a besoin d'un outil capable d'analyser les resultats d'enumeration multi-protocoles. Elliot doit rapidement identifier les informations sensibles exposees par les serveurs d'Evil Corp.*

*Les donnees arrivent de multiples sources : banners SSH, walks SNMP, sessions SMB null, queries LDAP anonymes. Ton outil doit extraire l'intelligence, detecter les misconfigurations... et identifier les honeypots qui pourraient pieger fsociety."*

---

**Ta mission :**

Implementer `service_revealer` qui:

1. **Parse les reponses multi-protocoles** (SNMP, SMB, LDAP, banners)
2. **Extrait les informations sensibles** (users, shares, system info)
3. **Detecte les misconfigurations** (null sessions, anonymous LDAP, community strings faibles)
4. **Identifie les honeypots** via des patterns caracteristiques
5. **Classifie les informations** par criticite (credentials > system info > metadata)

---

**Entree :**

```json
{
  "enumeration_session": {
    "target": "192.168.1.50",
    "timestamp": "2026-01-10T15:00:00Z",
    "protocols_enumerated": ["snmp", "smb", "ldap", "banner"]
  },
  "banner_grabs": [
    {
      "port": 22,
      "protocol": "tcp",
      "banner": "SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.6",
      "response_time_ms": 15
    },
    {
      "port": 21,
      "protocol": "tcp",
      "banner": "220 (vsFTPd 3.0.3)",
      "response_time_ms": 12
    }
  ],
  "snmp_data": {
    "community_tested": ["public", "private", "admin"],
    "successful_community": "public",
    "walk_results": [
      {
        "oid": "1.3.6.1.2.1.1.1.0",
        "name": "sysDescr",
        "value": "Linux server01 5.4.0-150-generic #167-Ubuntu SMP"
      },
      {
        "oid": "1.3.6.1.2.1.1.5.0",
        "name": "sysName",
        "value": "server01.evil-corp.local"
      },
      {
        "oid": "1.3.6.1.2.1.25.4.2.1.2",
        "name": "hrSWRunName",
        "value": "apache2"
      }
    ]
  },
  "smb_data": {
    "null_session_allowed": true,
    "signing_required": false,
    "smb_version": "SMB3.1.1",
    "shares": [
      {"name": "ADMIN$", "type": "SPECIAL", "remark": "Remote Admin"},
      {"name": "C$", "type": "SPECIAL", "remark": "Default share"},
      {"name": "IPC$", "type": "IPC", "remark": "Remote IPC"},
      {"name": "backup", "type": "DISK", "remark": "Backup files"},
      {"name": "public", "type": "DISK", "remark": "Public share"}
    ],
    "users_enumerated": [
      {"username": "Administrator", "rid": 500, "description": "Built-in admin"},
      {"username": "Guest", "rid": 501, "description": "Built-in guest"},
      {"username": "svc_backup", "rid": 1001, "description": "Backup service account"}
    ]
  },
  "ldap_data": {
    "anonymous_bind_allowed": true,
    "base_dn": "DC=evil-corp,DC=local",
    "entries": [
      {
        "dn": "CN=Administrator,CN=Users,DC=evil-corp,DC=local",
        "objectClass": ["top", "person", "user"],
        "sAMAccountName": "Administrator",
        "memberOf": ["CN=Domain Admins,CN=Users,DC=evil-corp,DC=local"]
      },
      {
        "dn": "CN=SQL Service,CN=Users,DC=evil-corp,DC=local",
        "objectClass": ["top", "person", "user"],
        "sAMAccountName": "svc_sql",
        "description": "SQL Server service - Pass: Summer2025!"
      }
    ]
  }
}
```

---

**Sortie :**

```json
{
  "analysis_metadata": {
    "analyzer": "service_revealer",
    "version": "1.0.0",
    "analyzed_at": "2026-01-10T15:05:00Z",
    "target": "192.168.1.50",
    "protocols_analyzed": 4
  },
  "extracted_info": {
    "credentials": [
      {
        "type": "plaintext_password",
        "source": "ldap",
        "username": "svc_sql",
        "password": "Summer2025!",
        "context": "Found in LDAP description field",
        "criticality": "critical"
      }
    ],
    "users": [
      {
        "username": "Administrator",
        "source": "smb",
        "rid": 500,
        "privileges": "admin",
        "criticality": "high"
      },
      {
        "username": "svc_backup",
        "source": "smb",
        "rid": 1001,
        "privileges": "service",
        "criticality": "medium"
      }
    ],
    "system_info": {
      "hostname": "server01",
      "domain": "evil-corp.local",
      "os": "Linux Ubuntu",
      "kernel": "5.4.0-150-generic",
      "services": ["apache2", "ssh", "ftp", "smb", "ldap"]
    },
    "shares": [
      {
        "name": "backup",
        "type": "DISK",
        "access": "potentially_accessible",
        "criticality": "high"
      }
    ]
  },
  "vulnerabilities": [
    {
      "id": "VULN-001",
      "type": "null_session",
      "protocol": "smb",
      "severity": "high",
      "description": "SMB null session allowed - user enumeration possible",
      "remediation": "Disable null sessions via registry or GPO"
    },
    {
      "id": "VULN-002",
      "type": "anonymous_ldap",
      "protocol": "ldap",
      "severity": "high",
      "description": "Anonymous LDAP bind allowed - full directory enumeration possible",
      "remediation": "Require authentication for LDAP binds"
    },
    {
      "id": "VULN-003",
      "type": "weak_snmp_community",
      "protocol": "snmp",
      "severity": "medium",
      "description": "Default 'public' community string accepted",
      "remediation": "Change to complex community string or use SNMPv3"
    },
    {
      "id": "VULN-004",
      "type": "password_in_description",
      "protocol": "ldap",
      "severity": "critical",
      "description": "Plaintext password found in user description field",
      "remediation": "Remove password from description, rotate credential"
    },
    {
      "id": "VULN-005",
      "type": "smb_signing_disabled",
      "protocol": "smb",
      "severity": "medium",
      "description": "SMB signing not required - MITM possible",
      "remediation": "Enable SMB signing requirement"
    }
  ],
  "honeypot_indicators": {
    "is_honeypot": false,
    "confidence": 0.15,
    "indicators_found": [],
    "indicators_checked": [
      "excessive_services",
      "fake_credentials",
      "banner_inconsistency",
      "unrealistic_config",
      "known_honeypot_signatures"
    ]
  },
  "risk_summary": {
    "overall_risk": "critical",
    "attack_vectors": [
      "Credential harvesting via LDAP",
      "Lateral movement via null session",
      "SNMP information disclosure"
    ],
    "priority_targets": [
      "svc_sql account (has password)",
      "backup share (potential data exfil)"
    ]
  }
}
```

---

**Contraintes :**

- Parser correctement les 4 protocoles (SNMP, SMB, LDAP, Banners)
- Detecter au moins 10 types de vulnerabilites/misconfigurations
- Extraire les credentials en clair des champs LDAP
- Identifier au moins 5 patterns de honeypots
- Classifier les informations par criticite (critical/high/medium/low)

---

### 1.3 Prototype

```rust
// src/lib.rs
use serde::{Deserialize, Serialize};

/// Point d'entree principal
pub fn analyze_enumeration(input: &EnumerationInput) -> AnalysisResult;

/// Parse et analyse les banners
pub fn analyze_banners(banners: &[BannerGrab]) -> BannerAnalysis;

/// Parse et analyse les donnees SNMP
pub fn analyze_snmp(snmp: &SnmpData) -> SnmpAnalysis;

/// Parse et analyse les donnees SMB
pub fn analyze_smb(smb: &SmbData) -> SmbAnalysis;

/// Parse et analyse les donnees LDAP
pub fn analyze_ldap(ldap: &LdapData) -> LdapAnalysis;

/// Detecte les credentials en clair
pub fn extract_credentials(input: &EnumerationInput) -> Vec<Credential>;

/// Detecte les vulnerabilites/misconfigurations
pub fn detect_vulnerabilities(input: &EnumerationInput) -> Vec<Vulnerability>;

/// Detecte les indicateurs de honeypot
pub fn detect_honeypot(input: &EnumerationInput) -> HoneypotAssessment;

/// Classifie les informations par criticite
pub fn classify_info(info: &ExtractedInfo) -> ClassifiedInfo;
```

---

## ğŸ’¡ SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 SNMP - Le protocole bavard

**SNMP** (Simple Network Management Protocol) est souvent laisse avec les community strings par defaut (`public`, `private`). En 2017, plus de **3 millions d'appareils** sur Internet acceptaient encore `public` !

### 2.2 Null Sessions - Le cadeau de Microsoft

Les **null sessions SMB** etaient une "feature" de Windows NT/2000 permettant l'enumeration anonyme. Bien que desactivee par defaut depuis Windows XP SP2, de nombreux serveurs legacy l'ont encore active.

### 2.3 Le piege des descriptions LDAP

Un classique en pentest : les administrateurs stockent les mots de passe dans le champ `description` des comptes de service LDAP. **Toujours verifier ce champ !**

---

## ğŸ¢ SECTION 2.5 : DANS LA VRAIE VIE

### Penetration Tester
- Enumere les reseaux clients pour identifier les quick wins
- Utilise les misconfigurations pour l'acces initial
- Documente les vulnerabilites dans les rapports

### SOC Analyst
- Detecte les tentatives d'enumeration dans les logs
- Correle les alerts SNMP/SMB/LDAP
- Identifie les mouvements lateraux

### Active Directory Admin
- Audit regulier des permissions anonymes
- Verification des descriptions de comptes
- Hardening SMB signing

### Compliance Auditor
- Verification des community strings SNMP
- Audit des null sessions
- Conformite aux baselines CIS

---

## ğŸ–¥ï¸ SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
Cargo.toml  src/  tests/  sample_data/

$ cargo build --release

$ ./target/release/service_revealer --input sample_data/enum_session.json
{
  "analysis_metadata": {
    "analyzer": "service_revealer",
    "version": "1.0.0",
    "protocols_analyzed": 4
  },
  "extracted_info": {
    "credentials": [
      {
        "type": "plaintext_password",
        "username": "svc_sql",
        "criticality": "critical"
      }
    ]
  },
  "vulnerabilities": [...],
  "honeypot_indicators": {
    "is_honeypot": false,
    "confidence": 0.15
  }
}

$ cargo test
running 35 tests
test protocols::snmp::test_parse_walk ... ok
test protocols::smb::test_null_session_detection ... ok
test protocols::ldap::test_password_in_description ... ok
test analyzer::honeypot_detector::test_kippo_signature ... ok
...
test result: ok. 35 passed; 0 failed
```

---

## âš¡ SECTION 3.1 : BONUS STANDARD (OPTIONNEL)

**Difficulte Bonus :**
â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜†â˜† (8/10)

**Recompense :**
XP Ã—2

### 3.1.1 Consigne Bonus

**ğŸ® "Whiterose Mode" - NSE Script Analyzer**

*Whiterose de Dark Army a besoin d'analyser les outputs de scripts NSE Nmap pour automatiser l'extraction d'informations.*

**Ta mission bonus :**

Implementer `analyze_nse_output` qui:

1. **Parse les outputs NSE** (format texte structure)
2. **Detecte les scripts d'enumeration** (smb-enum-*, ldap-*, snmp-*)
3. **Extrait les informations formatees** selon le type de script
4. **Correle les resultats** entre scripts

```rust
pub fn analyze_nse_output(nse_text: &str) -> NseAnalysis;

pub struct NseAnalysis {
    pub scripts_detected: Vec<NseScript>,
    pub extracted_data: HashMap<String, Vec<String>>,
    pub cross_references: Vec<CrossReference>,
}
```

---

## âœ…âŒ SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette

| Test ID | Description | Points | Trap |
|---------|-------------|--------|------|
| `T01` | Parse banner SSH | 5 | - |
| `T02` | Parse banner FTP avec version | 5 | - |
| `T03` | Parse SNMP walk complet | 5 | - |
| `T04` | Detect weak community string | 5 | - |
| `T05` | Parse SMB shares | 5 | - |
| `T06` | Detect null session | 10 | Piege principal |
| `T07` | Parse LDAP entries | 5 | - |
| `T08` | Detect anonymous bind | 5 | - |
| `T09` | Extract password from description | 10 | Pattern matching |
| `T10` | Classify credentials criticality | 5 | - |
| `T11` | Detect SMB signing disabled | 5 | - |
| `T12` | Honeypot: excessive services | 5 | - |
| `T13` | Honeypot: Kippo signature | 5 | - |
| `T14` | Honeypot: fake credentials | 5 | - |
| `T15` | Generate risk summary | 10 | - |
| `T16` | Handle missing protocols | 5 | Robustness |
| `BONUS_T01` | Parse NSE smb-enum-users | 10 | - |
| `BONUS_T02` | Parse NSE ldap-search | 10 | - |

**Total : 100 points (base) + 20 points (bonus)**

---

### 4.3 Solution de reference

```rust
use serde::{Deserialize, Serialize};
use regex::Regex;
use std::collections::HashMap;

// Detection de credentials dans les champs LDAP
pub fn extract_credentials(input: &EnumerationInput) -> Vec<Credential> {
    let mut credentials = Vec::new();

    // Pattern pour passwords dans descriptions
    let password_patterns = [
        Regex::new(r"(?i)pass(?:word)?[:\s=]+([^\s,;]+)").unwrap(),
        Regex::new(r"(?i)pwd[:\s=]+([^\s,;]+)").unwrap(),
        Regex::new(r"(?i)secret[:\s=]+([^\s,;]+)").unwrap(),
    ];

    if let Some(ldap) = &input.ldap_data {
        for entry in &ldap.entries {
            // Check description field
            if let Some(desc) = &entry.description {
                for pattern in &password_patterns {
                    if let Some(captures) = pattern.captures(desc) {
                        if let Some(password) = captures.get(1) {
                            credentials.push(Credential {
                                cred_type: CredentialType::PlaintextPassword,
                                source: "ldap".to_string(),
                                username: entry.sam_account_name.clone(),
                                password: Some(password.as_str().to_string()),
                                context: format!("Found in LDAP description: {}", desc),
                                criticality: Criticality::Critical,
                            });
                        }
                    }
                }
            }

            // Check other suspicious fields
            if let Some(info) = &entry.info {
                for pattern in &password_patterns {
                    if let Some(captures) = pattern.captures(info) {
                        if let Some(password) = captures.get(1) {
                            credentials.push(Credential {
                                cred_type: CredentialType::PlaintextPassword,
                                source: "ldap".to_string(),
                                username: entry.sam_account_name.clone(),
                                password: Some(password.as_str().to_string()),
                                context: "Found in LDAP info field".to_string(),
                                criticality: Criticality::Critical,
                            });
                        }
                    }
                }
            }
        }
    }

    credentials
}

// Detection des vulnerabilites
pub fn detect_vulnerabilities(input: &EnumerationInput) -> Vec<Vulnerability> {
    let mut vulns = Vec::new();
    let mut vuln_id = 1;

    // SNMP vulnerabilities
    if let Some(snmp) = &input.snmp_data {
        // Weak community string
        let weak_communities = ["public", "private", "admin", "community", "snmp"];
        if let Some(community) = &snmp.successful_community {
            if weak_communities.contains(&community.to_lowercase().as_str()) {
                vulns.push(Vulnerability {
                    id: format!("VULN-{:03}", vuln_id),
                    vuln_type: VulnType::WeakSnmpCommunity,
                    protocol: "snmp".to_string(),
                    severity: Severity::Medium,
                    description: format!(
                        "Default/weak community string '{}' accepted",
                        community
                    ),
                    remediation: "Change to complex community string or migrate to SNMPv3".to_string(),
                });
                vuln_id += 1;
            }
        }

        // SNMPv1/v2c (no encryption)
        if snmp.version.as_ref().map(|v| v.starts_with("v1") || v.starts_with("v2")).unwrap_or(true) {
            vulns.push(Vulnerability {
                id: format!("VULN-{:03}", vuln_id),
                vuln_type: VulnType::InsecureProtocolVersion,
                protocol: "snmp".to_string(),
                severity: Severity::Low,
                description: "SNMPv1/v2c in use - community strings sent in cleartext".to_string(),
                remediation: "Upgrade to SNMPv3 with authentication and encryption".to_string(),
            });
            vuln_id += 1;
        }
    }

    // SMB vulnerabilities
    if let Some(smb) = &input.smb_data {
        // Null session
        if smb.null_session_allowed {
            vulns.push(Vulnerability {
                id: format!("VULN-{:03}", vuln_id),
                vuln_type: VulnType::NullSession,
                protocol: "smb".to_string(),
                severity: Severity::High,
                description: "SMB null session allowed - anonymous user enumeration possible".to_string(),
                remediation: "Disable null sessions via RestrictAnonymous registry key".to_string(),
            });
            vuln_id += 1;
        }

        // SMB signing disabled
        if !smb.signing_required {
            vulns.push(Vulnerability {
                id: format!("VULN-{:03}", vuln_id),
                vuln_type: VulnType::SmbSigningDisabled,
                protocol: "smb".to_string(),
                severity: Severity::Medium,
                description: "SMB signing not required - MITM/relay attacks possible".to_string(),
                remediation: "Enable SMB signing requirement via GPO".to_string(),
            });
            vuln_id += 1;
        }

        // SMBv1 (if detected)
        if smb.smb_version.as_ref().map(|v| v.contains("SMB1")).unwrap_or(false) {
            vulns.push(Vulnerability {
                id: format!("VULN-{:03}", vuln_id),
                vuln_type: VulnType::InsecureProtocolVersion,
                protocol: "smb".to_string(),
                severity: Severity::Critical,
                description: "SMBv1 enabled - vulnerable to EternalBlue and similar exploits".to_string(),
                remediation: "Disable SMBv1, ensure patches applied".to_string(),
            });
            vuln_id += 1;
        }
    }

    // LDAP vulnerabilities
    if let Some(ldap) = &input.ldap_data {
        // Anonymous bind
        if ldap.anonymous_bind_allowed {
            vulns.push(Vulnerability {
                id: format!("VULN-{:03}", vuln_id),
                vuln_type: VulnType::AnonymousLdap,
                protocol: "ldap".to_string(),
                severity: Severity::High,
                description: "Anonymous LDAP bind allowed - full directory enumeration possible".to_string(),
                remediation: "Require authentication for LDAP binds".to_string(),
            });
            vuln_id += 1;
        }

        // Password in description (detected during credential extraction)
        let password_pattern = Regex::new(r"(?i)pass(?:word)?[:\s=]").unwrap();
        for entry in &ldap.entries {
            if let Some(desc) = &entry.description {
                if password_pattern.is_match(desc) {
                    vulns.push(Vulnerability {
                        id: format!("VULN-{:03}", vuln_id),
                        vuln_type: VulnType::PasswordInDescription,
                        protocol: "ldap".to_string(),
                        severity: Severity::Critical,
                        description: format!(
                            "Plaintext password found in description of user '{}'",
                            entry.sam_account_name.as_ref().unwrap_or(&"unknown".to_string())
                        ),
                        remediation: "Remove password from description, rotate credential immediately".to_string(),
                    });
                    vuln_id += 1;
                }
            }
        }
    }

    vulns
}

// Detection de honeypots
pub fn detect_honeypot(input: &EnumerationInput) -> HoneypotAssessment {
    let mut indicators = Vec::new();
    let mut score = 0.0;

    // Indicator 1: Excessive services
    let total_services = count_services(input);
    if total_services > 20 {
        indicators.push(HoneypotIndicator {
            indicator_type: "excessive_services".to_string(),
            description: format!("{} services detected - unusually high", total_services),
            weight: 0.3,
        });
        score += 0.3;
    }

    // Indicator 2: Known honeypot banners
    let honeypot_signatures = [
        ("Kippo", r"SSH-2\.0-OpenSSH_5\.1p1 Debian"),
        ("Cowrie", r"SSH-2\.0-OpenSSH_6\.0p1 Debian"),
        ("Dionaea", r"220 DiskStation"),
        ("HoneyPy", r"HoneyPy"),
    ];

    if let Some(banners) = &input.banner_grabs {
        for banner in banners {
            for (name, pattern) in &honeypot_signatures {
                let regex = Regex::new(pattern).unwrap();
                if regex.is_match(&banner.banner) {
                    indicators.push(HoneypotIndicator {
                        indicator_type: format!("known_signature_{}", name.to_lowercase()),
                        description: format!("{} honeypot signature detected", name),
                        weight: 0.8,
                    });
                    score += 0.8;
                }
            }
        }
    }

    // Indicator 3: Fake/obvious credentials
    if let Some(ldap) = &input.ldap_data {
        let fake_password_patterns = [
            r"(?i)password123",
            r"(?i)admin123",
            r"(?i)test123",
            r"(?i)honeypot",
            r"(?i)changeme",
        ];

        for entry in &ldap.entries {
            if let Some(desc) = &entry.description {
                for pattern in &fake_password_patterns {
                    let regex = Regex::new(pattern).unwrap();
                    if regex.is_match(desc) {
                        indicators.push(HoneypotIndicator {
                            indicator_type: "fake_credentials".to_string(),
                            description: "Suspiciously obvious credentials found".to_string(),
                            weight: 0.5,
                        });
                        score += 0.5;
                    }
                }
            }
        }
    }

    // Indicator 4: Banner inconsistencies
    if let Some(banners) = &input.banner_grabs {
        if has_banner_inconsistency(banners) {
            indicators.push(HoneypotIndicator {
                indicator_type: "banner_inconsistency".to_string(),
                description: "Service banners show inconsistent OS/versions".to_string(),
                weight: 0.4,
            });
            score += 0.4;
        }
    }

    // Indicator 5: All ports accepting connections
    if let Some(snmp) = &input.snmp_data {
        if let Some(smb) = &input.smb_data {
            if let Some(ldap) = &input.ldap_data {
                // If all protocols respond AND are misconfigured, suspicious
                if snmp.successful_community.is_some()
                    && smb.null_session_allowed
                    && ldap.anonymous_bind_allowed
                {
                    indicators.push(HoneypotIndicator {
                        indicator_type: "unrealistic_config".to_string(),
                        description: "All protocols misconfigured - unusually weak security".to_string(),
                        weight: 0.25,
                    });
                    score += 0.25;
                }
            }
        }
    }

    HoneypotAssessment {
        is_honeypot: score >= 0.7,
        confidence: score.min(1.0),
        indicators_found: indicators,
        indicators_checked: vec![
            "excessive_services".to_string(),
            "fake_credentials".to_string(),
            "banner_inconsistency".to_string(),
            "unrealistic_config".to_string(),
            "known_honeypot_signatures".to_string(),
        ],
    }
}

fn has_banner_inconsistency(banners: &[BannerGrab]) -> bool {
    let mut os_hints: Vec<&str> = Vec::new();

    for banner in banners {
        if banner.banner.contains("Ubuntu") || banner.banner.contains("Debian") {
            os_hints.push("Linux-Debian");
        } else if banner.banner.contains("Windows") {
            os_hints.push("Windows");
        } else if banner.banner.contains("FreeBSD") {
            os_hints.push("BSD");
        }
    }

    // If we see multiple different OS hints, that's suspicious
    let unique: std::collections::HashSet<_> = os_hints.iter().collect();
    unique.len() > 1
}
```

---

### 4.9 spec.json

```json
{
  "name": "service_revealer",
  "language": "rust",
  "version": "2024",
  "type": "code",
  "tier": 2,
  "tier_info": "Melange (concepts f + g + i + j + k + l + m)",
  "tags": ["enumeration", "snmp", "smb", "ldap", "security", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "analyze_enumeration",
    "prototype": "pub fn analyze_enumeration(input: &EnumerationInput) -> AnalysisResult",
    "return_type": "AnalysisResult",
    "parameters": [
      {"name": "input", "type": "&EnumerationInput"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "password_in_ldap_description",
        "expected_credential_count": 1,
        "is_trap": true,
        "trap_explanation": "Must detect password pattern in description field"
      },
      {
        "name": "null_session_enabled",
        "expected_vuln_type": "null_session",
        "is_trap": true,
        "trap_explanation": "Must detect SMB null session vulnerability"
      },
      {
        "name": "kippo_honeypot_banner",
        "expected_honeypot": true,
        "is_trap": true,
        "trap_explanation": "Must detect known Kippo SSH honeypot signature"
      },
      {
        "name": "missing_protocols",
        "input": {"snmp_data": null, "smb_data": null},
        "expected_error": false,
        "is_trap": true,
        "trap_explanation": "Must handle missing protocol data gracefully"
      }
    ]
  },

  "norm": {
    "allowed_functions": ["serde", "serde_json", "regex", "base64"],
    "forbidden_functions": ["std::net::TcpStream", "std::process::Command"],
    "check_security": true,
    "check_memory": true
  }
}
```

---

### 4.10 Solutions Mutantes

**Mutant A (Pattern) : Regex trop permissif pour passwords**
```rust
// BUG: Capture tout apres "pass"
let pattern = Regex::new(r"(?i)pass(.*)").unwrap();
// Devrait etre: r"(?i)pass(?:word)?[:\s=]+([^\s,;]+)"
// Ce qui etait pense: "Je veux tout ce qui suit 'pass'"
```

**Mutant B (Safety) : Pas de verification null pour optional fields**
```rust
// BUG: unwrap sur Option
let community = input.snmp_data.as_ref().unwrap().successful_community.as_ref().unwrap();
// Devrait utiliser: if let Some(...) ou .unwrap_or_default()
```

**Mutant C (Logic) : Inversion de la logique honeypot**
```rust
// BUG: is_honeypot si score < 0.7
is_honeypot: score < 0.7,  // Devrait etre >= 0.7
```

**Mutant D (Return) : Oubli des credentials SNMP**
```rust
// BUG: Ne cherche que dans LDAP
pub fn extract_credentials(input: &EnumerationInput) -> Vec<Credential> {
    let mut creds = Vec::new();
    // Manque: extraction depuis SNMP community strings RW
    if let Some(ldap) = &input.ldap_data { ... }
    creds
}
```

**Mutant E (Boundary) : Seuil honeypot trop bas**
```rust
// BUG: Trop de faux positifs
is_honeypot: score >= 0.3,  // Devrait etre 0.7
// Tout serveur mal configure serait flag comme honeypot
```

---

## ğŸ§  SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Parsing multi-protocoles** : Gerer SNMP, SMB, LDAP, banners
2. **Extraction d'intelligence** : Trouver les informations critiques
3. **Detection de vulnerabilites** : Identifier les misconfigurations courantes
4. **Analyse de honeypots** : Reconnaitre les pieges
5. **Classification par criticite** : Prioriser les findings

---

### 5.3 Visualisation ASCII

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SERVICE REVEALER ARCHITECTURE                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     INPUTS                    ANALYZERS                    OUTPUTS
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   BANNERS   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ Banner Parser â”‚â”€â”€â”€â”
  â”‚  SSH, FTP,  â”‚           â”‚ Version Extracâ”‚   â”‚
  â”‚  SMTP, etc. â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
                                                â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â”‚                 â”‚
  â”‚    SNMP     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ SNMP Analyzer â”‚â”€â”€â”€â”¼â”€â”€â”€â”€>â”‚  CREDENTIALS    â”‚
  â”‚ Walk resultsâ”‚           â”‚ OID Decoder   â”‚   â”‚     â”‚  - plaintext    â”‚
  â”‚ Community   â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚     â”‚  - hashes       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚     â”‚  - hints        â”‚
                                                â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
  â”‚     SMB     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ SMB Analyzer  â”‚â”€â”€â”€â”¤     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Shares     â”‚           â”‚ User Enum     â”‚   â”‚     â”‚                 â”‚
  â”‚  Users      â”‚           â”‚ Share Enum    â”‚   â”œâ”€â”€â”€â”€>â”‚ VULNERABILITIES â”‚
  â”‚  Sessions   â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚     â”‚  - null session â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚     â”‚  - anon bind    â”‚
                                                â”‚     â”‚  - weak config  â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚    LDAP     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ LDAP Analyzer â”‚â”€â”€â”€â”¤
  â”‚  Entries    â”‚           â”‚ Attr Parser   â”‚   â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  DN Tree    â”‚           â”‚ Cred Finder   â”‚   â”‚     â”‚                 â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”œâ”€â”€â”€â”€>â”‚    HONEYPOT     â”‚
                                                â”‚     â”‚   ASSESSMENT    â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â”‚  - confidence   â”‚
                            â”‚   Honeypot    â”‚â”€â”€â”€â”¤     â”‚  - indicators   â”‚
                            â”‚   Detector    â”‚   â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚               â”‚   â”‚
                            â”‚ - Signatures  â”‚   â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ - Patterns    â”‚   â”‚     â”‚                 â”‚
                            â”‚ - Anomalies   â”‚   â””â”€â”€â”€â”€>â”‚  RISK SUMMARY   â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚  - priority     â”‚
                                                      â”‚  - vectors      â”‚
                                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.5 Cours Complet (extraits)

#### 5.5.1 SNMP Enumeration

**SNMP** utilise des **OIDs** (Object Identifiers) pour identifier les informations :

```
OID Standard                    Information
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.3.6.1.2.1.1.1.0              sysDescr (OS/version)
1.3.6.1.2.1.1.3.0              sysUpTime
1.3.6.1.2.1.1.5.0              sysName (hostname)
1.3.6.1.2.1.25.4.2.1.2         hrSWRunName (processes)
1.3.6.1.2.1.25.6.3.1.2         hrSWInstalledName (software)
```

**Community strings** : Agissent comme des mots de passe
- `public` : Lecture seule (mais donne deja beaucoup d'info)
- `private` : Lecture/ecriture (tres dangereux si par defaut)

#### 5.5.2 SMB Enumeration

**Null sessions** permettent :
- Enumeration des utilisateurs (SID walking)
- Liste des partages
- Informations sur les politiques de mots de passe

**Outils classiques** : `enum4linux`, `smbclient -L`, `rpcclient`

#### 5.5.3 LDAP Enumeration

**Anonymous bind** = Acces complet a l'annuaire sans authentification

Points d'interet :
- `sAMAccountName` : Noms d'utilisateurs
- `memberOf` : Groupes (identifier les admins)
- `description` : Souvent contient des informations sensibles
- `servicePrincipalName` : Cibles pour Kerberoasting

---

### 5.8 Mnemotechniques (MEME obligatoire)

#### ğŸ­ MEME : "Mr. Robot - fsociety Rules"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  ğŸ­ fsociety ENUMERATION RULES                                  â”‚
â”‚                                                                 â”‚
â”‚  Rule 1: "SNMP public is like leaving your door open"           â”‚
â”‚          â†’ Toujours tester public/private/admin                â”‚
â”‚                                                                 â”‚
â”‚  Rule 2: "Null sessions are the gift that keeps giving"         â”‚
â”‚          â†’ Un null session = enumeration complete              â”‚
â”‚                                                                 â”‚
â”‚  Rule 3: "Passwords hide in plain sight"                        â”‚
â”‚          â†’ Toujours checker les champs description             â”‚
â”‚                                                                 â”‚
â”‚  Rule 4: "If it looks too easy, it's a honeypot"               â”‚
â”‚          â†’ Tout ouvert + creds obvioux = trap                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ’€ MEME : "The IT Crowd - Did you try turning it off and on again?"

```
Helpdesk: "Have you tried using 'public' as the community string?"
Hacker:   "Yes, and it worked. I now have full SNMP access."
Helpdesk: "Oh dear. Have you tried turning the security off and on again?"
```

---

## ğŸ“Š SECTION 8 : RECAPITULATIF

| Critere | Valeur |
|---------|--------|
| Concepts couverts | 7 (3.2.2.f-m) |
| Difficulte | 7/10 |
| Temps estime | 5-7 heures |
| XP Base | 300 |
| Protocoles | SNMP, SMB, LDAP, Banners |
| Vulnerabilites a detecter | 10+ |
| Patterns honeypot | 5+ |

---

## ğŸ“¦ SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.2.2-e-service-revealer",
    "generated_at": "2026-01-11T00:30:00Z",

    "metadata": {
      "exercise_id": "3.2.05",
      "exercise_name": "service_revealer",
      "module": "3.2.2",
      "module_name": "Scanning & Enumeration",
      "concept": "e",
      "concept_name": "Enumeration Protocol Analyzer",
      "type": "complet",
      "tier": 2,
      "phase": 3,
      "difficulty": 7,
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 360,
      "xp_base": 300,
      "domains": ["Net", "Struct", "Crypto"],
      "tags": ["enumeration", "snmp", "smb", "ldap", "honeypot"],
      "meme_reference": "Mr. Robot - fsociety"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 â€” Service Revealer*
*"Reveler les secrets, exposer les failles"*
*Compatible ENGINE v22.1 + Mutation Tester*