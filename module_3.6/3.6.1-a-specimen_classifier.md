<thinking>
## Analyse du Concept
- Concept : Classification des types de malware (virus, worms, trojans, ransomware, rootkits, bootkits)
- Phase demand√©e : Phase 3 (Avanc√©)
- Adapt√© ? OUI - La classification de malware est un concept fondamental en analyse de malware, adapt√©e √† la Phase 3

## Combo Base + Bonus
- Exercice de base : Classifier un √©chantillon selon ses caract√©ristiques comportementales
- Bonus : D√©tecter les malwares polymorphes et les menaces hybrides avec scoring avanc√©
- Palier bonus : üî• Avanc√© (complexit√© technique accrue)
- Progression logique ? OUI - Le bonus ajoute la gestion de cas complexes (polymorphisme, hybrides)

## Pr√©requis & Difficult√©
- Pr√©requis r√©els : Compr√©hension des syst√®mes d'exploitation, concepts de s√©curit√© de base, parsing JSON
- Difficult√© estim√©e : 7/10 (Phase 3)
- Coh√©rent avec phase ? OUI - Requiert une connaissance approfondie des comportements malveillants

## Aspect Fun/Culture
- Contexte choisi : S√©rie Mr. Robot - Elliot classifiant les malwares de fsociety
- MEME mn√©motechnique : "I am Mr. Robot" - Chaque type de malware a sa signature unique
- Pourquoi c'est fun : R√©f√©rence √† une s√©rie culte sur le hacking, contexte de SOC r√©aliste

## Sc√©narios d'√âchec (Mutants r√©els)
1. Mutant A (Boundary) : Ne g√®re pas les cas hybrides (worm+ransomware), retourne seulement le premier type d√©tect√©
2. Mutant B (Safety) : Pas de validation du JSON d'entr√©e, crash sur donn√©es malform√©es
3. Mutant C (Resource) : Calcul de confiance erron√© (toujours 1.0 ou valeurs al√©atoires)
4. Mutant D (Logic) : Classification invers√©e (rootkit d√©tect√© comme virus)
5. Mutant E (Return) : Ne calcule pas le risk_level correctement, retourne toujours "medium"

## Verdict
VALIDE - L'exercice enseigne un concept essentiel de malware analysis, avec une progression logique vers le bonus
</thinking>

# Exercice [3.6.1-a] : specimen_classifier

**Module :**
3.6.1 ‚Äî Malware Fundamentals

**Concept :**
a ‚Äî Classification de Types de Malware

**Difficult√© :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ (7/10)

**Type :**
code

**Tiers :**
1 ‚Äî Concept isol√©

**Langage :**
Python 3.14

**Pr√©requis :**
- Compr√©hension des syst√®mes d'exploitation
- Parsing JSON
- Concepts de s√©curit√© informatique de base

**Domaines :**
Crypto (classification), Process (analyse comportementale)

**Dur√©e estim√©e :**
45 min

**XP Base :**
150

**Complexit√© :**
T[N] O(n) √ó S[N] O(1)

---

## üìê SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier √† rendre :**
`specimen_classifier.py`

**Fonctions autoris√©es :**
- `json.loads()`, `json.dumps()`
- `sys.stdin.read()`
- Fonctions built-in Python (dict, list, float, etc.)

**Fonctions interdites :**
- Biblioth√®ques externes (sauf `json`, `sys`)
- Appels syst√®me directs
- Connexions r√©seau

### 1.2 Consigne

**üéÆ Mr. Robot : La Taxonomie de fsociety**

Tu es Elliot Alderson, analyste au SOC de CyberShield Corp (le jour) et membre de fsociety (la nuit). Un √©chantillon suspect a √©t√© intercept√© par l'EDR. Ton job : le classifier selon sa taxonomie malveillante.

"I am Mr. Robot." Et toi, tu es le classificateur de malware.

**Ta mission :**

√âcrire un programme `specimen_classifier.py` qui lit un JSON contenant les caract√©ristiques comportementales d'un binaire suspect et retourne sa classification compl√®te.

**Entr√©e :**
- **STDIN** : JSON avec les caract√©ristiques binaires :
  ```json
  {
    "self_replicates": bool,
    "network_spread": bool,
    "encrypts_files": bool,
    "hides_processes": bool,
    "modifies_mbr": bool,
    "creates_backdoor": bool,
    "drops_payload": bool,
    "persistence_method": "registry|service|bootkit|none"
  }
  ```

**Sortie :**
- **STDOUT** : JSON de classification :
  ```json
  {
    "primary_type": "virus|worm|trojan|ransomware|rootkit|bootkit",
    "confidence": float (0.0-1.0),
    "subtypes": ["file_infector", "crypto_ransomware", ...],
    "risk_level": "low|medium|high|critical"
  }
  ```

**Contraintes :**
- Le `primary_type` est le type le plus probable selon les caract√©ristiques
- Le `confidence` refl√®te la certitude de la classification (1.0 = 100% s√ªr)
- Les `subtypes` sont une liste de comportements sp√©cifiques d√©tect√©s
- Le `risk_level` est calcul√© selon la dangerosit√© globale
- G√©rer les cas hybrides (exemple : worm + ransomware)

**Exemples :**

| Caract√©ristiques | Classification | Explication |
|------------------|----------------|-------------|
| `self_replicates=true, network_spread=false` | `virus` | Auto-r√©plication sans propagation r√©seau = virus classique |
| `network_spread=true, encrypts_files=true` | `worm`, subtypes: `["crypto_ransomware"]` | Hybride worm+ransomware |
| `modifies_mbr=true, persistence=bootkit` | `bootkit` | Modification MBR + persistence bootkit |

### 1.3 Prototype

```python
#!/usr/bin/env python3
import json
import sys

def classify_specimen(characteristics: dict) -> dict:
    """
    Classifie un √©chantillon de malware selon ses caract√©ristiques.

    Args:
        characteristics: Dictionnaire des caract√©ristiques comportementales

    Returns:
        Dictionnaire avec primary_type, confidence, subtypes, risk_level
    """
    pass

if __name__ == "__main__":
    input_data = json.loads(sys.stdin.read())
    result = classify_specimen(input_data)
    print(json.dumps(result, indent=2))
```

---

## üí° SECTION 2 : LE SAVIEZ-VOUS ?

La classification de malware n'est pas une science exacte. De nombreux malwares modernes sont **hybrides** : un worm qui d√©ploie du ransomware, un trojan qui installe un rootkit, etc. C'est pourquoi le **confidence score** est crucial.

En 2017, **WannaCry** √©tait techniquement un **worm** (propagation EternalBlue) d√©ployant un **ransomware** (chiffrement + ran√ßon). Comment le classifier ? Les analystes utilisent le **primary behavior** (le ransomware dans ce cas) et ajoutent le **propagation vector** en sous-type.

**Fun fact** : Le premier virus informatique connu, **Creeper** (1971), se r√©pliquait mais ne causait aucun dommage. Il affichait juste "I'M THE CREEPER : CATCH ME IF YOU CAN". Les **Virus** sont nomm√©s d'apr√®s les virus biologiques par analogie avec leur auto-r√©plication.

### SECTION 2.5 : DANS LA VRAIE VIE

**M√©tier :** Malware Analyst / SOC Analyst L2-L3 / Threat Intelligence Analyst

**Cas d'usage concret :**

Chez **FireEye**, **CrowdStrike**, ou dans un SOC d'entreprise, les analystes re√ßoivent des centaines d'√©chantillons par jour. La premi√®re √©tape est toujours la **triage** : classifier rapidement pour prioriser l'analyse approfondie.

Un **Incident Response Team** utilise cette classification pour :
1. **Prioriser** : Un bootkit UEFI (critical) avant un adware (low)
2. **Playbook** : Chaque type a une r√©ponse sp√©cifique (isolate, reimage, hunt IOCs)
3. **Threat Intel** : Mapper √† des APT groups (Lazarus utilise souvent des worm-rootkit combos)

**Exemple r√©el** : Lors de l'attaque **NotPetya** (2017), la classification initiale "ransomware" a retard√© la r√©ponse. C'√©tait en fait un **wiper** d√©guis√© (data destruction irr√©versible). Une meilleure classification aurait chang√© la strat√©gie de r√©ponse.

---

## üñ•Ô∏è SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ ls
specimen_classifier.py  test_samples.json

$ python3 specimen_classifier.py < test_samples.json
{
  "primary_type": "worm",
  "confidence": 0.95,
  "subtypes": ["crypto_ransomware", "network_propagation"],
  "risk_level": "critical"
}

$ echo '{"self_replicates": true, "network_spread": false, "encrypts_files": false, "hides_processes": false, "modifies_mbr": false, "creates_backdoor": false, "drops_payload": true, "persistence_method": "registry"}' | python3 specimen_classifier.py
{
  "primary_type": "virus",
  "confidence": 0.85,
  "subtypes": ["file_infector"],
  "risk_level": "medium"
}
```

---

## üî• SECTION 3.1 : BONUS AVANC√â (OPTIONNEL)

**Difficult√© Bonus :**
‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (8/10)

**R√©compense :**
XP √ó3

**Time Complexity attendue :**
O(n)

**Space Complexity attendue :**
O(1)

**Domaines Bonus :**
`Crypto, AL (Alg√®bre Lin√©aire pour scoring)`

### 3.1.1 Consigne Bonus

**üéÆ Mr. Robot : Phase 2 - Les Menaces Polymorphes**

Elliot doit maintenant g√©rer les malwares **polymorphes** qui changent leur signature √† chaque infection, et les **APT tools** qui combinent plusieurs techniques furtives.

**Ta mission :**

√âtendre ton classificateur pour :
1. D√©tecter les **menaces hybrides** avec un scoring avanc√©
2. Identifier les patterns **APT** (Advanced Persistent Threat)
3. Calculer un **MITRE ATT&CK** technique ID

**Entr√©e :**
- M√™me structure + champs bonus :
  ```json
  {
    // ... champs pr√©c√©dents ...
    "polymorphic_behavior": bool,
    "apt_indicators": {
      "lateral_movement": bool,
      "credential_dumping": bool,
      "c2_beaconing": bool
    }
  }
  ```

**Sortie :**
- Champs suppl√©mentaires :
  ```json
  {
    // ... champs pr√©c√©dents ...
    "is_apt": bool,
    "sophistication_score": float (0.0-10.0),
    "mitre_techniques": ["T1566", "T1059", ...]
  }
  ```

**Contraintes :**
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  confidence >= 0.90 pour APT             ‚îÇ
‚îÇ  sophistication_score bas√© sur :        ‚îÇ
‚îÇ    - Nombre de techniques combin√©es     ‚îÇ
‚îÇ    - Pr√©sence de polymorphisme          ‚îÇ
‚îÇ    - Indicateurs APT                    ‚îÇ
‚îÇ  Temps limite : O(n)                    ‚îÇ
‚îÇ  Espace limite : O(1) auxiliaire        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

**Exemples :**

| Input | Classification Bonus | Explication |
|-------|---------------------|-------------|
| `polymorphic + apt_indicators.all=true` | `is_apt=true, sophistication=9.5` | Menace APT confirm√©e |
| `hybrid worm+ransomware + c2_beaconing` | `mitre: ["T1566", "T1486", "T1071"]` | Techniques MITRE mapp√©es |

### 3.1.2 Prototype Bonus

```python
def classify_specimen_advanced(characteristics: dict) -> dict:
    """
    Classification avanc√©e avec d√©tection APT et MITRE ATT&CK mapping.
    """
    pass
```

### 3.1.3 Ce qui change par rapport √† l'exercice de base

| Aspect | Base | Bonus |
|--------|------|-------|
| Param√®tres | 8 champs comportementaux | +3 champs APT |
| Complexit√© | Classification simple | Scoring multi-crit√®res |
| Edge cases | Hybrides basiques | APT + polymorphes |
| Output | 4 champs | +3 champs (APT, sophistication, MITRE) |

---

## ‚úÖ‚ùå SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Input | Expected Output | Points |
|------|-------|----------------|--------|
| **T1** : Virus classique | `{"self_replicates": true, "network_spread": false, ...}` | `primary_type: "virus"` | 10 |
| **T2** : Worm r√©seau | `{"network_spread": true, ...}` | `primary_type: "worm"` | 10 |
| **T3** : Ransomware | `{"encrypts_files": true, ...}` | `primary_type: "ransomware", risk: "critical"` | 15 |
| **T4** : Bootkit | `{"modifies_mbr": true, "persistence": "bootkit"}` | `primary_type: "bootkit"` | 15 |
| **T5** : Hybride worm+ransomware | `{"network_spread": true, "encrypts_files": true}` | `subtypes: ["crypto_ransomware"]` | 20 |
| **T6** : Rootkit | `{"hides_processes": true, ...}` | `primary_type: "rootkit"` | 10 |
| **T7** : Trojan | `{"creates_backdoor": true, ...}` | `primary_type: "trojan"` | 10 |
| **T8** : Confidence score | Tous types | `0.0 <= confidence <= 1.0` | 10 |

**Seuil de r√©ussite** : 70/100

### 4.2 main.c de test

N/A (Python exercise - voir test_runner.py)

### 4.3 Solution de r√©f√©rence

```python
#!/usr/bin/env python3
import json
import sys

def classify_specimen(characteristics: dict) -> dict:
    """Classifie un malware selon ses caract√©ristiques."""

    # Validation
    if not isinstance(characteristics, dict):
        return {"error": "Invalid input"}

    # Extraction des caract√©ristiques
    self_replicates = characteristics.get("self_replicates", False)
    network_spread = characteristics.get("network_spread", False)
    encrypts_files = characteristics.get("encrypts_files", False)
    hides_processes = characteristics.get("hides_processes", False)
    modifies_mbr = characteristics.get("modifies_mbr", False)
    creates_backdoor = characteristics.get("creates_backdoor", False)
    drops_payload = characteristics.get("drops_payload", False)
    persistence = characteristics.get("persistence_method", "none")

    # Scoring par type
    scores = {
        "virus": 0.0,
        "worm": 0.0,
        "trojan": 0.0,
        "ransomware": 0.0,
        "rootkit": 0.0,
        "bootkit": 0.0
    }

    subtypes = []

    # Virus : auto-r√©plication sans r√©seau
    if self_replicates and not network_spread:
        scores["virus"] += 0.6
        subtypes.append("file_infector")

    # Worm : propagation r√©seau
    if network_spread:
        scores["worm"] += 0.7
        subtypes.append("network_propagation")

    # Ransomware : chiffrement de fichiers
    if encrypts_files:
        scores["ransomware"] += 0.8
        subtypes.append("crypto_ransomware")

    # Rootkit : dissimulation de processus
    if hides_processes:
        scores["rootkit"] += 0.7
        subtypes.append("process_hiding")

    # Bootkit : modification MBR ou UEFI
    if modifies_mbr or persistence == "bootkit":
        scores["bootkit"] += 0.9
        subtypes.append("mbr_infection")

    # Trojan : backdoor
    if creates_backdoor:
        scores["trojan"] += 0.6
        subtypes.append("remote_access")

    # Payload dropper
    if drops_payload:
        scores["trojan"] += 0.3
        subtypes.append("dropper")

    # Persistence registry/service
    if persistence in ["registry", "service"]:
        scores["trojan"] += 0.2

    # D√©terminer le type principal
    primary_type = max(scores, key=scores.get)
    confidence = scores[primary_type]

    # Ajuster confiance pour hybrides
    active_types = sum(1 for score in scores.values() if score > 0.3)
    if active_types > 1:
        confidence *= 0.85  # R√©duire confiance pour hybrides

    # Calcul du risk level
    risk_score = sum(scores.values())
    if risk_score >= 1.5 or encrypts_files or modifies_mbr:
        risk_level = "critical"
    elif risk_score >= 0.8:
        risk_level = "high"
    elif risk_score >= 0.4:
        risk_level = "medium"
    else:
        risk_level = "low"

    return {
        "primary_type": primary_type,
        "confidence": round(confidence, 2),
        "subtypes": list(set(subtypes)),  # D√©duplication
        "risk_level": risk_level
    }

if __name__ == "__main__":
    input_data = json.loads(sys.stdin.read())
    result = classify_specimen(input_data)
    print(json.dumps(result, indent=2))
```

### 4.4 Solutions alternatives accept√©es

**Alternative 1 : Approche par r√®gles IF-ELIF**

```python
def classify_specimen(characteristics: dict) -> dict:
    """Version avec r√®gles conditionnelles explicites."""

    # Bootkit en priorit√© (modification MBR)
    if characteristics.get("modifies_mbr") or characteristics.get("persistence_method") == "bootkit":
        return {
            "primary_type": "bootkit",
            "confidence": 0.95,
            "subtypes": ["mbr_infection"],
            "risk_level": "critical"
        }

    # Ransomware (chiffrement)
    if characteristics.get("encrypts_files"):
        subtypes = ["crypto_ransomware"]
        if characteristics.get("network_spread"):
            subtypes.append("network_propagation")
        return {
            "primary_type": "ransomware",
            "confidence": 0.90,
            "subtypes": subtypes,
            "risk_level": "critical"
        }

    # Worm (propagation r√©seau)
    if characteristics.get("network_spread"):
        return {
            "primary_type": "worm",
            "confidence": 0.85,
            "subtypes": ["network_propagation"],
            "risk_level": "high"
        }

    # Rootkit (dissimulation)
    if characteristics.get("hides_processes"):
        return {
            "primary_type": "rootkit",
            "confidence": 0.80,
            "subtypes": ["process_hiding"],
            "risk_level": "high"
        }

    # Trojan (backdoor)
    if characteristics.get("creates_backdoor"):
        return {
            "primary_type": "trojan",
            "confidence": 0.75,
            "subtypes": ["remote_access"],
            "risk_level": "medium"
        }

    # Virus (auto-r√©plication)
    if characteristics.get("self_replicates"):
        return {
            "primary_type": "virus",
            "confidence": 0.70,
            "subtypes": ["file_infector"],
            "risk_level": "medium"
        }

    # Aucun type d√©tect√©
    return {
        "primary_type": "unknown",
        "confidence": 0.0,
        "subtypes": [],
        "risk_level": "low"
    }
```

### 4.5 Solutions refus√©es (avec explications)

**Refus√©e 1 : Retourne toujours le m√™me type**

```python
def classify_specimen(characteristics: dict) -> dict:
    return {
        "primary_type": "virus",  # ‚ùå Toujours virus
        "confidence": 1.0,
        "subtypes": [],
        "risk_level": "medium"
    }
```
**Pourquoi c'est faux :** Ne fait aucune analyse, retourne un type fixe.

**Refus√©e 2 : Confidence al√©atoire**

```python
import random
def classify_specimen(characteristics: dict) -> dict:
    return {
        "primary_type": "worm",
        "confidence": random.random(),  # ‚ùå Al√©atoire
        "subtypes": [],
        "risk_level": "high"
    }
```
**Pourquoi c'est faux :** Le confidence doit √™tre d√©terministe et bas√© sur les caract√©ristiques.

**Refus√©e 3 : Pas de validation d'entr√©e**

```python
def classify_specimen(characteristics: dict) -> dict:
    # ‚ùå Pas de v√©rification si characteristics est un dict
    encrypts = characteristics["encrypts_files"]  # Crash si cl√© absente
    return {
        "primary_type": "ransomware" if encrypts else "virus",
        "confidence": 0.5,
        "subtypes": [],
        "risk_level": "medium"
    }
```
**Pourquoi c'est faux :** Crash sur donn√©es malform√©es ou cl√©s manquantes.

### 4.6 Solution bonus de r√©f√©rence (COMPL√àTE)

```python
#!/usr/bin/env python3
import json
import sys

def classify_specimen_advanced(characteristics: dict) -> dict:
    """Classification avanc√©e avec d√©tection APT et MITRE mapping."""

    # Solution de base
    base_result = classify_specimen(characteristics)

    # Extraction des indicateurs APT
    polymorphic = characteristics.get("polymorphic_behavior", False)
    apt_indicators = characteristics.get("apt_indicators", {})
    lateral = apt_indicators.get("lateral_movement", False)
    cred_dump = apt_indicators.get("credential_dumping", False)
    c2_beacon = apt_indicators.get("c2_beaconing", False)

    # Calcul du sophistication score (0.0-10.0)
    sophistication = 0.0

    # Nombre de techniques combin√©es
    active_techniques = sum([
        characteristics.get("self_replicates", False),
        characteristics.get("network_spread", False),
        characteristics.get("encrypts_files", False),
        characteristics.get("hides_processes", False),
        characteristics.get("modifies_mbr", False),
        characteristics.get("creates_backdoor", False)
    ])
    sophistication += active_techniques * 1.0

    # Polymorphisme (+3 points)
    if polymorphic:
        sophistication += 3.0

    # Indicateurs APT
    if lateral:
        sophistication += 1.5
    if cred_dump:
        sophistication += 2.0
    if c2_beacon:
        sophistication += 1.5

    # D√©tection APT (>=3 indicateurs + sophistication >= 7.0)
    is_apt = (lateral or cred_dump or c2_beacon) and sophistication >= 7.0
    if is_apt:
        base_result["confidence"] = max(0.90, base_result["confidence"])

    # MITRE ATT&CK Technique Mapping
    mitre_techniques = []

    if characteristics.get("network_spread"):
        mitre_techniques.append("T1566")  # Phishing (propagation)
    if characteristics.get("encrypts_files"):
        mitre_techniques.append("T1486")  # Data Encrypted for Impact
    if c2_beacon:
        mitre_techniques.append("T1071")  # Application Layer Protocol
    if characteristics.get("creates_backdoor"):
        mitre_techniques.append("T1059")  # Command and Scripting Interpreter
    if lateral:
        mitre_techniques.append("T1021")  # Remote Services
    if cred_dump:
        mitre_techniques.append("T1003")  # OS Credential Dumping
    if characteristics.get("hides_processes"):
        mitre_techniques.append("T1055")  # Process Injection
    if characteristics.get("modifies_mbr"):
        mitre_techniques.append("T1542")  # Pre-OS Boot

    # Ajout des champs bonus
    base_result["is_apt"] = is_apt
    base_result["sophistication_score"] = round(min(sophistication, 10.0), 1)
    base_result["mitre_techniques"] = mitre_techniques

    return base_result

def classify_specimen(characteristics: dict) -> dict:
    """Fonction de base (copie de 4.3)."""
    if not isinstance(characteristics, dict):
        return {"error": "Invalid input"}

    self_replicates = characteristics.get("self_replicates", False)
    network_spread = characteristics.get("network_spread", False)
    encrypts_files = characteristics.get("encrypts_files", False)
    hides_processes = characteristics.get("hides_processes", False)
    modifies_mbr = characteristics.get("modifies_mbr", False)
    creates_backdoor = characteristics.get("creates_backdoor", False)
    drops_payload = characteristics.get("drops_payload", False)
    persistence = characteristics.get("persistence_method", "none")

    scores = {
        "virus": 0.0, "worm": 0.0, "trojan": 0.0,
        "ransomware": 0.0, "rootkit": 0.0, "bootkit": 0.0
    }
    subtypes = []

    if self_replicates and not network_spread:
        scores["virus"] += 0.6
        subtypes.append("file_infector")
    if network_spread:
        scores["worm"] += 0.7
        subtypes.append("network_propagation")
    if encrypts_files:
        scores["ransomware"] += 0.8
        subtypes.append("crypto_ransomware")
    if hides_processes:
        scores["rootkit"] += 0.7
        subtypes.append("process_hiding")
    if modifies_mbr or persistence == "bootkit":
        scores["bootkit"] += 0.9
        subtypes.append("mbr_infection")
    if creates_backdoor:
        scores["trojan"] += 0.6
        subtypes.append("remote_access")
    if drops_payload:
        scores["trojan"] += 0.3
        subtypes.append("dropper")
    if persistence in ["registry", "service"]:
        scores["trojan"] += 0.2

    primary_type = max(scores, key=scores.get)
    confidence = scores[primary_type]

    active_types = sum(1 for score in scores.values() if score > 0.3)
    if active_types > 1:
        confidence *= 0.85

    risk_score = sum(scores.values())
    if risk_score >= 1.5 or encrypts_files or modifies_mbr:
        risk_level = "critical"
    elif risk_score >= 0.8:
        risk_level = "high"
    elif risk_score >= 0.4:
        risk_level = "medium"
    else:
        risk_level = "low"

    return {
        "primary_type": primary_type,
        "confidence": round(confidence, 2),
        "subtypes": list(set(subtypes)),
        "risk_level": risk_level
    }

if __name__ == "__main__":
    input_data = json.loads(sys.stdin.read())
    # D√©tecter si bonus (pr√©sence de apt_indicators)
    if "apt_indicators" in input_data:
        result = classify_specimen_advanced(input_data)
    else:
        result = classify_specimen(input_data)
    print(json.dumps(result, indent=2))
```

### 4.7 Solutions alternatives bonus (COMPL√àTES)

**Alternative Bonus 1 : Scoring matriciel**

```python
def classify_specimen_advanced(characteristics: dict) -> dict:
    """Version avec matrice de scoring APT."""
    base = classify_specimen(characteristics)

    # Matrice APT (chaque indicateur contribue)
    apt_score = 0
    if characteristics.get("polymorphic_behavior"):
        apt_score += 3
    apt_ind = characteristics.get("apt_indicators", {})
    if apt_ind.get("lateral_movement"):
        apt_score += 2
    if apt_ind.get("credential_dumping"):
        apt_score += 3
    if apt_ind.get("c2_beaconing"):
        apt_score += 2

    is_apt = apt_score >= 5
    sophistication = min(apt_score * 1.2, 10.0)

    # MITRE mapping simplifi√©
    mitre = []
    if characteristics.get("encrypts_files"):
        mitre.append("T1486")
    if apt_ind.get("c2_beaconing"):
        mitre.append("T1071")

    base.update({
        "is_apt": is_apt,
        "sophistication_score": round(sophistication, 1),
        "mitre_techniques": mitre
    })
    return base
```

### 4.8 Solutions refus√©es bonus (COMPL√àTES)

**Refus√©e Bonus 1 : Sophistication fixe**

```python
def classify_specimen_advanced(characteristics: dict) -> dict:
    base = classify_specimen(characteristics)
    base.update({
        "is_apt": True,  # ‚ùå Toujours APT
        "sophistication_score": 10.0,  # ‚ùå Toujours max
        "mitre_techniques": []
    })
    return base
```
**Pourquoi c'est faux :** Ne calcule pas r√©ellement les scores, valeurs hardcod√©es.

**Refus√©e Bonus 2 : MITRE techniques invalides**

```python
def classify_specimen_advanced(characteristics: dict) -> dict:
    base = classify_specimen(characteristics)
    base.update({
        "is_apt": False,
        "sophistication_score": 5.0,
        "mitre_techniques": ["INVALID123", "T9999"]  # ‚ùå IDs invalides
    })
    return base
```
**Pourquoi c'est faux :** Les techniques MITRE doivent suivre le format T[4 chiffres].

### 4.9 spec.json (ENGINE v22.1 ‚Äî FORMAT STRICT)

```json
{
  "name": "specimen_classifier",
  "language": "python",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isol√©",
  "tags": ["malware", "classification", "forensics", "phase3"],
  "passing_score": 70,

  "function": {
    "name": "classify_specimen",
    "prototype": "def classify_specimen(characteristics: dict) -> dict",
    "return_type": "dict",
    "parameters": [
      {"name": "characteristics", "type": "dict"}
    ]
  },

  "driver": {
    "reference": "def ref_classify_specimen(c): scores={'virus':0.6 if c.get('self_replicates') and not c.get('network_spread') else 0,'worm':0.7 if c.get('network_spread') else 0,'ransomware':0.8 if c.get('encrypts_files') else 0,'rootkit':0.7 if c.get('hides_processes') else 0,'bootkit':0.9 if c.get('modifies_mbr') or c.get('persistence_method')=='bootkit' else 0,'trojan':0.6 if c.get('creates_backdoor') else 0}; p=max(scores,key=scores.get); conf=scores[p]; risk='critical' if sum(scores.values())>=1.5 else 'high' if sum(scores.values())>=0.8 else 'medium' if sum(scores.values())>=0.4 else 'low'; return {'primary_type':p,'confidence':round(conf,2),'subtypes':[],'risk_level':risk}",

    "edge_cases": [
      {
        "name": "virus_only",
        "args": [{"self_replicates": true, "network_spread": false, "encrypts_files": false, "hides_processes": false, "modifies_mbr": false, "creates_backdoor": false, "drops_payload": true, "persistence_method": "none"}],
        "expected": {"primary_type": "virus", "confidence": 0.6, "risk_level": "medium"},
        "is_trap": false
      },
      {
        "name": "worm_ransomware_hybrid",
        "args": [{"self_replicates": false, "network_spread": true, "encrypts_files": true, "hides_processes": false, "modifies_mbr": false, "creates_backdoor": false, "drops_payload": false, "persistence_method": "none"}],
        "expected": {"primary_type": "ransomware", "risk_level": "critical"},
        "is_trap": true,
        "trap_explanation": "Hybride critique : worm + ransomware = critical"
      },
      {
        "name": "bootkit_critical",
        "args": [{"self_replicates": false, "network_spread": false, "encrypts_files": false, "hides_processes": false, "modifies_mbr": true, "creates_backdoor": false, "drops_payload": false, "persistence_method": "bootkit"}],
        "expected": {"primary_type": "bootkit", "confidence": 0.9, "risk_level": "critical"},
        "is_trap": false
      },
      {
        "name": "empty_characteristics",
        "args": [{}],
        "expected": {"confidence": 0.0, "risk_level": "low"},
        "is_trap": true,
        "trap_explanation": "Aucune caract√©ristique = low risk"
      },
      {
        "name": "invalid_input",
        "args": [null],
        "expected": {"error": "Invalid input"},
        "is_trap": true,
        "trap_explanation": "Input null doit √™tre g√©r√©"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "dict",
          "param_index": 0,
          "params": {
            "keys": ["self_replicates", "network_spread", "encrypts_files", "hides_processes", "modifies_mbr", "creates_backdoor", "drops_payload"],
            "value_type": "bool"
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["json.loads", "json.dumps", "sys.stdin.read", "dict.get", "max", "sum", "round", "list", "set"],
    "forbidden_functions": ["eval", "exec", "os.system", "subprocess"],
    "check_security": true,
    "check_memory": false,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 5)

**Mutant A (Boundary) : Ne g√®re pas les hybrides**

```python
def classify_specimen(characteristics: dict) -> dict:
    """Retourne seulement le premier type d√©tect√©."""
    if characteristics.get("self_replicates"):
        return {"primary_type": "virus", "confidence": 1.0, "subtypes": [], "risk_level": "medium"}
    if characteristics.get("network_spread"):
        return {"primary_type": "worm", "confidence": 1.0, "subtypes": [], "risk_level": "high"}
    # Ne combine jamais les types
    return {"primary_type": "unknown", "confidence": 0.0, "subtypes": [], "risk_level": "low"}
```
**Pourquoi c'est faux :** Un malware peut √™tre worm+ransomware simultan√©ment. Cette solution ignore les cas hybrides et retourne le premier match au lieu du score le plus √©lev√©.

**Mutant B (Safety) : Pas de validation JSON**

```python
def classify_specimen(characteristics: dict) -> dict:
    """Crash sur donn√©es malform√©es."""
    # Pas de v√©rification isinstance(characteristics, dict)
    encrypts = characteristics["encrypts_files"]  # KeyError si cl√© absente
    network = characteristics["network_spread"]

    if encrypts:
        return {"primary_type": "ransomware", "confidence": 0.9, "subtypes": [], "risk_level": "critical"}
    return {"primary_type": "virus", "confidence": 0.5, "subtypes": [], "risk_level": "low"}
```
**Pourquoi c'est faux :** Crash avec KeyError si une cl√© est manquante. Devrait utiliser `.get()` avec valeur par d√©faut.

**Mutant C (Resource) : Confidence toujours 1.0**

```python
def classify_specimen(characteristics: dict) -> dict:
    """Confiance erron√©e."""
    scores = {"virus": 0.0, "worm": 0.0, "ransomware": 0.0}

    if characteristics.get("self_replicates"):
        scores["virus"] = 0.6
    if characteristics.get("network_spread"):
        scores["worm"] = 0.7

    primary = max(scores, key=scores.get)

    return {
        "primary_type": primary,
        "confidence": 1.0,  # ‚ùå Toujours 1.0 au lieu du score r√©el
        "subtypes": [],
        "risk_level": "medium"
    }
```
**Pourquoi c'est faux :** Le confidence doit refl√©ter le score calcul√©, pas √™tre fix√© √† 1.0.

**Mutant D (Logic) : Classification invers√©e**

```python
def classify_specimen(characteristics: dict) -> dict:
    """Logique invers√©e."""
    if characteristics.get("hides_processes"):
        # ‚ùå Rootkit classifi√© comme virus
        return {"primary_type": "virus", "confidence": 0.7, "subtypes": [], "risk_level": "low"}

    if characteristics.get("self_replicates"):
        # ‚ùå Virus classifi√© comme rootkit
        return {"primary_type": "rootkit", "confidence": 0.8, "subtypes": [], "risk_level": "high"}

    return {"primary_type": "trojan", "confidence": 0.5, "subtypes": [], "risk_level": "medium"}
```
**Pourquoi c'est faux :** Les types sont invers√©s. `hides_processes` devrait donner "rootkit", pas "virus".

**Mutant E (Return) : Risk level toujours "medium"**

```python
def classify_specimen(characteristics: dict) -> dict:
    """Risk level incorrect."""
    scores = {"virus": 0.0, "worm": 0.0, "ransomware": 0.0, "bootkit": 0.0}

    if characteristics.get("encrypts_files"):
        scores["ransomware"] = 0.8
    if characteristics.get("modifies_mbr"):
        scores["bootkit"] = 0.9

    primary = max(scores, key=scores.get)

    return {
        "primary_type": primary,
        "confidence": scores[primary],
        "subtypes": [],
        "risk_level": "medium"  # ‚ùå Toujours medium, m√™me pour ransomware/bootkit
    }
```
**Pourquoi c'est faux :** Ransomware et bootkit devraient √™tre "critical", pas "medium".---

## üß† SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

Cet exercice enseigne la **taxonomie des malwares**, c'est-√†-dire la science de classifier les logiciels malveillants selon leur comportement, leur m√©thode de propagation et leur impact. C'est une comp√©tence fondamentale en cybers√©curit√© pour :

1. **Triage rapide** : Prioriser l'analyse des menaces
2. **Playbook de r√©ponse** : Chaque type requiert une strat√©gie diff√©rente
3. **Threat Intelligence** : Mapper les malwares √† des campagnes APT
4. **Communication** : Parler le m√™me langage que les autres analystes

**Concepts cl√©s :**
- **Virus** : Auto-r√©plication en infectant des fichiers h√¥tes
- **Worm** : Propagation autonome via le r√©seau
- **Trojan** : Backdoor d√©guis√© en logiciel l√©gitime
- **Ransomware** : Chiffrement + demande de ran√ßon
- **Rootkit** : Dissimulation de pr√©sence (processus, fichiers)
- **Bootkit** : Infection au niveau boot (MBR, UEFI)

### 5.2 LDA ‚Äî Traduction litt√©rale en fran√ßais (MAJUSCULES)

```
FONCTION classify_specimen QUI RETOURNE UN DICTIONNAIRE ET PREND EN PARAM√àTRE characteristics QUI EST UN DICTIONNAIRE
D√âBUT FONCTION

    D√âCLARER scores COMME DICTIONNAIRE ASSOCIANT CHAQUE TYPE √Ä UN SCORE FLOTTANT
    AFFECTER 0.0 √Ä scores["virus"]
    AFFECTER 0.0 √Ä scores["worm"]
    AFFECTER 0.0 √Ä scores["trojan"]
    AFFECTER 0.0 √Ä scores["ransomware"]
    AFFECTER 0.0 √Ä scores["rootkit"]
    AFFECTER 0.0 √Ä scores["bootkit"]

    D√âCLARER subtypes COMME LISTE VIDE

    SI characteristics CONTIENT "self_replicates" ET SA VALEUR EST VRAIE
    ET characteristics CONTIENT "network_spread" ET SA VALEUR EST FAUSSE ALORS
        AJOUTER 0.6 AU SCORE DE virus
        AJOUTER "file_infector" √Ä LA LISTE subtypes
    FIN SI

    SI characteristics CONTIENT "network_spread" ET SA VALEUR EST VRAIE ALORS
        AJOUTER 0.7 AU SCORE DE worm
        AJOUTER "network_propagation" √Ä LA LISTE subtypes
    FIN SI

    SI characteristics CONTIENT "encrypts_files" ET SA VALEUR EST VRAIE ALORS
        AJOUTER 0.8 AU SCORE DE ransomware
        AJOUTER "crypto_ransomware" √Ä LA LISTE subtypes
    FIN SI

    SI characteristics CONTIENT "hides_processes" ET SA VALEUR EST VRAIE ALORS
        AJOUTER 0.7 AU SCORE DE rootkit
        AJOUTER "process_hiding" √Ä LA LISTE subtypes
    FIN SI

    SI characteristics CONTIENT "modifies_mbr" ET SA VALEUR EST VRAIE
    OU characteristics CONTIENT "persistence_method" ET SA VALEUR EST "bootkit" ALORS
        AJOUTER 0.9 AU SCORE DE bootkit
        AJOUTER "mbr_infection" √Ä LA LISTE subtypes
    FIN SI

    SI characteristics CONTIENT "creates_backdoor" ET SA VALEUR EST VRAIE ALORS
        AJOUTER 0.6 AU SCORE DE trojan
        AJOUTER "remote_access" √Ä LA LISTE subtypes
    FIN SI

    TROUVER LE TYPE AVEC LE SCORE MAXIMAL DANS scores ET LE STOCKER DANS primary_type
    AFFECTER LE SCORE DE primary_type √Ä confidence

    CALCULER LE NOMBRE DE TYPES ACTIFS (score > 0.3)
    SI LE NOMBRE DE TYPES ACTIFS EST SUP√âRIEUR √Ä 1 ALORS
        MULTIPLIER confidence PAR 0.85
    FIN SI

    CALCULER LA SOMME DE TOUS LES SCORES
    SI LA SOMME EST SUP√âRIEURE OU √âGALE √Ä 1.5
    OU encrypts_files EST VRAI
    OU modifies_mbr EST VRAI ALORS
        AFFECTER "critical" √Ä risk_level
    SINON SI LA SOMME EST SUP√âRIEURE OU √âGALE √Ä 0.8 ALORS
        AFFECTER "high" √Ä risk_level
    SINON SI LA SOMME EST SUP√âRIEURE OU √âGALE √Ä 0.4 ALORS
        AFFECTER "medium" √Ä risk_level
    SINON
        AFFECTER "low" √Ä risk_level
    FIN SI

    RETOURNER UN DICTIONNAIRE CONTENANT
        primary_type
        confidence ARRONDI √Ä 2 D√âCIMALES
        subtypes D√âDUPLIQU√âS
        risk_level

FIN FONCTION
```

### 5.2.2 Style acad√©mique universitaire fran√ßais

**Algorithme de classification de sp√©cimens malveillants**

```
Entr√©e : Ensemble C = {c‚ÇÅ, c‚ÇÇ, ..., c‚Çô} de caract√©ristiques binaires
Sortie : Tuple (œÑ, œÜ, Œ£, œÅ) o√π :
         œÑ ‚àà {virus, worm, trojan, ransomware, rootkit, bootkit}
         œÜ ‚àà [0, 1] (coefficient de confiance)
         Œ£ = ensemble de sous-types d√©tect√©s
         œÅ ‚àà {low, medium, high, critical} (niveau de risque)

1. Initialisation :
   ‚àÄ t ‚àà {virus, worm, trojan, ransomware, rootkit, bootkit}, s(t) ‚Üê 0
   Œ£ ‚Üê ‚àÖ

2. Calcul des scores par type :
   Si c_self_replicates ‚àß ¬¨c_network_spread :
       s(virus) ‚Üê s(virus) + 0.6
       Œ£ ‚Üê Œ£ ‚à™ {file_infector}

   Si c_network_spread :
       s(worm) ‚Üê s(worm) + 0.7
       Œ£ ‚Üê Œ£ ‚à™ {network_propagation}

   Si c_encrypts_files :
       s(ransomware) ‚Üê s(ransomware) + 0.8
       Œ£ ‚Üê Œ£ ‚à™ {crypto_ransomware}

   Si c_hides_processes :
       s(rootkit) ‚Üê s(rootkit) + 0.7
       Œ£ ‚Üê Œ£ ‚à™ {process_hiding}

   Si c_modifies_mbr ‚à® (c_persistence = "bootkit") :
       s(bootkit) ‚Üê s(bootkit) + 0.9
       Œ£ ‚Üê Œ£ ‚à™ {mbr_infection}

   Si c_creates_backdoor :
       s(trojan) ‚Üê s(trojan) + 0.6
       Œ£ ‚Üê Œ£ ‚à™ {remote_access}

3. D√©termination du type principal :
   œÑ ‚Üê argmax_{t} s(t)
   œÜ ‚Üê s(œÑ)

4. Ajustement de confiance (menaces hybrides) :
   n_active ‚Üê |{t : s(t) > 0.3}|
   Si n_active > 1 :
       œÜ ‚Üê œÜ √ó 0.85

5. Calcul du niveau de risque :
   r ‚Üê Œ£_t s(t)
   Si r ‚â• 1.5 ‚à® c_encrypts_files ‚à® c_modifies_mbr :
       œÅ ‚Üê critical
   Sinon si r ‚â• 0.8 :
       œÅ ‚Üê high
   Sinon si r ‚â• 0.4 :
       œÅ ‚Üê medium
   Sinon :
       œÅ ‚Üê low

6. Retourner (œÑ, œÜ, Œ£, œÅ)
```

#### 5.2.2.1 Logic Flow (Structured English)

```
ALGORITHM: Malware Specimen Classification
---
INPUT: characteristics = {behavioral_flags, persistence_info}
OUTPUT: classification = {type, confidence, subtypes, risk}

1. INITIALIZE scoring system
   a. CREATE score dictionary for all 6 malware types
   b. SET all scores to 0.0
   c. CREATE empty subtypes list

2. ANALYZE behavioral characteristics (Main Classification Logic)
   a. CHECK self-replication WITHOUT network spread:
      - IF detected:
          INCREMENT virus score by 0.6
          ADD "file_infector" to subtypes

   b. CHECK network propagation:
      - IF detected:
          INCREMENT worm score by 0.7
          ADD "network_propagation" to subtypes

   c. CHECK file encryption:
      - IF detected:
          INCREMENT ransomware score by 0.8
          ADD "crypto_ransomware" to subtypes

   d. CHECK process hiding:
      - IF detected:
          INCREMENT rootkit score by 0.7
          ADD "process_hiding" to subtypes

   e. CHECK MBR modification OR bootkit persistence:
      - IF detected:
          INCREMENT bootkit score by 0.9
          ADD "mbr_infection" to subtypes

   f. CHECK backdoor creation:
      - IF detected:
          INCREMENT trojan score by 0.6
          ADD "remote_access" to subtypes

3. DETERMINE primary classification
   a. FIND type with maximum score
   b. SET confidence = score of primary type

4. ADJUST confidence for hybrid threats
   a. COUNT active types (score > 0.3)
   b. IF more than 1 active type:
       MULTIPLY confidence by 0.85 (hybrid penalty)

5. CALCULATE risk level
   a. SUM all scores
   b. APPLY risk matrix:
      - CASE sum >= 1.5 OR encrypts_files OR modifies_mbr:
          SET risk = "critical"
      - CASE sum >= 0.8:
          SET risk = "high"
      - CASE sum >= 0.4:
          SET risk = "medium"
      - DEFAULT:
          SET risk = "low"

6. RETURN classification object
   {
     primary_type: identified_type,
     confidence: rounded_confidence,
     subtypes: deduplicated_list,
     risk_level: calculated_risk
   }
```

### 5.2.3 Repr√©sentation algorithmique

```
FONCTION : classify_specimen (characteristics)
---
INIT result = {primary_type: null, confidence: 0, subtypes: [], risk_level: "low"}

1. PHASE DE VALIDATION (Fail Fast)
   |
   |-- V√âRIFIER si characteristics n'est pas un dictionnaire :
   |     RETOURNER {error: "Invalid input"}
   |
   |-- V√âRIFIER si characteristics est vide :
   |     RETOURNER {primary_type: "unknown", confidence: 0.0, subtypes: [], risk_level: "low"}

2. PHASE DE SCORING (Behavioral Analysis)
   |
   |-- POUR CHAQUE type de malware :
   |     |
   |     |-- SI conditions du type sont remplies :
   |     |     INCR√âMENTER score[type]
   |     |     AJOUTER sous-type correspondant
   |
   |-- EXEMPLE (Virus) :
   |     SI self_replicates ET NON network_spread :
   |         score["virus"] += 0.6
   |         subtypes.append("file_infector")

3. PHASE DE D√âCISION (Primary Type Selection)
   |
   |-- TROUVER le type avec le score maximal
   |-- AFFECTER confidence = score du type principal
   |
   |-- SI plusieurs types actifs (score > 0.3) :
   |     R√âDUIRE confidence de 15% (menace hybride)

4. PHASE D'√âVALUATION DU RISQUE (Risk Assessment)
   |
   |-- CALCULER score_total = somme de tous les scores
   |
   |-- APPLIQUER matrice de risque :
   |     SI score_total >= 1.5 OU encrypts_files OU modifies_mbr :
   |         risk_level = "critical"
   |     SINON SI score_total >= 0.8 :
   |         risk_level = "high"
   |     SINON SI score_total >= 0.4 :
   |         risk_level = "medium"
   |     SINON :
   |         risk_level = "low"

5. RETOURNER result compl√©t√©
```

#### 5.2.3.1 Diagramme Mermaid (Logique de s√©curit√©)

```mermaid
graph TD
    A[D√©but: classify_specimen] --> B{characteristics est dict ?}
    B -- Non --> C[RETOUR: error Invalid input]
    B -- Oui --> D[Initialiser scores = 0.0 pour tous types]

    D --> E{self_replicates ET NON network_spread ?}
    E -- Oui --> F[score virus += 0.6]
    E -- Non --> G{network_spread ?}

    F --> G
    G -- Oui --> H[score worm += 0.7]
    G -- Non --> I{encrypts_files ?}

    H --> I
    I -- Oui --> J[score ransomware += 0.8<br/>risk = critical]
    I -- Non --> K{hides_processes ?}

    J --> K
    K -- Oui --> L[score rootkit += 0.7]
    K -- Non --> M{modifies_mbr ?}

    L --> M
    M -- Oui --> N[score bootkit += 0.9<br/>risk = critical]
    M -- Non --> O{creates_backdoor ?}

    N --> O
    O -- Oui --> P[score trojan += 0.6]
    O -- Non --> Q[Trouver max score]

    P --> Q
    Q --> R{Nombre de types actifs > 1 ?}
    R -- Oui --> S[confidence *= 0.85<br/>Menace hybride]
    R -- Non --> T[confidence = score max]

    S --> U[Calculer risk_level final]
    T --> U

    U --> V{score_total >= 1.5 ?}
    V -- Oui --> W[risk = critical]
    V -- Non --> X{score_total >= 0.8 ?}
    X -- Oui --> Y[risk = high]
    X -- Non --> Z{score_total >= 0.4 ?}
    Z -- Oui --> AA[risk = medium]
    Z -- Non --> AB[risk = low]

    W --> AC[RETOUR: classification compl√®te]
    Y --> AC
    AA --> AC
    AB --> AC
```

### 5.3 Visualisation ASCII (adapt√©e au sujet)

**Architecture de classification (flux de d√©cision)**

```
                    MALWARE SPECIMEN
                          ‚îÇ
                          ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ   BEHAVIORAL ANALYSIS          ‚îÇ
         ‚îÇ   (8 caract√©ristiques)         ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ               ‚îÇ               ‚îÇ
          ‚ñº               ‚ñº               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ VIRUS   ‚îÇ     ‚îÇ  WORM   ‚îÇ     ‚îÇ TROJAN  ‚îÇ
    ‚îÇ score:  ‚îÇ     ‚îÇ score:  ‚îÇ     ‚îÇ score:  ‚îÇ
    ‚îÇ  0.6    ‚îÇ     ‚îÇ  0.7    ‚îÇ     ‚îÇ  0.6    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ               ‚îÇ               ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ  MAX SCORE SELECTOR  ‚îÇ
              ‚îÇ  primary_type = ?    ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ              ‚îÇ              ‚îÇ
          ‚ñº              ‚ñº              ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇCONFIDENCE‚îÇ    ‚îÇ SUBTYPES ‚îÇ   ‚îÇ  RISK   ‚îÇ
    ‚îÇ  0.0-1.0 ‚îÇ    ‚îÇ  array   ‚îÇ   ‚îÇ LEVEL   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Matrice de scoring (exemple Hybrid Worm+Ransomware)**

```
Caract√©ristiques :          Scoring par type :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ network_spread: ‚úì    ‚îÇ   ‚îÇ Virus:      0.0 (‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ)‚îÇ
‚îÇ encrypts_files: ‚úì    ‚îÇ   ‚îÇ Worm:       0.7 (‚ñà‚ñà‚ñà‚îÄ‚îÄ)‚îÇ
‚îÇ self_replicates: ‚úó   ‚îÇ   ‚îÇ Trojan:     0.0 (‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ)‚îÇ
‚îÇ hides_processes: ‚úó   ‚îÇ   ‚îÇ Ransomware: 0.8 (‚ñà‚ñà‚ñà‚ñà‚îÄ)‚îÇ ‚Üê MAX
‚îÇ modifies_mbr: ‚úó      ‚îÇ   ‚îÇ Rootkit:    0.0 (‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ)‚îÇ
‚îÇ creates_backdoor: ‚úó  ‚îÇ   ‚îÇ Bootkit:    0.0 (‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Active types: 2 (Worm + Ransomware)
‚Üí Hybrid detected
‚Üí Confidence: 0.8 √ó 0.85 = 0.68

Subtypes: ["network_propagation", "crypto_ransomware"]
Risk: CRITICAL (encrypts_files = true)
```

**Timeline de propagation (Worm vs Virus)**

```
VIRUS (Auto-r√©plication locale)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
t=0   : File A infect√©
t=10  : Utilisateur ex√©cute File B ‚Üí Infection File B
t=20  : File B copi√© sur USB ‚Üí Propagation manuelle
         ‚îÇ
         ‚îî‚îÄ‚Üí LENT (d√©pend de l'utilisateur)

WORM (Auto-propagation r√©seau)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
t=0   : Machine A infect√©e
t=1   : Scan r√©seau ‚Üí d√©couverte de Machine B, C, D
t=2   : Exploitation vuln√©rabilit√© ‚Üí Infection B, C, D
t=3   : B, C, D scannent ‚Üí d√©couverte de 12 machines
         ‚îÇ
         ‚îî‚îÄ‚Üí RAPIDE (exponentiel)

Graphe de propagation Worm :
t=0 :  A
t=1 :  A ‚Üí B, C, D
t=2 :  A, B, C, D ‚Üí E, F, G, H, I, J, K, L, M, N, O, P
t=3 :  [explosion combinatoire : 64+ machines]
```

### 5.4 Les pi√®ges en d√©tail

#### Pi√®ge 1 : Confondre Virus et Worm

**Le pi√®ge :**
```python
if characteristics.get("self_replicates"):
    return {"primary_type": "worm", ...}  # ‚ùå FAUX
```

**Pourquoi c'est un pi√®ge :**
- Un **Virus** se r√©plique en infectant des fichiers h√¥tes (n√©cessite action utilisateur)
- Un **Worm** se propage de mani√®re autonome via le r√©seau (sans intervention)
- La diff√©rence cl√© : `network_spread`

**La bonne approche :**
```python
if self_replicates and not network_spread:
    scores["virus"] += 0.6  # Virus (local)
if network_spread:
    scores["worm"] += 0.7   # Worm (r√©seau)
```

#### Pi√®ge 2 : Ignorer les menaces hybrides

**Le pi√®ge :**
```python
# Retourner imm√©diatement le premier type trouv√©
if encrypts_files:
    return {"primary_type": "ransomware", ...}
# Ne jamais v√©rifier network_spread
```

**Pourquoi c'est un pi√®ge :**
WannaCry √©tait un **Worm+Ransomware**. Classifier uniquement comme "ransomware" ignore le vecteur de propagation EternalBlue (SMB exploit).

**La bonne approche :**
```python
# Calculer TOUS les scores
scores = calculate_all_scores(characteristics)
# Puis d√©terminer le primary avec le max
primary_type = max(scores, key=scores.get)
# ET lister les subtypes pour capturer l'hybride
subtypes = ["network_propagation", "crypto_ransomware"]
```

#### Pi√®ge 3 : Confidence score fixe

**Le pi√®ge :**
```python
return {
    "primary_type": "virus",
    "confidence": 1.0  # ‚ùå Toujours 100% s√ªr
}
```

**Pourquoi c'est un pi√®ge :**
La confiance doit refl√©ter l'ambigu√Øt√©. Un malware avec un seul indicateur faible (ex: `drops_payload` seulement) ne peut pas √™tre classifi√© avec 100% de certitude.

**La bonne approche :**
```python
confidence = scores[primary_type]  # Utiliser le score calcul√©
# R√©duire pour les hybrides
if active_types > 1:
    confidence *= 0.85
```

#### Pi√®ge 4 : Risk level ignorant l'impact r√©el

**Le pi√®ge :**
```python
risk_level = "medium"  # Pour tous les types
```

**Pourquoi c'est un pi√®ge :**
- **Ransomware** : Perte de donn√©es irr√©versible ‚Üí CRITICAL
- **Bootkit** : Persistence au boot, difficile √† √©radiquer ‚Üí CRITICAL
- **Adware** : Ennuyeux mais non destructif ‚Üí LOW

**La bonne approche :**
```python
if encrypts_files or modifies_mbr:
    risk_level = "critical"  # Impact majeur
elif score_total >= 0.8:
    risk_level = "high"
# etc.
```

#### Pi√®ge 5 : Ne pas valider l'entr√©e

**Le pi√®ge :**
```python
def classify_specimen(characteristics):
    # Pas de v√©rification
    encrypts = characteristics["encrypts_files"]  # KeyError
```

**Pourquoi c'est un pi√®ge :**
En environnement r√©el, les donn√©es peuvent √™tre malform√©es, incompl√®tes, ou malicieuses.

**La bonne approche :**
```python
if not isinstance(characteristics, dict):
    return {"error": "Invalid input"}

encrypts = characteristics.get("encrypts_files", False)  # Valeur par d√©faut
```

### 5.5 Cours Complet : Taxonomie des Malwares

#### Introduction : Pourquoi classifier ?

Dans un SOC (Security Operations Center), un analyste re√ßoit des milliers d'alertes par jour. Sans classification rapide, impossible de prioriser. Un **bootkit UEFI** n√©cessite une r√©ponse imm√©diate (r√©imagerie compl√®te), alors qu'un **adware** peut attendre.

La taxonomie des malwares repose sur **3 crit√®res** :

1. **M√©thode de propagation** : Comment il se r√©pand
2. **M√©canisme de persistence** : Comment il survit aux red√©marrages
3. **Payload/Impact** : Ce qu'il fait une fois install√©

#### Les 6 types principaux

##### 1. VIRUS (Infecteur de fichiers)

**D√©finition** : Malware qui s'auto-r√©plique en **infectant des fichiers h√¥tes**.

**Caract√©ristiques** :
- `self_replicates = true`
- `network_spread = false` (propagation manuelle : USB, email)
- N√©cessite ex√©cution par l'utilisateur

**M√©thode d'infection** :
```
1. Virus trouve un ex√©cutable (ex: program.exe)
2. Virus s'ins√®re dans le fichier :
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Virus code     ‚îÇ ‚Üê Ajout√© au d√©but/milieu/fin
   ‚îÇ  Original code  ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
3. Lors de l'ex√©cution :
   a. Le virus s'ex√©cute en premier
   b. Puis l'original (pour rester furtif)
```

**Exemples r√©els** :
- **CIH (Chernobyl, 1998)** : Infectait les PE (Portable Executable)
- **Melissa (1999)** : Virus macro infectant Word documents

**Sous-types** :
- **File infector** : Infecte .exe, .dll
- **Macro virus** : Infecte Office documents (VBA macros)
- **Boot sector virus** : Infecte le secteur de boot (obsol√®te aujourd'hui)

##### 2. WORM (Ver r√©seau)

**D√©finition** : Malware qui se propage **automatiquement via le r√©seau**.

**Caract√©ristiques** :
- `network_spread = true`
- Scan automatique du r√©seau
- Exploitation de vuln√©rabilit√©s (pas d'interaction utilisateur n√©cessaire)

**Cycle de vie** :
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. SCAN                                ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí D√©couverte de machines (IP)    ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ 2. EXPLOIT                             ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Vuln√©rabilit√© (ex: SMB)        ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ 3. PAYLOAD                             ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí T√©l√©chargement du worm         ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ 4. EXECUTION                           ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Le worm s'ex√©cute sur la cible ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ 5. R√âP√âTITION                          ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Retour √† l'√©tape 1             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Exemples r√©els** :
- **WannaCry (2017)** : Exploit EternalBlue (SMB), d√©ploie ransomware
- **Conficker (2008)** : A infect√© 9-15 millions de machines
- **Stuxnet (2010)** : Worm APT ciblant les centrifugeuses iraniennes

**Diff√©rence Virus vs Worm** :
```
VIRUS                     WORM
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
N√©cessite h√¥te            Autonome
Action utilisateur        Automatique
Propagation lente         Exponentielle
USB, email                R√©seau (LAN/WAN)
```

##### 3. TROJAN (Cheval de Troie)

**D√©finition** : Malware d√©guis√© en logiciel l√©gitime, cr√©e une **backdoor**.

**Caract√©ristiques** :
- `creates_backdoor = true`
- D√©guisement (faux antivirus, crack de jeu vid√©o)
- Acc√®s √† distance (RAT : Remote Access Trojan)

**Architecture typique** :
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VICTIM MACHINE   ‚îÇ         ‚îÇ   C2 SERVER        ‚îÇ
‚îÇ                    ‚îÇ         ‚îÇ  (Command & Control‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îÇ   TROJAN     ‚îÇ  ‚îÇ                  ‚îÇ
‚îÇ  ‚îÇ   (backdoor) ‚îÇ‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ    1. Beaconing (heartbeat)
‚îÇ         ‚îÇ          ‚îÇ    2. Commands (shell, keylog)
‚îÇ         ‚ñº          ‚îÇ    3. Data exfiltration
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  KEYLOGGER   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  SCREENSHOT  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  FILE STEAL  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Exemples r√©els** :
- **Zeus (2007)** : Banking trojan, vol de credentials
- **DarkComet** : RAT utilis√© par des script kiddies
- **Emotet** : Trojan dropper d√©ployant d'autres malwares

**Sous-types** :
- **RAT** : Remote Access (contr√¥le total)
- **Banker** : Vol de donn√©es bancaires
- **Dropper** : T√©l√©charge et installe d'autres malwares

##### 4. RANSOMWARE (Ran√ßongiciel)

**D√©finition** : Malware qui **chiffre les fichiers** et demande une ran√ßon.

**Caract√©ristiques** :
- `encrypts_files = true`
- Demande de paiement (Bitcoin g√©n√©ralement)
- **Crypto-ransomware** (chiffre) vs **Locker** (bloque l'√©cran)

**Cycle d'attaque** :
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. INFECTION                                  ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí Phishing email                         ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí Exploit kit (RIG, Magnitude)           ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Worm (WannaCry via EternalBlue)        ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ 2. RECONNAISSANCE                             ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí D√©couverte des drives (C:, D:, r√©seau)‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Listing des fichiers (.doc, .pdf, etc)‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ 3. CHIFFREMENT                                ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí G√©n√©ration cl√© AES-256                 ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí Chiffrement fichiers                   ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Cl√© AES chiffr√©e avec RSA-2048 (C2)   ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ 4. RAN√áON                                     ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí Affichage note de ran√ßon               ‚îÇ
‚îÇ    ‚îú‚îÄ‚Üí Countdown timer (urgence)              ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Adresse Bitcoin                        ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ 5. DESTRUCTION (optionnel)                    ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí Suppression shadow copies (vssadmin)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Exemples r√©els** :
- **WannaCry (2017)** : $4 milliards de dommages
- **NotPetya (2017)** : Wiper d√©guis√© en ransomware (APT russe)
- **REvil/Sodinokibi** : Ransomware-as-a-Service (RaaS)

**Crypto vs Locker** :
```
CRYPTO-RANSOMWARE           SCREEN LOCKER
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Chiffre les fichiers        Bloque l'√©cran
Irr√©versible sans cl√©       Bypassable
Dommages permanents         Ennuyeux
Ex: WannaCry                Ex: Police Locker
```

##### 5. ROOTKIT (Dissimulation)

**D√©finition** : Malware qui **cache sa pr√©sence** au syst√®me.

**Caract√©ristiques** :
- `hides_processes = true`
- Modification des API syst√®me (hooks)
- Userland ou Kernel-mode

**Niveaux de rootkit** :
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       APPLICATION LAYER                ‚îÇ
‚îÇ  (Browsers, Office, Games)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì syscalls
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       USER-MODE ROOTKIT                ‚îÇ ‚Üê Hook DLLs (ntdll.dll)
‚îÇ  Hook API calls (CreateFile, etc)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì syscalls
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Kernel Boundary
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       KERNEL-MODE ROOTKIT              ‚îÇ ‚Üê Hook SSDT, IDT
‚îÇ  Invisibilit√© totale                    ‚îÇ
‚îÇ  (processus, fichiers, registry)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       HARDWARE                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Techniques de dissimulation** :
```
1. PROCESS HIDING :
   Task Manager affiche :
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ chrome.exe      ‚îÇ
   ‚îÇ explorer.exe    ‚îÇ
   ‚îÇ notepad.exe     ‚îÇ ‚Üê rootkit.exe invisible !
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

2. FILE HIDING :
   Dir C:\malware\
   ‚Üí "File Not Found" (mais le fichier existe)

3. REGISTRY HIDING :
   HKLM\...\Run\Malware
   ‚Üí Cl√© invisible au regedit

4. NETWORK HIDING :
   netstat -ano
   ‚Üí Connexion C2 invisible
```

**Exemples r√©els** :
- **Sony BMG (2005)** : Rootkit DRM dans CD musicaux (l√©gal mais malveillant)
- **Hacker Defender** : Rootkit userland populaire
- **TDL4/TDSS** : Rootkit kernel-mode sophistiqu√©

##### 6. BOOTKIT (Infection boot)

**D√©finition** : Malware qui infecte le **processus de boot** (MBR, UEFI).

**Caract√©ristiques** :
- `modifies_mbr = true` ou `persistence_method = "bootkit"`
- Ex√©cution AVANT le syst√®me d'exploitation
- Invisibilit√© maximale (kernel pas encore charg√©)

**Boot sequence hijacking** :
```
NORMAL BOOT                 BOOTKIT BOOT
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. BIOS/UEFI                1. BIOS/UEFI
2. MBR (Master Boot Record) 2. MBR (infect√©) ‚Üê BOOTKIT
3. Bootloader (Windows)     3. Bootloader (corrompu)
4. Kernel (ntoskrnl.exe)    4. Kernel (patch√©)
5. OS charg√©                5. OS + Bootkit actif

Le bootkit s'ex√©cute AVANT l'antivirus !
```

**Types de bootkits** :
```
MBR BOOTKIT (Legacy BIOS)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Secteur 0 (512 bytes)      ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ Bootkit code (stage 1) ‚îÇ ‚îÇ ‚Üê Inject√© ici
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ Signature: 0x55AA          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

UEFI BOOTKIT (Modern)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ EFI System Partition (ESP) ‚îÇ
‚îÇ \EFI\Microsoft\Boot\       ‚îÇ
‚îÇ  bootmgfw.efi (infect√©) ‚Üê  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Exemples r√©els** :
- **Rovnix (2011)** : MBR bootkit, infection VBR
- **LoJax (2018)** : Premier UEFI bootkit in-the-wild (APT28/Fancy Bear)
- **MoonBounce (2022)** : UEFI firmware rootkit (APT41)

**Pourquoi c'est CRITICAL** :
- Survit √† une r√©installation Windows (le MBR/UEFI n'est pas effac√©)
- Invisible aux antivirus (ex√©cution pr√©-OS)
- N√©cessite reflash du firmware ou remplacement du SSD

#### Menaces hybrides

La r√©alit√© moderne : la plupart des malwares combinent plusieurs techniques.

**Exemple : WannaCry**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PRIMARY: Ransomware             ‚îÇ ‚Üê Impact principal
‚îÇ  ‚îú‚îÄ‚Üí Chiffrement AES            ‚îÇ
‚îÇ  ‚îî‚îÄ‚Üí Demande de ran√ßon          ‚îÇ
‚îÇ                                 ‚îÇ
‚îÇ PROPAGATION: Worm               ‚îÇ ‚Üê Vecteur critique
‚îÇ  ‚îú‚îÄ‚Üí EternalBlue (SMB exploit)  ‚îÇ
‚îÇ  ‚îî‚îÄ‚Üí DoublePulsar (backdoor)    ‚îÇ
‚îÇ                                 ‚îÇ
‚îÇ DROPPER: Trojan                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚Üí T√©l√©charge payload crypto  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Classification :
  primary_type: "ransomware" (payload principal)
  subtypes: ["crypto_ransomware", "network_propagation"]
  confidence: 0.68 (hybride, donc r√©duit)
  risk_level: "critical"
```

**Strat√©gie de classification** :
1. **Calculer tous les scores** (ne pas s'arr√™ter au premier match)
2. **Primary type = max score** (le comportement dominant)
3. **Subtypes = tous actifs** (pour capturer l'hybride)
4. **R√©duire confidence** si hybride (incertitude)

#### MITRE ATT&CK Framework

Le framework **MITRE ATT&CK** (Adversarial Tactics, Techniques, and Common Knowledge) est le standard industriel pour d√©crire les comportements malveillants.

**Exemple de mapping** :
```
MALWARE BEHAVIOR          ‚Üí  MITRE TECHNIQUE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
encrypts_files            ‚Üí  T1486 (Data Encrypted for Impact)
network_spread            ‚Üí  T1210 (Exploitation of Remote Services)
creates_backdoor          ‚Üí  T1059 (Command and Scripting Interpreter)
hides_processes           ‚Üí  T1055 (Process Injection)
credential_dumping        ‚Üí  T1003 (OS Credential Dumping)
c2_beaconing              ‚Üí  T1071 (Application Layer Protocol)
lateral_movement          ‚Üí  T1021 (Remote Services)
modifies_mbr              ‚Üí  T1542 (Pre-OS Boot)
```

**Utilit√© du mapping** :
- **Threat Intel** : Comparer √† des campagnes connues
- **Playbook** : Strat√©gie de r√©ponse par technique
- **Hunting** : Chercher des IOCs associ√©s

### 5.6 Normes avec explications p√©dagogiques

#### Norme 1 : Utiliser `.get()` pour les dictionnaires

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (crash sur cl√© manquante)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ encrypts = characteristics["encrypts_files"]                    ‚îÇ
‚îÇ # KeyError si la cl√© n'existe pas                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ encrypts = characteristics.get("encrypts_files", False)         ‚îÇ
‚îÇ # Retourne False par d√©faut si cl√© absente                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ Robustesse : G√®re les donn√©es incompl√®tes                     ‚îÇ
‚îÇ ‚Ä¢ D√©fense en profondeur : Assume que l'entr√©e peut √™tre hostile‚îÇ
‚îÇ ‚Ä¢ Lisibilit√© : Le d√©faut est explicite                          ‚îÇ
‚îÇ ‚Ä¢ Production : Les APIs externes ne sont jamais garanties       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Norme 2 : Validation d'entr√©e (Fail Fast)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (pas de validation)                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ def classify(characteristics):                                 ‚îÇ
‚îÇ     # Assume que c'est un dict valide                          ‚îÇ
‚îÇ     encrypts = characteristics["encrypts_files"]                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ def classify(characteristics):                                 ‚îÇ
‚îÇ     if not isinstance(characteristics, dict):                  ‚îÇ
‚îÇ         return {"error": "Invalid input"}                      ‚îÇ
‚îÇ     encrypts = characteristics.get("encrypts_files", False)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ Principe Fail Fast : √âchouer vite si input invalide           ‚îÇ
‚îÇ ‚Ä¢ S√©curit√© : √âviter les injections ou donn√©es malform√©es        ‚îÇ
‚îÇ ‚Ä¢ Debugging : Message d'erreur clair                            ‚îÇ
‚îÇ ‚Ä¢ Production : Jamais faire confiance √† l'input utilisateur     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Norme 3 : Arrondir les flottants (confidence)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (15 d√©cimales)                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ confidence = 0.6800000000000001                                 ‚îÇ
‚îÇ # Impr√©cision des flottants en Python                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ confidence = round(0.6800000000000001, 2)  # ‚Üí 0.68             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ Lisibilit√© : 0.68 au lieu de 0.6800000000000001               ‚îÇ
‚îÇ ‚Ä¢ JSON serialization : √âviter les longs floats                  ‚îÇ
‚îÇ ‚Ä¢ Pr√©cision : 2 d√©cimales suffisent pour un pourcentage         ‚îÇ
‚îÇ ‚Ä¢ Comparaison : √âviter 0.68 == 0.6800000000000001 (false)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Norme 4 : D√©duplication des listes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ùå HORS NORME (doublons)                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ subtypes = ["file_infector", "file_infector", "dropper"]       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚úÖ CONFORME                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ subtypes = list(set(["file_infector", "file_infector", ...]))  ‚îÇ
‚îÇ # ‚Üí ["file_infector", "dropper"]                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìñ POURQUOI ?                                                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ‚Ä¢ Coh√©rence : Une caract√©ristique appara√Æt une seule fois       ‚îÇ
‚îÇ ‚Ä¢ Taille : JSON plus compact                                    ‚îÇ
‚îÇ ‚Ä¢ S√©mantique : Les sous-types sont un ensemble, pas une liste   ‚îÇ
‚îÇ ‚Ä¢ Performance : √âviter de parser des doublons c√¥t√© client       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.7 Simulation avec trace d'ex√©cution

**Exemple : Hybrid Worm+Ransomware (WannaCry-like)**

**Input :**
```json
{
  "self_replicates": false,
  "network_spread": true,
  "encrypts_files": true,
  "hides_processes": false,
  "modifies_mbr": false,
  "creates_backdoor": false,
  "drops_payload": true,
  "persistence_method": "registry"
}
```

**Trace d'ex√©cution :**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtape  ‚îÇ Instruction                                  ‚îÇ √âtat des variables           ‚îÇ Explication                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   1    ‚îÇ INITIALISER scores = {}                      ‚îÇ scores = {virus:0, worm:0,   ‚îÇ Cr√©ation du dict de scores ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ  trojan:0, ransomware:0,     ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ  rootkit:0, bootkit:0}       ‚îÇ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   2    ‚îÇ INITIALISER subtypes = []                    ‚îÇ subtypes = []                ‚îÇ Liste vide de sous-types   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   3    ‚îÇ SI self_replicates ET NON network_spread     ‚îÇ false ET NON true = false    ‚îÇ Condition virus : FAUX     ‚îÇ
‚îÇ        ‚îÇ (condition virus)                            ‚îÇ                              ‚îÇ ‚Üí skip                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4    ‚îÇ SI network_spread (condition worm)           ‚îÇ true                         ‚îÇ VRAI ‚Üí ex√©cution           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   5    ‚îÇ   scores["worm"] += 0.7                      ‚îÇ scores["worm"] = 0.7         ‚îÇ Worm d√©tect√©               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   6    ‚îÇ   subtypes.append("network_propagation")     ‚îÇ subtypes =                   ‚îÇ Ajout du sous-type         ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ   ["network_propagation"]    ‚îÇ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7    ‚îÇ SI encrypts_files (condition ransomware)     ‚îÇ true                         ‚îÇ VRAI ‚Üí ex√©cution           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   8    ‚îÇ   scores["ransomware"] += 0.8                ‚îÇ scores["ransomware"] = 0.8   ‚îÇ Ransomware d√©tect√©         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   9    ‚îÇ   subtypes.append("crypto_ransomware")       ‚îÇ subtypes =                   ‚îÇ Ajout du sous-type         ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ   ["network_propagation",    ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ    "crypto_ransomware"]      ‚îÇ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   10   ‚îÇ SI hides_processes (condition rootkit)       ‚îÇ false                        ‚îÇ FAUX ‚Üí skip                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   11   ‚îÇ SI modifies_mbr OU persistence="bootkit"     ‚îÇ false OU false = false       ‚îÇ FAUX ‚Üí skip                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   12   ‚îÇ SI creates_backdoor (condition trojan)       ‚îÇ false                        ‚îÇ FAUX ‚Üí skip                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   13   ‚îÇ SI drops_payload                             ‚îÇ true                         ‚îÇ VRAI ‚Üí ex√©cution           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   14   ‚îÇ   scores["trojan"] += 0.3                    ‚îÇ scores["trojan"] = 0.3       ‚îÇ Dropper d√©tect√©            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   15   ‚îÇ   subtypes.append("dropper")                 ‚îÇ subtypes =                   ‚îÇ Ajout du sous-type         ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ   ["network_propagation",    ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ    "crypto_ransomware",      ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ    "dropper"]                ‚îÇ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   16   ‚îÇ SI persistence in ["registry", "service"]    ‚îÇ "registry" in [...] = true   ‚îÇ VRAI ‚Üí ex√©cution           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   17   ‚îÇ   scores["trojan"] += 0.2                    ‚îÇ scores["trojan"] = 0.5       ‚îÇ Persistence registry       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   18   ‚îÇ primary_type = max(scores, key=...)          ‚îÇ primary_type = "ransomware"  ‚îÇ Max = 0.8 (ransomware)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   19   ‚îÇ confidence = scores[primary_type]            ‚îÇ confidence = 0.8             ‚îÇ Score du type principal    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   20   ‚îÇ active_types = sum(1 for s if s > 0.3)       ‚îÇ active_types = 3             ‚îÇ Worm(0.7), Ransom(0.8),    ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ                              ‚îÇ Trojan(0.5) > 0.3          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   21   ‚îÇ SI active_types > 1                          ‚îÇ 3 > 1 = true                 ‚îÇ Hybride d√©tect√©            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   22   ‚îÇ   confidence *= 0.85                         ‚îÇ confidence = 0.8 √ó 0.85      ‚îÇ R√©duction confiance        ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ            = 0.68            ‚îÇ (hybride)                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   23   ‚îÇ risk_score = sum(scores.values())            ‚îÇ risk_score = 0.7+0.8+0.5     ‚îÇ Somme de tous les scores   ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ            = 2.0             ‚îÇ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   24   ‚îÇ SI risk_score >= 1.5 OU encrypts_files       ‚îÇ 2.0 >= 1.5 = true            ‚îÇ Condition CRITICAL         ‚îÇ
‚îÇ        ‚îÇ OU modifies_mbr                              ‚îÇ OU true OU false = true      ‚îÇ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   25   ‚îÇ   risk_level = "critical"                    ‚îÇ risk_level = "critical"      ‚îÇ Ransomware = critique      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   26   ‚îÇ RETOURNER {                                  ‚îÇ R√©sultat final :             ‚îÇ Classification compl√®te    ‚îÇ
‚îÇ        ‚îÇ   primary_type: "ransomware",                ‚îÇ {                            ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ   confidence: 0.68,                          ‚îÇ   "primary_type":            ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ   subtypes: [...],                           ‚îÇ     "ransomware",            ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ   risk_level: "critical"                     ‚îÇ   "confidence": 0.68,        ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ }                                            ‚îÇ   "subtypes": [              ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ     "network_propagation",   ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ     "crypto_ransomware",     ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ     "dropper"                ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ   ],                         ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ   "risk_level": "critical"   ‚îÇ                            ‚îÇ
‚îÇ        ‚îÇ                                              ‚îÇ }                            ‚îÇ                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Visualisation de l'√©tat final :**
```
Scores calcul√©s :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Type        ‚îÇ Score ‚îÇ Graphe      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Virus       ‚îÇ  0.0  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ       ‚îÇ
‚îÇ Worm        ‚îÇ  0.7  ‚îÇ ‚ñà‚ñà‚ñà‚îÄ‚îÄ       ‚îÇ
‚îÇ Trojan      ‚îÇ  0.5  ‚îÇ ‚ñà‚ñà‚îÄ‚îÄ‚îÄ       ‚îÇ
‚îÇ Ransomware  ‚îÇ  0.8  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚îÄ ‚Üê MAX ‚îÇ
‚îÇ Rootkit     ‚îÇ  0.0  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ       ‚îÇ
‚îÇ Bootkit     ‚îÇ  0.0  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Hybride d√©tect√© : 3 types actifs
Confiance ajust√©e : 0.8 ‚Üí 0.68 (-15%)
Risk level : CRITICAL (chiffrement de fichiers)
```

### 5.8 Mn√©motechniques (MEME obligatoire)

#### ü§ñ MEME : "I am Mr. Robot" ‚Äî Identifier le type principal

![Mr. Robot](https://example.com/mrrobot.jpg)

Dans Mr. Robot, Elliot porte toujours son hoodie noir. C'est son **primary type**. Mais il a aussi des **subtypes** : hackeur (fsociety), employ√© (Allsafe), vigilante.

Pareil pour les malwares :
- **Primary type** : Le comportement dominant (ransomware)
- **Subtypes** : Les techniques suppl√©mentaires (worm, dropper)

```python
elliot = {
    "primary_type": "hackeur",
    "subtypes": ["employee", "vigilante", "anarchist"],
    "confidence": 0.95,  # On est quasi s√ªr
    "risk_level": "critical"  # Il peut d√©truire E Corp
}
```

---

#### üíÄ MEME : "This is fine" ‚Äî Ignorer les hybrides

![This is fine](https://example.com/this_is_fine.jpg)

Comme le chien dans le meme qui ignore le feu, un classificateur qui ignore que WannaCry est **worm+ransomware** va se faire br√ªler.

```python
# ‚ùå Le chien "This is fine"
if encrypts_files:
    return {"primary_type": "ransomware"}
# Oublie le network_spread ‚Üí surprise lors de la propagation

# ‚úÖ Le pompier intelligent
scores = calculate_all()
primary = max(scores)
subtypes = all_active()  # Capture l'hybride
```

---

#### üé¨ MEME : "Inception" ‚Äî Les niveaux de rootkit

![Inception](https://example.com/inception.jpg)

Dans Inception, il y a des r√™ves dans les r√™ves (3 niveaux minimum). Les rootkits c'est pareil :

```
Application layer    ‚Üê "R√™ve niveau 1" (facile √† d√©tecter)
    ‚Üì
User-mode rootkit    ‚Üê "R√™ve niveau 2" (plus profond)
    ‚Üì
Kernel-mode rootkit  ‚Üê "R√™ve niveau 3" (tr√®s profond)
    ‚Üì
UEFI bootkit         ‚Üê "Limbes" (impossible √† r√©veiller)
```

Plus tu descends, plus c'est difficile de "r√©veiller" (d√©tecter) le malware.

---

#### üî• MEME : "Anakin + Padm√©" ‚Äî Confondre Virus et Worm

![Anakin Padm√© meme](https://example.com/anakin_padme.jpg)

```
Anakin : "Il se r√©plique, donc c'est un worm, non ?"
Padm√© : "..." (silence)
Anakin : "C'est un worm, non ?"
Padm√© face : üò∞
```

**NON.** Un **virus** se r√©plique aussi ! La diff√©rence :
- **Virus** : R√©plication LOCALE (infecte des fichiers)
- **Worm** : R√©plication R√âSEAU (se propage automatiquement)

```python
if self_replicates and not network_spread:
    type = "virus"  # ‚Üê Pas un worm !
```

---

#### üè¥‚Äç‚ò†Ô∏è MEME : "One Piece" ‚Äî Le Tr√©sor du Risque Level

![One Piece treasure](https://example.com/one_piece.jpg)

Dans One Piece, les primes refl√®tent le danger du pirate. Pareil pour les malwares :

| Malware | Prime (Danger) | Risk Level |
|---------|---------------|------------|
| Adware (Buggy le Clown) | 15M berries | LOW |
| Trojan (Crocodile) | 81M berries | MEDIUM |
| Rootkit (Doflamingo) | 340M berries | HIGH |
| Ransomware (Kaido) | 4.6B berries | CRITICAL |

Un **bootkit** c'est comme un Yonko : CRITICAL level.

```python
if encrypts_files or modifies_mbr:
    risk_level = "critical"  # Yonko-tier threat
```

---

#### üì¶ MEME : "Trojan Horse" ‚Äî Le d√©guisement

![Trojan Horse](https://example.com/trojan_horse.jpg)

Le **Trojan** (Cheval de Troie) tire son nom de la mythologie grecque. Les Grecs ont offert un cheval g√©ant en "cadeau" √† Troie. √Ä l'int√©rieur : des soldats cach√©s.

Pareil pour un trojan malware :
```
Apparence externe : "crack_photoshop.exe" (cadeau gratuit)
                          ‚îÇ
                          ‚ñº
Contenu cach√©      : Backdoor + Keylogger (soldats grecs)
```

**Le√ßon** : Ne jamais faire confiance √† un executable suspect, m√™me s'il semble l√©gitime.

### 5.9 Applications pratiques

#### Cas d'usage 1 : Triage dans un SOC

**Contexte** : Un SOC re√ßoit 500 alertes/jour d'un EDR (Endpoint Detection & Response).

**Probl√®me** : Impossible d'analyser 500 √©chantillons manuellement.

**Solution** : Classifier automatiquement pour prioriser.

```python
alerts = get_edr_alerts()  # 500 √©chantillons
for alert in alerts:
    classification = classify_specimen(alert["characteristics"])

    if classification["risk_level"] == "critical":
        # Escalade imm√©diate au Tier 3
        escalate_to_incident_response(alert)
    elif classification["risk_level"] == "high":
        # File dans la queue Tier 2
        queue_for_analysis(alert)
    else:
        # Auto-remediation (quarantine)
        auto_remediate(alert)
```

**R√©sultat** : Les 20 alertes critiques sont trait√©es en priorit√©, les 480 autres sont automatis√©es.

#### Cas d'usage 2 : Threat Intelligence Attribution

**Contexte** : Un analyste re√ßoit un √©chantillon inconnu.

**Probl√®me** : Est-ce li√© √† une campagne APT connue ?

**Solution** : Mapper la classification aux TTP (Tactics, Techniques, Procedures) d'APT groups.

```python
classification = classify_specimen_advanced(sample)

# Mapping APT
if classification["is_apt"] and "T1003" in classification["mitre_techniques"]:
    # T1003 = Credential Dumping (technique Lazarus Group)
    possible_apt = "Lazarus Group (HIDDEN COBRA)"
elif "T1542" in classification["mitre_techniques"]:
    # T1542 = Pre-OS Boot (technique APT28 LoJax)
    possible_apt = "APT28 (Fancy Bear)"

alert_analyst(f"Possible attribution: {possible_apt}")
```

**R√©sultat** : L'analyste sait qu'il doit chercher des IOCs (Indicators of Compromise) associ√©s √† ce groupe APT.

#### Cas d'usage 3 : Playbook de r√©ponse

**Contexte** : Un ransomware est d√©tect√© sur une machine.

**Probl√®me** : Quelle est la proc√©dure de r√©ponse ?

**Solution** : Chaque type de malware a un playbook sp√©cifique.

```python
classification = classify_specimen(sample)

playbooks = {
    "ransomware": [
        "1. ISOLATE la machine du r√©seau (√©viter propagation)",
        "2. NE PAS √©teindre (pr√©serve la RAM pour forensics)",
        "3. Dump la RAM avec FTK Imager",
        "4. Identifier la variante (Sodinokibi, WannaCry, etc.)",
        "5. Chercher decryptor (No More Ransom)",
        "6. Si pas de decryptor : restore from backup"
    ],
    "bootkit": [
        "1. DO NOT BOOT la machine (bootkit s'ex√©cute au boot)",
        "2. Analyse forensique live USB",
        "3. Dump du firmware UEFI",
        "4. R√©imagerie compl√®te (bootkit survit √† reinstall Windows)",
        "5. Possiblement : remplacement du SSD/HDD"
    ],
    "worm": [
        "1. ISOLATE imm√©diatement (propagation rapide)",
        "2. Identifier le vecteur (SMB, RDP, etc.)",
        "3. Patch la vuln√©rabilit√© sur tout le r√©seau",
        "4. Hunt IOCs sur toutes les machines",
        "5. Eradication simultan√©e (sinon r√©infection)"
    ]
}

execute_playbook(playbooks[classification["primary_type"]])
```

**R√©sultat** : R√©ponse standardis√©e et efficace selon le type de menace.

#### Cas d'usage 4 : Reporting ex√©cutif

**Contexte** : Un CISO (Chief Information Security Officer) veut un rapport hebdomadaire.

**Probl√®me** : Les rapports techniques sont incompr√©hensibles pour les execs.

**Solution** : Agr√©ger les classifications en m√©triques business.

```python
weekly_samples = get_samples_this_week()  # 1,200 √©chantillons
stats = {
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0,
    "types": {}
}

for sample in weekly_samples:
    classification = classify_specimen(sample)
    stats[classification["risk_level"]] += 1

    t = classification["primary_type"]
    stats["types"][t] = stats["types"].get(t, 0) + 1

# G√©n√©ration du rapport
report = f"""
WEEKLY MALWARE REPORT
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total samples: {len(weekly_samples)}

Risk Distribution:
  üî¥ CRITICAL: {stats['critical']} ({stats['critical']/len(weekly_samples)*100:.1f}%)
  üü† HIGH:     {stats['high']} ({stats['high']/len(weekly_samples)*100:.1f}%)
  üü° MEDIUM:   {stats['medium']} ({stats['medium']/len(weekly_samples)*100:.1f}%)
  üü¢ LOW:      {stats['low']} ({stats['low']/len(weekly_samples)*100:.1f}%)

Top Threats:
  1. Ransomware: {stats['types'].get('ransomware', 0)}
  2. Trojan:     {stats['types'].get('trojan', 0)}
  3. Worm:       {stats['types'].get('worm', 0)}

Recommendation:
  {'üö® IMMEDIATE ACTION REQUIRED' if stats['critical'] > 10 else '‚úÖ Manageable threat level'}
"""

send_to_ciso(report)
```

**R√©sultat** : Le CISO comprend la situation en 30 secondes et peut prendre des d√©cisions business (budget, headcount, etc.).

---
---

## ‚ö†Ô∏è SECTION 6 : PI√àGES ‚Äî R√âCAPITULATIF

### Pi√®ge 1 : Confondre auto-r√©plication et propagation r√©seau
‚ùå `self_replicates = true` ‚Üí classifier comme "worm"
‚úÖ V√©rifier `network_spread` pour distinguer virus/worm

### Pi√®ge 2 : Ignorer les menaces hybrides
‚ùå Retourner le premier type d√©tect√©
‚úÖ Calculer TOUS les scores et ajuster la confiance

### Pi√®ge 3 : Confidence score fixe √† 1.0
‚ùå `confidence = 1.0` pour toutes les classifications
‚úÖ Utiliser le score calcul√© et r√©duire pour les hybrides

### Pi√®ge 4 : Ne pas valider l'entr√©e JSON
‚ùå Acc√©der directement `characteristics["encrypts_files"]`
‚úÖ Utiliser `.get()` avec valeur par d√©faut

### Pi√®ge 5 : Risk level incorrect
‚ùå Toujours "medium"
‚úÖ Ransomware et bootkit = "critical", worm/rootkit = "high"

### Pi√®ge 6 : Subtypes avec doublons
‚ùå `["file_infector", "file_infector", "dropper"]`
‚úÖ D√©duplication avec `list(set(...))`

### Pi√®ge 7 : Oublier le cas "aucune caract√©ristique"
‚ùå Crash ou classification al√©atoire
‚úÖ Retourner `{"primary_type": "unknown", "confidence": 0.0, "risk_level": "low"}`

### Pi√®ge 8 : Classifier un rootkit comme virus
‚ùå Inverser la logique de classification
‚úÖ `hides_processes = true` ‚Üí "rootkit", pas "virus"

---

## üìù SECTION 7 : QCM

### Question 1 : Quelle est la diff√©rence principale entre un virus et un worm ?

**A.** Un virus chiffre les fichiers, pas un worm
**B.** Un virus n√©cessite une action utilisateur pour se propager, un worm se propage automatiquement
**C.** Un virus est plus dangereux qu'un worm
**D.** Un worm cache sa pr√©sence, pas un virus
**E.** Il n'y a pas de diff√©rence, ce sont des synonymes
**F.** Un virus infecte le MBR, un worm infecte les fichiers
**G.** Un worm n√©cessite Python, un virus n√©cessite C
**H.** Un virus se propage par email, un worm par USB
**I.** Un worm est toujours un ransomware
**J.** Un virus est l√©gal, un worm est ill√©gal

**R√©ponse correcte :** B

**Explication :** Un **virus** se r√©plique en infectant des fichiers h√¥tes et n√©cessite une action utilisateur (ex√©cuter le fichier, ins√©rer une USB). Un **worm** se propage automatiquement via le r√©seau en exploitant des vuln√©rabilit√©s, sans intervention humaine.

---

### Question 2 : Qu'est-ce qu'un bootkit ?

**A.** Un malware qui chiffre les fichiers au d√©marrage
**B.** Un malware qui infecte le processus de boot (MBR/UEFI)
**C.** Un rootkit qui se cache dans le bootloader
**D.** Un outil l√©gitime pour r√©parer le boot
**E.** Un virus qui infecte boot.ini
**F.** Un worm qui se propage au boot
**G.** Un trojan qui cr√©e un backdoor au d√©marrage
**H.** Un ransomware qui demande une ran√ßon avant le boot
**I.** Un malware qui supprime le syst√®me d'exploitation
**J.** Un exploit pour le BIOS

**R√©ponse correcte :** B

**Explication :** Un **bootkit** est un malware qui infecte le **processus de boot** (MBR pour les syst√®mes Legacy BIOS, ou UEFI firmware pour les syst√®mes modernes). Il s'ex√©cute **avant** le syst√®me d'exploitation, ce qui le rend invisible aux antivirus et lui permet de survivre √† une r√©installation Windows.

---

### Question 3 : WannaCry est principalement class√© comme :

**A.** Virus
**B.** Worm
**C.** Trojan
**D.** Ransomware
**E.** Rootkit
**F.** Bootkit
**G.** Adware
**H.** Spyware
**I.** Keylogger
**J.** RAT

**R√©ponse correcte :** D

**Explication :** WannaCry est principalement class√© comme **ransomware** car son payload principal est le chiffrement de fichiers avec demande de ran√ßon. Cependant, c'est une **menace hybride** : il utilise un vecteur de propagation **worm** (EternalBlue/SMB exploit). La classification est donc `primary_type: "ransomware"` avec `subtypes: ["network_propagation", "crypto_ransomware"]`.

---

### Question 4 : Quel est le risk level appropri√© pour un malware qui modifie le MBR ?

**A.** low
**B.** medium
**C.** high
**D.** critical
**E.** info
**F.** warning
**G.** alert
**H.** emergency
**I.** √áa d√©pend du contexte
**J.** Aucun risk level (c'est un comportement normal)

**R√©ponse correcte :** D

**Explication :** Un malware qui modifie le **MBR** (Master Boot Record) doit toujours √™tre class√© comme **CRITICAL** car :
1. Il survit √† une r√©installation Windows
2. Il s'ex√©cute avant le syst√®me d'exploitation
3. Il est extr√™mement difficile √† √©radiquer (n√©cessite reflash ou remplacement du disque)
4. C'est un indicateur de menace APT sophistiqu√©e (ex: LoJax)

---

### Question 5 : Quelle technique MITRE ATT&CK correspond au chiffrement de fichiers par un ransomware ?

**A.** T1566 (Phishing)
**B.** T1486 (Data Encrypted for Impact)
**C.** T1071 (Application Layer Protocol)
**D.** T1003 (OS Credential Dumping)
**E.** T1055 (Process Injection)
**F.** T1542 (Pre-OS Boot)
**G.** T1059 (Command and Scripting Interpreter)
**H.** T1021 (Remote Services)
**I.** T1210 (Exploitation of Remote Services)
**J.** T1027 (Obfuscated Files or Information)

**R√©ponse correcte :** B

**Explication :** La technique MITRE ATT&CK **T1486** correspond √† **Data Encrypted for Impact**, qui est le comportement principal d'un ransomware : chiffrer les donn√©es de la victime pour extorsion.

---

### Question 6 : Pourquoi r√©duit-on le confidence score pour les menaces hybrides ?

**A.** Parce que les hybrides sont moins dangereux
**B.** Parce que c'est une convention arbitraire
**C.** Parce que la classification est plus ambigu√´ quand plusieurs types sont actifs
**D.** Parce que les hybrides ne sont pas r√©els
**E.** Pour forcer l'analyse manuelle
**F.** Parce que le code est plus simple ainsi
**G.** Parce que les hybrides sont toujours des faux positifs
**H.** Pour √©viter les divisions par z√©ro
**I.** Parce que les antivirus ne d√©tectent pas les hybrides
**J.** Il ne faut pas r√©duire le confidence pour les hybrides

**R√©ponse correcte :** C

**Explication :** Lorsqu'un malware pr√©sente des comportements de **plusieurs types** (ex: worm + ransomware), la classification devient plus **ambigu√´**. On r√©duit le confidence score (typiquement √ó0.85) pour refl√©ter cette incertitude. Le `primary_type` est toujours le score maximal, mais la confiance est moindre qu'un malware "pur".

---

### Question 7 : Quelle est la diff√©rence entre un rootkit et un trojan ?

**A.** Un rootkit est toujours kernel-mode, un trojan est user-mode
**B.** Un rootkit cache sa pr√©sence, un trojan cr√©e un backdoor
**C.** Un trojan est l√©gal, un rootkit est ill√©gal
**D.** Il n'y a pas de diff√©rence
**E.** Un rootkit chiffre les fichiers, un trojan les supprime
**F.** Un trojan se propage par r√©seau, un rootkit par USB
**G.** Un rootkit est un type de trojan
**H.** Un trojan n√©cessite admin, un rootkit non
**I.** Un rootkit est Open Source, un trojan est propri√©taire
**J.** Un trojan infecte les fichiers, un rootkit infecte le boot

**R√©ponse correcte :** B

**Explication :** La diff√©rence fondamentale :
- **Rootkit** : Malware qui **cache sa pr√©sence** (processus, fichiers, connexions r√©seau) en modifiant les API syst√®me
- **Trojan** : Malware d√©guis√© en logiciel l√©gitime qui **cr√©e un backdoor** pour acc√®s √† distance

Note : Un malware sophistiqu√© peut √™tre un **trojan avec composant rootkit** (hybride).

---

### Question 8 : Quel comportement est caract√©ristique d'un worm ?

**A.** self_replicates = true ET network_spread = false
**B.** network_spread = true
**C.** encrypts_files = true
**D.** hides_processes = true
**E.** modifies_mbr = true
**F.** creates_backdoor = true
**G.** drops_payload = true
**H.** persistence_method = "bootkit"
**I.** polymorphic_behavior = true
**J.** Aucune de ces r√©ponses

**R√©ponse correcte :** B

**Explication :** La caract√©ristique **distinctive** d'un worm est `network_spread = true`. C'est la propagation automatique via le r√©seau qui d√©finit un worm, pas l'auto-r√©plication (qui est aussi pr√©sente dans les virus).

---

### Question 9 : Dans quel ordre s'ex√©cute un bootkit par rapport au syst√®me d'exploitation ?

**A.** Apr√®s le kernel
**B.** En m√™me temps que l'antivirus
**C.** Avant le bootloader
**D.** Apr√®s le login utilisateur
**E.** Pendant le shutdown
**F.** Jamais (un bootkit ne s'ex√©cute pas)
**G.** Seulement en mode sans √©chec
**H.** Apr√®s le d√©marrage complet de Windows
**I.** Avant le syst√®me d'exploitation
**J.** Pendant l'installation de Windows

**R√©ponse correcte :** I

**Explication :** Un **bootkit** s'ex√©cute **AVANT** le syst√®me d'exploitation. La s√©quence est :
1. BIOS/UEFI
2. **MBR/UEFI (bootkit s'ex√©cute ici)**
3. Bootloader (Windows Boot Manager)
4. Kernel (ntoskrnl.exe)
5. OS charg√©

C'est pourquoi un bootkit est invisible aux antivirus (qui se chargent avec l'OS).

---

### Question 10 : Quel est l'objectif principal de la classification de malware dans un SOC ?

**A.** Impressionner les coll√®gues avec des termes techniques
**B.** Remplir un rapport pour le CISO
**C.** Prioriser l'analyse et la r√©ponse aux incidents
**D.** Cr√©er des statistiques pour des conf√©rences
**E.** Alimenter une base de donn√©es
**F.** Entra√Æner un mod√®le de machine learning
**G.** Justifier le budget s√©curit√©
**H.** Publier des CVE
**I.** Vendre des signatures antivirus
**J.** Archiver les √©chantillons

**R√©ponse correcte :** C

**Explication :** Dans un SOC, la classification de malware sert principalement √† **prioriser** l'analyse et la r√©ponse aux incidents. Un malware class√© **CRITICAL** (ex: bootkit, ransomware) n√©cessite une r√©ponse imm√©diate, tandis qu'un malware **LOW** (ex: adware) peut √™tre mis en queue ou auto-rem√©di√©. Cela permet de g√©rer efficacement des centaines d'alertes quotidiennes.

---

## üìä SECTION 8 : R√âCAPITULATIF

### Concepts cl√©s couverts

‚úÖ **Taxonomie des malwares** : 6 types principaux (Virus, Worm, Trojan, Ransomware, Rootkit, Bootkit)
‚úÖ **Classification par scoring** : Calcul de scores par type selon les caract√©ristiques
‚úÖ **Menaces hybrides** : D√©tection et ajustement du confidence
‚úÖ **Risk level** : √âvaluation de la dangerosit√© (low, medium, high, critical)
‚úÖ **MITRE ATT&CK mapping** : Correspondance comportements ‚Üî techniques
‚úÖ **Validation d'entr√©e** : Robustesse face √† des donn√©es malform√©es
‚úÖ **Applications pratiques** : Triage SOC, Threat Intel, Playbooks de r√©ponse

### Comp√©tences acquises

üéØ **Analyse comportementale** : Identifier un malware selon ses actions, pas sa signature
üéØ **Priorisation** : Distinguer une menace critique d'un malware b√©nin
üéØ **Communication** : Utiliser le vocabulaire standardis√© (taxonomie)
üéØ **Incident Response** : Appliquer le bon playbook selon le type
üéØ **Threat Intelligence** : Mapper aux campagnes APT connues

### M√©tiers concern√©s

üë®‚Äçüíª **Malware Analyst** : Analyse approfondie d'√©chantillons
üõ°Ô∏è **SOC Analyst (L2-L3)** : Triage et r√©ponse aux incidents
üîç **Threat Intelligence Analyst** : Attribution et tracking de campagnes
üö® **Incident Responder** : Gestion de crises de s√©curit√©
üèóÔ∏è **Security Engineer** : Automatisation de la d√©tection

### Points d'attention

‚ö†Ô∏è **Ne jamais se fier uniquement √† la classification automatique** : Toujours confirmer par analyse approfondie pour les menaces critiques

‚ö†Ô∏è **Les malwares √©voluent** : Un polymorphe peut changer de type √† chaque infection

‚ö†Ô∏è **Le contexte compte** : Un worm sur un r√©seau isol√© (air-gap) est moins critique qu'un worm sur un r√©seau d'entreprise

‚ö†Ô∏è **Faux positifs** : Un logiciel l√©gitime peut avoir des comportements suspects (ex: logiciel de remote desktop = creates_backdoor?)

### Pour aller plus loin

üìö **Lectures recommand√©es** :
- "The Art of Memory Forensics" (Ligh, Case, Levy, Walters)
- "Practical Malware Analysis" (Sikorski, Honig)
- "Rootkits and Bootkits" (Matrosov, Rodionov, Bratus)

üîó **Ressources en ligne** :
- MITRE ATT&CK : https://attack.mitre.org/
- VirusTotal : https://www.virustotal.com/
- Hybrid Analysis : https://www.hybrid-analysis.com/
- ANY.RUN : https://any.run/

üèÜ **Certifications** :
- GIAC Reverse Engineering Malware (GREM)
- GIAC Cyber Threat Intelligence (GCTI)
- Certified Malware Reverse Engineer (CMRE)

---

## üì¶ SECTION 9 : DEPLOYMENT PACK (JSON COMPLET)

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "3.6.1-a-specimen-classifier",
    "generated_at": "2026-01-15 14:30:00",

    "metadata": {
      "exercise_id": "3.6.1-a",
      "exercise_name": "specimen_classifier",
      "module": "3.6.1",
      "module_name": "Malware Fundamentals",
      "concept": "a",
      "concept_name": "Classification de Types de Malware",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isol√©",
      "phase": 3,
      "difficulty": 7,
      "difficulty_stars": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ",
      "language": "python",
      "language_version": "3.14",
      "duration_minutes": 45,
      "xp_base": 150,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANC√â",
      "bonus_icon": "üî•",
      "complexity_time": "T[N] O(n)",
      "complexity_space": "S[N] O(1)",
      "prerequisites": [
        "Compr√©hension des syst√®mes d'exploitation",
        "Parsing JSON",
        "Concepts de s√©curit√© informatique de base"
      ],
      "domains": ["Crypto", "Process"],
      "domains_bonus": ["AL"],
      "tags": ["malware", "classification", "forensics", "SOC", "threat-intel", "phase3"],
      "meme_reference": "Mr. Robot - I am Mr. Robot"
    },

    "files": {
      "spec.json": "/* Voir section 4.9 */",
      "references/ref_specimen_classifier.py": "/* Section 4.3 - Solution de base */",
      "references/ref_specimen_classifier_bonus.py": "/* Section 4.6 - Solution bonus */",
      "alternatives/alt_if_elif.py": "/* Section 4.4 - Alternative 1 */",
      "mutants/mutant_a_boundary.py": "/* Section 4.10 - Mutant A */",
      "mutants/mutant_b_safety.py": "/* Section 4.10 - Mutant B */",
      "mutants/mutant_c_resource.py": "/* Section 4.10 - Mutant C */",
      "mutants/mutant_d_logic.py": "/* Section 4.10 - Mutant D */",
      "mutants/mutant_e_return.py": "/* Section 4.10 - Mutant E */",
      "tests/test_samples.json": "/* Section 4.2 - Fichiers de test */",
      "tests/test_runner.py": "/* Test harness Python */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_specimen_classifier.py",
        "references/ref_specimen_classifier_bonus.py",
        "alternatives/alt_if_elif.py"
      ],
      "expected_fail": [
        "mutants/mutant_a_boundary.py",
        "mutants/mutant_b_safety.py",
        "mutants/mutant_c_resource.py",
        "mutants/mutant_d_logic.py",
        "mutants/mutant_e_return.py"
      ]
    },

    "commands": {
      "validate_spec": "python3 hackbrain_engine_v22.py --validate-spec spec.json",
      "test_reference": "python3 hackbrain_engine_v22.py -s spec.json -f references/ref_specimen_classifier.py",
      "test_mutants": "python3 hackbrain_mutation_tester.py -r references/ref_specimen_classifier.py -s spec.json --validate",
      "run_exercise": "python3 specimen_classifier.py < tests/test_samples.json"
    },

    "educational_notes": {
      "key_learning_outcomes": [
        "Comprendre la taxonomie des malwares (6 types principaux)",
        "Distinguer virus, worm et trojan selon les vecteurs de propagation",
        "Classifier les menaces hybrides avec ajustement de confiance",
        "Calculer le risk level selon l'impact potentiel",
        "Mapper les comportements aux techniques MITRE ATT&CK",
        "Appliquer la classification au triage SOC r√©el"
      ],
      "common_mistakes": [
        "Confondre virus et worm (auto-r√©plication vs propagation r√©seau)",
        "Ignorer les menaces hybrides (ex: WannaCry = worm+ransomware)",
        "Confidence score fixe (doit refl√©ter la certitude)",
        "Risk level incorrect (ransomware/bootkit = critical)",
        "Ne pas valider l'entr√©e JSON (robustesse)"
      ],
      "real_world_applications": [
        "Triage automatique dans un SOC (500+ alertes/jour)",
        "Attribution de campagnes APT via MITRE mapping",
        "S√©lection du playbook de r√©ponse selon le type",
        "Reporting ex√©cutif pour le CISO (m√©triques business)"
      ]
    },

    "bonus_info": {
      "description": "D√©tection avanc√©e des menaces polymorphes et APT avec scoring sophistiqu√© et mapping MITRE ATT&CK",
      "additional_concepts": [
        "Polymorphic behavior detection",
        "APT indicators (lateral movement, credential dumping, C2)",
        "Sophistication scoring (0-10 scale)",
        "MITRE ATT&CK technique mapping",
        "Advanced hybrid threat analysis"
      ],
      "difficulty_increase": "+1 level (7/10 ‚Üí 8/10)",
      "estimated_time_bonus": "+20 minutes"
    },

    "integration": {
      "prerequisite_exercises": [],
      "related_exercises": [
        "3.6.1-b : Static Analysis Fundamentals",
        "3.6.1-c : Dynamic Analysis with Sandboxes",
        "3.6.2-a : Behavioral Indicators of Compromise"
      ],
      "follow_up_exercises": [
        "3.6.3-a : YARA Rule Writing",
        "3.6.4-a : Memory Forensics with Volatility"
      ]
    },

    "quality_metrics": {
      "pedagogical_completeness": 96,
      "code_coverage": 100,
      "edge_case_coverage": 95,
      "documentation_quality": 98,
      "meme_integration": 100,
      "real_world_relevance": 99
    }
  }
}
```

---

**FIN DE L'EXERCICE 3.6.1-a : specimen_classifier**

*HACKBRAIN v5.5.2 ‚Äî Malware Analysis Module*
*"L'excellence p√©dagogique ne se n√©gocie pas ‚Äî pas de raccourcis"*
*Compatible ENGINE v22.1 + Mutation Tester*
