<thinking>
## Analyse du Concept
- Concept : CRDT (Conflict-free Replicated Data Types) - G-Counter et PN-Counter
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les CRDTs sont fondamentaux pour la coherence eventuelle dans les systemes distribues.

## Combo Base + Bonus
- Exercice de base : G-Counter et PN-Counter avec merge semantique
- Bonus : OR-Set avec semantique add-wins et LWW-Register
- Palier bonus : AVANCE (structures plus complexes + garanties formelles)
- Progression logique ? OUI - Compteurs simples puis structures plus riches

## Prerequis & Difficulte
- Prerequis reels : HashMap, Traits Clone/PartialEq, Generics
- Difficulte estimee : 6/10 (base), 8/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference aux "Replicas" dans Blade Runner
- MEME mnemonique : "All replicas will eventually agree"
- Pourquoi c'est fun : Les CRDTs convergent comme des replicas identiques

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Merge) : Additionne au lieu de max dans merge
2. Mutant B (Value) : Retourne le count d'un seul replica
3. Mutant C (Commutativity) : Merge non commutatif
4. Mutant D (Idempotence) : Merge non idempotent
5. Mutant E (PN-Counter) : Soustrait positive au lieu de negative

## Verdict
VALIDE - Exercice fondamental pour la coherence eventuelle
</thinking>

# Exercice 5.4.3-a : crdt_gcounter

**Module :**
5.4.3 — Conflict-free Replicated Data Types

**Concept :**
a — G-Counter et PN-Counter (CRDTs de base)

**Difficulte :**
INTERMEDIAIRE (6/10)

**Type :**
code

**Tiers :**
1 — Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.2 — Generics et traits
- 2.5 — Collections (HashMap)
- 5.4.1 — Fondamentaux des systemes distribues

**Domaines :**
DS, CRDT, Eventual

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::HashMap`
- `std::hash::Hash`

**Fonctions/methodes interdites :**
- Crates CRDT externes (`crdts`, `automerge`, etc.)
- `unsafe` blocks
- Mutexes/Locks (exercice single-threaded)

### 1.2 Consigne

**CONTEXTE : "The Eventual Convergence"**

*"Imaginez plusieurs copies d'un document edite simultanement par des utilisateurs sur differents continents. Sans coordination centrale, comment garantir que toutes les copies finissent par avoir le meme contenu ? Les CRDTs resolvent ce probleme mathematiquement."* — Marc Shapiro, inventeur des CRDTs

Les CRDTs (Conflict-free Replicated Data Types) sont des structures de donnees qui peuvent etre repliquees sur plusieurs machines et modifiees de maniere concurrente, avec la garantie mathematique de converger vers le meme etat final sans coordination.

**Ta mission :**

Implementer deux types de CRDT fondamentaux :
1. **G-Counter** (Grow-only Counter) : Compteur qui ne peut qu'incrementer
2. **PN-Counter** (Positive-Negative Counter) : Compteur qui peut incrementer ET decrementer

Les deux doivent respecter les proprietes CRDT :
- **Commutativite** : `a.merge(b)` et `b.merge(a)` donnent le meme resultat
- **Associativite** : `(a.merge(b)).merge(c)` = `a.merge(b.merge(c))`
- **Idempotence** : `a.merge(a)` ne change pas `a`

**Entree :**
- Operations : `increment(replica_id)`, `decrement(replica_id)` (PN-Counter seulement)
- Merge : `merge(&other)` pour fusionner deux replicas

**Sortie :**
- `value()` : La valeur totale du compteur

**Contraintes :**
- Chaque replica ne peut incrementer que son propre compteur
- Le merge prend le maximum de chaque composante (G-Counter)
- Le PN-Counter utilise deux G-Counters (positif et negatif)

**Exemples :**

| Operation | Replica A | Replica B | Apres merge |
|-----------|-----------|-----------|-------------|
| A.increment("A") | {A:1} | {} | - |
| B.increment("B") | {A:1} | {B:1} | - |
| A.merge(B) | {A:1, B:1} | {B:1} | value()=2 |
| B.merge(A) | {A:1, B:1} | {A:1, B:1} | value()=2 |

### 1.2.2 Consigne Academique

Implementer les structures `GCounter` et `PNCounter` avec la semantique de merge CRDT. Les structures doivent garantir la convergence eventuelle : apres un nombre fini de merges, tous les replicas ont la meme valeur.

### 1.3 Prototype

```rust
use std::collections::HashMap;

/// Trait commun pour tous les CRDTs
pub trait CRDT: Clone {
    /// Fusionne deux replicas en un seul
    fn merge(&mut self, other: &Self);
}

/// Identifiant unique de replica
pub type ReplicaId = String;

// ============== G-COUNTER ==============

/// Compteur qui ne peut que croitre (Grow-only Counter)
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct GCounter {
    counts: HashMap<ReplicaId, u64>,
}

impl GCounter {
    /// Cree un nouveau G-Counter vide
    pub fn new() -> Self;

    /// Incremente le compteur pour ce replica
    pub fn increment(&mut self, replica: &ReplicaId);

    /// Incremente de n pour ce replica
    pub fn increment_by(&mut self, replica: &ReplicaId, n: u64);

    /// Retourne la valeur totale (somme de tous les replicas)
    pub fn value(&self) -> u64;

    /// Retourne la contribution d'un replica specifique
    pub fn replica_value(&self, replica: &ReplicaId) -> u64;

    /// Retourne tous les replicas connus
    pub fn replicas(&self) -> Vec<&ReplicaId>;
}

impl CRDT for GCounter {
    /// Merge : prend le max de chaque composante
    fn merge(&mut self, other: &Self);
}

// ============== PN-COUNTER ==============

/// Compteur qui peut incrementer et decrementer
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct PNCounter {
    positive: GCounter,
    negative: GCounter,
}

impl PNCounter {
    /// Cree un nouveau PN-Counter vide
    pub fn new() -> Self;

    /// Incremente le compteur
    pub fn increment(&mut self, replica: &ReplicaId);

    /// Decremente le compteur
    pub fn decrement(&mut self, replica: &ReplicaId);

    /// Incremente de n
    pub fn increment_by(&mut self, replica: &ReplicaId, n: u64);

    /// Decremente de n
    pub fn decrement_by(&mut self, replica: &ReplicaId, n: u64);

    /// Retourne la valeur (positive - negative)
    /// Note: peut etre negatif!
    pub fn value(&self) -> i64;
}

impl CRDT for PNCounter {
    fn merge(&mut self, other: &Self);
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 L'invention des CRDTs

Les CRDTs ont ete formalises en 2011 par Marc Shapiro, Nuno Preguica, Carlos Baquero et Marek Zawirski. Le papier "A comprehensive study of Convergent and Commutative Replicated Data Types" a revolutionne la coherence eventuelle.

### 2.2 Deux familles de CRDTs

- **CvRDT** (Convergent/State-based) : On envoie l'etat complet, on merge
- **CmRDT** (Commutative/Operation-based) : On envoie les operations

Le G-Counter est un CvRDT : on merge les etats, pas les operations.

### 2.3 Pourquoi le G-Counter marche ?

Le secret est le **max**. Prendre le maximum de chaque composante garantit :
- On ne perd jamais d'increment (monotonie)
- L'ordre des merges n'importe pas (commutativite)
- Merger plusieurs fois la meme chose ne change rien (idempotence)

```
A: {A:2, B:1}
B: {A:1, B:3}
merge: {A:max(2,1), B:max(1,3)} = {A:2, B:3}
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation des CRDTs |
|--------|----------------------|
| **Distributed Systems Engineer** | Datastores eventually consistent |
| **Frontend/Fullstack Developer** | Collaborative editing (Google Docs-like) |
| **Game Developer** | Synchronisation multi-joueurs |
| **Mobile Developer** | Offline-first applications |

### Cas d'usage concrets

1. **Redis CRDT** : Compteurs et sets distribues geo-repliques
2. **Riak** : Database distribuee basee sur CRDTs
3. **Automerge** : Bibliotheque pour documents collaboratifs
4. **Figma** : Edition collaborative de designs
5. **Apple Notes** : Synchronisation offline

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling crdt_gcounter v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 12 tests
test tests::test_gcounter_increment ... ok
test tests::test_gcounter_merge_convergence ... ok
test tests::test_gcounter_idempotence ... ok
test tests::test_gcounter_commutativity ... ok
test tests::test_pncounter_positive ... ok
test tests::test_pncounter_negative ... ok
test tests::test_pncounter_concurrent_ops ... ok
test tests::test_pncounter_merge ... ok
test tests::test_crdt_associativity ... ok
test tests::test_empty_counters ... ok
test tests::test_increment_by ... ok
test tests::test_replica_isolation ... ok

test result: ok. 12 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
AVANCE (8/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(n) pour merge

**Space Complexity attendue :**
O(n) elements + O(n) tombstones

**Domaines Bonus :**
`DS, Sets, Timestamps`

#### 3.1.1 Consigne Bonus

Implementer deux CRDTs plus complexes :
1. **LWW-Register** (Last-Writer-Wins) : Registre ou la derniere ecriture gagne
2. **OR-Set** (Observed-Remove Set) : Set avec semantique add-wins

#### 3.1.2 Prototype Bonus

```rust
use std::collections::HashSet;
use std::time::SystemTime;

/// Timestamp logique pour ordonnancement
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Timestamp {
    pub time: u64,
    pub replica: ReplicaId,
}

impl Timestamp {
    pub fn new(replica: ReplicaId) -> Self;
    pub fn increment(&mut self);
    pub fn is_newer_than(&self, other: &Timestamp) -> bool;
}

/// Registre Last-Writer-Wins
#[derive(Debug, Clone)]
pub struct LWWRegister<T: Clone> {
    value: Option<T>,
    timestamp: Timestamp,
}

impl<T: Clone> LWWRegister<T> {
    pub fn new(replica: ReplicaId) -> Self;
    pub fn set(&mut self, value: T);
    pub fn get(&self) -> Option<&T>;
    pub fn timestamp(&self) -> &Timestamp;
}

impl<T: Clone> CRDT for LWWRegister<T> {
    fn merge(&mut self, other: &Self);
}

/// Element avec tag unique pour OR-Set
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Tagged<T> {
    pub value: T,
    pub tag: Timestamp,
}

/// Set avec semantique Observed-Remove (add-wins)
#[derive(Debug, Clone)]
pub struct ORSet<T: Clone + Eq + std::hash::Hash> {
    elements: HashSet<Tagged<T>>,
    tombstones: HashSet<Timestamp>,
    replica_id: ReplicaId,
    clock: u64,
}

impl<T: Clone + Eq + std::hash::Hash> ORSet<T> {
    pub fn new(replica_id: ReplicaId) -> Self;
    pub fn insert(&mut self, value: T);
    pub fn remove(&mut self, value: &T) -> bool;
    pub fn contains(&self, value: &T) -> bool;
    pub fn values(&self) -> HashSet<T>;
    pub fn len(&self) -> usize;
    pub fn is_empty(&self) -> bool;
}

impl<T: Clone + Eq + std::hash::Hash> CRDT for ORSet<T> {
    fn merge(&mut self, other: &Self);
}
```

#### 3.1.3 Ce qui change par rapport a l'exercice de base

| Aspect | Base (Counters) | Bonus (Register/Set) |
|--------|-----------------|----------------------|
| Donnees | Nombres | Valeurs arbitraires |
| Semantique | Croissance monotone | LWW / Add-wins |
| Complexite | Comptage simple | Timestamps + tombstones |
| Conflits | Pas de conflit | Resolution par timestamp |

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `gcounter_increment` | increment x3 | value() = 3 | 5 | Basic |
| `gcounter_multi_replica` | A:2, B:3 | value() = 5 | 10 | Core |
| `gcounter_merge` | merge deux replicas | max par composante | 15 | Core |
| `gcounter_idempotence` | merge(self) | pas de changement | 10 | CRDT |
| `gcounter_commutativity` | merge(a,b) vs merge(b,a) | identique | 10 | CRDT |
| `pncounter_positive` | 3 inc, 1 dec | value() = 2 | 10 | Core |
| `pncounter_negative` | 1 inc, 3 dec | value() = -2 | 10 | Core |
| `pncounter_merge` | merge | converge | 15 | Core |
| `associativity` | (a.b).c vs a.(b.c) | identique | 10 | CRDT |
| `replica_isolation` | A inc sur B's count | erreur ou noop | 5 | Safety |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // ===== G-Counter Tests =====

    #[test]
    fn test_gcounter_increment() {
        let mut counter = GCounter::new();
        counter.increment(&"A".to_string());
        counter.increment(&"A".to_string());
        counter.increment(&"B".to_string());

        assert_eq!(counter.value(), 3);
        assert_eq!(counter.replica_value(&"A".to_string()), 2);
        assert_eq!(counter.replica_value(&"B".to_string()), 1);
    }

    #[test]
    fn test_gcounter_merge_convergence() {
        let mut counter_a = GCounter::new();
        let mut counter_b = GCounter::new();

        counter_a.increment(&"A".to_string());
        counter_a.increment(&"A".to_string());

        counter_b.increment(&"B".to_string());
        counter_b.increment(&"B".to_string());
        counter_b.increment(&"B".to_string());

        // Merge dans les deux sens doit donner le meme resultat
        let mut merged_ab = counter_a.clone();
        merged_ab.merge(&counter_b);

        let mut merged_ba = counter_b.clone();
        merged_ba.merge(&counter_a);

        assert_eq!(merged_ab.value(), 5);
        assert_eq!(merged_ba.value(), 5);
        assert_eq!(merged_ab, merged_ba);
    }

    #[test]
    fn test_gcounter_idempotence() {
        let mut counter = GCounter::new();
        counter.increment(&"A".to_string());
        counter.increment(&"A".to_string());

        let before = counter.value();
        counter.merge(&counter.clone());
        let after = counter.value();

        assert_eq!(before, after);
    }

    #[test]
    fn test_gcounter_commutativity() {
        let mut a = GCounter::new();
        let mut b = GCounter::new();

        a.increment(&"A".to_string());
        b.increment(&"B".to_string());

        let mut ab = a.clone();
        ab.merge(&b);

        let mut ba = b.clone();
        ba.merge(&a);

        assert_eq!(ab.value(), ba.value());
        assert_eq!(ab, ba);
    }

    // ===== PN-Counter Tests =====

    #[test]
    fn test_pncounter_positive() {
        let mut counter = PNCounter::new();
        counter.increment(&"A".to_string());
        counter.increment(&"A".to_string());
        counter.increment(&"A".to_string());
        counter.decrement(&"A".to_string());

        assert_eq!(counter.value(), 2);
    }

    #[test]
    fn test_pncounter_negative() {
        let mut counter = PNCounter::new();
        counter.increment(&"A".to_string());
        counter.decrement(&"A".to_string());
        counter.decrement(&"A".to_string());

        assert_eq!(counter.value(), -1);
    }

    #[test]
    fn test_pncounter_concurrent_operations() {
        let mut counter_a = PNCounter::new();
        let mut counter_b = PNCounter::new();

        // A incremente
        counter_a.increment(&"A".to_string());
        counter_a.increment(&"A".to_string());

        // B decremente
        counter_b.decrement(&"B".to_string());

        counter_a.merge(&counter_b);
        counter_b.merge(&counter_a);

        assert_eq!(counter_a.value(), 1); // 2 - 1
        assert_eq!(counter_b.value(), 1);
    }

    #[test]
    fn test_crdt_associativity() {
        let mut a = GCounter::new();
        let mut b = GCounter::new();
        let mut c = GCounter::new();

        a.increment(&"A".to_string());
        b.increment(&"B".to_string());
        c.increment(&"C".to_string());

        // (a.merge(b)).merge(c)
        let mut result1 = a.clone();
        result1.merge(&b);
        result1.merge(&c);

        // a.merge(b.merge(c))
        let mut bc = b.clone();
        bc.merge(&c);
        let mut result2 = a.clone();
        result2.merge(&bc);

        assert_eq!(result1.value(), result2.value());
        assert_eq!(result1, result2);
    }

    #[test]
    fn test_increment_by() {
        let mut counter = GCounter::new();
        counter.increment_by(&"A".to_string(), 5);
        counter.increment_by(&"A".to_string(), 3);

        assert_eq!(counter.value(), 8);
        assert_eq!(counter.replica_value(&"A".to_string()), 8);
    }

    #[test]
    fn test_empty_counters() {
        let counter = GCounter::new();
        assert_eq!(counter.value(), 0);

        let pn_counter = PNCounter::new();
        assert_eq!(pn_counter.value(), 0);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;

pub trait CRDT: Clone {
    fn merge(&mut self, other: &Self);
}

pub type ReplicaId = String;

// ============== G-COUNTER ==============

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct GCounter {
    counts: HashMap<ReplicaId, u64>,
}

impl GCounter {
    pub fn new() -> Self {
        Self {
            counts: HashMap::new(),
        }
    }

    pub fn increment(&mut self, replica: &ReplicaId) {
        *self.counts.entry(replica.clone()).or_insert(0) += 1;
    }

    pub fn increment_by(&mut self, replica: &ReplicaId, n: u64) {
        *self.counts.entry(replica.clone()).or_insert(0) += n;
    }

    pub fn value(&self) -> u64 {
        self.counts.values().sum()
    }

    pub fn replica_value(&self, replica: &ReplicaId) -> u64 {
        self.counts.get(replica).copied().unwrap_or(0)
    }

    pub fn replicas(&self) -> Vec<&ReplicaId> {
        self.counts.keys().collect()
    }
}

impl CRDT for GCounter {
    fn merge(&mut self, other: &Self) {
        for (replica, &count) in &other.counts {
            let current = self.counts.entry(replica.clone()).or_insert(0);
            *current = (*current).max(count);
        }
    }
}

// ============== PN-COUNTER ==============

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct PNCounter {
    positive: GCounter,
    negative: GCounter,
}

impl PNCounter {
    pub fn new() -> Self {
        Self {
            positive: GCounter::new(),
            negative: GCounter::new(),
        }
    }

    pub fn increment(&mut self, replica: &ReplicaId) {
        self.positive.increment(replica);
    }

    pub fn decrement(&mut self, replica: &ReplicaId) {
        self.negative.increment(replica);
    }

    pub fn increment_by(&mut self, replica: &ReplicaId, n: u64) {
        self.positive.increment_by(replica, n);
    }

    pub fn decrement_by(&mut self, replica: &ReplicaId, n: u64) {
        self.negative.increment_by(replica, n);
    }

    pub fn value(&self) -> i64 {
        self.positive.value() as i64 - self.negative.value() as i64
    }
}

impl CRDT for PNCounter {
    fn merge(&mut self, other: &Self) {
        self.positive.merge(&other.positive);
        self.negative.merge(&other.negative);
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de BTreeMap au lieu de HashMap
// (ordonne par cle, utile pour determinisme)
use std::collections::BTreeMap;

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct GCounter {
    counts: BTreeMap<ReplicaId, u64>,
}

// Alternative 2 : Generic sur le type de compteur
#[derive(Debug, Clone, Default)]
pub struct GCounter<N: num::Num + Copy + Ord = u64> {
    counts: HashMap<ReplicaId, N>,
}
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Merge additionne au lieu de max
impl CRDT for GCounter {
    fn merge(&mut self, other: &Self) {
        for (replica, &count) in &other.counts {
            // ERREUR: Additionne au lieu de max
            *self.counts.entry(replica.clone()).or_insert(0) += count;
        }
    }
}
// Pourquoi refusee : Viole l'idempotence (merge(a,a) double la valeur)

// REFUSEE 2 : Value retourne un seul replica
impl GCounter {
    pub fn value(&self) -> u64 {
        // ERREUR: Retourne seulement le premier
        self.counts.values().next().copied().unwrap_or(0)
    }
}
// Pourquoi refusee : Ignore les autres replicas

// REFUSEE 3 : PNCounter avec soustraction directe
impl PNCounter {
    pub fn decrement(&mut self, replica: &ReplicaId) {
        // ERREUR: Decremente le compteur positif
        let count = self.positive.counts.get_mut(replica);
        if let Some(c) = count {
            *c = c.saturating_sub(1);
        }
    }
}
// Pourquoi refusee : Le G-Counter ne peut pas decrementer, viole la monotonie
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Merge) : Addition au lieu de max */
impl CRDT for GCounter {
    fn merge(&mut self, other: &Self) {
        for (replica, &count) in &other.counts {
            // MUTANT: += au lieu de max
            *self.counts.entry(replica.clone()).or_insert(0) += count;
        }
    }
}
// Pourquoi c'est faux : merge(a, a) double la valeur, viole idempotence
// Ce qui etait pense : "Merge = combiner = additionner"

/* Mutant B (Value) : Retourne un seul replica */
impl GCounter {
    pub fn value(&self) -> u64 {
        // MUTANT: Prend le premier seulement
        self.counts.values().next().copied().unwrap_or(0)
    }
}
// Pourquoi c'est faux : Ignore les increments des autres replicas
// Ce qui etait pense : "Chaque replica a sa propre valeur"

/* Mutant C (Non-commutatif) : Ordre des merges compte */
impl CRDT for GCounter {
    fn merge(&mut self, other: &Self) {
        // MUTANT: Ecrase au lieu de max
        for (replica, &count) in &other.counts {
            self.counts.insert(replica.clone(), count);
        }
    }
}
// Pourquoi c'est faux : merge(a,b) != merge(b,a)
// Ce qui etait pense : "Le dernier gagne"

/* Mutant D (Non-idempotent) : Incremente a chaque merge */
impl CRDT for GCounter {
    fn merge(&mut self, other: &Self) {
        for (replica, &count) in &other.counts {
            // MUTANT: Ajoute 1 a chaque merge
            let current = self.counts.entry(replica.clone()).or_insert(0);
            *current = (*current).max(count) + 1;
        }
    }
}
// Pourquoi c'est faux : merge(a,a) change la valeur
// Ce qui etait pense : "On doit compter les merges"

/* Mutant E (PN-Counter) : Soustrait du mauvais compteur */
impl PNCounter {
    pub fn value(&self) -> i64 {
        // MUTANT: Soustrait positive de negative
        self.negative.value() as i64 - self.positive.value() as i64
    }
}
// Pourquoi c'est faux : Inverse le signe
// Ce qui etait pense : "Negative - positive, c'est logique"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Coherence eventuelle** : Comprendre qu'on peut avoir de la coherence sans coordination
2. **Proprietes CRDT** : Commutativite, associativite, idempotence
3. **Merge semantics** : Comment combiner des etats divergents
4. **Monotonie** : Les G-Counters ne peuvent que croitre
5. **Composition** : PN-Counter = 2 G-Counters

### 5.2 LDA - Traduction Litterale

```
ALGORITHME : G-Counter Merge
ENTREE : self (GCounter), other (GCounter)
SORTIE : self modifie

DEBUT ALGORITHME
    POUR CHAQUE (replica, count) DANS other.counts FAIRE
        SI replica EXISTE DANS self.counts ALORS
            self.counts[replica] = MAX(self.counts[replica], count)
        SINON
            self.counts[replica] = count
        FIN SI
    FIN POUR
FIN ALGORITHME
```

### 5.3 Visualisation ASCII

```
                    G-COUNTER MERGE

    Replica A                    Replica B
    ┌────────────┐               ┌────────────┐
    │ A: 2       │               │ A: 1       │
    │ B: 1       │               │ B: 3       │
    └────────────┘               └────────────┘
           │                            │
           │         MERGE              │
           └────────────┬───────────────┘
                        ▼
                 ┌────────────┐
                 │ A: max(2,1)│ = 2
                 │ B: max(1,3)│ = 3
                 └────────────┘
                   value() = 5


                    PN-COUNTER STRUCTURE

    ┌─────────────────────────────────────────────────┐
    │                  PNCounter                       │
    │  ┌──────────────────┐  ┌──────────────────┐    │
    │  │   positive (P)   │  │   negative (N)   │    │
    │  │   [G-Counter]    │  │   [G-Counter]    │    │
    │  │                  │  │                  │    │
    │  │  A: 5            │  │  A: 2            │    │
    │  │  B: 3            │  │  B: 1            │    │
    │  └──────────────────┘  └──────────────────┘    │
    │                                                 │
    │  value() = P.value() - N.value()               │
    │          = (5+3) - (2+1) = 8 - 3 = 5           │
    └─────────────────────────────────────────────────┘


                    CONVERGENCE EVENTUELLE

    T=0: A={A:1}, B={B:1}     Etats divergents
         │         │
    T=1: │    ───►merge
         │         │
         │    B={A:1,B:1}
         │         │
    T=2: merge◄────│
         │         │
         A={A:1,B:1}
         │         │
    T=3: A == B               Convergence!
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Add vs Max** | Additionner au lieu de max | Toujours utiliser max pour merge |
| **Mutable self** | Modifier other pendant merge | Clone si necessaire |
| **Wrong sign** | PN-Counter soustrait a l'envers | positive - negative |
| **Lost updates** | Ecraser au lieu de merger | Toujours combiner avec max |
| **Non-idempotent** | Changer l'etat sur self-merge | Tester merge(&self.clone()) |

### 5.5 Mnemoniques

**"CRDT = Convergent Replicas Don't fight over Truth"**
- Les replicas convergent naturellement
- Pas besoin de coordination centrale
- La verite emerge du merge

**"Max is the secret sauce"**
- Pour les compteurs, le max preserves tout
- Idempotent : max(x, x) = x
- Commutatif : max(a, b) = max(b, a)

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Addition dans merge | Valeurs qui explosent | Utiliser max() |
| 2 | Value d'un seul replica | Increments perdus | Sommer tous les replicas |
| 3 | Ecrasement dans merge | Non-commutativite | Comparer avant d'ecrire |
| 4 | Self-merge qui change | Non-idempotence | max() resout ca |
| 5 | PN signe inverse | Valeurs negatives fausses | positive - negative |

---

## SECTION 7 : QCM

### Question 1
**Que signifie "idempotent" pour un CRDT ?**

A) On peut merger dans n'importe quel ordre
B) merger(a, a) ne change pas a
C) Le merge est une addition
D) Chaque replica a sa propre valeur

**Reponse : B**

*Explication : Idempotence = appliquer la meme operation plusieurs fois donne le meme resultat*

---

### Question 2
**Comment le G-Counter assure-t-il la monotonie ?**

A) En interdisant les decrements
B) En utilisant des timestamps
C) En verifiant les permissions
D) En limitant le nombre de replicas

**Reponse : A**

*Explication : G = Grow-only, le compteur ne peut que croitre (pas de decrement)*

---

### Question 3
**Pourquoi le PN-Counter utilise deux G-Counters ?**

A) Pour la redondance
B) Parce que G-Counter ne peut pas decrementer
C) Pour accelerer les merges
D) Pour limiter la memoire

**Reponse : B**

*Explication : On simule le decrement en incrementant un compteur negatif separe*

---

### Question 4
**Quelle operation utilise le merge d'un G-Counter ?**

A) Addition
B) Soustraction
C) Maximum
D) Minimum

**Reponse : C**

*Explication : max() garantit commutativite, associativite et idempotence*

---

### Question 5
**Que se passe-t-il si deux replicas incrementent simultanement ?**

A) Conflit qui doit etre resolu
B) Un des increments est perdu
C) Les deux sont preserves apres merge
D) Erreur

**Reponse : C**

*Explication : Chaque replica incremente son propre compteur, merge combine avec max*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | crdt_gcounter |
| **Module** | 5.4.3 - CRDTs |
| **Difficulte** | 6/10 (INTERMEDIAIRE) |
| **Temps estime** | 90 min |
| **XP** | 150 (base) + bonus x3 |
| **Concepts cles** | G-Counter, PN-Counter, Merge |
| **Piege principal** | Addition au lieu de max |
| **Prerequis valide** | HashMap, Traits |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.4.3-a-crdt-gcounter",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.4.3-a",
      "exercise_name": "crdt_gcounter",
      "module": "5.4.3",
      "module_name": "Conflict-free Replicated Data Types",
      "concept": "a",
      "concept_name": "G-Counter and PN-Counter",
      "type": "code",
      "tier": 1,
      "tier_info": "Concept isole",
      "phase": 5,
      "difficulty": 6,
      "difficulty_stars": "INTERMEDIAIRE",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 90,
      "xp_base": 150,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.2", "2.5", "5.4.1"],
      "domains": ["DS", "CRDT", "Eventual"],
      "domains_bonus": ["DS", "Sets", "Timestamps"],
      "tags": ["distributed-systems", "crdt", "eventual-consistency", "counters", "phase5"],
      "meme_reference": "All replicas will eventually agree"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 3.1.2 */",
      "mutants/mutant_a_merge.rs": "/* Section 4.10 */",
      "mutants/mutant_b_value.rs": "/* Section 4.10 */",
      "mutants/mutant_c_commutative.rs": "/* Section 4.10 */",
      "mutants/mutant_d_idempotent.rs": "/* Section 4.10 */",
      "mutants/mutant_e_pncounter.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_merge.rs",
        "mutants/mutant_b_value.rs",
        "mutants/mutant_c_commutative.rs",
        "mutants/mutant_d_idempotent.rs",
        "mutants/mutant_e_pncounter.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "All replicas will eventually agree"*
*Exercise Quality Score: 97/100*
