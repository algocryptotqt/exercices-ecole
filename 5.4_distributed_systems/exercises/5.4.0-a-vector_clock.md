<thinking>
## Analyse du Concept
- Concept : Vector Clocks - Causal Ordering Engine
- Phase demandee : Fondamentale (systemes distribues)
- Adapte ? OUI - Les horloges vectorielles sont LE fondement de l'ordonnancement causal

## Combo Base + Bonus
- Exercice de base : Implementer VectorClock avec tick, merge, compare, happened_before
- Bonus : Interval Tree Clocks (ITC) pour systemes dynamiques + Causal History compression
- Palier bonus : AVANCE (detection de fork) puis EXPERT (ITC complet)
- Progression logique ? OUI - Base = VC standard, Bonus = extensions avancees

## Prerequis & Difficulte
- Prerequis reels : HashMap, PartialOrd, Serde, concepts de causalite
- Difficulte estimee : 6/10 (base), 8/10 (bonus detection fork), 9/10 (bonus ITC)
- Coherent avec module 5.4 ? OUI

## Aspect Fun/Culture
- Contexte choisi : "The Butterfly Effect" - Chaque evenement laisse une trace temporelle
- MEME mnemonique : "No one can escape causality, not even in distributed systems"
- Pourquoi c'est fun : Comme le voyage dans le temps, on peut savoir ce qui s'est passe AVANT

## Scenarios d'Echec (6 mutants concrets)
1. Mutant A (Boundary) : merge prend min au lieu de max - perd de l'information causale
2. Mutant B (Safety) : tick sur noeud inconnu ne l'initialise pas - KeyError
3. Mutant C (Logic) : happened_before mal implemente - retourne true pour concurrent
4. Mutant D (Comparison) : compare utilise && au lieu de checker toutes les composantes
5. Mutant E (Serialization) : from_bytes ne gere pas les erreurs - panic sur donnees corrompues
6. Mutant F (Merge) : oublie d'incrementer apres merge - viole la semantique

## Verdict
VALIDE - L'exercice couvre les fondamentaux critiques des systemes distribues
</thinking>

---

# Exercice 5.4.0-a : vector_clock

**Module :**
5.4.0 -- Distributed Systems Fundamentals

**Concept :**
a -- Vector Clocks & Causal Ordering

**Difficulte :**
6/10

**Type :**
complet

**Tiers :**
1 -- Concept isole

**Langage :**
Rust Edition 2024

**Prerequis :**
- HashMap et collections Rust
- Traits PartialOrd, Clone, Default
- Serialisation avec Serde
- Notions de base sur les systemes distribues

**Domaines :**
Distributed, Concurrency, Serialization

**Duree estimee :**
90 min

**XP Base :**
250

**Complexite :**
T[3] O(n) pour comparaison/merge (n = noeuds) * S[2] O(n) pour stockage

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichiers a rendre :**
- `src/lib.rs`
- `Cargo.toml`

**Dependances autorisees :**
- `serde` (avec features `derive`)
- `serde_json`
- `thiserror`

**Fonctions interdites :**
- Crates externes de vector clocks (`vector-clock`, `causality`, etc.)
- `unsafe` code
- Threads/async (pas necessaire pour cet exercice)

### 1.2 Consigne

**L'EFFET PAPILLON -- Traquer la Causalite dans le Chaos Distribue**

*"Dans un systeme distribue, un battement d'aile a Tokyo peut causer une tempete de donnees a Paris... mais comment savoir lequel est venu en PREMIER ?"*

Dans le film "The Butterfly Effect", Evan peut voir les consequences de chaque choix. Dans les systemes distribues, les **Vector Clocks** nous donnent ce meme pouvoir : determiner si un evenement A a CAUSE un evenement B, ou s'ils sont CONCURRENTS.

**Le probleme fondamental :**
- Les horloges physiques ne sont PAS synchronisees entre machines
- Un message peut arriver AVANT l'evenement qui l'a cause (du point de vue horloge locale)
- Comment ordonner les evenements de maniere LOGIQUE ?

**La solution de Lamport/Fidge/Mattern :**
Chaque processus maintient un vecteur de compteurs. Quand :
- **Evenement local** : incrementer son propre compteur
- **Envoi de message** : attacher son horloge vectorielle
- **Reception** : fusionner (max) puis incrementer

**Ta mission :**

Implementer une bibliotheque `VectorClock` qui permet de :
1. **Creer** une horloge vide
2. **Tick** : marquer un evenement local
3. **Merge** : fusionner lors de reception de message
4. **Compare** : determiner la relation causale entre deux horloges
5. **Serialize/Deserialize** : transmettre sur le reseau

**Entree :**
- `node_id` : Identifiant du noeud (String)
- `other` : Autre horloge pour merge/compare

**Sortie :**
- `CausalOrder::Before` : self happened-before other
- `CausalOrder::After` : other happened-before self
- `CausalOrder::Concurrent` : evenements incomparables
- `CausalOrder::Equal` : horloges identiques

**La regle d'or de la causalite :**
```
VC(a) < VC(b) ssi:
  - Pour tout i: VC(a)[i] <= VC(b)[i]
  - Et il existe j: VC(a)[j] < VC(b)[j]
```

**Exemples :**

| Scenario | Clock A | Clock B | Relation |
|----------|---------|---------|----------|
| A cause B | {A:1} | {A:1, B:1} | Before |
| B cause A | {A:2, B:1} | {B:1} | After |
| Concurrent | {A:1} | {B:1} | Concurrent |
| Identique | {A:1, B:2} | {A:1, B:2} | Equal |

### 1.3 Prototype

```rust
// src/lib.rs

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Identifiant unique d'un noeud dans le systeme distribue
pub type NodeId = String;

/// Resultat de la comparaison de deux horloges vectorielles
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CausalOrder {
    /// self happened-before other (self < other)
    Before,
    /// other happened-before self (self > other)
    After,
    /// Evenements concurrents (incomparables)
    Concurrent,
    /// Horloges identiques
    Equal,
}

/// Erreurs possibles pour les operations sur VectorClock
#[derive(Debug, thiserror::Error)]
pub enum ClockError {
    #[error("Failed to serialize clock: {0}")]
    SerializationError(String),
    #[error("Failed to deserialize clock: {0}")]
    DeserializationError(String),
    #[error("Invalid clock state: {0}")]
    InvalidState(String),
}

/// Horloge vectorielle pour le suivi causal
#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq, Eq)]
pub struct VectorClock {
    // TODO: Implementer la structure interne
    // Indice: HashMap<NodeId, u64>
}

/// Un evenement estampille avec une horloge vectorielle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimestampedEvent<T> {
    pub clock: VectorClock,
    pub origin: NodeId,
    pub payload: T,
}

impl VectorClock {
    /// Cree une nouvelle horloge vectorielle vide
    ///
    /// # Example
    /// ```
    /// let clock = VectorClock::new();
    /// assert!(clock.is_empty());
    /// ```
    pub fn new() -> Self;

    /// Incremente le compteur local pour le noeud donne (evenement local)
    ///
    /// # Arguments
    /// * `node_id` - Identifiant du noeud qui genere l'evenement
    ///
    /// # Example
    /// ```
    /// let mut clock = VectorClock::new();
    /// clock.tick(&"node_a".to_string());
    /// assert_eq!(clock.get(&"node_a".to_string()), 1);
    /// ```
    pub fn tick(&mut self, node_id: &NodeId);

    /// Fusionne avec une autre horloge (reception d'un message)
    /// Prend le maximum de chaque composante puis incremente le noeud local
    ///
    /// # Arguments
    /// * `other` - L'horloge recue avec le message
    /// * `local_node` - L'identifiant du noeud local (pour incrementer apres merge)
    ///
    /// # Semantique
    /// Pour chaque noeud i: result[i] = max(self[i], other[i])
    /// Puis: result[local_node] += 1
    pub fn merge(&mut self, other: &VectorClock, local_node: &NodeId);

    /// Obtient la valeur du compteur pour un noeud specifique
    /// Retourne 0 si le noeud n'est pas connu
    pub fn get(&self, node_id: &NodeId) -> u64;

    /// Compare deux horloges et retourne leur relation causale
    ///
    /// # Regles de comparaison
    /// - Equal: toutes les composantes sont egales
    /// - Before: self <= other pour tout, et self < other pour au moins un
    /// - After: other <= self pour tout, et other < self pour au moins un
    /// - Concurrent: ni Before, ni After, ni Equal
    pub fn compare(&self, other: &VectorClock) -> CausalOrder;

    /// Verifie si self happened-before other
    pub fn happened_before(&self, other: &VectorClock) -> bool;

    /// Verifie si les deux horloges representent des evenements concurrents
    pub fn is_concurrent_with(&self, other: &VectorClock) -> bool;

    /// Retourne tous les noeuds connus par cette horloge
    pub fn known_nodes(&self) -> Vec<NodeId>;

    /// Verifie si l'horloge est vide (aucun tick)
    pub fn is_empty(&self) -> bool;

    /// Serialise l'horloge en bytes (JSON) pour transmission reseau
    pub fn to_bytes(&self) -> Vec<u8>;

    /// Deserialise une horloge depuis des bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ClockError>;
}

impl<T: Clone> TimestampedEvent<T> {
    /// Cree un nouvel evenement avec l'horloge courante
    /// Incremente l'horloge automatiquement
    pub fn new(clock: &mut VectorClock, origin: NodeId, payload: T) -> Self;

    /// Verifie si cet evenement est causalement avant un autre
    pub fn happened_before(&self, other: &TimestampedEvent<T>) -> bool;

    /// Verifie si deux evenements sont concurrents
    pub fn is_concurrent_with(&self, other: &TimestampedEvent<T>) -> bool;
}

// Implementer PartialOrd pour VectorClock
// Note: Pas de Ord car la relation n'est pas totale (evenements concurrents)
impl PartialOrd for VectorClock {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering>;
}
```

### 1.2.2 Enonce Academique

Une **horloge vectorielle** (Vector Clock) est un mecanisme d'horodatage logique permettant de capturer les relations de causalite dans un systeme distribue.

**Definition formelle :**
Soit un systeme de N processus. Chaque processus Pi maintient un vecteur VC[i] de N compteurs.

**Regles de mise a jour :**
1. **Evenement local sur Pi** : VC[i][i] := VC[i][i] + 1
2. **Envoi de message par Pi** : attacher VC[i] au message
3. **Reception par Pj d'un message avec VC_m** :
   - Pour tout k : VC[j][k] := max(VC[j][k], VC_m[k])
   - VC[j][j] := VC[j][j] + 1

**Relation happened-before (a -> b)** :
VC(a) < VC(b) ssi pour tout i: VC(a)[i] <= VC(b)[i] ET il existe j: VC(a)[j] < VC(b)[j]

**Evenements concurrents (a || b)** :
Ni a -> b, ni b -> a

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Histoire des Vector Clocks

Les horloges vectorielles ont ete inventees independamment par **Colin Fidge** et **Friedemann Mattern** en 1988, comme extension des horloges logiques de **Leslie Lamport** (1978).

**Fun fact :** Leslie Lamport a recu le prix Turing en 2013, en partie pour ses travaux sur les horloges logiques et la causalite distribuee.

### 2.2 Le Probleme de la Synchronisation

Pourquoi les horloges physiques ne suffisent pas ?
- La derive d'horloge (clock drift) peut atteindre plusieurs secondes par jour
- La latence reseau est variable et imprevisible
- NTP ne garantit qu'une precision de quelques millisecondes (insuffisant pour micro-evenements)

**Citation celebre de Lamport :**
> "Time is a device invented to prevent everything from happening at once."

### 2.3 DANS LA VRAIE VIE

| Systeme | Utilisation | Pourquoi Vector Clocks |
|---------|-------------|------------------------|
| **Amazon DynamoDB** | Conflict detection | Detecter les ecritures concurrentes pour reconciliation |
| **Riak** | Causal consistency | Garantir l'ordre causal des operations |
| **CockroachDB** | Hybrid logical clocks | Combiner timestamps physiques et logiques |
| **Git** | Merge detection | Determiner si un commit est ancetre d'un autre |
| **Apache Cassandra** | Vector clocks (deprecated) | Detection de conflits (remplace par Last-Write-Wins) |

### 2.4 Limitations des Vector Clocks

1. **Taille O(n)** : Le vecteur croit avec le nombre de noeuds
2. **Garbage collection** : Difficile de savoir quand tronquer
3. **Churn** : Problematique quand les noeuds rejoignent/quittent souvent

**Solutions modernes :**
- Interval Tree Clocks (ITC)
- Dotted Version Vectors
- Hybrid Logical Clocks (HLC)

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ tree
.
├── Cargo.toml
└── src
    └── lib.rs

$ cat Cargo.toml
[package]
name = "vector_clock"
version = "0.1.0"
edition = "2024"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"

[dev-dependencies]
# Tests uniquement

$ cargo build
   Compiling vector_clock v0.1.0
    Finished dev [unoptimized + debuginfo]

$ cargo test
running 12 tests
test tests::test_new_clock_is_empty ... ok
test tests::test_basic_tick ... ok
test tests::test_multiple_ticks ... ok
test tests::test_happened_before_simple ... ok
test tests::test_concurrent_events ... ok
test tests::test_merge_basic ... ok
test tests::test_merge_increments_local ... ok
test tests::test_causal_chain ... ok
test tests::test_serialization_roundtrip ... ok
test tests::test_compare_equal ... ok
test tests::test_timestamped_event ... ok
test tests::test_partial_ord ... ok

test result: ok. 12 passed; 0 failed
```

### 3.1 Exemple de trace d'execution

```
=== Simulation: 3 noeuds (Alice, Bob, Charlie) ===

[T=0] Etat initial:
  Alice:   {}
  Bob:     {}
  Charlie: {}

[T=1] Alice: evenement local (tick)
  Alice:   {Alice: 1}

[T=2] Alice envoie message a Bob
  Message contient: {Alice: 1}

[T=3] Bob recoit message (merge + tick)
  Bob:     {Alice: 1, Bob: 1}

[T=4] Charlie: evenement local (tick)
  Charlie: {Charlie: 1}

[T=5] Comparaisons:
  Alice {Alice:1} vs Bob {Alice:1, Bob:1}
    -> Alice happened-before Bob (Before)

  Alice {Alice:1} vs Charlie {Charlie:1}
    -> CONCURRENT (ni l'un ni l'autre ne cause l'autre)

  Bob {Alice:1, Bob:1} vs Charlie {Charlie:1}
    -> CONCURRENT

[T=6] Charlie envoie a Bob, Bob merge:
  Bob:     {Alice: 1, Bob: 2, Charlie: 1}

[T=7] Maintenant:
  Bob {Alice:1, Bob:2, Charlie:1} vs Charlie {Charlie:1}
    -> Charlie happened-before Bob (After du point de vue Bob)
```

### 3.2 BONUS AVANCE : Fork Detection (OPTIONNEL)

**Difficulte Bonus :**
8/10

**Recompense :**
XP x3

**Consigne Bonus :**

**DETECTION DE FORK -- Quand l'Univers se Divise**

Dans certains systemes, un noeud peut "forker" (se diviser en deux identites). Implementer `detect_fork()` qui identifie si deux horloges proviennent d'un meme noeud qui a forke.

```rust
impl VectorClock {
    /// Detecte si deux horloges suggerent un fork
    /// Un fork est detecte si les deux horloges ont des valeurs
    /// pour le meme noeud qui ne sont pas comparables
    pub fn detect_fork(&self, other: &VectorClock, suspect_node: &NodeId) -> bool;
}
```

### 3.3 BONUS EXPERT : Interval Tree Clocks (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x4

**Consigne Bonus :**

Implementer les Interval Tree Clocks (ITC) qui resolvent le probleme de la taille O(n) des vector clocks dans les systemes dynamiques.

```rust
/// Interval Tree Clock - taille O(log n) en moyenne
pub struct IntervalTreeClock {
    id: ITCId,
    event: ITCEvent,
}

impl IntervalTreeClock {
    pub fn seed() -> Self;
    pub fn fork(&mut self) -> Self;
    pub fn join(&mut self, other: Self);
    pub fn event(&mut self);
    pub fn leq(&self, other: &Self) -> bool;
}
```

---

## SECTION 4 : ZONE CORRECTION (POUR LE TESTEUR)

### 4.1 Moulinette

| Test | Input | Expected | Points | Trap |
|------|-------|----------|--------|------|
| `test_new` | `VectorClock::new()` | `is_empty() == true` | 3 | |
| `test_tick_single` | `tick("A")` | `get("A") == 1` | 5 | |
| `test_tick_multiple` | `tick("A") x3` | `get("A") == 3` | 5 | |
| `test_tick_unknown` | `get("unknown")` | `0` | 5 | |
| `test_merge_basic` | `{A:1} merge {B:1}` | `{A:1, B:1, local:1}` | 8 | |
| `test_merge_max` | `{A:2} merge {A:3}` | `A == 3` | 8 | |
| `test_merge_increments` | merge puis check local | `local += 1` | 8 | |
| `test_compare_equal` | `{A:1} vs {A:1}` | `Equal` | 5 | |
| `test_compare_before` | `{A:1} vs {A:1,B:1}` | `Before` | 8 | |
| `test_compare_after` | `{A:2,B:1} vs {B:1}` | `After` | 8 | |
| `test_compare_concurrent` | `{A:1} vs {B:1}` | `Concurrent` | 10 | |
| `test_happened_before` | chaine A->B->C | `A.happened_before(C)` | 8 | |
| `test_serialization` | roundtrip | `clock == restored` | 8 | |
| `test_serialization_error` | invalid bytes | `Err(...)` | 5 | |
| `test_timestamped_event` | create event | clock incremented | 6 | |
| **TOTAL** | | | **100** | |

### 4.2 Tests de validation

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_clock_is_empty() {
        let clock = VectorClock::new();
        assert!(clock.is_empty());
        assert_eq!(clock.known_nodes().len(), 0);
    }

    #[test]
    fn test_basic_tick() {
        let mut clock = VectorClock::new();
        clock.tick(&"node_a".to_string());
        assert_eq!(clock.get(&"node_a".to_string()), 1);
        clock.tick(&"node_a".to_string());
        assert_eq!(clock.get(&"node_a".to_string()), 2);
    }

    #[test]
    fn test_get_unknown_node() {
        let clock = VectorClock::new();
        assert_eq!(clock.get(&"unknown".to_string()), 0);
    }

    #[test]
    fn test_happened_before() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());

        let mut clock_b = clock_a.clone();
        clock_b.tick(&"B".to_string());

        assert!(clock_a.happened_before(&clock_b));
        assert!(!clock_b.happened_before(&clock_a));
    }

    #[test]
    fn test_concurrent_events() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());

        let mut clock_b = VectorClock::new();
        clock_b.tick(&"B".to_string());

        assert!(clock_a.is_concurrent_with(&clock_b));
        assert!(clock_b.is_concurrent_with(&clock_a));
        assert!(!clock_a.happened_before(&clock_b));
        assert!(!clock_b.happened_before(&clock_a));
    }

    #[test]
    fn test_merge() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());
        clock_a.tick(&"A".to_string());

        let mut clock_b = VectorClock::new();
        clock_b.tick(&"B".to_string());

        clock_a.merge(&clock_b, &"A".to_string());

        assert_eq!(clock_a.get(&"A".to_string()), 3); // 2 + 1 from merge
        assert_eq!(clock_a.get(&"B".to_string()), 1);
    }

    #[test]
    fn test_merge_takes_max() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string()); // A=1

        let mut clock_b = VectorClock::new();
        clock_b.tick(&"A".to_string());
        clock_b.tick(&"A".to_string());
        clock_b.tick(&"A".to_string()); // A=3

        clock_a.merge(&clock_b, &"A".to_string());
        // max(1, 3) = 3, then +1 = 4
        assert_eq!(clock_a.get(&"A".to_string()), 4);
    }

    #[test]
    fn test_compare_equal() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());

        let clock_b = clock_a.clone();

        assert_eq!(clock_a.compare(&clock_b), CausalOrder::Equal);
    }

    #[test]
    fn test_compare_before() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());

        let mut clock_b = clock_a.clone();
        clock_b.tick(&"B".to_string());

        assert_eq!(clock_a.compare(&clock_b), CausalOrder::Before);
    }

    #[test]
    fn test_compare_after() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());
        clock_a.tick(&"A".to_string());

        let mut clock_b = VectorClock::new();
        clock_b.tick(&"A".to_string());

        assert_eq!(clock_a.compare(&clock_b), CausalOrder::After);
    }

    #[test]
    fn test_compare_concurrent() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());

        let mut clock_b = VectorClock::new();
        clock_b.tick(&"B".to_string());

        assert_eq!(clock_a.compare(&clock_b), CausalOrder::Concurrent);
    }

    #[test]
    fn test_serialization_roundtrip() {
        let mut clock = VectorClock::new();
        clock.tick(&"node1".to_string());
        clock.tick(&"node2".to_string());

        let bytes = clock.to_bytes();
        let restored = VectorClock::from_bytes(&bytes).unwrap();

        assert_eq!(clock.compare(&restored), CausalOrder::Equal);
    }

    #[test]
    fn test_serialization_error() {
        let invalid_bytes = b"not valid json";
        let result = VectorClock::from_bytes(invalid_bytes);
        assert!(result.is_err());
    }

    #[test]
    fn test_causal_chain() {
        // A -> B -> C (chaine causale)
        let node_a = "A".to_string();
        let node_b = "B".to_string();
        let node_c = "C".to_string();

        let mut clock_a = VectorClock::new();
        clock_a.tick(&node_a);

        let mut clock_b = VectorClock::new();
        clock_b.merge(&clock_a, &node_b);

        let mut clock_c = VectorClock::new();
        clock_c.merge(&clock_b, &node_c);

        assert!(clock_a.happened_before(&clock_b));
        assert!(clock_b.happened_before(&clock_c));
        assert!(clock_a.happened_before(&clock_c)); // Transitivite
    }

    #[test]
    fn test_timestamped_event() {
        let mut clock = VectorClock::new();
        let event = TimestampedEvent::new(
            &mut clock,
            "origin".to_string(),
            "payload data".to_string()
        );

        assert_eq!(event.origin, "origin");
        assert_eq!(event.payload, "payload data");
        assert_eq!(clock.get(&"origin".to_string()), 1);
    }

    #[test]
    fn test_partial_ord() {
        let mut clock_a = VectorClock::new();
        clock_a.tick(&"A".to_string());

        let mut clock_b = clock_a.clone();
        clock_b.tick(&"B".to_string());

        assert!(clock_a < clock_b);
        assert!(clock_b > clock_a);

        let mut clock_c = VectorClock::new();
        clock_c.tick(&"C".to_string());

        // Concurrent: partial_cmp returns None
        assert_eq!(clock_a.partial_cmp(&clock_c), None);
    }
}
```

### 4.3 Solution de reference

```rust
use serde::{Deserialize, Serialize};
use std::cmp::Ordering;
use std::collections::HashMap;

pub type NodeId = String;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CausalOrder {
    Before,
    After,
    Concurrent,
    Equal,
}

#[derive(Debug, thiserror::Error)]
pub enum ClockError {
    #[error("Failed to serialize clock: {0}")]
    SerializationError(String),
    #[error("Failed to deserialize clock: {0}")]
    DeserializationError(String),
    #[error("Invalid clock state: {0}")]
    InvalidState(String),
}

#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq, Eq)]
pub struct VectorClock {
    clocks: HashMap<NodeId, u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimestampedEvent<T> {
    pub clock: VectorClock,
    pub origin: NodeId,
    pub payload: T,
}

impl VectorClock {
    pub fn new() -> Self {
        VectorClock {
            clocks: HashMap::new(),
        }
    }

    pub fn tick(&mut self, node_id: &NodeId) {
        let counter = self.clocks.entry(node_id.clone()).or_insert(0);
        *counter += 1;
    }

    pub fn merge(&mut self, other: &VectorClock, local_node: &NodeId) {
        // Prendre le max de chaque composante
        for (node, &other_val) in &other.clocks {
            let self_val = self.clocks.entry(node.clone()).or_insert(0);
            *self_val = (*self_val).max(other_val);
        }
        // Incrementer le noeud local
        self.tick(local_node);
    }

    pub fn get(&self, node_id: &NodeId) -> u64 {
        *self.clocks.get(node_id).unwrap_or(&0)
    }

    pub fn compare(&self, other: &VectorClock) -> CausalOrder {
        // Collecter tous les noeuds
        let all_nodes: std::collections::HashSet<_> = self
            .clocks
            .keys()
            .chain(other.clocks.keys())
            .collect();

        let mut self_less = false;
        let mut other_less = false;

        for node in all_nodes {
            let self_val = self.get(node);
            let other_val = other.get(node);

            if self_val < other_val {
                self_less = true;
            }
            if other_val < self_val {
                other_less = true;
            }
        }

        match (self_less, other_less) {
            (false, false) => CausalOrder::Equal,
            (true, false) => CausalOrder::Before,
            (false, true) => CausalOrder::After,
            (true, true) => CausalOrder::Concurrent,
        }
    }

    pub fn happened_before(&self, other: &VectorClock) -> bool {
        self.compare(other) == CausalOrder::Before
    }

    pub fn is_concurrent_with(&self, other: &VectorClock) -> bool {
        self.compare(other) == CausalOrder::Concurrent
    }

    pub fn known_nodes(&self) -> Vec<NodeId> {
        self.clocks.keys().cloned().collect()
    }

    pub fn is_empty(&self) -> bool {
        self.clocks.is_empty() || self.clocks.values().all(|&v| v == 0)
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        serde_json::to_vec(self).unwrap_or_default()
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ClockError> {
        serde_json::from_slice(bytes)
            .map_err(|e| ClockError::DeserializationError(e.to_string()))
    }
}

impl<T: Clone> TimestampedEvent<T> {
    pub fn new(clock: &mut VectorClock, origin: NodeId, payload: T) -> Self {
        clock.tick(&origin);
        TimestampedEvent {
            clock: clock.clone(),
            origin,
            payload,
        }
    }

    pub fn happened_before(&self, other: &TimestampedEvent<T>) -> bool {
        self.clock.happened_before(&other.clock)
    }

    pub fn is_concurrent_with(&self, other: &TimestampedEvent<T>) -> bool {
        self.clock.is_concurrent_with(&other.clock)
    }
}

impl PartialOrd for VectorClock {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match self.compare(other) {
            CausalOrder::Equal => Some(Ordering::Equal),
            CausalOrder::Before => Some(Ordering::Less),
            CausalOrder::After => Some(Ordering::Greater),
            CausalOrder::Concurrent => None, // Pas d'ordre total
        }
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1: Utiliser BTreeMap pour ordre deterministe sur les noeuds
// Valide car meme semantique

// Alternative 2: Stocker les compteurs dans un Vec avec index mapping
// Valide si correctement implemente, mais plus complexe

// Alternative 3: Utiliser i64 au lieu de u64 (si bien gere)
// Valide mais non recommande (risque d'overflow negatif)
```

### 4.5 Solutions refusees (avec explications)

```rust
// REFUSE: Utiliser une crate externe de vector clocks
use vector_clock::VectorClock;
// Raison: L'exercice demande d'implementer la logique

// REFUSE: Ne pas incrementer apres merge
pub fn merge_bad(&mut self, other: &VectorClock, _local_node: &NodeId) {
    for (node, &val) in &other.clocks {
        let self_val = self.clocks.entry(node.clone()).or_insert(0);
        *self_val = (*self_val).max(val);
    }
    // Oubli du tick!
}
// Raison: Viole la semantique de reception de message

// REFUSE: Utiliser min au lieu de max dans merge
*self_val = (*self_val).min(other_val);
// Raison: Perd l'information causale
```

### 4.9 spec.json

```json
{
  "name": "vector_clock",
  "language": "rust",
  "type": "code",
  "tier": 1,
  "tier_info": "Concept isole - Fondamentaux distribues",
  "tags": ["distributed", "causality", "vector-clock", "ordering"],
  "passing_score": 70,

  "function": {
    "name": "VectorClock",
    "prototype": "pub struct VectorClock",
    "return_type": "struct",
    "parameters": []
  },

  "driver": {
    "edge_cases": [
      {
        "name": "empty_clock_get",
        "args": ["&\"unknown\".to_string()"],
        "expected": "0",
        "is_trap": false
      },
      {
        "name": "concurrent_detection",
        "args": ["{A:1}", "{B:1}"],
        "expected": "Concurrent",
        "is_trap": true,
        "trap_explanation": "Deux horloges sans composantes communes sont concurrentes"
      },
      {
        "name": "merge_self",
        "args": ["self", "self"],
        "expected": "Incremented",
        "is_trap": true,
        "trap_explanation": "Merge avec soi-meme doit quand meme incrementer"
      },
      {
        "name": "serialization_empty",
        "args": ["VectorClock::new()"],
        "expected": "Valid roundtrip",
        "is_trap": false
      },
      {
        "name": "invalid_json_deserialize",
        "args": ["b\"garbage\""],
        "expected": "Err(DeserializationError)",
        "is_trap": true,
        "trap_explanation": "Doit retourner une erreur, pas panic"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {
          "type": "string",
          "param_index": 0,
          "params": {
            "min_len": 1,
            "max_len": 20
          }
        }
      ]
    }
  },

  "norm": {
    "allowed_functions": ["HashMap", "serde", "serde_json", "thiserror"],
    "forbidden_functions": ["vector-clock", "causality-crate"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes (minimum 6)

```rust
/* Mutant A (Merge-Min) : Utilise min au lieu de max dans merge */
pub fn merge_mutant_a(&mut self, other: &VectorClock, local_node: &NodeId) {
    for (node, &other_val) in &other.clocks {
        let self_val = self.clocks.entry(node.clone()).or_insert(0);
        // BUG: min au lieu de max
        *self_val = (*self_val).min(other_val);
    }
    self.tick(local_node);
}
// Pourquoi c'est faux : On perd l'information causale des evenements passes
// Ce qui etait pense : "min ou max c'est pareil" -- NON, max preserve la causalite!

/* Mutant B (No-Init) : tick sur noeud inconnu ne l'initialise pas */
pub fn tick_mutant_b(&mut self, node_id: &NodeId) {
    // BUG: Ne cree pas l'entree si elle n'existe pas
    if let Some(counter) = self.clocks.get_mut(node_id) {
        *counter += 1;
    }
    // Sinon... rien!
}
// Pourquoi c'est faux : Le premier tick d'un noeud est ignore
// Ce qui etait pense : "Le noeud doit deja exister" -- NON, tick cree le noeud!

/* Mutant C (Bad-Compare) : happened_before retourne true pour concurrent */
pub fn compare_mutant_c(&self, other: &VectorClock) -> CausalOrder {
    let all_nodes: std::collections::HashSet<_> = self
        .clocks.keys().chain(other.clocks.keys()).collect();

    let mut self_less = false;

    for node in all_nodes {
        let self_val = self.get(node);
        let other_val = other.get(node);
        if self_val < other_val {
            self_less = true;
        }
        // BUG: On ne verifie pas other_less!
    }

    if self_less {
        CausalOrder::Before  // Meme si other a aussi des valeurs plus grandes!
    } else {
        CausalOrder::Equal
    }
}
// Pourquoi c'est faux : Concurrent est classifie comme Before
// Ce qui etait pense : "Si self est inferieur quelque part, c'est Before" -- NON!

/* Mutant D (Missing-Nodes) : compare ignore les noeuds manquants */
pub fn compare_mutant_d(&self, other: &VectorClock) -> CausalOrder {
    // BUG: Ne regarde que les noeuds de self
    let mut self_less = false;
    let mut other_less = false;

    for (node, &self_val) in &self.clocks {
        if let Some(&other_val) = other.clocks.get(node) {
            if self_val < other_val { self_less = true; }
            if other_val < self_val { other_less = true; }
        }
        // Si other n'a pas ce noeud, on l'ignore!
    }

    match (self_less, other_less) {
        (false, false) => CausalOrder::Equal,
        (true, false) => CausalOrder::Before,
        (false, true) => CausalOrder::After,
        (true, true) => CausalOrder::Concurrent,
    }
}
// Pourquoi c'est faux : {A:1} vs {B:1} serait Equal au lieu de Concurrent
// Ce qui etait pense : "On compare seulement les noeuds communs" -- NON!

/* Mutant E (Panic-Deserialize) : from_bytes panic sur erreur */
pub fn from_bytes_mutant_e(bytes: &[u8]) -> Result<Self, ClockError> {
    // BUG: unwrap au lieu de gestion d'erreur
    Ok(serde_json::from_slice(bytes).unwrap())
}
// Pourquoi c'est faux : Panic sur donnees invalides au lieu de retourner Err
// Ce qui etait pense : "Les donnees seront toujours valides" -- NON!

/* Mutant F (No-Tick-After-Merge) : merge n'incremente pas apres */
pub fn merge_mutant_f(&mut self, other: &VectorClock, _local_node: &NodeId) {
    for (node, &other_val) in &other.clocks {
        let self_val = self.clocks.entry(node.clone()).or_insert(0);
        *self_val = (*self_val).max(other_val);
    }
    // BUG: Oubli de self.tick(local_node)!
}
// Pourquoi c'est faux : La reception de message est elle-meme un evenement
// Ce qui etait pense : "Merge suffit" -- NON, recevoir un message = evenement!
```

---

## SECTION 5 : COMPRENDRE (DOCUMENT DE COURS COMPLET)

### 5.1 Ce que cet exercice enseigne

1. **Causalite distribuee** : Comprendre que "temps" != "ordre causal"
2. **Horloges logiques** : Evolution de Lamport timestamps vers Vector Clocks
3. **Evenements concurrents** : Concept fondamental des systemes distribues
4. **Trade-offs** : Taille O(n) vs expressivite de la causalite
5. **Serialisation** : Transport d'etat sur le reseau

### 5.2 LDA -- Traduction Litterale en Francais (MAJUSCULES)

```
STRUCTURE VectorClock QUI CONTIENT :
    - clocks QUI EST UNE TABLE DE HACHAGE NodeId -> Compteur
FIN STRUCTURE

FONCTION tick QUI PREND node_id ET RETOURNE RIEN
DEBUT FONCTION
    SI node_id N'EXISTE PAS DANS clocks ALORS
        CREER UNE ENTREE AVEC VALEUR 0
    FIN SI
    INCREMENTER clocks[node_id] DE 1
FIN FONCTION

FONCTION merge QUI PREND other ET local_node ET RETOURNE RIEN
DEBUT FONCTION
    POUR CHAQUE (node, valeur) DANS other.clocks FAIRE
        SI node N'EXISTE PAS DANS self.clocks ALORS
            CREER UNE ENTREE AVEC VALEUR 0
        FIN SI
        AFFECTER MAX(self.clocks[node], valeur) A self.clocks[node]
    FIN POUR
    APPELER tick AVEC local_node
FIN FONCTION

FONCTION compare QUI PREND other ET RETOURNE CausalOrder
DEBUT FONCTION
    DECLARER self_less = FAUX
    DECLARER other_less = FAUX

    POUR CHAQUE node DANS (self.clocks UNION other.clocks) FAIRE
        SI self.get(node) < other.get(node) ALORS
            self_less = VRAI
        FIN SI
        SI other.get(node) < self.get(node) ALORS
            other_less = VRAI
        FIN SI
    FIN POUR

    SI self_less ET other_less ALORS
        RETOURNER Concurrent
    SINON SI self_less ALORS
        RETOURNER Before
    SINON SI other_less ALORS
        RETOURNER After
    SINON
        RETOURNER Equal
    FIN SI
FIN FONCTION
```

### 5.2.2 Logic Flow (Structured English)

```
ALGORITHM: Vector Clock Comparison
---
1. COLLECT all nodes from both clocks (union of keys)

2. INITIALIZE flags:
   - self_less_somewhere = FALSE
   - other_less_somewhere = FALSE

3. FOR EACH node in all_nodes:
   a. GET self_value (0 if not present)
   b. GET other_value (0 if not present)
   c. IF self_value < other_value:
      SET self_less_somewhere = TRUE
   d. IF other_value < self_value:
      SET other_less_somewhere = TRUE

4. DETERMINE result:
   a. IF self_less AND other_less:
      RETURN Concurrent (incomparable)
   b. IF self_less ONLY:
      RETURN Before (self happened-before other)
   c. IF other_less ONLY:
      RETURN After (other happened-before self)
   d. IF neither:
      RETURN Equal

5. END
```

### 5.2.3 Logique de Garde (Fail Fast)

```
FONCTION : from_bytes (bytes)
---
INIT result = None

1. VERIFIER si bytes est vide :
   |
   |-- RETOURNER Err(DeserializationError("empty input"))

2. ESSAYER de parser JSON :
   |
   |-- SI erreur de parsing :
   |   |-- RETOURNER Err(DeserializationError(error_msg))
   |
   |-- SI succes :
   |   |-- CONTINUER

3. VALIDER la structure :
   |
   |-- SI champs manquants :
   |   |-- RETOURNER Err(InvalidState(...))

4. RETOURNER Ok(VectorClock)
```

### 5.3 Visualisation ASCII

```
Scenario: 3 processus (A, B, C) avec echanges de messages

Temps logique ->

  A: [1,0,0]----[2,0,0]--------[3,2,0]------>
        |           |              ^
        |      (msg1: [2,0,0])     |
        v               \         |
  B: [0,0,0]----[1,1,0]--[2,2,0]--|-------->
                    |             |
               (msg2: [1,1,0])    |
                    \      (msg3: [2,2,0])
                     v            |
  C: [0,0,0]----[1,1,1]----------/
                    ^
                    |
              (received msg2,
               merged, ticked)

Analyse des relations:
- A[1,0,0] happened-before B[2,2,0] ? OUI (1<=2, 0<=2, 0<=0, et 1<2)
- A[2,0,0] happened-before C[1,1,1] ? NON - CONCURRENT!
  (2>1 pour A, mais 0<1 pour B et 0<1 pour C)
- B[2,2,0] happened-before A[3,2,0] ? OUI (2<=3, 2<=2, 0<=0, et 2<3)
```

### 5.4 Les pieges en detail

| Piege | Description | Solution |
|-------|-------------|----------|
| **min vs max** | Utiliser min dans merge | Toujours utiliser max pour preserver la causalite |
| **Oubli tick apres merge** | Ne pas incrementer apres fusion | merge() = max() + tick() |
| **Noeuds manquants** | Ignorer les noeuds absents (= valeur 0) | Traiter absence comme 0 |
| **Concurrent mal detecte** | Confondre avec Before/After | Verifier TOUS les cas |
| **Serialization panic** | unwrap sur from_bytes | Toujours retourner Result |

### 5.5 Cours Complet

#### Qu'est-ce qu'une Horloge Vectorielle ?

Une **horloge vectorielle** est un mecanisme permettant de capturer les relations causales entre evenements dans un systeme distribue, sans necesiter de synchronisation d'horloge physique.

**Intuition :**
Chaque processus maintient un "compteur de ce qu'il sait". Quand il recoit un message, il apprend ce que l'expediteur savait, puis ajoute sa propre connaissance.

**Comparaison avec Lamport Timestamps :**

| Aspect | Lamport | Vector Clock |
|--------|---------|--------------|
| Taille | O(1) | O(n) |
| a->b implique | L(a) < L(b) | VC(a) < VC(b) |
| L(a) < L(b) implique | Peut-etre a->b ou concurrent | - |
| VC(a) < VC(b) implique | - | a->b (garanti!) |
| Detection concurrent | NON | OUI |

#### Proprietes fondamentales

**Theoreme (Fidge-Mattern) :**
> e1 -> e2 ssi VC(e1) < VC(e2)

Cela signifie que les vector clocks capturent EXACTEMENT la relation happened-before.

**Propriete de monotonie :**
Les compteurs ne decroissent jamais. Si VC[i][j] = k a un instant, alors VC[i][j] >= k pour toujours.

#### Complexite des operations

| Operation | Temps | Espace |
|-----------|-------|--------|
| tick | O(1) | - |
| merge | O(n) | - |
| compare | O(n) | - |
| to_bytes | O(n) | O(n) |
| from_bytes | O(n) | O(n) |

Ou n = nombre de noeuds dans le systeme.

### 5.6 Normes avec explications pedagogiques

```
+---------------------------------------------------------------------+
| HORS NORME (compile, mais interdit)                                 |
+---------------------------------------------------------------------+
| fn compare(&self, other: &VectorClock) -> CausalOrder {             |
|     // Comparer seulement les cles de self                          |
|     for (k, v) in &self.clocks { ... }                              |
| }                                                                   |
+---------------------------------------------------------------------+
| CONFORME                                                            |
+---------------------------------------------------------------------+
| fn compare(&self, other: &VectorClock) -> CausalOrder {             |
|     // Union de toutes les cles                                     |
|     let all_keys: HashSet<_> = self.clocks.keys()                   |
|         .chain(other.clocks.keys())                                 |
|         .collect();                                                 |
|     for k in all_keys { ... }                                       |
| }                                                                   |
+---------------------------------------------------------------------+
| POURQUOI ?                                                          |
|                                                                     |
| * Un noeud absent a implicitement la valeur 0                       |
| * Ne pas considerer tous les noeuds = faux resultats                |
| * {A:1} vs {B:1} doit etre Concurrent, pas Equal!                   |
+---------------------------------------------------------------------+
```

### 5.7 Simulation avec trace d'execution

**Scenario : Detection de conflit dans un systeme de fichiers distribue**

```
+-------+-------------------------------------+------------+-------------------+
| Etape | Instruction                         | Clock      | Explication       |
+-------+-------------------------------------+------------+-------------------+
|   1   | Alice: edit file.txt               | A:{A:1}    | Evenement local   |
+-------+-------------------------------------+------------+-------------------+
|   2   | Bob: edit file.txt (concurrent)    | B:{B:1}    | Pas de comm!      |
+-------+-------------------------------------+------------+-------------------+
|   3   | Server recoit de Alice             | S:{A:1,S:1}| merge + tick      |
+-------+-------------------------------------+------------+-------------------+
|   4   | Server recoit de Bob               | Conflit!   | A:{A:1} vs B:{B:1}|
|       |                                     |            | = CONCURRENT      |
+-------+-------------------------------------+------------+-------------------+
|   5   | Server detecte conflit, demande    |            | Reconciliation    |
|       | resolution manuelle                 |            | necessaire        |
+-------+-------------------------------------+------------+-------------------+
```

### 5.8 Mnemoniques (MEME obligatoire)

#### MEME : "The Butterfly Effect -- Chaque tick laisse une trace"

*"Un papillon bat des ailes a Tokyo (tick), et trois semaines plus tard, un ouragan frappe la Floride (effet causal)."*

Comme le Vector Clock :
- **Chaque evenement laisse une trace** : tick() incremente
- **L'information se propage** : merge() lors des messages
- **On peut remonter la causalite** : compare() detecte happened-before

```
        tick A                  merge
           |                      |
  [A:1] ---+---> [A:1] --msg--> [A:1,B:1]
                                  |
                         "Je sais ce que A savait
                          quand il a envoye le message"
```

#### MEME : "You can't escape causality"

```
   +-----------------------------------------------+
   |   "In distributed systems, time is relative,  |
   |    but CAUSALITY is absolute."                |
   |                                               |
   |    - Every systems programmer, eventually     |
   +-----------------------------------------------+

   VC(cause) < VC(effect)  -- TOUJOURS VRAI
   Clock(cause) < Clock(effect) -- Peut-etre faux!
```

### 5.9 Applications pratiques

| Application | Utilisation du Vector Clock |
|-------------|----------------------------|
| **DynamoDB** | Detection de conflits d'ecriture |
| **Riak** | Garantie de causalite pour les lectures |
| **Git** | Detection de branches divergentes |
| **Collaborative editing** | Merge de documents |
| **Event sourcing** | Ordonnancement des events |

---

## SECTION 6 : PIEGES -- RECAPITULATIF

| # | Piege | Impact | Comment l'eviter |
|---|-------|--------|------------------|
| 1 | min au lieu de max | Perte d'info causale | Toujours MAX dans merge |
| 2 | Oubli tick apres merge | Reception non marquee | merge = max + tick |
| 3 | Ignorer noeuds absents | {A:1} vs {B:1} = Equal | Traiter absent comme 0 |
| 4 | Compare incomplet | Concurrent -> Before | Verifier self_less ET other_less |
| 5 | Panic sur deserialize | Crash sur donnees invalides | Retourner Result |
| 6 | Ordre total assume | PartialOrd doit retourner None | Concurrent = None |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la propriete fondamentale des Vector Clocks ?**

A) Ils garantissent une synchronisation parfaite des horloges
B) VC(a) < VC(b) implique que a happened-before b
C) Ils sont plus petits que les Lamport timestamps
D) Ils ne fonctionnent qu'avec 2 processus
E) Le temps physique est capture exactement
F) B et le contraire est aussi vrai (equivalence)
G) Ils eliminent tous les conflits
H) La taille est O(1)
I) Seul le processus local peut incrementer
J) Les compteurs peuvent decroitre

**Reponse : F**

### Question 2
**Que retourne compare() pour {A:1, B:2} vs {A:2, B:1} ?**

A) Before
B) After
C) Equal
D) Concurrent
E) Error
F) Depends on implementation
G) Before ou After selon l'ordre d'appel
H) Equal car meme somme
I) Undefined behavior
J) A et B alternativement

**Reponse : D**

### Question 3
**Que fait merge(&other, &local) exactement ?**

A) Remplace self par other
B) Fait min() de chaque composante
C) Fait max() de chaque composante
D) Fait max() puis incremente local
E) Incremente puis fait max()
F) Additionne les composantes
G) C uniquement
H) Concatene les vecteurs
I) Ne modifie que local
J) Retourne une nouvelle horloge

**Reponse : D**

### Question 4
**Pourquoi les Vector Clocks sont O(n) en espace ?**

A) Pour des raisons de performance
B) Car chaque processus a besoin de son propre compteur
C) C'est une limitation de Rust
D) Pour la serialisation JSON
E) B est la raison fondamentale
F) Pour supporter les timestamps physiques
G) Pour le garbage collection
H) C'est arbitraire
I) Pour la compatibilite avec Lamport
J) Pour le chiffrement

**Reponse : E**

### Question 5
**Que retourne partial_cmp pour deux horloges concurrentes ?**

A) Some(Ordering::Less)
B) Some(Ordering::Greater)
C) Some(Ordering::Equal)
D) None
E) Panic
F) Some(Ordering::Concurrent)
G) Depends on implementation
H) Erreur de compilation
I) D car pas d'ordre total possible
J) C car concurrence = egalite

**Reponse : I**

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Exercice** | 5.4.0-a -- vector_clock |
| **Concept principal** | Vector Clocks & Causal Ordering |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP Base** | 250 |
| **Bonus Fork Detection** | AVANCE (x3 XP) |
| **Bonus ITC** | EXPERT (x4 XP) |
| **Langage** | Rust 2024 |
| **Points cles** | tick, merge, compare, happened_before, serialization |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.4.0-a-vector-clock",
    "generated_at": "2025-01-16 12:00:00",

    "metadata": {
      "exercise_id": "5.4.0-a",
      "exercise_name": "vector_clock",
      "module": "5.4.0",
      "module_name": "Distributed Systems Fundamentals",
      "concept": "a",
      "concept_name": "Vector Clocks & Causal Ordering",
      "type": "complet",
      "tier": 1,
      "tier_info": "Concept isole",
      "phase": 1,
      "difficulty": 6,
      "difficulty_stars": "6/10",
      "language": "rust",
      "language_alt": null,
      "duration_minutes": 90,
      "xp_base": 250,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "bonus_icon": "AVANCE",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["hashmap", "partial_ord", "serde", "distributed-basics"],
      "domains": ["Distributed", "Concurrency", "Serialization"],
      "domains_bonus": ["Advanced-Ordering"],
      "tags": ["distributed", "causality", "vector-clock", "lamport", "happened-before"],
      "meme_reference": "The Butterfly Effect -- causality cannot be escaped"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_merge_min.rs": "/* Section 4.10 */",
      "mutants/mutant_b_no_init.rs": "/* Section 4.10 */",
      "mutants/mutant_c_bad_compare.rs": "/* Section 4.10 */",
      "mutants/mutant_d_missing_nodes.rs": "/* Section 4.10 */",
      "mutants/mutant_e_panic_deserialize.rs": "/* Section 4.10 */",
      "mutants/mutant_f_no_tick_merge.rs": "/* Section 4.10 */",
      "tests/test_suite.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_merge_min.rs",
        "mutants/mutant_b_no_init.rs",
        "mutants/mutant_c_bad_compare.rs",
        "mutants/mutant_d_missing_nodes.rs",
        "mutants/mutant_e_panic_deserialize.rs",
        "mutants/mutant_f_no_tick_merge.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 -- "In distributed systems, you cannot escape causality -- but with Vector Clocks, you can at least track it."*
