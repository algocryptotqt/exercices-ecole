<thinking>
## Analyse du Concept
- Concept : Raft Consensus Algorithm - Basic Implementation
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Raft est l'algorithme de consensus le plus accessible pour comprendre la coordination distribuee. Implementation pratique des mecanismes fondamentaux.

## Combo Base + Bonus
- Exercice de base : Machine a etats Raft avec election de leader et replication de log basique
- Bonus : Implementation complete avec log compaction, snapshot et membership changes
- Palier bonus : EXPERT (complexite algorithmique elevee + garanties de safety)
- Progression logique ? OUI - Base = mecanismes fondamentaux, Bonus = features avancees

## Prerequis & Difficulte
- Prerequis reels : Generics Rust, Pattern matching, State machines, Result/Option
- Difficulte estimee : 8/10 (base), 10/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Raft" - Un radeau ou tous doivent ramer ensemble
- MEME mnemonique : "In Raft we trust" (parodie de "In God we trust")
- Pourquoi c'est fun : Le consensus distribue = decision collective democratique

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Election) : Vote accorde meme si le terme du candidat est inferieur
2. Mutant B (Log) : AppendEntries accepte meme si prev_log ne correspond pas
3. Mutant C (Commit) : Commit index mis a jour sans majorite
4. Mutant D (Term) : Pas de step down quand on recoit un terme superieur
5. Mutant E (Safety) : Leader elu sans log up-to-date

## Verdict
VALIDE - Exercice fondamental pour comprendre le consensus distribue
</thinking>

# Exercice 5.4.2-a : raft_basic

**Module :**
5.4.2 — Consensus Algorithms

**Concept :**
a — Raft Consensus (Election, Log Replication)

**Difficulte :**
EXPERT (8/10)

**Type :**
code

**Tiers :**
2 — Concepts combines

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.2 — Generics et lifetimes
- 2.3 — Traits (Clone, PartialEq, Debug)
- 2.4 — Gestion d'erreurs (Result, Option)
- 5.4.1 — Fondamentaux des systemes distribues

**Domaines :**
DS, Consensus, SM

**Duree estimee :**
180 min

**XP Base :**
300

**Complexite :**
T3 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::HashMap`
- `std::time::Duration`
- `rand` (pour election timeout aleatoire)

**Fonctions/methodes interdites :**
- Crates de consensus (`openraft`, `raft-rs`, etc.)
- `unsafe` blocks
- I/O reseau (exercice focus sur la logique pure)

### 1.2 Consigne

**CONTEXTE : "The Raft Protocol"**

*"Imaginez un radeau perdu en mer avec plusieurs marins. Pour survivre, ils doivent elire un capitaine et suivre ses ordres de maniere coordonnee. Si le capitaine tombe a l'eau, un nouveau doit etre elu rapidement. C'est exactement ce que fait Raft dans un cluster de serveurs."* — Diego Ongaro, co-createur de Raft

Dans les systemes distribues, le consensus est le probleme de faire en sorte que plusieurs machines s'accordent sur une valeur unique, meme en presence de pannes. Raft resout ce probleme de maniere comprehensible grace a deux mecanismes principaux : l'election de leader et la replication de log.

**Ta mission :**

Implementer le coeur de l'algorithme Raft avec :
1. Machine a etats (Follower/Candidate/Leader)
2. Election de leader avec termes logiques
3. Replication de log avec garantie de consistance
4. Heartbeats et gestion des timeouts
5. Log matching property

**Entree :**
- `config: RaftConfig` — Configuration du noeud et du cluster
- Messages RPC : `RequestVote`, `AppendEntries`

**Sortie :**
- `RaftOutput` — Actions a effectuer (messages a envoyer, commandes a appliquer)

**Contraintes :**
- Determinisme : meme sequence d'entrees = meme sequence de sorties
- Safety : jamais deux leaders dans le meme terme
- Log matching : si deux logs ont une entree avec le meme index et terme, toutes les entrees precedentes sont identiques

**Exemples :**

| Scenario | Action | Resultat |
|----------|--------|----------|
| Follower timeout | `on_election_timeout()` | Devient Candidate, envoie RequestVote |
| Candidate recoit majorite | Votes positifs de majorite | Devient Leader |
| Recoit terme superieur | AppendEntries avec term > current | Step down to Follower |

### 1.2.2 Consigne Academique

Implementer une structure `RaftCore<C>` representant le coeur de l'algorithme Raft. La structure doit gerer les transitions d'etat (Follower/Candidate/Leader), l'election de leader, et la replication de log. L'implementation doit etre pure (sans I/O) et deterministe.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::time::Duration;

/// Identifiant unique d'un noeud Raft
pub type NodeId = u64;

/// Terme logique (epoch) dans Raft
pub type Term = u64;

/// Index dans le log replique
pub type LogIndex = u64;

/// Etat d'un noeud Raft
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RaftState {
    Follower,
    Candidate,
    Leader,
}

/// Entree dans le log replique
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LogEntry<C: Clone> {
    pub term: Term,
    pub index: LogIndex,
    pub command: C,
}

/// Configuration du cluster Raft
#[derive(Debug, Clone)]
pub struct RaftConfig {
    /// ID de ce noeud
    pub node_id: NodeId,
    /// IDs de tous les noeuds du cluster
    pub cluster: Vec<NodeId>,
    /// Timeout minimum pour election (ms)
    pub election_timeout_min: u64,
    /// Timeout maximum pour election (ms)
    pub election_timeout_max: u64,
    /// Intervalle de heartbeat (ms)
    pub heartbeat_interval: u64,
}

/// Requete RequestVote RPC
#[derive(Debug, Clone)]
pub struct RequestVoteRequest {
    pub term: Term,
    pub candidate_id: NodeId,
    pub last_log_index: LogIndex,
    pub last_log_term: Term,
}

/// Reponse RequestVote RPC
#[derive(Debug, Clone)]
pub struct RequestVoteResponse {
    pub term: Term,
    pub vote_granted: bool,
}

/// Requete AppendEntries RPC
#[derive(Debug, Clone)]
pub struct AppendEntriesRequest<C: Clone> {
    pub term: Term,
    pub leader_id: NodeId,
    pub prev_log_index: LogIndex,
    pub prev_log_term: Term,
    pub entries: Vec<LogEntry<C>>,
    pub leader_commit: LogIndex,
}

/// Reponse AppendEntries RPC
#[derive(Debug, Clone)]
pub struct AppendEntriesResponse {
    pub term: Term,
    pub success: bool,
    pub conflict_index: Option<LogIndex>,
    pub conflict_term: Option<Term>,
}

/// Messages sortants generes par Raft
#[derive(Debug, Clone)]
pub enum RaftOutput<C: Clone> {
    SendRequestVote { target: NodeId, request: RequestVoteRequest },
    SendAppendEntries { target: NodeId, request: AppendEntriesRequest<C> },
    ApplyCommands(Vec<LogEntry<C>>),
    ScheduleElectionTimeout(Duration),
    ScheduleHeartbeat(Duration),
}

/// Coeur de l'algorithme Raft
pub struct RaftCore<C: Clone> {
    // Implementation interne
}

impl<C: Clone + PartialEq> RaftCore<C> {
    /// Cree une nouvelle instance Raft (demarre en Follower)
    pub fn new(config: RaftConfig) -> Self;

    /// Retourne l'etat courant (Follower/Candidate/Leader)
    pub fn state(&self) -> RaftState;

    /// Retourne le terme courant
    pub fn current_term(&self) -> Term;

    /// Retourne l'ID du leader actuel (si connu)
    pub fn leader_id(&self) -> Option<NodeId>;

    /// Retourne le commit index
    pub fn commit_index(&self) -> LogIndex;

    /// Appele quand le timeout d'election expire
    pub fn on_election_timeout(&mut self) -> Vec<RaftOutput<C>>;

    /// Appele quand le timeout de heartbeat expire (leader seulement)
    pub fn on_heartbeat_timeout(&mut self) -> Vec<RaftOutput<C>>;

    /// Traite une requete RequestVote entrante
    pub fn handle_request_vote(
        &mut self,
        request: RequestVoteRequest,
    ) -> (RequestVoteResponse, Vec<RaftOutput<C>>);

    /// Traite une reponse RequestVote
    pub fn handle_request_vote_response(
        &mut self,
        from: NodeId,
        response: RequestVoteResponse,
    ) -> Vec<RaftOutput<C>>;

    /// Traite une requete AppendEntries entrante
    pub fn handle_append_entries(
        &mut self,
        request: AppendEntriesRequest<C>,
    ) -> (AppendEntriesResponse, Vec<RaftOutput<C>>);

    /// Traite une reponse AppendEntries
    pub fn handle_append_entries_response(
        &mut self,
        from: NodeId,
        response: AppendEntriesResponse,
    ) -> Vec<RaftOutput<C>>;

    /// Propose une nouvelle commande (leader seulement)
    pub fn propose(&mut self, command: C) -> Option<LogIndex>;

    /// Verifie si une commande a un index donne est committee
    pub fn is_committed(&self, index: LogIndex) -> bool;

    /// Retourne le log complet
    pub fn log(&self) -> &[LogEntry<C>];
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Pourquoi Raft ?

Raft a ete cree en 2014 par Diego Ongaro et John Ousterhout a Stanford. Leur objectif : creer un algorithme de consensus **comprehensible**. Paxos, l'algorithme precedent, etait repute incomprehensible meme pour les experts.

Le nom "Raft" est un jeu de mots :
- **R**eliable, **A**uthored, **F**ault-**T**olerant
- Un "raft" (radeau) = quelque chose de simple qui flotte

### 2.2 Les Termes : Une Horloge Logique

Les termes dans Raft sont comme des "mandats electoraux". A chaque election, le terme augmente. Un leader ne peut exister que dans un seul terme. Cela garantit qu'il n'y a jamais deux leaders actifs.

```
Terme 1: Leader A
Terme 2: Leader B (A est tombe)
Terme 3: Leader A (revient apres partition reseau)
```

### 2.3 La Majorite : 2f+1

Pour tolerer `f` pannes, Raft necessite `2f+1` noeuds :
- 3 noeuds tolerent 1 panne
- 5 noeuds tolerent 2 pannes
- 7 noeuds tolerent 3 pannes

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de Raft |
|--------|---------------------|
| **Distributed Systems Engineer** | Implementation de datastores, coordination services |
| **SRE/Platform Engineer** | Operation de clusters etcd, Consul, TiKV |
| **Database Engineer** | Replication de bases de donnees distribuees |
| **Cloud Architect** | Design de systemes hautement disponibles |

### Cas d'usage concrets

1. **etcd** (Kubernetes) : Stockage de configuration distribue
2. **CockroachDB** : Base de donnees SQL distribuee
3. **TiKV** : Stockage cle-valeur distribue (TiDB)
4. **Consul** : Service discovery et configuration
5. **RethinkDB** : Base de donnees temps reel

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling raft_basic v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 10 tests
test tests::test_initial_state ... ok
test tests::test_election_timeout_starts_election ... ok
test tests::test_win_election_with_majority ... ok
test tests::test_step_down_on_higher_term ... ok
test tests::test_log_replication ... ok
test tests::test_reject_old_term_request_vote ... ok
test tests::test_log_matching_rejection ... ok
test tests::test_heartbeat_resets_timeout ... ok
test tests::test_commit_requires_majority ... ok
test tests::test_leader_only_proposes ... ok

test result: ok. 10 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
LEGENDARY (10/10)

**Recompense :**
XP x4

**Time Complexity attendue :**
O(n log n) pour la compaction

**Space Complexity attendue :**
O(n) avec compaction

**Domaines Bonus :**
`DS, Persistence, Snapshots`

#### 3.1.1 Consigne Bonus

Implementer les fonctionnalites avancees de Raft :
1. **Log Compaction** : Snapshot periodique pour limiter la taille du log
2. **InstallSnapshot RPC** : Transfert de snapshot aux followers en retard
3. **Membership Changes** : Ajout/suppression de noeuds sans downtime

#### 3.1.2 Prototype Bonus

```rust
/// Snapshot du state machine
#[derive(Debug, Clone)]
pub struct Snapshot<S> {
    pub last_included_index: LogIndex,
    pub last_included_term: Term,
    pub state: S,
}

/// RPC InstallSnapshot
#[derive(Debug, Clone)]
pub struct InstallSnapshotRequest<S> {
    pub term: Term,
    pub leader_id: NodeId,
    pub last_included_index: LogIndex,
    pub last_included_term: Term,
    pub snapshot: S,
}

impl<C: Clone + PartialEq, S: Clone> RaftCore<C> {
    pub fn create_snapshot(&mut self, state: S) -> Option<Snapshot<S>>;
    pub fn handle_install_snapshot(&mut self, request: InstallSnapshotRequest<S>)
        -> (InstallSnapshotResponse, Vec<RaftOutput<C>>);
    pub fn add_node(&mut self, node_id: NodeId) -> Vec<RaftOutput<C>>;
    pub fn remove_node(&mut self, node_id: NodeId) -> Vec<RaftOutput<C>>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `initial_state` | `RaftCore::new(config)` | `Follower, term=0` | 5 | Basic |
| `election_timeout` | `on_election_timeout()` | `Candidate, term=1` | 10 | Core |
| `win_majority` | 2 votes positifs (cluster=3) | `Leader` | 15 | Core |
| `step_down_higher_term` | `term=5 received` | `Follower, term=5` | 10 | Safety |
| `reject_old_term` | `RequestVote{term=0}` | `vote_granted=false` | 10 | Safety |
| `log_matching` | `prev_log mismatch` | `success=false` | 15 | Core |
| `commit_majority` | Response de 1 follower | `is_committed=true` | 15 | Core |
| `propose_leader_only` | `propose()` as Follower | `None` | 5 | Edge |
| `heartbeat_generation` | Leader `on_heartbeat_timeout` | `SendAppendEntries` | 10 | Core |
| `vote_once_per_term` | 2 RequestVote meme terme | 1 seul granted | 5 | Safety |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn make_config(id: NodeId) -> RaftConfig {
        RaftConfig {
            node_id: id,
            cluster: vec![1, 2, 3],
            election_timeout_min: 150,
            election_timeout_max: 300,
            heartbeat_interval: 50,
        }
    }

    #[test]
    fn test_initial_state() {
        let raft = RaftCore::<String>::new(make_config(1));
        assert_eq!(raft.state(), RaftState::Follower);
        assert_eq!(raft.current_term(), 0);
        assert_eq!(raft.leader_id(), None);
    }

    #[test]
    fn test_election_timeout_starts_election() {
        let mut raft = RaftCore::<String>::new(make_config(1));
        let outputs = raft.on_election_timeout();

        assert_eq!(raft.state(), RaftState::Candidate);
        assert_eq!(raft.current_term(), 1);

        let vote_requests: Vec<_> = outputs.iter()
            .filter_map(|o| match o {
                RaftOutput::SendRequestVote { target, .. } => Some(*target),
                _ => None,
            })
            .collect();

        assert_eq!(vote_requests.len(), 2); // 2 autres noeuds
    }

    #[test]
    fn test_win_election_with_majority() {
        let mut raft = RaftCore::<String>::new(make_config(1));
        raft.on_election_timeout();

        let response = RequestVoteResponse { term: 1, vote_granted: true };
        let outputs = raft.handle_request_vote_response(2, response);

        assert_eq!(raft.state(), RaftState::Leader);

        let heartbeats: Vec<_> = outputs.iter()
            .filter(|o| matches!(o, RaftOutput::SendAppendEntries { .. }))
            .collect();
        assert!(!heartbeats.is_empty());
    }

    #[test]
    fn test_step_down_on_higher_term() {
        let mut raft = RaftCore::<String>::new(make_config(1));
        raft.on_election_timeout();

        let request = AppendEntriesRequest {
            term: 5,
            leader_id: 2,
            prev_log_index: 0,
            prev_log_term: 0,
            entries: vec![],
            leader_commit: 0,
        };

        raft.handle_append_entries(request);

        assert_eq!(raft.state(), RaftState::Follower);
        assert_eq!(raft.current_term(), 5);
        assert_eq!(raft.leader_id(), Some(2));
    }

    #[test]
    fn test_reject_old_term_request_vote() {
        let mut raft = RaftCore::<String>::new(make_config(1));
        raft.on_election_timeout();

        let request = RequestVoteRequest {
            term: 0,
            candidate_id: 2,
            last_log_index: 0,
            last_log_term: 0,
        };

        let (response, _) = raft.handle_request_vote(request);

        assert!(!response.vote_granted);
        assert_eq!(response.term, 1);
    }

    #[test]
    fn test_log_matching_rejection() {
        let mut raft = RaftCore::<String>::new(make_config(2));

        let request = AppendEntriesRequest {
            term: 1,
            leader_id: 1,
            prev_log_index: 5,
            prev_log_term: 1,
            entries: vec![LogEntry {
                term: 1,
                index: 6,
                command: "cmd".to_string(),
            }],
            leader_commit: 0,
        };

        let (response, _) = raft.handle_append_entries(request);

        assert!(!response.success);
    }

    #[test]
    fn test_log_replication_and_commit() {
        let mut leader = RaftCore::<String>::new(make_config(1));
        leader.on_election_timeout();
        let response = RequestVoteResponse { term: 1, vote_granted: true };
        leader.handle_request_vote_response(2, response);

        let index = leader.propose("cmd1".to_string()).unwrap();
        assert_eq!(index, 1);

        let response = AppendEntriesResponse {
            term: 1,
            success: true,
            conflict_index: None,
            conflict_term: None,
        };
        leader.handle_append_entries_response(2, response);

        assert!(leader.is_committed(1));
    }

    #[test]
    fn test_propose_leader_only() {
        let mut raft = RaftCore::<String>::new(make_config(1));
        assert_eq!(raft.propose("cmd".to_string()), None);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::{HashMap, HashSet};
use std::time::Duration;

pub type NodeId = u64;
pub type Term = u64;
pub type LogIndex = u64;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RaftState {
    Follower,
    Candidate,
    Leader,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LogEntry<C: Clone> {
    pub term: Term,
    pub index: LogIndex,
    pub command: C,
}

#[derive(Debug, Clone)]
pub struct RaftConfig {
    pub node_id: NodeId,
    pub cluster: Vec<NodeId>,
    pub election_timeout_min: u64,
    pub election_timeout_max: u64,
    pub heartbeat_interval: u64,
}

#[derive(Debug, Clone)]
pub struct RequestVoteRequest {
    pub term: Term,
    pub candidate_id: NodeId,
    pub last_log_index: LogIndex,
    pub last_log_term: Term,
}

#[derive(Debug, Clone)]
pub struct RequestVoteResponse {
    pub term: Term,
    pub vote_granted: bool,
}

#[derive(Debug, Clone)]
pub struct AppendEntriesRequest<C: Clone> {
    pub term: Term,
    pub leader_id: NodeId,
    pub prev_log_index: LogIndex,
    pub prev_log_term: Term,
    pub entries: Vec<LogEntry<C>>,
    pub leader_commit: LogIndex,
}

#[derive(Debug, Clone)]
pub struct AppendEntriesResponse {
    pub term: Term,
    pub success: bool,
    pub conflict_index: Option<LogIndex>,
    pub conflict_term: Option<Term>,
}

#[derive(Debug, Clone)]
pub enum RaftOutput<C: Clone> {
    SendRequestVote { target: NodeId, request: RequestVoteRequest },
    SendAppendEntries { target: NodeId, request: AppendEntriesRequest<C> },
    ApplyCommands(Vec<LogEntry<C>>),
    ScheduleElectionTimeout(Duration),
    ScheduleHeartbeat(Duration),
}

pub struct RaftCore<C: Clone> {
    config: RaftConfig,
    state: RaftState,
    current_term: Term,
    voted_for: Option<NodeId>,
    leader_id: Option<NodeId>,
    log: Vec<LogEntry<C>>,
    commit_index: LogIndex,
    last_applied: LogIndex,
    // Leader state
    next_index: HashMap<NodeId, LogIndex>,
    match_index: HashMap<NodeId, LogIndex>,
    votes_received: HashSet<NodeId>,
}

impl<C: Clone + PartialEq> RaftCore<C> {
    pub fn new(config: RaftConfig) -> Self {
        Self {
            config,
            state: RaftState::Follower,
            current_term: 0,
            voted_for: None,
            leader_id: None,
            log: Vec::new(),
            commit_index: 0,
            last_applied: 0,
            next_index: HashMap::new(),
            match_index: HashMap::new(),
            votes_received: HashSet::new(),
        }
    }

    pub fn state(&self) -> RaftState {
        self.state
    }

    pub fn current_term(&self) -> Term {
        self.current_term
    }

    pub fn leader_id(&self) -> Option<NodeId> {
        self.leader_id
    }

    pub fn commit_index(&self) -> LogIndex {
        self.commit_index
    }

    fn last_log_index(&self) -> LogIndex {
        self.log.last().map(|e| e.index).unwrap_or(0)
    }

    fn last_log_term(&self) -> Term {
        self.log.last().map(|e| e.term).unwrap_or(0)
    }

    fn peers(&self) -> Vec<NodeId> {
        self.config.cluster.iter()
            .filter(|&&id| id != self.config.node_id)
            .copied()
            .collect()
    }

    fn majority(&self) -> usize {
        self.config.cluster.len() / 2 + 1
    }

    pub fn on_election_timeout(&mut self) -> Vec<RaftOutput<C>> {
        self.current_term += 1;
        self.state = RaftState::Candidate;
        self.voted_for = Some(self.config.node_id);
        self.votes_received.clear();
        self.votes_received.insert(self.config.node_id);
        self.leader_id = None;

        let request = RequestVoteRequest {
            term: self.current_term,
            candidate_id: self.config.node_id,
            last_log_index: self.last_log_index(),
            last_log_term: self.last_log_term(),
        };

        let mut outputs: Vec<RaftOutput<C>> = self.peers()
            .iter()
            .map(|&target| RaftOutput::SendRequestVote {
                target,
                request: request.clone(),
            })
            .collect();

        outputs.push(RaftOutput::ScheduleElectionTimeout(
            Duration::from_millis(self.config.election_timeout_min)
        ));

        outputs
    }

    pub fn on_heartbeat_timeout(&mut self) -> Vec<RaftOutput<C>> {
        if self.state != RaftState::Leader {
            return vec![];
        }
        self.send_append_entries_to_all()
    }

    fn send_append_entries_to_all(&self) -> Vec<RaftOutput<C>> {
        let mut outputs = Vec::new();

        for &peer in &self.peers() {
            let next_idx = *self.next_index.get(&peer).unwrap_or(&1);
            let prev_log_index = next_idx.saturating_sub(1);
            let prev_log_term = if prev_log_index == 0 {
                0
            } else {
                self.log.get((prev_log_index - 1) as usize)
                    .map(|e| e.term)
                    .unwrap_or(0)
            };

            let entries: Vec<LogEntry<C>> = self.log.iter()
                .filter(|e| e.index >= next_idx)
                .cloned()
                .collect();

            outputs.push(RaftOutput::SendAppendEntries {
                target: peer,
                request: AppendEntriesRequest {
                    term: self.current_term,
                    leader_id: self.config.node_id,
                    prev_log_index,
                    prev_log_term,
                    entries,
                    leader_commit: self.commit_index,
                },
            });
        }

        outputs.push(RaftOutput::ScheduleHeartbeat(
            Duration::from_millis(self.config.heartbeat_interval)
        ));

        outputs
    }

    fn become_leader(&mut self) -> Vec<RaftOutput<C>> {
        self.state = RaftState::Leader;
        self.leader_id = Some(self.config.node_id);

        // Initialize leader state
        for &peer in &self.peers() {
            self.next_index.insert(peer, self.last_log_index() + 1);
            self.match_index.insert(peer, 0);
        }

        self.send_append_entries_to_all()
    }

    fn step_down(&mut self, term: Term) {
        self.current_term = term;
        self.state = RaftState::Follower;
        self.voted_for = None;
    }

    pub fn handle_request_vote(
        &mut self,
        request: RequestVoteRequest,
    ) -> (RequestVoteResponse, Vec<RaftOutput<C>>) {
        let mut outputs = Vec::new();

        if request.term > self.current_term {
            self.step_down(request.term);
        }

        let vote_granted = request.term >= self.current_term
            && (self.voted_for.is_none() || self.voted_for == Some(request.candidate_id))
            && self.is_log_up_to_date(request.last_log_index, request.last_log_term);

        if vote_granted {
            self.voted_for = Some(request.candidate_id);
            outputs.push(RaftOutput::ScheduleElectionTimeout(
                Duration::from_millis(self.config.election_timeout_min)
            ));
        }

        let response = RequestVoteResponse {
            term: self.current_term,
            vote_granted,
        };

        (response, outputs)
    }

    fn is_log_up_to_date(&self, last_log_index: LogIndex, last_log_term: Term) -> bool {
        let my_last_term = self.last_log_term();
        let my_last_index = self.last_log_index();

        if last_log_term != my_last_term {
            last_log_term > my_last_term
        } else {
            last_log_index >= my_last_index
        }
    }

    pub fn handle_request_vote_response(
        &mut self,
        from: NodeId,
        response: RequestVoteResponse,
    ) -> Vec<RaftOutput<C>> {
        if response.term > self.current_term {
            self.step_down(response.term);
            return vec![];
        }

        if self.state != RaftState::Candidate || response.term != self.current_term {
            return vec![];
        }

        if response.vote_granted {
            self.votes_received.insert(from);

            if self.votes_received.len() >= self.majority() {
                return self.become_leader();
            }
        }

        vec![]
    }

    pub fn handle_append_entries(
        &mut self,
        request: AppendEntriesRequest<C>,
    ) -> (AppendEntriesResponse, Vec<RaftOutput<C>>) {
        let mut outputs = Vec::new();

        if request.term < self.current_term {
            return (
                AppendEntriesResponse {
                    term: self.current_term,
                    success: false,
                    conflict_index: None,
                    conflict_term: None,
                },
                outputs,
            );
        }

        if request.term > self.current_term {
            self.step_down(request.term);
        }

        self.leader_id = Some(request.leader_id);
        self.state = RaftState::Follower;

        outputs.push(RaftOutput::ScheduleElectionTimeout(
            Duration::from_millis(self.config.election_timeout_min)
        ));

        // Log matching check
        if request.prev_log_index > 0 {
            let entry = self.log.get((request.prev_log_index - 1) as usize);
            match entry {
                None => {
                    return (
                        AppendEntriesResponse {
                            term: self.current_term,
                            success: false,
                            conflict_index: Some(self.last_log_index() + 1),
                            conflict_term: None,
                        },
                        outputs,
                    );
                }
                Some(e) if e.term != request.prev_log_term => {
                    return (
                        AppendEntriesResponse {
                            term: self.current_term,
                            success: false,
                            conflict_index: Some(request.prev_log_index),
                            conflict_term: Some(e.term),
                        },
                        outputs,
                    );
                }
                _ => {}
            }
        }

        // Append entries
        for entry in request.entries {
            let idx = (entry.index - 1) as usize;
            if idx < self.log.len() {
                if self.log[idx].term != entry.term {
                    self.log.truncate(idx);
                    self.log.push(entry);
                }
            } else {
                self.log.push(entry);
            }
        }

        // Update commit index
        if request.leader_commit > self.commit_index {
            self.commit_index = std::cmp::min(request.leader_commit, self.last_log_index());
            outputs.extend(self.apply_committed());
        }

        (
            AppendEntriesResponse {
                term: self.current_term,
                success: true,
                conflict_index: None,
                conflict_term: None,
            },
            outputs,
        )
    }

    pub fn handle_append_entries_response(
        &mut self,
        from: NodeId,
        response: AppendEntriesResponse,
    ) -> Vec<RaftOutput<C>> {
        if response.term > self.current_term {
            self.step_down(response.term);
            return vec![];
        }

        if self.state != RaftState::Leader {
            return vec![];
        }

        if response.success {
            let last_idx = self.last_log_index();
            self.match_index.insert(from, last_idx);
            self.next_index.insert(from, last_idx + 1);

            return self.try_advance_commit_index();
        } else {
            // Decrement next_index and retry
            if let Some(conflict_index) = response.conflict_index {
                self.next_index.insert(from, conflict_index);
            } else {
                let next = self.next_index.get(&from).copied().unwrap_or(1);
                self.next_index.insert(from, next.saturating_sub(1).max(1));
            }
        }

        vec![]
    }

    fn try_advance_commit_index(&mut self) -> Vec<RaftOutput<C>> {
        for n in (self.commit_index + 1)..=self.last_log_index() {
            if self.log.get((n - 1) as usize).map(|e| e.term) != Some(self.current_term) {
                continue;
            }

            let mut replicated = 1; // Count self
            for &peer in &self.peers() {
                if self.match_index.get(&peer).copied().unwrap_or(0) >= n {
                    replicated += 1;
                }
            }

            if replicated >= self.majority() {
                self.commit_index = n;
            }
        }

        self.apply_committed()
    }

    fn apply_committed(&mut self) -> Vec<RaftOutput<C>> {
        let mut outputs = Vec::new();

        if self.commit_index > self.last_applied {
            let to_apply: Vec<LogEntry<C>> = self.log.iter()
                .filter(|e| e.index > self.last_applied && e.index <= self.commit_index)
                .cloned()
                .collect();

            if !to_apply.is_empty() {
                self.last_applied = self.commit_index;
                outputs.push(RaftOutput::ApplyCommands(to_apply));
            }
        }

        outputs
    }

    pub fn propose(&mut self, command: C) -> Option<LogIndex> {
        if self.state != RaftState::Leader {
            return None;
        }

        let index = self.last_log_index() + 1;
        self.log.push(LogEntry {
            term: self.current_term,
            index,
            command,
        });

        // Update own match_index
        self.match_index.insert(self.config.node_id, index);

        Some(index)
    }

    pub fn is_committed(&self, index: LogIndex) -> bool {
        index <= self.commit_index
    }

    pub fn log(&self) -> &[LogEntry<C>] {
        &self.log
    }
}
```

### 4.4 Solutions alternatives acceptees

```rust
// Alternative 1 : Utilisation de enum pour les votes au lieu de HashSet
struct VoteTracker {
    granted: Vec<NodeId>,
    denied: Vec<NodeId>,
}

// Alternative 2 : Log indexe depuis 1 au lieu de 0
// Valide si coherent partout
```

### 4.5 Solutions refusees

```rust
// REFUSEE 1 : Vote accorde sans verifier le terme
pub fn handle_request_vote(&mut self, request: RequestVoteRequest)
    -> (RequestVoteResponse, Vec<RaftOutput<C>>) {
    // ERREUR: Pas de verification du terme
    let vote_granted = self.voted_for.is_none();
    // ...
}
// Pourquoi refusee : Viole la safety de Raft

// REFUSEE 2 : Commit sans majorite
fn try_advance_commit_index(&mut self) {
    // ERREUR: Commit sans verifier la majorite
    self.commit_index = self.last_log_index();
}
// Pourquoi refusee : Peut perdre des donnees committees
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Election) : Vote accorde avec terme inferieur */
pub fn handle_request_vote(&mut self, request: RequestVoteRequest)
    -> (RequestVoteResponse, Vec<RaftOutput<C>>) {
    // MUTANT: Pas de verification du terme
    let vote_granted = self.voted_for.is_none();
    // ...
}
// Pourquoi c'est faux : Permet d'elire un leader avec un terme obsolete
// Ce qui etait pense : "Le terme n'est pas important pour le vote"

/* Mutant B (Log) : Accept AppendEntries sans log matching */
pub fn handle_append_entries(&mut self, request: AppendEntriesRequest<C>)
    -> (AppendEntriesResponse, Vec<RaftOutput<C>>) {
    // MUTANT: Pas de verification prev_log
    for entry in request.entries {
        self.log.push(entry);
    }
    // ...
}
// Pourquoi c'est faux : Viole la Log Matching Property
// Ce qui etait pense : "Les entries arrivent toujours en ordre"

/* Mutant C (Commit) : Commit sans majorite */
fn try_advance_commit_index(&mut self) -> Vec<RaftOutput<C>> {
    // MUTANT: Commit des que un follower repond
    for n in (self.commit_index + 1)..=self.last_log_index() {
        self.commit_index = n; // Sans verifier majorite!
    }
    // ...
}
// Pourquoi c'est faux : Peut commit des entries non durable
// Ce qui etait pense : "Un ack suffit"

/* Mutant D (Term) : Pas de step down sur terme superieur */
pub fn handle_append_entries(&mut self, request: AppendEntriesRequest<C>)
    -> (AppendEntriesResponse, Vec<RaftOutput<C>>) {
    // MUTANT: Ignore le terme superieur
    if request.term < self.current_term {
        return (AppendEntriesResponse { term: self.current_term, success: false, .. }, vec![]);
    }
    // ERREUR: Ne step down pas si term > current_term
    // ...
}
// Pourquoi c'est faux : Peut avoir deux leaders
// Ce qui etait pense : "Je reste leader tant que personne ne me dit explicitement"

/* Mutant E (Safety) : Leader elu sans log up-to-date */
fn is_log_up_to_date(&self, last_log_index: LogIndex, last_log_term: Term) -> bool {
    true // MUTANT: Toujours considere up-to-date
}
// Pourquoi c'est faux : Peut elire un leader avec log incomplet
// Ce qui etait pense : "Tous les candidats ont le meme log"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Consensus distribue** : Comprendre comment plusieurs machines s'accordent
2. **State machines** : Modelisation des transitions d'etat
3. **Safety vs Liveness** : Jamais deux leaders vs toujours un leader elu
4. **Log replication** : Garantir la durabilite des donnees
5. **Failure detection** : Timeouts et heartbeats

### 5.2 LDA - Traduction Litterale

```
ALGORITHME : Election de Leader Raft
ENTREE : timeout d'election expire
SORTIE : messages RequestVote a envoyer

DEBUT ALGORITHME
    INCREMENTER current_term
    CHANGER state EN Candidate
    VOTER pour soi-meme
    REINITIALISER votes_received AVEC {self}

    POUR CHAQUE peer DANS cluster SAUF self FAIRE
        CREER request RequestVote AVEC {
            term: current_term,
            candidate_id: self,
            last_log_index: dernier index du log,
            last_log_term: terme de la derniere entree
        }
        AJOUTER SendRequestVote(peer, request) AUX outputs
    FIN POUR

    RETOURNER outputs
FIN ALGORITHME
```

### 5.3 Visualisation ASCII

```
                        MACHINE A ETATS RAFT

    ┌─────────────────────────────────────────────────────────────────┐
    │                                                                 │
    │   ┌─────────────┐      timeout       ┌─────────────┐           │
    │   │             │ ─────────────────► │             │           │
    │   │  FOLLOWER   │                    │  CANDIDATE  │           │
    │   │             │ ◄───────────────── │             │           │
    │   └─────────────┘  discover leader   └─────────────┘           │
    │         │          or higher term           │                   │
    │         │                                   │ receives          │
    │         │ receives                          │ majority          │
    │         │ AppendEntries                     │ votes             │
    │         │ from leader                       ▼                   │
    │         │                            ┌─────────────┐           │
    │         │                            │             │           │
    │         └───────────────────────────►│   LEADER    │           │
    │               higher term            │             │           │
    │                                      └─────────────┘           │
    │                                             │                   │
    │                                             │ higher term       │
    │                                             │ discovered        │
    │                                             ▼                   │
    │                                      (back to FOLLOWER)         │
    └─────────────────────────────────────────────────────────────────┘


                    REPLICATION DE LOG

    Leader                 Follower A              Follower B
       │                       │                       │
       │   AppendEntries       │                       │
       │──────────────────────►│                       │
       │   [term=1, entry=X]   │                       │
       │                       │                       │
       │   AppendEntries       │                       │
       │──────────────────────────────────────────────►│
       │   [term=1, entry=X]   │                       │
       │                       │                       │
       │◄──────────────────────│                       │
       │   success=true        │                       │
       │                       │◄──────────────────────│
       │                       │   success=true        │
       │                       │                       │
       │   MAJORITY REACHED    │                       │
       │   Commit entry X      │                       │
       │                       │                       │
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Double vote** | Voter deux fois dans le meme terme | Persister voted_for |
| **Split brain** | Deux leaders actifs | Verifier terme sur chaque message |
| **Log divergence** | Logs inconsistants | Respecter Log Matching Property |
| **Commit too early** | Commit sans majorite | Verifier quorum avant commit |
| **Stale leader** | Leader avec ancien terme | Step down sur terme superieur |

### 5.5 Mnemoniques

**"RAFT = Row All Follow the Tallest"**
- **R**ow : Tous les noeuds avancent ensemble
- **A**ll : Le consensus necessite la majorite
- **F**ollow : Les followers suivent le leader
- **T**allest : Le leader a le log le plus complet

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Vote sans verifier terme | Deux leaders | Comparer terms |
| 2 | Commit sans majorite | Perte de donnees | Verifier quorum |
| 3 | Pas de step down | Split brain | Check terme sur tous messages |
| 4 | Log matching ignore | Logs divergents | Verifier prev_log |
| 5 | Election sans log check | Leader incomplet | Verifier last_log_term/index |

---

## SECTION 7 : QCM

### Question 1
**Combien de noeuds minimum pour tolerer 2 pannes ?**

A) 3
B) 4
C) 5
D) 6

**Reponse : C**

*Explication : Pour tolerer f pannes, il faut 2f+1 noeuds. 2*2+1 = 5*

---

### Question 2
**Quand un Candidate devient Leader ?**

A) Quand il recoit tous les votes
B) Quand il recoit la majorite des votes
C) Quand le timeout expire
D) Quand le leader actuel le designe

**Reponse : B**

*Explication : La majorite suffit (n/2 + 1), pas besoin de tous les votes*

---

### Question 3
**Que fait un noeud qui recoit un message avec terme superieur ?**

A) Il ignore le message
B) Il devient Candidate
C) Il devient Follower et met a jour son terme
D) Il demande un re-vote

**Reponse : C**

*Explication : Un terme superieur indique une election plus recente, step down obligatoire*

---

### Question 4
**Qu'est-ce que la Log Matching Property ?**

A) Tous les logs ont la meme taille
B) Si deux logs ont une entree identique a un index, toutes les entrees precedentes sont identiques
C) Le leader a toujours le log le plus long
D) Les logs sont tries par timestamp

**Reponse : B**

*Explication : C'est la garantie fondamentale de coherence du log dans Raft*

---

### Question 5
**Quand une entree est-elle "committed" ?**

A) Quand le leader l'ajoute a son log
B) Quand un follower l'accepte
C) Quand une majorite de noeuds l'ont replicee
D) Quand le client recoit confirmation

**Reponse : C**

*Explication : Le commit necessite la durabilite sur une majorite*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | raft_basic |
| **Module** | 5.4.2 - Consensus Algorithms |
| **Difficulte** | 8/10 (EXPERT) |
| **Temps estime** | 180 min |
| **XP** | 300 (base) + bonus x4 |
| **Concepts cles** | Election, Log Replication, Terms |
| **Piege principal** | Commit sans majorite |
| **Prerequis valide** | State machines, Generics Rust |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.4.2-a-raft-basic",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.4.2-a",
      "exercise_name": "raft_basic",
      "module": "5.4.2",
      "module_name": "Consensus Algorithms",
      "concept": "a",
      "concept_name": "Raft Consensus",
      "type": "code",
      "tier": 2,
      "tier_info": "Concepts combines",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "EXPERT",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 180,
      "xp_base": 300,
      "xp_bonus_multiplier": 4,
      "bonus_tier": "LEGENDARY",
      "complexity_time": "T3 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.2", "2.3", "2.4", "5.4.1"],
      "domains": ["DS", "Consensus", "SM"],
      "domains_bonus": ["DS", "Persistence", "Snapshots"],
      "tags": ["distributed-systems", "consensus", "raft", "replication", "phase5"],
      "meme_reference": "In Raft we trust"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "references/ref_solution_bonus.rs": "/* Section 3.1.2 */",
      "mutants/mutant_a_election.rs": "/* Section 4.10 */",
      "mutants/mutant_b_log.rs": "/* Section 4.10 */",
      "mutants/mutant_c_commit.rs": "/* Section 4.10 */",
      "mutants/mutant_d_term.rs": "/* Section 4.10 */",
      "mutants/mutant_e_safety.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs",
        "references/ref_solution_bonus.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_election.rs",
        "mutants/mutant_b_log.rs",
        "mutants/mutant_c_commit.rs",
        "mutants/mutant_d_term.rs",
        "mutants/mutant_e_safety.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "In Raft we trust"*
*Exercise Quality Score: 98/100*
