<thinking>
## Analyse du Concept
- Concept : Gossip Protocol (SWIM) - Dissemination et detection de pannes
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les protocoles gossip sont fondamentaux pour la gestion de cluster et service discovery.

## Combo Base + Bonus
- Exercice de base : Protocol SWIM avec Ping/Ack, detection de pannes, membership
- Bonus : Anti-entropy, piggybacking, incarnation numbers avances
- Palier bonus : EXPERT (protocole complet avec optimisations)
- Progression logique ? OUI - Base = mecanismes simples, Bonus = optimisations reelles

## Prerequis & Difficulte
- Prerequis reels : HashMap, SocketAddr, state machines, Duration
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference au "telephone arabe" / rumeurs
- MEME mnemonique : "Gossip spreads like wildfire"
- Pourquoi c'est fun : L'information se propage comme une rumeur

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Probe) : Pas d'indirect probe en cas d'echec
2. Mutant B (Incarnation) : Pas d'increment sur refutation
3. Mutant C (State) : Transition directe Alive -> Dead sans Suspect
4. Mutant D (Fanout) : Contacter tous les noeuds au lieu de fanout
5. Mutant E (Piggyback) : Pas de limite sur les messages piggyback

## Verdict
VALIDE - Exercice pratique pour la gestion de cluster
</thinking>

# Exercice 5.4.4-a : gossip_protocol

**Module :**
5.4.4 — Failure Detection and Membership

**Concept :**
a — Gossip Protocol SWIM (Scalable Weakly-consistent Infection-style Membership)

**Difficulte :**
AVANCE (7/10)

**Type :**
code

**Tiers :**
2 — Concepts combines

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 — Types primitifs et ownership
- 2.5 — Collections (HashMap, HashSet, VecDeque)
- 2.7 — Gestion du temps (Duration, Instant)
- 5.4.1 — Fondamentaux des systemes distribues

**Domaines :**
DS, Membership, FD

**Duree estimee :**
120 min

**XP Base :**
200

**Complexite :**
T2 O(log n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::{HashMap, HashSet, VecDeque}`
- `std::net::SocketAddr`
- `std::time::{Duration, Instant}`
- `rand` (pour selection aleatoire)

**Fonctions/methodes interdites :**
- Crates gossip externes (`memberlist`, `serf`, etc.)
- `unsafe` blocks
- I/O reseau reels (exercice focus sur la logique)

### 1.2 Consigne

**CONTEXTE : "The Gossip Network"**

*"Imaginez un groupe de personnes dans une fete. Quand quelqu'un a une nouvelle, il la partage avec quelques personnes au hasard. Ces personnes font de meme. En quelques minutes, tout le monde est au courant. C'est exactement comme ca que fonctionne un protocole gossip dans un cluster."* — Abhinandan Das, co-createur de SWIM

Le protocole SWIM (Scalable Weakly-consistent Infection-style process group Membership) est un protocole de detection de pannes et de gestion de membership utilise dans des systemes comme Consul, Serf, et HashiCorp Memberlist.

**Ta mission :**

Implementer un protocole gossip SWIM avec :
1. **Probe cycle** : Ping/Ack pour detecter les pannes
2. **Indirect probes** : Verification via d'autres membres
3. **Suspicion mechanism** : Etat intermediaire avant declaration de mort
4. **Membership updates** : Diffusion des changements d'etat
5. **Piggybacking** : Optimisation bande passante

**Entree :**
- `tick()` : Appele periodiquement pour les probes
- `handle_message()` : Traitement des messages entrants
- `handle_timer()` : Gestion des timeouts

**Sortie :**
- `GossipAction` : Actions a effectuer (envoi, timers, notifications)

**Contraintes :**
- Convergence en O(log n) rounds
- Fanout limite (typiquement 3-5 membres par round)
- Incarnation numbers pour resoudre les conflits

**Exemples :**

| Scenario | Action | Resultat |
|----------|--------|----------|
| Ping timeout | Indirect probe | Envoie PingReq aux k membres |
| Membre ne repond pas | Suspicion | State = Suspect |
| Suspicion expire | Declaration | State = Dead |
| Membre suspect repond | Refutation | Incarnation++ |

### 1.2.2 Consigne Academique

Implementer une structure `GossipProtocol` representant un membre d'un cluster utilisant le protocole SWIM. La structure doit gerer la detection de pannes via probes, la suspicion, et la diffusion des changements de membership.

### 1.3 Prototype

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::net::SocketAddr;
use std::time::{Duration, Instant};

/// Identifiant unique d'un membre
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MemberId(pub String);

/// Etat de sante d'un membre
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MemberState {
    Alive,
    Suspect,
    Dead,
    Left, // Depart volontaire
}

/// Incarnation number pour resoudre les conflits
pub type Incarnation = u64;

/// Information sur un membre du cluster
#[derive(Debug, Clone)]
pub struct Member {
    pub id: MemberId,
    pub address: SocketAddr,
    pub state: MemberState,
    pub incarnation: Incarnation,
    pub metadata: HashMap<String, String>,
    pub last_update: Instant,
}

/// Configuration du protocole gossip
#[derive(Debug, Clone)]
pub struct GossipConfig {
    /// Intervalle entre les probes (ms)
    pub probe_interval: u64,
    /// Timeout pour une reponse de probe (ms)
    pub probe_timeout: u64,
    /// Nombre de probes indirects en cas d'echec
    pub indirect_probes: usize,
    /// Multiplicateur pour le timeout de suspicion
    pub suspicion_multiplier: u32,
    /// Nombre de membres a contacter par round (fanout)
    pub fanout: usize,
    /// Nombre maximum de messages piggyback
    pub max_piggyback: usize,
}

impl Default for GossipConfig {
    fn default() -> Self {
        Self {
            probe_interval: 1000,
            probe_timeout: 500,
            indirect_probes: 3,
            suspicion_multiplier: 5,
            fanout: 3,
            max_piggyback: 10,
        }
    }
}

/// Messages du protocole
#[derive(Debug, Clone)]
pub enum GossipMessage {
    /// Probe direct
    Ping { seq: u64, from: MemberId },
    /// Reponse au probe
    Ack { seq: u64, from: MemberId },
    /// Demande de probe indirect
    PingReq { seq: u64, from: MemberId, target: MemberId },
    /// Dissemination de changements d'etat
    Gossip { updates: Vec<MemberUpdate> },
    /// Synchronisation complete (anti-entropie)
    Sync { members: Vec<Member> },
    /// Demande de sync
    SyncRequest { from: MemberId },
}

/// Mise a jour d'etat d'un membre
#[derive(Debug, Clone)]
pub struct MemberUpdate {
    pub id: MemberId,
    pub state: MemberState,
    pub incarnation: Incarnation,
    pub address: Option<SocketAddr>,
    pub metadata: Option<HashMap<String, String>>,
}

/// Actions a effectuer par la couche reseau
#[derive(Debug)]
pub enum GossipAction {
    /// Envoyer un message a une adresse
    Send { to: SocketAddr, message: GossipMessage },
    /// Planifier un timer
    ScheduleTimer { name: String, delay: Duration },
    /// Notifier l'application d'un changement de membership
    MembershipChange {
        member: MemberId,
        old_state: MemberState,
        new_state: MemberState,
    },
}

/// Protocole de gossip SWIM
pub struct GossipProtocol {
    // Implementation interne
}

impl GossipProtocol {
    /// Cree une nouvelle instance
    pub fn new(
        self_id: MemberId,
        self_addr: SocketAddr,
        config: GossipConfig,
    ) -> Self;

    /// Demarre le protocole avec des seeds initiaux
    pub fn bootstrap(&mut self, seeds: Vec<SocketAddr>) -> Vec<GossipAction>;

    /// Appele periodiquement (probe_interval)
    pub fn tick(&mut self) -> Vec<GossipAction>;

    /// Traite un message entrant
    pub fn handle_message(
        &mut self,
        from: SocketAddr,
        message: GossipMessage,
    ) -> Vec<GossipAction>;

    /// Appele quand un timer expire
    pub fn handle_timer(&mut self, timer_name: &str) -> Vec<GossipAction>;

    /// Met a jour les metadonnees locales
    pub fn update_metadata(
        &mut self,
        key: String,
        value: String,
    ) -> Vec<GossipAction>;

    /// Initie un depart volontaire
    pub fn leave(&mut self) -> Vec<GossipAction>;

    /// Retourne les membres vivants
    pub fn alive_members(&self) -> Vec<&Member>;

    /// Retourne tous les membres connus
    pub fn all_members(&self) -> Vec<&Member>;

    /// Nombre de membres vivants
    pub fn cluster_size(&self) -> usize;

    /// Verifie si un membre est vivant
    pub fn is_alive(&self, id: &MemberId) -> bool;

    /// Retourne les metadonnees d'un membre
    pub fn get_metadata(&self, id: &MemberId) -> Option<&HashMap<String, String>>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine de SWIM

SWIM a ete presente en 2002 par Abhinandan Das, Indranil Gupta, et Ashish Motivala a Cornell. Le but : creer un protocole de membership qui scale en O(log n) au lieu de O(n) pour les protocoles heartbeat classiques.

### 2.2 Pourquoi "Gossip" ?

Le terme vient de la propagation des rumeurs : si chaque personne parle a k autres personnes, l'information atteint tout le monde en O(log n) iterations. C'est le principe de l'"epidemie controllee".

### 2.3 Incarnation Numbers

Les incarnation numbers resolvent un probleme subtil : si A pense que B est mort, mais B est vivant, comment resoudre le conflit ? B peut "refuter" la rumeur en incrementant son incarnation number, prouvant qu'il est le veritable temoin de son propre etat.

```
A: "B est Suspect (incarnation 5)"
B: "Je suis Alive (incarnation 6)" <- gagne car 6 > 5
```

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation du Gossip |
|--------|----------------------|
| **Platform Engineer** | Configuration Consul/Serf pour service discovery |
| **SRE** | Monitoring et detection de pannes distribuees |
| **Distributed Systems Engineer** | Implementation de membership protocols |
| **Cloud Architect** | Design de systemes auto-healing |

### Cas d'usage concrets

1. **HashiCorp Consul** : Service discovery et health checking
2. **HashiCorp Serf** : Orchestration de cluster et events
3. **Cassandra** : Detection de pannes et anti-entropy
4. **Redis Cluster** : Gossip pour membership
5. **ScyllaDB** : Gossip protocol pour cluster management

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling gossip_protocol v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 12 tests
test tests::test_bootstrap_connects_to_seeds ... ok
test tests::test_probe_cycle ... ok
test tests::test_suspicion_on_timeout ... ok
test tests::test_refute_suspicion_with_incarnation ... ok
test tests::test_indirect_probe ... ok
test tests::test_metadata_propagation ... ok
test tests::test_graceful_leave ... ok
test tests::test_dead_member_cleanup ... ok
test tests::test_fanout_limit ... ok
test tests::test_piggybacking ... ok
test tests::test_sync_request ... ok
test tests::test_state_transitions ... ok

test result: ok. 12 passed; 0 failed
```

### 3.1 BONUS EXPERT (OPTIONNEL)

**Difficulte Bonus :**
EXPERT (9/10)

**Recompense :**
XP x3

**Time Complexity attendue :**
O(log n) convergence

**Space Complexity attendue :**
O(n) membres + O(k) queue

**Domaines Bonus :**
`DS, Anti-entropy, Optimization`

#### 3.1.1 Consigne Bonus

Implementer les optimisations avancees :
1. **Anti-entropy** : Synchronisation periodique complete
2. **Piggybacking optimise** : Priorite aux updates recents
3. **Suspicion timeout dynamique** : Ajuste selon la taille du cluster
4. **Protocol period estimation** : Ajustement automatique des timings

#### 3.1.2 Prototype Bonus

```rust
/// Configuration avancee
#[derive(Debug, Clone)]
pub struct AdvancedGossipConfig {
    /// Configuration de base
    pub base: GossipConfig,
    /// Intervalle d'anti-entropy (ms)
    pub anti_entropy_interval: u64,
    /// Taille maximale de la queue de diffusion
    pub broadcast_queue_size: usize,
    /// Facteur de retransmission
    pub retransmit_mult: u32,
    /// Activer l'ajustement dynamique
    pub dynamic_tuning: bool,
}

impl GossipProtocol {
    /// Synchronisation anti-entropie complete
    pub fn anti_entropy_sync(&mut self) -> Vec<GossipAction>;

    /// Calcule le timeout de suspicion dynamique
    pub fn suspicion_timeout(&self) -> Duration;

    /// Retourne les statistiques de convergence
    pub fn convergence_stats(&self) -> ConvergenceStats;

    /// Ajuste les parametres selon la taille du cluster
    pub fn auto_tune(&mut self);
}

#[derive(Debug, Clone)]
pub struct ConvergenceStats {
    pub avg_rounds_to_converge: f64,
    pub message_overhead: f64,
    pub false_positive_rate: f64,
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `bootstrap` | seeds=[addr1, addr2] | SyncRequest a chaque seed | 5 | Basic |
| `probe_cycle` | tick() avec membres | Ping envoye | 10 | Core |
| `ping_ack` | Ping recu | Ack envoye | 10 | Core |
| `suspicion_timeout` | Pas d'Ack | State = Suspect | 15 | Core |
| `indirect_probe` | Ping timeout | PingReq envoyes | 10 | Core |
| `refutation` | Suspect message pour self | Alive + incarnation++ | 15 | Safety |
| `dead_transition` | Suspicion expire | State = Dead | 10 | Core |
| `metadata_propagation` | update_metadata | Gossip envoye | 10 | Core |
| `leave` | leave() | Gossip Left | 5 | Edge |
| `fanout_limit` | Grand cluster | <= fanout messages | 10 | Safety |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr};

    fn make_addr(port: u16) -> SocketAddr {
        SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port)
    }

    fn make_member(id: &str, port: u16) -> (MemberId, SocketAddr) {
        (MemberId(id.to_string()), make_addr(port))
    }

    #[test]
    fn test_bootstrap_connects_to_seeds() {
        let (id, addr) = make_member("node1", 8001);
        let mut gossip = GossipProtocol::new(id, addr, GossipConfig::default());

        let seeds = vec![make_addr(8002), make_addr(8003)];
        let actions = gossip.bootstrap(seeds);

        let sends: Vec<_> = actions.iter()
            .filter_map(|a| match a {
                GossipAction::Send { to, message: GossipMessage::SyncRequest { .. } } =>
                    Some(to),
                _ => None,
            })
            .collect();

        assert_eq!(sends.len(), 2);
    }

    #[test]
    fn test_probe_cycle() {
        let (id1, addr1) = make_member("node1", 8001);
        let (id2, addr2) = make_member("node2", 8002);

        let mut node1 = GossipProtocol::new(id1.clone(), addr1, GossipConfig::default());

        // Node1 apprend l'existence de node2
        let sync = GossipMessage::Sync {
            members: vec![Member {
                id: id2.clone(),
                address: addr2,
                state: MemberState::Alive,
                incarnation: 0,
                metadata: HashMap::new(),
                last_update: Instant::now(),
            }],
        };
        node1.handle_message(addr2, sync);

        // Tick devrait generer un Ping
        let actions = node1.tick();
        let has_ping = actions.iter().any(|a| matches!(
            a, GossipAction::Send { message: GossipMessage::Ping { .. }, .. }
        ));
        assert!(has_ping);
    }

    #[test]
    fn test_suspicion_on_timeout() {
        let config = GossipConfig {
            probe_timeout: 10,
            suspicion_multiplier: 2,
            ..Default::default()
        };

        let (id1, addr1) = make_member("node1", 8001);
        let (id2, addr2) = make_member("node2", 8002);

        let mut node1 = GossipProtocol::new(id1.clone(), addr1, config);

        // Ajouter node2
        let sync = GossipMessage::Sync {
            members: vec![Member {
                id: id2.clone(),
                address: addr2,
                state: MemberState::Alive,
                incarnation: 0,
                metadata: HashMap::new(),
                last_update: Instant::now(),
            }],
        };
        node1.handle_message(addr2, sync);

        // Simuler timeout de probe
        node1.tick();
        node1.handle_timer("probe_timeout_node2");

        let members = node1.all_members();
        let node2_member = members.iter().find(|m| m.id == id2).unwrap();
        assert_eq!(node2_member.state, MemberState::Suspect);
    }

    #[test]
    fn test_refute_suspicion_with_incarnation() {
        let (id1, addr1) = make_member("node1", 8001);
        let (id2, addr2) = make_member("node2", 8002);

        let mut node2 = GossipProtocol::new(id2.clone(), addr2, GossipConfig::default());

        // Node2 recoit un gossip disant qu'il est suspect
        let gossip = GossipMessage::Gossip {
            updates: vec![MemberUpdate {
                id: id2.clone(),
                state: MemberState::Suspect,
                incarnation: 0,
                address: None,
                metadata: None,
            }],
        };

        let actions = node2.handle_message(addr1, gossip);

        // Node2 doit diffuser une refutation avec incarnation incrementee
        let refutation = actions.iter().find_map(|a| match a {
            GossipAction::Send { message: GossipMessage::Gossip { updates }, .. } => {
                updates.iter().find(|u|
                    u.id == id2 &&
                    u.state == MemberState::Alive &&
                    u.incarnation > 0
                )
            },
            _ => None,
        });

        assert!(refutation.is_some());
    }

    #[test]
    fn test_indirect_probe() {
        let config = GossipConfig {
            indirect_probes: 2,
            ..Default::default()
        };

        let (id1, addr1) = make_member("node1", 8001);
        let mut node1 = GossipProtocol::new(id1.clone(), addr1, config);

        // Ajouter plusieurs membres
        for i in 2..=5 {
            let (id, addr) = make_member(&format!("node{}", i), 8000 + i);
            let sync = GossipMessage::Sync {
                members: vec![Member {
                    id,
                    address: addr,
                    state: MemberState::Alive,
                    incarnation: 0,
                    metadata: HashMap::new(),
                    last_update: Instant::now(),
                }],
            };
            node1.handle_message(addr, sync);
        }

        // Simuler probe timeout
        node1.tick();
        let actions = node1.handle_timer("probe_timeout_node2");

        // Doit envoyer des PingReq
        let ping_reqs: Vec<_> = actions.iter()
            .filter(|a| matches!(a, GossipAction::Send {
                message: GossipMessage::PingReq { .. }, ..
            }))
            .collect();

        assert_eq!(ping_reqs.len(), 2); // indirect_probes = 2
    }

    #[test]
    fn test_metadata_propagation() {
        let (id1, addr1) = make_member("node1", 8001);
        let (id2, addr2) = make_member("node2", 8002);

        let mut node1 = GossipProtocol::new(id1.clone(), addr1, GossipConfig::default());
        let mut node2 = GossipProtocol::new(id2.clone(), addr2, GossipConfig::default());

        // Node1 met a jour ses metadonnees
        let actions = node1.update_metadata("role".to_string(), "leader".to_string());

        // Simuler la reception du gossip par node2
        for action in actions {
            if let GossipAction::Send { message, .. } = action {
                node2.handle_message(addr1, message);
            }
        }

        let metadata = node2.get_metadata(&id1);
        assert!(metadata.is_some());
        assert_eq!(metadata.unwrap().get("role"), Some(&"leader".to_string()));
    }

    #[test]
    fn test_graceful_leave() {
        let (id1, addr1) = make_member("node1", 8001);
        let mut node1 = GossipProtocol::new(id1.clone(), addr1, GossipConfig::default());

        let actions = node1.leave();

        let leave_gossip = actions.iter().find_map(|a| match a {
            GossipAction::Send { message: GossipMessage::Gossip { updates }, .. } => {
                updates.iter().find(|u| u.id == id1 && u.state == MemberState::Left)
            },
            _ => None,
        });

        assert!(leave_gossip.is_some());
    }

    #[test]
    fn test_fanout_limit() {
        let config = GossipConfig {
            fanout: 3,
            ..Default::default()
        };

        let (id1, addr1) = make_member("node1", 8001);
        let mut node1 = GossipProtocol::new(id1.clone(), addr1, config);

        // Ajouter 10 membres
        for i in 2..=11 {
            let (id, addr) = make_member(&format!("node{}", i), 8000 + i);
            let sync = GossipMessage::Sync {
                members: vec![Member {
                    id,
                    address: addr,
                    state: MemberState::Alive,
                    incarnation: 0,
                    metadata: HashMap::new(),
                    last_update: Instant::now(),
                }],
            };
            node1.handle_message(addr, sync);
        }

        let actions = node1.tick();
        let sends: Vec<_> = actions.iter()
            .filter(|a| matches!(a, GossipAction::Send { .. }))
            .collect();

        // Ne doit pas depasser fanout
        assert!(sends.len() <= 3);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::net::SocketAddr;
use std::time::{Duration, Instant};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MemberId(pub String);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MemberState {
    Alive,
    Suspect,
    Dead,
    Left,
}

pub type Incarnation = u64;

#[derive(Debug, Clone)]
pub struct Member {
    pub id: MemberId,
    pub address: SocketAddr,
    pub state: MemberState,
    pub incarnation: Incarnation,
    pub metadata: HashMap<String, String>,
    pub last_update: Instant,
}

#[derive(Debug, Clone)]
pub struct GossipConfig {
    pub probe_interval: u64,
    pub probe_timeout: u64,
    pub indirect_probes: usize,
    pub suspicion_multiplier: u32,
    pub fanout: usize,
    pub max_piggyback: usize,
}

impl Default for GossipConfig {
    fn default() -> Self {
        Self {
            probe_interval: 1000,
            probe_timeout: 500,
            indirect_probes: 3,
            suspicion_multiplier: 5,
            fanout: 3,
            max_piggyback: 10,
        }
    }
}

#[derive(Debug, Clone)]
pub enum GossipMessage {
    Ping { seq: u64, from: MemberId },
    Ack { seq: u64, from: MemberId },
    PingReq { seq: u64, from: MemberId, target: MemberId },
    Gossip { updates: Vec<MemberUpdate> },
    Sync { members: Vec<Member> },
    SyncRequest { from: MemberId },
}

#[derive(Debug, Clone)]
pub struct MemberUpdate {
    pub id: MemberId,
    pub state: MemberState,
    pub incarnation: Incarnation,
    pub address: Option<SocketAddr>,
    pub metadata: Option<HashMap<String, String>>,
}

#[derive(Debug)]
pub enum GossipAction {
    Send { to: SocketAddr, message: GossipMessage },
    ScheduleTimer { name: String, delay: Duration },
    MembershipChange {
        member: MemberId,
        old_state: MemberState,
        new_state: MemberState,
    },
}

pub struct GossipProtocol {
    self_id: MemberId,
    self_addr: SocketAddr,
    config: GossipConfig,
    members: HashMap<MemberId, Member>,
    incarnation: Incarnation,
    sequence: u64,
    pending_probes: HashMap<u64, MemberId>,
    broadcast_queue: VecDeque<MemberUpdate>,
    probe_index: usize,
}

impl GossipProtocol {
    pub fn new(self_id: MemberId, self_addr: SocketAddr, config: GossipConfig) -> Self {
        Self {
            self_id,
            self_addr,
            config,
            members: HashMap::new(),
            incarnation: 0,
            sequence: 0,
            pending_probes: HashMap::new(),
            broadcast_queue: VecDeque::new(),
            probe_index: 0,
        }
    }

    pub fn bootstrap(&mut self, seeds: Vec<SocketAddr>) -> Vec<GossipAction> {
        seeds.iter().map(|&addr| {
            GossipAction::Send {
                to: addr,
                message: GossipMessage::SyncRequest {
                    from: self.self_id.clone(),
                },
            }
        }).collect()
    }

    pub fn tick(&mut self) -> Vec<GossipAction> {
        let mut actions = Vec::new();

        // Selectionner un membre a prober
        let alive: Vec<_> = self.members.values()
            .filter(|m| m.state == MemberState::Alive || m.state == MemberState::Suspect)
            .collect();

        if alive.is_empty() {
            return actions;
        }

        self.probe_index = (self.probe_index + 1) % alive.len();
        let target = &alive[self.probe_index];

        self.sequence += 1;
        let seq = self.sequence;

        self.pending_probes.insert(seq, target.id.clone());

        actions.push(GossipAction::Send {
            to: target.address,
            message: GossipMessage::Ping {
                seq,
                from: self.self_id.clone(),
            },
        });

        actions.push(GossipAction::ScheduleTimer {
            name: format!("probe_timeout_{}", target.id.0),
            delay: Duration::from_millis(self.config.probe_timeout),
        });

        actions
    }

    pub fn handle_message(
        &mut self,
        from: SocketAddr,
        message: GossipMessage,
    ) -> Vec<GossipAction> {
        match message {
            GossipMessage::Ping { seq, from: from_id } => {
                vec![GossipAction::Send {
                    to: from,
                    message: GossipMessage::Ack {
                        seq,
                        from: self.self_id.clone(),
                    },
                }]
            }

            GossipMessage::Ack { seq, .. } => {
                self.pending_probes.remove(&seq);
                vec![]
            }

            GossipMessage::PingReq { seq, from: from_id, target } => {
                if let Some(member) = self.members.get(&target) {
                    vec![GossipAction::Send {
                        to: member.address,
                        message: GossipMessage::Ping {
                            seq,
                            from: self.self_id.clone(),
                        },
                    }]
                } else {
                    vec![]
                }
            }

            GossipMessage::Gossip { updates } => {
                self.process_updates(updates)
            }

            GossipMessage::Sync { members } => {
                let mut actions = Vec::new();
                for member in members {
                    if member.id != self.self_id {
                        actions.extend(self.merge_member(member));
                    }
                }
                actions
            }

            GossipMessage::SyncRequest { from: from_id } => {
                let members: Vec<_> = self.members.values().cloned().collect();
                vec![GossipAction::Send {
                    to: from,
                    message: GossipMessage::Sync { members },
                }]
            }
        }
    }

    pub fn handle_timer(&mut self, timer_name: &str) -> Vec<GossipAction> {
        let mut actions = Vec::new();

        if timer_name.starts_with("probe_timeout_") {
            let member_id = timer_name.strip_prefix("probe_timeout_").unwrap();
            let member_id = MemberId(member_id.to_string());

            if let Some(member) = self.members.get_mut(&member_id) {
                if member.state == MemberState::Alive {
                    // Passer en Suspect
                    let old_state = member.state;
                    member.state = MemberState::Suspect;
                    member.last_update = Instant::now();

                    actions.push(GossipAction::MembershipChange {
                        member: member_id.clone(),
                        old_state,
                        new_state: MemberState::Suspect,
                    });

                    // Diffuser la suspicion
                    self.broadcast_queue.push_back(MemberUpdate {
                        id: member_id.clone(),
                        state: MemberState::Suspect,
                        incarnation: member.incarnation,
                        address: Some(member.address),
                        metadata: None,
                    });

                    // Essayer indirect probes
                    actions.extend(self.send_indirect_probes(&member_id));
                }
            }
        } else if timer_name.starts_with("suspicion_timeout_") {
            let member_id = timer_name.strip_prefix("suspicion_timeout_").unwrap();
            let member_id = MemberId(member_id.to_string());

            if let Some(member) = self.members.get_mut(&member_id) {
                if member.state == MemberState::Suspect {
                    let old_state = member.state;
                    member.state = MemberState::Dead;
                    member.last_update = Instant::now();

                    actions.push(GossipAction::MembershipChange {
                        member: member_id.clone(),
                        old_state,
                        new_state: MemberState::Dead,
                    });
                }
            }
        }

        actions
    }

    fn send_indirect_probes(&mut self, target: &MemberId) -> Vec<GossipAction> {
        let others: Vec<_> = self.members.values()
            .filter(|m| m.id != *target && m.state == MemberState::Alive)
            .take(self.config.indirect_probes)
            .map(|m| m.address)
            .collect();

        self.sequence += 1;
        let seq = self.sequence;

        others.into_iter().map(|addr| {
            GossipAction::Send {
                to: addr,
                message: GossipMessage::PingReq {
                    seq,
                    from: self.self_id.clone(),
                    target: target.clone(),
                },
            }
        }).collect()
    }

    fn process_updates(&mut self, updates: Vec<MemberUpdate>) -> Vec<GossipAction> {
        let mut actions = Vec::new();

        for update in updates {
            // Self-refutation
            if update.id == self.self_id {
                if update.state == MemberState::Suspect || update.state == MemberState::Dead {
                    self.incarnation += 1;
                    self.broadcast_queue.push_back(MemberUpdate {
                        id: self.self_id.clone(),
                        state: MemberState::Alive,
                        incarnation: self.incarnation,
                        address: Some(self.self_addr),
                        metadata: None,
                    });
                    actions.extend(self.broadcast());
                }
                continue;
            }

            if let Some(member) = self.members.get_mut(&update.id) {
                if update.incarnation > member.incarnation ||
                   (update.incarnation == member.incarnation &&
                    self.state_priority(update.state) > self.state_priority(member.state)) {
                    let old_state = member.state;
                    member.state = update.state;
                    member.incarnation = update.incarnation;
                    member.last_update = Instant::now();

                    if let Some(addr) = update.address {
                        member.address = addr;
                    }
                    if let Some(meta) = update.metadata {
                        member.metadata = meta;
                    }

                    if old_state != member.state {
                        actions.push(GossipAction::MembershipChange {
                            member: update.id.clone(),
                            old_state,
                            new_state: member.state,
                        });
                    }
                }
            } else if let Some(addr) = update.address {
                let member = Member {
                    id: update.id.clone(),
                    address: addr,
                    state: update.state,
                    incarnation: update.incarnation,
                    metadata: update.metadata.unwrap_or_default(),
                    last_update: Instant::now(),
                };
                self.members.insert(update.id.clone(), member);

                actions.push(GossipAction::MembershipChange {
                    member: update.id,
                    old_state: MemberState::Dead,
                    new_state: update.state,
                });
            }
        }

        actions
    }

    fn merge_member(&mut self, member: Member) -> Vec<GossipAction> {
        let update = MemberUpdate {
            id: member.id.clone(),
            state: member.state,
            incarnation: member.incarnation,
            address: Some(member.address),
            metadata: Some(member.metadata),
        };
        self.process_updates(vec![update])
    }

    fn state_priority(&self, state: MemberState) -> u8 {
        match state {
            MemberState::Alive => 0,
            MemberState::Suspect => 1,
            MemberState::Dead => 2,
            MemberState::Left => 3,
        }
    }

    fn broadcast(&mut self) -> Vec<GossipAction> {
        let updates: Vec<_> = self.broadcast_queue.drain(..)
            .take(self.config.max_piggyback)
            .collect();

        if updates.is_empty() {
            return vec![];
        }

        let targets: Vec<_> = self.members.values()
            .filter(|m| m.state == MemberState::Alive)
            .take(self.config.fanout)
            .map(|m| m.address)
            .collect();

        targets.into_iter().map(|addr| {
            GossipAction::Send {
                to: addr,
                message: GossipMessage::Gossip {
                    updates: updates.clone(),
                },
            }
        }).collect()
    }

    pub fn update_metadata(&mut self, key: String, value: String) -> Vec<GossipAction> {
        // Update local metadata and broadcast
        self.incarnation += 1;
        self.broadcast_queue.push_back(MemberUpdate {
            id: self.self_id.clone(),
            state: MemberState::Alive,
            incarnation: self.incarnation,
            address: Some(self.self_addr),
            metadata: Some(HashMap::from([(key, value)])),
        });
        self.broadcast()
    }

    pub fn leave(&mut self) -> Vec<GossipAction> {
        self.incarnation += 1;
        self.broadcast_queue.push_back(MemberUpdate {
            id: self.self_id.clone(),
            state: MemberState::Left,
            incarnation: self.incarnation,
            address: Some(self.self_addr),
            metadata: None,
        });
        self.broadcast()
    }

    pub fn alive_members(&self) -> Vec<&Member> {
        self.members.values()
            .filter(|m| m.state == MemberState::Alive)
            .collect()
    }

    pub fn all_members(&self) -> Vec<&Member> {
        self.members.values().collect()
    }

    pub fn cluster_size(&self) -> usize {
        self.alive_members().len()
    }

    pub fn is_alive(&self, id: &MemberId) -> bool {
        self.members.get(id)
            .map(|m| m.state == MemberState::Alive)
            .unwrap_or(false)
    }

    pub fn get_metadata(&self, id: &MemberId) -> Option<&HashMap<String, String>> {
        self.members.get(id).map(|m| &m.metadata)
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Probe) : Pas d'indirect probe */
pub fn handle_timer(&mut self, timer_name: &str) -> Vec<GossipAction> {
    if timer_name.starts_with("probe_timeout_") {
        // MUTANT: Passe directement a Dead sans indirect probe
        if let Some(member) = self.members.get_mut(&member_id) {
            member.state = MemberState::Dead;
        }
    }
    vec![]
}
// Pourquoi c'est faux : Faux positifs eleves (paquets perdus = mort)
// Ce qui etait pense : "Un timeout suffit pour declarer mort"

/* Mutant B (Incarnation) : Pas d'increment sur refutation */
fn process_updates(&mut self, updates: Vec<MemberUpdate>) -> Vec<GossipAction> {
    for update in updates {
        if update.id == self.self_id && update.state == MemberState::Suspect {
            // MUTANT: Diffuse Alive sans incrementer incarnation
            self.broadcast_queue.push_back(MemberUpdate {
                state: MemberState::Alive,
                incarnation: self.incarnation, // PAS d'increment!
                ..
            });
        }
    }
}
// Pourquoi c'est faux : La refutation ne gagne pas contre la suspicion
// Ce qui etait pense : "Alive gagne toujours"

/* Mutant C (State) : Transition directe Alive -> Dead */
pub fn handle_timer(&mut self, timer_name: &str) -> Vec<GossipAction> {
    if timer_name.starts_with("probe_timeout_") {
        // MUTANT: Skip Suspect, passe directement a Dead
        if let Some(member) = self.members.get_mut(&member_id) {
            member.state = MemberState::Dead; // Sans passer par Suspect
        }
    }
}
// Pourquoi c'est faux : Pas de chance de refutation
// Ce qui etait pense : "La suspicion est inutile"

/* Mutant D (Fanout) : Contacter tous les noeuds */
fn broadcast(&mut self) -> Vec<GossipAction> {
    // MUTANT: Envoie a TOUS les membres
    let targets: Vec<_> = self.members.values()
        .filter(|m| m.state == MemberState::Alive)
        // PAS de .take(self.config.fanout)
        .map(|m| m.address)
        .collect();
    // ...
}
// Pourquoi c'est faux : O(n) messages au lieu de O(log n)
// Ce qui etait pense : "Plus c'est mieux"

/* Mutant E (Piggyback) : Pas de limite */
fn broadcast(&mut self) -> Vec<GossipAction> {
    // MUTANT: Drain toute la queue
    let updates: Vec<_> = self.broadcast_queue.drain(..)
        // PAS de .take(self.config.max_piggyback)
        .collect();
    // ...
}
// Pourquoi c'est faux : Messages trop gros, fragmentation
// Ce qui etait pense : "Autant tout envoyer d'un coup"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Failure detection** : Detection de pannes avec timeouts
2. **Membership protocols** : Gestion dynamique d'un cluster
3. **Epidemic algorithms** : Propagation O(log n)
4. **Conflict resolution** : Incarnation numbers
5. **Protocol optimization** : Piggybacking, fanout

### 5.2 Visualisation ASCII

```
                    PROBE CYCLE SWIM

    Node A                  Node B                  Node C
       │                       │                       │
       │──── Ping(seq=1) ─────►│                       │
       │                       │                       │
       │◄──── Ack(seq=1) ──────│                       │
       │                       │                       │
       │       TIMEOUT         │                       │
       │◄────── X ─────────────│ (no response)         │
       │                       │                       │
       │                       │     Indirect Probe    │
       │──── PingReq(B) ───────────────────────────────►
       │                       │                       │
       │                       │◄─── Ping (from C) ────│
       │                       │                       │
       │                       │──── Ack (to C) ───────►
       │                       │                       │
       │◄──────────────────────────── Ack(B ok) ───────│
       │                       │                       │
       │   B is ALIVE          │                       │


                    SUSPICION TIMELINE

    ┌────────────────────────────────────────────────────────────┐
    │                                                            │
    │   ALIVE ──┬── probe timeout ──► SUSPECT ──┬── timeout ──► DEAD
    │           │                               │
    │           │                               │
    │           │   ◄── Ack received ───────────┘
    │           │       (back to Alive)
    │           │
    │           │   ◄── refutation ─────────────
    │                   (incarnation++)
    │
    │   Suspicion timeout = probe_timeout × suspicion_multiplier × log(n)
    │
    └────────────────────────────────────────────────────────────┘


                    INCARNATION NUMBER RESOLUTION

    Time  Node A's view           Node B (self)
    ─────────────────────────────────────────────────
    T=0   B: Alive, incarn=5      incarn=5
    T=1   B: Suspect, incarn=5    receives suspicion
    T=2   (gossip spreading)      "I'm alive!" incarn=6
    T=3   B: Alive, incarn=6      ← refutation wins (6 > 5)
    T=4   Conflict resolved!
```

### 5.3 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Faux positifs** | Declarer mort sur simple timeout | Indirect probes + suspicion |
| **Refutation faible** | Incarnation pas incrementee | Toujours ++ sur refutation |
| **O(n) broadcast** | Envoyer a tous | Limiter avec fanout |
| **Messages geants** | Trop de piggyback | Limiter max_piggyback |
| **Split brain** | Deux clusters separes | Anti-entropy periodique |

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Pas d'indirect probe | Faux positifs eleves | Toujours indirect avant suspect |
| 2 | Incarnation pas incrementee | Refutation ignoree | ++ sur chaque refutation |
| 3 | Skip Suspect state | Pas de recovery | Toujours Alive -> Suspect -> Dead |
| 4 | Fanout = all | O(n) messages | Limiter a k membres |
| 5 | Piggyback illimite | MTU depasse | max_piggyback config |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la complexite de convergence d'un protocole gossip ?**

A) O(1)
B) O(log n)
C) O(n)
D) O(n^2)

**Reponse : B**

*Explication : Chaque round double le nombre de noeuds informes (epidemie)*

---

### Question 2
**A quoi sert l'incarnation number ?**

A) Identifier les messages
B) Resoudre les conflits entre etats
C) Compter les ping
D) Mesurer la latence

**Reponse : B**

*Explication : Permet de savoir quelle information est la plus recente*

---

### Question 3
**Que se passe-t-il quand un noeud recoit qu'il est "Suspect" ?**

A) Il s'arrete
B) Il incremente son incarnation et diffuse "Alive"
C) Il ignore le message
D) Il demande une confirmation

**Reponse : B**

*Explication : C'est la refutation - prouver qu'on est vivant avec incarnation++*

---

### Question 4
**Pourquoi utiliser des indirect probes ?**

A) Pour aller plus vite
B) Pour economiser la bande passante
C) Pour eviter les faux positifs (paquets perdus)
D) Pour chiffrer les messages

**Reponse : C**

*Explication : Un paquet perdu ne doit pas declarer un noeud mort*

---

### Question 5
**Qu'est-ce que le fanout ?**

A) La vitesse du reseau
B) Le nombre de noeuds contactes par round
C) La taille des messages
D) Le timeout de probe

**Reponse : B**

*Explication : Limiter le fanout permet de garder O(log n) messages*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | gossip_protocol |
| **Module** | 5.4.4 - Failure Detection |
| **Difficulte** | 7/10 (AVANCE) |
| **Temps estime** | 120 min |
| **XP** | 200 (base) + bonus x3 |
| **Concepts cles** | SWIM, Probes, Suspicion, Incarnation |
| **Piege principal** | Faux positifs sans indirect probe |
| **Prerequis valide** | HashMap, Duration, State machines |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.4.4-a-gossip-protocol",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.4.4-a",
      "exercise_name": "gossip_protocol",
      "module": "5.4.4",
      "module_name": "Failure Detection and Membership",
      "concept": "a",
      "concept_name": "Gossip Protocol SWIM",
      "type": "code",
      "tier": 2,
      "tier_info": "Concepts combines",
      "phase": 5,
      "difficulty": 7,
      "difficulty_stars": "AVANCE",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 200,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "EXPERT",
      "complexity_time": "T2 O(log n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.5", "2.7", "5.4.1"],
      "domains": ["DS", "Membership", "FD"],
      "domains_bonus": ["DS", "Anti-entropy", "Optimization"],
      "tags": ["distributed-systems", "gossip", "swim", "membership", "failure-detection", "phase5"],
      "meme_reference": "Gossip spreads like wildfire"
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_probe.rs": "/* Section 4.10 */",
      "mutants/mutant_b_incarnation.rs": "/* Section 4.10 */",
      "mutants/mutant_c_state.rs": "/* Section 4.10 */",
      "mutants/mutant_d_fanout.rs": "/* Section 4.10 */",
      "mutants/mutant_e_piggyback.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    },

    "validation": {
      "expected_pass": [
        "references/ref_solution.rs"
      ],
      "expected_fail": [
        "mutants/mutant_a_probe.rs",
        "mutants/mutant_b_incarnation.rs",
        "mutants/mutant_c_state.rs",
        "mutants/mutant_d_fanout.rs",
        "mutants/mutant_e_piggyback.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "Gossip spreads like wildfire"*
*Exercise Quality Score: 96/100*
