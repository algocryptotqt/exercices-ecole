# 5.5.0-a BuildPipeline : CI/CD Configuration Generator

<details>
<summary><strong>HACKBRAIN v5.5.2 - Metadata</strong></summary>

| Propriete | Valeur |
|-----------|--------|
| **Module** | 5.5 - DevOps & Cloud |
| **Exercice** | EX00-a |
| **Titre** | BuildPipeline: CI/CD Configuration Generator |
| **Niveau** | Intermediaire |
| **XP** | 2500 |
| **Duree estimee** | 4-6 heures |
| **Langage** | Rust |
| **Edition** | 2021 |
| **Dependencies** | serde, serde_yaml, serde_json |
| **Prerequis** | 5.4 (Serialization), notions GitHub Actions |
| **Score qualite** | 96/100 |

</details>

---

## Section 1 : Objectifs d'apprentissage

A l'issue de cet exercice, l'etudiant sera capable de :

| ID | Objectif | Niveau Bloom | Validation |
|----|----------|--------------|------------|
| O1 | Comprendre l'architecture d'un pipeline CI/CD moderne | Comprendre | QCM + Code |
| O2 | Modeliser la structure d'un workflow GitHub Actions en types Rust | Appliquer | Implementation |
| O3 | Generer du YAML valide a partir de structures de donnees | Appliquer | Tests YAML |
| O4 | Configurer des matrix builds multi-OS/multi-version | Analyser | Tests matrice |
| O5 | Implementer des strategies de caching pour optimiser les builds | Synthetiser | Tests perf |
| O6 | Integrer des verifications de securite (cargo audit, deny, vet) | Evaluer | Tests securite |
| O7 | Utiliser le pattern Builder pour des configurations flexibles | Appliquer | Tests builder |

---

## Section 2 : Contexte et mise en situation

### Scenario professionnel

Vous rejoignez **RustForge**, une startup developpant des outils CLI en Rust pour l'ecosysteme DevOps. L'equipe maintient actuellement 47 projets open-source, chacun avec sa propre configuration CI/CD copiee-collee et modifiee manuellement.

Le CTO vous confie la mission de creer **BuildPipeline**, un generateur de configurations GitHub Actions qui :
- Standardise les pratiques CI/CD de tous les projets
- Reduit la dette technique liee aux fichiers YAML dupliques
- Integre automatiquement les bonnes pratiques de securite
- Permet une configuration declarative type-safe en Rust

### Contraintes business

- Les configurations generees doivent etre **100% compatibles** GitHub Actions
- Support obligatoire des **matrix builds** (Rust stable/beta/nightly, Linux/Windows/macOS)
- Integration des outils de securite **cargo-audit** et **cargo-deny**
- Optimisation du temps de build via **caching intelligent**
- Generation de workflows **YAML valides** et idiomatiques

---

## Section 3 : Specification technique

### 3.1 Structures de donnees

```rust
// src/lib.rs

use std::collections::HashMap;
use serde::{Serialize, Deserialize};

// ============================================================================
// ENUMERATIONS DE CONFIGURATION
// ============================================================================

/// Version de Rust a cibler dans le pipeline
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RustVersion {
    /// Canal stable - production ready
    Stable,
    /// Canal beta - preview des fonctionnalites
    Beta,
    /// Canal nightly - fonctionnalites experimentales
    Nightly,
    /// Minimum Supported Rust Version - version minimale garantie
    MSRV(String),
}

impl RustVersion {
    /// Convertit la version en string pour le workflow YAML
    ///
    /// # Returns
    /// - "stable", "beta", "nightly" pour les canaux standards
    /// - La version exacte pour MSRV (ex: "1.70.0")
    ///
    /// # Example
    /// ```
    /// use build_pipeline::RustVersion;
    ///
    /// assert_eq!(RustVersion::Stable.to_string(), "stable");
    /// assert_eq!(RustVersion::MSRV("1.70.0".into()).to_string(), "1.70.0");
    /// ```
    pub fn to_string(&self) -> String {
        todo!("Implementer la conversion en string")
    }
}

/// Systeme d'exploitation cible pour les runners GitHub
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TargetOS {
    Ubuntu,
    Windows,
    MacOS,
}

impl TargetOS {
    /// Retourne le label du runner GitHub Actions correspondant
    ///
    /// # Returns
    /// - "ubuntu-latest" pour Ubuntu
    /// - "windows-latest" pour Windows
    /// - "macos-latest" pour MacOS
    ///
    /// # Example
    /// ```
    /// use build_pipeline::TargetOS;
    ///
    /// assert_eq!(TargetOS::Ubuntu.to_runner(), "ubuntu-latest");
    /// ```
    pub fn to_runner(&self) -> &str {
        todo!("Implementer le mapping vers les runners")
    }
}

/// Type de verification de securite a integrer au pipeline
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SecurityCheck {
    /// cargo-audit: Detection des vulnerabilites connues (RustSec)
    CargoAudit,
    /// cargo-deny: Verification licences, sources, duplications
    CargoDeny,
    /// cargo-vet: Audit de la supply chain
    CargoVet,
}

/// Configuration de la documentation generee
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum DocConfig {
    /// Pas de generation de documentation
    None,
    /// cargo doc seulement
    Build,
    /// cargo doc + deploiement GitHub Pages
    BuildAndDeploy,
}

// ============================================================================
// STRUCTURES DE CONFIGURATION AVANCEES
// ============================================================================

/// Configuration des releases automatiques
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReleaseConfig {
    /// Active les releases automatiques sur tag
    pub enabled: bool,
    /// Pattern de tag declencheur (ex: "v*", "release-*")
    pub tag_pattern: String,
    /// Targets de cross-compilation (ex: "x86_64-unknown-linux-gnu")
    pub targets: Vec<String>,
    /// Creer des binaires statiques avec musl
    pub static_binary: bool,
}

/// Configuration du code coverage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CoverageConfig {
    /// Active la mesure du coverage
    pub enabled: bool,
    /// Seuil minimum de coverage requis (0-100)
    pub threshold: Option<u8>,
    /// Upload vers Codecov.io
    pub codecov: bool,
    /// Patterns a exclure du coverage
    pub exclude: Vec<String>,
}

/// Configuration des benchmarks de performance
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BenchmarkConfig {
    /// Active les benchmarks dans le CI
    pub enabled: bool,
    /// Compare avec le baseline de la branche main
    pub compare_baseline: bool,
    /// Seuil d'alerte en pourcentage de regression
    pub alert_threshold: Option<u8>,
}

// ============================================================================
// CONFIGURATION PRINCIPALE DU PIPELINE
// ============================================================================

/// Configuration globale du pipeline CI/CD
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PipelineConfig {
    /// Nom du projet (utilise pour nommer les workflows)
    pub project_name: String,
    /// Versions de Rust a inclure dans la matrice
    pub rust_versions: Vec<RustVersion>,
    /// OS cibles pour la matrice de build
    pub target_os: Vec<TargetOS>,
    /// Verifications de securite a executer
    pub security_checks: Vec<SecurityCheck>,
    /// Configuration de documentation
    pub docs: DocConfig,
    /// Configuration de release (optionnelle)
    pub release: Option<ReleaseConfig>,
    /// Configuration de coverage (optionnelle)
    pub coverage: Option<CoverageConfig>,
    /// Configuration de benchmarks (optionnelle)
    pub benchmarks: Option<BenchmarkConfig>,
    /// Features Cargo a activer pour les tests
    pub features: Vec<String>,
    /// Activer le caching des dependances
    pub enable_cache: bool,
    /// Timeout maximum des jobs en minutes
    pub timeout_minutes: u32,
    /// Branches protegees (declenchent le CI sur PR)
    pub protected_branches: Vec<String>,
}

impl Default for PipelineConfig {
    /// Configuration par defaut minimaliste mais fonctionnelle
    fn default() -> Self {
        Self {
            project_name: "rust-project".to_string(),
            rust_versions: vec![RustVersion::Stable],
            target_os: vec![TargetOS::Ubuntu],
            security_checks: vec![SecurityCheck::CargoAudit],
            docs: DocConfig::Build,
            release: None,
            coverage: None,
            benchmarks: None,
            features: vec![],
            enable_cache: true,
            timeout_minutes: 30,
            protected_branches: vec!["main".to_string()],
        }
    }
}

// ============================================================================
// STRUCTURES DU WORKFLOW GITHUB ACTIONS
// ============================================================================

/// Workflow GitHub Actions complet
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Workflow {
    /// Nom affiche dans l'interface GitHub
    pub name: String,
    /// Triggers du workflow
    #[serde(rename = "on")]
    pub on: WorkflowTrigger,
    /// Variables d'environnement globales
    pub env: HashMap<String, String>,
    /// Jobs du workflow
    pub jobs: HashMap<String, Job>,
}

/// Declencheurs du workflow
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct WorkflowTrigger {
    /// Declenchement sur push
    pub push: Option<BranchFilter>,
    /// Declenchement sur pull request
    pub pull_request: Option<BranchFilter>,
    /// Declenchement sur release
    pub release: Option<ReleaseFilter>,
    /// Declenchement sur schedule (cron)
    pub schedule: Option<Vec<CronSchedule>>,
}

/// Filtre de branches
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BranchFilter {
    pub branches: Vec<String>,
}

/// Filtre pour les releases
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReleaseFilter {
    pub types: Vec<String>,
}

/// Schedule cron
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CronSchedule {
    pub cron: String,
}

/// Job du workflow
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Job {
    /// Nom affiche du job
    pub name: String,
    /// Runner a utiliser
    #[serde(rename = "runs-on")]
    pub runs_on: String,
    /// Dependances vers d'autres jobs
    pub needs: Option<Vec<String>>,
    /// Strategie de matrice
    pub strategy: Option<JobStrategy>,
    /// Timeout en minutes
    #[serde(rename = "timeout-minutes")]
    pub timeout_minutes: Option<u32>,
    /// Etapes du job
    pub steps: Vec<Step>,
    /// Condition d'execution
    #[serde(rename = "if", skip_serializing_if = "Option::is_none")]
    pub condition: Option<String>,
}

/// Strategie de matrice pour un job
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobStrategy {
    /// Definition de la matrice
    pub matrix: HashMap<String, Vec<String>>,
    /// Arreter tous les jobs si un echoue
    #[serde(rename = "fail-fast")]
    pub fail_fast: bool,
}

/// Etape d'un job
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Step {
    /// Nom de l'etape
    pub name: String,
    /// Action a utiliser (ex: "actions/checkout@v4")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uses: Option<String>,
    /// Commande shell a executer
    #[serde(skip_serializing_if = "Option::is_none")]
    pub run: Option<String>,
    /// Parametres de l'action
    #[serde(skip_serializing_if = "Option::is_none")]
    pub with: Option<HashMap<String, String>>,
    /// Variables d'environnement de l'etape
    #[serde(skip_serializing_if = "Option::is_none")]
    pub env: Option<HashMap<String, String>>,
    /// Condition d'execution
    #[serde(rename = "if", skip_serializing_if = "Option::is_none")]
    pub condition: Option<String>,
    /// Identifiant de l'etape (pour references)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
```

### 3.2 Generateur de pipeline

```rust
/// Generateur de workflows GitHub Actions
pub struct PipelineGenerator;

impl PipelineGenerator {
    /// Genere le workflow CI principal
    ///
    /// Ce workflow inclut:
    /// - Job "check": fmt + clippy
    /// - Job "build": compilation avec matrice
    /// - Job "test": execution des tests avec matrice
    /// - Job "coverage": si configure
    /// - Job "benchmark": si configure
    ///
    /// # Arguments
    /// * `config` - Configuration du pipeline
    ///
    /// # Returns
    /// Workflow complet pret a etre serialise en YAML
    ///
    /// # Example
    /// ```
    /// use build_pipeline::{PipelineConfig, PipelineGenerator};
    ///
    /// let config = PipelineConfig::default();
    /// let workflow = PipelineGenerator::generate_ci_workflow(&config);
    ///
    /// assert_eq!(workflow.name, "CI");
    /// assert!(workflow.jobs.contains_key("build"));
    /// ```
    pub fn generate_ci_workflow(config: &PipelineConfig) -> Workflow {
        todo!("Implementer la generation du workflow CI")
    }

    /// Genere le workflow de release
    ///
    /// Declenche sur tags matching le pattern configure.
    /// Inclut la cross-compilation vers les targets specifies.
    ///
    /// # Returns
    /// - Some(Workflow) si release est configure
    /// - None sinon
    pub fn generate_release_workflow(config: &PipelineConfig) -> Option<Workflow> {
        todo!("Implementer la generation du workflow release")
    }

    /// Genere le workflow de security scanning
    ///
    /// Inclut les jobs pour chaque SecurityCheck configure:
    /// - "audit": cargo-audit pour vulnerabilites
    /// - "deny": cargo-deny pour licences/sources
    /// - "vet": cargo-vet pour supply chain
    ///
    /// Execute quotidiennement via cron en plus des triggers standards.
    pub fn generate_security_workflow(config: &PipelineConfig) -> Workflow {
        todo!("Implementer la generation du workflow securite")
    }

    /// Genere le workflow de documentation
    ///
    /// # Returns
    /// - None si DocConfig::None
    /// - Some(Workflow) pour Build ou BuildAndDeploy
    pub fn generate_docs_workflow(config: &PipelineConfig) -> Option<Workflow> {
        todo!("Implementer la generation du workflow docs")
    }

    /// Genere tous les workflows et retourne le YAML
    ///
    /// # Returns
    /// HashMap avec:
    /// - "ci.yml" -> YAML du workflow CI
    /// - "security.yml" -> YAML du workflow securite
    /// - "release.yml" -> YAML du workflow release (si configure)
    /// - "docs.yml" -> YAML du workflow docs (si configure)
    pub fn generate_all(config: &PipelineConfig) -> HashMap<String, String> {
        todo!("Implementer la generation de tous les workflows")
    }

    /// Convertit un workflow en YAML valide
    ///
    /// # Constraints
    /// - Le YAML genere doit etre syntaxiquement valide
    /// - Les cles doivent respecter la convention GitHub Actions
    /// - L'indentation doit etre de 2 espaces
    pub fn to_yaml(workflow: &Workflow) -> String {
        todo!("Implementer la serialisation YAML")
    }
}
```

### 3.3 Builder pattern

```rust
/// Builder pour creer des configurations de pipeline
pub struct PipelineConfigBuilder {
    config: PipelineConfig,
}

impl PipelineConfigBuilder {
    /// Cree un nouveau builder avec le nom du projet
    pub fn new(project_name: impl Into<String>) -> Self {
        todo!("Initialiser le builder")
    }

    /// Ajoute une version de Rust a tester
    pub fn with_rust_version(mut self, version: RustVersion) -> Self {
        todo!("Ajouter une version Rust")
    }

    /// Definit les versions de Rust a tester
    pub fn with_rust_versions(mut self, versions: Vec<RustVersion>) -> Self {
        todo!("Definir les versions Rust")
    }

    /// Ajoute un OS cible
    pub fn with_os(mut self, os: TargetOS) -> Self {
        todo!("Ajouter un OS")
    }

    /// Ajoute tous les OS (Ubuntu, Windows, MacOS)
    pub fn with_all_os(mut self) -> Self {
        todo!("Ajouter tous les OS")
    }

    /// Ajoute une verification de securite
    pub fn with_security_check(mut self, check: SecurityCheck) -> Self {
        todo!("Ajouter un check securite")
    }

    /// Ajoute toutes les verifications de securite
    pub fn with_all_security_checks(mut self) -> Self {
        todo!("Ajouter tous les checks securite")
    }

    /// Configure la documentation
    pub fn with_docs(mut self, docs: DocConfig) -> Self {
        todo!("Configurer la documentation")
    }

    /// Configure les releases automatiques
    pub fn with_release(mut self, release: ReleaseConfig) -> Self {
        todo!("Configurer les releases")
    }

    /// Configure le code coverage
    pub fn with_coverage(mut self, coverage: CoverageConfig) -> Self {
        todo!("Configurer le coverage")
    }

    /// Configure les benchmarks
    pub fn with_benchmarks(mut self, benchmarks: BenchmarkConfig) -> Self {
        todo!("Configurer les benchmarks")
    }

    /// Ajoute une feature Cargo
    pub fn with_feature(mut self, feature: impl Into<String>) -> Self {
        todo!("Ajouter une feature")
    }

    /// Configure le timeout des jobs
    pub fn with_timeout(mut self, minutes: u32) -> Self {
        todo!("Configurer le timeout")
    }

    /// Desactive le cache
    pub fn without_cache(mut self) -> Self {
        todo!("Desactiver le cache")
    }

    /// Construit la configuration finale
    pub fn build(self) -> PipelineConfig {
        todo!("Construire la config")
    }
}
```

---

## Section 4 : Contraintes techniques

### 4.1 Contraintes obligatoires

| ID | Contrainte | Verification |
|----|------------|--------------|
| C1 | Le YAML genere doit etre syntaxiquement valide | Parse avec serde_yaml |
| C2 | Utiliser les actions officielles GitHub (actions/checkout@v4, etc.) | Grep dans output |
| C3 | Le cache doit cibler ~/.cargo et target/ | Verification YAML |
| C4 | Les matrix ne doivent pas avoir de combinaisons redondantes | Test specifique |
| C5 | Les secrets ne doivent jamais apparaitre en clair | Scan output |
| C6 | Timeout configurable avec defaut de 30 minutes | Test config |

### 4.2 Actions GitHub requises

```yaml
# Actions officielles a utiliser
actions/checkout@v4           # Checkout du code
actions/cache@v4              # Cache des dependances
dtolnay/rust-toolchain@stable # Installation Rust
taiki-e/install-action@v2     # Installation outils Cargo
codecov/codecov-action@v4     # Upload coverage (si active)
```

### 4.3 Structure du cache

```yaml
# Configuration cache attendue
- name: Cache cargo registry
  uses: actions/cache@v4
  with:
    path: |
      ~/.cargo/bin/
      ~/.cargo/registry/index/
      ~/.cargo/registry/cache/
      ~/.cargo/git/db/
      target/
    key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    restore-keys: |
      ${{ runner.os }}-cargo-
```

---

## Section 5 : Tests de validation (moulinette)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // TESTS DE CONFIGURATION PAR DEFAUT
    // ========================================================================

    #[test]
    fn test_default_config_creates_valid_workflow() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_ci_workflow(&config);

        assert_eq!(workflow.name, "CI");
        assert!(workflow.jobs.contains_key("build"));
        assert!(workflow.jobs.contains_key("test"));
    }

    #[test]
    fn test_default_config_has_check_job() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_ci_workflow(&config);

        // Le job check doit contenir fmt et clippy
        let check_job = workflow.jobs.get("check");
        assert!(check_job.is_some());

        let steps = &check_job.unwrap().steps;
        let has_fmt = steps.iter().any(|s| {
            s.run.as_ref().map(|r| r.contains("fmt")).unwrap_or(false)
        });
        let has_clippy = steps.iter().any(|s| {
            s.run.as_ref().map(|r| r.contains("clippy")).unwrap_or(false)
        });

        assert!(has_fmt, "Check job must include cargo fmt");
        assert!(has_clippy, "Check job must include cargo clippy");
    }

    // ========================================================================
    // TESTS DE MATRICE
    // ========================================================================

    #[test]
    fn test_matrix_strategy_with_multiple_versions_and_os() {
        let config = PipelineConfigBuilder::new("my-project")
            .with_rust_versions(vec![RustVersion::Stable, RustVersion::Nightly])
            .with_all_os()
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let build_job = workflow.jobs.get("build").unwrap();

        let strategy = build_job.strategy.as_ref().unwrap();
        assert!(strategy.matrix.contains_key("rust"));
        assert!(strategy.matrix.contains_key("os"));
        assert_eq!(strategy.matrix.get("rust").unwrap().len(), 2);
        assert_eq!(strategy.matrix.get("os").unwrap().len(), 3);
    }

    #[test]
    fn test_single_os_no_matrix() {
        let config = PipelineConfigBuilder::new("simple")
            .with_rust_version(RustVersion::Stable)
            .with_os(TargetOS::Ubuntu)
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let build_job = workflow.jobs.get("build").unwrap();

        // Avec un seul OS et une seule version, pas besoin de matrice
        // runs_on doit etre directement "ubuntu-latest"
        assert_eq!(build_job.runs_on, "ubuntu-latest");
    }

    // ========================================================================
    // TESTS DE CACHE
    // ========================================================================

    #[test]
    fn test_cache_configuration_present() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_ci_workflow(&config);

        let build_steps = &workflow.jobs.get("build").unwrap().steps;
        let cache_step = build_steps.iter().find(|s| {
            s.uses.as_ref().map(|u| u.contains("cache")).unwrap_or(false)
        });

        assert!(cache_step.is_some(), "Build job must have cache step");

        let cache = cache_step.unwrap();
        let with = cache.with.as_ref().unwrap();
        assert!(with.contains_key("path"), "Cache must specify path");
        assert!(with.contains_key("key"), "Cache must specify key");
    }

    #[test]
    fn test_cache_disabled() {
        let config = PipelineConfigBuilder::new("no-cache")
            .without_cache()
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let build_steps = &workflow.jobs.get("build").unwrap().steps;

        let cache_step = build_steps.iter().find(|s| {
            s.uses.as_ref().map(|u| u.contains("cache")).unwrap_or(false)
        });

        assert!(cache_step.is_none(), "Cache should be disabled");
    }

    // ========================================================================
    // TESTS DE SECURITE
    // ========================================================================

    #[test]
    fn test_security_workflow_with_all_checks() {
        let config = PipelineConfigBuilder::new("secure-project")
            .with_all_security_checks()
            .build();

        let workflow = PipelineGenerator::generate_security_workflow(&config);

        assert!(workflow.jobs.contains_key("audit"));
        assert!(workflow.jobs.contains_key("deny"));
        assert!(workflow.jobs.contains_key("vet"));
    }

    #[test]
    fn test_security_workflow_has_cron_schedule() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_security_workflow(&config);

        assert!(workflow.on.schedule.is_some());
        let schedule = workflow.on.schedule.as_ref().unwrap();
        assert!(!schedule.is_empty());
    }

    #[test]
    fn test_audit_job_uses_cargo_audit() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_security_workflow(&config);

        let audit_job = workflow.jobs.get("audit").unwrap();
        let audit_step = audit_job.steps.iter().find(|s| {
            s.run.as_ref().map(|r| r.contains("cargo audit")).unwrap_or(false)
        });

        assert!(audit_step.is_some(), "Audit job must run cargo audit");
    }

    // ========================================================================
    // TESTS DE RELEASE
    // ========================================================================

    #[test]
    fn test_release_workflow_generation() {
        let config = PipelineConfigBuilder::new("releasable")
            .with_release(ReleaseConfig {
                enabled: true,
                tag_pattern: "v*".to_string(),
                targets: vec![
                    "x86_64-unknown-linux-gnu".to_string(),
                    "x86_64-pc-windows-msvc".to_string(),
                ],
                static_binary: false,
            })
            .build();

        let workflow = PipelineGenerator::generate_release_workflow(&config).unwrap();

        assert!(workflow.on.release.is_some());
        let build_job = workflow.jobs.get("build-release").unwrap();
        let strategy = build_job.strategy.as_ref().unwrap();
        assert!(strategy.matrix.contains_key("target"));
        assert_eq!(strategy.matrix.get("target").unwrap().len(), 2);
    }

    #[test]
    fn test_release_workflow_none_when_disabled() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_release_workflow(&config);

        assert!(workflow.is_none());
    }

    // ========================================================================
    // TESTS DE COVERAGE
    // ========================================================================

    #[test]
    fn test_coverage_job_generation() {
        let config = PipelineConfigBuilder::new("covered")
            .with_coverage(CoverageConfig {
                enabled: true,
                threshold: Some(80),
                codecov: true,
                exclude: vec!["tests/*".to_string()],
            })
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let coverage_job = workflow.jobs.get("coverage");

        assert!(coverage_job.is_some());

        let steps = &coverage_job.unwrap().steps;
        let coverage_step = steps.iter().find(|s| {
            s.run.as_ref().map(|r| {
                r.contains("tarpaulin") || r.contains("llvm-cov")
            }).unwrap_or(false)
        });

        assert!(coverage_step.is_some());
    }

    #[test]
    fn test_coverage_codecov_upload() {
        let config = PipelineConfigBuilder::new("codecov-test")
            .with_coverage(CoverageConfig {
                enabled: true,
                threshold: None,
                codecov: true,
                exclude: vec![],
            })
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let coverage_job = workflow.jobs.get("coverage").unwrap();

        let codecov_step = coverage_job.steps.iter().find(|s| {
            s.uses.as_ref().map(|u| u.contains("codecov")).unwrap_or(false)
        });

        assert!(codecov_step.is_some());
    }

    // ========================================================================
    // TESTS YAML
    // ========================================================================

    #[test]
    fn test_yaml_output_is_valid() {
        let config = PipelineConfigBuilder::new("yaml-test")
            .with_rust_version(RustVersion::Stable)
            .with_os(TargetOS::Ubuntu)
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let yaml = PipelineGenerator::to_yaml(&workflow);

        assert!(yaml.contains("name:"));
        assert!(yaml.contains("jobs:"));
        assert!(yaml.contains("runs-on:"));
        assert!(yaml.contains("steps:"));

        // Le YAML doit etre parseable
        let parsed: serde_yaml::Value = serde_yaml::from_str(&yaml).unwrap();
        assert!(parsed.get("jobs").is_some());
    }

    #[test]
    fn test_yaml_contains_on_trigger() {
        let config = PipelineConfig::default();
        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let yaml = PipelineGenerator::to_yaml(&workflow);

        // Doit avoir un trigger 'on'
        let parsed: serde_yaml::Value = serde_yaml::from_str(&yaml).unwrap();
        assert!(parsed.get("on").is_some());
    }

    #[test]
    fn test_msrv_appears_in_yaml() {
        let config = PipelineConfigBuilder::new("msrv-test")
            .with_rust_version(RustVersion::MSRV("1.70.0".to_string()))
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let yaml = PipelineGenerator::to_yaml(&workflow);

        assert!(yaml.contains("1.70.0"));
    }

    // ========================================================================
    // TESTS BENCHMARK
    // ========================================================================

    #[test]
    fn test_benchmark_job_generation() {
        let config = PipelineConfigBuilder::new("bench-test")
            .with_benchmarks(BenchmarkConfig {
                enabled: true,
                compare_baseline: true,
                alert_threshold: Some(10),
            })
            .build();

        let workflow = PipelineGenerator::generate_ci_workflow(&config);
        let bench_job = workflow.jobs.get("benchmark");

        assert!(bench_job.is_some());

        let steps = &bench_job.unwrap().steps;
        let bench_step = steps.iter().find(|s| {
            s.run.as_ref().map(|r| r.contains("cargo bench")).unwrap_or(false)
        });

        assert!(bench_step.is_some());
    }

    // ========================================================================
    // TESTS RUST VERSION
    // ========================================================================

    #[test]
    fn test_rust_version_to_string() {
        assert_eq!(RustVersion::Stable.to_string(), "stable");
        assert_eq!(RustVersion::Beta.to_string(), "beta");
        assert_eq!(RustVersion::Nightly.to_string(), "nightly");
        assert_eq!(RustVersion::MSRV("1.70.0".into()).to_string(), "1.70.0");
    }

    // ========================================================================
    // TESTS TARGET OS
    // ========================================================================

    #[test]
    fn test_target_os_to_runner() {
        assert_eq!(TargetOS::Ubuntu.to_runner(), "ubuntu-latest");
        assert_eq!(TargetOS::Windows.to_runner(), "windows-latest");
        assert_eq!(TargetOS::MacOS.to_runner(), "macos-latest");
    }

    // ========================================================================
    // TESTS BUILDER PATTERN
    // ========================================================================

    #[test]
    fn test_builder_chaining() {
        let config = PipelineConfigBuilder::new("chained")
            .with_rust_version(RustVersion::Stable)
            .with_rust_version(RustVersion::Nightly)
            .with_os(TargetOS::Ubuntu)
            .with_os(TargetOS::MacOS)
            .with_feature("serde")
            .with_feature("async")
            .with_timeout(60)
            .build();

        assert_eq!(config.project_name, "chained");
        assert_eq!(config.rust_versions.len(), 2);
        assert_eq!(config.target_os.len(), 2);
        assert_eq!(config.features.len(), 2);
        assert_eq!(config.timeout_minutes, 60);
    }

    // ========================================================================
    // TESTS GENERATE_ALL
    // ========================================================================

    #[test]
    fn test_generate_all_returns_ci_workflow() {
        let config = PipelineConfig::default();
        let workflows = PipelineGenerator::generate_all(&config);

        assert!(workflows.contains_key("ci.yml"));
        assert!(workflows.contains_key("security.yml"));
    }

    #[test]
    fn test_generate_all_includes_release_when_configured() {
        let config = PipelineConfigBuilder::new("with-release")
            .with_release(ReleaseConfig {
                enabled: true,
                tag_pattern: "v*".to_string(),
                targets: vec!["x86_64-unknown-linux-gnu".to_string()],
                static_binary: false,
            })
            .build();

        let workflows = PipelineGenerator::generate_all(&config);

        assert!(workflows.contains_key("release.yml"));
    }
}
```

---

## Section 6 : Tests de mutation (Mutants)

Les mutants suivants doivent etre **detectes** par votre suite de tests :

### Mutant M1 : Cache path incomplet

```rust
// MUTANT: Oubli du repertoire target/ dans le cache
fn generate_cache_step() -> Step {
    Step {
        with: Some(HashMap::from([
            ("path".to_string(), "~/.cargo/bin/\n~/.cargo/registry/".to_string()),
            // MANQUE: target/
        ])),
        ..
    }
}
```

**Detection**: Le test `test_cache_configuration_present` doit verifier que le path contient "target/".

### Mutant M2 : Matrice sans fail-fast

```rust
// MUTANT: fail_fast toujours a true
fn generate_matrix_strategy(config: &PipelineConfig) -> Option<JobStrategy> {
    Some(JobStrategy {
        matrix: build_matrix(config),
        fail_fast: true, // MUTANT: devrait etre configurable ou false par defaut
    })
}
```

**Detection**: Ajouter un test verifiant que `fail_fast` est `false` pour permettre l'execution complete de la matrice.

### Mutant M3 : Runner Windows incorrect

```rust
// MUTANT: Mauvais label de runner
impl TargetOS {
    pub fn to_runner(&self) -> &str {
        match self {
            TargetOS::Ubuntu => "ubuntu-latest",
            TargetOS::Windows => "windows-2022", // MUTANT: devrait etre windows-latest
            TargetOS::MacOS => "macos-latest",
        }
    }
}
```

**Detection**: Le test `test_target_os_to_runner` detecte cette mutation.

### Mutant M4 : Schedule cron manquant pour security

```rust
// MUTANT: Pas de schedule pour le workflow security
pub fn generate_security_workflow(config: &PipelineConfig) -> Workflow {
    Workflow {
        on: WorkflowTrigger {
            push: Some(BranchFilter { branches: vec!["main".into()] }),
            schedule: None, // MUTANT: devrait avoir un cron quotidien
            ..
        },
        ..
    }
}
```

**Detection**: Le test `test_security_workflow_has_cron_schedule` detecte cette mutation.

### Mutant M5 : MSRV non inclus dans le YAML

```rust
// MUTANT: MSRV converti en "stable" au lieu de la version
impl RustVersion {
    pub fn to_string(&self) -> String {
        match self {
            RustVersion::Stable => "stable".into(),
            RustVersion::Beta => "beta".into(),
            RustVersion::Nightly => "nightly".into(),
            RustVersion::MSRV(_) => "stable".into(), // MUTANT: ignore la version
        }
    }
}
```

**Detection**: Le test `test_msrv_appears_in_yaml` detecte cette mutation.

### Mutant M6 : Codecov step absent

```rust
// MUTANT: Oubli de l'upload codecov
fn generate_coverage_job(config: &CoverageConfig) -> Job {
    let mut steps = vec![
        checkout_step(),
        setup_rust_step(),
        run_coverage_step(),
        // MANQUE: codecov_upload_step() quand config.codecov == true
    ];
    // ...
}
```

**Detection**: Le test `test_coverage_codecov_upload` detecte cette mutation.

---

## Section 7 : Exemples d'execution et sorties attendues

### Exemple 1 : Configuration minimale

```rust
fn main() {
    let config = PipelineConfig::default();
    let workflows = PipelineGenerator::generate_all(&config);

    println!("Generated {} workflow files:", workflows.len());
    for (filename, content) in &workflows {
        println!("\n=== {} ===", filename);
        println!("{}", content);
    }
}
```

**Sortie attendue (ci.yml)** :

```yaml
name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: -Dwarnings

jobs:
  check:
    name: Check
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [check]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build
        run: cargo build --release

  test:
    name: Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Run tests
        run: cargo test --all-features
```

### Exemple 2 : Configuration complete avec matrice

```rust
fn main() {
    let config = PipelineConfigBuilder::new("awesome-cli")
        .with_rust_versions(vec![
            RustVersion::MSRV("1.70.0".into()),
            RustVersion::Stable,
            RustVersion::Nightly,
        ])
        .with_all_os()
        .with_all_security_checks()
        .with_coverage(CoverageConfig {
            enabled: true,
            threshold: Some(80),
            codecov: true,
            exclude: vec!["tests/*".into(), "benches/*".into()],
        })
        .with_release(ReleaseConfig {
            enabled: true,
            tag_pattern: "v*".into(),
            targets: vec![
                "x86_64-unknown-linux-gnu".into(),
                "x86_64-unknown-linux-musl".into(),
                "x86_64-apple-darwin".into(),
                "aarch64-apple-darwin".into(),
                "x86_64-pc-windows-msvc".into(),
            ],
            static_binary: true,
        })
        .with_docs(DocConfig::BuildAndDeploy)
        .build();

    let workflows = PipelineGenerator::generate_all(&config);

    for (filename, _) in &workflows {
        println!("Generated: {}", filename);
    }
}
```

**Sortie attendue** :

```
Generated: ci.yml
Generated: security.yml
Generated: release.yml
Generated: docs.yml
```

### Exemple 3 : Sortie security.yml

```yaml
name: Security

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  schedule:
    - cron: '0 0 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install cargo-audit
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-audit

      - name: Run cargo audit
        run: cargo audit

  deny:
    name: Cargo Deny
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install cargo-deny
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-deny

      - name: Run cargo deny
        run: cargo deny check

  vet:
    name: Cargo Vet
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install cargo-vet
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-vet

      - name: Run cargo vet
        run: cargo vet
```

---

## Section 8 : Bloc de reflexion strategique

<thinking>
## Analyse du probleme

### Decomposition des responsabilites

1. **Couche Modele** : Les structures de donnees (enums, configs)
   - Conversion de types (RustVersion -> String, TargetOS -> runner)
   - Serialisation/deserialisation YAML avec serde

2. **Couche Generateur** : La logique de generation des workflows
   - Assemblage des jobs et steps
   - Gestion des conditions (cache active, coverage, etc.)
   - Generation de la matrice

3. **Couche Builder** : Interface fluide pour la configuration
   - Pattern Builder classique avec `self` consuming

### Points critiques d'implementation

#### 1. Serialisation YAML correcte

```rust
// Attention aux noms de champs YAML
#[serde(rename = "runs-on")]     // kebab-case requis
#[serde(rename = "timeout-minutes")]
#[serde(rename = "fail-fast")]
#[serde(skip_serializing_if = "Option::is_none")]  // Eviter les null
```

#### 2. Generation de la matrice conditionnelle

```rust
fn should_use_matrix(config: &PipelineConfig) -> bool {
    config.rust_versions.len() > 1 || config.target_os.len() > 1
}

// Si pas de matrice, utiliser directement runs_on
// Si matrice, utiliser ${{ matrix.os }}
```

#### 3. Gestion des dependances entre jobs

```
check --> build --> test
              \--> coverage (si active)
              \--> benchmark (si actif)
```

#### 4. Template des steps communs

Factoriser les steps repetitifs :
- checkout_step()
- setup_rust_step(version)
- cache_step()

### Erreurs communes a eviter

1. **Oublier les quotes dans le YAML** pour les expressions ${{ }}
2. **Mauvais ordre des jobs** dans le HashMap (utiliser indexmap si ordre important)
3. **Cache key sans Cargo.lock** -> invalidation permanente
4. **Oublier CARGO_TERM_COLOR** -> output illisible dans CI

### Strategie de test

1. Tester chaque enum separement (coverage unitaire)
2. Tester la generation avec config minimale
3. Tester la generation avec config complete
4. Valider le YAML genere avec serde_yaml::from_str
5. Tests de mutation pour les cas limites

### Extensions possibles

- Support GitLab CI
- Support CircleCI
- Templates personnalisables
- Validation du YAML contre le schema GitHub Actions
</thinking>

---

## Section 9 : Fichiers a rendre

```
build_pipeline/
  Cargo.toml
  src/
    lib.rs          # Structures et enums
    generator.rs    # PipelineGenerator
    builder.rs      # PipelineConfigBuilder
    steps.rs        # Fonctions helper pour creer les steps
  tests/
    integration.rs  # Tests d'integration
  examples/
    generate_ci.rs  # Exemple d'utilisation
```

### Cargo.toml requis

```toml
[package]
name = "build_pipeline"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_yaml = "0.9"
serde_json = "1.0"

[dev-dependencies]
pretty_assertions = "1.4"
```

---

## Bareme de notation

| Critere | Points | Details |
|---------|--------|---------|
| Compilation sans erreur | 10 | `cargo build` reussit |
| Tests unitaires passent | 25 | Tous les tests fournis |
| YAML valide genere | 20 | Parse sans erreur |
| Matrice correcte | 15 | Multi-OS, multi-version |
| Cache configure | 10 | Paths corrects, key avec hash |
| Security workflow | 10 | audit, deny, vet + cron |
| Builder pattern | 5 | Chaining fluide |
| Code quality | 5 | clippy, fmt, documentation |
| **Total** | **100** | |

---

## Ressources autorisees

- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [serde_yaml Documentation](https://docs.rs/serde_yaml)
- [Rust Toolchain Action](https://github.com/dtolnay/rust-toolchain)
- [Cargo Audit](https://rustsec.org/)
- [Cargo Deny](https://embarkstudios.github.io/cargo-deny/)

---

<details>
<summary><strong>Indices progressifs (cliquer pour reveler)</strong></summary>

### Indice 1 : Structure de base du Workflow

```rust
impl PipelineGenerator {
    pub fn generate_ci_workflow(config: &PipelineConfig) -> Workflow {
        let mut jobs = HashMap::new();

        // Job check est toujours present
        jobs.insert("check".to_string(), Self::generate_check_job(config));

        // Build et test
        jobs.insert("build".to_string(), Self::generate_build_job(config));
        jobs.insert("test".to_string(), Self::generate_test_job(config));

        // Jobs optionnels
        if let Some(ref coverage) = config.coverage {
            if coverage.enabled {
                jobs.insert("coverage".to_string(), Self::generate_coverage_job(coverage));
            }
        }

        Workflow {
            name: "CI".to_string(),
            on: Self::default_trigger(&config.protected_branches),
            env: Self::default_env(),
            jobs,
        }
    }
}
```

### Indice 2 : Generation de la matrice

```rust
fn generate_matrix(config: &PipelineConfig) -> Option<JobStrategy> {
    let need_matrix = config.rust_versions.len() > 1 || config.target_os.len() > 1;

    if !need_matrix {
        return None;
    }

    let mut matrix = HashMap::new();

    if config.rust_versions.len() > 1 {
        matrix.insert(
            "rust".to_string(),
            config.rust_versions.iter().map(|v| v.to_string()).collect()
        );
    }

    if config.target_os.len() > 1 {
        matrix.insert(
            "os".to_string(),
            config.target_os.iter().map(|os| os.to_runner().to_string()).collect()
        );
    }

    Some(JobStrategy {
        matrix,
        fail_fast: false,
    })
}
```

### Indice 3 : Step de cache

```rust
fn cache_step() -> Step {
    let mut with = HashMap::new();
    with.insert("path".to_string(),
        "~/.cargo/bin/\n~/.cargo/registry/index/\n~/.cargo/registry/cache/\n~/.cargo/git/db/\ntarget/".to_string()
    );
    with.insert("key".to_string(),
        "${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}".to_string()
    );
    with.insert("restore-keys".to_string(),
        "${{ runner.os }}-cargo-".to_string()
    );

    Step {
        name: "Cache cargo".to_string(),
        uses: Some("actions/cache@v4".to_string()),
        with: Some(with),
        run: None,
        env: None,
        condition: None,
        id: None,
    }
}
```

</details>

---

*Exercice genere par HACKBRAIN v5.5.2 - Module DevOps & Cloud*
*Derniere mise a jour: 2025*
