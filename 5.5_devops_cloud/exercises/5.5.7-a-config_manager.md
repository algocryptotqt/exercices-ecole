<thinking>
## Analyse du Concept
- Concept : Config Manager
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La gestion de configuration est essentielle pour les applications cloud-native. L'exercice combine parsing, validation, hot-reload et environnements.

## Combo Base + Bonus
- Exercice de base : Implementation d'un gestionnaire de configuration avec support multi-format et environnements
- Bonus : Implementation d'un systeme de configuration distribuee avec watch et notification de changements
- Palier bonus : AVANCE (consistance distribuee + temps reel)
- Progression logique ? OUI - Base = config statique, Bonus = config dynamique temps reel

## Prerequis & Difficulte
- Prerequis reels : Serde, file I/O, HashMap, Result/Option, generics
- Difficulte estimee : 6/10 (base), 8/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Matrix" - La configuration comme les regles de la Matrix
- MEME mnemonique : "There is no hardcoded value" (everything is configurable)

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Cle vide acceptee
2. Mutant B (Safety) : Override d'environnement ignore
3. Mutant C (Logic) : Type coercion incorrecte (string vers int)
4. Mutant D (Edge) : Fichier inexistant ne retourne pas d'erreur
5. Mutant E (Return) : Default non applique quand valeur absente

## Verdict
VALIDE - Exercice de qualite industrielle couvrant la gestion de configuration
</thinking>

# Exercice 5.5.7-a : config_manager

**Module :**
5.5.7 - Configuration Management

**Concept :**
a - Config Manager (Multi-format, Environment Override, Hot Reload)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
2 - Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 - Types primitifs et ownership
- 2.3 - Traits (Serialize, Deserialize)
- 3.2 - File I/O
- 4.1 - Generics et type system

**Domaines :**
Config, DevOps, Cloud

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::HashMap`
- `std::path::Path`
- `std::env`
- `serde`, `serde_json`, `serde_yaml`, `toml`

**Fonctions/methodes interdites :**
- Crates de configuration (`config`, `figment`)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Configuration Matrix"**

*"Les regles de la Matrix peuvent etre courbees, parfois brisees. Mais d'abord, tu dois les connaitre."* - Morpheus

La configuration est le fondement de toute application deployable. Un bon gestionnaire de configuration supporte plusieurs formats, environnements, et permet des overrides flexibles.

**Ta mission :**

Implementer un `ConfigManager` qui permet de :
1. Charger la configuration depuis plusieurs formats (JSON, YAML, TOML, ENV)
2. Supporter la hierarchie de configuration (default < file < env < override)
3. Valider les valeurs selon un schema
4. Fournir un acces type-safe aux valeurs
5. Supporter le hot-reload des fichiers
6. Gerer les secrets de maniere securisee

**Entree :**
- `config_path: Path` - Chemin vers le fichier de configuration
- `env_prefix: String` - Prefixe pour les variables d'environnement

**Sortie :**
- `ConfigManager` - Gestionnaire de configuration
- `ConfigError` - En cas d'erreur de parsing ou validation

**Contraintes :**
- Les variables d'environnement overrident les fichiers
- Les cles sont case-insensitive pour les env vars
- Le format est detecte automatiquement par extension
- Les valeurs sensibles ne doivent pas etre loggees

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `config.get::<u16>("server.port")` | `Ok(8080)` | Valeur du fichier |
| `config.get::<String>("api.key")` | `Ok("***")` | Masque par defaut |
| `config.get::<bool>("debug")` | `Ok(true)` | Env var override |

### 1.2.2 Consigne Academique

Implementer un gestionnaire de configuration supportant plusieurs formats de fichiers, la hierarchie de sources (fichier, environnement, override), la validation de schema, et l'acces type-safe aux valeurs.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::path::Path;
use serde::{Serialize, Deserialize, de::DeserializeOwned};

/// Format de configuration supporte
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConfigFormat {
    Json,
    Yaml,
    Toml,
    Env,
}

impl ConfigFormat {
    pub fn from_extension(ext: &str) -> Option<Self>;
    pub fn from_path(path: &Path) -> Option<Self>;
}

/// Source de configuration
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum ConfigSource {
    Default,
    File(String),
    Environment,
    Override,
}

/// Valeur de configuration
#[derive(Debug, Clone)]
pub enum ConfigValue {
    Null,
    Bool(bool),
    Integer(i64),
    Float(f64),
    String(String),
    Array(Vec<ConfigValue>),
    Object(HashMap<String, ConfigValue>),
}

impl ConfigValue {
    pub fn as_bool(&self) -> Option<bool>;
    pub fn as_i64(&self) -> Option<i64>;
    pub fn as_f64(&self) -> Option<f64>;
    pub fn as_str(&self) -> Option<&str>;
    pub fn as_array(&self) -> Option<&Vec<ConfigValue>>;
    pub fn as_object(&self) -> Option<&HashMap<String, ConfigValue>>;

    pub fn try_into<T: DeserializeOwned>(self) -> Result<T, ConfigError>;
}

/// Erreur de configuration
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConfigError {
    FileNotFound(String),
    ParseError(String),
    ValidationError(String),
    KeyNotFound(String),
    TypeMismatch { expected: String, got: String },
    IoError(String),
}

/// Options de chargement
#[derive(Debug, Clone)]
pub struct LoadOptions {
    pub env_prefix: Option<String>,
    pub env_separator: String,
    pub required_keys: Vec<String>,
    pub sensitive_keys: Vec<String>,
    pub defaults: HashMap<String, ConfigValue>,
}

impl Default for LoadOptions {
    fn default() -> Self {
        Self {
            env_prefix: None,
            env_separator: "__".to_string(),
            required_keys: Vec::new(),
            sensitive_keys: vec!["password".to_string(), "secret".to_string(), "key".to_string(), "token".to_string()],
            defaults: HashMap::new(),
        }
    }
}

/// Configuration chargee
#[derive(Debug, Clone)]
pub struct Config {
    values: HashMap<String, ConfigValue>,
    sources: HashMap<String, ConfigSource>,
    sensitive_keys: Vec<String>,
}

impl Config {
    /// Recupere une valeur avec conversion de type
    pub fn get<T: DeserializeOwned>(&self, key: &str) -> Result<T, ConfigError>;

    /// Recupere une valeur avec default
    pub fn get_or<T: DeserializeOwned>(&self, key: &str, default: T) -> T;

    /// Recupere une valeur optionnelle
    pub fn get_opt<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>, ConfigError>;

    /// Verifie si une cle existe
    pub fn contains(&self, key: &str) -> bool;

    /// Retourne la source d'une valeur
    pub fn source_of(&self, key: &str) -> Option<&ConfigSource>;

    /// Liste toutes les cles
    pub fn keys(&self) -> Vec<String>;

    /// Merge avec une autre config
    pub fn merge(&mut self, other: Config);

    /// Affiche la config (masque les valeurs sensibles)
    pub fn display_safe(&self) -> String;
}

/// Gestionnaire de configuration
pub struct ConfigManager {
    config: Config,
    options: LoadOptions,
    file_path: Option<String>,
}

impl ConfigManager {
    pub fn new() -> Self;

    /// Charge depuis un fichier
    pub fn load_file(&mut self, path: impl AsRef<Path>) -> Result<(), ConfigError>;

    /// Charge depuis une chaine
    pub fn load_str(&mut self, content: &str, format: ConfigFormat) -> Result<(), ConfigError>;

    /// Charge les variables d'environnement
    pub fn load_env(&mut self) -> Result<(), ConfigError>;

    /// Ajoute un override
    pub fn set(&mut self, key: impl Into<String>, value: ConfigValue);

    /// Configure les options
    pub fn with_options(self, options: LoadOptions) -> Self;

    /// Valide la configuration
    pub fn validate(&self) -> Result<(), ConfigError>;

    /// Retourne la configuration
    pub fn config(&self) -> &Config;

    /// Recharge depuis le fichier
    pub fn reload(&mut self) -> Result<(), ConfigError>;
}

impl Default for ConfigManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Builder pattern pour configuration
pub struct ConfigBuilder {
    manager: ConfigManager,
}

impl ConfigBuilder {
    pub fn new() -> Self;

    pub fn with_file(self, path: impl AsRef<Path>) -> Result<Self, ConfigError>;
    pub fn with_env(self) -> Self;
    pub fn with_env_prefix(self, prefix: impl Into<String>) -> Self;
    pub fn with_default<T: Serialize>(self, key: impl Into<String>, value: T) -> Self;
    pub fn with_required(self, key: impl Into<String>) -> Self;
    pub fn with_sensitive(self, key: impl Into<String>) -> Self;

    pub fn build(self) -> Result<Config, ConfigError>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 The Twelve-Factor App

Le manifeste Twelve-Factor App recommande de stocker la configuration dans l'environnement. Cela permet de separer le code de la configuration et facilite le deploiement dans differents environnements.

### 2.2 Configuration Hierarchy

La hierarchie typique de configuration (du moins au plus prioritaire) :
1. Valeurs par defaut dans le code
2. Fichiers de configuration
3. Variables d'environnement
4. Arguments de ligne de commande
5. Overrides runtime

### 2.3 Secrets Management

Les secrets ne doivent jamais etre stockes en clair dans les fichiers de configuration commites. Utilisez des outils comme HashiCorp Vault, AWS Secrets Manager, ou des variables d'environnement injectees au runtime.

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation de la configuration |
|--------|----------------------------------|
| **DevOps Engineer** | Configuration des deployments, secrets management |
| **SRE** | Feature flags, circuit breakers, tuning |
| **Backend Developer** | Configuration applicative, connexions DB |
| **Platform Engineer** | Configuration infrastructure, templates |

### Cas d'usage concrets

1. **Kubernetes ConfigMaps** : Configuration montee en volume ou injectee en env
2. **AWS Parameter Store** : Configuration hierarchique avec chiffrement
3. **HashiCorp Consul** : Configuration distribuee avec watch

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cat config.yaml
server:
  host: "0.0.0.0"
  port: 8080
database:
  url: "postgres://localhost/db"
  pool_size: 10
features:
  enable_cache: true

$ APP_DATABASE__POOL_SIZE=20 cargo run
Config loaded:
  server.host: "0.0.0.0" (source: File)
  server.port: 8080 (source: File)
  database.url: "***" (source: File, sensitive)
  database.pool_size: 20 (source: Environment)
  features.enable_cache: true (source: File)
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
8/10

**Recompense :**
XP x3

#### 3.1.1 Consigne Bonus

Implementer un systeme de **configuration distribuee** avec :
1. Watch de fichiers pour hot-reload
2. Notification des changements via callbacks
3. Validation de schema JSON
4. Support des templates (${VAR} expansion)

#### 3.1.2 Prototype Bonus

```rust
pub trait ConfigWatcher: Send + Sync {
    fn on_change(&self, key: &str, old: Option<&ConfigValue>, new: &ConfigValue);
}

pub struct DistributedConfig {
    config: Config,
    watchers: Vec<Box<dyn ConfigWatcher>>,
}

impl DistributedConfig {
    pub fn watch<W: ConfigWatcher + 'static>(&mut self, watcher: W);
    pub fn start_file_watch(&self, path: impl AsRef<Path>) -> Result<(), ConfigError>;
    pub fn expand_templates(&mut self) -> Result<(), ConfigError>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `load_json` | Fichier JSON valide | `Ok(())` | 5 | Basic |
| `load_yaml` | Fichier YAML valide | `Ok(())` | 5 | Basic |
| `load_toml` | Fichier TOML valide | `Ok(())` | 5 | Basic |
| `get_string` | Cle existante | `Ok(value)` | 5 | Core |
| `get_int` | Valeur numerique | `Ok(number)` | 5 | Core |
| `get_bool` | Valeur booleenne | `Ok(bool)` | 5 | Core |
| `get_nested` | Cle avec points | `Ok(value)` | 10 | Core |
| `env_override` | Env var definie | Override fichier | 15 | Core |
| `env_prefix` | Prefixe APP_ | Filtre correct | 10 | Core |
| `default_value` | Cle absente | Default applique | 10 | Core |
| `required_missing` | Cle requise absente | `Err(Validation)` | 10 | Edge |
| `type_mismatch` | Mauvais type demande | `Err(TypeMismatch)` | 5 | Edge |
| `sensitive_mask` | Cle sensible | Valeur masquee | 5 | Security |
| `file_not_found` | Fichier inexistant | `Err(FileNotFound)` | 5 | Edge |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    #[test]
    fn test_load_json() {
        let json = r#"{"server": {"port": 8080}}"#;
        let mut manager = ConfigManager::new();
        assert!(manager.load_str(json, ConfigFormat::Json).is_ok());
        assert_eq!(manager.config().get::<u16>("server.port").unwrap(), 8080);
    }

    #[test]
    fn test_load_yaml() {
        let yaml = "server:\n  port: 8080";
        let mut manager = ConfigManager::new();
        assert!(manager.load_str(yaml, ConfigFormat::Yaml).is_ok());
        assert_eq!(manager.config().get::<u16>("server.port").unwrap(), 8080);
    }

    #[test]
    fn test_env_override() {
        env::set_var("APP_SERVER__PORT", "9090");

        let yaml = "server:\n  port: 8080";
        let mut manager = ConfigManager::new()
            .with_options(LoadOptions {
                env_prefix: Some("APP".to_string()),
                ..Default::default()
            });

        manager.load_str(yaml, ConfigFormat::Yaml).unwrap();
        manager.load_env().unwrap();

        assert_eq!(manager.config().get::<u16>("server.port").unwrap(), 9090);

        env::remove_var("APP_SERVER__PORT");
    }

    #[test]
    fn test_default_value() {
        let yaml = "server:\n  host: localhost";
        let mut manager = ConfigManager::new();
        manager.load_str(yaml, ConfigFormat::Yaml).unwrap();

        let port = manager.config().get_or::<u16>("server.port", 3000);
        assert_eq!(port, 3000);
    }

    #[test]
    fn test_required_key_missing() {
        let yaml = "server:\n  host: localhost";
        let manager = ConfigBuilder::new()
            .with_required("server.port");

        let result = manager.build();
        assert!(matches!(result, Err(ConfigError::ValidationError(_))));
    }

    #[test]
    fn test_type_mismatch() {
        let json = r#"{"port": "not_a_number"}"#;
        let mut manager = ConfigManager::new();
        manager.load_str(json, ConfigFormat::Json).unwrap();

        let result = manager.config().get::<u16>("port");
        assert!(matches!(result, Err(ConfigError::TypeMismatch { .. })));
    }

    #[test]
    fn test_sensitive_mask() {
        let json = r#"{"api_key": "secret123", "name": "app"}"#;
        let mut manager = ConfigManager::new();
        manager.load_str(json, ConfigFormat::Json).unwrap();

        let display = manager.config().display_safe();
        assert!(!display.contains("secret123"));
        assert!(display.contains("***"));
        assert!(display.contains("app"));
    }

    #[test]
    fn test_nested_keys() {
        let json = r#"{"a": {"b": {"c": 42}}}"#;
        let mut manager = ConfigManager::new();
        manager.load_str(json, ConfigFormat::Json).unwrap();

        assert_eq!(manager.config().get::<i64>("a.b.c").unwrap(), 42);
    }

    #[test]
    fn test_merge_configs() {
        let base = r#"{"a": 1, "b": 2}"#;
        let override_cfg = r#"{"b": 3, "c": 4}"#;

        let mut manager = ConfigManager::new();
        manager.load_str(base, ConfigFormat::Json).unwrap();
        manager.load_str(override_cfg, ConfigFormat::Json).unwrap();

        assert_eq!(manager.config().get::<i64>("a").unwrap(), 1);
        assert_eq!(manager.config().get::<i64>("b").unwrap(), 3);
        assert_eq!(manager.config().get::<i64>("c").unwrap(), 4);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::path::Path;
use std::fs;
use std::env;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConfigFormat {
    Json,
    Yaml,
    Toml,
    Env,
}

impl ConfigFormat {
    pub fn from_extension(ext: &str) -> Option<Self> {
        match ext.to_lowercase().as_str() {
            "json" => Some(Self::Json),
            "yaml" | "yml" => Some(Self::Yaml),
            "toml" => Some(Self::Toml),
            "env" => Some(Self::Env),
            _ => None,
        }
    }

    pub fn from_path(path: &Path) -> Option<Self> {
        path.extension()
            .and_then(|e| e.to_str())
            .and_then(Self::from_extension)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum ConfigSource {
    Default,
    File(String),
    Environment,
    Override,
}

#[derive(Debug, Clone)]
pub enum ConfigValue {
    Null,
    Bool(bool),
    Integer(i64),
    Float(f64),
    String(String),
    Array(Vec<ConfigValue>),
    Object(HashMap<String, ConfigValue>),
}

impl ConfigValue {
    pub fn as_bool(&self) -> Option<bool> {
        match self {
            Self::Bool(b) => Some(*b),
            Self::String(s) => s.parse().ok(),
            _ => None,
        }
    }

    pub fn as_i64(&self) -> Option<i64> {
        match self {
            Self::Integer(i) => Some(*i),
            Self::String(s) => s.parse().ok(),
            _ => None,
        }
    }

    pub fn as_str(&self) -> Option<&str> {
        match self {
            Self::String(s) => Some(s),
            _ => None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConfigError {
    FileNotFound(String),
    ParseError(String),
    ValidationError(String),
    KeyNotFound(String),
    TypeMismatch { expected: String, got: String },
    IoError(String),
}

#[derive(Debug, Clone)]
pub struct LoadOptions {
    pub env_prefix: Option<String>,
    pub env_separator: String,
    pub required_keys: Vec<String>,
    pub sensitive_keys: Vec<String>,
    pub defaults: HashMap<String, ConfigValue>,
}

impl Default for LoadOptions {
    fn default() -> Self {
        Self {
            env_prefix: None,
            env_separator: "__".to_string(),
            required_keys: Vec::new(),
            sensitive_keys: vec![
                "password".to_string(),
                "secret".to_string(),
                "key".to_string(),
                "token".to_string(),
            ],
            defaults: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Config {
    values: HashMap<String, ConfigValue>,
    sources: HashMap<String, ConfigSource>,
    sensitive_keys: Vec<String>,
}

impl Config {
    pub fn new() -> Self {
        Self {
            values: HashMap::new(),
            sources: HashMap::new(),
            sensitive_keys: Vec::new(),
        }
    }

    pub fn get<T: serde::de::DeserializeOwned>(&self, key: &str) -> Result<T, ConfigError> {
        let value = self.get_value(key)?;
        self.convert_value(value)
    }

    pub fn get_or<T: serde::de::DeserializeOwned>(&self, key: &str, default: T) -> T {
        self.get(key).unwrap_or(default)
    }

    fn get_value(&self, key: &str) -> Result<&ConfigValue, ConfigError> {
        let parts: Vec<&str> = key.split('.').collect();
        let mut current = self.values.get(parts[0])
            .ok_or_else(|| ConfigError::KeyNotFound(key.to_string()))?;

        for part in &parts[1..] {
            match current {
                ConfigValue::Object(map) => {
                    current = map.get(*part)
                        .ok_or_else(|| ConfigError::KeyNotFound(key.to_string()))?;
                }
                _ => return Err(ConfigError::KeyNotFound(key.to_string())),
            }
        }

        Ok(current)
    }

    fn convert_value<T: serde::de::DeserializeOwned>(&self, value: &ConfigValue) -> Result<T, ConfigError> {
        let json = serde_json::to_value(self.value_to_json(value))
            .map_err(|e| ConfigError::ParseError(e.to_string()))?;

        serde_json::from_value(json)
            .map_err(|e| ConfigError::TypeMismatch {
                expected: std::any::type_name::<T>().to_string(),
                got: format!("{:?}", value),
            })
    }

    fn value_to_json(&self, value: &ConfigValue) -> serde_json::Value {
        match value {
            ConfigValue::Null => serde_json::Value::Null,
            ConfigValue::Bool(b) => serde_json::Value::Bool(*b),
            ConfigValue::Integer(i) => serde_json::json!(*i),
            ConfigValue::Float(f) => serde_json::json!(*f),
            ConfigValue::String(s) => serde_json::Value::String(s.clone()),
            ConfigValue::Array(arr) => {
                serde_json::Value::Array(arr.iter().map(|v| self.value_to_json(v)).collect())
            }
            ConfigValue::Object(map) => {
                let obj: serde_json::Map<String, serde_json::Value> = map
                    .iter()
                    .map(|(k, v)| (k.clone(), self.value_to_json(v)))
                    .collect();
                serde_json::Value::Object(obj)
            }
        }
    }

    pub fn contains(&self, key: &str) -> bool {
        self.get_value(key).is_ok()
    }

    pub fn display_safe(&self) -> String {
        let mut lines = Vec::new();
        for (key, value) in &self.values {
            let display_value = if self.is_sensitive(key) {
                "***".to_string()
            } else {
                format!("{:?}", value)
            };
            lines.push(format!("{}: {}", key, display_value));
        }
        lines.join("\n")
    }

    fn is_sensitive(&self, key: &str) -> bool {
        let key_lower = key.to_lowercase();
        self.sensitive_keys.iter().any(|s| key_lower.contains(s))
    }

    pub fn merge(&mut self, other: Config) {
        for (key, value) in other.values {
            self.values.insert(key.clone(), value);
            if let Some(source) = other.sources.get(&key) {
                self.sources.insert(key, source.clone());
            }
        }
    }
}

pub struct ConfigManager {
    config: Config,
    options: LoadOptions,
}

impl ConfigManager {
    pub fn new() -> Self {
        Self {
            config: Config::new(),
            options: LoadOptions::default(),
        }
    }

    pub fn with_options(mut self, options: LoadOptions) -> Self {
        self.options = options;
        self.config.sensitive_keys = self.options.sensitive_keys.clone();
        self
    }

    pub fn load_str(&mut self, content: &str, format: ConfigFormat) -> Result<(), ConfigError> {
        let values = match format {
            ConfigFormat::Json => self.parse_json(content)?,
            ConfigFormat::Yaml => self.parse_yaml(content)?,
            ConfigFormat::Toml => self.parse_toml(content)?,
            ConfigFormat::Env => self.parse_env(content)?,
        };

        for (key, value) in values {
            self.config.values.insert(key.clone(), value);
            self.config.sources.insert(key, ConfigSource::File("string".to_string()));
        }

        Ok(())
    }

    pub fn load_env(&mut self) -> Result<(), ConfigError> {
        let prefix = self.options.env_prefix.as_deref().unwrap_or("");
        let separator = &self.options.env_separator;

        for (key, value) in env::vars() {
            if !prefix.is_empty() && !key.starts_with(prefix) {
                continue;
            }

            let config_key = if prefix.is_empty() {
                key.clone()
            } else {
                key[prefix.len()..].trim_start_matches('_').to_string()
            };

            let config_key = config_key.replace(separator, ".").to_lowercase();

            let value = self.parse_env_value(&value);
            self.set_nested(&config_key, value, ConfigSource::Environment);
        }

        Ok(())
    }

    fn set_nested(&mut self, key: &str, value: ConfigValue, source: ConfigSource) {
        let parts: Vec<&str> = key.split('.').collect();

        if parts.len() == 1 {
            self.config.values.insert(key.to_string(), value);
            self.config.sources.insert(key.to_string(), source);
            return;
        }

        let root_key = parts[0].to_string();
        let mut current = self.config.values
            .entry(root_key.clone())
            .or_insert_with(|| ConfigValue::Object(HashMap::new()));

        for (i, part) in parts[1..parts.len()-1].iter().enumerate() {
            if let ConfigValue::Object(map) = current {
                current = map
                    .entry(part.to_string())
                    .or_insert_with(|| ConfigValue::Object(HashMap::new()));
            }
        }

        if let ConfigValue::Object(map) = current {
            let last_key = parts.last().unwrap();
            map.insert(last_key.to_string(), value);
        }

        self.config.sources.insert(key.to_string(), source);
    }

    fn parse_env_value(&self, value: &str) -> ConfigValue {
        if let Ok(b) = value.parse::<bool>() {
            return ConfigValue::Bool(b);
        }
        if let Ok(i) = value.parse::<i64>() {
            return ConfigValue::Integer(i);
        }
        if let Ok(f) = value.parse::<f64>() {
            return ConfigValue::Float(f);
        }
        ConfigValue::String(value.to_string())
    }

    fn parse_json(&self, content: &str) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let json: serde_json::Value = serde_json::from_str(content)
            .map_err(|e| ConfigError::ParseError(e.to_string()))?;

        self.json_to_config_values(json)
    }

    fn parse_yaml(&self, content: &str) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let yaml: serde_yaml::Value = serde_yaml::from_str(content)
            .map_err(|e| ConfigError::ParseError(e.to_string()))?;

        self.yaml_to_config_values(yaml)
    }

    fn parse_toml(&self, content: &str) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let toml: toml::Value = content.parse()
            .map_err(|e: toml::de::Error| ConfigError::ParseError(e.to_string()))?;

        self.toml_to_config_values(toml)
    }

    fn parse_env(&self, content: &str) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let mut values = HashMap::new();
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            if let Some((key, value)) = line.split_once('=') {
                let value = value.trim_matches('"').trim_matches('\'');
                values.insert(key.to_string(), self.parse_env_value(value));
            }
        }
        Ok(values)
    }

    fn json_to_config_values(&self, json: serde_json::Value) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let mut result = HashMap::new();
        if let serde_json::Value::Object(map) = json {
            for (key, value) in map {
                result.insert(key, self.json_value_to_config(value));
            }
        }
        Ok(result)
    }

    fn json_value_to_config(&self, value: serde_json::Value) -> ConfigValue {
        match value {
            serde_json::Value::Null => ConfigValue::Null,
            serde_json::Value::Bool(b) => ConfigValue::Bool(b),
            serde_json::Value::Number(n) => {
                if let Some(i) = n.as_i64() {
                    ConfigValue::Integer(i)
                } else {
                    ConfigValue::Float(n.as_f64().unwrap_or(0.0))
                }
            }
            serde_json::Value::String(s) => ConfigValue::String(s),
            serde_json::Value::Array(arr) => {
                ConfigValue::Array(arr.into_iter().map(|v| self.json_value_to_config(v)).collect())
            }
            serde_json::Value::Object(map) => {
                let obj: HashMap<String, ConfigValue> = map
                    .into_iter()
                    .map(|(k, v)| (k, self.json_value_to_config(v)))
                    .collect();
                ConfigValue::Object(obj)
            }
        }
    }

    fn yaml_to_config_values(&self, yaml: serde_yaml::Value) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let json = serde_json::to_value(yaml)
            .map_err(|e| ConfigError::ParseError(e.to_string()))?;
        self.json_to_config_values(json)
    }

    fn toml_to_config_values(&self, toml: toml::Value) -> Result<HashMap<String, ConfigValue>, ConfigError> {
        let json = serde_json::to_value(toml)
            .map_err(|e| ConfigError::ParseError(e.to_string()))?;
        self.json_to_config_values(json)
    }

    pub fn config(&self) -> &Config {
        &self.config
    }

    pub fn validate(&self) -> Result<(), ConfigError> {
        for key in &self.options.required_keys {
            if !self.config.contains(key) {
                return Err(ConfigError::ValidationError(
                    format!("Required key '{}' is missing", key)
                ));
            }
        }
        Ok(())
    }
}

impl Default for ConfigManager {
    fn default() -> Self {
        Self::new()
    }
}
```

### 4.9 spec.json

```json
{
  "name": "config_manager",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Integration de concepts - Configuration Management",
  "tags": ["devops", "cloud", "config", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "ConfigManager",
    "prototype": "impl ConfigManager"
  },

  "driver": {
    "edge_cases": [
      {
        "name": "empty_key",
        "input": "get with empty key",
        "expected": "Err(KeyNotFound)",
        "is_trap": true
      },
      {
        "name": "env_override",
        "input": "env var over file",
        "expected": "env value wins",
        "is_trap": true
      }
    ]
  },

  "norm": {
    "allowed_functions": ["serde", "std::env", "std::fs"],
    "forbidden_crates": ["config", "figment"],
    "check_security": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Cle vide acceptee */
pub fn get<T>(&self, key: &str) -> Result<T, ConfigError> {
    // MUTANT: Pas de validation de cle vide
    self.get_value(key).and_then(|v| self.convert_value(v))
}
// Pourquoi c'est faux : Une cle vide devrait retourner KeyNotFound

/* Mutant B (Safety) : Env override ignore */
pub fn load_env(&mut self) -> Result<(), ConfigError> {
    // MUTANT: Ne met pas a jour les valeurs existantes
    for (key, value) in env::vars() {
        if !self.config.contains(&key) {
            self.config.values.insert(key, value);
        }
    }
    Ok(())
}
// Pourquoi c'est faux : Les env vars doivent overrider les fichiers

/* Mutant C (Logic) : Type coercion incorrecte */
fn parse_env_value(&self, value: &str) -> ConfigValue {
    // MUTANT: Retourne toujours String
    ConfigValue::String(value.to_string())
}
// Pourquoi c'est faux : "true" devrait devenir Bool(true), "42" devrait devenir Integer(42)

/* Mutant D (Edge) : Fichier inexistant silencieux */
pub fn load_file(&mut self, path: impl AsRef<Path>) -> Result<(), ConfigError> {
    let content = fs::read_to_string(&path).unwrap_or_default();  // MUTANT
    // ...
}
// Pourquoi c'est faux : Fichier inexistant doit retourner FileNotFound

/* Mutant E (Return) : Default ignore */
pub fn get_or<T>(&self, key: &str, default: T) -> T {
    self.get(key).unwrap()  // MUTANT: Ignore le default, panic si absent
}
// Pourquoi c'est faux : Doit retourner le default si la cle n'existe pas
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Multi-format parsing** : JSON, YAML, TOML avec serde
2. **Hierarchie de sources** : Default < File < Env < Override
3. **Type coercion** : Conversion automatique des types
4. **Security** : Masquage des valeurs sensibles
5. **Nested access** : Navigation avec notation pointee

### 5.2 Visualisation ASCII

```
                    CONFIGURATION HIERARCHY

    Priority (highest)
         ^
         |
    ┌────┴────┐
    │ Override │  config.set("key", value)
    └────┬────┘
         │
    ┌────┴────────┐
    │ Environment │  APP_SERVER__PORT=9090
    └────┬────────┘
         │
    ┌────┴────┐
    │  File   │  config.yaml, config.json
    └────┬────┘
         │
    ┌────┴────┐
    │ Default │  with_default("port", 8080)
    └─────────┘
         |
    Priority (lowest)
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Cle vide | Comportement indefini | Valider la cle |
| 2 | Env ignore | Override ne marche pas | Toujours merger |
| 3 | Type coercion | Tout est String | Parser les types |
| 4 | Fichier silencieux | Config vide | Retourner erreur |
| 5 | Default ignore | Panic | Utiliser unwrap_or |

---

## SECTION 7 : QCM

### Question 1
**Quelle est la priorite correcte des sources de configuration ?**

A) File > Env > Default
B) Default > File > Env
C) Env > Default > File
D) Default < File < Env

**Reponse : D**

*Explication : Les valeurs par defaut sont les moins prioritaires, puis les fichiers, puis les variables d'environnement qui peuvent tout overrider.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | config_manager |
| **Module** | 5.5.7 - Configuration Management |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP** | 150 (base) + bonus x3 |
| **Concepts cles** | Multi-format, Hierarchy, Type-safety |
| **Piege principal** | Override d'environnement ignore |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.5.7-a-config-manager",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.5.7-a",
      "exercise_name": "config_manager",
      "module": "5.5.7",
      "module_name": "Configuration Management",
      "type": "code",
      "tier": 2,
      "phase": 5,
      "difficulty": 6,
      "language": "rust",
      "duration_minutes": 90,
      "xp_base": 150
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
