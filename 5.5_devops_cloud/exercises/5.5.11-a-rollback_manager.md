<thinking>
## Analyse du Concept
- Concept : Rollback Manager
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La gestion des rollbacks est critique pour la resilience des deployments.

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A : Rollback vers une version inexistante
2. Mutant B : Historique non mis a jour apres rollback
3. Mutant C : Etat inconsistant entre services
4. Mutant D : Pas de verification de sante post-rollback
5. Mutant E : Rollback en cascade non gere
</thinking>

# Exercice 5.5.11-a : rollback_manager

**Module :**
5.5.11 - Deployment Recovery

**Concept :**
a - Rollback Manager (Version History, Automated Recovery)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 - Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.5.9 - Blue-Green Deployment
- 5.5.10 - Canary Deployment
- 4.2 - State management

**Domaines :**
DevOps, Resilience, Cloud

**Duree estimee :**
100 min

**XP Base :**
160

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

**CONTEXTE : "The Time Machine"**

*"Chaque deploiement est un point dans le temps. Le Rollback Manager est ta machine a remonter le temps - quand le present est casse, tu reviens a un passe qui marchait."*

Le Rollback Manager maintient l'historique des deployments et permet de revenir rapidement a une version stable en cas de probleme.

**Ta mission :**

Implementer un `RollbackManager` qui permet de :
1. Maintenir l'historique des deployments avec snapshots
2. Detecter automatiquement les echecs (via health checks)
3. Executer des rollbacks manuels ou automatiques
4. Supporter les rollbacks partiels (par service)
5. Gerer les dependances entre services
6. Valider la sante post-rollback

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

/// Version deployee
#[derive(Debug, Clone)]
pub struct DeployedVersion {
    pub service: String,
    pub version: String,
    pub image: String,
    pub deployed_at: SystemTime,
    pub config_snapshot: HashMap<String, String>,
    pub replicas: u32,
}

/// Point de restauration
#[derive(Debug, Clone)]
pub struct RestorePoint {
    pub id: String,
    pub created_at: SystemTime,
    pub description: String,
    pub versions: HashMap<String, DeployedVersion>,
    pub is_stable: bool,
}

/// Strategie de rollback
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RollbackStrategy {
    Immediate,          // Rollback instantane
    Gradual,            // Rollback progressif
    ServiceByService,   // Un service a la fois
}

/// Configuration du rollback
#[derive(Debug, Clone)]
pub struct RollbackConfig {
    pub max_history: usize,
    pub auto_rollback_on_failure: bool,
    pub health_check_timeout: Duration,
    pub strategy: RollbackStrategy,
}

/// Erreur de rollback
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RollbackError {
    RestorePointNotFound(String),
    ServiceNotFound(String),
    RollbackInProgress,
    HealthCheckFailed(String),
    DependencyConflict(String),
    InvalidState(String),
}

/// Resultat de rollback
#[derive(Debug, Clone)]
pub struct RollbackResult {
    pub success: bool,
    pub rolled_back_services: Vec<String>,
    pub failed_services: Vec<String>,
    pub duration: Duration,
    pub previous_versions: HashMap<String, String>,
    pub new_versions: HashMap<String, String>,
}

/// Health checker trait
pub trait HealthChecker: Send + Sync {
    fn check_service(&self, service: &str) -> bool;
    fn check_all(&self) -> HashMap<String, bool>;
}

/// Gestionnaire de rollback
pub struct RollbackManager<H: HealthChecker> {
    history: Vec<RestorePoint>,
    current_versions: HashMap<String, DeployedVersion>,
    config: RollbackConfig,
    health_checker: H,
    rollback_in_progress: bool,
}

impl<H: HealthChecker> RollbackManager<H> {
    pub fn new(health_checker: H, config: RollbackConfig) -> Self;

    /// Enregistre un nouveau deployment
    pub fn record_deployment(&mut self, version: DeployedVersion) -> Result<(), RollbackError>;

    /// Cree un point de restauration manuel
    pub fn create_restore_point(&mut self, description: impl Into<String>) -> String;

    /// Marque un point comme stable
    pub fn mark_stable(&mut self, restore_point_id: &str) -> Result<(), RollbackError>;

    /// Rollback vers un point de restauration
    pub fn rollback_to(&mut self, restore_point_id: &str) -> Result<RollbackResult, RollbackError>;

    /// Rollback vers la derniere version stable
    pub fn rollback_to_stable(&mut self) -> Result<RollbackResult, RollbackError>;

    /// Rollback d'un service specifique
    pub fn rollback_service(
        &mut self,
        service: &str,
        version: &str,
    ) -> Result<RollbackResult, RollbackError>;

    /// Verifie la sante et rollback automatique si necessaire
    pub fn check_and_auto_rollback(&mut self) -> Option<RollbackResult>;

    /// Retourne l'historique
    pub fn history(&self) -> &[RestorePoint];

    /// Retourne les versions courantes
    pub fn current_versions(&self) -> &HashMap<String, DeployedVersion>;

    /// Nettoie l'ancien historique
    pub fn cleanup_history(&mut self) -> usize;

    /// Annule le dernier rollback (roll-forward)
    pub fn cancel_rollback(&mut self) -> Result<RollbackResult, RollbackError>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `record_deployment` | New version | Added to current | 5 | Basic |
| `create_restore_point` | Description | Point created | 10 | Core |
| `rollback_to_point` | Valid point ID | Versions restored | 15 | Core |
| `rollback_to_stable` | Stable exists | Rollback to stable | 15 | Core |
| `rollback_service` | Single service | Only service rolled back | 10 | Core |
| `auto_rollback` | Health check fails | Auto rollback triggered | 15 | Safety |
| `point_not_found` | Invalid ID | Err(RestorePointNotFound) | 5 | Edge |
| `rollback_in_progress` | Double rollback | Err(RollbackInProgress) | 5 | Edge |
| `mark_stable` | Valid point | is_stable = true | 5 | Core |
| `cleanup_history` | Old points | Removed, kept max | 5 | Core |
| `cancel_rollback` | After rollback | Roll-forward | 10 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockHealthChecker {
        healthy_services: Vec<String>,
    }

    impl HealthChecker for MockHealthChecker {
        fn check_service(&self, service: &str) -> bool {
            self.healthy_services.contains(&service.to_string())
        }

        fn check_all(&self) -> HashMap<String, bool> {
            let mut result = HashMap::new();
            for s in &self.healthy_services {
                result.insert(s.clone(), true);
            }
            result
        }
    }

    fn default_config() -> RollbackConfig {
        RollbackConfig {
            max_history: 10,
            auto_rollback_on_failure: true,
            health_check_timeout: Duration::from_secs(30),
            strategy: RollbackStrategy::Immediate,
        }
    }

    #[test]
    fn test_record_and_restore_point() {
        let checker = MockHealthChecker { healthy_services: vec!["api".to_string()] };
        let mut manager = RollbackManager::new(checker, default_config());

        let version = DeployedVersion {
            service: "api".to_string(),
            version: "1.0.0".to_string(),
            image: "api:1.0.0".to_string(),
            deployed_at: SystemTime::now(),
            config_snapshot: HashMap::new(),
            replicas: 3,
        };

        manager.record_deployment(version).unwrap();
        let point_id = manager.create_restore_point("Before v2 deployment");

        assert!(!point_id.is_empty());
        assert_eq!(manager.history().len(), 1);
    }

    #[test]
    fn test_rollback_to_point() {
        let checker = MockHealthChecker { healthy_services: vec!["api".to_string()] };
        let mut manager = RollbackManager::new(checker, default_config());

        // Deploy v1
        let v1 = DeployedVersion {
            service: "api".to_string(),
            version: "1.0.0".to_string(),
            image: "api:1.0.0".to_string(),
            deployed_at: SystemTime::now(),
            config_snapshot: HashMap::new(),
            replicas: 3,
        };
        manager.record_deployment(v1).unwrap();
        let point_id = manager.create_restore_point("v1 stable");
        manager.mark_stable(&point_id).unwrap();

        // Deploy v2
        let v2 = DeployedVersion {
            service: "api".to_string(),
            version: "2.0.0".to_string(),
            image: "api:2.0.0".to_string(),
            deployed_at: SystemTime::now(),
            config_snapshot: HashMap::new(),
            replicas: 3,
        };
        manager.record_deployment(v2).unwrap();

        // Rollback to v1
        let result = manager.rollback_to(&point_id).unwrap();

        assert!(result.success);
        assert_eq!(manager.current_versions().get("api").unwrap().version, "1.0.0");
    }

    #[test]
    fn test_rollback_to_stable() {
        let checker = MockHealthChecker { healthy_services: vec!["api".to_string()] };
        let mut manager = RollbackManager::new(checker, default_config());

        // Deploy v1 and mark stable
        let v1 = DeployedVersion {
            service: "api".to_string(),
            version: "1.0.0".to_string(),
            image: "api:1.0.0".to_string(),
            deployed_at: SystemTime::now(),
            config_snapshot: HashMap::new(),
            replicas: 3,
        };
        manager.record_deployment(v1).unwrap();
        let point_id = manager.create_restore_point("stable");
        manager.mark_stable(&point_id).unwrap();

        // Deploy v2 (problematic)
        let v2 = DeployedVersion {
            service: "api".to_string(),
            version: "2.0.0".to_string(),
            image: "api:2.0.0".to_string(),
            deployed_at: SystemTime::now(),
            config_snapshot: HashMap::new(),
            replicas: 3,
        };
        manager.record_deployment(v2).unwrap();

        // Rollback to stable
        let result = manager.rollback_to_stable().unwrap();

        assert!(result.success);
        assert_eq!(
            result.new_versions.get("api").unwrap(),
            "1.0.0"
        );
    }

    #[test]
    fn test_point_not_found() {
        let checker = MockHealthChecker { healthy_services: vec![] };
        let manager = RollbackManager::new(checker, default_config());

        let result = manager.rollback_to("nonexistent");
        assert!(matches!(result, Err(RollbackError::RestorePointNotFound(_))));
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant, SystemTime};

#[derive(Debug, Clone)]
pub struct DeployedVersion {
    pub service: String,
    pub version: String,
    pub image: String,
    pub deployed_at: SystemTime,
    pub config_snapshot: HashMap<String, String>,
    pub replicas: u32,
}

#[derive(Debug, Clone)]
pub struct RestorePoint {
    pub id: String,
    pub created_at: SystemTime,
    pub description: String,
    pub versions: HashMap<String, DeployedVersion>,
    pub is_stable: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RollbackStrategy {
    Immediate,
    Gradual,
    ServiceByService,
}

#[derive(Debug, Clone)]
pub struct RollbackConfig {
    pub max_history: usize,
    pub auto_rollback_on_failure: bool,
    pub health_check_timeout: Duration,
    pub strategy: RollbackStrategy,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RollbackError {
    RestorePointNotFound(String),
    ServiceNotFound(String),
    RollbackInProgress,
    HealthCheckFailed(String),
    DependencyConflict(String),
    InvalidState(String),
}

#[derive(Debug, Clone)]
pub struct RollbackResult {
    pub success: bool,
    pub rolled_back_services: Vec<String>,
    pub failed_services: Vec<String>,
    pub duration: Duration,
    pub previous_versions: HashMap<String, String>,
    pub new_versions: HashMap<String, String>,
}

pub trait HealthChecker: Send + Sync {
    fn check_service(&self, service: &str) -> bool;
    fn check_all(&self) -> HashMap<String, bool>;
}

pub struct RollbackManager<H: HealthChecker> {
    history: Vec<RestorePoint>,
    current_versions: HashMap<String, DeployedVersion>,
    config: RollbackConfig,
    health_checker: H,
    rollback_in_progress: bool,
    point_counter: u64,
    last_rollback_from: Option<HashMap<String, DeployedVersion>>,
}

impl<H: HealthChecker> RollbackManager<H> {
    pub fn new(health_checker: H, config: RollbackConfig) -> Self {
        Self {
            history: Vec::new(),
            current_versions: HashMap::new(),
            config,
            health_checker,
            rollback_in_progress: false,
            point_counter: 0,
            last_rollback_from: None,
        }
    }

    pub fn record_deployment(&mut self, version: DeployedVersion) -> Result<(), RollbackError> {
        self.current_versions.insert(version.service.clone(), version);
        Ok(())
    }

    pub fn create_restore_point(&mut self, description: impl Into<String>) -> String {
        self.point_counter += 1;
        let id = format!("rp-{}", self.point_counter);

        let point = RestorePoint {
            id: id.clone(),
            created_at: SystemTime::now(),
            description: description.into(),
            versions: self.current_versions.clone(),
            is_stable: false,
        };

        self.history.push(point);
        self.cleanup_history();

        id
    }

    pub fn mark_stable(&mut self, restore_point_id: &str) -> Result<(), RollbackError> {
        let point = self.history.iter_mut()
            .find(|p| p.id == restore_point_id)
            .ok_or_else(|| RollbackError::RestorePointNotFound(restore_point_id.to_string()))?;

        point.is_stable = true;
        Ok(())
    }

    pub fn rollback_to(&mut self, restore_point_id: &str) -> Result<RollbackResult, RollbackError> {
        if self.rollback_in_progress {
            return Err(RollbackError::RollbackInProgress);
        }

        let point = self.history.iter()
            .find(|p| p.id == restore_point_id)
            .ok_or_else(|| RollbackError::RestorePointNotFound(restore_point_id.to_string()))?
            .clone();

        self.rollback_in_progress = true;
        let start = Instant::now();

        let previous_versions: HashMap<String, String> = self.current_versions.iter()
            .map(|(k, v)| (k.clone(), v.version.clone()))
            .collect();

        self.last_rollback_from = Some(self.current_versions.clone());
        self.current_versions = point.versions.clone();

        let new_versions: HashMap<String, String> = self.current_versions.iter()
            .map(|(k, v)| (k.clone(), v.version.clone()))
            .collect();

        let rolled_back: Vec<String> = self.current_versions.keys().cloned().collect();

        self.rollback_in_progress = false;

        Ok(RollbackResult {
            success: true,
            rolled_back_services: rolled_back,
            failed_services: Vec::new(),
            duration: start.elapsed(),
            previous_versions,
            new_versions,
        })
    }

    pub fn rollback_to_stable(&mut self) -> Result<RollbackResult, RollbackError> {
        let stable_point = self.history.iter()
            .rev()
            .find(|p| p.is_stable)
            .ok_or_else(|| RollbackError::RestorePointNotFound("No stable point found".to_string()))?
            .clone();

        self.rollback_to(&stable_point.id)
    }

    pub fn rollback_service(
        &mut self,
        service: &str,
        version: &str,
    ) -> Result<RollbackResult, RollbackError> {
        let start = Instant::now();

        let target_version = self.history.iter()
            .flat_map(|p| p.versions.get(service))
            .find(|v| v.version == version)
            .ok_or_else(|| RollbackError::ServiceNotFound(
                format!("{}:{}", service, version)
            ))?
            .clone();

        let previous = self.current_versions.get(service)
            .map(|v| v.version.clone())
            .unwrap_or_default();

        self.current_versions.insert(service.to_string(), target_version);

        let mut previous_versions = HashMap::new();
        previous_versions.insert(service.to_string(), previous);

        let mut new_versions = HashMap::new();
        new_versions.insert(service.to_string(), version.to_string());

        Ok(RollbackResult {
            success: true,
            rolled_back_services: vec![service.to_string()],
            failed_services: Vec::new(),
            duration: start.elapsed(),
            previous_versions,
            new_versions,
        })
    }

    pub fn check_and_auto_rollback(&mut self) -> Option<RollbackResult> {
        if !self.config.auto_rollback_on_failure {
            return None;
        }

        let health = self.health_checker.check_all();
        let unhealthy: Vec<_> = health.iter()
            .filter(|(_, &healthy)| !healthy)
            .map(|(s, _)| s.clone())
            .collect();

        if unhealthy.is_empty() {
            return None;
        }

        self.rollback_to_stable().ok()
    }

    pub fn history(&self) -> &[RestorePoint] {
        &self.history
    }

    pub fn current_versions(&self) -> &HashMap<String, DeployedVersion> {
        &self.current_versions
    }

    pub fn cleanup_history(&mut self) -> usize {
        let excess = self.history.len().saturating_sub(self.config.max_history);
        if excess > 0 {
            // Keep stable points
            let mut removed = 0;
            self.history.retain(|p| {
                if removed >= excess {
                    true
                } else if !p.is_stable {
                    removed += 1;
                    false
                } else {
                    true
                }
            });
            removed
        } else {
            0
        }
    }

    pub fn cancel_rollback(&mut self) -> Result<RollbackResult, RollbackError> {
        let previous = self.last_rollback_from.take()
            .ok_or_else(|| RollbackError::InvalidState("No rollback to cancel".to_string()))?;

        let start = Instant::now();

        let previous_versions: HashMap<String, String> = self.current_versions.iter()
            .map(|(k, v)| (k.clone(), v.version.clone()))
            .collect();

        let new_versions: HashMap<String, String> = previous.iter()
            .map(|(k, v)| (k.clone(), v.version.clone()))
            .collect();

        let services: Vec<String> = previous.keys().cloned().collect();

        self.current_versions = previous;

        Ok(RollbackResult {
            success: true,
            rolled_back_services: services,
            failed_services: Vec::new(),
            duration: start.elapsed(),
            previous_versions,
            new_versions,
        })
    }
}
```

### 4.9 spec.json

```json
{
  "name": "rollback_manager",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tags": ["devops", "deployment", "resilience", "phase5"],
  "passing_score": 70
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A : Rollback vers version inexistante */
pub fn rollback_to(&mut self, id: &str) -> Result<RollbackResult, RollbackError> {
    // MUTANT: Pas de verification de l'existence
    self.current_versions.clear();
    Ok(RollbackResult { success: true, .. })
}

/* Mutant B : Historique non mis a jour */
pub fn rollback_to(&mut self, id: &str) -> Result<RollbackResult, RollbackError> {
    let point = self.history.iter().find(|p| p.id == id)?.clone();
    // MUTANT: Oubli de self.last_rollback_from = Some(...)
    self.current_versions = point.versions;
    Ok(...)
}

/* Mutant C : Etat inconsistant */
pub fn rollback_service(&mut self, service: &str, version: &str) -> Result<...> {
    // MUTANT: Ne verifie pas que le service existe dans l'historique
    self.current_versions.remove(service);
    Ok(...)
}

/* Mutant D : Pas de health check post-rollback */
pub fn rollback_to(&mut self, id: &str) -> Result<RollbackResult, RollbackError> {
    self.current_versions = point.versions;
    // MUTANT: Pas de verification de sante
    Ok(RollbackResult { success: true, .. })
}

/* Mutant E : Rollback en cascade ignore */
pub fn check_and_auto_rollback(&mut self) -> Option<RollbackResult> {
    // MUTANT: Rollback seulement le premier service unhealthy
    let first_unhealthy = ...;
    self.rollback_service(&first_unhealthy, "latest").ok()
}
```

---

## SECTION 5 : COMPRENDRE

### 5.2 Visualisation ASCII

```
                    ROLLBACK MANAGER FLOW

    Timeline:
    ─────────────────────────────────────────────────────►
    │           │              │              │
    ▼           ▼              ▼              ▼
   v1.0       v1.1           v1.2           v2.0
   [RP1]      [RP2]          [RP3]          [Current]
   stable     stable         unstable

    Rollback to stable (v1.1):
    ─────────────────────────────────────────────────────►
    │           │              │              │
    ▼           ▼              ▼              ▼
   v1.0       v1.1           v1.2           v2.0
              [RESTORE]◄─────────────────────┘
              stable                         rollback

    After rollback:
    ─────────────────────────────────────────────────────►
    │           │              │              │
    ▼           ▼              ▼              ▼
   v1.0       v1.1           v1.2           v2.0
              [Current]
              stable
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Version inexistante | Panic ou etat vide | Valider l'existence |
| 2 | Historique perdu | Cancel impossible | Sauvegarder before |
| 3 | Etat partiel | Services inconsistants | Rollback atomique |
| 4 | Pas de validation | Service unhealthy | Health check post |
| 5 | Cascade ignore | Probleme propage | Rollback complet |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | rollback_manager |
| **Module** | 5.5.11 - Deployment Recovery |
| **Difficulte** | 7/10 |
| **Temps estime** | 100 min |
| **XP** | 160 |
| **Concepts cles** | Version History, Restore Points, Auto Recovery |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.5.11-a-rollback-manager"
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
