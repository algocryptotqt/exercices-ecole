<thinking>
## Analyse du Concept
- Concept : Metrics Exporter
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - L'exportation de metriques Prometheus est fondamentale pour l'observabilite.
</thinking>

# Exercice 5.5.13-a : metrics_exporter

**Module :**
5.5.13 - Metrics & Observability

**Concept :**
a - Metrics Exporter (Prometheus Format, Counters, Gauges, Histograms)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 - Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.5 - Concurrency
- 4.2 - HTTP basics
- 5.5.12 - Health Monitoring

**Domaines :**
Observability, DevOps, Cloud

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

**CONTEXTE : "The Observable Universe"**

*"Tu ne peux pas ameliorer ce que tu ne mesures pas. Les metriques sont les yeux qui te permettent de voir a l'interieur de tes systemes."*

Les metriques Prometheus sont le standard de facto pour le monitoring cloud-native. Un bon exporteur doit supporter les types de metriques standards et le format d'exposition.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::sync::atomic::{AtomicU64, AtomicI64, Ordering};

/// Nom de metrique valide
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetricName(String);

impl MetricName {
    pub fn new(name: impl Into<String>) -> Result<Self, MetricError>;
    pub fn as_str(&self) -> &str;
}

/// Labels de metrique
#[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]
pub struct Labels(Vec<(String, String)>);

impl Labels {
    pub fn new() -> Self;
    pub fn with(self, key: impl Into<String>, value: impl Into<String>) -> Self;
    pub fn to_prometheus(&self) -> String;
}

/// Erreur de metrique
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MetricError {
    InvalidName(String),
    InvalidLabel(String),
    DuplicateMetric(String),
    BucketsNotSorted,
    EmptyBuckets,
}

/// Counter - valeur incrementale
pub struct Counter {
    name: MetricName,
    help: String,
    values: RwLock<HashMap<Labels, AtomicU64>>,
}

impl Counter {
    pub fn new(name: MetricName, help: impl Into<String>) -> Self;
    pub fn inc(&self);
    pub fn inc_by(&self, n: u64);
    pub fn with_labels(&self, labels: Labels) -> CounterVec;
    pub fn get(&self) -> u64;
    pub fn get_with_labels(&self, labels: &Labels) -> u64;
}

/// Gauge - valeur variable
pub struct Gauge {
    name: MetricName,
    help: String,
    values: RwLock<HashMap<Labels, AtomicI64>>,
}

impl Gauge {
    pub fn new(name: MetricName, help: impl Into<String>) -> Self;
    pub fn set(&self, value: i64);
    pub fn inc(&self);
    pub fn dec(&self);
    pub fn add(&self, n: i64);
    pub fn sub(&self, n: i64);
    pub fn with_labels(&self, labels: Labels) -> GaugeVec;
    pub fn get(&self) -> i64;
}

/// Histogram - distribution de valeurs
pub struct Histogram {
    name: MetricName,
    help: String,
    buckets: Vec<f64>,
    values: RwLock<HashMap<Labels, HistogramData>>,
}

struct HistogramData {
    bucket_counts: Vec<AtomicU64>,
    sum: AtomicU64,  // bits of f64
    count: AtomicU64,
}

impl Histogram {
    pub fn new(name: MetricName, help: impl Into<String>, buckets: Vec<f64>) -> Result<Self, MetricError>;
    pub fn default_buckets() -> Vec<f64>;
    pub fn linear_buckets(start: f64, width: f64, count: usize) -> Vec<f64>;
    pub fn exponential_buckets(start: f64, factor: f64, count: usize) -> Vec<f64>;
    pub fn observe(&self, value: f64);
    pub fn observe_with_labels(&self, value: f64, labels: &Labels);
    pub fn start_timer(&self) -> HistogramTimer;
}

/// Timer RAII pour histogrammes
pub struct HistogramTimer {
    histogram: Arc<Histogram>,
    labels: Labels,
    start: std::time::Instant,
}

impl Drop for HistogramTimer {
    fn drop(&mut self);
}

/// Registry de metriques
pub struct MetricsRegistry {
    counters: RwLock<HashMap<MetricName, Arc<Counter>>>,
    gauges: RwLock<HashMap<MetricName, Arc<Gauge>>>,
    histograms: RwLock<HashMap<MetricName, Arc<Histogram>>>,
}

impl MetricsRegistry {
    pub fn new() -> Self;

    pub fn register_counter(
        &self,
        name: impl Into<String>,
        help: impl Into<String>,
    ) -> Result<Arc<Counter>, MetricError>;

    pub fn register_gauge(
        &self,
        name: impl Into<String>,
        help: impl Into<String>,
    ) -> Result<Arc<Gauge>, MetricError>;

    pub fn register_histogram(
        &self,
        name: impl Into<String>,
        help: impl Into<String>,
        buckets: Vec<f64>,
    ) -> Result<Arc<Histogram>, MetricError>;

    /// Exporte au format Prometheus text
    pub fn export(&self) -> String;

    pub fn metric_count(&self) -> usize;
}

/// Formatter Prometheus
pub struct PrometheusFormatter;

impl PrometheusFormatter {
    pub fn format_counter(counter: &Counter) -> String;
    pub fn format_gauge(gauge: &Gauge) -> String;
    pub fn format_histogram(histogram: &Histogram) -> String;
    pub fn escape_label_value(value: &str) -> String;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `counter_inc` | inc() | Value = 1 | 5 | Basic |
| `counter_inc_by` | inc_by(5) | Value = 5 | 5 | Basic |
| `counter_labels` | With labels | Separate values | 10 | Core |
| `gauge_set` | set(42) | Value = 42 | 5 | Basic |
| `gauge_inc_dec` | inc(), dec() | Correct value | 5 | Basic |
| `histogram_observe` | observe(0.5) | Correct bucket | 10 | Core |
| `histogram_buckets` | Custom buckets | Sorted, validated | 10 | Edge |
| `prometheus_format` | Export | Valid format | 15 | Core |
| `labels_escape` | Special chars | Escaped correctly | 10 | Edge |
| `invalid_name` | "123-bad" | Err(InvalidName) | 5 | Edge |
| `concurrent_inc` | 1000 threads | Correct total | 10 | Safety |
| `histogram_timer` | start_timer() | Duration observed | 10 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    #[test]
    fn test_counter_basic() {
        let counter = Counter::new(
            MetricName::new("requests_total").unwrap(),
            "Total requests"
        );

        assert_eq!(counter.get(), 0);
        counter.inc();
        assert_eq!(counter.get(), 1);
        counter.inc_by(5);
        assert_eq!(counter.get(), 6);
    }

    #[test]
    fn test_counter_with_labels() {
        let counter = Counter::new(
            MetricName::new("http_requests_total").unwrap(),
            "HTTP requests"
        );

        let labels_200 = Labels::new().with("status", "200");
        let labels_500 = Labels::new().with("status", "500");

        counter.with_labels(labels_200.clone()).inc_by(10);
        counter.with_labels(labels_500.clone()).inc_by(2);

        assert_eq!(counter.get_with_labels(&labels_200), 10);
        assert_eq!(counter.get_with_labels(&labels_500), 2);
    }

    #[test]
    fn test_gauge() {
        let gauge = Gauge::new(
            MetricName::new("temperature").unwrap(),
            "Temperature"
        );

        gauge.set(20);
        assert_eq!(gauge.get(), 20);

        gauge.inc();
        assert_eq!(gauge.get(), 21);

        gauge.sub(5);
        assert_eq!(gauge.get(), 16);
    }

    #[test]
    fn test_histogram() {
        let histogram = Histogram::new(
            MetricName::new("request_duration").unwrap(),
            "Request duration",
            vec![0.1, 0.5, 1.0, 5.0],
        ).unwrap();

        histogram.observe(0.05);  // bucket 0.1
        histogram.observe(0.3);   // bucket 0.5
        histogram.observe(0.8);   // bucket 1.0
        histogram.observe(10.0);  // +Inf
    }

    #[test]
    fn test_invalid_buckets() {
        let result = Histogram::new(
            MetricName::new("test").unwrap(),
            "test",
            vec![1.0, 0.5, 2.0],  // Not sorted
        );
        assert!(matches!(result, Err(MetricError::BucketsNotSorted)));
    }

    #[test]
    fn test_prometheus_format() {
        let registry = MetricsRegistry::new();

        let counter = registry.register_counter(
            "http_requests_total",
            "Total HTTP requests"
        ).unwrap();

        counter.inc_by(42);

        let output = registry.export();

        assert!(output.contains("# HELP http_requests_total Total HTTP requests"));
        assert!(output.contains("# TYPE http_requests_total counter"));
        assert!(output.contains("http_requests_total 42"));
    }

    #[test]
    fn test_labels_format() {
        let labels = Labels::new()
            .with("method", "GET")
            .with("status", "200");

        let formatted = labels.to_prometheus();
        assert!(formatted.contains("method=\"GET\""));
        assert!(formatted.contains("status=\"200\""));
    }

    #[test]
    fn test_label_escaping() {
        let escaped = PrometheusFormatter::escape_label_value("value\"with\\special");
        assert_eq!(escaped, "value\\\"with\\\\special");
    }

    #[test]
    fn test_invalid_metric_name() {
        let result = MetricName::new("123-invalid");
        assert!(matches!(result, Err(MetricError::InvalidName(_))));

        let result = MetricName::new("valid_metric_name");
        assert!(result.is_ok());
    }

    #[test]
    fn test_concurrent_counter() {
        let counter = Arc::new(Counter::new(
            MetricName::new("concurrent").unwrap(),
            "test"
        ));

        let handles: Vec<_> = (0..10).map(|_| {
            let c = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1000 {
                    c.inc();
                }
            })
        }).collect();

        for h in handles {
            h.join().unwrap();
        }

        assert_eq!(counter.get(), 10_000);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::sync::atomic::{AtomicU64, AtomicI64, Ordering};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetricName(String);

impl MetricName {
    pub fn new(name: impl Into<String>) -> Result<Self, MetricError> {
        let name = name.into();

        if name.is_empty() {
            return Err(MetricError::InvalidName("empty name".to_string()));
        }

        let first_char = name.chars().next().unwrap();
        if !first_char.is_ascii_alphabetic() && first_char != '_' {
            return Err(MetricError::InvalidName(
                "must start with letter or underscore".to_string()
            ));
        }

        if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
            return Err(MetricError::InvalidName(
                "invalid characters".to_string()
            ));
        }

        Ok(Self(name))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]
pub struct Labels(Vec<(String, String)>);

impl Labels {
    pub fn new() -> Self {
        Self(Vec::new())
    }

    pub fn with(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.0.push((key.into(), value.into()));
        self
    }

    pub fn to_prometheus(&self) -> String {
        if self.0.is_empty() {
            return String::new();
        }

        let pairs: Vec<String> = self.0.iter()
            .map(|(k, v)| format!("{}=\"{}\"", k, PrometheusFormatter::escape_label_value(v)))
            .collect();

        format!("{{{}}}", pairs.join(","))
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MetricError {
    InvalidName(String),
    InvalidLabel(String),
    DuplicateMetric(String),
    BucketsNotSorted,
    EmptyBuckets,
}

pub struct Counter {
    name: MetricName,
    help: String,
    values: RwLock<HashMap<Labels, AtomicU64>>,
}

impl Counter {
    pub fn new(name: MetricName, help: impl Into<String>) -> Self {
        let mut values = HashMap::new();
        values.insert(Labels::new(), AtomicU64::new(0));

        Self {
            name,
            help: help.into(),
            values: RwLock::new(values),
        }
    }

    pub fn inc(&self) {
        self.inc_by(1);
    }

    pub fn inc_by(&self, n: u64) {
        let values = self.values.read().unwrap();
        if let Some(counter) = values.get(&Labels::new()) {
            counter.fetch_add(n, Ordering::Relaxed);
        }
    }

    pub fn with_labels(&self, labels: Labels) -> CounterVec {
        {
            let mut values = self.values.write().unwrap();
            values.entry(labels.clone()).or_insert_with(|| AtomicU64::new(0));
        }
        CounterVec { counter: self, labels }
    }

    pub fn get(&self) -> u64 {
        let values = self.values.read().unwrap();
        values.get(&Labels::new())
            .map(|c| c.load(Ordering::Relaxed))
            .unwrap_or(0)
    }

    pub fn get_with_labels(&self, labels: &Labels) -> u64 {
        let values = self.values.read().unwrap();
        values.get(labels)
            .map(|c| c.load(Ordering::Relaxed))
            .unwrap_or(0)
    }
}

pub struct CounterVec<'a> {
    counter: &'a Counter,
    labels: Labels,
}

impl<'a> CounterVec<'a> {
    pub fn inc(&self) {
        self.inc_by(1);
    }

    pub fn inc_by(&self, n: u64) {
        let values = self.counter.values.read().unwrap();
        if let Some(counter) = values.get(&self.labels) {
            counter.fetch_add(n, Ordering::Relaxed);
        }
    }
}

pub struct Gauge {
    name: MetricName,
    help: String,
    values: RwLock<HashMap<Labels, AtomicI64>>,
}

impl Gauge {
    pub fn new(name: MetricName, help: impl Into<String>) -> Self {
        let mut values = HashMap::new();
        values.insert(Labels::new(), AtomicI64::new(0));

        Self {
            name,
            help: help.into(),
            values: RwLock::new(values),
        }
    }

    pub fn set(&self, value: i64) {
        let values = self.values.read().unwrap();
        if let Some(gauge) = values.get(&Labels::new()) {
            gauge.store(value, Ordering::Relaxed);
        }
    }

    pub fn inc(&self) {
        self.add(1);
    }

    pub fn dec(&self) {
        self.sub(1);
    }

    pub fn add(&self, n: i64) {
        let values = self.values.read().unwrap();
        if let Some(gauge) = values.get(&Labels::new()) {
            gauge.fetch_add(n, Ordering::Relaxed);
        }
    }

    pub fn sub(&self, n: i64) {
        self.add(-n);
    }

    pub fn get(&self) -> i64 {
        let values = self.values.read().unwrap();
        values.get(&Labels::new())
            .map(|g| g.load(Ordering::Relaxed))
            .unwrap_or(0)
    }
}

pub struct Histogram {
    name: MetricName,
    help: String,
    buckets: Vec<f64>,
    values: RwLock<HashMap<Labels, HistogramData>>,
}

struct HistogramData {
    bucket_counts: Vec<AtomicU64>,
    sum: AtomicU64,
    count: AtomicU64,
}

impl Histogram {
    pub fn new(name: MetricName, help: impl Into<String>, buckets: Vec<f64>) -> Result<Self, MetricError> {
        if buckets.is_empty() {
            return Err(MetricError::EmptyBuckets);
        }

        for i in 1..buckets.len() {
            if buckets[i] <= buckets[i - 1] {
                return Err(MetricError::BucketsNotSorted);
            }
        }

        let mut values = HashMap::new();
        values.insert(Labels::new(), HistogramData {
            bucket_counts: (0..=buckets.len()).map(|_| AtomicU64::new(0)).collect(),
            sum: AtomicU64::new(0),
            count: AtomicU64::new(0),
        });

        Ok(Self {
            name,
            help: help.into(),
            buckets,
            values: RwLock::new(values),
        })
    }

    pub fn default_buckets() -> Vec<f64> {
        vec![0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
    }

    pub fn observe(&self, value: f64) {
        self.observe_with_labels(value, &Labels::new());
    }

    pub fn observe_with_labels(&self, value: f64, labels: &Labels) {
        let values = self.values.read().unwrap();
        if let Some(data) = values.get(labels) {
            let bucket_idx = self.buckets.iter()
                .position(|&b| value <= b)
                .unwrap_or(self.buckets.len());

            for i in bucket_idx..=self.buckets.len() {
                data.bucket_counts[i].fetch_add(1, Ordering::Relaxed);
            }

            data.sum.fetch_add(value.to_bits(), Ordering::Relaxed);
            data.count.fetch_add(1, Ordering::Relaxed);
        }
    }
}

pub struct MetricsRegistry {
    counters: RwLock<HashMap<MetricName, Arc<Counter>>>,
    gauges: RwLock<HashMap<MetricName, Arc<Gauge>>>,
    histograms: RwLock<HashMap<MetricName, Arc<Histogram>>>,
}

impl MetricsRegistry {
    pub fn new() -> Self {
        Self {
            counters: RwLock::new(HashMap::new()),
            gauges: RwLock::new(HashMap::new()),
            histograms: RwLock::new(HashMap::new()),
        }
    }

    pub fn register_counter(
        &self,
        name: impl Into<String>,
        help: impl Into<String>,
    ) -> Result<Arc<Counter>, MetricError> {
        let metric_name = MetricName::new(name)?;
        let counter = Arc::new(Counter::new(metric_name.clone(), help));

        let mut counters = self.counters.write().unwrap();
        if counters.contains_key(&metric_name) {
            return Err(MetricError::DuplicateMetric(metric_name.as_str().to_string()));
        }
        counters.insert(metric_name, Arc::clone(&counter));

        Ok(counter)
    }

    pub fn register_gauge(
        &self,
        name: impl Into<String>,
        help: impl Into<String>,
    ) -> Result<Arc<Gauge>, MetricError> {
        let metric_name = MetricName::new(name)?;
        let gauge = Arc::new(Gauge::new(metric_name.clone(), help));

        let mut gauges = self.gauges.write().unwrap();
        gauges.insert(metric_name, Arc::clone(&gauge));

        Ok(gauge)
    }

    pub fn register_histogram(
        &self,
        name: impl Into<String>,
        help: impl Into<String>,
        buckets: Vec<f64>,
    ) -> Result<Arc<Histogram>, MetricError> {
        let metric_name = MetricName::new(name)?;
        let histogram = Arc::new(Histogram::new(metric_name.clone(), help, buckets)?);

        let mut histograms = self.histograms.write().unwrap();
        histograms.insert(metric_name, Arc::clone(&histogram));

        Ok(histogram)
    }

    pub fn export(&self) -> String {
        let mut output = String::new();

        let counters = self.counters.read().unwrap();
        for counter in counters.values() {
            output.push_str(&PrometheusFormatter::format_counter(counter));
            output.push('\n');
        }

        let gauges = self.gauges.read().unwrap();
        for gauge in gauges.values() {
            output.push_str(&PrometheusFormatter::format_gauge(gauge));
            output.push('\n');
        }

        output
    }

    pub fn metric_count(&self) -> usize {
        self.counters.read().unwrap().len()
            + self.gauges.read().unwrap().len()
            + self.histograms.read().unwrap().len()
    }
}

pub struct PrometheusFormatter;

impl PrometheusFormatter {
    pub fn format_counter(counter: &Counter) -> String {
        let mut output = String::new();
        output.push_str(&format!("# HELP {} {}\n", counter.name.as_str(), counter.help));
        output.push_str(&format!("# TYPE {} counter\n", counter.name.as_str()));

        let values = counter.values.read().unwrap();
        for (labels, value) in values.iter() {
            let label_str = labels.to_prometheus();
            let val = value.load(Ordering::Relaxed);
            output.push_str(&format!("{}{} {}\n", counter.name.as_str(), label_str, val));
        }

        output
    }

    pub fn format_gauge(gauge: &Gauge) -> String {
        let mut output = String::new();
        output.push_str(&format!("# HELP {} {}\n", gauge.name.as_str(), gauge.help));
        output.push_str(&format!("# TYPE {} gauge\n", gauge.name.as_str()));

        let values = gauge.values.read().unwrap();
        for (labels, value) in values.iter() {
            let label_str = labels.to_prometheus();
            let val = value.load(Ordering::Relaxed);
            output.push_str(&format!("{}{} {}\n", gauge.name.as_str(), label_str, val));
        }

        output
    }

    pub fn escape_label_value(value: &str) -> String {
        value
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
    }
}
```

### 4.9 spec.json

```json
{
  "name": "metrics_exporter",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tags": ["observability", "prometheus", "metrics", "phase5"],
  "passing_score": 70
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A : Non thread-safe */
pub fn inc(&self) {
    // MUTANT: Pas d'atomique
    let mut values = self.values.write().unwrap();
    // Race condition possible
}

/* Mutant B : Labels non echappes */
pub fn escape_label_value(value: &str) -> String {
    value.to_string()  // MUTANT: Pas d'echappement
}

/* Mutant C : Buckets non valides */
pub fn new(name: MetricName, help: impl Into<String>, buckets: Vec<f64>) -> Result<Self, MetricError> {
    // MUTANT: Pas de validation des buckets
    Ok(Self { buckets, .. })
}

/* Mutant D : Histogram bucket incorrect */
pub fn observe(&self, value: f64) {
    let bucket_idx = self.buckets.iter()
        .position(|&b| value < b)  // MUTANT: < au lieu de <=
        .unwrap_or(self.buckets.len());
}

/* Mutant E : Counter decrement */
pub fn inc_by(&self, n: u64) {
    counter.fetch_sub(n, Ordering::Relaxed);  // MUTANT: sub au lieu de add
}
```

---

## SECTION 5 : COMPRENDRE

### 5.2 Visualisation ASCII

```
                    PROMETHEUS METRICS FORMAT

    # HELP http_requests_total Total HTTP requests
    # TYPE http_requests_total counter
    http_requests_total{method="GET",status="200"} 1234
    http_requests_total{method="POST",status="201"} 567

    # HELP process_memory_bytes Memory usage
    # TYPE process_memory_bytes gauge
    process_memory_bytes 1.234e+08

    # HELP request_duration_seconds Request duration
    # TYPE request_duration_seconds histogram
    request_duration_seconds_bucket{le="0.1"} 24
    request_duration_seconds_bucket{le="0.5"} 129
    request_duration_seconds_bucket{le="1.0"} 156
    request_duration_seconds_bucket{le="+Inf"} 160
    request_duration_seconds_sum 64.23
    request_duration_seconds_count 160
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Non thread-safe | Race conditions | Atomics |
| 2 | Labels non echappes | Parse error | Escape special chars |
| 3 | Buckets invalides | Valeurs incorrectes | Validation |
| 4 | Bucket boundary | Off-by-one | <= au lieu de < |
| 5 | Counter decrement | Valeur negative | Seulement increment |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | metrics_exporter |
| **Module** | 5.5.13 - Metrics & Observability |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 |
| **Concepts cles** | Prometheus, Counters, Gauges, Histograms |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.5.13-a-metrics-exporter"
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 96/100*
