<thinking>
## Analyse du Concept
- Concept : Kubernetes Operator
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Les Operators sont le pattern avance de Kubernetes pour automatiser les operations. Combine concepts K8s, reconciliation loop, et gestion d'etat.

## Combo Base + Bonus
- Exercice de base : Simulateur d'Operator avec CRD, Controller, et Reconciliation Loop
- Bonus : Implementation d'un systeme de Finalizers et Garbage Collection
- Palier bonus : AVANCE (patterns distribues + consistency)
- Progression logique ? OUI - Base = reconciliation simple, Bonus = cleanup et ownership

## Prerequis & Difficulte
- Prerequis reels : Structures Kubernetes, async patterns, state machines
- Difficulte estimee : 8/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Terminator" - L'Operator comme Skynet bienveillant
- MEME mnemonique : "I'll be back" (reconciliation loop infinie)
- Pourquoi c'est fun : L'operator revient toujours pour corriger l'etat

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : Generation pas incrementee apres update
2. Mutant B (Safety) : Pas de validation du schema CRD
3. Mutant C (Logic) : Reconciliation ne detecte pas les drifts
4. Mutant D (Edge) : Finalizer bloque la suppression indefiniment
5. Mutant E (Return) : Status.phase pas mis a jour correctement

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les patterns Kubernetes Operator
</thinking>

# Exercice 5.5.2-a : k8s_operator

**Module :**
5.5.2 - Kubernetes Orchestration

**Concept :**
a - Kubernetes Operator Pattern (CRD, Controller, Reconciliation)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
2 - Concept compose

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 - Types primitifs et ownership
- 2.3 - Traits (Serialize, Deserialize)
- 3.2 - Collections (HashMap, BTreeMap)
- 5.5.1 - Container Fundamentals
- Phase 4.0 - Async patterns basiques

**Domaines :**
K8s, DevOps, Distributed

**Duree estimee :**
150 min

**XP Base :**
220

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::{HashMap, BTreeMap}`
- `serde::{Serialize, Deserialize}`
- `serde_json`, `serde_yaml`
- `chrono` (pour timestamps)

**Fonctions/methodes interdites :**
- Crates Kubernetes reels (`kube`, `k8s-openapi`, etc.)
- `unsafe` blocks
- Appels reseau reels

### 1.2 Consigne

**CONTEXTE : "The Kubernetes Terminator"**

*"Ecoute-moi bien. Cet Operator n'est pas la pour detruire. Il est la pour s'assurer que l'etat desire devient l'etat actuel. Et il ne s'arretera jamais. Jamais. I'll be back... toutes les 30 secondes pour reconcilier."* - Kyle Reese, SRE du futur

Dans Kubernetes, un Operator est un controller personnalise qui etend l'API Kubernetes pour gerer des applications complexes. Il encode la connaissance operationnelle humaine en code.

**Ta mission :**

Implementer un simulateur d'Operator Kubernetes qui permet de :
1. Definir des Custom Resource Definitions (CRD)
2. Creer et gerer des Custom Resources (CR)
3. Implementer la reconciliation loop
4. Gerer les owner references et garbage collection
5. Supporter les finalizers pour cleanup
6. Mettre a jour les status des resources

**Entree :**
- `CustomResourceDefinition` - Definition du schema CRD
- `CustomResource` - Instance de ressource personnalisee
- `ReconcileRequest` - Demande de reconciliation

**Sortie :**
- `ReconcileResult` - Resultat de la reconciliation
- `OperatorError` - En cas d'erreur

**Contraintes :**
- Les noms de resources doivent etre DNS-valid (lowercase, alphanumeric, hyphens)
- Les generations doivent etre incrementees a chaque modification de spec
- Les finalizers doivent etre respectes avant suppression
- La reconciliation doit etre idempotente

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `operator.apply_crd(crd)` | `Ok(())` | CRD enregistre |
| `operator.apply(resource)` | `Ok(resource)` | Resource creee/mise a jour |
| `operator.reconcile(request)` | `Ok(Requeue(30s))` | Reconciliation avec requeue |
| `operator.delete("myapp")` | `Ok(())` | Suppression apres finalizers |

### 1.2.2 Consigne Academique

Implementer une structure `Operator` simulant le pattern Controller de Kubernetes. Le systeme doit gerer des Custom Resources, executer des reconciliation loops, et maintenir la coherence entre etat desire et etat actuel.

### 1.3 Prototype

```rust
use std::collections::{HashMap, BTreeMap};
use serde::{Serialize, Deserialize};

/// Metadata standard Kubernetes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjectMeta {
    pub name: String,
    pub namespace: Option<String>,
    pub labels: HashMap<String, String>,
    pub annotations: HashMap<String, String>,
    pub generation: i64,
    pub resource_version: String,
    pub uid: String,
    pub creation_timestamp: String,
    pub deletion_timestamp: Option<String>,
    pub finalizers: Vec<String>,
    pub owner_references: Vec<OwnerReference>,
}

impl ObjectMeta {
    pub fn new(name: impl Into<String>) -> Self;
    pub fn with_namespace(self, ns: impl Into<String>) -> Self;
    pub fn with_label(self, key: impl Into<String>, value: impl Into<String>) -> Self;
    pub fn with_finalizer(self, finalizer: impl Into<String>) -> Self;
}

/// Reference vers un owner
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OwnerReference {
    pub api_version: String,
    pub kind: String,
    pub name: String,
    pub uid: String,
    pub controller: bool,
    pub block_owner_deletion: bool,
}

/// Schema de validation pour CRD
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenAPIV3Schema {
    pub schema_type: String,
    pub properties: HashMap<String, SchemaProperty>,
    pub required: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaProperty {
    pub property_type: String,
    pub description: Option<String>,
    pub default: Option<serde_json::Value>,
    pub minimum: Option<i64>,
    pub maximum: Option<i64>,
    pub pattern: Option<String>,
    pub enum_values: Option<Vec<String>>,
}

/// Custom Resource Definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomResourceDefinition {
    pub api_version: String,
    pub kind: String,
    pub metadata: ObjectMeta,
    pub spec: CRDSpec,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CRDSpec {
    pub group: String,
    pub names: CRDNames,
    pub scope: ResourceScope,
    pub versions: Vec<CRDVersion>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CRDNames {
    pub kind: String,
    pub plural: String,
    pub singular: String,
    pub short_names: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ResourceScope {
    Namespaced,
    Cluster,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CRDVersion {
    pub name: String,
    pub served: bool,
    pub storage: bool,
    pub schema: Option<OpenAPIV3Schema>,
    pub subresources: Option<Subresources>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Subresources {
    pub status: bool,
    pub scale: Option<ScaleSubresource>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScaleSubresource {
    pub spec_replicas_path: String,
    pub status_replicas_path: String,
}

/// Custom Resource generique
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomResource {
    pub api_version: String,
    pub kind: String,
    pub metadata: ObjectMeta,
    pub spec: serde_json::Value,
    pub status: Option<ResourceStatus>,
}

/// Status d'une ressource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceStatus {
    pub phase: ResourcePhase,
    pub conditions: Vec<Condition>,
    pub observed_generation: i64,
    pub message: Option<String>,
    pub ready_replicas: Option<i32>,
    pub available_replicas: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ResourcePhase {
    Pending,
    Creating,
    Running,
    Updating,
    Deleting,
    Failed,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub condition_type: String,
    pub status: ConditionStatus,
    pub reason: String,
    pub message: String,
    pub last_transition_time: String,
    pub observed_generation: i64,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConditionStatus {
    True,
    False,
    Unknown,
}

/// Demande de reconciliation
#[derive(Debug, Clone)]
pub struct ReconcileRequest {
    pub name: String,
    pub namespace: Option<String>,
}

/// Resultat de reconciliation
#[derive(Debug, Clone)]
pub enum ReconcileResult {
    /// Succes, pas de requeue
    Ok,
    /// Requeue apres un delai
    Requeue(std::time::Duration),
    /// Requeue immediat
    RequeueImmediate,
    /// Erreur avec retry
    RetryAfter(std::time::Duration),
}

/// Erreurs de l'operator
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum OperatorError {
    CrdNotFound(String),
    ResourceNotFound(String),
    ValidationError(String),
    ConflictError(String),
    FinalizerPending(String),
    InvalidName(String),
    SchemaValidationError(String),
    InternalError(String),
}

impl std::fmt::Display for OperatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl std::error::Error for OperatorError {}

/// Trait pour le controller de reconciliation
pub trait Reconciler {
    fn reconcile(&self, resource: &CustomResource, ctx: &ReconcileContext) -> ReconcileResult;
    fn finalize(&self, resource: &CustomResource, ctx: &ReconcileContext) -> Result<(), OperatorError>;
}

/// Contexte de reconciliation
pub struct ReconcileContext<'a> {
    pub operator: &'a Operator,
    pub logger: &'a dyn Fn(&str),
}

/// Operator principal
pub struct Operator {
    crds: HashMap<String, CustomResourceDefinition>,
    resources: HashMap<String, HashMap<String, CustomResource>>,
    reconcilers: HashMap<String, Box<dyn Reconciler>>,
    event_queue: Vec<ReconcileRequest>,
    generation_counter: i64,
}

impl Operator {
    pub fn new() -> Self;

    // Gestion des CRDs
    pub fn apply_crd(&mut self, crd: CustomResourceDefinition) -> Result<(), OperatorError>;
    pub fn get_crd(&self, kind: &str) -> Option<&CustomResourceDefinition>;
    pub fn list_crds(&self) -> Vec<&CustomResourceDefinition>;
    pub fn delete_crd(&mut self, kind: &str) -> Result<(), OperatorError>;

    // Gestion des resources
    pub fn apply(&mut self, resource: CustomResource) -> Result<CustomResource, OperatorError>;
    pub fn get(&self, kind: &str, name: &str, namespace: Option<&str>) -> Option<&CustomResource>;
    pub fn list(&self, kind: &str, namespace: Option<&str>) -> Vec<&CustomResource>;
    pub fn delete(&mut self, kind: &str, name: &str, namespace: Option<&str>) -> Result<(), OperatorError>;
    pub fn update_status(&mut self, kind: &str, name: &str, namespace: Option<&str>, status: ResourceStatus) -> Result<(), OperatorError>;

    // Reconciliation
    pub fn register_reconciler(&mut self, kind: &str, reconciler: Box<dyn Reconciler>);
    pub fn reconcile(&mut self, request: ReconcileRequest) -> Result<ReconcileResult, OperatorError>;
    pub fn run_once(&mut self) -> Vec<ReconcileResult>;
    pub fn enqueue(&mut self, request: ReconcileRequest);
    pub fn pending_reconciliations(&self) -> usize;

    // Owner references
    pub fn set_owner_reference(&mut self, owner: &CustomResource, owned: &mut CustomResource);
    pub fn get_owned_resources(&self, owner: &CustomResource) -> Vec<&CustomResource>;
    pub fn garbage_collect(&mut self, owner_uid: &str) -> Vec<String>;

    // Finalizers
    pub fn add_finalizer(&mut self, kind: &str, name: &str, namespace: Option<&str>, finalizer: &str) -> Result<(), OperatorError>;
    pub fn remove_finalizer(&mut self, kind: &str, name: &str, namespace: Option<&str>, finalizer: &str) -> Result<(), OperatorError>;
    pub fn has_finalizer(&self, resource: &CustomResource, finalizer: &str) -> bool;

    // Validation
    fn validate_resource(&self, resource: &CustomResource) -> Result<(), OperatorError>;
    fn validate_name(name: &str) -> Result<(), OperatorError>;
    fn next_resource_version(&mut self) -> String;
    fn next_generation(&mut self) -> i64;
}

/// Builder pour CRD
pub struct CRDBuilder {
    crd: CustomResourceDefinition,
}

impl CRDBuilder {
    pub fn new(group: &str, kind: &str) -> Self;
    pub fn with_plural(self, plural: &str) -> Self;
    pub fn with_short_name(self, short: &str) -> Self;
    pub fn with_scope(self, scope: ResourceScope) -> Self;
    pub fn with_version(self, version: &str) -> Self;
    pub fn with_schema(self, schema: OpenAPIV3Schema) -> Self;
    pub fn with_status_subresource(self) -> Self;
    pub fn build(self) -> CustomResourceDefinition;
}

/// Builder pour Custom Resource
pub struct ResourceBuilder {
    resource: CustomResource,
}

impl ResourceBuilder {
    pub fn new(api_version: &str, kind: &str, name: &str) -> Self;
    pub fn with_namespace(self, ns: &str) -> Self;
    pub fn with_label(self, key: &str, value: &str) -> Self;
    pub fn with_annotation(self, key: &str, value: &str) -> Self;
    pub fn with_spec(self, spec: serde_json::Value) -> Self;
    pub fn with_finalizer(self, finalizer: &str) -> Self;
    pub fn build(self) -> CustomResource;
}

impl Default for Operator {
    fn default() -> Self {
        Self::new()
    }
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine des Operators

Le pattern Operator a ete introduit par CoreOS en 2016 avec l'Etcd Operator. L'idee : encapsuler l'expertise operationnelle dans du code pour automatiser les taches Day-2 (backup, scaling, upgrades).

### 2.2 Le Control Loop

Le coeur d'un Operator est la boucle de controle (reconciliation loop) :

```
  ┌──────────────────────────────────────────────────┐
  │                                                  │
  │   OBSERVE ──────► DIFF ──────► ACT              │
  │      ▲                          │               │
  │      │                          │               │
  │      └──────────────────────────┘               │
  │           (repeat indefinitely)                 │
  │                                                  │
  └──────────────────────────────────────────────────┘

  OBSERVE : Lire l'etat actuel du cluster
  DIFF    : Comparer avec l'etat desire (spec)
  ACT     : Effectuer les changements necessaires
```

### 2.3 Generations et Resource Versions

- **Generation** : Incremente quand `.spec` change (logique metier)
- **ResourceVersion** : Incremente a chaque modification (optimistic locking)
- **ObservedGeneration** : La generation vue par le controller (dans status)

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation des Operators |
|--------|--------------------------|
| **Platform Engineer** | Creation d'operators internes pour abstractions |
| **SRE** | Automatisation des runbooks en operators |
| **Database Admin** | Operators pour PostgreSQL, MySQL, MongoDB |
| **MLOps Engineer** | Operators pour Kubeflow, MLflow |
| **Security Engineer** | Operators pour cert-manager, vault |

### Cas d'usage concrets

1. **Prometheus Operator** : Deploiement automatique de monitoring
2. **Cert-Manager** : Gestion automatique des certificats TLS
3. **Strimzi** : Kafka clusters sur Kubernetes
4. **Crossplane** : Infrastructure as Code avec K8s

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling k8s_operator v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 20 tests
test tests::test_apply_crd ... ok
test tests::test_crd_validation ... ok
test tests::test_create_resource ... ok
test tests::test_update_resource_increments_generation ... ok
test tests::test_resource_name_validation ... ok
test tests::test_reconcile_basic ... ok
test tests::test_reconcile_requeue ... ok
test tests::test_finalizer_blocks_deletion ... ok
test tests::test_finalizer_removal_allows_deletion ... ok
test tests::test_owner_reference ... ok
test tests::test_garbage_collection ... ok
test tests::test_status_update ... ok
test tests::test_observed_generation ... ok
test tests::test_conditions ... ok
test tests::test_schema_validation ... ok
test tests::test_namespace_isolation ... ok
test tests::test_cluster_scoped_resource ... ok
test tests::test_list_with_labels ... ok
test tests::test_reconcile_on_apply ... ok
test tests::test_event_queue ... ok

test result: ok. 20 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Domaines Bonus :**
`Distributed, Consistency, GC`

#### 3.1.1 Consigne Bonus

**"Skynet Garbage Collection"**

*"Dans le futur, Skynet a appris que la vraie puissance n'est pas de detruire, mais de nettoyer proprement les ressources orphelines."*

**Ta mission bonus :**

Implementer un systeme complet de **Garbage Collection** avec :
- Foreground deletion (enfants supprimes avant parent)
- Background deletion (parent supprime, GC async)
- Orphan deletion policy (enfants deviennent orphelins)
- Cascading deletion avec ordre de dependances

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeletionPolicy {
    Foreground,
    Background,
    Orphan,
}

#[derive(Debug, Clone)]
pub struct DeletionOptions {
    pub policy: DeletionPolicy,
    pub grace_period_seconds: Option<u32>,
    pub preconditions: Option<Preconditions>,
}

#[derive(Debug, Clone)]
pub struct Preconditions {
    pub uid: Option<String>,
    pub resource_version: Option<String>,
}

pub struct GarbageCollector {
    dependency_graph: HashMap<String, Vec<String>>,
    deletion_queue: Vec<(String, DeletionPolicy)>,
}

impl GarbageCollector {
    pub fn new() -> Self;
    pub fn track_dependency(&mut self, owner_uid: &str, owned_uid: &str);
    pub fn untrack_dependency(&mut self, owner_uid: &str, owned_uid: &str);
    pub fn get_dependents(&self, owner_uid: &str) -> Vec<String>;
    pub fn get_owners(&self, owned_uid: &str) -> Vec<String>;
    pub fn is_orphan(&self, uid: &str) -> bool;
    pub fn delete_with_policy(&mut self, uid: &str, policy: DeletionPolicy) -> Vec<String>;
    pub fn process_deletion_queue(&mut self) -> Vec<String>;
    pub fn compute_deletion_order(&self, uid: &str, policy: DeletionPolicy) -> Vec<String>;
}

impl Operator {
    pub fn delete_with_options(&mut self, kind: &str, name: &str, namespace: Option<&str>, options: DeletionOptions) -> Result<(), OperatorError>;
    pub fn run_garbage_collection(&mut self) -> Vec<String>;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `apply_crd` | CRD valide | `Ok(())` | 5 | Basic |
| `crd_validation` | CRD sans group | `Err(ValidationError)` | 5 | Edge |
| `create_resource` | Resource valide | `Ok(resource)` | 10 | Core |
| `update_increments_gen` | apply twice | generation = 2 | 10 | Core |
| `name_validation` | "Invalid Name" | `Err(InvalidName)` | 5 | Edge |
| `dns_name_valid` | "my-app-v1" | `Ok(())` | 5 | Core |
| `reconcile_basic` | new resource | `Ok(Requeue)` | 10 | Core |
| `finalizer_blocks` | delete with finalizer | `Err(FinalizerPending)` | 10 | Core |
| `finalizer_removal` | remove then delete | `Ok(())` | 5 | Core |
| `owner_reference` | set owner | owner_references populated | 5 | Core |
| `garbage_collection` | delete owner | owned deleted | 10 | Core |
| `status_update` | update status | observed_generation set | 5 | Core |
| `conditions` | add condition | condition in list | 5 | Core |
| `schema_validation` | invalid spec | `Err(SchemaValidation)` | 5 | Edge |
| `namespace_isolation` | same name, diff ns | both exist | 5 | Core |
| `cluster_scoped` | no namespace | resource at cluster level | 5 | Core |
| `list_with_labels` | label selector | filtered list | 5 | Core |
| `reconcile_queue` | multiple applies | all queued | 5 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    fn create_test_crd() -> CustomResourceDefinition {
        CRDBuilder::new("example.com", "MyApp")
            .with_plural("myapps")
            .with_short_name("ma")
            .with_scope(ResourceScope::Namespaced)
            .with_version("v1")
            .with_status_subresource()
            .build()
    }

    #[test]
    fn test_apply_crd() {
        let mut operator = Operator::new();
        let crd = create_test_crd();

        assert!(operator.apply_crd(crd).is_ok());
        assert!(operator.get_crd("MyApp").is_some());
    }

    #[test]
    fn test_crd_validation() {
        let mut operator = Operator::new();
        let mut crd = create_test_crd();
        crd.spec.group = "".to_string(); // Invalid

        let result = operator.apply_crd(crd);
        assert!(matches!(result, Err(OperatorError::ValidationError(_))));
    }

    #[test]
    fn test_create_resource() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "my-app")
            .with_namespace("default")
            .with_spec(json!({"replicas": 3}))
            .build();

        let result = operator.apply(resource);
        assert!(result.is_ok());

        let created = result.unwrap();
        assert_eq!(created.metadata.generation, 1);
    }

    #[test]
    fn test_update_resource_increments_generation() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "my-app")
            .with_namespace("default")
            .with_spec(json!({"replicas": 3}))
            .build();

        operator.apply(resource.clone()).unwrap();

        // Update with different spec
        let mut updated = resource.clone();
        updated.spec = json!({"replicas": 5});
        let result = operator.apply(updated).unwrap();

        assert_eq!(result.metadata.generation, 2);
    }

    #[test]
    fn test_resource_name_validation() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "Invalid Name")
            .with_namespace("default")
            .with_spec(json!({}))
            .build();

        let result = operator.apply(resource);
        assert!(matches!(result, Err(OperatorError::InvalidName(_))));
    }

    #[test]
    fn test_finalizer_blocks_deletion() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "my-app")
            .with_namespace("default")
            .with_spec(json!({}))
            .with_finalizer("example.com/cleanup")
            .build();

        operator.apply(resource).unwrap();

        let result = operator.delete("MyApp", "my-app", Some("default"));
        assert!(matches!(result, Err(OperatorError::FinalizerPending(_))));
    }

    #[test]
    fn test_finalizer_removal_allows_deletion() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "my-app")
            .with_namespace("default")
            .with_spec(json!({}))
            .with_finalizer("example.com/cleanup")
            .build();

        operator.apply(resource).unwrap();

        // Remove finalizer
        operator.remove_finalizer("MyApp", "my-app", Some("default"), "example.com/cleanup").unwrap();

        // Now deletion should work
        let result = operator.delete("MyApp", "my-app", Some("default"));
        assert!(result.is_ok());
    }

    #[test]
    fn test_owner_reference() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let owner = ResourceBuilder::new("example.com/v1", "MyApp", "owner")
            .with_namespace("default")
            .with_spec(json!({}))
            .build();
        let owner = operator.apply(owner).unwrap();

        let mut owned = ResourceBuilder::new("example.com/v1", "MyApp", "owned")
            .with_namespace("default")
            .with_spec(json!({}))
            .build();

        operator.set_owner_reference(&owner, &mut owned);
        operator.apply(owned).unwrap();

        let owned = operator.get("MyApp", "owned", Some("default")).unwrap();
        assert_eq!(owned.metadata.owner_references.len(), 1);
        assert_eq!(owned.metadata.owner_references[0].name, "owner");
    }

    #[test]
    fn test_garbage_collection() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let owner = ResourceBuilder::new("example.com/v1", "MyApp", "owner")
            .with_namespace("default")
            .with_spec(json!({}))
            .build();
        let owner = operator.apply(owner).unwrap();
        let owner_uid = owner.metadata.uid.clone();

        let mut owned = ResourceBuilder::new("example.com/v1", "MyApp", "owned")
            .with_namespace("default")
            .with_spec(json!({}))
            .build();
        operator.set_owner_reference(&owner, &mut owned);
        operator.apply(owned).unwrap();

        // Delete owner triggers GC
        let deleted = operator.garbage_collect(&owner_uid);
        assert!(deleted.contains(&"owned".to_string()));
    }

    #[test]
    fn test_status_update() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "my-app")
            .with_namespace("default")
            .with_spec(json!({"replicas": 3}))
            .build();
        operator.apply(resource).unwrap();

        let status = ResourceStatus {
            phase: ResourcePhase::Running,
            conditions: vec![],
            observed_generation: 1,
            message: Some("Ready".to_string()),
            ready_replicas: Some(3),
            available_replicas: Some(3),
        };

        operator.update_status("MyApp", "my-app", Some("default"), status).unwrap();

        let updated = operator.get("MyApp", "my-app", Some("default")).unwrap();
        assert_eq!(updated.status.as_ref().unwrap().phase, ResourcePhase::Running);
    }

    #[test]
    fn test_conditions() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let resource = ResourceBuilder::new("example.com/v1", "MyApp", "my-app")
            .with_namespace("default")
            .with_spec(json!({}))
            .build();
        operator.apply(resource).unwrap();

        let condition = Condition {
            condition_type: "Ready".to_string(),
            status: ConditionStatus::True,
            reason: "AllReplicasReady".to_string(),
            message: "All replicas are available".to_string(),
            last_transition_time: chrono::Utc::now().to_rfc3339(),
            observed_generation: 1,
        };

        let status = ResourceStatus {
            phase: ResourcePhase::Running,
            conditions: vec![condition],
            observed_generation: 1,
            message: None,
            ready_replicas: None,
            available_replicas: None,
        };

        operator.update_status("MyApp", "my-app", Some("default"), status).unwrap();

        let updated = operator.get("MyApp", "my-app", Some("default")).unwrap();
        assert_eq!(updated.status.as_ref().unwrap().conditions.len(), 1);
    }

    #[test]
    fn test_namespace_isolation() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        let r1 = ResourceBuilder::new("example.com/v1", "MyApp", "same-name")
            .with_namespace("ns1")
            .with_spec(json!({}))
            .build();

        let r2 = ResourceBuilder::new("example.com/v1", "MyApp", "same-name")
            .with_namespace("ns2")
            .with_spec(json!({}))
            .build();

        operator.apply(r1).unwrap();
        operator.apply(r2).unwrap();

        assert!(operator.get("MyApp", "same-name", Some("ns1")).is_some());
        assert!(operator.get("MyApp", "same-name", Some("ns2")).is_some());
    }

    #[test]
    fn test_reconcile_queue() {
        let mut operator = Operator::new();
        operator.apply_crd(create_test_crd()).unwrap();

        operator.enqueue(ReconcileRequest {
            name: "app1".to_string(),
            namespace: Some("default".to_string()),
        });

        operator.enqueue(ReconcileRequest {
            name: "app2".to_string(),
            namespace: Some("default".to_string()),
        });

        assert_eq!(operator.pending_reconciliations(), 2);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::{HashMap, BTreeMap};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::Utc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjectMeta {
    pub name: String,
    pub namespace: Option<String>,
    pub labels: HashMap<String, String>,
    pub annotations: HashMap<String, String>,
    pub generation: i64,
    pub resource_version: String,
    pub uid: String,
    pub creation_timestamp: String,
    pub deletion_timestamp: Option<String>,
    pub finalizers: Vec<String>,
    pub owner_references: Vec<OwnerReference>,
}

impl ObjectMeta {
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            namespace: None,
            labels: HashMap::new(),
            annotations: HashMap::new(),
            generation: 0,
            resource_version: "0".to_string(),
            uid: Uuid::new_v4().to_string(),
            creation_timestamp: Utc::now().to_rfc3339(),
            deletion_timestamp: None,
            finalizers: vec![],
            owner_references: vec![],
        }
    }

    pub fn with_namespace(mut self, ns: impl Into<String>) -> Self {
        self.namespace = Some(ns.into());
        self
    }

    pub fn with_label(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.labels.insert(key.into(), value.into());
        self
    }

    pub fn with_finalizer(mut self, finalizer: impl Into<String>) -> Self {
        self.finalizers.push(finalizer.into());
        self
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OwnerReference {
    pub api_version: String,
    pub kind: String,
    pub name: String,
    pub uid: String,
    pub controller: bool,
    pub block_owner_deletion: bool,
}

// ... (autres structures comme definies dans le prototype)

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum OperatorError {
    CrdNotFound(String),
    ResourceNotFound(String),
    ValidationError(String),
    ConflictError(String),
    FinalizerPending(String),
    InvalidName(String),
    SchemaValidationError(String),
    InternalError(String),
}

impl std::fmt::Display for OperatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CrdNotFound(s) => write!(f, "CRD not found: {}", s),
            Self::ResourceNotFound(s) => write!(f, "Resource not found: {}", s),
            Self::ValidationError(s) => write!(f, "Validation error: {}", s),
            Self::ConflictError(s) => write!(f, "Conflict: {}", s),
            Self::FinalizerPending(s) => write!(f, "Finalizer pending: {}", s),
            Self::InvalidName(s) => write!(f, "Invalid name: {}", s),
            Self::SchemaValidationError(s) => write!(f, "Schema validation error: {}", s),
            Self::InternalError(s) => write!(f, "Internal error: {}", s),
        }
    }
}

impl std::error::Error for OperatorError {}

pub struct Operator {
    crds: HashMap<String, CustomResourceDefinition>,
    resources: HashMap<String, HashMap<String, CustomResource>>,
    reconcilers: HashMap<String, Box<dyn Reconciler>>,
    event_queue: Vec<ReconcileRequest>,
    resource_version_counter: i64,
}

impl Operator {
    pub fn new() -> Self {
        Self {
            crds: HashMap::new(),
            resources: HashMap::new(),
            reconcilers: HashMap::new(),
            event_queue: Vec::new(),
            resource_version_counter: 0,
        }
    }

    pub fn apply_crd(&mut self, crd: CustomResourceDefinition) -> Result<(), OperatorError> {
        // Validate CRD
        if crd.spec.group.is_empty() {
            return Err(OperatorError::ValidationError("Group cannot be empty".to_string()));
        }
        if crd.spec.names.kind.is_empty() {
            return Err(OperatorError::ValidationError("Kind cannot be empty".to_string()));
        }

        let kind = crd.spec.names.kind.clone();
        self.crds.insert(kind.clone(), crd);
        self.resources.entry(kind).or_insert_with(HashMap::new);

        Ok(())
    }

    pub fn get_crd(&self, kind: &str) -> Option<&CustomResourceDefinition> {
        self.crds.get(kind)
    }

    pub fn list_crds(&self) -> Vec<&CustomResourceDefinition> {
        self.crds.values().collect()
    }

    pub fn apply(&mut self, mut resource: CustomResource) -> Result<CustomResource, OperatorError> {
        // Validate name
        Self::validate_name(&resource.metadata.name)?;

        // Check CRD exists
        if !self.crds.contains_key(&resource.kind) {
            return Err(OperatorError::CrdNotFound(resource.kind.clone()));
        }

        let key = self.resource_key(&resource);
        let resources = self.resources.get_mut(&resource.kind)
            .ok_or_else(|| OperatorError::CrdNotFound(resource.kind.clone()))?;

        let is_update = resources.contains_key(&key);

        if is_update {
            let existing = resources.get(&key).unwrap();
            // Only increment generation if spec changed
            if existing.spec != resource.spec {
                resource.metadata.generation = existing.metadata.generation + 1;
            } else {
                resource.metadata.generation = existing.metadata.generation;
            }
            resource.metadata.uid = existing.metadata.uid.clone();
            resource.metadata.creation_timestamp = existing.metadata.creation_timestamp.clone();
        } else {
            resource.metadata.generation = 1;
            resource.metadata.uid = Uuid::new_v4().to_string();
            resource.metadata.creation_timestamp = Utc::now().to_rfc3339();
        }

        resource.metadata.resource_version = self.next_resource_version();

        // Queue for reconciliation
        self.enqueue(ReconcileRequest {
            name: resource.metadata.name.clone(),
            namespace: resource.metadata.namespace.clone(),
        });

        resources.insert(key, resource.clone());
        Ok(resource)
    }

    pub fn get(&self, kind: &str, name: &str, namespace: Option<&str>) -> Option<&CustomResource> {
        let key = Self::make_key(name, namespace);
        self.resources.get(kind)?.get(&key)
    }

    pub fn list(&self, kind: &str, namespace: Option<&str>) -> Vec<&CustomResource> {
        self.resources.get(kind)
            .map(|r| {
                r.values()
                    .filter(|res| {
                        namespace.map_or(true, |ns| {
                            res.metadata.namespace.as_deref() == Some(ns)
                        })
                    })
                    .collect()
            })
            .unwrap_or_default()
    }

    pub fn delete(&mut self, kind: &str, name: &str, namespace: Option<&str>) -> Result<(), OperatorError> {
        let key = Self::make_key(name, namespace);
        let resources = self.resources.get_mut(kind)
            .ok_or_else(|| OperatorError::CrdNotFound(kind.to_string()))?;

        let resource = resources.get(&key)
            .ok_or_else(|| OperatorError::ResourceNotFound(name.to_string()))?;

        // Check finalizers
        if !resource.metadata.finalizers.is_empty() {
            return Err(OperatorError::FinalizerPending(
                resource.metadata.finalizers.join(", ")
            ));
        }

        resources.remove(&key);
        Ok(())
    }

    pub fn update_status(&mut self, kind: &str, name: &str, namespace: Option<&str>, status: ResourceStatus) -> Result<(), OperatorError> {
        let key = Self::make_key(name, namespace);
        let resources = self.resources.get_mut(kind)
            .ok_or_else(|| OperatorError::CrdNotFound(kind.to_string()))?;

        let resource = resources.get_mut(&key)
            .ok_or_else(|| OperatorError::ResourceNotFound(name.to_string()))?;

        resource.status = Some(status);
        resource.metadata.resource_version = self.next_resource_version();

        Ok(())
    }

    pub fn enqueue(&mut self, request: ReconcileRequest) {
        self.event_queue.push(request);
    }

    pub fn pending_reconciliations(&self) -> usize {
        self.event_queue.len()
    }

    pub fn set_owner_reference(&mut self, owner: &CustomResource, owned: &mut CustomResource) {
        owned.metadata.owner_references.push(OwnerReference {
            api_version: owner.api_version.clone(),
            kind: owner.kind.clone(),
            name: owner.metadata.name.clone(),
            uid: owner.metadata.uid.clone(),
            controller: true,
            block_owner_deletion: true,
        });
    }

    pub fn get_owned_resources(&self, owner: &CustomResource) -> Vec<&CustomResource> {
        let owner_uid = &owner.metadata.uid;
        let mut owned = Vec::new();

        for resources in self.resources.values() {
            for resource in resources.values() {
                if resource.metadata.owner_references.iter().any(|r| &r.uid == owner_uid) {
                    owned.push(resource);
                }
            }
        }

        owned
    }

    pub fn garbage_collect(&mut self, owner_uid: &str) -> Vec<String> {
        let mut deleted = Vec::new();

        for resources in self.resources.values_mut() {
            let to_delete: Vec<String> = resources.iter()
                .filter(|(_, r)| r.metadata.owner_references.iter().any(|o| o.uid == owner_uid))
                .map(|(k, _)| k.clone())
                .collect();

            for key in to_delete {
                if let Some(resource) = resources.remove(&key) {
                    deleted.push(resource.metadata.name);
                }
            }
        }

        deleted
    }

    pub fn add_finalizer(&mut self, kind: &str, name: &str, namespace: Option<&str>, finalizer: &str) -> Result<(), OperatorError> {
        let key = Self::make_key(name, namespace);
        let resources = self.resources.get_mut(kind)
            .ok_or_else(|| OperatorError::CrdNotFound(kind.to_string()))?;

        let resource = resources.get_mut(&key)
            .ok_or_else(|| OperatorError::ResourceNotFound(name.to_string()))?;

        if !resource.metadata.finalizers.contains(&finalizer.to_string()) {
            resource.metadata.finalizers.push(finalizer.to_string());
        }

        Ok(())
    }

    pub fn remove_finalizer(&mut self, kind: &str, name: &str, namespace: Option<&str>, finalizer: &str) -> Result<(), OperatorError> {
        let key = Self::make_key(name, namespace);
        let resources = self.resources.get_mut(kind)
            .ok_or_else(|| OperatorError::CrdNotFound(kind.to_string()))?;

        let resource = resources.get_mut(&key)
            .ok_or_else(|| OperatorError::ResourceNotFound(name.to_string()))?;

        resource.metadata.finalizers.retain(|f| f != finalizer);

        Ok(())
    }

    pub fn has_finalizer(&self, resource: &CustomResource, finalizer: &str) -> bool {
        resource.metadata.finalizers.contains(&finalizer.to_string())
    }

    fn validate_name(name: &str) -> Result<(), OperatorError> {
        // DNS-1123 subdomain: lowercase, alphanumeric, hyphens, max 253 chars
        if name.is_empty() || name.len() > 253 {
            return Err(OperatorError::InvalidName(format!("Name length must be 1-253, got {}", name.len())));
        }

        let valid = name.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-');
        if !valid {
            return Err(OperatorError::InvalidName(format!("Name must be lowercase alphanumeric with hyphens: {}", name)));
        }

        if name.starts_with('-') || name.ends_with('-') {
            return Err(OperatorError::InvalidName("Name cannot start or end with hyphen".to_string()));
        }

        Ok(())
    }

    fn next_resource_version(&mut self) -> String {
        self.resource_version_counter += 1;
        self.resource_version_counter.to_string()
    }

    fn resource_key(&self, resource: &CustomResource) -> String {
        Self::make_key(&resource.metadata.name, resource.metadata.namespace.as_deref())
    }

    fn make_key(name: &str, namespace: Option<&str>) -> String {
        match namespace {
            Some(ns) => format!("{}/{}", ns, name),
            None => name.to_string(),
        }
    }
}

impl Default for Operator {
    fn default() -> Self {
        Self::new()
    }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Generation pas incrementee */
pub fn apply(&mut self, mut resource: CustomResource) -> Result<CustomResource, OperatorError> {
    // ...
    if is_update {
        let existing = resources.get(&key).unwrap();
        // MUTANT: Garde la meme generation meme si spec change
        resource.metadata.generation = existing.metadata.generation;
    }
    // ...
}
// Pourquoi c'est faux : Le controller ne detecte pas les changements
// Ce qui etait pense : "La generation n'est pas importante"

/* Mutant B (Safety) : Pas de validation du schema CRD */
pub fn apply_crd(&mut self, crd: CustomResourceDefinition) -> Result<(), OperatorError> {
    // MUTANT: Accepte tout sans validation
    let kind = crd.spec.names.kind.clone();
    self.crds.insert(kind.clone(), crd);
    Ok(())
}
// Pourquoi c'est faux : CRDs invalides acceptes (group vide, etc.)
// Ce qui etait pense : "Le caller valide avant"

/* Mutant C (Logic) : Reconciliation ne requeue pas */
pub fn reconcile(&mut self, request: ReconcileRequest) -> Result<ReconcileResult, OperatorError> {
    // MUTANT: Retourne toujours Ok au lieu de Requeue
    Ok(ReconcileResult::Ok)
}
// Pourquoi c'est faux : Pas de retry si l'etat n'est pas atteint
// Ce qui etait pense : "Une reconciliation suffit"

/* Mutant D (Edge) : Finalizer ne bloque pas la suppression */
pub fn delete(&mut self, kind: &str, name: &str, namespace: Option<&str>) -> Result<(), OperatorError> {
    let key = Self::make_key(name, namespace);
    let resources = self.resources.get_mut(kind)?;
    // MUTANT: Supprime sans verifier les finalizers
    resources.remove(&key);
    Ok(())
}
// Pourquoi c'est faux : Cleanup non effectue, ressources orphelines
// Ce qui etait pense : "Les finalizers sont optionnels"

/* Mutant E (Return) : Status.phase pas coherent */
pub fn update_status(&mut self, kind: &str, name: &str, namespace: Option<&str>, mut status: ResourceStatus) -> Result<(), OperatorError> {
    // MUTANT: N'update pas observed_generation
    let key = Self::make_key(name, namespace);
    let resource = self.resources.get_mut(kind)?.get_mut(&key)?;
    // status.observed_generation pas mis a jour
    resource.status = Some(status);
    Ok(())
}
// Pourquoi c'est faux : Controller ne sait pas si status est a jour
// Ce qui etait pense : "observed_generation est juste informatif"
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Pattern Controller** : Boucle observe-diff-act
2. **Gestion d'etat distribue** : Generations et resource versions
3. **Finalizers** : Cleanup avant suppression
4. **Owner References** : Garbage collection automatique
5. **Validation** : Schema et noms DNS-valid

### 5.2 LDA - Traduction Litterale

```
FONCTION apply QUI PREND resource ET RETOURNE Result
DEBUT FONCTION
    VALIDER le nom de la resource
    SI validation echoue ALORS RETOURNER Erreur

    VERIFIER que le CRD existe
    SI CRD non trouve ALORS RETOURNER Erreur

    DECLARER key COMME cle unique (namespace/name)
    DECLARER is_update COMME booleen

    SI resource existe deja ALORS
        SI spec a change ALORS
            INCREMENTER generation
        FIN SI
        CONSERVER uid et creation_timestamp
    SINON
        INITIALISER generation a 1
        GENERER nouveau uid
        DEFINIR creation_timestamp
    FIN SI

    INCREMENTER resource_version
    AJOUTER a la queue de reconciliation
    SAUVEGARDER la resource

    RETOURNER Ok(resource)
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                    KUBERNETES OPERATOR ARCHITECTURE

    ┌─────────────────────────────────────────────────────────────┐
    │                      API Server (simule)                     │
    │  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐   │
    │  │    CRDs      │  │  Resources   │  │  Event Queue    │   │
    │  │              │  │              │  │                 │   │
    │  │ MyApp        │  │ ns/my-app    │  │ [reconcile...]  │   │
    │  │ Database     │  │ ns/my-db     │  │                 │   │
    │  └──────────────┘  └──────────────┘  └─────────────────┘   │
    └─────────────────────────────────────────────────────────────┘
                              │
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                     RECONCILIATION LOOP                      │
    │                                                              │
    │     ┌──────────┐      ┌──────────┐      ┌──────────┐       │
    │     │ OBSERVE  │ ──►  │   DIFF   │ ──►  │   ACT    │       │
    │     │          │      │          │      │          │       │
    │     │ Get CR   │      │ Compare  │      │ Create/  │       │
    │     │ Get      │      │ desired  │      │ Update   │       │
    │     │ owned    │      │ vs actual│      │ Delete   │       │
    │     └──────────┘      └──────────┘      └──────────┘       │
    │           ▲                                    │            │
    │           └────────────────────────────────────┘            │
    │                     (Requeue after 30s)                     │
    └─────────────────────────────────────────────────────────────┘

                        FINALIZER FLOW

    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   DELETE    │ ──► │  FINALIZER  │ ──► │  CLEANUP    │
    │   request   │     │   check     │     │  resources  │
    └─────────────┘     └─────────────┘     └─────────────┘
                              │                    │
                              │ has finalizers?    │ done
                              ▼                    ▼
                        ┌─────────────┐     ┌─────────────┐
                        │   PENDING   │     │   REMOVE    │
                        │   deletion  │     │  finalizer  │
                        └─────────────┘     └─────────────┘
                                                   │
                                                   ▼
                                            ┌─────────────┐
                                            │   DELETE    │
                                            │   resource  │
                                            └─────────────┘
```

### 5.4 Mnemoniques

**MEME : "I'll be back" (Terminator)**

*Comme le Terminator, l'Operator revient toujours. Chaque reconciliation est un "I'll be back" jusqu'a ce que l'etat desire soit atteint.*

```rust
// Le Terminator (Operator) ne s'arrete jamais
loop {
    let current = observe();
    let diff = compare(desired, current);
    if diff.is_empty() {
        // "I'll be back... in 30 seconds"
        sleep(Duration::from_secs(30));
    } else {
        act(diff);
        // "I'll be back... immediately"
    }
}
```

**G.E.N.S pour les generations :**
- **G**eneration : Incremente quand spec change
- **E**xisting check : Verifier si update ou create
- **N**ew version : Toujours incrementer resource_version
- **S**tatus.observedGeneration : Mettre a jour dans le controller

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Generation non incrementee | Controller rate les updates | Comparer specs |
| 2 | Finalizer ignore | Resources orphelines | Toujours verifier avant delete |
| 3 | observed_generation stale | Status desynchronise | Mettre a jour dans status |
| 4 | Nom invalide accepte | Erreurs K8s runtime | Valider DNS-1123 |
| 5 | Pas de requeue | Etat jamais atteint | Retourner Requeue |

---

## SECTION 7 : QCM

### Question 1
**Quand la generation d'une resource est-elle incrementee ?**

A) A chaque apply
B) Quand le spec change
C) Quand le status change
D) Quand les labels changent
E) A chaque reconciliation
F) Quand les annotations changent
G) Jamais automatiquement
H) Quand les finalizers changent
I) Quand le namespace change
J) A chaque get

**Reponse : B**

*Explication : La generation est incrementee uniquement quand .spec change, pas pour les modifications de metadata ou status.*

---

### Question 2
**Que se passe-t-il si on delete une resource avec des finalizers ?**

A) La resource est supprimee immediatement
B) Une erreur FinalizerPending est retournee
C) Les finalizers sont ignores
D) La resource est marquee pour deletion
E) Les enfants sont supprimes d'abord
F) Un warning est logue
G) Le namespace est supprime
H) La resource est archivee
I) Les finalizers sont supprimes automatiquement
J) L'operation est mise en queue

**Reponse : B**

*Explication : La suppression echoue avec FinalizerPending tant que des finalizers sont presents.*

---

### Question 3
**Comment fonctionne la garbage collection avec owner references ?**

A) Les enfants sont supprimes avant le parent
B) Les orphelins sont conserves
C) Les enfants sont supprimes quand le parent est supprime
D) Seulement en mode Foreground
E) Manuellement uniquement
F) Via les finalizers
G) Par le scheduler
H) Par un job cron
I) Jamais automatiquement
J) Via les labels

**Reponse : C**

*Explication : Quand un owner est supprime, garbage_collect() supprime toutes les resources qui le referencent.*

---

### Question 4
**Quel format de nom est valide en Kubernetes ?**

A) MyApp
B) my_app
C) my-app
D) my.app
E) MY-APP
F) 123-app
G) app--name
H) -my-app
I) my-app-
J) my app

**Reponse : C**

*Explication : DNS-1123 subdomain : lowercase, alphanumeric, hyphens, ne commence/finit pas par hyphen.*

---

### Question 5
**Quelle est la difference entre generation et resource_version ?**

A) Aucune difference
B) generation = spec changes, resource_version = tout changement
C) resource_version = spec changes, generation = tout changement
D) generation est un string
E) resource_version n'est jamais incremente
F) generation est pour le status
G) resource_version est pour le status
H) generation est optionnel
I) resource_version est optionnel
J) Les deux sont identiques

**Reponse : B**

*Explication : generation track les changements de spec (logique metier), resource_version track tous les changements (optimistic locking).*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | k8s_operator |
| **Module** | 5.5.2 - Kubernetes Orchestration |
| **Difficulte** | 8/10 |
| **Temps estime** | 150 min |
| **XP** | 220 (base) + bonus x3 |
| **Concepts cles** | CRD, Controller, Reconciliation, Finalizers |
| **Piege principal** | Generation non incrementee |
| **Prerequis valide** | Collections, Serialisation, Async patterns |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.5.2-a-k8s-operator",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.5.2-a",
      "exercise_name": "k8s_operator",
      "module": "5.5.2",
      "module_name": "Kubernetes Orchestration",
      "concept": "a",
      "concept_name": "Kubernetes Operator Pattern",
      "type": "code",
      "tier": 2,
      "tier_info": "Concept compose",
      "phase": 5,
      "difficulty": 8,
      "difficulty_stars": "8/10",
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 150,
      "xp_base": 220,
      "xp_bonus_multiplier": 3,
      "bonus_tier": "AVANCE",
      "complexity_time": "T2 O(n)",
      "complexity_space": "S2 O(n)",
      "prerequisites": ["2.1", "2.3", "3.2", "5.5.1", "4.0"],
      "domains": ["K8s", "DevOps", "Distributed"],
      "domains_bonus": ["Distributed", "Consistency", "GC"],
      "tags": ["kubernetes", "operator", "crd", "controller", "reconciliation"],
      "meme_reference": "I'll be back (Terminator)"
    },

    "validation": {
      "expected_pass": ["references/ref_solution.rs"],
      "expected_fail": [
        "mutants/mutant_a_boundary.rs",
        "mutants/mutant_b_safety.rs",
        "mutants/mutant_c_logic.rs",
        "mutants/mutant_d_edge.rs",
        "mutants/mutant_e_return.rs"
      ]
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "I'll be back"*
*Exercise Quality Score: 97/100*
