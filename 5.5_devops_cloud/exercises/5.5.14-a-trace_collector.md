<thinking>
## Analyse du Concept
- Concept : Trace Collector
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le distributed tracing est essentiel pour le debugging des microservices.
</thinking>

# Exercice 5.5.14-a : trace_collector

**Module :**
5.5.14 - Distributed Tracing

**Concept :**
a - Trace Collector (Spans, Context Propagation, OpenTelemetry)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
3 - Systeme complet

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.5 - Async/await
- 5.5.13 - Metrics Exporter
- 4.3 - HTTP Headers

**Domaines :**
Observability, Distributed Systems, Cloud

**Duree estimee :**
150 min

**XP Base :**
200

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

**CONTEXTE : "Following the Thread"**

*"Dans un labyrinthe de microservices, le trace ID est ton fil d'Ariane. Il te permet de suivre une requete a travers des dizaines de services."*

Le distributed tracing permet de suivre le parcours d'une requete a travers plusieurs services, identifiant les goulots d'etranglement et les erreurs.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

/// Identifiant de trace (128 bits)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraceId([u8; 16]);

impl TraceId {
    pub fn new() -> Self;
    pub fn from_hex(hex: &str) -> Result<Self, TraceError>;
    pub fn to_hex(&self) -> String;
}

/// Identifiant de span (64 bits)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpanId([u8; 8]);

impl SpanId {
    pub fn new() -> Self;
    pub fn from_hex(hex: &str) -> Result<Self, SpanError>;
    pub fn to_hex(&self) -> String;
}

/// Contexte de trace propageable
#[derive(Debug, Clone)]
pub struct TraceContext {
    pub trace_id: TraceId,
    pub span_id: SpanId,
    pub parent_span_id: Option<SpanId>,
    pub trace_flags: u8,
    pub trace_state: HashMap<String, String>,
}

impl TraceContext {
    /// Parse le header W3C traceparent
    pub fn from_traceparent(header: &str) -> Result<Self, TraceError>;

    /// Genere le header W3C traceparent
    pub fn to_traceparent(&self) -> String;

    /// Parse le header W3C tracestate
    pub fn parse_tracestate(header: &str) -> HashMap<String, String>;

    /// Cree un nouveau contexte enfant
    pub fn child(&self) -> Self;
}

/// Type de span
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SpanKind {
    Internal,
    Server,
    Client,
    Producer,
    Consumer,
}

/// Status du span
#[derive(Debug, Clone)]
pub enum SpanStatus {
    Unset,
    Ok,
    Error(String),
}

/// Evenement dans un span
#[derive(Debug, Clone)]
pub struct SpanEvent {
    pub name: String,
    pub timestamp: SystemTime,
    pub attributes: HashMap<String, AttributeValue>,
}

/// Valeur d'attribut
#[derive(Debug, Clone)]
pub enum AttributeValue {
    String(String),
    Int(i64),
    Float(f64),
    Bool(bool),
    StringArray(Vec<String>),
    IntArray(Vec<i64>),
}

/// Span individuel
#[derive(Debug, Clone)]
pub struct Span {
    pub context: TraceContext,
    pub name: String,
    pub kind: SpanKind,
    pub start_time: SystemTime,
    pub end_time: Option<SystemTime>,
    pub attributes: HashMap<String, AttributeValue>,
    pub events: Vec<SpanEvent>,
    pub status: SpanStatus,
    pub service_name: String,
}

/// Erreur de trace
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TraceError {
    InvalidTraceId(String),
    InvalidSpanId(String),
    InvalidTraceparent(String),
    SpanNotFound(String),
    ExportFailed(String),
}

/// Configuration du collector
#[derive(Debug, Clone)]
pub struct CollectorConfig {
    pub service_name: String,
    pub max_spans_per_trace: usize,
    pub sample_rate: f64,
    pub export_batch_size: usize,
    pub export_timeout: Duration,
}

/// Exporter de traces
pub trait TraceExporter: Send + Sync {
    fn export(&self, spans: &[Span]) -> Result<(), TraceError>;
}

/// Collecteur de traces
pub struct TraceCollector<E: TraceExporter> {
    config: CollectorConfig,
    active_spans: HashMap<SpanId, Span>,
    completed_spans: Vec<Span>,
    exporter: E,
}

impl<E: TraceExporter> TraceCollector<E> {
    pub fn new(exporter: E, config: CollectorConfig) -> Self;

    /// Demarre un nouveau span racine
    pub fn start_span(&mut self, name: impl Into<String>, kind: SpanKind) -> SpanId;

    /// Demarre un span enfant
    pub fn start_child_span(
        &mut self,
        parent: &TraceContext,
        name: impl Into<String>,
        kind: SpanKind,
    ) -> SpanId;

    /// Ajoute un attribut au span
    pub fn set_attribute(
        &mut self,
        span_id: &SpanId,
        key: impl Into<String>,
        value: AttributeValue,
    ) -> Result<(), TraceError>;

    /// Ajoute un evenement au span
    pub fn add_event(
        &mut self,
        span_id: &SpanId,
        name: impl Into<String>,
        attributes: HashMap<String, AttributeValue>,
    ) -> Result<(), TraceError>;

    /// Definit le status du span
    pub fn set_status(
        &mut self,
        span_id: &SpanId,
        status: SpanStatus,
    ) -> Result<(), TraceError>;

    /// Termine un span
    pub fn end_span(&mut self, span_id: &SpanId) -> Result<(), TraceError>;

    /// Retourne le contexte d'un span
    pub fn get_context(&self, span_id: &SpanId) -> Option<&TraceContext>;

    /// Exporte les spans completes
    pub fn flush(&mut self) -> Result<usize, TraceError>;

    /// Decide si une trace doit etre echantillonnee
    pub fn should_sample(&self, trace_id: &TraceId) -> bool;
}

/// Guard RAII pour auto-terminer les spans
pub struct SpanGuard<'a, E: TraceExporter> {
    collector: &'a mut TraceCollector<E>,
    span_id: SpanId,
}

impl<'a, E: TraceExporter> Drop for SpanGuard<'a, E> {
    fn drop(&mut self);
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `trace_id_generation` | new() | Valid 128-bit ID | 5 | Basic |
| `span_id_generation` | new() | Valid 64-bit ID | 5 | Basic |
| `traceparent_parse` | W3C header | Correct context | 10 | Core |
| `traceparent_generate` | Context | Valid header | 10 | Core |
| `start_span` | Name, kind | Span created | 10 | Core |
| `child_span` | Parent context | Linked span | 10 | Core |
| `set_attributes` | Key, value | Stored | 5 | Basic |
| `add_event` | Name, attrs | Event added | 5 | Basic |
| `end_span` | Active span | Completed | 10 | Core |
| `context_propagation` | Trace through services | Same trace_id | 15 | Core |
| `sampling` | Rate 50% | Approx 50% sampled | 10 | Core |
| `flush_export` | Completed spans | Exported | 5 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockExporter {
        exported: std::cell::RefCell<Vec<Span>>,
    }

    impl TraceExporter for MockExporter {
        fn export(&self, spans: &[Span]) -> Result<(), TraceError> {
            self.exported.borrow_mut().extend(spans.iter().cloned());
            Ok(())
        }
    }

    fn default_config() -> CollectorConfig {
        CollectorConfig {
            service_name: "test-service".to_string(),
            max_spans_per_trace: 100,
            sample_rate: 1.0,
            export_batch_size: 10,
            export_timeout: Duration::from_secs(5),
        }
    }

    #[test]
    fn test_trace_id() {
        let id1 = TraceId::new();
        let id2 = TraceId::new();

        assert_ne!(id1, id2);
        assert_eq!(id1.to_hex().len(), 32);
    }

    #[test]
    fn test_traceparent_roundtrip() {
        let context = TraceContext {
            trace_id: TraceId::new(),
            span_id: SpanId::new(),
            parent_span_id: None,
            trace_flags: 1,
            trace_state: HashMap::new(),
        };

        let header = context.to_traceparent();
        let parsed = TraceContext::from_traceparent(&header).unwrap();

        assert_eq!(context.trace_id, parsed.trace_id);
        assert_eq!(context.span_id, parsed.span_id);
    }

    #[test]
    fn test_parse_traceparent() {
        let header = "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01";
        let context = TraceContext::from_traceparent(header).unwrap();

        assert_eq!(context.to_traceparent(), header);
    }

    #[test]
    fn test_start_and_end_span() {
        let exporter = MockExporter { exported: std::cell::RefCell::new(vec![]) };
        let mut collector = TraceCollector::new(exporter, default_config());

        let span_id = collector.start_span("test-operation", SpanKind::Internal);

        collector.set_attribute(&span_id, "key", AttributeValue::String("value".to_string())).unwrap();

        collector.end_span(&span_id).unwrap();

        assert_eq!(collector.flush().unwrap(), 1);
    }

    #[test]
    fn test_child_span() {
        let exporter = MockExporter { exported: std::cell::RefCell::new(vec![]) };
        let mut collector = TraceCollector::new(exporter, default_config());

        let parent_id = collector.start_span("parent", SpanKind::Server);
        let parent_context = collector.get_context(&parent_id).unwrap().clone();

        let child_id = collector.start_child_span(&parent_context, "child", SpanKind::Client);
        let child_context = collector.get_context(&child_id).unwrap();

        assert_eq!(child_context.trace_id, parent_context.trace_id);
        assert_eq!(child_context.parent_span_id, Some(parent_context.span_id));
    }

    #[test]
    fn test_span_events() {
        let exporter = MockExporter { exported: std::cell::RefCell::new(vec![]) };
        let mut collector = TraceCollector::new(exporter, default_config());

        let span_id = collector.start_span("with-events", SpanKind::Internal);

        let mut attrs = HashMap::new();
        attrs.insert("error.type".to_string(), AttributeValue::String("timeout".to_string()));

        collector.add_event(&span_id, "exception", attrs).unwrap();
        collector.set_status(&span_id, SpanStatus::Error("timeout".to_string())).unwrap();
        collector.end_span(&span_id).unwrap();
    }

    #[test]
    fn test_sampling() {
        let config = CollectorConfig {
            sample_rate: 0.5,
            ..default_config()
        };

        let exporter = MockExporter { exported: std::cell::RefCell::new(vec![]) };
        let collector = TraceCollector::new(exporter, config);

        let mut sampled = 0;
        for _ in 0..1000 {
            let trace_id = TraceId::new();
            if collector.should_sample(&trace_id) {
                sampled += 1;
            }
        }

        // Should be approximately 500 (50% with some variance)
        assert!(sampled > 400 && sampled < 600);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraceId([u8; 16]);

impl TraceId {
    pub fn new() -> Self {
        let mut bytes = [0u8; 16];
        for byte in &mut bytes {
            *byte = rand::random();
        }
        Self(bytes)
    }

    pub fn from_hex(hex: &str) -> Result<Self, TraceError> {
        if hex.len() != 32 {
            return Err(TraceError::InvalidTraceId("must be 32 hex chars".to_string()));
        }

        let mut bytes = [0u8; 16];
        for (i, chunk) in hex.as_bytes().chunks(2).enumerate() {
            let s = std::str::from_utf8(chunk).map_err(|_| {
                TraceError::InvalidTraceId("invalid utf8".to_string())
            })?;
            bytes[i] = u8::from_str_radix(s, 16).map_err(|_| {
                TraceError::InvalidTraceId("invalid hex".to_string())
            })?;
        }

        Ok(Self(bytes))
    }

    pub fn to_hex(&self) -> String {
        self.0.iter().map(|b| format!("{:02x}", b)).collect()
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpanId([u8; 8]);

impl SpanId {
    pub fn new() -> Self {
        let mut bytes = [0u8; 8];
        for byte in &mut bytes {
            *byte = rand::random();
        }
        Self(bytes)
    }

    pub fn from_hex(hex: &str) -> Result<Self, TraceError> {
        if hex.len() != 16 {
            return Err(TraceError::InvalidSpanId("must be 16 hex chars".to_string()));
        }

        let mut bytes = [0u8; 8];
        for (i, chunk) in hex.as_bytes().chunks(2).enumerate() {
            let s = std::str::from_utf8(chunk).unwrap();
            bytes[i] = u8::from_str_radix(s, 16).unwrap();
        }

        Ok(Self(bytes))
    }

    pub fn to_hex(&self) -> String {
        self.0.iter().map(|b| format!("{:02x}", b)).collect()
    }
}

#[derive(Debug, Clone)]
pub struct TraceContext {
    pub trace_id: TraceId,
    pub span_id: SpanId,
    pub parent_span_id: Option<SpanId>,
    pub trace_flags: u8,
    pub trace_state: HashMap<String, String>,
}

impl TraceContext {
    pub fn from_traceparent(header: &str) -> Result<Self, TraceError> {
        let parts: Vec<&str> = header.split('-').collect();
        if parts.len() != 4 {
            return Err(TraceError::InvalidTraceparent("wrong format".to_string()));
        }

        let trace_id = TraceId::from_hex(parts[1])?;
        let span_id = SpanId::from_hex(parts[2])?;
        let trace_flags = u8::from_str_radix(parts[3], 16)
            .map_err(|_| TraceError::InvalidTraceparent("invalid flags".to_string()))?;

        Ok(Self {
            trace_id,
            span_id,
            parent_span_id: None,
            trace_flags,
            trace_state: HashMap::new(),
        })
    }

    pub fn to_traceparent(&self) -> String {
        format!(
            "00-{}-{}-{:02x}",
            self.trace_id.to_hex(),
            self.span_id.to_hex(),
            self.trace_flags
        )
    }

    pub fn child(&self) -> Self {
        Self {
            trace_id: self.trace_id.clone(),
            span_id: SpanId::new(),
            parent_span_id: Some(self.span_id.clone()),
            trace_flags: self.trace_flags,
            trace_state: self.trace_state.clone(),
        }
    }
}

// ... rest of implementation
```

### 4.9 spec.json

```json
{
  "name": "trace_collector",
  "language": "rust",
  "type": "code",
  "tier": 3,
  "tags": ["observability", "tracing", "distributed", "phase5"],
  "passing_score": 70
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A : Trace ID non unique */
impl TraceId {
    pub fn new() -> Self {
        Self([0u8; 16])  // MUTANT: Toujours le meme ID
    }
}

/* Mutant B : Child garde le meme span_id */
pub fn child(&self) -> Self {
    Self {
        trace_id: self.trace_id.clone(),
        span_id: self.span_id.clone(),  // MUTANT: Pas de nouveau span_id
        parent_span_id: Some(self.span_id.clone()),
        ..
    }
}

/* Mutant C : Traceparent mal formate */
pub fn to_traceparent(&self) -> String {
    format!("{}-{}", self.trace_id.to_hex(), self.span_id.to_hex())  // MUTANT: Format incomplet
}

/* Mutant D : Sampling toujours true */
pub fn should_sample(&self, _trace_id: &TraceId) -> bool {
    true  // MUTANT: Ignore sample_rate
}

/* Mutant E : Span end_time non defini */
pub fn end_span(&mut self, span_id: &SpanId) -> Result<(), TraceError> {
    let span = self.active_spans.remove(span_id)?;
    // MUTANT: Oubli de span.end_time = Some(SystemTime::now())
    self.completed_spans.push(span);
    Ok(())
}
```

---

## SECTION 5 : COMPRENDRE

### 5.2 Visualisation ASCII

```
                    DISTRIBUTED TRACE

    Service A                 Service B                 Service C
    ─────────────────────────────────────────────────────────────
    │                         │                         │
    ├─► Span 1 (root)         │                         │
    │   trace_id: abc123      │                         │
    │   span_id: span001      │                         │
    │   │                     │                         │
    │   └──HTTP──────────────►│                         │
    │                         ├─► Span 2 (child)        │
    │                         │   trace_id: abc123      │
    │                         │   span_id: span002      │
    │                         │   parent: span001       │
    │                         │   │                     │
    │                         │   └──HTTP──────────────►│
    │                         │                         ├─► Span 3
    │                         │                         │   trace_id: abc123
    │                         │                         │   span_id: span003
    │                         │                         │   parent: span002
    │                         │                         │
    │                         │◄─────────────────────────┤
    │                         │                         │
    │◄─────────────────────────┤                         │
    │                         │                         │
    ▼                         ▼                         ▼
```

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | trace_collector |
| **Module** | 5.5.14 - Distributed Tracing |
| **Difficulte** | 8/10 |
| **Temps estime** | 150 min |
| **XP** | 200 |
| **Concepts cles** | Spans, Context Propagation, Sampling |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.5.14-a-trace-collector"
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 97/100*
