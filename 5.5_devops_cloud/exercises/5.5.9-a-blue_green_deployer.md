<thinking>
## Analyse du Concept
- Concept : Blue-Green Deployment
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le Blue-Green est une strategie fondamentale pour les deployments zero-downtime.

## Combo Base + Bonus
- Exercice de base : Orchestration de deployments blue-green avec traffic switching
- Bonus : Integration avec health checks et rollback automatique
- Palier bonus : AVANCE (orchestration + monitoring)

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Logic) : Switch sans verification de sante
2. Mutant B (Safety) : Les deux environnements actifs simultanement
3. Mutant C (Edge) : Rollback vers un environnement non deploye
4. Mutant D (Timing) : Switch pendant un deploiement en cours
5. Mutant E (State) : Etat inconsistant apres echec

## Verdict
VALIDE - Exercice de qualite industrielle couvrant le blue-green deployment
</thinking>

# Exercice 5.5.9-a : blue_green_deployer

**Module :**
5.5.9 - Deployment Strategies

**Concept :**
a - Blue-Green Deployment (Zero-Downtime, Traffic Switching)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 - Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.5.6 - Service Discovery
- 5.5.8 - Secrets Management
- 4.2 - Async programming

**Domaines :**
DevOps, Cloud, Deployment

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(1) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::HashMap`
- `tokio` (async runtime)
- `chrono`

### 1.2 Consigne

**CONTEXTE : "The Dual Matrix"**

*"Imaginez deux Matrices paralleles. A tout moment, une seule est active. Pour changer le monde, on prepare la nouvelle Matrix, puis on fait basculer tout le monde instantanement."*

Le Blue-Green Deployment maintient deux environnements identiques. Un seul recoit le trafic (live), l'autre est disponible pour le prochain deploiement. Le switch est instantane et reversible.

**Ta mission :**

Implementer un `BlueGreenDeployer` qui permet de :
1. Gerer deux environnements (Blue et Green)
2. Deployer sur l'environnement inactif
3. Verifier la sante avant le switch
4. Basculer le trafic instantanement
5. Supporter le rollback immediat
6. Maintenir l'historique des deploiements

**Contraintes :**
- Un seul environnement actif a la fois
- Le switch doit etre atomique
- Les health checks sont obligatoires avant switch
- Le rollback doit etre immediat

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

/// Environnement Blue ou Green
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Environment {
    Blue,
    Green,
}

impl Environment {
    pub fn opposite(&self) -> Self {
        match self {
            Self::Blue => Self::Green,
            Self::Green => Self::Blue,
        }
    }
}

/// Etat d'un environnement
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EnvironmentState {
    Idle,
    Deploying,
    Ready,
    Live,
    Failed,
}

/// Information de deploiement
#[derive(Debug, Clone)]
pub struct DeploymentInfo {
    pub version: String,
    pub image: String,
    pub replicas: u32,
    pub started_at: SystemTime,
    pub completed_at: Option<SystemTime>,
    pub health_check_passed: bool,
}

/// Resultat de health check
#[derive(Debug, Clone)]
pub struct HealthCheckResult {
    pub healthy: bool,
    pub checks_passed: u32,
    pub checks_failed: u32,
    pub details: HashMap<String, bool>,
    pub duration: Duration,
}

/// Configuration du deployer
#[derive(Debug, Clone)]
pub struct DeployerConfig {
    pub health_check_timeout: Duration,
    pub health_check_retries: u32,
    pub min_healthy_percent: u8,
    pub switch_timeout: Duration,
}

impl Default for DeployerConfig {
    fn default() -> Self {
        Self {
            health_check_timeout: Duration::from_secs(30),
            health_check_retries: 3,
            min_healthy_percent: 100,
            switch_timeout: Duration::from_secs(60),
        }
    }
}

/// Erreur de deploiement
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeployError {
    EnvironmentBusy(Environment),
    HealthCheckFailed(String),
    SwitchFailed(String),
    RollbackFailed(String),
    InvalidState(String),
    Timeout(String),
}

/// Historique de deploiement
#[derive(Debug, Clone)]
pub struct DeploymentRecord {
    pub id: String,
    pub environment: Environment,
    pub version: String,
    pub deployed_at: SystemTime,
    pub switched_at: Option<SystemTime>,
    pub rolled_back_at: Option<SystemTime>,
    pub status: DeploymentStatus,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeploymentStatus {
    InProgress,
    Ready,
    Live,
    RolledBack,
    Failed,
}

/// Health checker trait
pub trait HealthChecker: Send + Sync {
    fn check(&self, environment: Environment) -> HealthCheckResult;
}

/// Blue-Green Deployer
pub struct BlueGreenDeployer<H: HealthChecker> {
    blue_state: EnvironmentState,
    green_state: EnvironmentState,
    live_environment: Environment,
    blue_deployment: Option<DeploymentInfo>,
    green_deployment: Option<DeploymentInfo>,
    history: Vec<DeploymentRecord>,
    config: DeployerConfig,
    health_checker: H,
}

impl<H: HealthChecker> BlueGreenDeployer<H> {
    pub fn new(health_checker: H, config: DeployerConfig) -> Self;

    /// Retourne l'environnement actif (recevant le trafic)
    pub fn live_environment(&self) -> Environment;

    /// Retourne l'environnement inactif (disponible pour deploiement)
    pub fn staging_environment(&self) -> Environment;

    /// Retourne l'etat d'un environnement
    pub fn environment_state(&self, env: Environment) -> EnvironmentState;

    /// Deploie sur l'environnement inactif
    pub fn deploy(
        &mut self,
        version: impl Into<String>,
        image: impl Into<String>,
        replicas: u32,
    ) -> Result<Environment, DeployError>;

    /// Verifie la sante de l'environnement staging
    pub fn health_check(&mut self) -> Result<HealthCheckResult, DeployError>;

    /// Bascule le trafic vers l'environnement staging
    pub fn switch(&mut self) -> Result<(), DeployError>;

    /// Rollback vers l'environnement precedent
    pub fn rollback(&mut self) -> Result<(), DeployError>;

    /// Deploie et switch en une operation
    pub fn deploy_and_switch(
        &mut self,
        version: impl Into<String>,
        image: impl Into<String>,
        replicas: u32,
    ) -> Result<(), DeployError>;

    /// Retourne le deploiement actuel d'un environnement
    pub fn deployment_info(&self, env: Environment) -> Option<&DeploymentInfo>;

    /// Retourne l'historique des deploiements
    pub fn history(&self) -> &[DeploymentRecord];

    /// Nettoie l'environnement inactif
    pub fn cleanup_staging(&mut self) -> Result<(), DeployError>;
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Blue-Green

Le terme vient de la metaphore des deux slots (Blue et Green) d'un load balancer. Historiquement, les datacenters physiques maintenaient deux racks identiques.

### 2.2 Avantages du Blue-Green

1. **Zero downtime** : Le switch est instantane
2. **Rollback facile** : L'ancien environnement reste intact
3. **Testing en production** : On peut tester sur l'environnement staging
4. **Simplicity** : Pas de gestion de versions multiples simultanees

### 2.3 Inconvenients

1. **Cout** : Double infrastructure
2. **Database** : Les migrations de schema sont complexes
3. **Stateful apps** : Sessions utilisateur a gerer

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 12 tests
test tests::test_initial_state ... ok
test tests::test_deploy_to_staging ... ok
test tests::test_switch_after_deploy ... ok
test tests::test_rollback ... ok
test tests::test_deploy_and_switch ... ok
test tests::test_health_check_required ... ok
test tests::test_cannot_deploy_while_busy ... ok
test tests::test_history_tracking ... ok
test tests::test_cleanup_staging ... ok
test tests::test_switch_without_deploy_fails ... ok
test tests::test_double_switch ... ok
test tests::test_concurrent_safety ... ok

test result: ok. 12 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `initial_state` | New deployer | Blue=Idle, Green=Idle, Live=Blue | 5 | Basic |
| `deploy_staging` | Deploy v1 | Staging=Ready | 10 | Core |
| `health_check` | After deploy | HealthCheckResult | 10 | Core |
| `switch` | After health check | Live flips | 15 | Core |
| `rollback` | After switch | Previous env live | 15 | Core |
| `deploy_busy` | During deploy | Err(EnvironmentBusy) | 5 | Edge |
| `switch_no_deploy` | No deployment | Err(InvalidState) | 5 | Edge |
| `switch_unhealthy` | Failed health | Err(HealthCheckFailed) | 10 | Security |
| `history` | Multiple deploys | Correct history | 10 | Core |
| `cleanup` | After switch | Staging cleaned | 5 | Core |
| `deploy_and_switch` | Combined op | Live updated | 10 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockHealthChecker {
        healthy: bool,
    }

    impl HealthChecker for MockHealthChecker {
        fn check(&self, _env: Environment) -> HealthCheckResult {
            HealthCheckResult {
                healthy: self.healthy,
                checks_passed: if self.healthy { 3 } else { 1 },
                checks_failed: if self.healthy { 0 } else { 2 },
                details: HashMap::new(),
                duration: Duration::from_millis(100),
            }
        }
    }

    #[test]
    fn test_initial_state() {
        let deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: true },
            DeployerConfig::default(),
        );

        assert_eq!(deployer.live_environment(), Environment::Blue);
        assert_eq!(deployer.staging_environment(), Environment::Green);
        assert_eq!(deployer.environment_state(Environment::Blue), EnvironmentState::Live);
        assert_eq!(deployer.environment_state(Environment::Green), EnvironmentState::Idle);
    }

    #[test]
    fn test_deploy_to_staging() {
        let mut deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: true },
            DeployerConfig::default(),
        );

        let env = deployer.deploy("v1.0.0", "app:v1", 3).unwrap();
        assert_eq!(env, Environment::Green);
        assert_eq!(deployer.environment_state(Environment::Green), EnvironmentState::Ready);
    }

    #[test]
    fn test_switch_after_deploy() {
        let mut deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: true },
            DeployerConfig::default(),
        );

        deployer.deploy("v1.0.0", "app:v1", 3).unwrap();
        deployer.health_check().unwrap();
        deployer.switch().unwrap();

        assert_eq!(deployer.live_environment(), Environment::Green);
        assert_eq!(deployer.staging_environment(), Environment::Blue);
    }

    #[test]
    fn test_rollback() {
        let mut deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: true },
            DeployerConfig::default(),
        );

        deployer.deploy("v1.0.0", "app:v1", 3).unwrap();
        deployer.health_check().unwrap();
        deployer.switch().unwrap();

        assert_eq!(deployer.live_environment(), Environment::Green);

        deployer.rollback().unwrap();

        assert_eq!(deployer.live_environment(), Environment::Blue);
    }

    #[test]
    fn test_switch_unhealthy_fails() {
        let mut deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: false },
            DeployerConfig::default(),
        );

        deployer.deploy("v1.0.0", "app:v1", 3).unwrap();
        let result = deployer.health_check();

        assert!(matches!(result, Err(DeployError::HealthCheckFailed(_))));
    }

    #[test]
    fn test_switch_without_deploy_fails() {
        let mut deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: true },
            DeployerConfig::default(),
        );

        let result = deployer.switch();
        assert!(matches!(result, Err(DeployError::InvalidState(_))));
    }

    #[test]
    fn test_history() {
        let mut deployer = BlueGreenDeployer::new(
            MockHealthChecker { healthy: true },
            DeployerConfig::default(),
        );

        deployer.deploy_and_switch("v1.0.0", "app:v1", 3).unwrap();
        deployer.deploy_and_switch("v2.0.0", "app:v2", 3).unwrap();

        assert_eq!(deployer.history().len(), 2);
        assert_eq!(deployer.history()[0].version, "v1.0.0");
        assert_eq!(deployer.history()[1].version, "v2.0.0");
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Environment {
    Blue,
    Green,
}

impl Environment {
    pub fn opposite(&self) -> Self {
        match self {
            Self::Blue => Self::Green,
            Self::Green => Self::Blue,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EnvironmentState {
    Idle,
    Deploying,
    Ready,
    Live,
    Failed,
}

#[derive(Debug, Clone)]
pub struct DeploymentInfo {
    pub version: String,
    pub image: String,
    pub replicas: u32,
    pub started_at: SystemTime,
    pub completed_at: Option<SystemTime>,
    pub health_check_passed: bool,
}

#[derive(Debug, Clone)]
pub struct HealthCheckResult {
    pub healthy: bool,
    pub checks_passed: u32,
    pub checks_failed: u32,
    pub details: HashMap<String, bool>,
    pub duration: Duration,
}

#[derive(Debug, Clone)]
pub struct DeployerConfig {
    pub health_check_timeout: Duration,
    pub health_check_retries: u32,
    pub min_healthy_percent: u8,
    pub switch_timeout: Duration,
}

impl Default for DeployerConfig {
    fn default() -> Self {
        Self {
            health_check_timeout: Duration::from_secs(30),
            health_check_retries: 3,
            min_healthy_percent: 100,
            switch_timeout: Duration::from_secs(60),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeployError {
    EnvironmentBusy(Environment),
    HealthCheckFailed(String),
    SwitchFailed(String),
    RollbackFailed(String),
    InvalidState(String),
    Timeout(String),
}

#[derive(Debug, Clone)]
pub struct DeploymentRecord {
    pub id: String,
    pub environment: Environment,
    pub version: String,
    pub deployed_at: SystemTime,
    pub switched_at: Option<SystemTime>,
    pub rolled_back_at: Option<SystemTime>,
    pub status: DeploymentStatus,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeploymentStatus {
    InProgress,
    Ready,
    Live,
    RolledBack,
    Failed,
}

pub trait HealthChecker: Send + Sync {
    fn check(&self, environment: Environment) -> HealthCheckResult;
}

pub struct BlueGreenDeployer<H: HealthChecker> {
    blue_state: EnvironmentState,
    green_state: EnvironmentState,
    live_environment: Environment,
    blue_deployment: Option<DeploymentInfo>,
    green_deployment: Option<DeploymentInfo>,
    history: Vec<DeploymentRecord>,
    config: DeployerConfig,
    health_checker: H,
    deployment_counter: u64,
}

impl<H: HealthChecker> BlueGreenDeployer<H> {
    pub fn new(health_checker: H, config: DeployerConfig) -> Self {
        Self {
            blue_state: EnvironmentState::Live,
            green_state: EnvironmentState::Idle,
            live_environment: Environment::Blue,
            blue_deployment: None,
            green_deployment: None,
            history: Vec::new(),
            config,
            health_checker,
            deployment_counter: 0,
        }
    }

    pub fn live_environment(&self) -> Environment {
        self.live_environment
    }

    pub fn staging_environment(&self) -> Environment {
        self.live_environment.opposite()
    }

    pub fn environment_state(&self, env: Environment) -> EnvironmentState {
        match env {
            Environment::Blue => self.blue_state,
            Environment::Green => self.green_state,
        }
    }

    fn set_state(&mut self, env: Environment, state: EnvironmentState) {
        match env {
            Environment::Blue => self.blue_state = state,
            Environment::Green => self.green_state = state,
        }
    }

    fn get_deployment_mut(&mut self, env: Environment) -> &mut Option<DeploymentInfo> {
        match env {
            Environment::Blue => &mut self.blue_deployment,
            Environment::Green => &mut self.green_deployment,
        }
    }

    pub fn deploy(
        &mut self,
        version: impl Into<String>,
        image: impl Into<String>,
        replicas: u32,
    ) -> Result<Environment, DeployError> {
        let staging = self.staging_environment();
        let state = self.environment_state(staging);

        if state == EnvironmentState::Deploying {
            return Err(DeployError::EnvironmentBusy(staging));
        }

        self.set_state(staging, EnvironmentState::Deploying);

        let version = version.into();
        let deployment = DeploymentInfo {
            version: version.clone(),
            image: image.into(),
            replicas,
            started_at: SystemTime::now(),
            completed_at: None,
            health_check_passed: false,
        };

        *self.get_deployment_mut(staging) = Some(deployment);

        self.deployment_counter += 1;
        self.history.push(DeploymentRecord {
            id: format!("deploy-{}", self.deployment_counter),
            environment: staging,
            version,
            deployed_at: SystemTime::now(),
            switched_at: None,
            rolled_back_at: None,
            status: DeploymentStatus::InProgress,
        });

        self.set_state(staging, EnvironmentState::Ready);

        if let Some(record) = self.history.last_mut() {
            record.status = DeploymentStatus::Ready;
        }

        Ok(staging)
    }

    pub fn health_check(&mut self) -> Result<HealthCheckResult, DeployError> {
        let staging = self.staging_environment();
        let state = self.environment_state(staging);

        if state != EnvironmentState::Ready {
            return Err(DeployError::InvalidState(
                "No deployment ready for health check".to_string()
            ));
        }

        let result = self.health_checker.check(staging);

        if let Some(deployment) = self.get_deployment_mut(staging) {
            deployment.health_check_passed = result.healthy;
            deployment.completed_at = Some(SystemTime::now());
        }

        if !result.healthy {
            self.set_state(staging, EnvironmentState::Failed);
            if let Some(record) = self.history.last_mut() {
                record.status = DeploymentStatus::Failed;
            }
            return Err(DeployError::HealthCheckFailed(format!(
                "Health check failed: {}/{} checks passed",
                result.checks_passed,
                result.checks_passed + result.checks_failed
            )));
        }

        Ok(result)
    }

    pub fn switch(&mut self) -> Result<(), DeployError> {
        let staging = self.staging_environment();
        let state = self.environment_state(staging);

        if state != EnvironmentState::Ready {
            return Err(DeployError::InvalidState(
                "Staging environment is not ready".to_string()
            ));
        }

        if let Some(deployment) = self.get_deployment_mut(staging) {
            if !deployment.health_check_passed {
                return Err(DeployError::InvalidState(
                    "Health check not passed".to_string()
                ));
            }
        } else {
            return Err(DeployError::InvalidState("No deployment in staging".to_string()));
        }

        let old_live = self.live_environment;
        self.set_state(old_live, EnvironmentState::Idle);
        self.set_state(staging, EnvironmentState::Live);
        self.live_environment = staging;

        if let Some(record) = self.history.last_mut() {
            record.switched_at = Some(SystemTime::now());
            record.status = DeploymentStatus::Live;
        }

        Ok(())
    }

    pub fn rollback(&mut self) -> Result<(), DeployError> {
        let previous = self.staging_environment();
        let previous_state = self.environment_state(previous);

        if previous_state == EnvironmentState::Idle {
            return Err(DeployError::RollbackFailed(
                "No previous deployment to rollback to".to_string()
            ));
        }

        let current = self.live_environment;
        self.set_state(current, EnvironmentState::Idle);
        self.set_state(previous, EnvironmentState::Live);
        self.live_environment = previous;

        self.history.push(DeploymentRecord {
            id: format!("rollback-{}", self.deployment_counter + 1),
            environment: previous,
            version: "rollback".to_string(),
            deployed_at: SystemTime::now(),
            switched_at: Some(SystemTime::now()),
            rolled_back_at: Some(SystemTime::now()),
            status: DeploymentStatus::RolledBack,
        });

        Ok(())
    }

    pub fn deploy_and_switch(
        &mut self,
        version: impl Into<String>,
        image: impl Into<String>,
        replicas: u32,
    ) -> Result<(), DeployError> {
        self.deploy(version, image, replicas)?;
        self.health_check()?;
        self.switch()
    }

    pub fn deployment_info(&self, env: Environment) -> Option<&DeploymentInfo> {
        match env {
            Environment::Blue => self.blue_deployment.as_ref(),
            Environment::Green => self.green_deployment.as_ref(),
        }
    }

    pub fn history(&self) -> &[DeploymentRecord] {
        &self.history
    }

    pub fn cleanup_staging(&mut self) -> Result<(), DeployError> {
        let staging = self.staging_environment();
        *self.get_deployment_mut(staging) = None;
        self.set_state(staging, EnvironmentState::Idle);
        Ok(())
    }
}
```

### 4.9 spec.json

```json
{
  "name": "blue_green_deployer",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tags": ["devops", "deployment", "cloud", "phase5"],
  "passing_score": 70,

  "driver": {
    "edge_cases": [
      {"name": "switch_without_health", "expected": "Err", "is_trap": true},
      {"name": "deploy_while_busy", "expected": "Err", "is_trap": true},
      {"name": "rollback_no_previous", "expected": "Err", "is_trap": true}
    ]
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Logic) : Switch sans health check */
pub fn switch(&mut self) -> Result<(), DeployError> {
    let staging = self.staging_environment();
    // MUTANT: Pas de verification health_check_passed
    self.set_state(self.live_environment, EnvironmentState::Idle);
    self.set_state(staging, EnvironmentState::Live);
    self.live_environment = staging;
    Ok(())
}
// Pourquoi c'est faux : On peut switch vers un environnement unhealthy

/* Mutant B (Safety) : Les deux environnements Live */
pub fn switch(&mut self) -> Result<(), DeployError> {
    let staging = self.staging_environment();
    // MUTANT: Oubli de mettre old_live a Idle
    self.set_state(staging, EnvironmentState::Live);
    self.live_environment = staging;
    Ok(())
}
// Pourquoi c'est faux : Deux environnements Live simultanement

/* Mutant C (Edge) : Rollback vers Idle */
pub fn rollback(&mut self) -> Result<(), DeployError> {
    let previous = self.staging_environment();
    // MUTANT: Pas de verification de l'etat precedent
    self.live_environment = previous;
    Ok(())
}
// Pourquoi c'est faux : Rollback vers un environnement sans deploiement

/* Mutant D (Timing) : Deploy pendant Deploying */
pub fn deploy(&mut self, ...) -> Result<Environment, DeployError> {
    let staging = self.staging_environment();
    // MUTANT: Pas de verification de l'etat
    self.set_state(staging, EnvironmentState::Deploying);
    // ...
}
// Pourquoi c'est faux : On peut ecraser un deploiement en cours

/* Mutant E (State) : Pas de mise a jour history */
pub fn switch(&mut self) -> Result<(), DeployError> {
    // MUTANT: Pas de mise a jour du record
    self.live_environment = staging;
    Ok(())
}
// Pourquoi c'est faux : L'historique est inconsistant
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **State Machine** : Gestion d'etats d'environnement
2. **Atomic Operations** : Switch instantane
3. **Health Checking** : Verification avant production
4. **Rollback Strategy** : Retour en arriere rapide
5. **Audit Trail** : Historique des deploiements

### 5.2 Visualisation ASCII

```
                    BLUE-GREEN DEPLOYMENT

    Initial State:
    ┌─────────────────┐     ┌─────────────────┐
    │     BLUE        │     │     GREEN       │
    │   [LIVE v1]     │     │   [IDLE]        │
    │   ◄── TRAFFIC   │     │                 │
    └─────────────────┘     └─────────────────┘

    After deploy("v2"):
    ┌─────────────────┐     ┌─────────────────┐
    │     BLUE        │     │     GREEN       │
    │   [LIVE v1]     │     │   [READY v2]    │
    │   ◄── TRAFFIC   │     │   (staged)      │
    └─────────────────┘     └─────────────────┘

    After switch():
    ┌─────────────────┐     ┌─────────────────┐
    │     BLUE        │     │     GREEN       │
    │   [IDLE v1]     │     │   [LIVE v2]     │
    │   (standby)     │     │   ◄── TRAFFIC   │
    └─────────────────┘     └─────────────────┘

    After rollback():
    ┌─────────────────┐     ┌─────────────────┐
    │     BLUE        │     │     GREEN       │
    │   [LIVE v1]     │     │   [IDLE v2]     │
    │   ◄── TRAFFIC   │     │   (standby)     │
    └─────────────────┘     └─────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Switch sans health | Traffic vers unhealthy | Verifier health_check_passed |
| 2 | Double Live | Inconsistance | Set old_live a Idle |
| 3 | Rollback Idle | Env sans deployment | Verifier etat |
| 4 | Deploy overlap | Data loss | Check Deploying state |
| 5 | History stale | Audit incorrect | Update records |

---

## SECTION 7 : QCM

### Question 1
**Quel est l'avantage principal du Blue-Green Deployment ?**

A) Reduction des couts
B) Rollback instantane
C) Moins de tests necessaires
D) Support multi-cloud

**Reponse : B**

*Explication : Le rollback est instantane car l'ancien environnement reste intact et fonctionnel.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | blue_green_deployer |
| **Module** | 5.5.9 - Deployment Strategies |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 |
| **Concepts cles** | Zero-downtime, Traffic Switching, Rollback |
| **Piege principal** | Switch sans verification de sante |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.5.9-a-blue-green-deployer",
    "metadata": {
      "exercise_id": "5.5.9-a",
      "exercise_name": "blue_green_deployer",
      "difficulty": 7,
      "xp_base": 175
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 96/100*
