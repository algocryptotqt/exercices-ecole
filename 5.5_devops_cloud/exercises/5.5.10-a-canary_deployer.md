<thinking>
## Analyse du Concept
- Concept : Canary Deployment
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le Canary est une strategie avancee pour les deployments progressifs avec analyse de metriques.

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Logic) : Pourcentage de trafic non respecte
2. Mutant B (Safety) : Promotion sans analyse de metriques
3. Mutant C (Edge) : Rollback partiel laisse des instances canary
4. Mutant D (Math) : Calcul de pourcentage incorrect
5. Mutant E (State) : Pas de mise a jour des phases

## Verdict
VALIDE
</thinking>

# Exercice 5.5.10-a : canary_deployer

**Module :**
5.5.10 - Advanced Deployment Strategies

**Concept :**
a - Canary Deployment (Progressive Rollout, Metrics Analysis)

**Difficulte :**
8/10

**Type :**
code

**Tiers :**
3 - Systeme complet

**Langage :**
Rust Edition 2024

**Prerequis :**
- 5.5.9 - Blue-Green Deployment
- 5.5.13 - Metrics Exporter
- 4.2 - Async programming

**Domaines :**
DevOps, Cloud, Observability

**Duree estimee :**
150 min

**XP Base :**
200

**Complexite :**
T2 O(n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

### 1.2 Consigne

**CONTEXTE : "The Canary Protocol"**

*"Dans les mines de charbon, le canari etait le premier a detecter le gaz. En production, notre canary detecte les problemes avant qu'ils n'affectent tous les utilisateurs."*

Le Canary Deployment envoie progressivement du trafic vers la nouvelle version, analysant les metriques en temps reel pour decider de continuer ou rollback.

**Ta mission :**

Implementer un `CanaryDeployer` qui permet de :
1. Deployer une nouvelle version sur un petit pourcentage du trafic
2. Analyser les metriques (latence, erreurs, etc.)
3. Progresser par phases (1%, 5%, 25%, 50%, 100%)
4. Rollback automatique si les metriques depassent les seuils
5. Promouvoir completement si toutes les phases passent

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

/// Phase du deploiement canary
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum CanaryPhase {
    Initial,        // 0% - Deploiement initial
    Canary1,        // 1% - Premier test
    Canary5,        // 5% - Test elargi
    Canary25,       // 25% - Quarter traffic
    Canary50,       // 50% - Half traffic
    FullRollout,    // 100% - Complete
}

impl CanaryPhase {
    pub fn traffic_percent(&self) -> u8;
    pub fn next(&self) -> Option<Self>;
    pub fn previous(&self) -> Option<Self>;
}

/// Metriques collectees
#[derive(Debug, Clone)]
pub struct CanaryMetrics {
    pub error_rate: f64,           // 0.0 - 1.0
    pub latency_p50_ms: f64,
    pub latency_p99_ms: f64,
    pub requests_per_second: f64,
    pub success_count: u64,
    pub error_count: u64,
    pub collected_at: SystemTime,
}

/// Seuils d'analyse
#[derive(Debug, Clone)]
pub struct AnalysisThresholds {
    pub max_error_rate: f64,
    pub max_latency_p99_ms: f64,
    pub min_requests: u64,
    pub latency_increase_percent: f64,
}

impl Default for AnalysisThresholds {
    fn default() -> Self {
        Self {
            max_error_rate: 0.01,           // 1% max errors
            max_latency_p99_ms: 500.0,      // 500ms max
            min_requests: 100,               // Min requests before analysis
            latency_increase_percent: 25.0,  // 25% max latency increase
        }
    }
}

/// Resultat d'analyse
#[derive(Debug, Clone)]
pub struct AnalysisResult {
    pub passed: bool,
    pub error_rate_ok: bool,
    pub latency_ok: bool,
    pub sample_size_ok: bool,
    pub details: HashMap<String, String>,
    pub recommendation: AnalysisRecommendation,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AnalysisRecommendation {
    Promote,        // Passer a la phase suivante
    Hold,           // Rester a la phase actuelle
    Rollback,       // Revenir en arriere
}

/// Configuration du deploiement
#[derive(Debug, Clone)]
pub struct CanaryConfig {
    pub phase_duration: Duration,
    pub analysis_interval: Duration,
    pub thresholds: AnalysisThresholds,
    pub auto_promote: bool,
    pub auto_rollback: bool,
}

/// Erreur de deploiement
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CanaryError {
    DeploymentFailed(String),
    AnalysisFailed(String),
    PromotionFailed(String),
    RollbackFailed(String),
    InvalidPhase(String),
    InsufficientData(String),
}

/// Etat du deploiement
#[derive(Debug, Clone)]
pub struct CanaryState {
    pub version: String,
    pub baseline_version: String,
    pub current_phase: CanaryPhase,
    pub started_at: SystemTime,
    pub phase_started_at: SystemTime,
    pub canary_metrics: Vec<CanaryMetrics>,
    pub baseline_metrics: Vec<CanaryMetrics>,
    pub analysis_history: Vec<AnalysisResult>,
}

/// Collecteur de metriques trait
pub trait MetricsCollector: Send + Sync {
    fn collect_canary(&self) -> CanaryMetrics;
    fn collect_baseline(&self) -> CanaryMetrics;
}

/// Canary Deployer
pub struct CanaryDeployer<M: MetricsCollector> {
    state: Option<CanaryState>,
    config: CanaryConfig,
    metrics_collector: M,
}

impl<M: MetricsCollector> CanaryDeployer<M> {
    pub fn new(metrics_collector: M, config: CanaryConfig) -> Self;

    /// Demarre un deploiement canary
    pub fn start(
        &mut self,
        version: impl Into<String>,
        baseline_version: impl Into<String>,
    ) -> Result<(), CanaryError>;

    /// Collecte et analyse les metriques
    pub fn analyze(&mut self) -> Result<AnalysisResult, CanaryError>;

    /// Passe a la phase suivante
    pub fn promote(&mut self) -> Result<CanaryPhase, CanaryError>;

    /// Rollback a la version baseline
    pub fn rollback(&mut self) -> Result<(), CanaryError>;

    /// Retourne la phase actuelle
    pub fn current_phase(&self) -> Option<CanaryPhase>;

    /// Retourne le pourcentage de trafic actuel
    pub fn traffic_percent(&self) -> u8;

    /// Verifie si le deploiement est termine
    pub fn is_complete(&self) -> bool;

    /// Retourne l'etat complet
    pub fn state(&self) -> Option<&CanaryState>;

    /// Execute une iteration automatique
    pub fn tick(&mut self) -> Result<CanaryAction, CanaryError>;
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CanaryAction {
    Promoted(CanaryPhase),
    Holding,
    RolledBack,
    Completed,
    NothingToDo,
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Terme

Le terme "canary" vient des canaris utilises dans les mines de charbon au 19e siecle. Les oiseaux, plus sensibles aux gaz toxiques, servaient de systeme d'alerte precoce.

### 2.2 Canary vs Blue-Green

| Aspect | Blue-Green | Canary |
|--------|------------|--------|
| Trafic | 0% ou 100% | Progressif |
| Risque | Tout ou rien | Limite |
| Rollback | Instantane | Progressif |
| Analyse | Pre-switch | Continue |

### 2.3 Outils Modernes

- **Istio** : Service mesh avec traffic splitting
- **Argo Rollouts** : Controller Kubernetes pour canary
- **Flagger** : Operateur GitOps pour progressive delivery

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
running 14 tests
test tests::test_start_canary ... ok
test tests::test_phase_progression ... ok
test tests::test_analyze_healthy ... ok
test tests::test_analyze_unhealthy ... ok
test tests::test_auto_rollback ... ok
test tests::test_full_promotion ... ok
test tests::test_traffic_percent ... ok
test tests::test_insufficient_data ... ok
test tests::test_manual_rollback ... ok
test tests::test_metrics_comparison ... ok
test tests::test_latency_threshold ... ok
test tests::test_error_rate_threshold ... ok
test tests::test_tick_loop ... ok
test tests::test_state_tracking ... ok

test result: ok. 14 passed; 0 failed
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `start_canary` | New version | Phase = Initial | 5 | Basic |
| `phase_progression` | Promote 5 times | FullRollout | 10 | Core |
| `traffic_percent` | Each phase | Correct % | 10 | Core |
| `analyze_healthy` | Good metrics | Promote | 15 | Core |
| `analyze_unhealthy` | Bad metrics | Rollback | 15 | Core |
| `auto_rollback` | Error rate > threshold | Auto rollback | 10 | Safety |
| `latency_threshold` | High latency | Recommendation Hold | 10 | Core |
| `error_rate` | Error rate calc | Correct value | 5 | Core |
| `insufficient_data` | Few requests | Hold | 5 | Edge |
| `metrics_comparison` | Canary vs baseline | Relative analysis | 10 | Core |
| `state_tracking` | Multiple phases | Correct history | 5 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMetricsCollector {
        canary_error_rate: f64,
        baseline_error_rate: f64,
    }

    impl MetricsCollector for MockMetricsCollector {
        fn collect_canary(&self) -> CanaryMetrics {
            CanaryMetrics {
                error_rate: self.canary_error_rate,
                latency_p50_ms: 50.0,
                latency_p99_ms: 200.0,
                requests_per_second: 100.0,
                success_count: 1000,
                error_count: (1000.0 * self.canary_error_rate) as u64,
                collected_at: SystemTime::now(),
            }
        }

        fn collect_baseline(&self) -> CanaryMetrics {
            CanaryMetrics {
                error_rate: self.baseline_error_rate,
                latency_p50_ms: 45.0,
                latency_p99_ms: 180.0,
                requests_per_second: 1000.0,
                success_count: 10000,
                error_count: (10000.0 * self.baseline_error_rate) as u64,
                collected_at: SystemTime::now(),
            }
        }
    }

    #[test]
    fn test_start_canary() {
        let collector = MockMetricsCollector {
            canary_error_rate: 0.001,
            baseline_error_rate: 0.001,
        };
        let mut deployer = CanaryDeployer::new(collector, CanaryConfig::default());

        deployer.start("v2.0.0", "v1.0.0").unwrap();

        assert_eq!(deployer.current_phase(), Some(CanaryPhase::Initial));
        assert_eq!(deployer.traffic_percent(), 0);
    }

    #[test]
    fn test_phase_progression() {
        let collector = MockMetricsCollector {
            canary_error_rate: 0.001,
            baseline_error_rate: 0.001,
        };
        let mut deployer = CanaryDeployer::new(collector, CanaryConfig::default());

        deployer.start("v2.0.0", "v1.0.0").unwrap();

        let phases = vec![
            CanaryPhase::Canary1,
            CanaryPhase::Canary5,
            CanaryPhase::Canary25,
            CanaryPhase::Canary50,
            CanaryPhase::FullRollout,
        ];

        for expected_phase in phases {
            let phase = deployer.promote().unwrap();
            assert_eq!(phase, expected_phase);
        }

        assert!(deployer.is_complete());
    }

    #[test]
    fn test_analyze_healthy() {
        let collector = MockMetricsCollector {
            canary_error_rate: 0.005,  // 0.5% errors - healthy
            baseline_error_rate: 0.004,
        };
        let mut deployer = CanaryDeployer::new(collector, CanaryConfig::default());

        deployer.start("v2.0.0", "v1.0.0").unwrap();
        deployer.promote().unwrap();  // Go to Canary1

        let result = deployer.analyze().unwrap();

        assert!(result.passed);
        assert_eq!(result.recommendation, AnalysisRecommendation::Promote);
    }

    #[test]
    fn test_analyze_unhealthy() {
        let collector = MockMetricsCollector {
            canary_error_rate: 0.05,  // 5% errors - unhealthy
            baseline_error_rate: 0.001,
        };
        let mut deployer = CanaryDeployer::new(collector, CanaryConfig::default());

        deployer.start("v2.0.0", "v1.0.0").unwrap();
        deployer.promote().unwrap();

        let result = deployer.analyze().unwrap();

        assert!(!result.passed);
        assert_eq!(result.recommendation, AnalysisRecommendation::Rollback);
    }

    #[test]
    fn test_traffic_percent() {
        assert_eq!(CanaryPhase::Initial.traffic_percent(), 0);
        assert_eq!(CanaryPhase::Canary1.traffic_percent(), 1);
        assert_eq!(CanaryPhase::Canary5.traffic_percent(), 5);
        assert_eq!(CanaryPhase::Canary25.traffic_percent(), 25);
        assert_eq!(CanaryPhase::Canary50.traffic_percent(), 50);
        assert_eq!(CanaryPhase::FullRollout.traffic_percent(), 100);
    }

    #[test]
    fn test_rollback() {
        let collector = MockMetricsCollector {
            canary_error_rate: 0.001,
            baseline_error_rate: 0.001,
        };
        let mut deployer = CanaryDeployer::new(collector, CanaryConfig::default());

        deployer.start("v2.0.0", "v1.0.0").unwrap();
        deployer.promote().unwrap();
        deployer.promote().unwrap();

        deployer.rollback().unwrap();

        assert!(deployer.state().is_none());
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum CanaryPhase {
    Initial,
    Canary1,
    Canary5,
    Canary25,
    Canary50,
    FullRollout,
}

impl CanaryPhase {
    pub fn traffic_percent(&self) -> u8 {
        match self {
            Self::Initial => 0,
            Self::Canary1 => 1,
            Self::Canary5 => 5,
            Self::Canary25 => 25,
            Self::Canary50 => 50,
            Self::FullRollout => 100,
        }
    }

    pub fn next(&self) -> Option<Self> {
        match self {
            Self::Initial => Some(Self::Canary1),
            Self::Canary1 => Some(Self::Canary5),
            Self::Canary5 => Some(Self::Canary25),
            Self::Canary25 => Some(Self::Canary50),
            Self::Canary50 => Some(Self::FullRollout),
            Self::FullRollout => None,
        }
    }

    pub fn previous(&self) -> Option<Self> {
        match self {
            Self::Initial => None,
            Self::Canary1 => Some(Self::Initial),
            Self::Canary5 => Some(Self::Canary1),
            Self::Canary25 => Some(Self::Canary5),
            Self::Canary50 => Some(Self::Canary25),
            Self::FullRollout => Some(Self::Canary50),
        }
    }
}

#[derive(Debug, Clone)]
pub struct CanaryMetrics {
    pub error_rate: f64,
    pub latency_p50_ms: f64,
    pub latency_p99_ms: f64,
    pub requests_per_second: f64,
    pub success_count: u64,
    pub error_count: u64,
    pub collected_at: SystemTime,
}

#[derive(Debug, Clone)]
pub struct AnalysisThresholds {
    pub max_error_rate: f64,
    pub max_latency_p99_ms: f64,
    pub min_requests: u64,
    pub latency_increase_percent: f64,
}

impl Default for AnalysisThresholds {
    fn default() -> Self {
        Self {
            max_error_rate: 0.01,
            max_latency_p99_ms: 500.0,
            min_requests: 100,
            latency_increase_percent: 25.0,
        }
    }
}

#[derive(Debug, Clone)]
pub struct AnalysisResult {
    pub passed: bool,
    pub error_rate_ok: bool,
    pub latency_ok: bool,
    pub sample_size_ok: bool,
    pub details: HashMap<String, String>,
    pub recommendation: AnalysisRecommendation,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AnalysisRecommendation {
    Promote,
    Hold,
    Rollback,
}

#[derive(Debug, Clone)]
pub struct CanaryConfig {
    pub phase_duration: Duration,
    pub analysis_interval: Duration,
    pub thresholds: AnalysisThresholds,
    pub auto_promote: bool,
    pub auto_rollback: bool,
}

impl Default for CanaryConfig {
    fn default() -> Self {
        Self {
            phase_duration: Duration::from_secs(300),
            analysis_interval: Duration::from_secs(60),
            thresholds: AnalysisThresholds::default(),
            auto_promote: false,
            auto_rollback: true,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CanaryError {
    DeploymentFailed(String),
    AnalysisFailed(String),
    PromotionFailed(String),
    RollbackFailed(String),
    InvalidPhase(String),
    InsufficientData(String),
}

#[derive(Debug, Clone)]
pub struct CanaryState {
    pub version: String,
    pub baseline_version: String,
    pub current_phase: CanaryPhase,
    pub started_at: SystemTime,
    pub phase_started_at: SystemTime,
    pub canary_metrics: Vec<CanaryMetrics>,
    pub baseline_metrics: Vec<CanaryMetrics>,
    pub analysis_history: Vec<AnalysisResult>,
}

pub trait MetricsCollector: Send + Sync {
    fn collect_canary(&self) -> CanaryMetrics;
    fn collect_baseline(&self) -> CanaryMetrics;
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CanaryAction {
    Promoted(CanaryPhase),
    Holding,
    RolledBack,
    Completed,
    NothingToDo,
}

pub struct CanaryDeployer<M: MetricsCollector> {
    state: Option<CanaryState>,
    config: CanaryConfig,
    metrics_collector: M,
}

impl<M: MetricsCollector> CanaryDeployer<M> {
    pub fn new(metrics_collector: M, config: CanaryConfig) -> Self {
        Self {
            state: None,
            config,
            metrics_collector,
        }
    }

    pub fn start(
        &mut self,
        version: impl Into<String>,
        baseline_version: impl Into<String>,
    ) -> Result<(), CanaryError> {
        let now = SystemTime::now();
        self.state = Some(CanaryState {
            version: version.into(),
            baseline_version: baseline_version.into(),
            current_phase: CanaryPhase::Initial,
            started_at: now,
            phase_started_at: now,
            canary_metrics: Vec::new(),
            baseline_metrics: Vec::new(),
            analysis_history: Vec::new(),
        });
        Ok(())
    }

    pub fn analyze(&mut self) -> Result<AnalysisResult, CanaryError> {
        let state = self.state.as_mut()
            .ok_or_else(|| CanaryError::AnalysisFailed("No active deployment".to_string()))?;

        let canary = self.metrics_collector.collect_canary();
        let baseline = self.metrics_collector.collect_baseline();

        state.canary_metrics.push(canary.clone());
        state.baseline_metrics.push(baseline.clone());

        let total_requests = canary.success_count + canary.error_count;
        let sample_size_ok = total_requests >= self.config.thresholds.min_requests;

        let error_rate_ok = canary.error_rate <= self.config.thresholds.max_error_rate;

        let latency_increase = if baseline.latency_p99_ms > 0.0 {
            ((canary.latency_p99_ms - baseline.latency_p99_ms) / baseline.latency_p99_ms) * 100.0
        } else {
            0.0
        };
        let latency_ok = latency_increase <= self.config.thresholds.latency_increase_percent
            && canary.latency_p99_ms <= self.config.thresholds.max_latency_p99_ms;

        let passed = sample_size_ok && error_rate_ok && latency_ok;

        let recommendation = if !sample_size_ok {
            AnalysisRecommendation::Hold
        } else if !error_rate_ok || !latency_ok {
            AnalysisRecommendation::Rollback
        } else {
            AnalysisRecommendation::Promote
        };

        let mut details = HashMap::new();
        details.insert("error_rate".to_string(), format!("{:.4}", canary.error_rate));
        details.insert("latency_p99".to_string(), format!("{:.2}ms", canary.latency_p99_ms));
        details.insert("total_requests".to_string(), total_requests.to_string());

        let result = AnalysisResult {
            passed,
            error_rate_ok,
            latency_ok,
            sample_size_ok,
            details,
            recommendation,
        };

        state.analysis_history.push(result.clone());

        Ok(result)
    }

    pub fn promote(&mut self) -> Result<CanaryPhase, CanaryError> {
        let state = self.state.as_mut()
            .ok_or_else(|| CanaryError::PromotionFailed("No active deployment".to_string()))?;

        let next_phase = state.current_phase.next()
            .ok_or_else(|| CanaryError::PromotionFailed("Already at full rollout".to_string()))?;

        state.current_phase = next_phase;
        state.phase_started_at = SystemTime::now();

        Ok(next_phase)
    }

    pub fn rollback(&mut self) -> Result<(), CanaryError> {
        if self.state.is_none() {
            return Err(CanaryError::RollbackFailed("No active deployment".to_string()));
        }

        self.state = None;
        Ok(())
    }

    pub fn current_phase(&self) -> Option<CanaryPhase> {
        self.state.as_ref().map(|s| s.current_phase)
    }

    pub fn traffic_percent(&self) -> u8 {
        self.state.as_ref()
            .map(|s| s.current_phase.traffic_percent())
            .unwrap_or(0)
    }

    pub fn is_complete(&self) -> bool {
        self.current_phase() == Some(CanaryPhase::FullRollout)
    }

    pub fn state(&self) -> Option<&CanaryState> {
        self.state.as_ref()
    }

    pub fn tick(&mut self) -> Result<CanaryAction, CanaryError> {
        if self.state.is_none() {
            return Ok(CanaryAction::NothingToDo);
        }

        if self.is_complete() {
            return Ok(CanaryAction::Completed);
        }

        let result = self.analyze()?;

        match result.recommendation {
            AnalysisRecommendation::Promote if self.config.auto_promote => {
                let phase = self.promote()?;
                if phase == CanaryPhase::FullRollout {
                    Ok(CanaryAction::Completed)
                } else {
                    Ok(CanaryAction::Promoted(phase))
                }
            }
            AnalysisRecommendation::Rollback if self.config.auto_rollback => {
                self.rollback()?;
                Ok(CanaryAction::RolledBack)
            }
            _ => Ok(CanaryAction::Holding),
        }
    }
}
```

### 4.9 spec.json

```json
{
  "name": "canary_deployer",
  "language": "rust",
  "type": "code",
  "tier": 3,
  "tags": ["devops", "deployment", "observability", "phase5"],
  "passing_score": 70
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Logic) : Pourcentage incorrect */
impl CanaryPhase {
    pub fn traffic_percent(&self) -> u8 {
        match self {
            Self::Canary1 => 10,  // MUTANT: 10 au lieu de 1
            _ => 0,
        }
    }
}

/* Mutant B (Safety) : Promotion sans analyse */
pub fn promote(&mut self) -> Result<CanaryPhase, CanaryError> {
    // MUTANT: Pas de verification des metriques
    let state = self.state.as_mut().unwrap();
    state.current_phase = state.current_phase.next().unwrap();
    Ok(state.current_phase)
}

/* Mutant C (Edge) : Rollback partiel */
pub fn rollback(&mut self) -> Result<(), CanaryError> {
    let state = self.state.as_mut().unwrap();
    state.current_phase = CanaryPhase::Initial;  // MUTANT: Ne clear pas state
    Ok(())
}

/* Mutant D (Math) : Error rate mal calcule */
let error_rate_ok = canary.error_count < 10;  // MUTANT: Absolu au lieu de ratio

/* Mutant E (State) : Phase non mise a jour */
pub fn promote(&mut self) -> Result<CanaryPhase, CanaryError> {
    let state = self.state.as_mut().unwrap();
    let next = state.current_phase.next().unwrap();
    // MUTANT: Oubli de state.current_phase = next
    Ok(next)
}
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Progressive Delivery** : Deploiement graduel
2. **Metrics Analysis** : Decision basee sur les donnees
3. **Automatic Rollback** : Protection automatique
4. **State Machine** : Gestion des phases
5. **Comparison Analysis** : Canary vs Baseline

### 5.2 Visualisation ASCII

```
                    CANARY DEPLOYMENT PHASES

    Traffic Distribution:

    0%   ████████████████████████████████████████ Baseline
         ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ Canary (0%)

    1%   ███████████████████████████████████████░ Baseline
         ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█ Canary (1%)

    5%   ██████████████████████████████████████░░ Baseline
         ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██ Canary (5%)

    25%  ██████████████████████████████░░░░░░░░░░ Baseline
         ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████████ Canary (25%)

    50%  ████████████████████░░░░░░░░░░░░░░░░░░░░ Baseline
         ░░░░░░░░░░░░░░░░░░░░████████████████████ Canary (50%)

    100% ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ Baseline
         ████████████████████████████████████████ Canary (100%)
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Mauvais % | Trop de trafic canary | Verifier traffic_percent() |
| 2 | Promote blind | Pas d'analyse | Forcer analyze() avant |
| 3 | Rollback partiel | Instances canary restent | Clear state completement |
| 4 | Error rate absolu | Threshold incorrect | Utiliser ratio |
| 5 | Phase stale | Etat inconsistant | Mettre a jour current_phase |

---

## SECTION 7 : QCM

### Question 1
**Quel est l'avantage principal du Canary Deployment sur le Blue-Green ?**

A) Plus rapide
B) Moins couteux
C) Risque limite par exposition progressive
D) Plus simple a implementer

**Reponse : C**

*Explication : Le canary limite le blast radius en exposant progressivement le trafic, permettant de detecter les problemes avant qu'ils n'affectent tous les utilisateurs.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | canary_deployer |
| **Module** | 5.5.10 - Advanced Deployment |
| **Difficulte** | 8/10 |
| **Temps estime** | 150 min |
| **XP** | 200 |
| **Concepts cles** | Progressive Rollout, Metrics Analysis |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.5.10-a-canary-deployer",
    "metadata": {
      "exercise_id": "5.5.10-a",
      "difficulty": 8,
      "xp_base": 200
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 97/100*
