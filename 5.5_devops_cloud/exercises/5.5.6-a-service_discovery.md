<thinking>
## Analyse du Concept
- Concept : Service Discovery
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - La decouverte de services est fondamentale dans les architectures distribuees et cloud-native. L'exercice combine networking, DNS, health checking et load balancing.

## Combo Base + Bonus
- Exercice de base : Implementation d'un systeme de service discovery avec enregistrement, heartbeat et resolution DNS
- Bonus : Implementation d'un load balancer intelligent avec circuit breaker et health-aware routing
- Palier bonus : AVANCE (complexite distribuee + consistance)
- Progression logique ? OUI - Base = registry statique, Bonus = routing dynamique intelligent

## Prerequis & Difficulte
- Prerequis reels : Async Rust, networking basics, HashMap/BTreeMap, Result/Option
- Difficulte estimee : 7/10 (base), 9/10 (bonus)
- Coherent avec phase 5 ? OUI

## Aspect Fun/Culture
- Contexte choisi : Reference a "The Matrix" - Les services comme agents dans la Matrix
- MEME mnemonique : "I know Kung Fu... and where to find it" (service location)
- Pourquoi c'est fun : Les services se trouvent comme Neo trouve ses allies

## Scenarios d'Echec (5 mutants concrets)
1. Mutant A (Boundary) : TTL negatif ou zero accepte sans erreur
2. Mutant B (Safety) : Race condition lors de l'enregistrement concurrent
3. Mutant C (Logic) : Services expires non supprimes du registry
4. Mutant D (Edge) : Health check timeout non gere (hang infini)
5. Mutant E (Return) : Resolution retourne un service unhealthy

## Verdict
VALIDE - Exercice de qualite industrielle couvrant les fondamentaux du service discovery
</thinking>

# Exercice 5.5.6-a : service_discovery

**Module :**
5.5.6 - Service Discovery & Registration

**Concept :**
a - Service Discovery System (DNS-SD, Health Checking, Load Balancing)

**Difficulte :**
7/10

**Type :**
code

**Tiers :**
2 - Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.1 - Types primitifs et ownership
- 2.5 - Async/await et tokio
- 4.2 - Networking basics
- 5.5.1 - Container orchestration concepts

**Domaines :**
Net, Distributed, Cloud

**Duree estimee :**
120 min

**XP Base :**
175

**Complexite :**
T2 O(log n) x S2 O(n)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.1 Obligations

**Fichier a rendre :**
```
src/lib.rs
```

**Dependances autorisees :**
- `std::collections::{HashMap, BTreeMap}`
- `std::sync::{Arc, RwLock}`
- `std::time::{Duration, Instant}`
- `tokio` (runtime async)

**Fonctions/methodes interdites :**
- Crates externes de service discovery (`consul`, `etcd`, etc.)
- `unsafe` blocks

### 1.2 Consigne

**CONTEXTE : "The Service Matrix"**

*"Dans la Matrix, chaque agent sait ou trouver les autres. Quand Morpheus a besoin de Neo, il ne cherche pas au hasard - il interroge l'Oracle. Ton systeme de Service Discovery sera cet Oracle."* - Morpheus, probablement

Dans les architectures microservices, les services doivent pouvoir se localiser dynamiquement. Un Service Discovery permet l'enregistrement, le health checking et la resolution de services.

**Ta mission :**

Implementer un systeme `ServiceRegistry` qui permet de :
1. Enregistrer des services avec leurs metadonnees
2. Maintenir un heartbeat pour detecter les services morts
3. Resoudre les services par nom avec load balancing
4. Gerer les health checks et marquer les services unhealthy
5. Supporter les tags et filtres pour la resolution
6. Implementer une strategie de selection (round-robin, random, least-connections)

**Entree :**
- `service_name: String` - Nom du service
- `instance: ServiceInstance` - Instance avec adresse, port, metadata

**Sortie :**
- `ServiceRegistry` - Registry thread-safe
- `DiscoveryError` - En cas d'erreur

**Contraintes :**
- Le registry doit etre thread-safe (`Send + Sync`)
- Les services expires doivent etre automatiquement retires
- Le TTL par defaut est de 30 secondes
- Les health checks doivent etre non-bloquants

**Exemples :**

| Appel | Resultat | Explication |
|-------|----------|-------------|
| `registry.register("api", instance)` | `Ok(())` | Enregistrement reussi |
| `registry.resolve("api")` | `Ok(Some(instance))` | Resolution avec LB |
| `registry.resolve("unknown")` | `Ok(None)` | Service non trouve |
| `registry.deregister("api", "id-1")` | `Ok(())` | Desenregistrement |

### 1.2.2 Consigne Academique

Implementer un systeme de Service Discovery permettant l'enregistrement dynamique, le health checking et la resolution de services avec load balancing. Le systeme doit etre thread-safe et supporter les operations concurrentes.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

/// Etat de sante d'un service
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

/// Instance de service
#[derive(Debug, Clone)]
pub struct ServiceInstance {
    pub id: String,
    pub address: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub health: HealthStatus,
    pub weight: u32,
}

impl ServiceInstance {
    pub fn new(id: impl Into<String>, address: impl Into<String>, port: u16) -> Self;
    pub fn with_tags(self, tags: Vec<String>) -> Self;
    pub fn with_metadata(self, key: impl Into<String>, value: impl Into<String>) -> Self;
    pub fn with_weight(self, weight: u32) -> Self;
}

/// Configuration du registry
#[derive(Debug, Clone)]
pub struct RegistryConfig {
    pub default_ttl: Duration,
    pub health_check_interval: Duration,
    pub deregister_critical_after: Duration,
}

impl Default for RegistryConfig {
    fn default() -> Self {
        Self {
            default_ttl: Duration::from_secs(30),
            health_check_interval: Duration::from_secs(10),
            deregister_critical_after: Duration::from_secs(90),
        }
    }
}

/// Strategie de selection
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SelectionStrategy {
    RoundRobin,
    Random,
    WeightedRandom,
    LeastConnections,
}

/// Erreur de discovery
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DiscoveryError {
    ServiceNotFound(String),
    InstanceNotFound(String),
    InvalidConfiguration(String),
    RegistrationFailed(String),
    HealthCheckFailed(String),
}

/// Options de resolution
#[derive(Debug, Clone, Default)]
pub struct ResolveOptions {
    pub tags: Option<Vec<String>>,
    pub healthy_only: bool,
    pub strategy: Option<SelectionStrategy>,
}

impl ResolveOptions {
    pub fn new() -> Self;
    pub fn with_tags(self, tags: Vec<String>) -> Self;
    pub fn healthy_only(self) -> Self;
    pub fn with_strategy(self, strategy: SelectionStrategy) -> Self;
}

/// Service enregistre avec ses instances
#[derive(Debug, Clone)]
pub struct RegisteredService {
    pub name: String,
    pub instances: Vec<ServiceInstance>,
    pub last_update: Instant,
}

/// Registry de services
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, RegisteredService>>>,
    config: RegistryConfig,
    round_robin_counters: Arc<RwLock<HashMap<String, usize>>>,
}

impl ServiceRegistry {
    pub fn new() -> Self;
    pub fn with_config(config: RegistryConfig) -> Self;

    /// Enregistre une instance de service
    pub fn register(
        &self,
        service_name: impl Into<String>,
        instance: ServiceInstance,
    ) -> Result<(), DiscoveryError>;

    /// Desenregistre une instance
    pub fn deregister(
        &self,
        service_name: &str,
        instance_id: &str,
    ) -> Result<(), DiscoveryError>;

    /// Resout un service et retourne une instance
    pub fn resolve(&self, service_name: &str) -> Result<Option<ServiceInstance>, DiscoveryError>;

    /// Resout avec options
    pub fn resolve_with_options(
        &self,
        service_name: &str,
        options: &ResolveOptions,
    ) -> Result<Option<ServiceInstance>, DiscoveryError>;

    /// Retourne toutes les instances d'un service
    pub fn resolve_all(&self, service_name: &str) -> Result<Vec<ServiceInstance>, DiscoveryError>;

    /// Met a jour le heartbeat d'une instance
    pub fn heartbeat(
        &self,
        service_name: &str,
        instance_id: &str,
    ) -> Result<(), DiscoveryError>;

    /// Met a jour le status de sante
    pub fn update_health(
        &self,
        service_name: &str,
        instance_id: &str,
        status: HealthStatus,
    ) -> Result<(), DiscoveryError>;

    /// Supprime les services expires
    pub fn cleanup_expired(&self) -> usize;

    /// Liste tous les services enregistres
    pub fn list_services(&self) -> Vec<String>;

    /// Retourne les statistiques du registry
    pub fn stats(&self) -> RegistryStats;
}

#[derive(Debug, Clone)]
pub struct RegistryStats {
    pub total_services: usize,
    pub total_instances: usize,
    pub healthy_instances: usize,
    pub unhealthy_instances: usize,
}

impl Default for ServiceRegistry {
    fn default() -> Self {
        Self::new()
    }
}
```

---

## SECTION 2 : LE SAVIEZ-VOUS ?

### 2.1 Origine du Service Discovery

Le concept de Service Discovery est ne avec les systemes distribues dans les annees 1990. Le DNS est la premiere forme de service discovery, mais les architectures microservices modernes necessitent des solutions plus dynamiques comme Consul (2014), etcd (2013), ou Kubernetes DNS.

### 2.2 Le Pattern Service Registry

Le Service Registry est un pattern ou chaque service s'enregistre au demarrage et envoie des heartbeats reguliers. Les clients interrogent le registry pour trouver les services disponibles, permettant un decouplage total entre producteurs et consommateurs.

### 2.3 CAP Theorem et Service Discovery

Les systemes de service discovery doivent choisir entre Consistency et Availability (le P de Partition tolerance etant obligatoire). Consul privilegie la consistance (CP), tandis que Eureka privilegie la disponibilite (AP).

---

## SECTION 2.5 : DANS LA VRAIE VIE

### Metiers concernes

| Metier | Utilisation du service discovery |
|--------|-----------------------------------|
| **Platform Engineer** | Configuration Consul/etcd, integration Kubernetes |
| **SRE** | Monitoring des registries, failover, capacity planning |
| **Backend Developer** | Integration client SDK, health endpoints |
| **DevOps Engineer** | Automatisation enregistrement, scripts de deploiement |

### Cas d'usage concrets

1. **Kubernetes Services** : CoreDNS resout les services par nom dans le cluster
2. **Consul Service Mesh** : Sidecar proxies pour communication inter-services
3. **AWS Cloud Map** : Service discovery manage pour ECS et Lambda

---

## SECTION 3 : EXEMPLE D'UTILISATION

### 3.0 Session bash

```bash
$ cargo test
   Compiling service_discovery v0.1.0
    Finished test [unoptimized + debuginfo] target(s)
     Running unittests src/lib.rs

running 15 tests
test tests::test_register_service ... ok
test tests::test_deregister_service ... ok
test tests::test_resolve_service ... ok
test tests::test_resolve_all ... ok
test tests::test_round_robin ... ok
test tests::test_weighted_random ... ok
test tests::test_health_filtering ... ok
test tests::test_tag_filtering ... ok
test tests::test_heartbeat ... ok
test tests::test_cleanup_expired ... ok
test tests::test_concurrent_access ... ok
test tests::test_stats ... ok
test tests::test_service_not_found ... ok
test tests::test_instance_not_found ... ok
test tests::test_empty_registry ... ok

test result: ok. 15 passed; 0 failed
```

### 3.1 BONUS AVANCE (OPTIONNEL)

**Difficulte Bonus :**
9/10

**Recompense :**
XP x3

**Time Complexity attendue :**
O(log n) pour les operations

**Space Complexity attendue :**
O(n)

**Domaines Bonus :**
`Algo, Distributed`

#### 3.1.1 Consigne Bonus

**"The Oracle's Wisdom"**

*"L'Oracle ne se contente pas de savoir ou sont les choses. Elle sait lesquelles vont echouer."*

**Ta mission bonus :**

Implementer un **Circuit Breaker** integre au service discovery qui :
1. Track les erreurs par instance
2. Ouvre le circuit apres N erreurs consecutives
3. Permet un mode half-open pour tester la recovery
4. Integre la selection pour eviter les instances en erreur

**Entree :**
- `CircuitBreakerConfig` - Configuration (threshold, timeout, etc.)

**Sortie :**
- Load balancer avec circuit breaker integre

#### 3.1.2 Prototype Bonus

```rust
#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: u32,
    pub success_threshold: u32,
    pub timeout: Duration,
    pub half_open_max_calls: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct SmartLoadBalancer {
    registry: Arc<ServiceRegistry>,
    circuits: Arc<RwLock<HashMap<String, CircuitState>>>,
    config: CircuitBreakerConfig,
}

impl SmartLoadBalancer {
    pub fn new(registry: Arc<ServiceRegistry>, config: CircuitBreakerConfig) -> Self;

    pub fn select(&self, service_name: &str) -> Result<Option<ServiceInstance>, DiscoveryError>;

    pub fn report_success(&self, service_name: &str, instance_id: &str);

    pub fn report_failure(&self, service_name: &str, instance_id: &str);

    pub fn get_circuit_state(&self, instance_id: &str) -> CircuitState;
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `register_service` | Instance valide | `Ok(())` | 5 | Basic |
| `register_duplicate` | Meme ID | Update instance | 5 | Edge |
| `deregister_existing` | ID existant | `Ok(())` | 5 | Basic |
| `deregister_unknown` | ID inconnu | `Err(InstanceNotFound)` | 5 | Edge |
| `resolve_existing` | Service existant | `Ok(Some(instance))` | 10 | Core |
| `resolve_unknown` | Service inconnu | `Ok(None)` | 5 | Edge |
| `resolve_all` | Multiple instances | `Vec<ServiceInstance>` | 10 | Core |
| `round_robin` | 3 instances, 6 calls | Chaque instance 2 fois | 10 | Core |
| `weighted_selection` | Poids 1:2:1 | Distribution proportionnelle | 10 | Core |
| `health_filtering` | Mix healthy/unhealthy | Seulement healthy | 10 | Core |
| `tag_filtering` | Tags specifiques | Instances matchantes | 5 | Core |
| `heartbeat_update` | Instance existante | `last_update` mis a jour | 5 | Core |
| `cleanup_expired` | Instances expirees | Suppression automatique | 10 | Core |
| `concurrent_register` | 100 threads | Pas de race condition | 10 | Safety |
| `stats_accuracy` | Operations diverses | Stats correctes | 5 | Core |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    #[test]
    fn test_register_service() {
        let registry = ServiceRegistry::new();
        let instance = ServiceInstance::new("api-1", "192.168.1.1", 8080);

        assert!(registry.register("api", instance).is_ok());
        assert_eq!(registry.list_services(), vec!["api"]);
    }

    #[test]
    fn test_deregister_service() {
        let registry = ServiceRegistry::new();
        let instance = ServiceInstance::new("api-1", "192.168.1.1", 8080);

        registry.register("api", instance).unwrap();
        assert!(registry.deregister("api", "api-1").is_ok());
        assert!(registry.resolve("api").unwrap().is_none());
    }

    #[test]
    fn test_resolve_service() {
        let registry = ServiceRegistry::new();
        let instance = ServiceInstance::new("api-1", "192.168.1.1", 8080);

        registry.register("api", instance.clone()).unwrap();

        let resolved = registry.resolve("api").unwrap();
        assert!(resolved.is_some());
        assert_eq!(resolved.unwrap().id, "api-1");
    }

    #[test]
    fn test_resolve_all() {
        let registry = ServiceRegistry::new();

        registry.register("api", ServiceInstance::new("api-1", "192.168.1.1", 8080)).unwrap();
        registry.register("api", ServiceInstance::new("api-2", "192.168.1.2", 8080)).unwrap();

        let all = registry.resolve_all("api").unwrap();
        assert_eq!(all.len(), 2);
    }

    #[test]
    fn test_round_robin() {
        let registry = ServiceRegistry::new();

        registry.register("api", ServiceInstance::new("api-1", "192.168.1.1", 8080)).unwrap();
        registry.register("api", ServiceInstance::new("api-2", "192.168.1.2", 8080)).unwrap();
        registry.register("api", ServiceInstance::new("api-3", "192.168.1.3", 8080)).unwrap();

        let options = ResolveOptions::new().with_strategy(SelectionStrategy::RoundRobin);

        let mut counts: HashMap<String, usize> = HashMap::new();
        for _ in 0..6 {
            if let Some(instance) = registry.resolve_with_options("api", &options).unwrap() {
                *counts.entry(instance.id).or_insert(0) += 1;
            }
        }

        assert_eq!(counts.get("api-1"), Some(&2));
        assert_eq!(counts.get("api-2"), Some(&2));
        assert_eq!(counts.get("api-3"), Some(&2));
    }

    #[test]
    fn test_health_filtering() {
        let registry = ServiceRegistry::new();

        let healthy = ServiceInstance::new("api-1", "192.168.1.1", 8080);
        let mut unhealthy = ServiceInstance::new("api-2", "192.168.1.2", 8080);
        unhealthy.health = HealthStatus::Unhealthy;

        registry.register("api", healthy).unwrap();
        registry.register("api", unhealthy).unwrap();

        let options = ResolveOptions::new().healthy_only();
        let resolved = registry.resolve_with_options("api", &options).unwrap();

        assert!(resolved.is_some());
        assert_eq!(resolved.unwrap().id, "api-1");
    }

    #[test]
    fn test_tag_filtering() {
        let registry = ServiceRegistry::new();

        let v1 = ServiceInstance::new("api-1", "192.168.1.1", 8080)
            .with_tags(vec!["v1".to_string(), "production".to_string()]);
        let v2 = ServiceInstance::new("api-2", "192.168.1.2", 8080)
            .with_tags(vec!["v2".to_string(), "production".to_string()]);

        registry.register("api", v1).unwrap();
        registry.register("api", v2).unwrap();

        let options = ResolveOptions::new().with_tags(vec!["v1".to_string()]);
        let resolved = registry.resolve_with_options("api", &options).unwrap();

        assert!(resolved.is_some());
        assert_eq!(resolved.unwrap().id, "api-1");
    }

    #[test]
    fn test_heartbeat() {
        let registry = ServiceRegistry::new();
        let instance = ServiceInstance::new("api-1", "192.168.1.1", 8080);

        registry.register("api", instance).unwrap();
        thread::sleep(Duration::from_millis(10));

        assert!(registry.heartbeat("api", "api-1").is_ok());
    }

    #[test]
    fn test_stats() {
        let registry = ServiceRegistry::new();

        registry.register("api", ServiceInstance::new("api-1", "192.168.1.1", 8080)).unwrap();
        registry.register("api", ServiceInstance::new("api-2", "192.168.1.2", 8080)).unwrap();
        registry.register("db", ServiceInstance::new("db-1", "192.168.1.10", 5432)).unwrap();

        let stats = registry.stats();
        assert_eq!(stats.total_services, 2);
        assert_eq!(stats.total_instances, 3);
        assert_eq!(stats.healthy_instances, 3);
    }

    #[test]
    fn test_concurrent_access() {
        let registry = Arc::new(ServiceRegistry::new());
        let mut handles = vec![];

        for i in 0..100 {
            let reg = Arc::clone(&registry);
            handles.push(thread::spawn(move || {
                let instance = ServiceInstance::new(
                    format!("api-{}", i),
                    format!("192.168.1.{}", i % 256),
                    8080,
                );
                reg.register("api", instance).unwrap();
            }));
        }

        for handle in handles {
            handle.join().unwrap();
        }

        assert_eq!(registry.resolve_all("api").unwrap().len(), 100);
    }

    #[test]
    fn test_service_not_found() {
        let registry = ServiceRegistry::new();
        assert!(registry.resolve("unknown").unwrap().is_none());
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct ServiceInstance {
    pub id: String,
    pub address: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub health: HealthStatus,
    pub weight: u32,
    pub last_heartbeat: Instant,
}

impl ServiceInstance {
    pub fn new(id: impl Into<String>, address: impl Into<String>, port: u16) -> Self {
        Self {
            id: id.into(),
            address: address.into(),
            port,
            tags: Vec::new(),
            metadata: HashMap::new(),
            health: HealthStatus::Healthy,
            weight: 1,
            last_heartbeat: Instant::now(),
        }
    }

    pub fn with_tags(mut self, tags: Vec<String>) -> Self {
        self.tags = tags;
        self
    }

    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }

    pub fn with_weight(mut self, weight: u32) -> Self {
        self.weight = weight;
        self
    }
}

#[derive(Debug, Clone)]
pub struct RegistryConfig {
    pub default_ttl: Duration,
    pub health_check_interval: Duration,
    pub deregister_critical_after: Duration,
}

impl Default for RegistryConfig {
    fn default() -> Self {
        Self {
            default_ttl: Duration::from_secs(30),
            health_check_interval: Duration::from_secs(10),
            deregister_critical_after: Duration::from_secs(90),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SelectionStrategy {
    RoundRobin,
    Random,
    WeightedRandom,
    LeastConnections,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DiscoveryError {
    ServiceNotFound(String),
    InstanceNotFound(String),
    InvalidConfiguration(String),
    RegistrationFailed(String),
    HealthCheckFailed(String),
}

#[derive(Debug, Clone, Default)]
pub struct ResolveOptions {
    pub tags: Option<Vec<String>>,
    pub healthy_only: bool,
    pub strategy: Option<SelectionStrategy>,
}

impl ResolveOptions {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_tags(mut self, tags: Vec<String>) -> Self {
        self.tags = Some(tags);
        self
    }

    pub fn healthy_only(mut self) -> Self {
        self.healthy_only = true;
        self
    }

    pub fn with_strategy(mut self, strategy: SelectionStrategy) -> Self {
        self.strategy = Some(strategy);
        self
    }
}

#[derive(Debug, Clone)]
pub struct RegisteredService {
    pub name: String,
    pub instances: Vec<ServiceInstance>,
    pub last_update: Instant,
}

#[derive(Debug, Clone)]
pub struct RegistryStats {
    pub total_services: usize,
    pub total_instances: usize,
    pub healthy_instances: usize,
    pub unhealthy_instances: usize,
}

pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, RegisteredService>>>,
    config: RegistryConfig,
    round_robin_counters: Arc<RwLock<HashMap<String, usize>>>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self::with_config(RegistryConfig::default())
    }

    pub fn with_config(config: RegistryConfig) -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
            config,
            round_robin_counters: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn register(
        &self,
        service_name: impl Into<String>,
        instance: ServiceInstance,
    ) -> Result<(), DiscoveryError> {
        let name = service_name.into();
        let mut services = self.services.write().unwrap();

        let service = services.entry(name.clone()).or_insert_with(|| RegisteredService {
            name: name.clone(),
            instances: Vec::new(),
            last_update: Instant::now(),
        });

        if let Some(existing) = service.instances.iter_mut().find(|i| i.id == instance.id) {
            *existing = instance;
        } else {
            service.instances.push(instance);
        }

        service.last_update = Instant::now();
        Ok(())
    }

    pub fn deregister(
        &self,
        service_name: &str,
        instance_id: &str,
    ) -> Result<(), DiscoveryError> {
        let mut services = self.services.write().unwrap();

        if let Some(service) = services.get_mut(service_name) {
            let initial_len = service.instances.len();
            service.instances.retain(|i| i.id != instance_id);

            if service.instances.len() == initial_len {
                return Err(DiscoveryError::InstanceNotFound(instance_id.to_string()));
            }

            if service.instances.is_empty() {
                services.remove(service_name);
            }

            Ok(())
        } else {
            Err(DiscoveryError::ServiceNotFound(service_name.to_string()))
        }
    }

    pub fn resolve(&self, service_name: &str) -> Result<Option<ServiceInstance>, DiscoveryError> {
        self.resolve_with_options(service_name, &ResolveOptions::default())
    }

    pub fn resolve_with_options(
        &self,
        service_name: &str,
        options: &ResolveOptions,
    ) -> Result<Option<ServiceInstance>, DiscoveryError> {
        let services = self.services.read().unwrap();

        let service = match services.get(service_name) {
            Some(s) => s,
            None => return Ok(None),
        };

        let mut candidates: Vec<_> = service.instances.iter()
            .filter(|i| {
                if options.healthy_only && i.health != HealthStatus::Healthy {
                    return false;
                }
                if let Some(ref tags) = options.tags {
                    if !tags.iter().all(|t| i.tags.contains(t)) {
                        return false;
                    }
                }
                true
            })
            .cloned()
            .collect();

        if candidates.is_empty() {
            return Ok(None);
        }

        let strategy = options.strategy.unwrap_or(SelectionStrategy::RoundRobin);

        let selected = match strategy {
            SelectionStrategy::RoundRobin => {
                drop(services);
                let mut counters = self.round_robin_counters.write().unwrap();
                let counter = counters.entry(service_name.to_string()).or_insert(0);
                let idx = *counter % candidates.len();
                *counter = (*counter + 1) % candidates.len();
                candidates.remove(idx)
            }
            SelectionStrategy::Random => {
                use std::collections::hash_map::DefaultHasher;
                use std::hash::{Hash, Hasher};

                let mut hasher = DefaultHasher::new();
                Instant::now().hash(&mut hasher);
                let idx = (hasher.finish() as usize) % candidates.len();
                candidates.remove(idx)
            }
            SelectionStrategy::WeightedRandom => {
                let total_weight: u32 = candidates.iter().map(|c| c.weight).sum();
                let mut rng_val = (Instant::now().elapsed().as_nanos() as u32) % total_weight;

                let mut selected_idx = 0;
                for (idx, candidate) in candidates.iter().enumerate() {
                    if rng_val < candidate.weight {
                        selected_idx = idx;
                        break;
                    }
                    rng_val -= candidate.weight;
                }
                candidates.remove(selected_idx)
            }
            SelectionStrategy::LeastConnections => {
                candidates.remove(0)
            }
        };

        Ok(Some(selected))
    }

    pub fn resolve_all(&self, service_name: &str) -> Result<Vec<ServiceInstance>, DiscoveryError> {
        let services = self.services.read().unwrap();

        match services.get(service_name) {
            Some(service) => Ok(service.instances.clone()),
            None => Ok(Vec::new()),
        }
    }

    pub fn heartbeat(
        &self,
        service_name: &str,
        instance_id: &str,
    ) -> Result<(), DiscoveryError> {
        let mut services = self.services.write().unwrap();

        if let Some(service) = services.get_mut(service_name) {
            if let Some(instance) = service.instances.iter_mut().find(|i| i.id == instance_id) {
                instance.last_heartbeat = Instant::now();
                return Ok(());
            }
            return Err(DiscoveryError::InstanceNotFound(instance_id.to_string()));
        }

        Err(DiscoveryError::ServiceNotFound(service_name.to_string()))
    }

    pub fn update_health(
        &self,
        service_name: &str,
        instance_id: &str,
        status: HealthStatus,
    ) -> Result<(), DiscoveryError> {
        let mut services = self.services.write().unwrap();

        if let Some(service) = services.get_mut(service_name) {
            if let Some(instance) = service.instances.iter_mut().find(|i| i.id == instance_id) {
                instance.health = status;
                return Ok(());
            }
            return Err(DiscoveryError::InstanceNotFound(instance_id.to_string()));
        }

        Err(DiscoveryError::ServiceNotFound(service_name.to_string()))
    }

    pub fn cleanup_expired(&self) -> usize {
        let mut services = self.services.write().unwrap();
        let ttl = self.config.default_ttl;
        let mut removed = 0;

        for service in services.values_mut() {
            let initial_len = service.instances.len();
            service.instances.retain(|i| i.last_heartbeat.elapsed() < ttl);
            removed += initial_len - service.instances.len();
        }

        services.retain(|_, s| !s.instances.is_empty());
        removed
    }

    pub fn list_services(&self) -> Vec<String> {
        let services = self.services.read().unwrap();
        services.keys().cloned().collect()
    }

    pub fn stats(&self) -> RegistryStats {
        let services = self.services.read().unwrap();

        let total_instances: usize = services.values().map(|s| s.instances.len()).sum();
        let healthy_instances: usize = services.values()
            .flat_map(|s| s.instances.iter())
            .filter(|i| i.health == HealthStatus::Healthy)
            .count();

        RegistryStats {
            total_services: services.len(),
            total_instances,
            healthy_instances,
            unhealthy_instances: total_instances - healthy_instances,
        }
    }
}

impl Default for ServiceRegistry {
    fn default() -> Self {
        Self::new()
    }
}
```

### 4.9 spec.json

```json
{
  "name": "service_discovery",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tier_info": "Integration de concepts - Service Discovery",
  "tags": ["devops", "cloud", "service-discovery", "distributed", "phase5"],
  "passing_score": 70,

  "function": {
    "name": "ServiceRegistry",
    "prototype": "impl ServiceRegistry",
    "return_type": "struct",
    "parameters": [
      {"name": "service_name", "type": "String"},
      {"name": "instance", "type": "ServiceInstance"}
    ]
  },

  "driver": {
    "edge_cases": [
      {
        "name": "empty_registry",
        "input": "resolve on empty",
        "expected": "Ok(None)",
        "is_trap": false
      },
      {
        "name": "duplicate_registration",
        "input": "same instance_id twice",
        "expected": "update existing",
        "is_trap": true,
        "trap_explanation": "Doit mettre a jour, pas dupliquer"
      },
      {
        "name": "expired_cleanup",
        "input": "instances with old heartbeat",
        "expected": "removed by cleanup",
        "is_trap": true,
        "trap_explanation": "Instances expirees doivent etre supprimees"
      }
    ],

    "fuzzing": {
      "enabled": true,
      "iterations": 500,
      "generators": [
        {"type": "random_string", "param": "service_name"},
        {"type": "random_port", "param": "port"}
      ]
    }
  },

  "norm": {
    "allowed_functions": ["std::collections", "std::sync", "std::time"],
    "forbidden_functions": ["unsafe"],
    "forbidden_crates": ["consul", "etcd-client"],
    "check_security": true,
    "check_memory": true,
    "blocking": true
  }
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A (Boundary) : Accepte TTL zero ou negatif */
impl RegistryConfig {
    pub fn with_ttl(mut self, ttl: Duration) -> Self {
        // MUTANT: Pas de validation du TTL
        self.default_ttl = ttl;
        self
    }
}
// Pourquoi c'est faux : TTL zero cause des expirations immediates

/* Mutant B (Safety) : Race condition dans register */
pub fn register(&self, service_name: impl Into<String>, instance: ServiceInstance) -> Result<(), DiscoveryError> {
    let name = service_name.into();
    // MUTANT: Lecture puis ecriture separees
    let has_service = self.services.read().unwrap().contains_key(&name);
    if !has_service {
        let mut services = self.services.write().unwrap();
        services.insert(name.clone(), RegisteredService { ... });
    }
    Ok(())
}
// Pourquoi c'est faux : Race condition entre read et write

/* Mutant C (Logic) : Cleanup ne supprime pas les expires */
pub fn cleanup_expired(&self) -> usize {
    let services = self.services.read().unwrap();  // MUTANT: read au lieu de write
    // Ne peut pas modifier, donc aucune suppression
    0
}
// Pourquoi c'est faux : Les services expires restent dans le registry

/* Mutant D (Edge) : Round robin ne wrap pas */
SelectionStrategy::RoundRobin => {
    let mut counters = self.round_robin_counters.write().unwrap();
    let counter = counters.entry(service_name.to_string()).or_insert(0);
    let idx = *counter % candidates.len();
    *counter += 1;  // MUTANT: Pas de modulo, overflow possible
    candidates.remove(idx)
}
// Pourquoi c'est faux : Counter overflow apres beaucoup de requetes

/* Mutant E (Return) : Retourne un service unhealthy */
pub fn resolve_with_options(&self, service_name: &str, options: &ResolveOptions) -> Result<Option<ServiceInstance>, DiscoveryError> {
    // MUTANT: Ignore healthy_only option
    let candidates: Vec<_> = service.instances.iter().cloned().collect();
    // ...
}
// Pourquoi c'est faux : Retourne des instances unhealthy meme si healthy_only=true
```

---

## SECTION 5 : COMPRENDRE

### 5.1 Ce que cet exercice enseigne

1. **Thread-safety** : RwLock pour acces concurrents read-heavy
2. **Patterns distribues** : Service Registry, Health Checking
3. **Load Balancing** : Round-robin, weighted selection
4. **Gestion du temps** : TTL, expiration, heartbeats
5. **Filtrage** : Tags, health status, metadata

### 5.2 LDA - Traduction Litterale

```
FONCTION resolve_with_options QUI RETOURNE Option<ServiceInstance>
DEBUT FONCTION
    ACQUERIR verrou lecture sur services

    SI service_name n'existe pas DANS services ALORS
        RETOURNER Ok(None)
    FIN SI

    FILTRER les instances selon:
        - healthy_only : exclure les unhealthy
        - tags : matcher tous les tags requis

    SI aucun candidat ALORS
        RETOURNER Ok(None)
    FIN SI

    SELON strategie:
        RoundRobin: utiliser compteur circulaire
        Random: selection aleatoire
        WeightedRandom: selection ponderee

    RETOURNER Ok(Some(instance_selectionnee))
FIN FONCTION
```

### 5.3 Visualisation ASCII

```
                    SERVICE REGISTRY ARCHITECTURE

    ┌─────────────────────────────────────────────────────────┐
    │                    SERVICE REGISTRY                      │
    │  ┌─────────────────────────────────────────────────┐    │
    │  │  HashMap<ServiceName, RegisteredService>         │    │
    │  │                                                  │    │
    │  │  "api" ──► RegisteredService                     │    │
    │  │            ├─ instances: [Instance1, Instance2]  │    │
    │  │            └─ last_update: Instant               │    │
    │  │                                                  │    │
    │  │  "db" ───► RegisteredService                     │    │
    │  │            ├─ instances: [Instance3]             │    │
    │  │            └─ last_update: Instant               │    │
    │  └─────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
    ┌────────┐          ┌────────┐          ┌────────┐
    │Register│          │Resolve │          │Heartbeat│
    │        │          │        │          │        │
    │ Write  │          │ Read   │          │ Write  │
    │ Lock   │          │ Lock   │          │ Lock   │
    └────────┘          └────────┘          └────────┘
```

### 5.4 Les pieges en detail

| Piege | Description | Comment l'eviter |
|-------|-------------|------------------|
| **Race condition** | Read puis Write separes | Utiliser write lock unique |
| **Counter overflow** | Round-robin sans modulo | Modulo sur le counter |
| **Stale data** | Services expires non nettoyes | Cleanup periodique |
| **Deadlock** | Lock order inconsistant | Toujours meme ordre |
| **Memory leak** | Services vides non supprimes | Nettoyer les services vides |

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Race condition register | Doublons ou pertes | Single write lock |
| 2 | TTL zero | Expiration immediate | Valider TTL > 0 |
| 3 | Counter overflow | Panic ou comportement erratique | Modulo wrap |
| 4 | Healthy filter ignore | Unhealthy retournes | Verifier le filtre |
| 5 | Services vides | Memory leak | Cleanup apres deregister |

---

## SECTION 7 : QCM

### Question 1
**Quel pattern permet la decouverte dynamique de services ?**

A) Factory Pattern
B) Service Locator Pattern
C) Observer Pattern
D) Singleton Pattern

**Reponse : B**

*Explication : Le Service Locator (ou Service Registry) maintient un registre des services disponibles et permet leur decouverte dynamique.*

---

### Question 2
**Pourquoi utiliser RwLock plutot que Mutex pour un Service Registry ?**

A) RwLock est plus rapide
B) RwLock permet plusieurs lecteurs simultanement
C) RwLock est plus simple
D) Mutex ne supporte pas les HashMap

**Reponse : B**

*Explication : Un registry est read-heavy (beaucoup de resolutions, peu d'enregistrements). RwLock optimise ce cas avec plusieurs lecteurs concurrents.*

---

### Question 3
**Quel probleme resout le heartbeat dans un Service Registry ?**

A) Authentification des services
B) Detection des services morts
C) Chiffrement des communications
D) Compression des donnees

**Reponse : B**

*Explication : Le heartbeat permet de detecter les services qui ne repondent plus et de les marquer comme unhealthy ou les supprimer.*

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | service_discovery |
| **Module** | 5.5.6 - Service Discovery & Registration |
| **Difficulte** | 7/10 |
| **Temps estime** | 120 min |
| **XP** | 175 (base) + bonus x3 |
| **Concepts cles** | Registry, Health Checking, Load Balancing |
| **Piege principal** | Race conditions sur enregistrement concurrent |
| **Prerequis valide** | Async Rust, RwLock, HashMap |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "engine_version": "v22.1",
    "exercise_slug": "5.5.6-a-service-discovery",
    "generated_at": "2024-01-15T10:00:00Z",

    "metadata": {
      "exercise_id": "5.5.6-a",
      "exercise_name": "service_discovery",
      "module": "5.5.6",
      "module_name": "Service Discovery & Registration",
      "concept": "a",
      "concept_name": "Service Discovery System",
      "type": "code",
      "tier": 2,
      "tier_info": "Integration de concepts",
      "phase": 5,
      "difficulty": 7,
      "language": "rust",
      "language_version": "2024",
      "duration_minutes": 120,
      "xp_base": 175,
      "xp_bonus_multiplier": 3
    },

    "files": {
      "spec.json": "/* Section 4.9 */",
      "references/ref_solution.rs": "/* Section 4.3 */",
      "mutants/mutant_a_boundary.rs": "/* Section 4.10 */",
      "mutants/mutant_b_safety.rs": "/* Section 4.10 */",
      "mutants/mutant_c_logic.rs": "/* Section 4.10 */",
      "mutants/mutant_d_edge.rs": "/* Section 4.10 */",
      "mutants/mutant_e_return.rs": "/* Section 4.10 */",
      "tests/lib_test.rs": "/* Section 4.2 */"
    }
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 96/100*
