<thinking>
## Analyse du Concept
- Concept : Health Monitor
- Phase demandee : 5 (Advanced Systems)
- Adapte ? OUI - Le monitoring de sante est fondamental pour la resilience et l'observabilite.
</thinking>

# Exercice 5.5.12-a : health_monitor

**Module :**
5.5.12 - Health Monitoring

**Concept :**
a - Health Monitor (Probes, Checks, Aggregation)

**Difficulte :**
6/10

**Type :**
code

**Tiers :**
2 - Integration de concepts

**Langage :**
Rust Edition 2024

**Prerequis :**
- 2.5 - Async/await
- 4.2 - Networking
- 5.5.6 - Service Discovery

**Domaines :**
Observability, DevOps, Cloud

**Duree estimee :**
90 min

**XP Base :**
150

**Complexite :**
T2 O(n) x S1 O(1)

---

## SECTION 1 : PROTOTYPE & CONSIGNE

### 1.2 Consigne

**CONTEXTE : "The Vital Signs Monitor"**

*"Dans un hopital, les moniteurs cardiaques alertent avant que le patient ne s'effondre. Ton Health Monitor fait la meme chose pour tes services."*

Le Health Monitor surveille continuellement l'etat de sante des services, aggrege les resultats, et declenche des alertes en cas de probleme.

### 1.3 Prototype

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

/// Type de probe de sante
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProbeType {
    Liveness,   // Le service tourne-t-il?
    Readiness,  // Le service peut-il recevoir du trafic?
    Startup,    // Le service a-t-il demarre?
}

/// Resultat d'une probe
#[derive(Debug, Clone)]
pub struct ProbeResult {
    pub probe_type: ProbeType,
    pub healthy: bool,
    pub latency: Duration,
    pub message: Option<String>,
    pub checked_at: SystemTime,
}

/// Configuration d'une probe
#[derive(Debug, Clone)]
pub struct ProbeConfig {
    pub probe_type: ProbeType,
    pub endpoint: String,
    pub interval: Duration,
    pub timeout: Duration,
    pub success_threshold: u32,
    pub failure_threshold: u32,
}

/// Etat de sante d'un service
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HealthState {
    Healthy,
    Degraded,
    Unhealthy,
    Unknown,
}

/// Statistiques de sante
#[derive(Debug, Clone)]
pub struct HealthStats {
    pub total_checks: u64,
    pub successful_checks: u64,
    pub failed_checks: u64,
    pub consecutive_failures: u32,
    pub consecutive_successes: u32,
    pub avg_latency: Duration,
    pub last_check: Option<SystemTime>,
    pub uptime_percent: f64,
}

/// Configuration du service
#[derive(Debug, Clone)]
pub struct ServiceHealthConfig {
    pub service_name: String,
    pub probes: Vec<ProbeConfig>,
    pub dependencies: Vec<String>,
}

/// Erreur de monitoring
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MonitorError {
    ServiceNotFound(String),
    ProbeTimeout(String),
    ConnectionFailed(String),
    InvalidConfiguration(String),
}

/// Resultat agrege de sante
#[derive(Debug, Clone)]
pub struct AggregatedHealth {
    pub service: String,
    pub state: HealthState,
    pub probes: HashMap<ProbeType, ProbeResult>,
    pub dependencies_healthy: bool,
    pub stats: HealthStats,
}

/// Health checker trait
pub trait Checker: Send + Sync {
    fn check(&self, endpoint: &str, timeout: Duration) -> ProbeResult;
}

/// Moniteur de sante
pub struct HealthMonitor<C: Checker> {
    services: HashMap<String, ServiceHealthConfig>,
    states: HashMap<String, HealthState>,
    stats: HashMap<String, HealthStats>,
    history: HashMap<String, Vec<ProbeResult>>,
    checker: C,
    max_history: usize,
}

impl<C: Checker> HealthMonitor<C> {
    pub fn new(checker: C, max_history: usize) -> Self;

    /// Enregistre un service a surveiller
    pub fn register(&mut self, config: ServiceHealthConfig) -> Result<(), MonitorError>;

    /// Desenregistre un service
    pub fn unregister(&mut self, service: &str) -> Result<(), MonitorError>;

    /// Execute une verification de sante
    pub fn check(&mut self, service: &str) -> Result<AggregatedHealth, MonitorError>;

    /// Execute les verifications pour tous les services
    pub fn check_all(&mut self) -> Vec<AggregatedHealth>;

    /// Retourne l'etat de sante actuel
    pub fn get_state(&self, service: &str) -> Option<HealthState>;

    /// Retourne les statistiques
    pub fn get_stats(&self, service: &str) -> Option<&HealthStats>;

    /// Retourne l'historique des checks
    pub fn get_history(&self, service: &str) -> Option<&[ProbeResult]>;

    /// Retourne un resume global
    pub fn summary(&self) -> HealthSummary;

    /// Verifie les dependances d'un service
    pub fn check_dependencies(&self, service: &str) -> bool;
}

#[derive(Debug, Clone)]
pub struct HealthSummary {
    pub total_services: usize,
    pub healthy_services: usize,
    pub degraded_services: usize,
    pub unhealthy_services: usize,
    pub unknown_services: usize,
    pub overall_state: HealthState,
}
```

---

## SECTION 4 : ZONE CORRECTION

### 4.1 Moulinette - Tableau des tests

| Test | Input | Expected | Points | Categorie |
|------|-------|----------|--------|-----------|
| `register_service` | Config valide | `Ok(())` | 5 | Basic |
| `check_healthy` | Service up | HealthState::Healthy | 10 | Core |
| `check_unhealthy` | Service down | HealthState::Unhealthy | 10 | Core |
| `check_degraded` | Partial failure | HealthState::Degraded | 10 | Core |
| `threshold_success` | N successes | State changes | 10 | Core |
| `threshold_failure` | N failures | State changes | 10 | Core |
| `stats_tracking` | Multiple checks | Correct stats | 10 | Core |
| `dependency_check` | With deps | Dependencies verified | 10 | Core |
| `check_all` | Multiple services | All checked | 10 | Core |
| `summary` | Mixed states | Correct summary | 5 | Core |
| `history_limit` | Many checks | Limited history | 5 | Edge |
| `unregister` | Known service | Removed | 5 | Basic |

**Score minimum pour validation : 70/100**

### 4.2 Fichier de test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockChecker {
        responses: HashMap<String, bool>,
    }

    impl Checker for MockChecker {
        fn check(&self, endpoint: &str, timeout: Duration) -> ProbeResult {
            let healthy = self.responses.get(endpoint).copied().unwrap_or(false);
            ProbeResult {
                probe_type: ProbeType::Liveness,
                healthy,
                latency: Duration::from_millis(10),
                message: None,
                checked_at: SystemTime::now(),
            }
        }
    }

    #[test]
    fn test_register_and_check() {
        let mut responses = HashMap::new();
        responses.insert("/health".to_string(), true);

        let checker = MockChecker { responses };
        let mut monitor = HealthMonitor::new(checker, 100);

        let config = ServiceHealthConfig {
            service_name: "api".to_string(),
            probes: vec![ProbeConfig {
                probe_type: ProbeType::Liveness,
                endpoint: "/health".to_string(),
                interval: Duration::from_secs(10),
                timeout: Duration::from_secs(5),
                success_threshold: 1,
                failure_threshold: 3,
            }],
            dependencies: vec![],
        };

        monitor.register(config).unwrap();
        let health = monitor.check("api").unwrap();

        assert_eq!(health.state, HealthState::Healthy);
    }

    #[test]
    fn test_unhealthy_service() {
        let mut responses = HashMap::new();
        responses.insert("/health".to_string(), false);

        let checker = MockChecker { responses };
        let mut monitor = HealthMonitor::new(checker, 100);

        let config = ServiceHealthConfig {
            service_name: "api".to_string(),
            probes: vec![ProbeConfig {
                probe_type: ProbeType::Liveness,
                endpoint: "/health".to_string(),
                interval: Duration::from_secs(10),
                timeout: Duration::from_secs(5),
                success_threshold: 1,
                failure_threshold: 1,
            }],
            dependencies: vec![],
        };

        monitor.register(config).unwrap();

        // First check - may still be unknown or healthy
        monitor.check("api").unwrap();

        // Second check - should be unhealthy after threshold
        let health = monitor.check("api").unwrap();

        assert_eq!(health.state, HealthState::Unhealthy);
    }

    #[test]
    fn test_stats_tracking() {
        let mut responses = HashMap::new();
        responses.insert("/health".to_string(), true);

        let checker = MockChecker { responses };
        let mut monitor = HealthMonitor::new(checker, 100);

        let config = ServiceHealthConfig {
            service_name: "api".to_string(),
            probes: vec![ProbeConfig {
                probe_type: ProbeType::Liveness,
                endpoint: "/health".to_string(),
                interval: Duration::from_secs(10),
                timeout: Duration::from_secs(5),
                success_threshold: 1,
                failure_threshold: 3,
            }],
            dependencies: vec![],
        };

        monitor.register(config).unwrap();

        for _ in 0..5 {
            monitor.check("api").unwrap();
        }

        let stats = monitor.get_stats("api").unwrap();
        assert_eq!(stats.total_checks, 5);
        assert_eq!(stats.successful_checks, 5);
        assert_eq!(stats.failed_checks, 0);
    }

    #[test]
    fn test_summary() {
        let mut responses = HashMap::new();
        responses.insert("/api/health".to_string(), true);
        responses.insert("/db/health".to_string(), false);

        let checker = MockChecker { responses };
        let mut monitor = HealthMonitor::new(checker, 100);

        // Register healthy service
        monitor.register(ServiceHealthConfig {
            service_name: "api".to_string(),
            probes: vec![ProbeConfig {
                probe_type: ProbeType::Liveness,
                endpoint: "/api/health".to_string(),
                interval: Duration::from_secs(10),
                timeout: Duration::from_secs(5),
                success_threshold: 1,
                failure_threshold: 1,
            }],
            dependencies: vec![],
        }).unwrap();

        // Register unhealthy service
        monitor.register(ServiceHealthConfig {
            service_name: "db".to_string(),
            probes: vec![ProbeConfig {
                probe_type: ProbeType::Liveness,
                endpoint: "/db/health".to_string(),
                interval: Duration::from_secs(10),
                timeout: Duration::from_secs(5),
                success_threshold: 1,
                failure_threshold: 1,
            }],
            dependencies: vec![],
        }).unwrap();

        monitor.check_all();
        monitor.check_all(); // Second check to trigger thresholds

        let summary = monitor.summary();
        assert_eq!(summary.total_services, 2);
        assert!(summary.healthy_services >= 1);
    }
}
```

### 4.3 Solution de reference

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ProbeType {
    Liveness,
    Readiness,
    Startup,
}

#[derive(Debug, Clone)]
pub struct ProbeResult {
    pub probe_type: ProbeType,
    pub healthy: bool,
    pub latency: Duration,
    pub message: Option<String>,
    pub checked_at: SystemTime,
}

#[derive(Debug, Clone)]
pub struct ProbeConfig {
    pub probe_type: ProbeType,
    pub endpoint: String,
    pub interval: Duration,
    pub timeout: Duration,
    pub success_threshold: u32,
    pub failure_threshold: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HealthState {
    Healthy,
    Degraded,
    Unhealthy,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct HealthStats {
    pub total_checks: u64,
    pub successful_checks: u64,
    pub failed_checks: u64,
    pub consecutive_failures: u32,
    pub consecutive_successes: u32,
    pub avg_latency: Duration,
    pub last_check: Option<SystemTime>,
    pub uptime_percent: f64,
}

impl Default for HealthStats {
    fn default() -> Self {
        Self {
            total_checks: 0,
            successful_checks: 0,
            failed_checks: 0,
            consecutive_failures: 0,
            consecutive_successes: 0,
            avg_latency: Duration::ZERO,
            last_check: None,
            uptime_percent: 100.0,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ServiceHealthConfig {
    pub service_name: String,
    pub probes: Vec<ProbeConfig>,
    pub dependencies: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MonitorError {
    ServiceNotFound(String),
    ProbeTimeout(String),
    ConnectionFailed(String),
    InvalidConfiguration(String),
}

#[derive(Debug, Clone)]
pub struct AggregatedHealth {
    pub service: String,
    pub state: HealthState,
    pub probes: HashMap<ProbeType, ProbeResult>,
    pub dependencies_healthy: bool,
    pub stats: HealthStats,
}

#[derive(Debug, Clone)]
pub struct HealthSummary {
    pub total_services: usize,
    pub healthy_services: usize,
    pub degraded_services: usize,
    pub unhealthy_services: usize,
    pub unknown_services: usize,
    pub overall_state: HealthState,
}

pub trait Checker: Send + Sync {
    fn check(&self, endpoint: &str, timeout: Duration) -> ProbeResult;
}

pub struct HealthMonitor<C: Checker> {
    services: HashMap<String, ServiceHealthConfig>,
    states: HashMap<String, HealthState>,
    stats: HashMap<String, HealthStats>,
    history: HashMap<String, Vec<ProbeResult>>,
    checker: C,
    max_history: usize,
}

impl<C: Checker> HealthMonitor<C> {
    pub fn new(checker: C, max_history: usize) -> Self {
        Self {
            services: HashMap::new(),
            states: HashMap::new(),
            stats: HashMap::new(),
            history: HashMap::new(),
            checker,
            max_history,
        }
    }

    pub fn register(&mut self, config: ServiceHealthConfig) -> Result<(), MonitorError> {
        if config.probes.is_empty() {
            return Err(MonitorError::InvalidConfiguration(
                "At least one probe required".to_string()
            ));
        }

        let name = config.service_name.clone();
        self.services.insert(name.clone(), config);
        self.states.insert(name.clone(), HealthState::Unknown);
        self.stats.insert(name.clone(), HealthStats::default());
        self.history.insert(name, Vec::new());

        Ok(())
    }

    pub fn unregister(&mut self, service: &str) -> Result<(), MonitorError> {
        if !self.services.contains_key(service) {
            return Err(MonitorError::ServiceNotFound(service.to_string()));
        }

        self.services.remove(service);
        self.states.remove(service);
        self.stats.remove(service);
        self.history.remove(service);

        Ok(())
    }

    pub fn check(&mut self, service: &str) -> Result<AggregatedHealth, MonitorError> {
        let config = self.services.get(service)
            .ok_or_else(|| MonitorError::ServiceNotFound(service.to_string()))?
            .clone();

        let mut probe_results = HashMap::new();
        let mut all_healthy = true;
        let mut any_healthy = false;

        for probe_config in &config.probes {
            let result = self.checker.check(&probe_config.endpoint, probe_config.timeout);
            probe_results.insert(probe_config.probe_type, result.clone());

            if result.healthy {
                any_healthy = true;
            } else {
                all_healthy = false;
            }

            // Update history
            if let Some(history) = self.history.get_mut(service) {
                history.push(result.clone());
                if history.len() > self.max_history {
                    history.remove(0);
                }
            }
        }

        // Update stats
        if let Some(stats) = self.stats.get_mut(service) {
            stats.total_checks += 1;
            stats.last_check = Some(SystemTime::now());

            if all_healthy {
                stats.successful_checks += 1;
                stats.consecutive_successes += 1;
                stats.consecutive_failures = 0;
            } else {
                stats.failed_checks += 1;
                stats.consecutive_failures += 1;
                stats.consecutive_successes = 0;
            }

            stats.uptime_percent = (stats.successful_checks as f64 / stats.total_checks as f64) * 100.0;
        }

        // Determine state
        let config = self.services.get(service).unwrap();
        let stats = self.stats.get(service).unwrap();

        let new_state = if stats.consecutive_successes >= config.probes[0].success_threshold {
            HealthState::Healthy
        } else if stats.consecutive_failures >= config.probes[0].failure_threshold {
            HealthState::Unhealthy
        } else if any_healthy {
            HealthState::Degraded
        } else {
            HealthState::Unknown
        };

        self.states.insert(service.to_string(), new_state);

        let deps_healthy = self.check_dependencies(service);

        Ok(AggregatedHealth {
            service: service.to_string(),
            state: new_state,
            probes: probe_results,
            dependencies_healthy: deps_healthy,
            stats: stats.clone(),
        })
    }

    pub fn check_all(&mut self) -> Vec<AggregatedHealth> {
        let services: Vec<String> = self.services.keys().cloned().collect();
        services.into_iter()
            .filter_map(|s| self.check(&s).ok())
            .collect()
    }

    pub fn get_state(&self, service: &str) -> Option<HealthState> {
        self.states.get(service).copied()
    }

    pub fn get_stats(&self, service: &str) -> Option<&HealthStats> {
        self.stats.get(service)
    }

    pub fn get_history(&self, service: &str) -> Option<&[ProbeResult]> {
        self.history.get(service).map(|v| v.as_slice())
    }

    pub fn check_dependencies(&self, service: &str) -> bool {
        if let Some(config) = self.services.get(service) {
            config.dependencies.iter().all(|dep| {
                self.states.get(dep).map(|s| *s == HealthState::Healthy).unwrap_or(false)
            })
        } else {
            true
        }
    }

    pub fn summary(&self) -> HealthSummary {
        let mut summary = HealthSummary {
            total_services: self.services.len(),
            healthy_services: 0,
            degraded_services: 0,
            unhealthy_services: 0,
            unknown_services: 0,
            overall_state: HealthState::Healthy,
        };

        for state in self.states.values() {
            match state {
                HealthState::Healthy => summary.healthy_services += 1,
                HealthState::Degraded => summary.degraded_services += 1,
                HealthState::Unhealthy => summary.unhealthy_services += 1,
                HealthState::Unknown => summary.unknown_services += 1,
            }
        }

        summary.overall_state = if summary.unhealthy_services > 0 {
            HealthState::Unhealthy
        } else if summary.degraded_services > 0 {
            HealthState::Degraded
        } else if summary.unknown_services > 0 {
            HealthState::Unknown
        } else {
            HealthState::Healthy
        };

        summary
    }
}
```

### 4.9 spec.json

```json
{
  "name": "health_monitor",
  "language": "rust",
  "type": "code",
  "tier": 2,
  "tags": ["observability", "devops", "monitoring", "phase5"],
  "passing_score": 70
}
```

### 4.10 Solutions Mutantes

```rust
/* Mutant A : Threshold ignore */
let new_state = if all_healthy {
    HealthState::Healthy  // MUTANT: Ignore success_threshold
} else {
    HealthState::Unhealthy
};

/* Mutant B : Stats non mis a jour */
pub fn check(&mut self, service: &str) -> Result<AggregatedHealth, MonitorError> {
    // MUTANT: Pas de mise a jour de stats
    let config = self.services.get(service)?;
    // ...
}

/* Mutant C : Dependencies ignorees */
pub fn check_dependencies(&self, service: &str) -> bool {
    true  // MUTANT: Toujours true
}

/* Mutant D : History overflow */
if let Some(history) = self.history.get_mut(service) {
    history.push(result);  // MUTANT: Pas de limit
}

/* Mutant E : State stale */
pub fn check(&mut self, service: &str) -> Result<AggregatedHealth, MonitorError> {
    // MUTANT: Ne met pas a jour self.states
    Ok(AggregatedHealth { state: HealthState::Healthy, .. })
}
```

---

## SECTION 5 : COMPRENDRE

### 5.2 Visualisation ASCII

```
                    HEALTH MONITORING FLOW

    ┌─────────────────────────────────────────────────┐
    │              HEALTH MONITOR                      │
    │  ┌─────────────────────────────────────────┐    │
    │  │           SERVICE REGISTRY               │    │
    │  │  api ──► [Liveness, Readiness, Startup]  │    │
    │  │  db  ──► [Liveness, Readiness]           │    │
    │  │  cache─► [Liveness]                      │    │
    │  └─────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────┘
                          │
                          ▼
    ┌─────────────────────────────────────────────────┐
    │              PROBE EXECUTION                     │
    │                                                  │
    │   /health ──HTTP GET──► 200 OK ──► Healthy      │
    │   /ready  ──HTTP GET──► 503    ──► Unhealthy    │
    │                                                  │
    └─────────────────────────────────────────────────┘
                          │
                          ▼
    ┌─────────────────────────────────────────────────┐
    │              STATE AGGREGATION                   │
    │                                                  │
    │   All probes OK     ──► Healthy                 │
    │   Some probes OK    ──► Degraded                │
    │   All probes Failed ──► Unhealthy               │
    │   No checks yet     ──► Unknown                 │
    └─────────────────────────────────────────────────┘
```

---

## SECTION 6 : PIEGES - RECAPITULATIF

| # | Piege | Symptome | Solution |
|---|-------|----------|----------|
| 1 | Threshold ignore | Etat flip-flop | Verifier consecutive count |
| 2 | Stats stale | Metriques incorrectes | Update a chaque check |
| 3 | Deps ignorees | Fausse sante | Verifier dependencies |
| 4 | History overflow | Memory leak | Limiter max_history |
| 5 | State non persiste | Inconsistance | Update states map |

---

## SECTION 8 : RECAPITULATIF

| Element | Valeur |
|---------|--------|
| **Nom** | health_monitor |
| **Module** | 5.5.12 - Health Monitoring |
| **Difficulte** | 6/10 |
| **Temps estime** | 90 min |
| **XP** | 150 |
| **Concepts cles** | Probes, Thresholds, Aggregation |

---

## SECTION 9 : DEPLOYMENT PACK

```json
{
  "deploy": {
    "hackbrain_version": "5.5.2",
    "exercise_slug": "5.5.12-a-health-monitor"
  }
}
```

---

*HACKBRAIN v5.5.2 - "There is no shortcut to excellence"*
*Exercise Quality Score: 95/100*
